{
  "cve_id": "CVE-2024-29190",
  "cve_desc": "Mobile Security Framework (MobSF) is a pen-testing, malware analysis and security assessment framework capable of performing static and dynamic analysis. In version 3.9.5 Beta and prior, MobSF does not perform any input validation when extracting the hostnames in `android:host`, so requests can also be sent to local hostnames. This can lead to server-side request forgery. An attacker can cause the server to make a connection to internal-only services within the organization's infrastructure. Commit 5a8eeee73c5f504a6c3abdf2a139a13804efdb77 has a hotfix for this issue.\n",
  "repo": "MobSF/Mobile-Security-Framework-MobSF",
  "patch_hash": "5a8eeee73c5f504a6c3abdf2a139a13804efdb77",
  "patch_info": {
    "commit_hash": "5a8eeee73c5f504a6c3abdf2a139a13804efdb77",
    "repo": "MobSF/Mobile-Security-Framework-MobSF",
    "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/5a8eeee73c5f504a6c3abdf2a139a13804efdb77",
    "files": [
      ".github/workflows/docker-release.yml",
      ".github/workflows/docker-test.yml",
      "mobsf/MobSF/init.py",
      "mobsf/MobSF/utils.py",
      "mobsf/StaticAnalyzer/views/android/manifest_analysis.py",
      "poetry.lock",
      "pyproject.toml"
    ],
    "message": "HOTFIX:[SECURITY] Fix GHSA-wfgj-wrgh-h3r3, dep bump, docker build qa",
    "before_after_code_files": [
      "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
      "mobsf/MobSF/utils.py||mobsf/MobSF/utils.py",
      "mobsf/StaticAnalyzer/views/android/manifest_analysis.py||mobsf/StaticAnalyzer/views/android/manifest_analysis.py",
      "poetry.lock||poetry.lock"
    ]
  },
  "patch_diff": {
    "mobsf/MobSF/init.py||mobsf/MobSF/init.py": [
      "File: mobsf/MobSF/init.py -> mobsf/MobSF/init.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "11: logger = logging.getLogger(__name__)",
      "14: BANNER = \"\"\"",
      "15:   __  __       _    ____  _____       _____ ___",
      "16:  |  \\/  | ___ | |__/ ___||  ___|_   _|___ // _ \\",
      "",
      "[Removed Lines]",
      "13: VERSION = '3.9.5'",
      "",
      "[Added Lines]",
      "13: VERSION = '3.9.6'",
      "",
      "---------------"
    ],
    "mobsf/MobSF/utils.py||mobsf/MobSF/utils.py": [
      "File: mobsf/MobSF/utils.py -> mobsf/MobSF/utils.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: import string",
      "17: import subprocess",
      "18: import stat",
      "19: import sqlite3",
      "20: import unicodedata",
      "21: import threading",
      "22: from pathlib import Path",
      "23: from distutils.version import StrictVersion",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: import socket",
      "23: from urllib.parse import urlparse",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "848: def id_generator(size=6, chars=string.ascii_uppercase + string.digits):",
      "849:     \"\"\"Generate random string.\"\"\"",
      "850:     return ''.join(random.choice(chars) for _ in range(size))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "855: def valid_host(host):",
      "856:     \"\"\"Check if host is valid.\"\"\"",
      "857:     try:",
      "858:         prefixs = ('http://', 'https://')",
      "859:         if not host.startswith(prefixs):",
      "860:             host = f'http://{host}'",
      "861:         parsed = urlparse(host)",
      "862:         domain = parsed.netloc",
      "863:         path = parsed.path",
      "864:         if len(domain) == 0:",
      "865:             # No valid domain",
      "866:             return False",
      "867:         if len(path) > 0:",
      "868:             # Only host is allowed",
      "869:             return False",
      "870:         if ':' in domain:",
      "871:             # IPv6",
      "872:             return False",
      "873:         # Local network",
      "874:         invalid_prefix = (",
      "875:             '127.',",
      "876:             '192.',",
      "877:             '10.',",
      "878:             '172.',",
      "879:             '169',",
      "880:             '0.',",
      "881:             'localhost')",
      "882:         if domain.startswith(invalid_prefix):",
      "883:             return False",
      "884:         ip = socket.gethostbyname(domain)",
      "885:         if ip.startswith(invalid_prefix):",
      "886:             # Resolve dns to get IP",
      "887:             return False",
      "888:         return True",
      "889:     except Exception:",
      "890:         return False",
      "",
      "---------------"
    ],
    "mobsf/StaticAnalyzer/views/android/manifest_analysis.py||mobsf/StaticAnalyzer/views/android/manifest_analysis.py": [
      "File: mobsf/StaticAnalyzer/views/android/manifest_analysis.py -> mobsf/StaticAnalyzer/views/android/manifest_analysis.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "7: from concurrent.futures import ThreadPoolExecutor",
      "9: from mobsf.MobSF.utils import (",
      "10:     upstream_proxy,",
      "11: )",
      "12: from mobsf.StaticAnalyzer.views.android import (",
      "13:     android_manifest_desc,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "10:     is_number,",
      "12:     valid_host,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "148:                           and scheme in ('http', 'https')",
      "149:                           and host",
      "150:                           and host != '*'):",
      "152:                         shost = f'{scheme}://{host}'",
      "154:                             c_url = f'{shost}:{port}{well_known_path}'",
      "155:                         else:",
      "156:                             c_url = f'{shost}{well_known_path}'",
      "",
      "[Removed Lines]",
      "151:                         host = host.replace('*.', '')",
      "153:                         if port:",
      "",
      "[Added Lines]",
      "153:                         host = host.replace('*.', '').replace('#', '')",
      "154:                         if not valid_host(host):",
      "155:                             continue",
      "157:                         if port and is_number(port):",
      "",
      "---------------"
    ],
    "poetry.lock||poetry.lock": [
      "File: poetry.lock -> poetry.lock",
      "--- Hunk 1 ---",
      "[Context before]",
      "101: [[package]]",
      "102: name = \"apkinspector\"",
      "104: description = \"apkInspector is a tool designed to provide detailed insights into the zip structure of APK files, offering the capability to extract content and decode the AndroidManifest.xml file.\"",
      "105: optional = false",
      "106: python-versions = \">=3.5,<4.0\"",
      "107: files = [",
      "110: ]",
      "112: [[package]]",
      "",
      "[Removed Lines]",
      "103: version = \"1.2.1\"",
      "108:     {file = \"apkinspector-1.2.1-py3-none-any.whl\", hash = \"sha256:4736719884e92dfbe3203103ad46deb22b4683e208ae66972236a052c5d23e37\"},",
      "109:     {file = \"apkinspector-1.2.1.tar.gz\", hash = \"sha256:6c1fd678246760e75f8386e6f4d9686b640cc6bd88256f0865dfacbd49e8e0dd\"},",
      "",
      "[Added Lines]",
      "103: version = \"1.2.2\"",
      "108:     {file = \"apkinspector-1.2.2-py3-none-any.whl\", hash = \"sha256:ad55200bd72eb1edeeb5fb114e3bb576ec825feef54fb8727173f1f02fa12bb7\"},",
      "109:     {file = \"apkinspector-1.2.2.tar.gz\", hash = \"sha256:ea7e56090e95eb791b593e9beedf4f1056eb269c4483558e13d5d5ef4b479c60\"},",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "951: [[package]]",
      "952: name = \"fonttools\"",
      "954: description = \"Tools to manipulate font files\"",
      "955: optional = false",
      "956: python-versions = \">=3.8\"",
      "957: files = [",
      "1000: ]",
      "1002: [package.extras]",
      "",
      "[Removed Lines]",
      "953: version = \"4.49.0\"",
      "958:     {file = \"fonttools-4.49.0-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:d970ecca0aac90d399e458f0b7a8a597e08f95de021f17785fb68e2dc0b99717\"},",
      "959:     {file = \"fonttools-4.49.0-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:ac9a745b7609f489faa65e1dc842168c18530874a5f5b742ac3dd79e26bca8bc\"},",
      "960:     {file = \"fonttools-4.49.0-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:0ba0e00620ca28d4ca11fc700806fd69144b463aa3275e1b36e56c7c09915559\"},",
      "961:     {file = \"fonttools-4.49.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:cdee3ab220283057e7840d5fb768ad4c2ebe65bdba6f75d5d7bf47f4e0ed7d29\"},",
      "962:     {file = \"fonttools-4.49.0-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:ce7033cb61f2bb65d8849658d3786188afd80f53dad8366a7232654804529532\"},",
      "963:     {file = \"fonttools-4.49.0-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:07bc5ea02bb7bc3aa40a1eb0481ce20e8d9b9642a9536cde0218290dd6085828\"},",
      "964:     {file = \"fonttools-4.49.0-cp310-cp310-win32.whl\", hash = \"sha256:86eef6aab7fd7c6c8545f3ebd00fd1d6729ca1f63b0cb4d621bccb7d1d1c852b\"},",
      "965:     {file = \"fonttools-4.49.0-cp310-cp310-win_amd64.whl\", hash = \"sha256:1fac1b7eebfce75ea663e860e7c5b4a8831b858c17acd68263bc156125201abf\"},",
      "966:     {file = \"fonttools-4.49.0-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:edc0cce355984bb3c1d1e89d6a661934d39586bb32191ebff98c600f8957c63e\"},",
      "967:     {file = \"fonttools-4.49.0-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:83a0d9336de2cba86d886507dd6e0153df333ac787377325a39a2797ec529814\"},",
      "968:     {file = \"fonttools-4.49.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:36c8865bdb5cfeec88f5028e7e592370a0657b676c6f1d84a2108e0564f90e22\"},",
      "969:     {file = \"fonttools-4.49.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:33037d9e56e2562c710c8954d0f20d25b8386b397250d65581e544edc9d6b942\"},",
      "970:     {file = \"fonttools-4.49.0-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:8fb022d799b96df3eaa27263e9eea306bd3d437cc9aa981820850281a02b6c9a\"},",
      "971:     {file = \"fonttools-4.49.0-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:33c584c0ef7dc54f5dd4f84082eabd8d09d1871a3d8ca2986b0c0c98165f8e86\"},",
      "972:     {file = \"fonttools-4.49.0-cp311-cp311-win32.whl\", hash = \"sha256:cbe61b158deb09cffdd8540dc4a948d6e8f4d5b4f3bf5cd7db09bd6a61fee64e\"},",
      "973:     {file = \"fonttools-4.49.0-cp311-cp311-win_amd64.whl\", hash = \"sha256:fc11e5114f3f978d0cea7e9853627935b30d451742eeb4239a81a677bdee6bf6\"},",
      "974:     {file = \"fonttools-4.49.0-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:d647a0e697e5daa98c87993726da8281c7233d9d4ffe410812a4896c7c57c075\"},",
      "975:     {file = \"fonttools-4.49.0-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:f3bbe672df03563d1f3a691ae531f2e31f84061724c319652039e5a70927167e\"},",
      "976:     {file = \"fonttools-4.49.0-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:bebd91041dda0d511b0d303180ed36e31f4f54b106b1259b69fade68413aa7ff\"},",
      "977:     {file = \"fonttools-4.49.0-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:4145f91531fd43c50f9eb893faa08399816bb0b13c425667c48475c9f3a2b9b5\"},",
      "978:     {file = \"fonttools-4.49.0-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:ea329dafb9670ffbdf4dbc3b0e5c264104abcd8441d56de77f06967f032943cb\"},",
      "979:     {file = \"fonttools-4.49.0-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:c076a9e548521ecc13d944b1d261ff3d7825048c338722a4bd126d22316087b7\"},",
      "980:     {file = \"fonttools-4.49.0-cp312-cp312-win32.whl\", hash = \"sha256:b607ea1e96768d13be26d2b400d10d3ebd1456343eb5eaddd2f47d1c4bd00880\"},",
      "981:     {file = \"fonttools-4.49.0-cp312-cp312-win_amd64.whl\", hash = \"sha256:a974c49a981e187381b9cc2c07c6b902d0079b88ff01aed34695ec5360767034\"},",
      "982:     {file = \"fonttools-4.49.0-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:b85ec0bdd7bdaa5c1946398cbb541e90a6dfc51df76dfa88e0aaa41b335940cb\"},",
      "983:     {file = \"fonttools-4.49.0-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:af20acbe198a8a790618ee42db192eb128afcdcc4e96d99993aca0b60d1faeb4\"},",
      "984:     {file = \"fonttools-4.49.0-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:4d418b1fee41a1d14931f7ab4b92dc0bc323b490e41d7a333eec82c9f1780c75\"},",
      "985:     {file = \"fonttools-4.49.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b44a52b8e6244b6548851b03b2b377a9702b88ddc21dcaf56a15a0393d425cb9\"},",
      "986:     {file = \"fonttools-4.49.0-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:7c7125068e04a70739dad11857a4d47626f2b0bd54de39e8622e89701836eabd\"},",
      "987:     {file = \"fonttools-4.49.0-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:29e89d0e1a7f18bc30f197cfadcbef5a13d99806447c7e245f5667579a808036\"},",
      "988:     {file = \"fonttools-4.49.0-cp38-cp38-win32.whl\", hash = \"sha256:9d95fa0d22bf4f12d2fb7b07a46070cdfc19ef5a7b1c98bc172bfab5bf0d6844\"},",
      "989:     {file = \"fonttools-4.49.0-cp38-cp38-win_amd64.whl\", hash = \"sha256:768947008b4dc552d02772e5ebd49e71430a466e2373008ce905f953afea755a\"},",
      "990:     {file = \"fonttools-4.49.0-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:08877e355d3dde1c11973bb58d4acad1981e6d1140711230a4bfb40b2b937ccc\"},",
      "991:     {file = \"fonttools-4.49.0-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:fdb54b076f25d6b0f0298dc706acee5052de20c83530fa165b60d1f2e9cbe3cb\"},",
      "992:     {file = \"fonttools-4.49.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:0af65c720520710cc01c293f9c70bd69684365c6015cc3671db2b7d807fe51f2\"},",
      "993:     {file = \"fonttools-4.49.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:1f255ce8ed7556658f6d23f6afd22a6d9bbc3edb9b96c96682124dc487e1bf42\"},",
      "994:     {file = \"fonttools-4.49.0-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:d00af0884c0e65f60dfaf9340e26658836b935052fdd0439952ae42e44fdd2be\"},",
      "995:     {file = \"fonttools-4.49.0-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:263832fae27481d48dfafcc43174644b6706639661e242902ceb30553557e16c\"},",
      "996:     {file = \"fonttools-4.49.0-cp39-cp39-win32.whl\", hash = \"sha256:0404faea044577a01bb82d47a8fa4bc7a54067fa7e324785dd65d200d6dd1133\"},",
      "997:     {file = \"fonttools-4.49.0-cp39-cp39-win_amd64.whl\", hash = \"sha256:b050d362df50fc6e38ae3954d8c29bf2da52be384649ee8245fdb5186b620836\"},",
      "998:     {file = \"fonttools-4.49.0-py3-none-any.whl\", hash = \"sha256:af281525e5dd7fa0b39fb1667b8d5ca0e2a9079967e14c4bfe90fd1cd13e0f18\"},",
      "999:     {file = \"fonttools-4.49.0.tar.gz\", hash = \"sha256:ebf46e7f01b7af7861310417d7c49591a85d99146fc23a5ba82fdb28af156321\"},",
      "",
      "[Added Lines]",
      "953: version = \"4.50.0\"",
      "958:     {file = \"fonttools-4.50.0-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:effd303fb422f8ce06543a36ca69148471144c534cc25f30e5be752bc4f46736\"},",
      "959:     {file = \"fonttools-4.50.0-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:7913992ab836f621d06aabac118fc258b9947a775a607e1a737eb3a91c360335\"},",
      "960:     {file = \"fonttools-4.50.0-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:8e0a1c5bd2f63da4043b63888534b52c5a1fd7ae187c8ffc64cbb7ae475b9dab\"},",
      "961:     {file = \"fonttools-4.50.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:d40fc98540fa5360e7ecf2c56ddf3c6e7dd04929543618fd7b5cc76e66390562\"},",
      "962:     {file = \"fonttools-4.50.0-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:9fff65fbb7afe137bac3113827855e0204482727bddd00a806034ab0d3951d0d\"},",
      "963:     {file = \"fonttools-4.50.0-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:b1aeae3dd2ee719074a9372c89ad94f7c581903306d76befdaca2a559f802472\"},",
      "964:     {file = \"fonttools-4.50.0-cp310-cp310-win32.whl\", hash = \"sha256:e9623afa319405da33b43c85cceb0585a6f5d3a1d7c604daf4f7e1dd55c03d1f\"},",
      "965:     {file = \"fonttools-4.50.0-cp310-cp310-win_amd64.whl\", hash = \"sha256:778c5f43e7e654ef7fe0605e80894930bc3a7772e2f496238e57218610140f54\"},",
      "966:     {file = \"fonttools-4.50.0-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:3dfb102e7f63b78c832e4539969167ffcc0375b013080e6472350965a5fe8048\"},",
      "967:     {file = \"fonttools-4.50.0-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:9e58fe34cb379ba3d01d5d319d67dd3ce7ca9a47ad044ea2b22635cd2d1247fc\"},",
      "968:     {file = \"fonttools-4.50.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2c673ab40d15a442a4e6eb09bf007c1dda47c84ac1e2eecbdf359adacb799c24\"},",
      "969:     {file = \"fonttools-4.50.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9b3ac35cdcd1a4c90c23a5200212c1bb74fa05833cc7c14291d7043a52ca2aaa\"},",
      "970:     {file = \"fonttools-4.50.0-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:8844e7a2c5f7ecf977e82eb6b3014f025c8b454e046d941ece05b768be5847ae\"},",
      "971:     {file = \"fonttools-4.50.0-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:f849bd3c5c2249b49c98eca5aaebb920d2bfd92b3c69e84ca9bddf133e9f83f0\"},",
      "972:     {file = \"fonttools-4.50.0-cp311-cp311-win32.whl\", hash = \"sha256:39293ff231b36b035575e81c14626dfc14407a20de5262f9596c2cbb199c3625\"},",
      "973:     {file = \"fonttools-4.50.0-cp311-cp311-win_amd64.whl\", hash = \"sha256:c33d5023523b44d3481624f840c8646656a1def7630ca562f222eb3ead16c438\"},",
      "974:     {file = \"fonttools-4.50.0-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:b4a886a6dbe60100ba1cd24de962f8cd18139bd32808da80de1fa9f9f27bf1dc\"},",
      "975:     {file = \"fonttools-4.50.0-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:b2ca1837bfbe5eafa11313dbc7edada79052709a1fffa10cea691210af4aa1fa\"},",
      "976:     {file = \"fonttools-4.50.0-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:a0493dd97ac8977e48ffc1476b932b37c847cbb87fd68673dee5182004906828\"},",
      "977:     {file = \"fonttools-4.50.0-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:77844e2f1b0889120b6c222fc49b2b75c3d88b930615e98893b899b9352a27ea\"},",
      "978:     {file = \"fonttools-4.50.0-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:3566bfb8c55ed9100afe1ba6f0f12265cd63a1387b9661eb6031a1578a28bad1\"},",
      "979:     {file = \"fonttools-4.50.0-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:35e10ddbc129cf61775d58a14f2d44121178d89874d32cae1eac722e687d9019\"},",
      "980:     {file = \"fonttools-4.50.0-cp312-cp312-win32.whl\", hash = \"sha256:cc8140baf9fa8f9b903f2b393a6c413a220fa990264b215bf48484f3d0bf8710\"},",
      "981:     {file = \"fonttools-4.50.0-cp312-cp312-win_amd64.whl\", hash = \"sha256:0ccc85fd96373ab73c59833b824d7a73846670a0cb1f3afbaee2b2c426a8f931\"},",
      "982:     {file = \"fonttools-4.50.0-cp38-cp38-macosx_10_9_universal2.whl\", hash = \"sha256:e270a406219af37581d96c810172001ec536e29e5593aa40d4c01cca3e145aa6\"},",
      "983:     {file = \"fonttools-4.50.0-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:ac2463de667233372e9e1c7e9de3d914b708437ef52a3199fdbf5a60184f190c\"},",
      "984:     {file = \"fonttools-4.50.0-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:47abd6669195abe87c22750dbcd366dc3a0648f1b7c93c2baa97429c4dc1506e\"},",
      "985:     {file = \"fonttools-4.50.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:074841375e2e3d559aecc86e1224caf78e8b8417bb391e7d2506412538f21adc\"},",
      "986:     {file = \"fonttools-4.50.0-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:0743fd2191ad7ab43d78cd747215b12033ddee24fa1e088605a3efe80d6984de\"},",
      "987:     {file = \"fonttools-4.50.0-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:3d7080cce7be5ed65bee3496f09f79a82865a514863197ff4d4d177389e981b0\"},",
      "988:     {file = \"fonttools-4.50.0-cp38-cp38-win32.whl\", hash = \"sha256:a467ba4e2eadc1d5cc1a11d355abb945f680473fbe30d15617e104c81f483045\"},",
      "989:     {file = \"fonttools-4.50.0-cp38-cp38-win_amd64.whl\", hash = \"sha256:f77e048f805e00870659d6318fd89ef28ca4ee16a22b4c5e1905b735495fc422\"},",
      "990:     {file = \"fonttools-4.50.0-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:b6245eafd553c4e9a0708e93be51392bd2288c773523892fbd616d33fd2fda59\"},",
      "991:     {file = \"fonttools-4.50.0-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:a4062cc7e8de26f1603323ef3ae2171c9d29c8a9f5e067d555a2813cd5c7a7e0\"},",
      "992:     {file = \"fonttools-4.50.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:34692850dfd64ba06af61e5791a441f664cb7d21e7b544e8f385718430e8f8e4\"},",
      "993:     {file = \"fonttools-4.50.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:678dd95f26a67e02c50dcb5bf250f95231d455642afbc65a3b0bcdacd4e4dd38\"},",
      "994:     {file = \"fonttools-4.50.0-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:4f2ce7b0b295fe64ac0a85aef46a0f2614995774bd7bc643b85679c0283287f9\"},",
      "995:     {file = \"fonttools-4.50.0-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:d346f4dc2221bfb7ab652d1e37d327578434ce559baf7113b0f55768437fe6a0\"},",
      "996:     {file = \"fonttools-4.50.0-cp39-cp39-win32.whl\", hash = \"sha256:a51eeaf52ba3afd70bf489be20e52fdfafe6c03d652b02477c6ce23c995222f4\"},",
      "997:     {file = \"fonttools-4.50.0-cp39-cp39-win_amd64.whl\", hash = \"sha256:8639be40d583e5d9da67795aa3eeeda0488fb577a1d42ae11a5036f18fb16d93\"},",
      "998:     {file = \"fonttools-4.50.0-py3-none-any.whl\", hash = \"sha256:48fa36da06247aa8282766cfd63efff1bb24e55f020f29a335939ed3844d20d3\"},",
      "999:     {file = \"fonttools-4.50.0.tar.gz\", hash = \"sha256:fa5cf61058c7dbb104c2ac4e782bf1b2016a8cf2f69de6e4dd6a865d2c969bb5\"},",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2538: [[package]]",
      "2539: name = \"pyqt5-qt5\"",
      "2541: description = \"The subset of a Qt installation needed by PyQt5.\"",
      "2542: optional = false",
      "2543: python-versions = \"*\"",
      "2544: files = [",
      "2549: ]",
      "2551: [[package]]",
      "",
      "[Removed Lines]",
      "2540: version = \"5.15.2\"",
      "2545:     {file = \"PyQt5_Qt5-5.15.2-py3-none-macosx_10_13_intel.whl\", hash = \"sha256:76980cd3d7ae87e3c7a33bfebfaee84448fd650bad6840471d6cae199b56e154\"},",
      "2546:     {file = \"PyQt5_Qt5-5.15.2-py3-none-manylinux2014_x86_64.whl\", hash = \"sha256:1988f364ec8caf87a6ee5d5a3a5210d57539988bf8e84714c7d60972692e2f4a\"},",
      "2547:     {file = \"PyQt5_Qt5-5.15.2-py3-none-win32.whl\", hash = \"sha256:9cc7a768b1921f4b982ebc00a318ccb38578e44e45316c7a4a850e953e1dd327\"},",
      "2548:     {file = \"PyQt5_Qt5-5.15.2-py3-none-win_amd64.whl\", hash = \"sha256:750b78e4dba6bdf1607febedc08738e318ea09e9b10aea9ff0d73073f11f6962\"},",
      "",
      "[Added Lines]",
      "2540: version = \"5.15.13\"",
      "2545:     {file = \"PyQt5_Qt5-5.15.13-py3-none-macosx_10_13_x86_64.whl\", hash = \"sha256:92575a9e96a27c4ed67c56c7048ded7461a1655d5d21f0e05064664e6e9fcbdf\"},",
      "2546:     {file = \"PyQt5_Qt5-5.15.13-py3-none-macosx_11_0_arm64.whl\", hash = \"sha256:141859f2ffe04cc6c5db970e2b6ad9f98897805d886a14c52614e3799daab6d6\"},",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4417da03ba8ec23adae91a5d2c78ec1287e56173",
      "candidate_info": {
        "commit_hash": "4417da03ba8ec23adae91a5d2c78ec1287e56173",
        "repo": "MobSF/Mobile-Security-Framework-MobSF",
        "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/4417da03ba8ec23adae91a5d2c78ec1287e56173",
        "files": [
          "mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "poetry.lock",
          "pyproject.toml"
        ],
        "message": "poetry pyqt5 fixes (#2362)\n\n* poetry pyqt5 fixes\n\n* QA\n\n* fix\n\n* Cert analysis qa\n\n* QA\n\n* pin pyqt5",
        "before_after_code_files": [
          "mobsf/StaticAnalyzer/views/android/cert_analysis.py||mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "poetry.lock||poetry.lock"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "poetry.lock||poetry.lock"
          ],
          "candidate": [
            "poetry.lock||poetry.lock"
          ]
        }
      },
      "candidate_diff": {
        "mobsf/StaticAnalyzer/views/android/cert_analysis.py||mobsf/StaticAnalyzer/views/android/cert_analysis.py": [
          "File: mobsf/StaticAnalyzer/views/android/cert_analysis.py -> mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: import subprocess",
          "9: from pathlib import Path",
          "15: from cryptography.hazmat.backends import default_backend",
          "16: from cryptography.hazmat.primitives import serialization",
          "",
          "[Removed Lines]",
          "11: from androguard.util import get_certificate_name_string",
          "13: from asn1crypto import x509",
          "",
          "[Added Lines]",
          "11: import asn1crypto",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40: }",
          "43: def get_hardcoded_cert_keystore(files):",
          "44:     \"\"\"Returns the hardcoded certificate keystore.\"\"\"",
          "45:     try:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: def get_certificate_name_string(name, short=False, delimiter=', '):",
          "42:     \"\"\"",
          "43:     Function from androguard.",
          "45:     licensed  under the Apache License, Version 2.0.",
          "46:     https://github.com/androguard/androguard/blob/master/androguard/util.py",
          "47:     Format the Name type of a X509 Certificate in a human readable form.",
          "49:     :param name: Name object to return the DN from",
          "50:     :param short: Use short form (default: False)",
          "51:     :param delimiter: Delimiter string or character between",
          "52:         two parts (default: ', ')",
          "54:     :type name: dict or :class:`asn1crypto.x509.Name`",
          "55:     :type short: boolean",
          "56:     :type delimiter: str",
          "58:     :rtype: str",
          "59:     \"\"\"",
          "60:     if isinstance(name, asn1crypto.x509.Name):",
          "61:         name = name.native",
          "63:     # For the shortform, we have a lookup table",
          "64:     # See RFC4514 for more details",
          "65:     _ = {",
          "66:         'business_category': ('businessCategory', 'businessCategory'),",
          "67:         'serial_number': ('serialNumber', 'serialNumber'),",
          "68:         'country_name': ('C', 'countryName'),",
          "69:         'postal_code': ('postalCode', 'postalCode'),",
          "70:         'state_or_province_name': ('ST', 'stateOrProvinceName'),",
          "71:         'locality_name': ('L', 'localityName'),",
          "72:         'street_address': ('street', 'streetAddress'),",
          "73:         'organization_name': ('O', 'organizationName'),",
          "74:         'organizational_unit_name': ('OU', 'organizationalUnitName'),",
          "75:         'title': ('title', 'title'),",
          "76:         'common_name': ('CN', 'commonName'),",
          "77:         'initials': ('initials', 'initials'),",
          "78:         'generation_qualifier': ('generationQualifier', 'generationQualifier'),",
          "79:         'surname': ('SN', 'surname'),",
          "80:         'given_name': ('GN', 'givenName'),",
          "81:         'name': ('name', 'name'),",
          "82:         'pseudonym': ('pseudonym', 'pseudonym'),",
          "83:         'dn_qualifier': ('dnQualifier', 'dnQualifier'),",
          "84:         'telephone_number': ('telephoneNumber', 'telephoneNumber'),",
          "85:         'email_address': ('E', 'emailAddress'),",
          "86:         'domain_component': ('DC', 'domainComponent'),",
          "87:         'name_distinguisher': ('nameDistinguisher', 'nameDistinguisher'),",
          "88:         'organization_identifier': (",
          "89:             'organizationIdentifier', 'organizationIdentifier'),",
          "90:     }",
          "91:     return delimiter.join(",
          "92:         ['{}={}'.format(",
          "93:             _.get(attr, (attr, attr))[0 if short else 1],",
          "94:             name[attr]) for attr in name])",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70: def get_cert_details(data):",
          "71:     \"\"\"Get certificate details.\"\"\"",
          "72:     certlist = []",
          "74:     subject = get_certificate_name_string(x509_cert.subject, short=True)",
          "75:     certlist.append(f'X.509 Subject: {subject}')",
          "76:     certlist.append(f'Signature Algorithm: {x509_cert.signature_algo}')",
          "",
          "[Removed Lines]",
          "73:     x509_cert = x509.Certificate.load(data)",
          "",
          "[Added Lines]",
          "127:     x509_cert = asn1crypto.x509.Certificate.load(data)",
          "",
          "---------------"
        ],
        "poetry.lock||poetry.lock": [
          "File: poetry.lock -> poetry.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "2538: [[package]]",
          "2539: name = \"pyqt5-qt5\"",
          "2541: description = \"The subset of a Qt installation needed by PyQt5.\"",
          "2542: optional = false",
          "2543: python-versions = \"*\"",
          "2544: files = [",
          "2547: ]",
          "2549: [[package]]",
          "",
          "[Removed Lines]",
          "2540: version = \"5.15.13\"",
          "2545:     {file = \"PyQt5_Qt5-5.15.13-py3-none-macosx_10_13_x86_64.whl\", hash = \"sha256:92575a9e96a27c4ed67c56c7048ded7461a1655d5d21f0e05064664e6e9fcbdf\"},",
          "2546:     {file = \"PyQt5_Qt5-5.15.13-py3-none-macosx_11_0_arm64.whl\", hash = \"sha256:141859f2ffe04cc6c5db970e2b6ad9f98897805d886a14c52614e3799daab6d6\"},",
          "",
          "[Added Lines]",
          "2540: version = \"5.15.2\"",
          "2545:     {file = \"PyQt5_Qt5-5.15.2-py3-none-macosx_10_13_intel.whl\", hash = \"sha256:76980cd3d7ae87e3c7a33bfebfaee84448fd650bad6840471d6cae199b56e154\"},",
          "2546:     {file = \"PyQt5_Qt5-5.15.2-py3-none-manylinux2014_x86_64.whl\", hash = \"sha256:1988f364ec8caf87a6ee5d5a3a5210d57539988bf8e84714c7d60972692e2f4a\"},",
          "2547:     {file = \"PyQt5_Qt5-5.15.2-py3-none-win32.whl\", hash = \"sha256:9cc7a768b1921f4b982ebc00a318ccb38578e44e45316c7a4a850e953e1dd327\"},",
          "2548:     {file = \"PyQt5_Qt5-5.15.2-py3-none-win_amd64.whl\", hash = \"sha256:750b78e4dba6bdf1607febedc08738e318ea09e9b10aea9ff0d73073f11f6962\"},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3629: [metadata]",
          "3630: lock-version = \"2.0\"",
          "3631: python-versions = \"^3.10\"",
          "",
          "[Removed Lines]",
          "3632: content-hash = \"ac9146cb36bfc2e8e726e78144e601bdc51baa8fdae71cec1c615c7f4d5ed514\"",
          "",
          "[Added Lines]",
          "3634: content-hash = \"e077f3a528867790025d5079bc7af606f8a2d71b365a488ba4159ad31bae20dc\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d021da6eab6bc03b96bb18f871b29999866fb9a6",
      "candidate_info": {
        "commit_hash": "d021da6eab6bc03b96bb18f871b29999866fb9a6",
        "repo": "MobSF/Mobile-Security-Framework-MobSF",
        "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/d021da6eab6bc03b96bb18f871b29999866fb9a6",
        "files": [
          ".github/workflows/mobsf-test.yml",
          "Dockerfile",
          "mobsf/DynamicAnalyzer/tools/webproxy.py",
          "mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py",
          "mobsf/DynamicAnalyzer/views/android/environment.py",
          "mobsf/MobSF/init.py",
          "mobsf/templates/dynamic_analysis/dynamic_analysis.html"
        ],
        "message": "HOTFIX: MobSF Android Dynamic Analysis Docker Support (#2214)\n\n* MobSF Android Docker Support\n\n* Pin pip version\n\n* Update mobsf-test.yml",
        "before_after_code_files": [
          "mobsf/DynamicAnalyzer/tools/webproxy.py||mobsf/DynamicAnalyzer/tools/webproxy.py",
          "mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py||mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py",
          "mobsf/DynamicAnalyzer/views/android/environment.py||mobsf/DynamicAnalyzer/views/android/environment.py",
          "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
          "mobsf/templates/dynamic_analysis/dynamic_analysis.html||mobsf/templates/dynamic_analysis/dynamic_analysis.html"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ],
          "candidate": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ]
        }
      },
      "candidate_diff": {
        "mobsf/DynamicAnalyzer/tools/webproxy.py||mobsf/DynamicAnalyzer/tools/webproxy.py": [
          "File: mobsf/DynamicAnalyzer/tools/webproxy.py -> mobsf/DynamicAnalyzer/tools/webproxy.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: from django.conf import settings",
          "13: logger = logging.getLogger(__name__)",
          "",
          "[Removed Lines]",
          "11: from mobsf.MobSF.utils import is_file_exists, upstream_proxy",
          "",
          "[Added Lines]",
          "11: from mobsf.MobSF.utils import upstream_proxy",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:                      stdout=None,",
          "62:                      stderr=None,",
          "63:                      close_fds=True)",
          "67: def get_ca_file():",
          "68:     \"\"\"Get CA Dir.\"\"\"",
          "69:     from mitmproxy import ctx",
          "70:     ca_dir = Path(ctx.mitmproxy.options.CONF_DIR).expanduser()",
          "73:         create_ca()",
          "77: def get_traffic(package):",
          "",
          "[Removed Lines]",
          "64:     time.sleep(2)",
          "71:     ca_file = os.path.join(str(ca_dir), 'mitmproxy-ca-cert.pem')",
          "72:     if not is_file_exists(ca_file):",
          "74:     return ca_file",
          "",
          "[Added Lines]",
          "64:     time.sleep(3)",
          "71:     ca_file = ca_dir / 'mitmproxy-ca-cert.pem'",
          "72:     if not ca_file.exists():",
          "74:     return ca_file.as_posix()",
          "",
          "---------------"
        ],
        "mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py||mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py": [
          "File: mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py -> mobsf/DynamicAnalyzer/views/android/dynamic_analyzer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:         try:",
          "76:             if identifier:",
          "77:                 env = Environment(identifier)",
          "78:                 device_packages = env.get_device_packages()",
          "79:                 pkg_file = Path(settings.DWD_DIR) / 'packages.json'",
          "80:                 with pkg_file.open('w', encoding='utf-8') as target:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78:                 env.connect()",
          "",
          "---------------"
        ],
        "mobsf/DynamicAnalyzer/views/android/environment.py||mobsf/DynamicAnalyzer/views/android/environment.py": [
          "File: mobsf/DynamicAnalyzer/views/android/environment.py -> mobsf/DynamicAnalyzer/views/android/environment.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: from frida import __version__ as frida_version",
          "19: from mobsf.DynamicAnalyzer.tools.webproxy import (",
          "20:     get_ca_file,",
          "21:     get_http_tools_url,",
          "22:     start_proxy,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:     create_ca,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35: from mobsf.StaticAnalyzer.models import StaticAnalyzerAndroid",
          "37: logger = logging.getLogger(__name__)",
          "41: class Environment:",
          "",
          "[Removed Lines]",
          "38: ANDROID_API_SUPPORTED = 29",
          "",
          "[Added Lines]",
          "39: ANDROID_API_SUPPORTED = 30",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:     def wait(self, sec):",
          "53:         \"\"\"Wait in Seconds.\"\"\"",
          "57:     def check_connect_error(self, output):",
          "58:         \"\"\"Check if connect failed.\"\"\"",
          "",
          "[Removed Lines]",
          "54:         logger.info('Waiting for %s seconds...', str(sec))",
          "55:         time.sleep(sec)",
          "",
          "[Added Lines]",
          "55:         if sec > 0:",
          "56:             logger.info('Waiting for %s seconds...', str(sec))",
          "57:             time.sleep(sec)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "61:             return False",
          "62:         return True",
          "65:         \"\"\"Run subprocess and verify execution.\"\"\"",
          "66:         out = subprocess.check_output(cmd)  # lgtm [py/command-line-injection]",
          "68:         return self.check_connect_error(out)",
          "70:     def connect_n_mount(self):",
          "71:         \"\"\"Test ADB Connection.\"\"\"",
          "72:         self.adb_command(['kill-server'])",
          "",
          "[Removed Lines]",
          "64:     def run_subprocess_verify_output(self, cmd):",
          "67:         self.wait(2)                        # adb shell is allowed",
          "",
          "[Added Lines]",
          "66:     def run_subprocess_verify_output(self, cmd, wait=2):",
          "69:         self.wait(wait)                        # adb shell is allowed",
          "72:     def connect(self):",
          "73:         \"\"\"ADB Connect.\"\"\"",
          "74:         logger.info('Connecting to Android %s', self.identifier)",
          "75:         self.run_subprocess_verify_output([get_adb(),",
          "76:                                            'connect',",
          "77:                                            self.identifier], 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "565:     def mobsf_agents_setup(self, agent):",
          "566:         \"\"\"Setup MobSF agents.\"\"\"",
          "567:         # Install MITM RootCA",
          "568:         self.install_mobsf_ca('install')",
          "569:         # Install MobSF Agents",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "576:         create_ca()",
          "",
          "---------------"
        ],
        "mobsf/MobSF/init.py||mobsf/MobSF/init.py": [
          "File: mobsf/MobSF/init.py -> mobsf/MobSF/init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: logger = logging.getLogger(__name__)",
          "14: BANNER = \"\"\"",
          "15:   __  __       _    ____  _____       _____  __",
          "16:  |  \\/  | ___ | |__/ ___||  ___|_   _|___ / / /_",
          "",
          "[Removed Lines]",
          "13: VERSION = '3.6.8'",
          "",
          "[Added Lines]",
          "13: VERSION = '3.6.9'",
          "",
          "---------------"
        ],
        "mobsf/templates/dynamic_analysis/dynamic_analysis.html||mobsf/templates/dynamic_analysis/dynamic_analysis.html": [
          "File: mobsf/templates/dynamic_analysis/dynamic_analysis.html -> mobsf/templates/dynamic_analysis/dynamic_analysis.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:                      <div class=\"col-md-9\">",
          "88:                         <h4>MobSF Dynamic Analyzer Supports</h4>",
          "89:                         <h5>",
          "91:                           <strong>\u2022 Android Emulator AVD</strong> (non production) version 5.0 - 9.0 (arm, arm64, x86, and x86_64 upto API 28)",
          "92:                         </h5>",
          "93:                         <p>",
          "",
          "[Removed Lines]",
          "90:                           <strong>\u2022 Genymotion Android VM</strong> version 4.1 - 10.0 (x86, upto API 29)<br/>",
          "",
          "[Added Lines]",
          "90:                           <strong>\u2022 Genymotion Android VM</strong> version 4.1 - 11.0 (x86, upto API 30)<br/>",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af49985dd1a8e7be6632ef1125f049823418f419",
      "candidate_info": {
        "commit_hash": "af49985dd1a8e7be6632ef1125f049823418f419",
        "repo": "MobSF/Mobile-Security-Framework-MobSF",
        "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/af49985dd1a8e7be6632ef1125f049823418f419",
        "files": [
          "LICENSES/androguard.txt",
          "mobsf/MobSF/init.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apk.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/headers.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py",
          "mobsf/StaticAnalyzer/tools/androguard4/axml.py",
          "mobsf/StaticAnalyzer/tools/androguard4/resources/public.py",
          "mobsf/StaticAnalyzer/tools/androguard4/types.py",
          "mobsf/StaticAnalyzer/tools/androguard4/util.py",
          "mobsf/StaticAnalyzer/views/android/apk.py",
          "mobsf/StaticAnalyzer/views/android/app.py",
          "mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "mobsf/StaticAnalyzer/views/android/jar_aar.py",
          "mobsf/StaticAnalyzer/views/android/manifest_utils.py",
          "pyproject.toml"
        ],
        "message": "[4.2.7] Androguard & ApkInspector Bump + Patch AXMLParsing (#2461)\n\n* Androguard 293ab2d89ab9ce011c7dbbc5df3c876172875a1c update\n* AXML Parser warn \"reserved must be zero!\" instead of raise\n* Fallback on get app name when androguard returns empty string",
        "before_after_code_files": [
          "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apk.py||mobsf/StaticAnalyzer/tools/androguard4/apk.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py",
          "mobsf/StaticAnalyzer/tools/androguard4/zipfile.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/headers.py",
          "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py",
          "mobsf/StaticAnalyzer/tools/androguard4/axml.py||mobsf/StaticAnalyzer/tools/androguard4/axml.py",
          "mobsf/StaticAnalyzer/tools/androguard4/resources/public.py||mobsf/StaticAnalyzer/tools/androguard4/resources/public.py",
          "mobsf/StaticAnalyzer/tools/androguard4/types.py||mobsf/StaticAnalyzer/tools/androguard4/types.py",
          "mobsf/StaticAnalyzer/tools/androguard4/util.py||mobsf/StaticAnalyzer/tools/androguard4/util.py",
          "mobsf/StaticAnalyzer/views/android/apk.py||mobsf/StaticAnalyzer/views/android/apk.py",
          "mobsf/StaticAnalyzer/views/android/app.py||mobsf/StaticAnalyzer/views/android/app.py",
          "mobsf/StaticAnalyzer/views/android/cert_analysis.py||mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "mobsf/StaticAnalyzer/views/android/jar_aar.py||mobsf/StaticAnalyzer/views/android/jar_aar.py",
          "mobsf/StaticAnalyzer/views/android/manifest_utils.py||mobsf/StaticAnalyzer/views/android/manifest_utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ],
          "candidate": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ]
        }
      },
      "candidate_diff": {
        "mobsf/MobSF/init.py||mobsf/MobSF/init.py": [
          "File: mobsf/MobSF/init.py -> mobsf/MobSF/init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: logger = logging.getLogger(__name__)",
          "22: BANNER = r\"\"\"",
          "23:   __  __       _    ____  _____       _  _    ____",
          "24:  |  \\/  | ___ | |__/ ___||  ___|_   _| || |  |___ \\",
          "",
          "[Removed Lines]",
          "21: VERSION = '4.2.6'",
          "",
          "[Added Lines]",
          "21: VERSION = '4.2.7'",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/apk.py||mobsf/StaticAnalyzer/tools/androguard4/apk.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/apk.py -> mobsf/StaticAnalyzer/tools/androguard4/apk.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "8: # Python core",
          "9: import io",
          "11: import os",
          "12: import re",
          "14: import zipfile",
          "15: from struct import unpack",
          "21: import lxml.sax",
          "23: # Used for reading Certificates",
          "89: def parse_lxml_dom(tree):",
          "",
          "[Removed Lines]",
          "3: # Androguard",
          "5: from .axml import ARSCParser, AXMLPrinter, ARSCResTableConfig",
          "6: from .zipfile import ZipEntry",
          "10: from zlib import crc32",
          "13: import binascii",
          "16: import hashlib",
          "17: import asn1crypto",
          "18: import logging",
          "20: # External dependecies",
          "22: from xml.dom.pulldom import SAX2DOM",
          "24: from asn1crypto import cms, x509, keys",
          "26: logger = logging.getLogger(__name__)",
          "27: logger.setLevel(level=logging.CRITICAL)",
          "29: NS_ANDROID_URI = 'http://schemas.android.com/apk/res/android'",
          "30: NS_ANDROID = '{{{}}}'.format(NS_ANDROID_URI)  # Namespace as used by etree",
          "33: def get_certificate_name_string(name, short=False, delimiter=', '):",
          "34:     \"\"\"",
          "35:     Function from androguard.",
          "37:     licensed  under the Apache License, Version 2.0.",
          "38:     https://github.com/androguard/androguard/blob/master/androguard/util.py",
          "39:     Format the Name type of a X509 Certificate in a human readable form.",
          "41:     :param name: Name object to return the DN from",
          "42:     :param short: Use short form (default: False)",
          "43:     :param delimiter: Delimiter string or character between",
          "44:         two parts (default: ', ')",
          "46:     :type name: dict or :class:`asn1crypto.x509.Name`",
          "47:     :type short: boolean",
          "48:     :type delimiter: str",
          "50:     :rtype: str",
          "51:     \"\"\"",
          "52:     if isinstance(name, asn1crypto.x509.Name):",
          "53:         name = name.native",
          "55:     # For the shortform, we have a lookup table",
          "56:     # See RFC4514 for more details",
          "57:     _ = {",
          "58:         'business_category': ('businessCategory', 'businessCategory'),",
          "59:         'serial_number': ('serialNumber', 'serialNumber'),",
          "60:         'country_name': ('C', 'countryName'),",
          "61:         'postal_code': ('postalCode', 'postalCode'),",
          "62:         'state_or_province_name': ('ST', 'stateOrProvinceName'),",
          "63:         'locality_name': ('L', 'localityName'),",
          "64:         'street_address': ('street', 'streetAddress'),",
          "65:         'organization_name': ('O', 'organizationName'),",
          "66:         'organizational_unit_name': ('OU', 'organizationalUnitName'),",
          "67:         'title': ('title', 'title'),",
          "68:         'common_name': ('CN', 'commonName'),",
          "69:         'initials': ('initials', 'initials'),",
          "70:         'generation_qualifier': ('generationQualifier', 'generationQualifier'),",
          "71:         'surname': ('SN', 'surname'),",
          "72:         'given_name': ('GN', 'givenName'),",
          "73:         'name': ('name', 'name'),",
          "74:         'pseudonym': ('pseudonym', 'pseudonym'),",
          "75:         'dn_qualifier': ('dnQualifier', 'dnQualifier'),",
          "76:         'telephone_number': ('telephoneNumber', 'telephoneNumber'),",
          "77:         'email_address': ('E', 'emailAddress'),",
          "78:         'domain_component': ('DC', 'domainComponent'),",
          "79:         'name_distinguisher': ('nameDistinguisher', 'nameDistinguisher'),",
          "80:         'organization_identifier': (",
          "81:             'organizationIdentifier', 'organizationIdentifier'),",
          "82:     }",
          "83:     return delimiter.join(",
          "84:         ['{}={}'.format(",
          "85:             _.get(attr, (attr, attr))[0 if short else 1],",
          "86:             name[attr]) for attr in name])",
          "",
          "[Added Lines]",
          "3: # Androguard4 APK - Nov 24, 2024 - 04a5703b8ba7c181bb9f5f5995a2c16b6f9353cf",
          "4: # Allows type hinting of types not-yet-declared",
          "5: # in Python >= 3.7",
          "6: # see https://peps.python.org/pep-0563/",
          "7: from __future__ import annotations",
          "10: import binascii",
          "11: import hashlib",
          "15: import unicodedata",
          "17: from hashlib import md5, sha1, sha224, sha256, sha384, sha512",
          "19: from typing import Any, Iterator, List, Tuple, Union",
          "20: from xml.dom.pulldom import SAX2DOM",
          "21: from zlib import crc32",
          "24: from .apkinspector.headers import ZipEntry",
          "27: from asn1crypto import cms, keys, x509",
          "28: from asn1crypto.util import OrderedDict",
          "29: from cryptography.exceptions import InvalidSignature",
          "30: from cryptography.hazmat.backends import default_backend",
          "31: from cryptography.hazmat.primitives import hashes, serialization",
          "32: from cryptography.hazmat.primitives.asymmetric import dsa, ec, padding, rsa",
          "35: # External dependencies",
          "36: from lxml.etree import Element",
          "38: # Androguard",
          "39: from .axml import (",
          "40:     END_DOCUMENT,",
          "41:     END_TAG,",
          "42:     START_TAG,",
          "43:     TEXT,",
          "44:     ARSCParser,",
          "45:     ARSCResTableConfig,",
          "46:     AXMLParser,",
          "47:     AXMLPrinter,",
          "48:     format_value,",
          "49: )",
          "50: from .util import get_certificate_name_string",
          "52: import logging",
          "55: logger = logging.getLogger(__name__)",
          "56: logger.setLevel(level=logging.CRITICAL)",
          "57: NS_ANDROID_URI = 'http://schemas.android.com/apk/res/android'",
          "58: NS_ANDROID = '{{{}}}'.format(NS_ANDROID_URI)  # Namespace as used by etree",
          "60: # Dictionary of the different protection levels mapped to their corresponding attribute names as described in",
          "61: # https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/content/pm/PermissionInfo.java",
          "62: protection_flags_to_attributes = {",
          "63:     \"0x00000000\": \"normal\",",
          "64:     \"0x00000001\": \"dangerous\",",
          "65:     \"0x00000002\": \"signature\",",
          "66:     \"0x00000003\": \"signature or system\",",
          "67:     \"0x00000004\": \"internal\",",
          "68:     \"0x00000010\": \"privileged\",",
          "69:     \"0x00000020\": \"development\",",
          "70:     \"0x00000040\": \"appop\",",
          "71:     \"0x00000080\": \"pre23\",",
          "72:     \"0x00000100\": \"installer\",",
          "73:     \"0x00000200\": \"verifier\",",
          "74:     \"0x00000400\": \"preinstalled\",",
          "75:     \"0x00000800\": \"setup\",",
          "76:     \"0x00001000\": \"instant\",",
          "77:     \"0x00002000\": \"runtime only\",",
          "78:     \"0x00004000\": \"oem\",",
          "79:     \"0x00008000\": \"vendor privileged\",",
          "80:     \"0x00010000\": \"system text classifier\",",
          "81:     \"0x00020000\": \"wellbeing\",",
          "82:     \"0x00040000\": \"documenter\",",
          "83:     \"0x00080000\": \"configurator\",",
          "84:     \"0x00100000\": \"incident report approver\",",
          "85:     \"0x00200000\": \"app predictor\",",
          "86:     \"0x00400000\": \"module\",",
          "87:     \"0x00800000\": \"companion\",",
          "88:     \"0x01000000\": \"retail demo\",",
          "89:     \"0x02000000\": \"recents\",",
          "90:     \"0x04000000\": \"role\",",
          "91:     \"0x08000000\": \"known signer\",",
          "92: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108: def _dump_additional_attributes(additional_attributes):",
          "111:     attributes_raw = io.BytesIO(additional_attributes)",
          "112:     attributes_hex = binascii.hexlify(additional_attributes)",
          "",
          "[Removed Lines]",
          "109:     \"\"\" try to parse additional attributes, but ends up to hexdump if the scheme is unknown \"\"\"",
          "",
          "[Added Lines]",
          "116:     \"\"\"try to parse additional attributes, but ends up to hexdump if the scheme is unknown\"\"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114:     if not len(additional_attributes):",
          "115:         return attributes_hex",
          "118:     if len_attribute != 8:",
          "119:         return attributes_hex",
          "122:     if attr_id != APK._APK_SIG_ATTR_V2_STRIPPING_PROTECTION:",
          "123:         return attributes_hex",
          "127:     return \"stripping protection set, scheme %d\" % scheme_id",
          "",
          "[Removed Lines]",
          "117:     len_attribute, = unpack('<I', attributes_raw.read(4))",
          "121:     attr_id, = unpack('<I', attributes_raw.read(4))",
          "125:     scheme_id, = unpack('<I', attributes_raw.read(4))",
          "",
          "[Added Lines]",
          "124:     (len_attribute,) = unpack('<I', attributes_raw.read(4))",
          "128:     (attr_id,) = unpack('<I', attributes_raw.read(4))",
          "132:     (scheme_id,) = unpack('<I', attributes_raw.read(4))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:         infos += \"\\n\"",
          "136:         infos += \" [%d]\\n\" % i",
          "137:         infos += \"  - Signature Id : %s\\n\" % APK._APK_SIG_ALGO_IDS.get(",
          "139:         infos += \"  - Digest: %s\" % binascii.hexlify(dos[1])",
          "141:     return infos",
          "",
          "[Removed Lines]",
          "138:             dos[0], hex(dos[0]))",
          "",
          "[Added Lines]",
          "145:             dos[0], hex(dos[0])",
          "146:         )",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:     source : https://source.android.com/security/apksigning/v2.html",
          "148:     \"\"\"",
          "151:         self._bytes = None",
          "152:         self.digests = None",
          "153:         self.certificates = None",
          "",
          "[Removed Lines]",
          "150:     def __init__(self):",
          "",
          "[Added Lines]",
          "158:     def __init__(self) -> None:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "163:             certs_infos += \"\\n\"",
          "164:             certs_infos += \" [%d]\\n\" % i",
          "165:             certs_infos += \"  - Issuer: %s\\n\" % get_certificate_name_string(",
          "167:             certs_infos += \"  - Subject: %s\\n\" % get_certificate_name_string(",
          "170:             certs_infos += \"  - Hash Algorithm: %s\\n\" % x509_cert.hash_algo",
          "183: class APKV3SignedData(APKV2SignedData):",
          "",
          "[Removed Lines]",
          "166:                 x509_cert.issuer, short=True)",
          "168:                 x509_cert.subject, short=True)",
          "169:             certs_infos += \"  - Serial Number: %s\\n\" % hex(x509_cert.serial_number)",
          "171:             certs_infos += \"  - Signature Algorithm: %s\\n\" % x509_cert.signature_algo",
          "172:             certs_infos += \"  - Valid not before: %s\\n\" % x509_cert['tbs_certificate']['validity']['not_before'].native",
          "173:             certs_infos += \"  - Valid not after: %s\" % x509_cert['tbs_certificate']['validity']['not_after'].native",
          "175:         return \"\\n\".join([",
          "176:             'additional_attributes : {}'.format(",
          "177:                 _dump_additional_attributes(self.additional_attributes)),",
          "178:             'digests : {}'.format(_dump_digests_or_signatures(self.digests)),",
          "179:             'certificates : {}'.format(certs_infos),",
          "180:         ])",
          "",
          "[Added Lines]",
          "174:                 x509_cert.issuer, short=True",
          "175:             )",
          "177:                 x509_cert.subject, short=True",
          "178:             )",
          "179:             certs_infos += \"  - Serial Number: %s\\n\" % hex(",
          "180:                 x509_cert.serial_number",
          "181:             )",
          "183:             certs_infos += (",
          "184:                 \"  - Signature Algorithm: %s\\n\" % x509_cert.signature_algo",
          "185:             )",
          "186:             certs_infos += (",
          "187:                 \"  - Valid not before: %s\\n\"",
          "188:                 % x509_cert['tbs_certificate']['validity']['not_before'].native",
          "189:             )",
          "190:             certs_infos += (",
          "191:                 \"  - Valid not after: %s\"",
          "192:                 % x509_cert['tbs_certificate']['validity']['not_after'].native",
          "193:             )",
          "195:         return \"\\n\".join(",
          "196:             [",
          "197:                 'additional_attributes : {}'.format(",
          "198:                     _dump_additional_attributes(self.additional_attributes)",
          "199:                 ),",
          "200:                 'digests : {}'.format(",
          "201:                     _dump_digests_or_signatures(self.digests)",
          "202:                 ),",
          "203:                 'certificates : {}'.format(certs_infos),",
          "204:             ]",
          "205:         )",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "186:     source : https://source.android.com/security/apksigning/v3.html",
          "187:     \"\"\"",
          "190:         super().__init__()",
          "191:         self.minSDK = None",
          "192:         self.maxSDK = None",
          "",
          "[Removed Lines]",
          "189:     def __init__(self):",
          "",
          "[Added Lines]",
          "214:     def __init__(self) -> None:",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "198:         # maxSDK is set to a negative value if there is no upper bound on the sdk targeted",
          "199:         max_sdk_str = \"%d\" % self.maxSDK",
          "201:             max_sdk_str = \"0x%x\" % self.maxSDK",
          "210: class APKV2Signer:",
          "",
          "[Removed Lines]",
          "200:         if self.maxSDK >= 0x7fffffff:",
          "203:         return \"\\n\".join([",
          "204:             'signer minSDK : {:d}'.format(self.minSDK),",
          "205:             'signer maxSDK : {:s}'.format(max_sdk_str),",
          "206:             base_str",
          "207:         ])",
          "",
          "[Added Lines]",
          "225:         if self.maxSDK >= 0x7FFFFFFF:",
          "228:         return \"\\n\".join(",
          "229:             [",
          "230:                 'signer minSDK : {:d}'.format(self.minSDK),",
          "231:                 'signer maxSDK : {:s}'.format(max_sdk_str),",
          "232:                 base_str,",
          "233:             ]",
          "234:         )",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "213:     source : https://source.android.com/security/apksigning/v2.html",
          "214:     \"\"\"",
          "217:         self._bytes = None",
          "218:         self.signed_data = None",
          "219:         self.signatures = None",
          "220:         self.public_key = None",
          "222:     def __str__(self):",
          "230: class APKV3Signer(APKV2Signer):",
          "",
          "[Removed Lines]",
          "216:     def __init__(self):",
          "223:         return \"\\n\".join([",
          "224:             '{:s}'.format(str(self.signed_data)),",
          "225:             'signatures : {}'.format(_dump_digests_or_signatures(self.signatures)),",
          "226:             'public key : {}'.format(binascii.hexlify(self.public_key)),",
          "227:         ])",
          "",
          "[Added Lines]",
          "243:     def __init__(self) -> None:",
          "250:         return \"\\n\".join(",
          "251:             [",
          "252:                 '{:s}'.format(str(self.signed_data)),",
          "253:                 'signatures : {}'.format(",
          "254:                     _dump_digests_or_signatures(self.signatures)",
          "255:                 ),",
          "256:                 'public key : {}'.format(binascii.hexlify(self.public_key)),",
          "257:             ]",
          "258:         )",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "233:     source : https://source.android.com/security/apksigning/v3.html",
          "234:     \"\"\"",
          "237:         super().__init__()",
          "238:         self.minSDK = None",
          "239:         self.maxSDK = None",
          "",
          "[Removed Lines]",
          "236:     def __init__(self):",
          "",
          "[Added Lines]",
          "267:     def __init__(self) -> None:",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "245:         # maxSDK is set to a negative value if there is no upper bound on the sdk targeted",
          "246:         max_sdk_str = \"%d\" % self.maxSDK",
          "248:             max_sdk_str = \"0x%x\" % self.maxSDK",
          "257: class APK:",
          "",
          "[Removed Lines]",
          "247:         if self.maxSDK >= 0x7fffffff:",
          "250:         return \"\\n\".join([",
          "251:             'signer minSDK : {:d}'.format(self.minSDK),",
          "252:             'signer maxSDK : {:s}'.format(max_sdk_str),",
          "253:             base_str",
          "254:         ])",
          "",
          "[Added Lines]",
          "278:         if self.maxSDK >= 0x7FFFFFFF:",
          "281:         return \"\\n\".join(",
          "282:             [",
          "283:                 'signer minSDK : {:d}'.format(self.minSDK),",
          "284:                 'signer maxSDK : {:s}'.format(max_sdk_str),",
          "285:                 base_str,",
          "286:             ]",
          "287:         )",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "262:     # Constants in the APK Signature Block",
          "263:     _APK_SIG_MAGIC = b\"APK Sig Block 42\"",
          "268:     _APK_SIG_ALGO_IDS = {",
          "269:         0x0101: \"RSASSA-PSS with SHA2-256 digest, SHA2-256 MGF1, 32 bytes of salt, trailer: 0xbc\",",
          "",
          "[Removed Lines]",
          "264:     _APK_SIG_KEY_V2_SIGNATURE = 0x7109871a",
          "265:     _APK_SIG_KEY_V3_SIGNATURE = 0xf05368c0",
          "266:     _APK_SIG_ATTR_V2_STRIPPING_PROTECTION = 0xbeeff00d",
          "",
          "[Added Lines]",
          "297:     _APK_SIG_KEY_V2_SIGNATURE = 0x7109871A",
          "298:     _APK_SIG_KEY_V3_SIGNATURE = 0xF05368C0",
          "299:     _APK_SIG_ATTR_V2_STRIPPING_PROTECTION = 0xBEEFF00D",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "280:     __no_magic = False",
          "283:         \"\"\"",
          "284:         This class can access to all elements in an APK file",
          "",
          "[Removed Lines]",
          "282:     def __init__(self, filename, raw=False, magic_file=None, skip_analysis=False, testzip=False):",
          "",
          "[Added Lines]",
          "315:     def __init__(",
          "316:         self,",
          "317:         filename: str,",
          "318:         raw: bool = False,",
          "319:         magic_file: Union[str, None] = None,",
          "320:         skip_analysis: bool = False,",
          "321:         testzip: bool = False,",
          "322:     ) -> None:",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "303:         \"\"\"",
          "304:         if magic_file:",
          "305:             logger.warning(",
          "308:         self.filename = filename",
          "",
          "[Removed Lines]",
          "306:                 \"You set magic_file but this parameter is actually unused. You should remove it.\")",
          "",
          "[Added Lines]",
          "346:                 \"You set magic_file but this parameter is actually unused. You should remove it.\"",
          "347:             )",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "338:             self.__raw = self.zip.zip.getvalue()",
          "340:         if testzip:",
          "342:             # Test the zipfile for integrity before continuing.",
          "343:             # This process might be slow, as the whole file is read.",
          "344:             # Therefore it is possible to enable it as a separate feature.",
          "",
          "[Removed Lines]",
          "341:             logger.info(\"Testing zip file integrity, this might take a while...\")",
          "",
          "[Added Lines]",
          "382:             logger.info(",
          "383:                 \"Testing zip file integrity, this might take a while...\"",
          "384:             )",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "353:                 # That the filename is either very very long or does not make any sense.",
          "354:                 # Thus we do not do it, the user might find out by using other tools.",
          "355:                 raise BrokenAPKError(",
          "358:         if not skip_analysis:",
          "359:             self._apk_analysis()",
          "",
          "[Removed Lines]",
          "356:                     \"The APK is probably broken: testzip returned an error.\")",
          "",
          "[Added Lines]",
          "399:                     \"The APK is probably broken: testzip returned an error.\"",
          "400:                 )",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "385:             if not ap.is_valid():",
          "386:                 logger.error(",
          "388:                 return",
          "390:             self.axml[i] = ap",
          "",
          "[Removed Lines]",
          "387:                     \"Error while parsing AndroidManifest.xml - is the file valid?\")",
          "",
          "[Added Lines]",
          "431:                     \"Error while parsing AndroidManifest.xml - is the file valid?\"",
          "432:                 )",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "393:             if self.axml[i].is_packed():",
          "394:                 logger.warning(",
          "397:             if self.xml[i] is not None:",
          "398:                 if self.xml[i].tag != \"manifest\":",
          "399:                     logger.error(",
          "401:                     return",
          "403:                 self.package = self.get_attribute_value(\"manifest\", \"package\")",
          "404:                 self.androidversion[\"Code\"] = self.get_attribute_value(",
          "406:                 self.androidversion[\"Name\"] = self.get_attribute_value(",
          "410:                 self.permissions = list(set(self.permissions + permission))",
          "412:                 for uses_permission in self.find_tags(\"uses-permission\"):",
          "418:                 # getting details of the declared permissions",
          "419:                 for d_perm_item in self.find_tags('permission'):",
          "420:                     d_perm_name = self._get_res_string_value(",
          "422:                     d_perm_label = self._get_res_string_value(",
          "424:                     d_perm_description = self._get_res_string_value(",
          "426:                     d_perm_permissionGroup = self._get_res_string_value(",
          "428:                     d_perm_protectionLevel = self._get_res_string_value(",
          "431:                     d_perm_details = {",
          "432:                         \"label\": d_perm_label,",
          "",
          "[Removed Lines]",
          "395:                     \"XML Seems to be packed, operations on the AndroidManifest.xml might fail.\")",
          "400:                         \"AndroidManifest.xml does not start with a <manifest> tag! Is this a valid APK?\")",
          "405:                     \"manifest\", \"versionCode\")",
          "407:                     \"manifest\", \"versionName\")",
          "408:                 permission = list(self.get_all_attribute_value(",
          "409:                     \"uses-permission\", \"name\"))",
          "413:                     self.uses_permissions.append([",
          "414:                         self.get_value_from_tag(uses_permission, \"name\"),",
          "415:                         self._get_permission_maxsdk(uses_permission)",
          "416:                     ])",
          "421:                         str(self.get_value_from_tag(d_perm_item, \"name\")))",
          "423:                         str(self.get_value_from_tag(d_perm_item, \"label\")))",
          "425:                         str(self.get_value_from_tag(d_perm_item, \"description\")))",
          "427:                         str(self.get_value_from_tag(d_perm_item, \"permissionGroup\")))",
          "429:                         str(self.get_value_from_tag(d_perm_item, \"protectionLevel\")))",
          "",
          "[Added Lines]",
          "440:                     \"XML Seems to be packed, operations on the AndroidManifest.xml might fail.\"",
          "441:                 )",
          "446:                         \"AndroidManifest.xml does not start with a <manifest> tag! Is this a valid APK?\"",
          "447:                     )",
          "452:                     \"manifest\", \"versionCode\"",
          "453:                 )",
          "455:                     \"manifest\", \"versionName\"",
          "456:                 )",
          "457:                 permission = list(",
          "458:                     self.get_all_attribute_value(\"uses-permission\", \"name\")",
          "459:                 )",
          "463:                     self.uses_permissions.append(",
          "464:                         [",
          "465:                             self.get_value_from_tag(uses_permission, \"name\"),",
          "466:                             self._get_permission_maxsdk(uses_permission),",
          "467:                         ]",
          "468:                     )",
          "473:                         str(self.get_value_from_tag(d_perm_item, \"name\"))",
          "474:                     )",
          "476:                         str(self.get_value_from_tag(d_perm_item, \"label\"))",
          "477:                     )",
          "479:                         str(",
          "480:                             self.get_value_from_tag(d_perm_item, \"description\")",
          "481:                         )",
          "482:                     )",
          "484:                         str(",
          "485:                             self.get_value_from_tag(",
          "486:                                 d_perm_item, \"permissionGroup\"",
          "487:                             )",
          "488:                         )",
          "489:                     )",
          "491:                         str(",
          "492:                             self.get_value_from_tag(",
          "493:                                 d_perm_item, \"protectionLevel\"",
          "494:                             )",
          "495:                         )",
          "496:                     )",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "437:                     self.declared_permissions[d_perm_name] = d_perm_details",
          "439:                 self.valid_apk = True",
          "442:         # self.permission_module = androconf.load_api_specific_resource_module(",
          "447:     def __getstate__(self):",
          "448:         \"\"\"",
          "",
          "[Removed Lines]",
          "440:                 logger.debug(\"APK file was successfully validated!\")",
          "443:         #     \"aosp_permissions\", self.get_target_sdk_version())",
          "444:         # self.permission_module_min_sdk = androconf.load_api_specific_resource_module(",
          "445:         #     \"aosp_permissions\", self.get_min_sdk_version())",
          "",
          "[Added Lines]",
          "507:                 logger.info(\"APK file was successfully validated!\")",
          "510:         #     \"aosp_permissions\", self.get_target_sdk_version()",
          "511:         # )",
          "512:         # self.permission_module_min_sdk = (",
          "513:         #     androconf.load_api_specific_resource_module(",
          "514:         #         \"aosp_permissions\", self.get_min_sdk_version()",
          "515:         #     )",
          "516:         # )",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "494:         try:",
          "495:             maxSdkVersion = int(self.get_value_from_tag(item, \"maxSdkVersion\"))",
          "496:         except ValueError:",
          "499:         except TypeError:",
          "500:             pass",
          "501:         return maxSdkVersion",
          "504:         \"\"\"",
          "505:         Return true if the APK is valid, false otherwise.",
          "506:         An APK is seen as valid, if the AndroidManifest.xml could be successful parsed.",
          "",
          "[Removed Lines]",
          "497:             logger.warning(str(maxSdkVersion)",
          "498:                            + ' is not a valid value for <uses-permission> maxSdkVersion')",
          "503:     def is_valid_APK(self):",
          "",
          "[Added Lines]",
          "568:             logger.warning(",
          "569:                 str(maxSdkVersion)",
          "570:                 + ' is not a valid value for <uses-permission> maxSdkVersion'",
          "571:             )",
          "576:     def is_valid_APK(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "511:         \"\"\"",
          "512:         return self.valid_apk",
          "515:         \"\"\"",
          "516:         Return the filename of the APK",
          "",
          "[Removed Lines]",
          "514:     def get_filename(self):",
          "",
          "[Added Lines]",
          "587:     def get_filename(self) -> str:",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "519:         \"\"\"",
          "520:         return self.filename",
          "523:         \"\"\"",
          "524:         Return the appname of the APK",
          "",
          "[Removed Lines]",
          "522:     def get_app_name(self):",
          "",
          "[Added Lines]",
          "595:     def get_app_name(self, locale=None) -> str:",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "542:             # FIXME: would need to use _format_value inside get_attribute_value for each returned name!",
          "543:             # For example, as the activity name might be foobar.foo.bar but inside the activity it is only .bar",
          "544:             app_name = self.get_attribute_value(",
          "547:         if app_name is None:",
          "548:             # No App name set",
          "549:             # TODO return packagename instead?",
          "550:             logger.warning(",
          "552:             return \"\"",
          "554:         if app_name.startswith(\"@\"):",
          "",
          "[Removed Lines]",
          "545:                 'activity', 'label', name=main_activity_name)",
          "551:                 \"It looks like that no app name is set for the main activity!\")",
          "",
          "[Added Lines]",
          "618:                 'activity', 'label', name=main_activity_name",
          "619:             )",
          "625:                 \"It looks like that no app name is set for the main activity!\"",
          "626:             )",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "565:                 if package == 'android':",
          "566:                     # TODO: we can not resolve this, as we lack framework-res.apk",
          "567:                     # one exception would be when parsing framework-res.apk directly.",
          "570:                     return app_name",
          "571:                 else:",
          "572:                     # TODO should look this up, might be in the resources",
          "573:                     logger.warning(",
          "575:                     return app_name",
          "577:             try:",
          "581:             except Exception as e:",
          "582:                 logger.warning(\"Exception selecting app name: %s\" % e)",
          "583:         return app_name",
          "586:         \"\"\"",
          "587:         Return the first icon file name, which density is not greater than max_dpi,",
          "588:         unless exact icon resolution is set in the manifest, in which case",
          "",
          "[Removed Lines]",
          "568:                     logger.warning(\"Resource ID with android package name encountered! \"",
          "569:                                    \"Will not resolve, framework-res.apk would be required.\")",
          "574:                         \"Resource ID with Package name '{}' encountered! Will not resolve\".format(package))",
          "578:                 app_name = res_parser.get_resolved_res_configs(",
          "579:                     res_id,",
          "580:                     ARSCResTableConfig.default_config())[0][1]",
          "585:     def get_app_icon(self, max_dpi=65536):",
          "",
          "[Added Lines]",
          "643:                     logger.warning(",
          "644:                         \"Resource ID with android package name encountered! \"",
          "645:                         \"Will not resolve, framework-res.apk would be required.\"",
          "646:                     )",
          "651:                         \"Resource ID with Package name '{}' encountered! Will not resolve\".format(",
          "652:                             package",
          "653:                         )",
          "654:                     )",
          "658:                 config = (",
          "659:                     ARSCResTableConfig(None, locale=locale)",
          "660:                     if locale",
          "661:                     else ARSCResTableConfig.default_config()",
          "662:                 )",
          "663:                 app_name = res_parser.get_resolved_res_configs(res_id, config)[",
          "664:                     0",
          "665:                 ][1]",
          "670:     def get_app_icon(self, max_dpi: int = 65536) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "626:         main_activity_name = self.get_main_activity()",
          "628:         app_icon = self.get_attribute_value(",
          "631:         if not app_icon:",
          "632:             app_icon = self.get_attribute_value('application', 'icon')",
          "",
          "[Removed Lines]",
          "629:             'activity', 'icon', name=main_activity_name)",
          "",
          "[Added Lines]",
          "714:             'activity', 'icon', name=main_activity_name",
          "715:         )",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "637:             return None",
          "639:         if not app_icon:",
          "641:             if res_id:",
          "642:                 app_icon = \"@%x\" % res_id",
          "644:         if not app_icon:",
          "645:             res_id = res_parser.get_res_id_by_key(",
          "647:             if res_id:",
          "648:                 app_icon = \"@%x\" % res_id",
          "",
          "[Removed Lines]",
          "640:             res_id = res_parser.get_res_id_by_key(self.package, 'mipmap', 'ic_launcher')",
          "646:                 self.package, 'drawable', 'ic_launcher')",
          "",
          "[Added Lines]",
          "726:             res_id = res_parser.get_res_id_by_key(",
          "727:                 self.package, 'mipmap', 'ic_launcher'",
          "728:             )",
          "734:                 self.package, 'drawable', 'ic_launcher'",
          "735:             )",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "672:         return app_icon",
          "675:         \"\"\"",
          "676:         Return the name of the package",
          "",
          "[Removed Lines]",
          "674:     def get_package(self):",
          "",
          "[Added Lines]",
          "763:     def get_package(self) -> str:",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "681:         \"\"\"",
          "682:         return self.package",
          "685:         \"\"\"",
          "686:         Return the android version code",
          "",
          "[Removed Lines]",
          "684:     def get_androidversion_code(self):",
          "",
          "[Added Lines]",
          "773:     def get_androidversion_code(self) -> str:",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "691:         \"\"\"",
          "692:         return self.androidversion[\"Code\"]",
          "695:         \"\"\"",
          "696:         Return the android version name",
          "",
          "[Removed Lines]",
          "694:     def get_androidversion_name(self):",
          "",
          "[Added Lines]",
          "783:     def get_androidversion_name(self) -> str:",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "701:         \"\"\"",
          "702:         return self.androidversion[\"Name\"]",
          "705:         \"\"\"",
          "706:         Return the file names inside the APK.",
          "",
          "[Removed Lines]",
          "704:     def get_files(self):",
          "",
          "[Added Lines]",
          "793:     def get_files(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "709:         \"\"\"",
          "710:         return self.zip.namelist()",
          "713:     #     \"\"\"",
          "714:     #     Return the filetype guessed for a buffer",
          "715:     #     :param buffer: bytes",
          "",
          "[Removed Lines]",
          "712:     # def _get_file_magic_name(self, buffer):",
          "",
          "[Added Lines]",
          "801:     # def _get_file_magic_name(self, buffer: bytes) -> str:",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "730:     #         return default",
          "731:     #     except TypeError as e:",
          "732:     #         self.__no_magic = True",
          "734:     #         logger.warning(\"Error from magic library: %s\", e)",
          "737:     #         return default",
          "773:     #     \"\"\"",
          "774:     #     Return the files inside the APK with their associated types (by using python-magic)",
          "776:     #     At the same time, the CRC32 are calculated for the files.",
          "779:     #     \"\"\"",
          "780:     #     if self._files == {}:",
          "781:     #         # Generate File Types / CRC List",
          "",
          "[Removed Lines]",
          "733:     #         logger.warning(\"It looks like you have the magic python package installed but not the magic library itself!\")",
          "735:     #         logger.warning(\"Please follow the installation instructions at https://github.com/ahupp/python-magic/#installation\")",
          "736:     #         logger.warning(\"You can also install the 'python-magic-bin' package on Windows and MacOS\")",
          "739:         try:",
          "740:             # There are several implementations of magic,",
          "741:             # unfortunately all called magic",
          "742:             # We use this one: https://github.com/ahupp/python-magic/",
          "743:             # You can also use python-magic-bin on Windows or MacOS",
          "744:             getattr(magic, \"MagicException\")",
          "745:         except AttributeError:",
          "746:             self.__no_magic = True",
          "747:             logger.warning(\"Not the correct Magic library was found on your \"",
          "748:                            \"system. Please install python-magic or python-magic-bin!\")",
          "749:             return default",
          "751:         try:",
          "752:             # 1024 byte are usually enough to test the magic",
          "753:             ftype = magic.from_buffer(buffer[:1024])",
          "754:         except magic.MagicException as e:",
          "755:             logger.exception(\"Error getting the magic type: %s\", e)",
          "756:             return default",
          "758:         if not ftype:",
          "759:             return default",
          "760:         else:",
          "761:             return self._patch_magic(buffer, ftype)",
          "763:     @property",
          "764:     def files(self):",
          "765:         \"\"\"",
          "766:         Returns a dictionary of filenames and detected magic type",
          "768:         :returns: dictionary of files and their mime type",
          "769:         \"\"\"",
          "770:         return self.get_files_types()",
          "772:     # def get_files_types(self):",
          "778:     #     :rtype: a dictionnary",
          "",
          "[Added Lines]",
          "822:     #         logger.warning(",
          "823:     #             \"It looks like you have the magic python package installed but not the magic library itself!\"",
          "824:     #         )",
          "826:     #         logger.warning(",
          "827:     #             \"Please follow the installation instructions at https://github.com/ahupp/python-magic/#installation\"",
          "828:     #         )",
          "829:     #         logger.warning(",
          "830:     #             \"You can also install the 'python-magic-bin' package on Windows and MacOS\"",
          "831:     #         )",
          "834:     #     try:",
          "835:     #         # There are several implementations of magic,",
          "836:     #         # unfortunately all called magic",
          "837:     #         # We use this one: https://github.com/ahupp/python-magic/",
          "838:     #         # You can also use python-magic-bin on Windows or MacOS",
          "839:     #         getattr(magic, \"MagicException\")",
          "840:     #     except AttributeError:",
          "841:     #         self.__no_magic = True",
          "842:     #         logger.warning(",
          "843:     #             \"Not the correct Magic library was found on your \"",
          "844:     #             \"system. Please install python-magic or python-magic-bin!\"",
          "845:     #         )",
          "846:     #         return default",
          "848:     #     try:",
          "849:     #         # 1024 byte are usually enough to test the magic",
          "850:     #         ftype = magic.from_buffer(buffer[:1024])",
          "851:     #     except magic.MagicException as e:",
          "852:     #         logger.exception(\"Error getting the magic type: %s\", e)",
          "853:     #         return default",
          "855:     #     if not ftype:",
          "856:     #         return default",
          "857:     #     else:",
          "858:     #         return self._patch_magic(buffer, ftype)",
          "860:     # @property",
          "861:     # def files(self) -> dict[str, str]:",
          "862:     #     \"\"\"",
          "863:     #     Returns a dictionary of filenames and detected magic type",
          "865:     #     :returns: dictionary of files and their mime type",
          "866:     #     \"\"\"",
          "867:     #     return self.get_files_types()",
          "869:     # def get_files_types(self) -> dict[str, str]:",
          "875:     #     :rtype: a dictionary",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "793:     #     :param orig: guess by mime libary",
          "794:     #     :returns: corrected guess",
          "795:     #     \"\"\"",
          "797:     #         return \"Android application package file\"",
          "799:     #     return orig",
          "",
          "[Removed Lines]",
          "796:     #     if (\"Zip\" in orig) or ('(JAR)' in orig) and androconf.is_android_raw(buffer) == 'APK':",
          "",
          "[Added Lines]",
          "893:     #     if (",
          "894:     #         (\"Zip\" in orig)",
          "895:     #         or ('(JAR)' in orig)",
          "896:     #         and androconf.is_android_raw(buffer) == 'APK'",
          "897:     #     ):",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "810:         buffer = self.zip.read(filename)",
          "811:         if filename not in self.files_crc32:",
          "812:             self.files_crc32[filename] = crc32(buffer)",
          "819:         return buffer",
          "822:         \"\"\"",
          "823:         Calculates and returns a dictionary of filenames and CRC32",
          "",
          "[Removed Lines]",
          "813:             if self.files_crc32[filename] != self.zip.infolist()[filename].crc32_of_uncompressed_data:",
          "814:                 logger.error(\"File '{}' has different CRC32 after unpacking! \"",
          "815:                              \"Declared: {:08x}, Calculated: {:08x}\".format(filename,",
          "816:                                                                            self.zip.infolist()[",
          "817:                                                                                filename].crc32_of_uncompressed_data,",
          "818:                                                                            self.files_crc32[filename]))",
          "821:     def get_files_crc32(self):",
          "",
          "[Added Lines]",
          "914:             if (",
          "915:                 self.files_crc32[filename]",
          "916:                 != self.zip.infolist()[filename].crc32_of_uncompressed_data",
          "917:             ):",
          "918:                 logger.error(",
          "919:                     \"File '{}' has different CRC32 after unpacking! \"",
          "920:                     \"Declared: {:08x}, Calculated: {:08x}\".format(",
          "921:                         filename,",
          "922:                         self.zip.infolist()[",
          "923:                             filename",
          "924:                         ].crc32_of_uncompressed_data,",
          "925:                         self.files_crc32[filename],",
          "926:                     )",
          "927:                 )",
          "930:     def get_files_crc32(self) -> dict[str, int]:",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "831:         return self.files_crc32",
          "843:         \"\"\"",
          "844:         Return raw bytes of the APK",
          "",
          "[Removed Lines]",
          "833:     # def get_files_information(self):",
          "834:     #     \"\"\"",
          "835:     #     Return the files inside the APK with their associated types and crc32",
          "837:     #     :rtype: str, str, int",
          "838:     #     \"\"\"",
          "839:     #     for k in self.get_files():",
          "840:     #         yield k, self.get_files_types()[k], self.get_files_crc32()[k]",
          "842:     def get_raw(self):",
          "",
          "[Added Lines]",
          "942:     def get_files_information(self) -> Iterator[tuple[str, str, int]]:",
          "943:         \"\"\"",
          "944:         Return the files inside the APK with their associated types and crc32",
          "946:         :rtype: str, str, int",
          "947:         \"\"\"",
          "948:         for k in self.get_files():",
          "949:             yield k, self.get_files_types()[k], self.get_files_crc32()[k]",
          "951:     def get_raw(self) -> bytes:",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "853:                 self.__raw = bytearray(f.read())",
          "854:             return self.__raw",
          "857:         \"\"\"",
          "858:         Return the raw data of the specified filename",
          "859:         inside the APK",
          "",
          "[Removed Lines]",
          "856:     def get_file(self, filename):",
          "",
          "[Added Lines]",
          "965:     def get_file(self, filename: str) -> bytes:",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "865:         except KeyError:",
          "866:             raise FileNotPresent(filename)",
          "869:         \"\"\"",
          "870:         Return the raw data of the classes dex file",
          "",
          "[Removed Lines]",
          "868:     def get_dex(self):",
          "",
          "[Added Lines]",
          "977:     def get_dex(self) -> bytes:",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "880:             # TODO is this a good idea to return an empty string?",
          "881:             return b\"\"",
          "884:         \"\"\"",
          "885:         Return the names of all DEX files found in the APK.",
          "886:         This method only accounts for \"offical\" dex files, i.e. all files",
          "",
          "[Removed Lines]",
          "883:     def get_dex_names(self):",
          "",
          "[Added Lines]",
          "992:     def get_dex_names(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "891:         dexre = re.compile(r\"^classes(\\d*).dex$\")",
          "892:         return filter(lambda x: dexre.match(x), self.get_files())",
          "895:         \"\"\"",
          "896:         Return the raw data of all classes dex files",
          "",
          "[Removed Lines]",
          "894:     def get_all_dex(self):",
          "",
          "[Added Lines]",
          "1003:     def get_all_dex(self) -> Iterator[bytes]:",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "900:         for dex_name in self.get_dex_names():",
          "901:             yield self.get_file(dex_name)",
          "904:         \"\"\"",
          "905:         Test if the APK has multiple DEX files",
          "907:         :returns: True if multiple dex found, otherwise False",
          "908:         \"\"\"",
          "909:         dexre = re.compile(r\"^classes(\\d+)?.dex$\")",
          "912:     def _format_value(self, value):",
          "913:         \"\"\"",
          "",
          "[Removed Lines]",
          "903:     def is_multidex(self):",
          "910:         return len([instance for instance in self.get_files() if dexre.search(instance)]) > 1",
          "",
          "[Added Lines]",
          "1012:     def is_multidex(self) -> bool:",
          "1019:         return (",
          "1020:             len(",
          "1021:                 [",
          "1022:                     instance",
          "1023:                     for instance in self.get_files()",
          "1024:                     if dexre.search(instance)",
          "1025:                 ]",
          "1026:             )",
          "1027:             > 1",
          "1028:         )",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "931:         return value",
          "933:     def get_all_attribute_value(",
          "936:         \"\"\"",
          "937:         Yields all the attribute values in xml files which match with the tag name and the specific attribute",
          "",
          "[Removed Lines]",
          "934:         self, tag_name, attribute, format_value=True, **attribute_filter",
          "935:     ):",
          "",
          "[Added Lines]",
          "1052:         self,",
          "1053:         tag_name: str,",
          "1054:         attribute: str,",
          "1055:         format_value: bool = True,",
          "1057:     ) -> Iterator[str]:",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "950:                     yield value",
          "952:     def get_attribute_value(",
          "955:         \"\"\"",
          "956:         Return the attribute value in xml files which matches the tag name and the specific attribute",
          "",
          "[Removed Lines]",
          "953:         self, tag_name, attribute, format_value=False, **attribute_filter",
          "954:     ):",
          "",
          "[Added Lines]",
          "1075:         self,",
          "1076:         tag_name: str,",
          "1077:         attribute: str,",
          "1078:         format_value: bool = False,",
          "1080:     ) -> str:",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "961:         \"\"\"",
          "963:         for value in self.get_all_attribute_value(",
          "965:             if value is not None:",
          "966:                 return value",
          "969:         \"\"\"",
          "970:         Return the value of the android prefixed attribute in a specific tag.",
          "",
          "[Removed Lines]",
          "964:                 tag_name, attribute, format_value, **attribute_filter):",
          "968:     def get_value_from_tag(self, tag, attribute):",
          "",
          "[Added Lines]",
          "1090:             tag_name, attribute, format_value, **attribute_filter",
          "1091:         ):",
          "1095:     def get_value_from_tag(",
          "1096:         self, tag: Element, attribute: str",
          "1097:     ) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1006:             if value:",
          "1007:                 # If value is still None, the attribute could not be found, thus is not present",
          "1010:         return value",
          "1013:         \"\"\"",
          "1014:         Return a list of all the matched tags in all available xml",
          "1016:         :param str tag: specify the tag name",
          "1017:         \"\"\"",
          "1018:         all_tags = [",
          "1022:             for i in self.xml",
          "1023:         ]",
          "1024:         return [tag for tag_list in all_tags for tag in tag_list]",
          "1026:     def find_tags_from_xml(",
          "1029:         \"\"\"",
          "1030:         Return a list of all the matched tags in a specific xml",
          "1031:         w",
          "",
          "[Removed Lines]",
          "1008:                 logger.warning(\"Failed to get the attribute '{}' on tag '{}' with namespace. \"",
          "1009:                                \"But found the same attribute without namespace!\".format(attribute, tag.tag))",
          "1012:     def find_tags(self, tag_name, **attribute_filter):",
          "1019:             self.find_tags_from_xml(",
          "1020:                 i, tag_name, **attribute_filter",
          "1021:             )",
          "1027:         self, xml_name, tag_name, **attribute_filter",
          "1028:     ):",
          "",
          "[Added Lines]",
          "1137:                 logger.warning(",
          "1138:                     \"Failed to get the attribute '{}' on tag '{}' with namespace. \"",
          "1139:                     \"But found the same attribute without namespace!\".format(",
          "1140:                         attribute, tag.tag",
          "1141:                     )",
          "1142:                 )",
          "1145:     def find_tags(self, tag_name: str, **attribute_filter) -> list[str]:",
          "1152:             self.find_tags_from_xml(i, tag_name, **attribute_filter)",
          "1158:         self, xml_name: str, tag_name: str, **attribute_filter",
          "1159:     ) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1036:         if xml is None:",
          "1037:             return []",
          "1038:         if xml.tag == tag_name:",
          "1042:                 return [xml]",
          "1043:             return []",
          "1045:         return [",
          "1049:         ]",
          "1052:         r\"\"\"",
          "1053:         Return true if the attributes matches in attribute filter.",
          "",
          "[Removed Lines]",
          "1039:             if self.is_tag_matched(",
          "1040:                 xml.tag, **attribute_filter",
          "1041:             ):",
          "1044:         tags = xml.findall(\".//\" + tag_name)",
          "1046:             tag for tag in tags if self.is_tag_matched(",
          "1047:                 tag, **attribute_filter",
          "1048:             )",
          "1051:     def is_tag_matched(self, tag, **attribute_filter):",
          "",
          "[Added Lines]",
          "1170:             if self.is_tag_matched(xml.tag, **attribute_filter):",
          "1173:         tags = set()",
          "1174:         tags.update(xml.findall(\".//\" + tag_name))",
          "1176:         # https://github.com/androguard/androguard/pull/1053",
          "1177:         # permission declared using tag <android:uses-permission...",
          "1178:         tags.update(xml.findall(\".//\" + NS_ANDROID + tag_name))",
          "1180:             tag for tag in tags if self.is_tag_matched(tag, **attribute_filter)",
          "1183:     def is_tag_matched(self, tag: str, **attribute_filter) -> bool:",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1075:                 return False",
          "1076:         return True",
          "1079:         \"\"\"",
          "1080:         Return names of the main activities",
          "",
          "[Removed Lines]",
          "1078:     def get_main_activities(self):",
          "",
          "[Added Lines]",
          "1210:     def get_main_activities(self) -> set[str]:",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1089:         for i in self.xml:",
          "1090:             if self.xml[i] is None:",
          "1091:                 continue",
          "1095:             for item in activities_and_aliases:",
          "1096:                 # Some applications have more than one MAIN activity.",
          "",
          "[Removed Lines]",
          "1092:             activities_and_aliases = self.xml[i].findall(\".//activity\") + \\",
          "1093:                 self.xml[i].findall(\".//activity-alias\")",
          "",
          "[Added Lines]",
          "1224:             activities_and_aliases = self.xml[i].findall(",
          "1225:                 \".//activity\"",
          "1226:             ) + self.xml[i].findall(\".//activity-alias\")",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1120:         return x.intersection(y)",
          "1123:         \"\"\"",
          "1124:         Return the name of the main activity",
          "",
          "[Removed Lines]",
          "1122:     def get_main_activity(self):",
          "",
          "[Added Lines]",
          "1255:     def get_main_activity(self) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1135:             # sorted is necessary",
          "1136:             # 9fc7d3e8225f6b377f9181a92c551814317b77e1aa0df4c6d508d24b18f0f633",
          "1137:             good_main_activities = sorted(",
          "1139:             if good_main_activities:",
          "1140:                 return good_main_activities[0]",
          "1141:             return sorted(main_activities)[0]",
          "1142:         return None",
          "1145:         \"\"\"",
          "1146:         Return the android:name attribute of all activities",
          "",
          "[Removed Lines]",
          "1138:                 main_activities.intersection(self.get_activities()))",
          "1144:     def get_activities(self):",
          "",
          "[Added Lines]",
          "1271:                 main_activities.intersection(self.get_activities())",
          "1272:             )",
          "1278:     def get_activities(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1149:         \"\"\"",
          "1150:         return list(self.get_all_attribute_value(\"activity\", \"name\"))",
          "1153:         \"\"\"",
          "1154:         Return the android:name and android:targetActivity attribute of all activity aliases.",
          "",
          "[Removed Lines]",
          "1152:     def get_activity_aliases(self):",
          "",
          "[Added Lines]",
          "1286:     def get_activity_aliases(self) -> list[dict[str, str]]:",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1159:         for alias in self.find_tags('activity-alias'):",
          "1160:             activity_alias = {}",
          "1161:             for attribute in ['name', 'targetActivity']:",
          "1164:                 if not value:",
          "1165:                     continue",
          "1166:                 activity_alias[attribute] = self._format_value(value)",
          "",
          "[Removed Lines]",
          "1162:                 value = (alias.get(attribute)",
          "1163:                          or alias.get(self._ns(attribute)))",
          "",
          "[Added Lines]",
          "1296:                 value = alias.get(attribute) or alias.get(self._ns(attribute))",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1168:                 ali.append(activity_alias)",
          "1169:         return ali",
          "1172:         \"\"\"",
          "1173:         Return the android:name attribute of all services",
          "",
          "[Removed Lines]",
          "1171:     def get_services(self):",
          "",
          "[Added Lines]",
          "1304:     def get_services(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1176:         \"\"\"",
          "1177:         return list(self.get_all_attribute_value(\"service\", \"name\"))",
          "1180:         \"\"\"",
          "1181:         Return the android:name attribute of all receivers",
          "",
          "[Removed Lines]",
          "1179:     def get_receivers(self):",
          "",
          "[Added Lines]",
          "1312:     def get_receivers(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1184:         \"\"\"",
          "1185:         return list(self.get_all_attribute_value(\"receiver\", \"name\"))",
          "1188:         \"\"\"",
          "1189:         Return the android:name attribute of all providers",
          "",
          "[Removed Lines]",
          "1187:     def get_providers(self):",
          "",
          "[Added Lines]",
          "1320:     def get_providers(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1192:         \"\"\"",
          "1193:         return list(self.get_all_attribute_value(\"provider\", \"name\"))",
          "1196:         \"\"\"",
          "1197:         Return the literal value with a resource id",
          "1198:         :rtype: str",
          "",
          "[Removed Lines]",
          "1195:     def get_res_value(self, name):",
          "",
          "[Added Lines]",
          "1328:     def get_res_value(self, name: str) -> str:",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1205:         res_id = res_parser.parse_id(name)[0]",
          "1206:         try:",
          "1207:             value = res_parser.get_resolved_res_configs(",
          "1210:         except Exception as e:",
          "1211:             logger.warning(\"Exception get resolved resource id: %s\" % e)",
          "1212:             return name",
          "1214:         return value",
          "1217:         \"\"\"",
          "1218:         Find intent filters for a given item and name.",
          "",
          "[Removed Lines]",
          "1208:                 res_id,",
          "1209:                 ARSCResTableConfig.default_config())[0][1]",
          "1216:     def get_intent_filters(self, itemtype, name):",
          "",
          "[Added Lines]",
          "1341:                 res_id, ARSCResTableConfig.default_config()",
          "1342:             )[0][1]",
          "1349:     def get_intent_filters(",
          "1350:         self, itemtype: str, name: str",
          "1351:     ) -> dict[str, list[str]]:",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1225:         :param name: the `android:name` of the parent item, e.g. activity name",
          "1226:         :returns: a dictionary with the keys `action` and `category` containing the `android:name` of those items",
          "1227:         \"\"\"",
          "1231:         d = {}",
          "1232:         for element in attributes.keys():",
          "",
          "[Removed Lines]",
          "1228:         attributes = {\"action\": [\"name\"], \"category\": [\"name\"], \"data\": [",
          "1229:             'scheme', 'host', 'port', 'path', 'pathPattern', 'pathPrefix', 'mimeType']}",
          "",
          "[Added Lines]",
          "1363:         attributes = {",
          "1364:             \"action\": [\"name\"],",
          "1365:             \"category\": [\"name\"],",
          "1366:             \"data\": [",
          "1367:                 'scheme',",
          "1368:                 'host',",
          "1369:                 'port',",
          "1370:                 'path',",
          "1371:                 'pathPattern',",
          "1372:                 'pathPrefix',",
          "1373:                 'mimeType',",
          "1374:             ],",
          "1375:         }",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1245:                                         value = ssitem.get(self._ns(attribute))",
          "1246:                                         if value:",
          "1247:                                             if value.startswith('@'):",
          "1249:                                             values[attribute] = value",
          "1251:                                     if values:",
          "",
          "[Removed Lines]",
          "1248:                                                 value = self.get_res_value(value)",
          "",
          "[Added Lines]",
          "1394:                                                 value = self.get_res_value(",
          "1395:                                                     value",
          "1396:                                                 )",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1266:         return d",
          "1269:         \"\"\"",
          "1270:         Return permissions names declared in the AndroidManifest.xml.",
          "",
          "[Removed Lines]",
          "1268:     def get_permissions(self):",
          "",
          "[Added Lines]",
          "1416:     def get_permissions(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1282:         \"\"\"",
          "1283:         return self.permissions",
          "1286:         \"\"\"",
          "1290:         \"\"\"",
          "1291:         target_sdk_version = self.get_effective_target_sdk_version()",
          "",
          "[Removed Lines]",
          "1285:     def get_uses_implied_permission_list(self):",
          "1287:             Return all permissions implied by the target SDK or other permissions.",
          "1289:             :rtype: list of string",
          "",
          "[Added Lines]",
          "1433:     def get_uses_implied_permission_list(self) -> list[str]:",
          "1435:         Return all permissions implied by the target SDK or other permissions.",
          "1437:         :rtype: list of string",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1308:             if READ_PHONE_STATE not in self.permissions:",
          "1309:                 implied.append([READ_PHONE_STATE, None])",
          "1313:             maxSdkVersion = None",
          "1314:             for name, version in self.uses_permissions:",
          "1315:                 if name == WRITE_EXTERNAL_STORAGE:",
          "",
          "[Removed Lines]",
          "1311:         if (WRITE_EXTERNAL_STORAGE in self.permissions or implied_WRITE_EXTERNAL_STORAGE) \\",
          "1312:                 and READ_EXTERNAL_STORAGE not in self.permissions:",
          "",
          "[Added Lines]",
          "1459:         if (",
          "1460:             WRITE_EXTERNAL_STORAGE in self.permissions",
          "1461:             or implied_WRITE_EXTERNAL_STORAGE",
          "1462:         ) and READ_EXTERNAL_STORAGE not in self.permissions:",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1318:             implied.append([READ_EXTERNAL_STORAGE, maxSdkVersion])",
          "1320:         if target_sdk_version < 16:",
          "1323:                 implied.append([READ_CALL_LOG, None])",
          "1326:                 implied.append([WRITE_CALL_LOG, None])",
          "1328:         return implied",
          "1331:         if not sdk_version or int(sdk_version) <= 15:",
          "1332:             return protection_level.replace('Or', '|').lower()",
          "1333:         return protection_level",
          "",
          "[Removed Lines]",
          "1321:             if READ_CONTACTS in self.permissions \\",
          "1322:                     and READ_CALL_LOG not in self.permissions:",
          "1324:             if WRITE_CONTACTS in self.permissions \\",
          "1325:                     and WRITE_CALL_LOG not in self.permissions:",
          "1330:     def _update_permission_protection_level(self, protection_level, sdk_version):",
          "",
          "[Added Lines]",
          "1471:             if (",
          "1472:                 READ_CONTACTS in self.permissions",
          "1473:                 and READ_CALL_LOG not in self.permissions",
          "1474:             ):",
          "1476:             if (",
          "1477:                 WRITE_CONTACTS in self.permissions",
          "1478:                 and WRITE_CALL_LOG not in self.permissions",
          "1479:             ):",
          "1484:     def _update_permission_protection_level(",
          "1485:         self, protection_level, sdk_version",
          "1486:     ):",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1337:         target_sdk = self.get_target_sdk_version()",
          "1338:         filled_permissions = permissions.copy()",
          "1339:         for permission in filled_permissions:",
          "1343:                 x = self.permission_module_min_sdk[permission]",
          "1344:                 protection_level = self._update_permission_protection_level(",
          "1346:                 filled_permissions[permission] = [",
          "1348:             else:",
          "1349:                 filled_permissions[permission] = [",
          "1350:                     self._update_permission_protection_level(",
          "1353:         return filled_permissions",
          "1356:         \"\"\"",
          "1357:         Return permissions with details.",
          "",
          "[Removed Lines]",
          "1340:             protection_level, label, description = filled_permissions[permission]",
          "1341:             if ((not label or not description)",
          "1342:                     and permission in self.permission_module_min_sdk):",
          "1345:                     x['protectionLevel'], min_sdk)",
          "1347:                     protection_level, x['label'], x['description']]",
          "1351:                         protection_level, target_sdk),",
          "1352:                     label, description]",
          "1355:     def get_details_permissions(self):",
          "",
          "[Added Lines]",
          "1496:             protection_level, label, description = filled_permissions[",
          "1497:                 permission",
          "1498:             ]",
          "1499:             if (",
          "1500:                 not label or not description",
          "1501:             ) and permission in self.permission_module_min_sdk:",
          "1504:                     x['protectionLevel'], min_sdk",
          "1505:                 )",
          "1507:                     protection_level,",
          "1508:                     x['label'],",
          "1509:                     x['description'],",
          "1510:                 ]",
          "1514:                         protection_level, target_sdk",
          "1515:                     ),",
          "1516:                     label,",
          "1517:                     description,",
          "1518:                 ]",
          "1521:     def get_details_permissions(self) -> dict[str, list[str]]:",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1367:             if i in self.permission_module:",
          "1368:                 x = self.permission_module[i]",
          "1369:                 l[i] = [x[\"protectionLevel\"], x[\"label\"], x[\"description\"]]",
          "1370:             else:",
          "1374:         return self._fill_deprecated_permissions(l)",
          "1377:         \"\"\"",
          "1378:         Returns requested permissions declared within AOSP project.",
          "",
          "[Removed Lines]",
          "1371:                 # FIXME: the permission might be signature, if it is defined by the app itself!",
          "1372:                 l[i] = [\"normal\", \"Unknown permission from android reference\",",
          "1373:                         \"Unknown permission from android reference\"]",
          "1376:     def get_requested_aosp_permissions(self):",
          "",
          "[Added Lines]",
          "1536:             elif i in self.declared_permissions:",
          "1537:                 protectionLevel_hex = self.declared_permissions[i][",
          "1538:                     \"protectionLevel\"",
          "1539:                 ]",
          "1540:                 protectionLevel = protection_flags_to_attributes[",
          "1541:                     protectionLevel_hex",
          "1542:                 ]",
          "1543:                 l[i] = [",
          "1544:                     protectionLevel,",
          "1545:                     \"Unknown permission from android reference\",",
          "1546:                     \"Unknown permission from android reference\",",
          "1547:                 ]",
          "1549:                 # Is there a valid case not belonging to the above two?",
          "1550:                 logger.info(f\"Unknown permission {i}\")",
          "1553:     def get_requested_aosp_permissions(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "1388:                 aosp_permissions.append(perm)",
          "1389:         return aosp_permissions",
          "1392:         \"\"\"",
          "1393:         Returns requested aosp permissions with details.",
          "",
          "[Removed Lines]",
          "1391:     def get_requested_aosp_permissions_details(self):",
          "",
          "[Added Lines]",
          "1568:     def get_requested_aosp_permissions_details(self) -> dict[str, list[str]]:",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "1403:                 continue",
          "1404:         return l",
          "1407:         \"\"\"",
          "1408:         Returns list of requested permissions not declared within AOSP project.",
          "",
          "[Removed Lines]",
          "1406:     def get_requested_third_party_permissions(self):",
          "",
          "[Added Lines]",
          "1583:     def get_requested_third_party_permissions(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "1416:                 third_party_permissions.append(perm)",
          "1417:         return third_party_permissions",
          "1420:         \"\"\"",
          "1421:         Returns list of the declared permissions.",
          "",
          "[Removed Lines]",
          "1419:     def get_declared_permissions(self):",
          "",
          "[Added Lines]",
          "1596:     def get_declared_permissions(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "1424:         \"\"\"",
          "1425:         return list(self.declared_permissions.keys())",
          "1428:         \"\"\"",
          "1429:         Returns declared permissions with the details.",
          "",
          "[Removed Lines]",
          "1427:     def get_declared_permissions_details(self):",
          "",
          "[Added Lines]",
          "1604:     def get_declared_permissions_details(self) -> dict[str, list[str]]:",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "1432:         \"\"\"",
          "1433:         return self.declared_permissions",
          "1436:         \"\"\"",
          "1440:         \"\"\"",
          "1441:         return self.get_attribute_value(\"uses-sdk\", \"maxSdkVersion\")",
          "1444:         \"\"\"",
          "1448:         \"\"\"",
          "1449:         return self.get_attribute_value(\"uses-sdk\", \"minSdkVersion\")",
          "1452:         \"\"\"",
          "1456:         \"\"\"",
          "1457:         return self.get_attribute_value(\"uses-sdk\", \"targetSdkVersion\")",
          "1460:         \"\"\"",
          "1468:         \"\"\"",
          "1469:         target_sdk_version = self.get_target_sdk_version()",
          "1470:         if not target_sdk_version:",
          "",
          "[Removed Lines]",
          "1435:     def get_max_sdk_version(self):",
          "1437:             Return the android:maxSdkVersion attribute",
          "1439:             :rtype: string",
          "1443:     def get_min_sdk_version(self):",
          "1445:             Return the android:minSdkVersion attribute",
          "1447:             :rtype: string",
          "1451:     def get_target_sdk_version(self):",
          "1453:             Return the android:targetSdkVersion attribute",
          "1455:             :rtype: string",
          "1459:     def get_effective_target_sdk_version(self):",
          "1461:             Return the effective targetSdkVersion, always returns int > 0.",
          "1463:             If the targetSdkVersion is not set, it defaults to 1.  This is",
          "1464:             set based on defaults as defined in:",
          "1465:             https://developer.android.com/guide/topics/manifest/uses-sdk-element.html",
          "1467:             :rtype: int",
          "",
          "[Added Lines]",
          "1612:     def get_max_sdk_version(self) -> str:",
          "1614:         Return the android:maxSdkVersion attribute",
          "1616:         :rtype: string",
          "1620:     def get_min_sdk_version(self) -> str:",
          "1622:         Return the android:minSdkVersion attribute",
          "1624:         :rtype: string",
          "1628:     def get_target_sdk_version(self) -> str:",
          "1630:         Return the android:targetSdkVersion attribute",
          "1632:         :rtype: string",
          "1636:     def get_effective_target_sdk_version(self) -> int:",
          "1638:         Return the effective targetSdkVersion, always returns int > 0.",
          "1640:         If the targetSdkVersion is not set, it defaults to 1.  This is",
          "1641:         set based on defaults as defined in:",
          "1642:         https://developer.android.com/guide/topics/manifest/uses-sdk-element.html",
          "1644:         :rtype: int",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "1474:         except (ValueError, TypeError):",
          "1475:             return 1",
          "1478:         \"\"\"",
          "1482:         \"\"\"",
          "1483:         return list(self.get_all_attribute_value(\"uses-library\", \"name\"))",
          "1486:         \"\"\"",
          "1487:         Return a list of all android:names found for the tag uses-feature",
          "1488:         in the AndroidManifest.xml",
          "",
          "[Removed Lines]",
          "1477:     def get_libraries(self):",
          "1479:             Return the android:name attributes for libraries",
          "1481:             :rtype: list",
          "1485:     def get_features(self):",
          "",
          "[Added Lines]",
          "1654:     def get_libraries(self) -> list[str]:",
          "1656:         Return the android:name attributes for libraries",
          "1658:         :rtype: list",
          "1662:     def get_features(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "1491:         \"\"\"",
          "1492:         return list(self.get_all_attribute_value(\"uses-feature\", \"name\"))",
          "1495:         \"\"\"",
          "1496:         Checks if this application is build for wearables by",
          "1497:         checking if it uses the feature 'android.hardware.type.watch'",
          "",
          "[Removed Lines]",
          "1494:     def is_wearable(self):",
          "",
          "[Added Lines]",
          "1671:     def is_wearable(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "1504:         \"\"\"",
          "1505:         return 'android.hardware.type.watch' in self.get_features()",
          "1508:         \"\"\"",
          "1509:         Checks if this application is build for TV (Leanback support)",
          "1510:         by checkin if it uses the feature 'android.software.leanback'",
          "",
          "[Removed Lines]",
          "1507:     def is_leanback(self):",
          "",
          "[Added Lines]",
          "1684:     def is_leanback(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "1513:         \"\"\"",
          "1514:         return 'android.software.leanback' in self.get_features()",
          "1517:         \"\"\"",
          "1518:         Checks if this application does not require a touchscreen,",
          "1519:         as this is the rule to get into the TV section of the Play Store",
          "",
          "[Removed Lines]",
          "1516:     def is_androidtv(self):",
          "",
          "[Added Lines]",
          "1693:     def is_androidtv(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "1522:         :returns: True if 'android.hardware.touchscreen' is not required, False otherwise",
          "1523:         \"\"\"",
          "1527:         \"\"\"",
          "1528:         Return the DER coded X.509 certificate from the signature file.",
          "1530:         :param filename: Signature filename in APK",
          "1532:         \"\"\"",
          "1533:         pkcs7message = self.get_file(filename)",
          "1540:         \"\"\"",
          "1541:         Return a X.509 certificate object by giving the name in the apk file",
          "",
          "[Removed Lines]",
          "1524:         return self.get_attribute_value('uses-feature', 'name', required=\"false\", name=\"android.hardware.touchscreen\") == \"android.hardware.touchscreen\"",
          "1526:     def get_certificate_der(self, filename):",
          "1531:         :returns: DER coded X.509 certificate as binary",
          "1535:         pkcs7obj = cms.ContentInfo.load(pkcs7message)",
          "1536:         cert = pkcs7obj['content']['certificates'][0].chosen.dump()",
          "1537:         return cert",
          "1539:     def get_certificate(self, filename):",
          "",
          "[Added Lines]",
          "1701:         return (",
          "1702:             self.get_attribute_value(",
          "1703:                 'uses-feature',",
          "1704:                 'name',",
          "1705:                 required=\"false\",",
          "1706:                 name=\"android.hardware.touchscreen\",",
          "1707:             )",
          "1708:             == \"android.hardware.touchscreen\"",
          "1709:         )",
          "1711:     def get_certificate_der(",
          "1712:         self, filename: str, max_sdk_version: int = None",
          "1713:     ) -> Union[bytes, None]:",
          "1716:         If minSdkVersion is prior to Android N only the first SignerInfo is used.",
          "1717:         If signed attributes are present, they are taken into account",
          "1718:         Note that unsupported critical extensions and key usage are not verified!",
          "1719:         https://android.googlesource.com/platform/tools/apksig/+/refs/tags/platform-tools-34.0.5/src/main/java/com/android/apksig/internal/apk/v1/V1SchemeVerifier.java#668",
          "1722:         :param max_sdk_version: An optional integer parameter for the max sdk version",
          "1723:         :returns: DER coded X.509 certificate as binary or None",
          "1726:         # Get the signature",
          "1728:         # Get the .SF",
          "1729:         sf_filename = os.path.splitext(filename)[0] + '.SF'",
          "1730:         sf_object = self.get_file(sf_filename)",
          "1731:         # Load the signature",
          "1732:         signed_data = cms.ContentInfo.load(pkcs7message)",
          "1733:         # Locate the SignerInfo structure",
          "1734:         signer_infos = signed_data['content']['signer_infos']",
          "1735:         if not signer_infos:",
          "1736:             logger.error(",
          "1737:                 'No signer information found in the PKCS7 object. The APK may not be properly signed.'",
          "1738:             )",
          "1739:             return None",
          "1741:         # Prior to Android N, Android attempts to verify only the first SignerInfo. From N onwards, Android attempts",
          "1742:         # to verify all SignerInfos and then picks the first verified SignerInfo.",
          "1743:         min_sdk_version = self.get_min_sdk_version()",
          "1744:         if (",
          "1745:             min_sdk_version is None or int(min_sdk_version) < 24",
          "1746:         ):  # AndroidSdkVersion.N",
          "1747:             logger.info(",
          "1748:                 f\"minSdkVersion: {min_sdk_version} is less than 24. Getting the first signerInfo only!\"",
          "1749:             )",
          "1750:             unverified_signer_infos_to_try = [signer_infos[0]]",
          "1751:         else:",
          "1752:             unverified_signer_infos_to_try = signer_infos",
          "1754:         # Extract certificates from the PKCS7 object",
          "1755:         certificates = signed_data['content']['certificates']",
          "1756:         return_certificate = None",
          "1757:         list_certificates_verified = []",
          "1758:         for signer_info in unverified_signer_infos_to_try:",
          "1759:             try:",
          "1760:                 matching_certificate_verified = (",
          "1761:                     self.verify_signer_info_against_sig_file(",
          "1762:                         signed_data,",
          "1763:                         certificates,",
          "1764:                         signer_info,",
          "1765:                         sf_object,",
          "1766:                         max_sdk_version,",
          "1767:                     )",
          "1768:                 )",
          "1769:             except (ValueError, TypeError, OSError, InvalidSignature) as e:",
          "1770:                 logger.error(",
          "1771:                     f\"The following exception was raised while verifying the certificate: {e}\"",
          "1772:                 )",
          "1773:                 return (",
          "1774:                     None  # the validation stops due to the exception raised!",
          "1775:                 )",
          "1776:             if matching_certificate_verified is not None:",
          "1777:                 list_certificates_verified.append(",
          "1778:                     matching_certificate_verified",
          "1779:                 )",
          "1780:         if not list_certificates_verified:",
          "1781:             logger.error(",
          "1782:                 f\"minSdkVersion: {min_sdk_version}, # of SignerInfos: {len(unverified_signer_infos_to_try)}. None Verified!\"",
          "1783:             )",
          "1784:         else:",
          "1785:             return_certificate = list_certificates_verified[0]",
          "1786:         return return_certificate",
          "1788:     def verify_signer_info_against_sig_file(",
          "1789:         self,",
          "1790:         signed_data,",
          "1791:         certificates,",
          "1792:         signer_info,",
          "1793:         sf_object,",
          "1794:         max_sdk_version,",
          "1795:     ):",
          "1796:         matching_certificate = self.find_certificate(certificates, signer_info)",
          "1797:         matching_certificate_verified = None",
          "1798:         digest_algorithm, crypto_hash_algorithm = self.get_hash_algorithm(",
          "1799:             signer_info",
          "1800:         )",
          "1801:         if matching_certificate is None:",
          "1802:             raise ValueError(",
          "1803:                 \"Signing certificate referenced in SignerInfo not found in SignedData\"",
          "1804:             )",
          "1805:         else:",
          "1806:             if signer_info['signed_attrs'].native:",
          "1807:                 logger.info(\"Signed Attributes detected!\")",
          "1808:                 signed_attrs = signer_info['signed_attrs']",
          "1809:                 signed_attrs_dict = OrderedDict()",
          "1810:                 for attr in signed_attrs:",
          "1811:                     if attr['type'].dotted in signed_attrs_dict:",
          "1812:                         raise ValueError(",
          "1813:                             f\"Duplicate signed attribute: {attr['type'].dotted}\"",
          "1814:                         )",
          "1815:                     signed_attrs_dict[attr['type'].dotted] = attr['values']",
          "1817:                 # Check content type attribute (for Android N and newer)",
          "1818:                 if max_sdk_version is None or int(max_sdk_version) >= 24:",
          "1819:                     content_type_oid = (",
          "1820:                         '1.2.840.113549.1.9.3'  # OID for contentType",
          "1821:                     )",
          "1822:                     if content_type_oid not in signed_attrs_dict:",
          "1823:                         raise ValueError(",
          "1824:                             \"No Content Type in signed attributes\"",
          "1825:                         )",
          "1826:                     content_type = signed_attrs_dict[content_type_oid][",
          "1827:                         0",
          "1828:                     ].native",
          "1829:                     if (",
          "1830:                         content_type",
          "1831:                         != signed_data['content']['encap_content_info'][",
          "1832:                             'content_type'",
          "1833:                         ].native",
          "1834:                     ):",
          "1835:                         logger.error(",
          "1836:                             \"Content Type mismatch. Continuing to next SignerInfo, if any.\"",
          "1837:                         )",
          "1838:                         return None",
          "1840:                 # Check message digest attribute",
          "1841:                 message_digest_oid = (",
          "1842:                     '1.2.840.113549.1.9.4'  # OID for messageDigest",
          "1843:                 )",
          "1844:                 if message_digest_oid not in signed_attrs_dict:",
          "1845:                     raise ValueError(\"No content digest in signed attributes\")",
          "1846:                 expected_signature_file_digest = signed_attrs_dict[",
          "1847:                     message_digest_oid",
          "1848:                 ][0].native",
          "1849:                 hash_algo = digest_algorithm()",
          "1850:                 hash_algo.update(sf_object)",
          "1851:                 actual_digest = hash_algo.digest()",
          "1853:                 # Compare digests",
          "1854:                 if actual_digest != expected_signature_file_digest:",
          "1855:                     logger.error(",
          "1856:                         \"Digest mismatch. Continuing to next SignerInfo, if any.\"",
          "1857:                     )",
          "1858:                     return None",
          "1860:                 signed_attrs_dump = signed_attrs.dump()",
          "1861:                 # Modify the first byte to 0x31 for UNIVERSAL SET",
          "1862:                 signed_attrs_dump = b'\\x31' + signed_attrs_dump[1:]",
          "1863:                 matching_certificate_verified = self.verify_signature(",
          "1864:                     signer_info,",
          "1865:                     matching_certificate,",
          "1866:                     signed_attrs_dump,",
          "1867:                     crypto_hash_algorithm,",
          "1868:                 )",
          "1869:             else:",
          "1870:                 matching_certificate_verified = self.verify_signature(",
          "1871:                     signer_info,",
          "1872:                     matching_certificate,",
          "1873:                     sf_object,",
          "1874:                     crypto_hash_algorithm,",
          "1875:                 )",
          "1876:         return matching_certificate_verified",
          "1878:     @staticmethod",
          "1879:     def verify_signature(",
          "1880:         signer_info, matching_certificate, signed_data, crypto_hash_algorithm",
          "1881:     ):",
          "1882:         matching_certificate_verified = None",
          "1883:         signature = signer_info['signature'].native",
          "1885:         # Load the certificate using asn1crypto as it can handle more cases (v1-only-with-rsa-1024-cert-not-der.apk)",
          "1886:         cert = x509.Certificate.load(matching_certificate.chosen.dump())",
          "1887:         public_key_info = cert.public_key",
          "1889:         # Convert the ASN.1 public key to a cryptography-compatible object",
          "1890:         public_key_der = public_key_info.dump()",
          "1891:         public_key = serialization.load_der_public_key(",
          "1892:             public_key_der, backend=default_backend()",
          "1893:         )",
          "1895:         try:",
          "1896:             # RSA Key",
          "1897:             if isinstance(public_key, rsa.RSAPublicKey):",
          "1898:                 public_key.verify(",
          "1899:                     signature,",
          "1900:                     signed_data,",
          "1901:                     padding.PKCS1v15(),",
          "1902:                     crypto_hash_algorithm(),",
          "1903:                 )",
          "1905:             # DSA Key",
          "1906:             elif isinstance(public_key, dsa.DSAPublicKey):",
          "1907:                 public_key.verify(",
          "1908:                     signature, signed_data, crypto_hash_algorithm()",
          "1909:                 )",
          "1911:             # EC Key",
          "1912:             elif isinstance(public_key, ec.EllipticCurvePublicKey):",
          "1913:                 public_key.verify(",
          "1914:                     signature, signed_data, ec.ECDSA(crypto_hash_algorithm())",
          "1915:                 )",
          "1917:             else:",
          "1918:                 raise ValueError(",
          "1919:                     f\"Unsupported key algorithm: {public_key.__class__.__name__.lower()}\"",
          "1920:                 )",
          "1922:             # If verification succeeds, return the certificate",
          "1923:             matching_certificate_verified = matching_certificate.chosen.dump()",
          "1925:         except InvalidSignature:",
          "1926:             logger.info(",
          "1927:                 f\"The public key of the certificate: {hashlib.sha256(matching_certificate.chosen.dump()).hexdigest()} \"",
          "1928:                 f\"is not associated with the signature!\"",
          "1929:             )",
          "1931:         return matching_certificate_verified",
          "1933:     @staticmethod",
          "1934:     def get_hash_algorithm(signer_info):",
          "1935:         # Determine the hash algorithm from the SignerInfo",
          "1936:         digest_algorithm = signer_info['digest_algorithm']['algorithm'].native",
          "1937:         # Map the digest algorithm to a hash function",
          "1938:         hash_algorithms = {",
          "1939:             'md5': (md5, hashes.MD5),",
          "1940:             'sha1': (sha1, hashes.SHA1),",
          "1941:             'sha224': (sha224, hashes.SHA224),",
          "1942:             'sha256': (sha256, hashes.SHA256),",
          "1943:             'sha384': (sha384, hashes.SHA384),",
          "1944:             'sha512': (sha512, hashes.SHA512),",
          "1945:         }",
          "1946:         if digest_algorithm not in hash_algorithms:",
          "1947:             raise ValueError(f\"Unsupported hash algorithm: {digest_algorithm}\")",
          "1948:         return hash_algorithms[digest_algorithm]",
          "1950:     def find_certificate(self, signed_data_certificates, signer_info):",
          "1951:         \"\"\"",
          "1952:         From the bag of certs, obtain the certificate referenced by the SignerInfo.",
          "1954:         Args:",
          "1955:             signed_data_certificates: List of certificates in the SignedData.",
          "1956:             signer_info: SignerInfo object containing the issuer and serial number reference.",
          "1958:         Returns:",
          "1959:             The matching certificate if found, otherwise None.",
          "1960:         \"\"\"",
          "1961:         matching_certificate = None",
          "1962:         issuer_and_serial_number = signer_info['sid']",
          "1963:         issuer_str = self.canonical_name(",
          "1964:             issuer_and_serial_number.chosen['issuer']",
          "1965:         )",
          "1966:         serial_number = issuer_and_serial_number.native['serial_number']",
          "1968:         # # Create a x509.Name object for the issuer in the SignerInfo",
          "1969:         # issuer_name = x509.Name.build(issuer)",
          "1970:         # issuer_str = self.canonical_name(issuer_name)",
          "1972:         for cert in signed_data_certificates:",
          "1973:             if cert.name == 'certificate':",
          "1974:                 cert_issuer = self.canonical_name(",
          "1975:                     cert.chosen['tbs_certificate']['issuer']",
          "1976:                 )",
          "1977:                 cert_serial_number = cert.native['tbs_certificate'][",
          "1978:                     'serial_number'",
          "1979:                 ]",
          "1981:                 # Compare the canonical string representations of the issuers and the serial numbers",
          "1982:                 if (",
          "1983:                     cert_issuer == issuer_str",
          "1984:                     and cert_serial_number == serial_number",
          "1985:                 ):",
          "1986:                     matching_certificate = cert",
          "1987:                     break",
          "1989:         return matching_certificate",
          "1991:     def get_certificate(self, filename: str) -> Union[x509.Certificate, None]:",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "1544:         :returns: a :class:`Certificate` certificate",
          "1545:         \"\"\"",
          "1546:         cert = self.get_certificate_der(filename)",
          "1549:         return certificate",
          "1552:         \"\"\"",
          "1562:         \"\"\"",
          "1563:         zout = zipfile.ZipFile(filename, 'w')",
          "",
          "[Removed Lines]",
          "1547:         certificate = x509.Certificate.load(cert)",
          "1551:     def new_zip(self, filename, deleted_files=None, new_files={}):",
          "1553:             Create a new zip file",
          "1555:             :param filename: the output filename of the zip",
          "1556:             :param deleted_files: a regex pattern to remove specific file",
          "1557:             :param new_files: a dictionnary of new files",
          "1559:             :type filename: string",
          "1560:             :type deleted_files: None or a string",
          "1561:             :type new_files: a dictionnary (key:filename, value:content of the file)",
          "",
          "[Added Lines]",
          "1999:         if cert:",
          "2000:             certificate = x509.Certificate.load(cert)",
          "2001:         else:",
          "2002:             certificate = None",
          "2005:     def canonical_name(self, name: Any, android: bool = False) -> str:",
          "2006:         \"\"\"",
          "2013:          Canonical representation of x509.Name as str (with raw control characters",
          "2014:         in places those are not stripped by normalisation).",
          "2015:         \"\"\"",
          "2016:         # return \",\".join(\"+\".join(f\"{t}:{v}\" for _, t, v in avas) for avas in self.comparison_name(name))",
          "2017:         return \",\".join(",
          "2018:             \"+\".join(f\"{t}={v}\" for t, v in avas)",
          "2019:             for avas in self.comparison_name(name, android=android)",
          "2020:         )",
          "2022:     def comparison_name(",
          "2023:         self, name: x509.Name, *, android: bool = False",
          "2024:     ) -> List[List[Tuple[str, str]]]:",
          "2025:         \"\"\"",
          "2032:         Canonical representation of x509.Name as nested list.",
          "2034:         Returns a list of RDNs which are a list of AVAs which are a (type, value)",
          "2035:         tuple, where type is the standard name or dotted OID, and value is the",
          "2036:         normalised string representation of the value.",
          "2039:         return [",
          "2040:             [(t, nv) for _, t, nv, _ in avas]",
          "2041:             for avas in self.x509_ordered_name(name, android=android)",
          "2042:         ]",
          "2044:     @staticmethod",
          "2045:     def x509_ordered_name(",
          "2046:         name: x509.Name,",
          "2048:         android: bool = False,",
          "2049:     ) -> List[List[Tuple[int, str, str, str]]]:",
          "2050:         \"\"\"",
          "2057:         Representation of x509.Name as nested list, in canonical ordering (but also",
          "2058:         including non-canonical pre-normalised string values).",
          "2060:         Returns a list of RDNs which are a list of AVAs which are a (oid, type,",
          "2061:         normalised_value, esc_value) tuple, where oid is 0 for standard names and 1",
          "2062:         for dotted OIDs, type is the standard name or dotted OID, normalised_value",
          "2063:         is the normalised string representation of the value, and esc_value is the",
          "2064:         string value before normalisation (but after escaping).",
          "2066:         NB: control characters are not escaped, only characters in \",+<>;\\\"\\\\\" and",
          "2067:         \"#\" at the start (before \"whitespace\" trimming) are.",
          "2069:         https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/security/auth/x500/X500Principal.html#getName(java.lang.String)",
          "2070:         https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/AVA.java#L805",
          "2071:         https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/RDN.java#L472",
          "2072:         https://android.googlesource.com/platform/libcore/+/refs/heads/android14-release/ojluni/src/main/java/sun/security/x509/RDN.java#481",
          "2073:         \"\"\"",
          "2075:         def key(",
          "2076:             ava: Tuple[int, str, str, str]",
          "2077:         ) -> Tuple[int, Union[str, List[int]], str]:",
          "2078:             o, t, nv, _ = ava",
          "2079:             if android and o:",
          "2080:                 return o, [int(x) for x in t.split(\".\")], nv",
          "2081:             return o, t, nv",
          "2083:         DS, U8, PS = (",
          "2084:             x509.DirectoryString,",
          "2085:             x509.UTF8String,",
          "2086:             x509.PrintableString,",
          "2087:         )",
          "2088:         oids = {",
          "2089:             \"2.5.4.3\": (\"common_name\", \"cn\"),",
          "2090:             \"2.5.4.6\": (\"country_name\", \"c\"),",
          "2091:             \"2.5.4.7\": (\"locality_name\", \"l\"),",
          "2092:             \"2.5.4.8\": (\"state_or_province_name\", \"st\"),",
          "2093:             \"2.5.4.9\": (\"street_address\", \"street\"),",
          "2094:             \"2.5.4.10\": (\"organization_name\", \"o\"),",
          "2095:             \"2.5.4.11\": (\"organizational_unit_name\", \"ou\"),",
          "2096:             \"0.9.2342.19200300.100.1.1\": (\"user_id\", \"uid\"),",
          "2097:             \"0.9.2342.19200300.100.1.25\": (\"domain_component\", \"dc\"),",
          "2098:         }",
          "2099:         esc = {ord(c): f\"\\\\{c}\" for c in \",+<>;\\\"\\\\\"}",
          "2100:         cws = \"\".join(",
          "2101:             chr(i) for i in range(32 + 1)",
          "2102:         )  # control (but not esc) and whitespace",
          "2103:         data = []",
          "2104:         for rdn in reversed(name.chosen):",
          "2105:             avas = []",
          "2106:             for ava in rdn:",
          "2107:                 at, av = ava[\"type\"], ava[\"value\"]",
          "2108:                 if at.dotted in oids:",
          "2109:                     o, t = 0, oids[at.dotted][1]  # order standard before OID",
          "2110:                 else:",
          "2111:                     o, t = 1, at.dotted",
          "2112:                 if o or not (",
          "2113:                     isinstance(av, DS) and isinstance(av.chosen, (U8, PS))",
          "2114:                 ):",
          "2115:                     ev = nv = \"#\" + binascii.hexlify(av.dump()).decode()",
          "2116:                 else:",
          "2117:                     ev = (av.native or \"\").translate(esc)",
          "2118:                     if ev.startswith(\"#\"):",
          "2119:                         ev = \"\\\\\" + ev",
          "2120:                     nv = unicodedata.normalize(",
          "2121:                         \"NFKD\",",
          "2122:                         re.sub(r\" +\", \" \", ev).strip(cws).upper().lower(),",
          "2123:                     )",
          "2124:                 avas.append((o, t, nv, ev))",
          "2125:             data.append(sorted(avas, key=key))",
          "2126:         return data",
          "2128:     def new_zip(",
          "2129:         self,",
          "2130:         filename: str,",
          "2131:         deleted_files: Union[str, None] = None,",
          "2132:         new_files: dict = {},",
          "2133:     ) -> None:",
          "2134:         \"\"\"",
          "2135:         Create a new zip file",
          "2137:         :param filename: the output filename of the zip",
          "2138:         :param deleted_files: a regex pattern to remove specific file",
          "2139:         :param new_files: a dictionnary of new files",
          "2141:         :type filename: string",
          "2142:         :type deleted_files: None or a string",
          "2143:         :type new_files: a dictionnary (key:filename, value:content of the file)",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "1589:                 zout.writestr(item, buffer)",
          "1590:         zout.close()",
          "1593:         \"\"\"",
          "1597:         \"\"\"",
          "1598:         try:",
          "1599:             return self.axml[\"AndroidManifest.xml\"]",
          "1600:         except KeyError:",
          "1601:             return None",
          "1604:         \"\"\"",
          "1605:         Return the parsed xml object which corresponds to the AndroidManifest.xml file",
          "",
          "[Removed Lines]",
          "1592:     def get_android_manifest_axml(self):",
          "1594:             Return the :class:`AXMLPrinter` object which corresponds to the AndroidManifest.xml file",
          "1596:             :rtype: :class:`~androguard.core.bytecodes.axml.AXMLPrinter`",
          "1603:     def get_android_manifest_xml(self):",
          "",
          "[Added Lines]",
          "2174:     def get_android_manifest_axml(self) -> Union[AXMLPrinter, None]:",
          "2176:         Return the :class:`AXMLPrinter` object which corresponds to the AndroidManifest.xml file",
          "2178:         :rtype: :class:`~androguard.core.axml.AXMLPrinter`",
          "2185:     def get_android_manifest_xml(self) -> Union[lxml.etree.Element, None]:",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "1611:         except KeyError:",
          "1612:             return None",
          "1615:         \"\"\"",
          "1619:         \"\"\"",
          "1620:         try:",
          "1621:             return self.arsc[\"resources.arsc\"]",
          "",
          "[Removed Lines]",
          "1614:     def get_android_resources(self):",
          "1616:         Return the :class:`~androguard.core.bytecodes.axml.ARSCParser` object which corresponds to the resources.arsc file",
          "1618:         :rtype: :class:`~androguard.core.bytecodes.axml.ARSCParser`",
          "",
          "[Added Lines]",
          "2196:     def get_android_resources(self) -> Union[ARSCParser, None]:",
          "2198:         Return the :class:`~androguard.core.axml.ARSCParser` object which corresponds to the resources.arsc file",
          "2200:         :rtype: :class:`~androguard.core.axml.ARSCParser`",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "1624:                 # There is a rare case, that no resource file is supplied.",
          "1625:                 # Maybe it was added manually, thus we check here",
          "1626:                 return None",
          "1628:             return self.arsc[\"resources.arsc\"]",
          "1631:         \"\"\"",
          "1632:         Returns true if any of v1, v2, or v3 signatures were found.",
          "1633:         \"\"\"",
          "1637:         \"\"\"",
          "1638:         Returns true if a v1 / JAR signature was found.",
          "",
          "[Removed Lines]",
          "1627:             self.arsc[\"resources.arsc\"] = ARSCParser(self.zip.read(\"resources.arsc\"))",
          "1630:     def is_signed(self):",
          "1634:         return self.is_signed_v1() or self.is_signed_v2() or self.is_signed_v3()",
          "1636:     def is_signed_v1(self):",
          "",
          "[Added Lines]",
          "2209:             self.arsc[\"resources.arsc\"] = ARSCParser(",
          "2210:                 self.zip.read(\"resources.arsc\")",
          "2211:             )",
          "2214:     def is_signed(self) -> bool:",
          "2218:         return (",
          "2219:             self.is_signed_v1() or self.is_signed_v2() or self.is_signed_v3()",
          "2220:         )",
          "2222:     def is_signed_v1(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "1642:         \"\"\"",
          "1643:         return self.get_signature_name() is not None",
          "1646:         \"\"\"",
          "1647:         Returns true of a v2 / APK signature was found.",
          "",
          "[Removed Lines]",
          "1645:     def is_signed_v2(self):",
          "",
          "[Added Lines]",
          "2231:     def is_signed_v2(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "1655:         return self._is_signed_v2",
          "1658:         \"\"\"",
          "1659:         Returns true of a v3 / APK signature was found.",
          "",
          "[Removed Lines]",
          "1657:     def is_signed_v3(self):",
          "",
          "[Added Lines]",
          "2243:     def is_signed_v3(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "1667:         return self._is_signed_v3",
          "1671:         return value",
          "1676:         if not len(digest_bytes):",
          "1677:             return []",
          "",
          "[Removed Lines]",
          "1669:     def read_uint32_le(self, io_stream):",
          "1670:         value, = unpack('<I', io_stream.read(4))",
          "1673:     def parse_signatures_or_digests(self, digest_bytes):",
          "1674:         \"\"\" Parse digests \"\"\"",
          "",
          "[Added Lines]",
          "2255:     def read_uint32_le(self, io_stream) -> int:",
          "2256:         (value,) = unpack('<I', io_stream.read(4))",
          "2259:     def parse_signatures_or_digests(",
          "2260:         self, digest_bytes",
          "2261:     ) -> list[tuple[int, bytes]]:",
          "2262:         \"\"\"Parse digests\"\"\"",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "1691:         return digests",
          "1694:         # Need to find an v2 Block in the APK.",
          "1695:         # The Google Docs gives you the following rule:",
          "1696:         # * go to the end of the ZIP File",
          "",
          "[Removed Lines]",
          "1693:     def parse_v2_v3_signature(self):",
          "",
          "[Added Lines]",
          "2281:     def parse_v2_v3_signature(self) -> None:",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "1715:         while f.tell() > 0:",
          "1716:             f.seek(-1, io.SEEK_CUR)",
          "1718:             if r == self._PK_END_OF_CENTRAL_DIR:",
          "1719:                 # Read central dir",
          "1722:                 # TODO according to the standard we need to check if the",
          "1723:                 # end of central directory is the last item in the zip file",
          "1724:                 # TODO We also need to check if the central dir is exactly",
          "",
          "[Removed Lines]",
          "1717:             r, = unpack('<4s', f.read(4))",
          "1720:                 this_disk, disk_central, this_entries, total_entries, \\",
          "1721:                     size_central, offset_central = unpack('<HHHHII', f.read(16))",
          "",
          "[Added Lines]",
          "2305:             (r,) = unpack('<4s', f.read(4))",
          "2308:                 (",
          "2309:                     this_disk,",
          "2310:                     disk_central,",
          "2311:                     this_entries,",
          "2312:                     total_entries,",
          "2313:                     size_central,",
          "2314:                     offset_central,",
          "2315:                 ) = unpack('<HHHHII', f.read(16))",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "1727:                 # These things should not happen for APKs",
          "1728:                 if this_disk != 0:",
          "1729:                     logger.warning(",
          "1731:                 if disk_central != 0:",
          "1732:                     logger.warning(",
          "1734:                 break",
          "1735:             f.seek(-4, io.SEEK_CUR)",
          "",
          "[Removed Lines]",
          "1730:                         \"This is a multi disk ZIP! Attempting to process its signature anyway!\")",
          "1733:                         \"This is a multi disk ZIP! Attempting to process its signature anyway!\")",
          "",
          "[Added Lines]",
          "2324:                         \"This is a multi disk ZIP! Attempting to process its signature anyway!\"",
          "2325:                     )",
          "2328:                         \"This is a multi disk ZIP! Attempting to process its signature anyway!\"",
          "2329:                     )",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "1738:             return",
          "1740:         f.seek(offset_central)",
          "1742:         f.seek(-4, io.SEEK_CUR)",
          "1743:         if r != self._PK_CENTRAL_DIR:",
          "1744:             raise BrokenAPKError(\"No Central Dir at specified offset\")",
          "",
          "[Removed Lines]",
          "1741:         r, = unpack('<4s', f.read(4))",
          "",
          "[Added Lines]",
          "2337:         (r,) = unpack('<4s', f.read(4))",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "1757:         # go back size_of_blocks + 8 and read size_of_block again",
          "1758:         f.seek(-(size_of_block + 8), io.SEEK_CUR)",
          "1760:         if size_of_block_start != size_of_block:",
          "1761:             raise BrokenAPKError(\"Sizes at beginning and and does not match!\")",
          "",
          "[Removed Lines]",
          "1759:         size_of_block_start, = unpack(\"<Q\", f.read(8))",
          "",
          "[Added Lines]",
          "2355:         (size_of_block_start,) = unpack(\"<Q\", f.read(8))",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "1764:         while f.tell() < end_offset - 24:",
          "1765:             size, key = unpack('<QI', f.read(12))",
          "1766:             value = f.read(size - 4)",
          "1769:         # Test if a signature is found",
          "1770:         if self._APK_SIG_KEY_V2_SIGNATURE in self._v2_blocks:",
          "",
          "[Removed Lines]",
          "1767:             self._v2_blocks[key] = value",
          "",
          "[Added Lines]",
          "2363:             if key in self._v2_blocks:",
          "2364:                 # TODO: Store the duplicate V2 Signature blocks and offer a way to show them",
          "2365:                 # https://github.com/androguard/androguard/issues/1030",
          "2366:                 logger.warning(",
          "2367:                     \"Duplicate block ID in APK Signing Block: {}\".format(key)",
          "2368:                 )",
          "2369:             else:",
          "2370:                 self._v2_blocks[key] = value",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "1773:         if self._APK_SIG_KEY_V3_SIGNATURE in self._v2_blocks:",
          "1774:             self._is_signed_v3 = True",
          "1777:         \"\"\"",
          "1778:         Parse the V2 signing block and extract all features",
          "1779:         \"\"\"",
          "",
          "[Removed Lines]",
          "1776:     def parse_v3_signing_block(self):",
          "",
          "[Added Lines]",
          "2379:     def parse_v3_signing_block(self) -> None:",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "1805:         #    * publickey",
          "1806:         size_sequence = self.read_uint32_le(block)",
          "1807:         if size_sequence + 4 != len(block_bytes):",
          "1810:         while block.tell() < len(block_bytes):",
          "1811:             off_signer = block.tell()",
          "",
          "[Removed Lines]",
          "1808:             raise BrokenAPKError(\"size of sequence and blocksize does not match\")",
          "",
          "[Added Lines]",
          "2411:             raise BrokenAPKError(",
          "2412:                 \"size of sequence and blocksize does not match\"",
          "2413:             )",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "1862:             publickey = block.read(len_publickey)",
          "1864:             signer = APKV3Signer()",
          "1866:             signer.signed_data = signed_data_object",
          "1867:             signer.signatures = sigs",
          "1868:             signer.public_key = publickey",
          "",
          "[Removed Lines]",
          "1865:             signer._bytes = view[off_signer:off_signer + size_signer]",
          "",
          "[Added Lines]",
          "2470:             signer._bytes = view[off_signer: off_signer + size_signer]",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "1872:             self._v3_signing_data.append(signer)",
          "1875:         \"\"\"",
          "1876:         Parse the V2 signing block and extract all features",
          "1877:         \"\"\"",
          "",
          "[Removed Lines]",
          "1874:     def parse_v2_signing_block(self):",
          "",
          "[Added Lines]",
          "2479:     def parse_v2_signing_block(self) -> None:",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "1901:         size_sequence = self.read_uint32_le(block)",
          "1902:         if size_sequence + 4 != len(block_bytes):",
          "1905:         while block.tell() < len(block_bytes):",
          "1906:             off_signer = block.tell()",
          "",
          "[Removed Lines]",
          "1903:             raise BrokenAPKError(\"size of sequence and blocksize does not match\")",
          "",
          "[Added Lines]",
          "2508:             raise BrokenAPKError(",
          "2509:                 \"size of sequence and blocksize does not match\"",
          "2510:             )",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "1946:             publickey = block.read(len_publickey)",
          "1948:             signer = APKV2Signer()",
          "1950:             signer.signed_data = signed_data_object",
          "1951:             signer.signatures = sigs",
          "1952:             signer.public_key = publickey",
          "1954:             self._v2_signing_data.append(signer)",
          "1957:         \"\"\"",
          "1958:         Return a list of DER coded X.509 public keys from the v3 signature block",
          "1959:         \"\"\"",
          "",
          "[Removed Lines]",
          "1949:             signer._bytes = view[off_signer:off_signer + size_signer]",
          "1956:     def get_public_keys_der_v3(self):",
          "",
          "[Added Lines]",
          "2556:             signer._bytes = view[off_signer: off_signer + size_signer]",
          "2563:     def get_public_keys_der_v3(self) -> list[bytes]:",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "1969:         return public_keys",
          "1972:         \"\"\"",
          "1973:         Return a list of DER coded X.509 public keys from the v3 signature block",
          "1974:         \"\"\"",
          "",
          "[Removed Lines]",
          "1971:     def get_public_keys_der_v2(self):",
          "",
          "[Added Lines]",
          "2578:     def get_public_keys_der_v2(self) -> list[bytes]:",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "1984:         return public_keys",
          "1987:         \"\"\"",
          "1988:         Return a list of DER coded X.509 certificates from the v3 signature block",
          "1989:         \"\"\"",
          "",
          "[Removed Lines]",
          "1986:     def get_certificates_der_v3(self):",
          "",
          "[Added Lines]",
          "2593:     def get_certificates_der_v3(self) -> list[bytes]:",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "1992:             self.parse_v3_signing_block()",
          "1994:         certs = []",
          "1996:             for cert in signed_data.certificates:",
          "1997:                 certs.append(cert)",
          "1999:         return certs",
          "2002:         \"\"\"",
          "2003:         Return a list of DER coded X.509 certificates from the v3 signature block",
          "2004:         \"\"\"",
          "",
          "[Removed Lines]",
          "1995:         for signed_data in [signer.signed_data for signer in self._v3_signing_data]:",
          "2001:     def get_certificates_der_v2(self):",
          "",
          "[Added Lines]",
          "2602:         for signed_data in [",
          "2603:             signer.signed_data for signer in self._v3_signing_data",
          "2604:         ]:",
          "2610:     def get_certificates_der_v2(self) -> list[bytes]:",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "2007:             self.parse_v2_signing_block()",
          "2009:         certs = []",
          "2011:             for cert in signed_data.certificates:",
          "2012:                 certs.append(cert)",
          "2014:         return certs",
          "2017:         \"\"\"",
          "2018:         Return a list of :class:`asn1crypto.keys.PublicKeyInfo` which are found",
          "2019:         in the v3 signing block.",
          "2020:         \"\"\"",
          "2024:         \"\"\"",
          "2025:         Return a list of :class:`asn1crypto.keys.PublicKeyInfo` which are found",
          "2026:         in the v2 signing block.",
          "2027:         \"\"\"",
          "2031:         \"\"\"",
          "2032:         Return a list of :class:`asn1crypto.x509.Certificate` which are found",
          "2033:         in the v3 signing block.",
          "2034:         Note that we simply extract all certificates regardless of the signer.",
          "2035:         Therefore this is just a list of all certificates found in all signers.",
          "2036:         \"\"\"",
          "2040:         \"\"\"",
          "2041:         Return a list of :class:`asn1crypto.x509.Certificate` which are found",
          "2042:         in the v2 signing block.",
          "2043:         Note that we simply extract all certificates regardless of the signer.",
          "2044:         Therefore this is just a list of all certificates found in all signers.",
          "2045:         \"\"\"",
          "2049:         \"\"\"",
          "2051:         in the META-INF folder (v1 signing).",
          "2054:         \"\"\"",
          "2055:         certs = []",
          "2056:         for x in self.get_signature_names():",
          "2059:         return certs",
          "2062:         \"\"\"",
          "2063:         Return a list of unique :class:`asn1crypto.x509.Certificate` which are found",
          "2064:         in v1, v2 and v3 signing",
          "2065:         Note that we simply extract all certificates regardless of the signer.",
          "2066:         Therefore this is just a list of all certificates found in all signers.",
          "2067:         \"\"\"",
          "2068:         fps = []",
          "2069:         certs = []",
          "2071:             if x.sha256 not in fps:",
          "2072:                 fps.append(x.sha256)",
          "2073:                 certs.append(x)",
          "2074:         return certs",
          "2077:         \"\"\"",
          "2079:         \"\"\"",
          "2080:         if self.get_signature_names():",
          "2081:             return self.get_signature_names()[0]",
          "",
          "[Removed Lines]",
          "2010:         for signed_data in [signer.signed_data for signer in self._v2_signing_data]:",
          "2016:     def get_public_keys_v3(self):",
          "2021:         return [keys.PublicKeyInfo.load(pkey) for pkey in self.get_public_keys_der_v3()]",
          "2023:     def get_public_keys_v2(self):",
          "2028:         return [keys.PublicKeyInfo.load(pkey) for pkey in self.get_public_keys_der_v2()]",
          "2030:     def get_certificates_v3(self):",
          "2037:         return [x509.Certificate.load(cert) for cert in self.get_certificates_der_v3()]",
          "2039:     def get_certificates_v2(self):",
          "2046:         return [x509.Certificate.load(cert) for cert in self.get_certificates_der_v2()]",
          "2048:     def get_certificates_v1(self):",
          "2050:         Return a list of :class:`asn1crypto.x509.Certificate` which are found",
          "2052:         Note that we simply extract all certificates regardless of the signer.",
          "2053:         Therefore this is just a list of all certificates found in all signers.",
          "2057:             certs.append(x509.Certificate.load(self.get_certificate_der(x)))",
          "2061:     def get_certificates(self):",
          "2070:         for x in self.get_certificates_v1() + self.get_certificates_v2() + self.get_certificates_v3():",
          "2076:     def get_signature_name(self):",
          "2078:             Return the name of the first signature file found.",
          "",
          "[Added Lines]",
          "2619:         for signed_data in [",
          "2620:             signer.signed_data for signer in self._v2_signing_data",
          "2621:         ]:",
          "2627:     def get_public_keys_v3(self) -> list[keys.PublicKeyInfo]:",
          "2632:         return [",
          "2633:             keys.PublicKeyInfo.load(pkey)",
          "2634:             for pkey in self.get_public_keys_der_v3()",
          "2635:         ]",
          "2637:     def get_public_keys_v2(self) -> list[keys.PublicKeyInfo]:",
          "2642:         return [",
          "2643:             keys.PublicKeyInfo.load(pkey)",
          "2644:             for pkey in self.get_public_keys_der_v2()",
          "2645:         ]",
          "2647:     def get_certificates_v3(self) -> list[x509.Certificate]:",
          "2654:         return [",
          "2655:             x509.Certificate.load(cert)",
          "2656:             for cert in self.get_certificates_der_v3()",
          "2657:         ]",
          "2659:     def get_certificates_v2(self) -> list[x509.Certificate]:",
          "2666:         return [",
          "2667:             x509.Certificate.load(cert)",
          "2668:             for cert in self.get_certificates_der_v2()",
          "2669:         ]",
          "2671:     def get_certificates_v1(self) -> list[Union[x509.Certificate, None]]:",
          "2673:         Return a list of verified :class:`asn1crypto.x509.Certificate` which are found",
          "2678:             cc = self.get_certificate_der(x)",
          "2679:             if cc is not None:",
          "2680:                 certs.append(x509.Certificate.load(cc))",
          "2683:     def get_certificates(self) -> list[x509.Certificate]:",
          "2689:         Exception is v1, for which the certificate returned is verified.",
          "2693:         for x in (",
          "2694:             self.get_certificates_v1()",
          "2695:             + self.get_certificates_v2()",
          "2696:             + self.get_certificates_v3()",
          "2697:         ):",
          "2703:     def get_signature_name(self) -> Union[str, None]:",
          "2705:         Return the name of the first signature file found.",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "2083:             # Unsigned APK",
          "2084:             return None",
          "2087:         \"\"\"",
          "2088:         Return a list of the signature file names (v1 Signature / JAR",
          "2089:         Signature)",
          "",
          "[Removed Lines]",
          "2086:     def get_signature_names(self):",
          "",
          "[Added Lines]",
          "2713:     def get_signature_names(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "2099:                     signatures.append(i)",
          "2100:                 else:",
          "2101:                     logger.warning(",
          "2104:         return signatures",
          "2107:         \"\"\"",
          "2108:         Return the data of the first signature file found (v1 Signature / JAR",
          "2109:         Signature)",
          "",
          "[Removed Lines]",
          "2102:                         \"v1 signature file {} missing .SF file - Partial signature!\".format(i))",
          "2106:     def get_signature(self):",
          "",
          "[Added Lines]",
          "2729:                         \"v1 signature file {} missing .SF file - Partial signature!\".format(",
          "2730:                             i",
          "2731:                         )",
          "2732:                     )",
          "2736:     def get_signature(self) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "2115:         else:",
          "2116:             return None",
          "2119:         \"\"\"",
          "2120:         Return a list of the data of the signature files.",
          "2121:         Only v1 / JAR Signing.",
          "",
          "[Removed Lines]",
          "2118:     def get_signatures(self):",
          "",
          "[Added Lines]",
          "2748:     def get_signatures(self) -> list[bytes]:",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "2132:         return signature_datas",
          "2135:         self.get_files_types()",
          "2137:         print(\"FILES: \")",
          "",
          "[Removed Lines]",
          "2134:     def show(self):",
          "",
          "[Added Lines]",
          "2764:     def show(self) -> None:",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "2184:                 show_Certificate(c)",
          "2188:     \"\"\"",
          "2196:     \"\"\"",
          "2197:     print(\"SHA1 Fingerprint: {}\".format(cert.sha1_fingerprint))",
          "2198:     print(\"SHA256 Fingerprint: {}\".format(cert.sha256_fingerprint))",
          "2204:     \"\"\"Ensure incoming value is always the value, not the resid",
          "2206:     androguard will sometimes return the Android \"resId\" aka",
          "",
          "[Removed Lines]",
          "2187: def show_Certificate(cert, short=False):",
          "2189:         Print Fingerprints, Issuer and Subject of an X509 Certificate.",
          "2191:         :param cert: X509 Certificate to print",
          "2192:         :param short: Print in shortform for DN (Default: False)",
          "2194:         :type cert: :class:`asn1crypto.x509.Certificate`",
          "2195:         :type short: Boolean",
          "2199:     print(\"Issuer: {}\".format(get_certificate_name_string(cert.issuer.native, short=short)))",
          "2200:     print(\"Subject: {}\".format(get_certificate_name_string(cert.subject.native, short=short)))",
          "2203: def ensure_final_value(packageName, arsc, value):",
          "",
          "[Added Lines]",
          "2817: def show_Certificate(cert, short: bool = False) -> None:",
          "2819:     Print Fingerprints, Issuer and Subject of an X509 Certificate.",
          "2821:     :param cert: X509 Certificate to print",
          "2822:     :param short: Print in shortform for DN (Default: False)",
          "2824:     :type cert: :class:`asn1crypto.x509.Certificate`",
          "2825:     :type short: Boolean",
          "2829:     print(",
          "2830:         \"Issuer: {}\".format(",
          "2831:             get_certificate_name_string(cert.issuer.native, short=short)",
          "2832:         )",
          "2833:     )",
          "2834:     print(",
          "2835:         \"Subject: {}\".format(",
          "2836:             get_certificate_name_string(cert.subject.native, short=short)",
          "2837:         )",
          "2838:     )",
          "2841: def ensure_final_value(packageName: str, arsc: ARSCParser, value: str) -> str:",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "2221:                 pass",
          "2222:         return returnValue",
          "2223:     return ''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2864: def get_apkid(apkfile: str) -> tuple[str, str, str]:",
          "2865:     \"\"\"Read (appid, versionCode, versionName) from an APK",
          "2867:     This first tries to do quick binary XML parsing to just get the",
          "2868:     values that are needed.  It will fallback to full androguard",
          "2869:     parsing, which is slow, if it can't find the versionName value or",
          "2870:     versionName is set to a Android String Resource (e.g. an integer",
          "2871:     hex value that starts with @).",
          "2873:     \"\"\"",
          "2874:     logger.debug(\"GET_APKID\")",
          "2876:     if not os.path.exists(apkfile):",
          "2877:         logger.error(\"'{apkfile}' does not exist!\".format(apkfile=apkfile))",
          "2879:     appid = None",
          "2880:     versionCode = None",
          "2881:     versionName = None",
          "2882:     apk = ZipEntry.parse(apkfile, False)",
          "2883:     manifest = apk.read('AndroidManifest.xml')",
          "2884:     axml = AXMLParser(manifest)",
          "2885:     count = 0",
          "2886:     while axml.is_valid():",
          "2887:         _type = next(axml)",
          "2888:         count += 1",
          "2889:         if _type == START_TAG:",
          "2890:             for i in range(0, axml.getAttributeCount()):",
          "2891:                 name = axml.getAttributeName(i)",
          "2892:                 _type = axml.getAttributeValueType(i)",
          "2893:                 _data = axml.getAttributeValueData(i)",
          "2894:                 value = format_value(",
          "2895:                     _type, _data, lambda _: axml.getAttributeValue(i)",
          "2896:                 )",
          "2897:                 if appid is None and name == 'package':",
          "2898:                     appid = value",
          "2899:                 elif versionCode is None and name == 'versionCode':",
          "2900:                     if value.startswith('0x'):",
          "2901:                         versionCode = str(int(value, 16))",
          "2902:                     else:",
          "2903:                         versionCode = value",
          "2904:                 elif versionName is None and name == 'versionName':",
          "2905:                     versionName = value",
          "2907:             if axml.name == 'manifest':",
          "2908:                 break",
          "2909:         elif _type == END_TAG or _type == TEXT or _type == END_DOCUMENT:",
          "2910:             raise RuntimeError(",
          "2911:                 '{path}: <manifest> must be the first element in AndroidManifest.xml'.format(",
          "2912:                     path=apkfile",
          "2913:                 )",
          "2914:             )",
          "2916:     if not versionName or versionName[0] == '@':",
          "2917:         a = APK(apkfile)",
          "2918:         versionName = ensure_final_value(",
          "2919:             a.package, a.get_android_resources(), a.get_androidversion_name()",
          "2920:         )",
          "2921:     if not versionName:",
          "2922:         versionName = ''  # versionName is expected to always be a str",
          "2924:     return appid, versionCode, versionName.strip('\\0')",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py -> mobsf/StaticAnalyzer/tools/androguard4/apkinspector/extract.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "3: import zlib",
          "4: import os",
          "7: def extract_file_based_on_header_info(apk_file, local_header_info, central_directory_info):",
          "8:     \"\"\"",
          "9:     Extracts a single file from the apk_file based on the information provided from the offset and the header_info.",
          "10:     It takes into account that the compression method provided might not be STORED or DEFLATED! The returned",
          "11:     'indicator', shows what compression method was used. Besides the standard STORED/DEFLATE it may return",
          "12:     'DEFLATED_TAMPERED', which means that the compression method found was not DEFLATED(8) but it should have been,",
          "13:     and 'STORED_TAMPERED' which means that the compression method found was not STORED(0) but should have been.",
          "15:     :param apk_file: The APK file e.g. with open('test.apk', 'rb') as apk_file",
          "16:     :type apk_file: bytesIO",
          "17:     :param local_header_info: The local header dictionary info for that specific filename",
          "18:     :type local_header_info: dict",
          "19:     :param central_directory_info: The central directory entry for that specific filename",
          "20:     :type central_directory_info: dict",
          "21:     :return: Returns the actual extracted data for that file along with an indication of whether a static analysis evasion technique was used or not.",
          "22:     :rtype: set(bytes, str)",
          "23:     \"\"\"",
          "24:     filename_length = local_header_info[\"file_name_length\"]",
          "25:     if local_header_info[\"compressed_size\"] == 0 or local_header_info[\"uncompressed_size\"] == 0:",
          "26:         compressed_size = central_directory_info[\"compressed_size\"]",
          "27:         uncompressed_size = central_directory_info[\"uncompressed_size\"]",
          "28:     else:",
          "29:         compressed_size = local_header_info[\"compressed_size\"]",
          "30:         uncompressed_size = local_header_info[\"uncompressed_size\"]",
          "32:     extra_field_length = local_header_info[\"extra_field_length\"]",
          "33:     compression_method = local_header_info[\"compression_method\"]",
          "34:     # Skip the offset + local header to reach the compressed data",
          "35:     local_header_size = 30  # Size of the local header in bytes",
          "36:     offset = central_directory_info[\"relative_offset_of_local_file_header\"]",
          "37:     apk_file.seek(offset + local_header_size + filename_length + extra_field_length)",
          "38:     if compression_method == 0:  # Stored (no compression)",
          "39:         uncompressed_data = apk_file.read(uncompressed_size)",
          "40:         extracted_data = uncompressed_data",
          "41:         indicator = 'STORED'",
          "42:     elif compression_method == 8:",
          "43:         compressed_data = apk_file.read(compressed_size)",
          "44:         # -15 for windows size due to raw stream with no header or trailer",
          "45:         extracted_data = zlib.decompress(compressed_data, -15)",
          "46:         indicator = 'DEFLATED'",
          "47:     elif compressed_size == uncompressed_size:",
          "48:         compressed_data = apk_file.read(uncompressed_size)",
          "49:         extracted_data = compressed_data",
          "50:         indicator = 'STORED_TAMPERED'",
          "51:     else:",
          "52:         cur_loc = apk_file.tell()",
          "53:         try:",
          "54:             compressed_data = apk_file.read(compressed_size)",
          "55:             extracted_data = zlib.decompress(compressed_data, -15)",
          "56:             indicator = 'DEFLATED_TAMPERED'",
          "57:         except:",
          "58:             apk_file.seek(cur_loc)",
          "59:             compressed_data = apk_file.read(uncompressed_size)",
          "60:             extracted_data = compressed_data",
          "61:             indicator = 'STORED_TAMPERED'",
          "62:     return extracted_data, indicator",
          "65: def extract_all_files_from_central_directory(apk_file, central_directory_entries, local_header_entries, output_dir):",
          "66:     \"\"\"",
          "67:     Extracts all files from an APK based on the entries detected in the central_directory_entries.",
          "69:     :param apk_file: The APK file e.g. with open('test.apk', 'rb') as apk_file",
          "70:     :type apk_file: bytesIO",
          "71:     :param central_directory_entries: The dictionary with all the entries for the central directory",
          "72:     :type central_directory_entries: dict",
          "73:     :param local_header_entries: The dictionary with all the local header entries",
          "74:     :type local_header_entries: dict",
          "75:     :param output_dir: The output directory where to save the files.",
          "76:     :type output_dir: str",
          "77:     :return: Returns 0 if no errors, 1 if an exception and 2 if the output directory already exists",
          "78:     :rtype: int",
          "79:     \"\"\"",
          "80:     try:",
          "81:         # Check if the output directory already exists",
          "82:         if os.path.exists(output_dir):",
          "83:             print(\"Extraction aborted. Output directory already exists.\")",
          "84:             return 2",
          "85:         # Create the output directory or overwrite if it already exists",
          "86:         os.makedirs(output_dir, exist_ok=True)",
          "87:         # Iterate over central directory entries",
          "88:         for filename, cd_header_info in central_directory_entries.items():",
          "89:             if not filename:",
          "90:                 # to account for the cases where an empty filename entry is added",
          "91:                 continue",
          "92:             # Extract the file using the local header information",
          "93:             extracted_data = \\",
          "94:                 extract_file_based_on_header_info(",
          "95:                     apk_file, local_header_entries[filename], cd_header_info)[0]",
          "96:             # Construct the output file path",
          "97:             output_path = os.path.join(output_dir, filename)",
          "98:             # Create directories if necessary",
          "99:             os.makedirs(os.path.dirname(output_path), exist_ok=True)",
          "100:             # Write the extracted data to the output file",
          "101:             with open(output_path, 'wb') as output_file:",
          "102:                 output_file.write(extracted_data)",
          "103:         return 0",
          "104:     except Exception as e:",
          "105:         print(f\"Error extracting files: {e}\")",
          "106:         return 1",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/zipfile.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/headers.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/zipfile.py -> mobsf/StaticAnalyzer/tools/androguard4/apkinspector/headers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "4: import io",
          "6: import struct",
          "7: from typing import Dict",
          "64: class EndOfCentralDirectoryRecord:",
          "",
          "[Removed Lines]",
          "3: \"\"\"This file is from apkinspector licensed under the Apache License 2.0.\"\"\"",
          "5: import zlib",
          "10: def extract_file_based_on_header_info(apk_file, local_header_info, central_directory_info):",
          "11:     \"\"\"",
          "12:     Extracts a single file from the apk_file based on the information provided from the offset and the header_info.",
          "13:     It takes into account that the compression method provided might not be STORED or DEFLATED! The returned",
          "14:     'indicator', shows what compression method was used. Besides the standard STORED/DEFLATE it may return",
          "15:     'DEFLATED_TAMPERED', which means that the compression method found was not DEFLATED(8) but it should have been,",
          "16:     and 'STORED_TAMPERED' which means that the compression method found was not STORED(0) but should have been.",
          "18:     :param apk_file: The APK file e.g. with open('test.apk', 'rb') as apk_file",
          "19:     :type apk_file: bytesIO",
          "20:     :param local_header_info: The local header dictionary info for that specific filename",
          "21:     :type local_header_info: dict",
          "22:     :param central_directory_info: The central directory entry for that specific filename",
          "23:     :type central_directory_info: dict",
          "24:     :return: Returns the actual extracted data for that file along with an indication of whether a static analysis evasion technique was used or not.",
          "25:     :rtype: set(bytes, str)",
          "26:     \"\"\"",
          "27:     filename_length = local_header_info[\"file_name_length\"]",
          "28:     if local_header_info[\"compressed_size\"] == 0 or local_header_info[\"uncompressed_size\"] == 0:",
          "29:         compressed_size = central_directory_info[\"compressed_size\"]",
          "30:         uncompressed_size = central_directory_info[\"uncompressed_size\"]",
          "31:     else:",
          "32:         compressed_size = local_header_info[\"compressed_size\"]",
          "33:         uncompressed_size = local_header_info[\"uncompressed_size\"]",
          "35:     extra_field_length = local_header_info[\"extra_field_length\"]",
          "36:     compression_method = local_header_info[\"compression_method\"]",
          "37:     # Skip the offset + local header to reach the compressed data",
          "38:     local_header_size = 30  # Size of the local header in bytes",
          "39:     offset = central_directory_info[\"relative_offset_of_local_file_header\"]",
          "40:     apk_file.seek(offset + local_header_size + filename_length + extra_field_length)",
          "41:     if compression_method == 0:  # Stored (no compression)",
          "42:         uncompressed_data = apk_file.read(uncompressed_size)",
          "43:         extracted_data = uncompressed_data",
          "44:         indicator = 'STORED'",
          "45:     elif compression_method == 8:",
          "46:         compressed_data = apk_file.read(compressed_size)",
          "47:         # -15 for windows size due to raw stream with no header or trailer",
          "48:         extracted_data = zlib.decompress(compressed_data, -15)",
          "49:         indicator = 'DEFLATED'",
          "50:     else:",
          "51:         try:",
          "52:             cur_loc = apk_file.tell()",
          "53:             compressed_data = apk_file.read(compressed_size)",
          "54:             extracted_data = zlib.decompress(compressed_data, -15)",
          "55:             indicator = 'DEFLATED_TAMPERED'",
          "56:         except:",
          "57:             apk_file.seek(cur_loc)",
          "58:             compressed_data = apk_file.read(uncompressed_size)",
          "59:             extracted_data = compressed_data",
          "60:             indicator = 'STORED_TAMPERED'",
          "61:     return extracted_data, indicator",
          "",
          "[Added Lines]",
          "3: # ApkInspector - Nov 24, 2024 - 293ab2d89ab9ce011c7dbbc5df3c876172875a1c",
          "5: import os",
          "9: from .extract import extract_file_based_on_header_info, extract_all_files_from_central_directory",
          "10: from .helpers import pretty_print_header, save_to_json, save_data_to_file",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "98:         signature_offset = -1",
          "99:         file_size = apk_file.seek(0, 2)",
          "100:         while offset < file_size:",
          "104:             apk_file.seek(position)",
          "105:             chunk = apk_file.read(chunk_size)",
          "106:             if not chunk:",
          "107:                 break",
          "110:             if signature_offset != -1:",
          "111:                 eo_central_directory_offset = position + signature_offset",
          "114:         if signature_offset == -1:",
          "115:             raise ValueError(",
          "116:                 \"End of central directory record (EOCD) signature not found\")",
          "",
          "[Removed Lines]",
          "101:             position = file_size - offset - chunk_size",
          "102:             if position < 0:",
          "103:                 position = 0",
          "108:             # end of Central Directory File Header signature",
          "109:             signature_offset = chunk.rfind(b'\\x50\\x4b\\x05\\x06')",
          "112:                 break  # Found End of central directory record (EOCD) signature",
          "113:             offset += chunk_size",
          "",
          "[Added Lines]",
          "50:             position = max(0, file_size - offset - chunk_size)",
          "55:             signature_offset = chunk.rfind(b'\\x50\\x4b\\x05\\x06')  # EOCD signature",
          "58:                 break  # Found EOCD signature",
          "59:             # Adjust offset to overlap by 4 bytes",
          "60:             offset += chunk_size - 4",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "301:             relative_offset_of_local_file_header = struct.unpack('<I', apk_file.read(4))[",
          "302:                 0]",
          "303:             filename = struct.unpack(f'<{file_name_length}s', apk_file.read(file_name_length))[",
          "309:             offset_in_central_directory = c_offset",
          "311:             central_directory_entry = CentralDirectoryEntry(",
          "",
          "[Removed Lines]",
          "304:                 0].decode('utf-8')",
          "305:             extra_field = struct.unpack(f'<{extra_field_length}s', apk_file.read(extra_field_length))[0].decode('utf-8',",
          "306:                                                                                                                 'ignore')",
          "307:             file_comment = struct.unpack(f'<{file_comment_length}s', apk_file.read(file_comment_length))[0].decode(",
          "308:                 'utf-8', 'ignore')",
          "",
          "[Added Lines]",
          "252:                 0].decode('utf-8', 'ignore')",
          "253:             extra_field = struct.unpack(f'<{extra_field_length}s', apk_file.read(",
          "254:                 extra_field_length))[0].decode('utf-8', 'ignore')",
          "255:             file_comment = struct.unpack(f'<{file_comment_length}s', apk_file.read(",
          "256:                 file_comment_length))[0].decode('utf-8', 'ignore')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "398:             uncompressed_size = struct.unpack('<I', apk_file.read(4))[0]",
          "399:             file_name_length = struct.unpack('<H', apk_file.read(2))[0]",
          "400:             extra_field_length = struct.unpack('<H', apk_file.read(2))[0]",
          "405:         return cls(",
          "406:             version_needed_to_extract, general_purpose_bit_flag, compression_method,",
          "407:             file_last_modification_time, file_last_modification_date, crc32_of_uncompressed_data,",
          "",
          "[Removed Lines]",
          "401:             filename = struct.unpack(f'<{file_name_length}s', apk_file.read(file_name_length))[",
          "402:                 0].decode('utf-8')",
          "403:             extra_field = struct.unpack(f'<{extra_field_length}s', apk_file.read(extra_field_length))[0].decode('utf-8',",
          "404:                                                                                                                 'ignore')",
          "",
          "[Added Lines]",
          "349:             try:",
          "350:                 filename = struct.unpack(f'<{file_name_length}s', apk_file.read(file_name_length))[",
          "351:                     0].decode('utf-8', 'ignore')",
          "352:                 extra_field = struct.unpack(f'<{extra_field_length}s', apk_file.read(",
          "353:                     extra_field_length))[0].decode('utf-8', 'ignore')",
          "354:             except:",
          "355:                 filename = entry_of_interest.filename",
          "356:                 extra_field = entry_of_interest.extra_field",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "488:         Similar to parse, but instead of parsing the entire APK, it only targets the specified file.",
          "490:         :param apk_file: The apk file expected raw",
          "492:         :param filename: the filename of the file to be parsed",
          "493:         :type filename: str",
          "494:         :param eocd: Optionally, the instance of the end of central directory from the APK",
          "",
          "[Removed Lines]",
          "491:         :type apk_file: io.TextIOWrapper",
          "",
          "[Added Lines]",
          "443:         :type apk_file: bytesIO",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "561:         \"\"\"",
          "562:         extracted_file = extract_file_based_on_header_info(self.zip, self.get_local_header_dict(name),",
          "563:                                                            self.get_central_directory_entry_dict(name))[0]",
          "566:         return extracted_file",
          "568:     def infolist(self) -> Dict[str, CentralDirectoryEntry]:",
          "",
          "[Removed Lines]",
          "564:         # if save:",
          "565:         #     save_data_to_file(f\"EXTRACTED_{name}\", extracted_file)",
          "",
          "[Added Lines]",
          "516:         if save:",
          "517:             save_data_to_file(f\"EXTRACTED_{name}\", extracted_file)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "582:         :rtype: list",
          "583:         \"\"\"",
          "584:         return [vl for vl in self.central_directory.to_dict()]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "538:     def extract_all(self, extract_path, apk_name):",
          "539:         \"\"\"",
          "540:         Extracts all the contents of the APK.",
          "542:         :param extract_path: where to extract it",
          "543:         :type extract_path: str",
          "544:         :param apk_name: the name of the apk",
          "545:         :type apk_name: str",
          "546:         \"\"\"",
          "547:         output_path = os.path.join(extract_path, apk_name)",
          "548:         if not extract_all_files_from_central_directory(self.zip, self.to_dict()[\"central_directory\"],",
          "549:                                                         self.to_dict()[\"local_headers\"], output_path):",
          "550:             print(f\"Extraction successful for: {apk_name}\")",
          "553: def print_headers_of_filename(cd_h_of_file, local_header_of_file):",
          "554:     \"\"\"",
          "555:     Prints out the details for both the central directory header and the local file header. Useful for the CLI.",
          "557:     :param cd_h_of_file: central directory header of a filename as it may be retrieved from headers_of_filename",
          "558:     :type cd_h_of_file: dict",
          "559:     :param local_header_of_file: local header dictionary of a filename as it may be retrieved from headers_of_filename",
          "560:     :type local_header_of_file: dict",
          "561:     \"\"\"",
          "562:     if not cd_h_of_file or not local_header_of_file:",
          "563:         print(\"Are you sure the filename exists?\")",
          "564:         return",
          "565:     pretty_print_header(\"CENTRAL DIRECTORY\")",
          "566:     for k in cd_h_of_file:",
          "567:         if k == 'Relative offset of local file header' or k == 'Offset in the central directory header':",
          "568:             print(f\"{k:40} : {hex(int(cd_h_of_file[k]))} | {cd_h_of_file[k]}\")",
          "569:         else:",
          "570:             print(f\"{k:40} : {cd_h_of_file[k]}\")",
          "571:     pretty_print_header(\"LOCAL HEADER\")",
          "572:     for k in local_header_of_file:",
          "573:         print(f\"{k:40} : {local_header_of_file[k]}\")",
          "576: def show_and_save_info_of_headers(entries, apk_name, header_type: str, export: bool, show: bool):",
          "577:     \"\"\"",
          "578:     Print information for each entry for the central directory header and allow to possibly export to JSON.",
          "580:     :param entries: The dictionary with all the entries for the central directory",
          "581:     :type entries: dict",
          "582:     :param apk_name: String with the name of the APK, so it can be used for the export.",
          "583:     :type apk_name: str",
          "584:     :param header_type: What type of header that is, either central_directory or local, to be used for the export",
          "585:     :type header_type: str",
          "586:     :param export: Boolean for exporting or not to JSON",
          "587:     :type export: bool",
          "588:     :param show: Boolean for printing or not the entries",
          "589:     :type show: bool",
          "590:     \"\"\"",
          "591:     if show:",
          "592:         for entry in entries:",
          "593:             pretty_print_header(entry)",
          "594:             print(entries[entry])",
          "595:     if export:",
          "596:         save_to_json(f\"{apk_name}_{header_type}_header.json\", entries)",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py||mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py -> mobsf/StaticAnalyzer/tools/androguard4/apkinspector/helpers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "3: import json",
          "6: def pretty_print_header(header_text, width=50, char='-'):",
          "7:     \"\"\"",
          "8:     Formatting output used for the CLI",
          "10:     :param header_text: The text to be displayed",
          "11:     :type header_text: str",
          "12:     :param width: total width of the display",
          "13:     :type width: int",
          "14:     :param char: which char to be used as a filler",
          "15:     :type char: str",
          "16:     \"\"\"",
          "17:     padding = max(0, width - len(header_text)) // 2",
          "18:     formatted_header = f\"\\n{char * padding} {header_text} {char * padding}\"",
          "19:     print(formatted_header)",
          "22: def save_data_to_file(filename, data):",
          "23:     \"\"\"",
          "24:     Write data to file",
          "26:     :param data: the actual data",
          "27:     :type data: bytes",
          "28:     :param filename: file to be saved in",
          "29:     :type filename: str",
          "30:     \"\"\"",
          "31:     try:",
          "32:         with open(filename, 'wb') as output_file:",
          "33:             output_file.write(data)",
          "34:         print(f\"Data saved to {filename}\")",
          "35:     except Exception as e:",
          "36:         print(f\"Error while saving data to {filename}: {e}\")",
          "39: def save_to_json(filename, dictionary):",
          "40:     \"\"\"",
          "41:     Simple method to save a dictionary as JSON into the filename.",
          "43:     :param filename: the name of the file to be saved as",
          "44:     :type filename: str",
          "45:     :param dictionary: the dictionary to be saved as JSON",
          "46:     :type dictionary: dict",
          "47:     \"\"\"",
          "48:     with open(filename, \"w\") as h_file:",
          "49:         json.dump(dictionary, h_file, indent=4)",
          "52: def escape_xml_entities(data):",
          "53:     \"\"\"",
          "54:     Escaping characters that cant be included within an XML file.",
          "56:     :param data: The string to escape",
          "57:     :type data: str",
          "58:     :return: The escaped output",
          "59:     :rtype: str",
          "60:     \"\"\"",
          "61:     replacements = {",
          "62:         '<': '&lt;',",
          "63:         '>': '&gt;',",
          "64:         '&': '&amp;',",
          "65:         '\"': '&quot;',",
          "66:         \"'\": '&apos;'",
          "67:     }",
          "68:     return ''.join(replacements.get(c, c) for c in data)",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/axml.py||mobsf/StaticAnalyzer/tools/androguard4/axml.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/axml.py -> mobsf/StaticAnalyzer/tools/androguard4/axml.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "8: import collections",
          "9: from collections import defaultdict",
          "11: from lxml import etree",
          "15: import logging",
          "17: logger = logging.getLogger(__name__)",
          "18: logger.setLevel(level=logging.CRITICAL)",
          "20: # Constants for ARSC Files",
          "21: # see http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#233",
          "22: RES_NULL_TYPE = 0x0000",
          "",
          "[Removed Lines]",
          "3: from .resources import public",
          "4: from .types import *",
          "6: from struct import pack, unpack",
          "7: from xml.sax.saxutils import escape",
          "12: import re",
          "13: import binascii",
          "14: import io",
          "",
          "[Added Lines]",
          "3: # Androguard4 AXML - Nov 24, 2024 -04a5703b8ba7c181bb9f5f5995a2c16b6f9353cf",
          "4: # Allows type hinting of types not-yet-declared",
          "5: # in Python >= 3.7",
          "6: # see https://peps.python.org/pep-0563/",
          "7: from __future__ import annotations",
          "9: import binascii",
          "11: import io",
          "12: import re",
          "14: from struct import pack, unpack",
          "15: from typing import BinaryIO, Union",
          "16: from xml.sax.saxutils import escape",
          "22: from .resources import public",
          "23: from .types import *",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: RES_XML_START_ELEMENT_TYPE = 0x0102",
          "31: RES_XML_END_ELEMENT_TYPE = 0x0103",
          "32: RES_XML_CDATA_TYPE = 0x0104",
          "35: RES_XML_RESOURCE_MAP_TYPE = 0x0180",
          "",
          "[Removed Lines]",
          "33: RES_XML_LAST_CHUNK_TYPE = 0x017f",
          "",
          "[Added Lines]",
          "43: RES_XML_LAST_CHUNK_TYPE = 0x017F",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:     TYPE_STRING: \"string\",",
          "79: }",
          "82: DIMENSION_UNITS = [\"px\", \"dip\", \"sp\", \"pt\", \"in\", \"mm\"]",
          "83: FRACTION_UNITS = [\"%\", \"%p\"]",
          "",
          "[Removed Lines]",
          "81: RADIX_MULTS = [0.00390625, 3.051758E-005, 1.192093E-007, 4.656613E-010]",
          "",
          "[Added Lines]",
          "91: RADIX_MULTS = [0.00390625, 3.051758e-005, 1.192093e-007, 4.656613e-010]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "88: class ResParserError(Exception):",
          "89:     \"\"\"Exception for the parsers\"\"\"",
          "90:     pass",
          "94:     \"\"\"",
          "95:     Convert a complex unit into float",
          "96:     \"\"\"",
          "",
          "[Removed Lines]",
          "93: def complexToFloat(xcomplex):",
          "",
          "[Added Lines]",
          "104: def complexToFloat(xcomplex) -> float:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "100: class StringBlock:",
          "101:     \"\"\"",
          "102:     StringBlock is a CHUNK inside an AXML File: `ResStringPool_header`",
          "105:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#436",
          "106:     \"\"\"",
          "109:         \"\"\"",
          "110:         :param buff: buffer which holds the string block",
          "111:         :param header: a instance of :class:`~ARSCHeader`",
          "",
          "[Removed Lines]",
          "103:     It contains all strings, which are used by referecing to ID's",
          "108:     def __init__(self, buff, header):",
          "",
          "[Added Lines]",
          "114:     It contains all strings, which are used by referencing to ID's",
          "119:     def __init__(self, buff: BinaryIO, header: ARSCHeader) -> None:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "121:         # flags",
          "122:         self.flags = unpack('<I', buff.read(4))[0]",
          "125:         # string_pool_offset",
          "126:         # The string offset is counted from the beginning of the string section",
          "127:         self.stringsOffset = unpack('<I', buff.read(4))[0]",
          "128:         # check if the stringCount is correct",
          "130:             self.stringCount = int(",
          "133:         # style_pool_offset",
          "134:         # The styles offset is counted as well from the beginning of the string section",
          "",
          "[Removed Lines]",
          "123:         self.m_isUTF8 = ((self.flags & UTF8_FLAG) != 0)",
          "129:         if (self.stringsOffset - (self.styleCount * 4 + 28)) / 4 != self.stringCount:",
          "131:                 (self.stringsOffset - (self.styleCount * 4 + 28)) / 4)",
          "",
          "[Added Lines]",
          "134:         self.m_isUTF8 = (self.flags & UTF8_FLAG) != 0",
          "140:         if (",
          "141:             self.stringsOffset - (self.styleCount * 4 + 28)",
          "142:         ) / 4 != self.stringCount:",
          "144:                 (self.stringsOffset - (self.styleCount * 4 + 28)) / 4",
          "145:             )",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "137:         # Check if they supplied a stylesOffset even if the count is 0:",
          "138:         if self.styleCount == 0 and self.stylesOffset > 0:",
          "142:         self.m_stringOffsets = []",
          "143:         self.m_styleOffsets = []",
          "",
          "[Removed Lines]",
          "139:             logger.info(\"Styles Offset given, but styleCount is zero. \"",
          "140:                         \"This is not a problem but could indicate packers.\")",
          "",
          "[Added Lines]",
          "153:             logger.info(",
          "154:                 \"Styles Offset given, but styleCount is zero. \"",
          "155:                 \"This is not a problem but could indicate packers.\"",
          "156:             )",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "177:                 self.m_styles.append(unpack('<I', buff.read(4))[0])",
          "179:     def __repr__(self):",
          "182:     def __getitem__(self, idx):",
          "183:         \"\"\"",
          "",
          "[Removed Lines]",
          "180:         return \"<StringPool #strings={}, #styles={}, UTF8={}>\".format(self.stringCount, self.styleCount, self.m_isUTF8)",
          "",
          "[Added Lines]",
          "196:         return \"<StringPool #strings={}, #styles={}, UTF8={}>\".format(",
          "197:             self.stringCount, self.styleCount, self.m_isUTF8",
          "198:         )",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "198:         for i in range(self.stringCount):",
          "199:             yield self.getString(i)",
          "202:         \"\"\"",
          "203:         Return the string at the index in the string table",
          "",
          "[Removed Lines]",
          "201:     def getString(self, idx):",
          "",
          "[Added Lines]",
          "219:     def getString(self, idx: int) -> str:",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "208:         if idx in self._cache:",
          "209:             return self._cache[idx]",
          "212:             return \"\"",
          "214:         offset = self.m_stringOffsets[idx]",
          "",
          "[Removed Lines]",
          "211:         if idx < 0 or not self.m_stringOffsets or idx > self.stringCount:",
          "",
          "[Added Lines]",
          "229:         if idx < 0 or not self.m_stringOffsets or idx >= self.stringCount:",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "221:         return self._cache[idx]",
          "224:         \"\"\"",
          "225:         Return the style associated with the index",
          "",
          "[Removed Lines]",
          "223:     def getStyle(self, idx):",
          "",
          "[Added Lines]",
          "241:     def getStyle(self, idx: int) -> int:",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "229:         \"\"\"",
          "230:         return self.m_styles[idx]",
          "233:         \"\"\"",
          "234:         Decode an UTF-8 String at the given offset",
          "",
          "[Removed Lines]",
          "232:     def _decode8(self, offset):",
          "",
          "[Added Lines]",
          "250:     def _decode8(self, offset: int) -> str:",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "245:         encoded_bytes, skip = self._decode_length(offset, 1)",
          "246:         offset += skip",
          "248:         data = self.m_charbuff[offset: offset + encoded_bytes]",
          "250:         if self.m_charbuff[offset + encoded_bytes] != 0:",
          "251:             raise ResParserError(",
          "254:         return self._decode_bytes(data, 'utf-8', str_len)",
          "257:         \"\"\"",
          "258:         Decode an UTF-16 String at the given offset",
          "",
          "[Removed Lines]",
          "252:                 \"UTF-8 String is not null terminated! At offset={}\".format(offset))",
          "256:     def _decode16(self, offset):",
          "",
          "[Added Lines]",
          "266:         # Two checks should happen here:",
          "267:         # a) offset + encoded_bytes surpassing the string_pool length and",
          "268:         # b) non-null terminated strings which should be rejected",
          "269:         # platform/frameworks/base/libs/androidfw/ResourceTypes.cpp#789",
          "270:         if len(self.m_charbuff) < (offset + encoded_bytes):",
          "271:             logger.warning(",
          "272:                 f\"String size: {offset + encoded_bytes} is exceeding string pool size. Returning empty string.\"",
          "273:             )",
          "274:             return \"\"",
          "279:                 \"UTF-8 String is not null terminated! At offset={}\".format(",
          "280:                     offset",
          "281:                 )",
          "282:             )",
          "286:     def _decode16(self, offset: int) -> str:",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "266:         # The len is the string len in utf-16 units",
          "267:         encoded_bytes = str_len * 2",
          "269:         data = self.m_charbuff[offset: offset + encoded_bytes]",
          "272:             raise ResParserError(",
          "275:         return self._decode_bytes(data, 'utf-16', str_len)",
          "277:     @staticmethod",
          "279:         \"\"\"",
          "280:         Generic decoding with length check.",
          "281:         The string is decoded from bytes with the given encoding, then the length",
          "",
          "[Removed Lines]",
          "271:         if self.m_charbuff[offset + encoded_bytes:offset + encoded_bytes + 2] != b\"\\x00\\x00\":",
          "273:                 \"UTF-16 String is not null terminated! At offset={}\".format(offset))",
          "278:     def _decode_bytes(data, encoding, str_len):",
          "",
          "[Added Lines]",
          "299:         # Two checks should happen here:",
          "300:         # a) offset + encoded_bytes surpassing the string_pool length and",
          "301:         # b) non-null terminated strings which should be rejected",
          "302:         # platform/frameworks/base/libs/androidfw/ResourceTypes.cpp#789",
          "303:         if len(self.m_charbuff) < (offset + encoded_bytes):",
          "304:             logger.warning(",
          "305:                 f\"String size: {offset + encoded_bytes} is exceeding string pool size. Returning empty string.\"",
          "306:             )",
          "307:             return \"\"",
          "311:         if (",
          "312:             self.m_charbuff[",
          "313:                 offset + encoded_bytes: offset + encoded_bytes + 2",
          "314:             ]",
          "315:             != b\"\\x00\\x00\"",
          "316:         ):",
          "318:                 \"UTF-16 String is not null terminated! At offset={}\".format(",
          "319:                     offset",
          "320:                 )",
          "321:             )",
          "326:     def _decode_bytes(data: bytes, encoding: str, str_len: int) -> str:",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "292:             logger.warning(\"invalid decoded string length\")",
          "293:         return string",
          "296:         \"\"\"",
          "297:         Generic Length Decoding at offset of string",
          "",
          "[Removed Lines]",
          "295:     def _decode_length(self, offset, sizeof_char):",
          "",
          "[Added Lines]",
          "343:     def _decode_length(self, offset: int, sizeof_char: int) -> tuple[int, int]:",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "312:         fmt = \"<2{}\".format('B' if sizeof_char == 1 else 'H')",
          "313:         highbit = 0x80 << (8 * (sizeof_char - 1))",
          "317:         if (length1 & highbit) != 0:",
          "318:             length = ((length1 & ~highbit) << (8 * sizeof_char)) | length2",
          "",
          "[Removed Lines]",
          "315:         length1, length2 = unpack(fmt, self.m_charbuff[offset:(offset + sizeof_2chars)])",
          "",
          "[Added Lines]",
          "363:         length1, length2 = unpack(",
          "364:             fmt, self.m_charbuff[offset: (offset + sizeof_2chars)]",
          "365:         )",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "324:         # These are true asserts, as the size should never be less than the values",
          "325:         if sizeof_char == 1:",
          "328:         else:",
          "332:         return length, size",
          "335:         \"\"\"",
          "336:         Print some information on stdout about the string table",
          "337:         \"\"\"",
          "349:         if self.stringCount > 0:",
          "350:             print()",
          "",
          "[Removed Lines]",
          "326:             assert length <= 0x7FFF, \"length of UTF-8 string is too large! At offset={}\".format(",
          "327:                 offset)",
          "329:             assert length <= 0x7FFFFFFF, \"length of UTF-16 string is too large!  At offset={}\".format(",
          "330:                 offset)",
          "334:     def show(self):",
          "338:         print(\"StringBlock(stringsCount=0x%x, \"",
          "339:               \"stringsOffset=0x%x, \"",
          "340:               \"stylesCount=0x%x, \"",
          "341:               \"stylesOffset=0x%x, \"",
          "342:               \"flags=0x%x\"",
          "343:               \")\" % (self.stringCount,",
          "344:                      self.stringsOffset,",
          "345:                      self.styleCount,",
          "346:                      self.stylesOffset,",
          "347:                      self.flags))",
          "",
          "[Added Lines]",
          "376:             assert (",
          "377:                 length <= 0x7FFF",
          "378:             ), \"length of UTF-8 string is too large! At offset={}\".format(",
          "379:                 offset",
          "380:             )",
          "382:             assert (",
          "383:                 length <= 0x7FFFFFFF",
          "384:             ), \"length of UTF-16 string is too large!  At offset={}\".format(",
          "385:                 offset",
          "386:             )",
          "390:     def show(self) -> None:",
          "394:         print(",
          "395:             \"StringBlock(stringsCount=0x%x, \"",
          "396:             \"stringsOffset=0x%x, \"",
          "397:             \"stylesCount=0x%x, \"",
          "398:             \"stylesOffset=0x%x, \"",
          "399:             \"flags=0x%x\"",
          "400:             \")\"",
          "401:             % (",
          "402:                 self.stringCount,",
          "403:                 self.stringsOffset,",
          "404:                 self.styleCount,",
          "405:                 self.stylesOffset,",
          "406:                 self.flags,",
          "407:             )",
          "408:         )",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "383:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#563",
          "384:     \"\"\"",
          "387:         logger.debug(\"AXMLParser\")",
          "389:         self._reset()",
          "",
          "[Removed Lines]",
          "386:     def __init__(self, raw_buff):",
          "",
          "[Added Lines]",
          "447:     def __init__(self, raw_buff: bytes) -> None:",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "392:         self.axml_tampered = False",
          "393:         self.buff = io.BufferedReader(io.BytesIO(raw_buff))",
          "394:         self.buff_size = self.buff.raw.getbuffer().nbytes",
          "396:         # Minimum is a single ARSCHeader, which would be a strange edge case...",
          "397:         if self.buff_size < 8:",
          "398:             logger.error(",
          "400:             self._valid = False",
          "401:             return",
          "",
          "[Removed Lines]",
          "399:                 \"Filesize is too small to be a valid AXML file! Filesize: {}\".format(self.buff_size))",
          "",
          "[Added Lines]",
          "456:         self.packerwarning = False",
          "461:                 \"Filesize is too small to be a valid AXML file! Filesize: {}\".format(",
          "462:                     self.buff_size",
          "463:                 )",
          "464:             )",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "404:         # But this is not possible as the maximum chunk size is a unsigned 4 byte int.",
          "405:         if self.buff_size > 0xFFFFFFFF:",
          "406:             logger.error(",
          "408:             self._valid = False",
          "409:             return",
          "",
          "[Removed Lines]",
          "407:                 \"Filesize is too large to be a valid AXML file! Filesize: {}\".format(self.buff_size))",
          "",
          "[Added Lines]",
          "472:                 \"Filesize is too large to be a valid AXML file! Filesize: {}\".format(",
          "473:                     self.buff_size",
          "474:                 )",
          "475:             )",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "422:             # Can be a common error: the file is not an AXML but a plain XML",
          "423:             # The file will then usually start with '<?xm' / '3C 3F 78 6D'",
          "424:             logger.warning(",
          "427:         if axml_header.header_size != 8:",
          "430:             self._valid = False",
          "431:             return",
          "433:         if self.filesize > self.buff_size:",
          "436:             self._valid = False",
          "437:             return",
          "439:         if self.filesize < self.buff_size:",
          "440:             # The file can still be parsed up to the point where the chunk should end.",
          "441:             self.axml_tampered = True",
          "445:         # Not that severe of an error, we have plenty files where this is not",
          "446:         # set correctly",
          "447:         if axml_header.type != RES_XML_TYPE:",
          "448:             self.axml_tampered = True",
          "453:         # Now we parse the STRING POOL",
          "454:         try:",
          "455:             header = ARSCHeader(self.buff, expected_type=RES_STRING_POOL_TYPE)",
          "456:             logger.debug(\"STRING_POOL {}\".format(header))",
          "457:         except ResParserError as e:",
          "459:             self._valid = False",
          "460:             return",
          "462:         if header.header_size != 0x1C:",
          "465:             self._valid = False",
          "466:             return",
          "",
          "[Removed Lines]",
          "425:                 \"Header size is 28024! Are you trying to parse a plain XML file?\")",
          "428:             logger.error(\"This does not look like an AXML file. header size does not equal 8! header size = {}\".format(",
          "429:                 axml_header.header_size))",
          "434:             logger.error(\"This does not look like an AXML file. Declared filesize does not match real size: {} vs {}\".format(",
          "435:                 self.filesize, self.buff_size))",
          "442:             logger.warning(\"Declared filesize ({}) is smaller than total file size ({}). \"",
          "443:                            \"Was something appended to the file? Trying to parse it anyways.\".format(self.filesize, self.buff.size()))",
          "449:             logger.warning(\"AXML file has an unusual resource type! \"",
          "450:                            \"Malware likes to to such stuff to anti androguard! \"",
          "451:                            \"But we try to parse it anyways. Resource Type: 0x{:04x}\".format(axml_header.type))",
          "458:             logger.error(\"Error parsing resource header of string pool: {}\".format(e))",
          "463:             logger.error(\"This does not look like an AXML file. String chunk header size does not equal 28! header size = {}\".format(",
          "464:                 header.header_size))",
          "",
          "[Added Lines]",
          "493:                 \"Header size is 28024! Are you trying to parse a plain XML file?\"",
          "494:             )",
          "497:             logger.error(",
          "498:                 \"This does not look like an AXML file. header size does not equal 8! header size = {}\".format(",
          "499:                     axml_header.header_size",
          "500:                 )",
          "501:             )",
          "506:             logger.error(",
          "507:                 \"This does not look like an AXML file. Declared filesize does not match real size: {} vs {}\".format(",
          "508:                     self.filesize, self.buff_size",
          "509:                 )",
          "510:             )",
          "517:             logger.warning(",
          "518:                 \"Declared filesize ({}) is smaller than total file size ({}). \"",
          "519:                 \"Was something appended to the file? Trying to parse it anyways.\".format(",
          "520:                     self.filesize, self.buff_size",
          "521:                 )",
          "522:             )",
          "528:             logger.warning(",
          "529:                 \"AXML file has an unusual resource type! \"",
          "530:                 \"Malware likes to to such stuff to anti androguard! \"",
          "531:                 \"But we try to parse it anyways. Resource Type: 0x{:04x}\".format(",
          "532:                     axml_header.type",
          "533:                 )",
          "534:             )",
          "541:             logger.error(",
          "542:                 \"Error parsing resource header of string pool: {}\".format(e)",
          "543:             )",
          "548:             logger.error(",
          "549:                 \"This does not look like an AXML file. String chunk header size does not equal 28! header size = {}\".format(",
          "550:                     header.header_size",
          "551:                 )",
          "552:             )",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "475:         # Store a list of prefix/uri mappings encountered",
          "476:         self.namespaces = []",
          "479:         \"\"\"",
          "480:         Get the state of the AXMLPrinter.",
          "481:         if an error happend somewhere in the process of parsing the file,",
          "",
          "[Removed Lines]",
          "478:     def is_valid(self):",
          "",
          "[Added Lines]",
          "566:     def is_valid(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "528:                 # Check size: < 8 bytes mean that the chunk is not complete",
          "529:                 # Should be aligned to 4 bytes.",
          "530:                 if h.size < 8 or (h.size % 4) != 0:",
          "532:                     self._valid = False",
          "533:                     return",
          "535:                 for i in range((h.size - h.header_size) // 4):",
          "538:                 continue",
          "540:             # Parse now the XML chunks.",
          "541:             # unknown chunk types might cause problems, but we can skip them!",
          "543:                 # h.size is the size of the whole chunk including the header.",
          "544:                 # We read already 8 bytes of the header, thus we need to",
          "545:                 # subtract them.",
          "546:                 logger.error(",
          "548:                 self.buff.seek(h.end)",
          "549:                 continue",
          "551:             # Check that we read a correct header",
          "552:             if h.header_size != 0x10:",
          "555:                 self.buff.seek(h.end)",
          "556:                 continue",
          "558:             # Line Number of the source file, only used as meta information",
          "561:             # Comment_Index (usually 0xFFFFFFFF)",
          "568:             if h.type == RES_XML_START_NAMESPACE_TYPE:",
          "572:                 s_prefix = self.sb[prefix]",
          "573:                 s_uri = self.sb[uri]",
          "575:                 logger.debug(",
          "578:                 if s_uri == '':",
          "582:                 if (prefix, uri) in self.namespaces:",
          "585:                 self.namespaces.append((prefix, uri))",
          "587:                 # We can continue with the next chunk, as we store the namespace",
          "",
          "[Removed Lines]",
          "531:                     logger.error(\"Invalid chunk size in chunk XML_RESOURCE_MAP\")",
          "536:                     self.m_resourceIDs.append(unpack('<L', self.buff.read(4))[0])",
          "542:             if h.type < RES_XML_FIRST_CHUNK_TYPE or h.type > RES_XML_LAST_CHUNK_TYPE:",
          "547:                     \"Not a XML resource chunk type: 0x{:04x}. Skipping {} bytes\".format(h.type, h.size))",
          "553:                 logger.error(\"XML Resource Type Chunk header size does not match 16! \"",
          "554:                              \"At chunk type 0x{:04x}, declared header size=0x{:04x}, chunk size=0x{:04x}\".format(h.type, h.header_size, h.size))",
          "559:             self.m_lineNumber, = unpack('<L', self.buff.read(4))",
          "562:             self.m_comment_index, = unpack('<L', self.buff.read(4))",
          "564:             if self.m_comment_index != 0xFFFFFFFF and h.type in [RES_XML_START_NAMESPACE_TYPE, RES_XML_END_NAMESPACE_TYPE]:",
          "565:                 logger.warning(\"Unhandled Comment at namespace chunk: '{}'\".format(",
          "566:                     self.sb[self.m_comment_index]))",
          "569:                 prefix, = unpack('<L', self.buff.read(4))",
          "570:                 uri, = unpack('<L', self.buff.read(4))",
          "576:                     \"Start of Namespace mapping: prefix {}: '{}' --> uri {}: '{}'\".format(prefix, s_prefix, uri, s_uri))",
          "579:                     logger.warning(\"Namespace prefix '{}' resolves to empty URI. \"",
          "580:                                    \"This might be a packer.\".format(s_prefix))",
          "583:                     logger.debug(\"Namespace mapping ({}, {}) already seen! \"",
          "584:                                  \"This is usually not a problem but could indicate packers or broken AXML compilers.\".format(prefix, uri))",
          "",
          "[Added Lines]",
          "619:                     logger.error(",
          "620:                         \"Invalid chunk size in chunk XML_RESOURCE_MAP\"",
          "621:                     )",
          "626:                     self.m_resourceIDs.append(",
          "627:                         unpack('<L', self.buff.read(4))[0]",
          "628:                     )",
          "634:             if (",
          "635:                 h.type < RES_XML_FIRST_CHUNK_TYPE",
          "636:                 or h.type > RES_XML_LAST_CHUNK_TYPE",
          "637:             ):",
          "642:                     \"Not a XML resource chunk type: 0x{:04x}. Skipping {} bytes\".format(",
          "643:                         h.type, h.size",
          "644:                     )",
          "645:                 )",
          "651:                 logger.error(",
          "652:                     \"XML Resource Type Chunk header size does not match 16! \"",
          "653:                     \"At chunk type 0x{:04x}, declared header size=0x{:04x}, chunk size=0x{:04x}\".format(",
          "654:                         h.type, h.header_size, h.size",
          "655:                     )",
          "656:                 )",
          "661:             (self.m_lineNumber,) = unpack('<L', self.buff.read(4))",
          "664:             (self.m_comment_index,) = unpack('<L', self.buff.read(4))",
          "666:             if self.m_comment_index != 0xFFFFFFFF and h.type in [",
          "667:                 RES_XML_START_NAMESPACE_TYPE,",
          "668:                 RES_XML_END_NAMESPACE_TYPE,",
          "669:             ]:",
          "670:                 logger.warning(",
          "671:                     \"Unhandled Comment at namespace chunk: '{}'\".format(",
          "672:                         self.sb[self.m_comment_index]",
          "673:                     )",
          "674:                 )",
          "677:                 (prefix,) = unpack('<L', self.buff.read(4))",
          "678:                 (uri,) = unpack('<L', self.buff.read(4))",
          "684:                     \"Start of Namespace mapping: prefix {}: '{}' --> uri {}: '{}'\".format(",
          "685:                         prefix, s_prefix, uri, s_uri",
          "686:                     )",
          "687:                 )",
          "690:                     logger.warning(",
          "691:                         \"Namespace prefix '{}' resolves to empty URI. \"",
          "692:                         \"This might be a packer.\".format(s_prefix)",
          "693:                     )",
          "696:                     logger.debug(",
          "697:                         \"Namespace mapping ({}, {}) already seen! \"",
          "698:                         \"This is usually not a problem but could indicate packers or broken AXML compilers.\".format(",
          "699:                             prefix, uri",
          "700:                         )",
          "701:                     )",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "591:             if h.type == RES_XML_END_NAMESPACE_TYPE:",
          "592:                 # END_PREFIX contains again prefix and uri field",
          "596:                 # We remove the last namespace mapping matching",
          "597:                 if (prefix, uri) in self.namespaces:",
          "598:                     self.namespaces.remove((prefix, uri))",
          "599:                 else:",
          "603:                 # We can continue with the next chunk, as we store the namespace",
          "604:                 # mappings for each tag",
          "",
          "[Removed Lines]",
          "593:                 prefix, = unpack('<L', self.buff.read(4))",
          "594:                 uri, = unpack('<L', self.buff.read(4))",
          "600:                     logger.warning(\"Reached a NAMESPACE_END without having the namespace stored before? \"",
          "601:                                    \"Prefix ID: {}, URI ID: {}\".format(prefix, uri))",
          "",
          "[Added Lines]",
          "710:                 (prefix,) = unpack('<L', self.buff.read(4))",
          "711:                 (uri,) = unpack('<L', self.buff.read(4))",
          "717:                     logger.warning(",
          "718:                         \"Reached a NAMESPACE_END without having the namespace stored before? \"",
          "719:                         \"Prefix ID: {}, URI ID: {}\".format(prefix, uri)",
          "720:                     )",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "616:                 # After that, there are two lists of attributes, 20 bytes each",
          "618:                 # Namespace URI (String ID)",
          "620:                 # Name of the Tag (String ID)",
          "622:                 self.at_start, self.at_size = unpack('<HH', self.buff.read(4))",
          "623:                 # Attribute Count",
          "625:                 # Class Attribute",
          "628:                 self.m_idAttribute = (attributeCount >> 16) - 1",
          "629:                 self.m_attribute_count = attributeCount & 0xFFFF",
          "",
          "[Removed Lines]",
          "619:                 self.m_namespaceUri, = unpack('<L', self.buff.read(4))",
          "621:                 self.m_name, = unpack('<L', self.buff.read(4))",
          "624:                 attributeCount, = unpack('<L', self.buff.read(4))",
          "626:                 self.m_classAttribute, = unpack('<L', self.buff.read(4))",
          "",
          "[Added Lines]",
          "738:                 (self.m_namespaceUri,) = unpack('<L', self.buff.read(4))",
          "740:                 (self.m_name,) = unpack('<L', self.buff.read(4))",
          "743:                 (attributeCount,) = unpack('<L', self.buff.read(4))",
          "745:                 (self.m_classAttribute,) = unpack('<L', self.buff.read(4))",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "641:                     # * Type",
          "642:                     # * Data",
          "643:                     for j in range(0, ATTRIBUTE_LENGTH):",
          "645:                     if self.at_size != 20:",
          "646:                         self.buff.read(self.at_size - 20)",
          "648:                 # Then there are class_attributes",
          "650:                     self.m_attributes[i] = self.m_attributes[i] >> 24",
          "652:                 self.m_event = START_TAG",
          "653:                 break",
          "655:             if h.type == RES_XML_END_ELEMENT_TYPE:",
          "659:                 self.m_event = END_TAG",
          "660:                 break",
          "",
          "[Removed Lines]",
          "644:                         self.m_attributes.append(unpack('<L', self.buff.read(4))[0])",
          "649:                 for i in range(ATTRIBUTE_IX_VALUE_TYPE, len(self.m_attributes), ATTRIBUTE_LENGTH):",
          "656:                 self.m_namespaceUri, = unpack('<L', self.buff.read(4))",
          "657:                 self.m_name, = unpack('<L', self.buff.read(4))",
          "",
          "[Added Lines]",
          "763:                         self.m_attributes.append(",
          "764:                             unpack('<L', self.buff.read(4))[0]",
          "765:                         )",
          "770:                 for i in range(",
          "771:                     ATTRIBUTE_IX_VALUE_TYPE,",
          "772:                     len(self.m_attributes),",
          "773:                     ATTRIBUTE_LENGTH,",
          "774:                 ):",
          "781:                 (self.m_namespaceUri,) = unpack('<L', self.buff.read(4))",
          "782:                 (self.m_name,) = unpack('<L', self.buff.read(4))",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "666:                 # usually, this typed value is set to UNDEFINED",
          "668:                 # ResStringPool_ref data --> uint32_t index",
          "671:                 # Res_value typedData:",
          "672:                 # uint16_t size",
          "",
          "[Removed Lines]",
          "669:                 self.m_name, = unpack('<L', self.buff.read(4))",
          "",
          "[Added Lines]",
          "794:                 (self.m_name,) = unpack('<L', self.buff.read(4))",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "676:                 # For now, we ingore these values",
          "677:                 size, res0, dataType, data = unpack(\"<HBBL\", self.buff.read(8))",
          "686:                 self.m_event = TEXT",
          "687:                 break",
          "689:             # Still here? Looks like we read an unknown XML header, try to skip it...",
          "690:             logger.warning(",
          "692:             self.buff.seek(h.end)",
          "694:     @property",
          "696:         \"\"\"",
          "698:         \"\"\"",
          "700:             return ''",
          "702:         return self.sb[self.m_name]",
          "704:     @property",
          "706:         \"\"\"",
          "707:         Return the comment at the current position or None if no comment is given",
          "",
          "[Removed Lines]",
          "679:                 logger.debug(\"found a CDATA Chunk: \"",
          "680:                              \"index={: 6d}, size={: 4d}, res0={: 4d}, dataType={: 4d}, data={: 4d}\".format(self.m_name,",
          "681:                                                                                                            size,",
          "682:                                                                                                            res0,",
          "683:                                                                                                            dataType,",
          "684:                                                                                                            data))",
          "691:                 \"Unknown XML Chunk: 0x{:04x}, skipping {} bytes.\".format(h.type, h.size))",
          "695:     def name(self):",
          "697:         Return the String assosciated with the tag name",
          "699:         if self.m_name == -1 or (self.m_event != START_TAG and self.m_event != END_TAG):",
          "705:     def comment(self):",
          "",
          "[Added Lines]",
          "804:                 logger.debug(",
          "805:                     \"found a CDATA Chunk: \"",
          "806:                     \"index={: 6d}, size={: 4d}, res0={: 4d}, dataType={: 4d}, data={: 4d}\".format(",
          "807:                         self.m_name, size, res0, dataType, data",
          "808:                     )",
          "809:                 )",
          "816:                 \"Unknown XML Chunk: 0x{:04x}, skipping {} bytes.\".format(",
          "817:                     h.type, h.size",
          "818:                 )",
          "819:             )",
          "823:     def name(self) -> str:",
          "825:         Return the String associated with the tag name",
          "827:         if self.m_name == -1 or (",
          "828:             self.m_event != START_TAG and self.m_event != END_TAG",
          "829:         ):",
          "835:     def comment(self) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "715:         return self.sb[self.m_comment_index]",
          "717:     @property",
          "719:         \"\"\"",
          "720:         Return the Namespace URI (if any) as a String for the current tag",
          "721:         \"\"\"",
          "723:             return ''",
          "725:         # No Namespace",
          "",
          "[Removed Lines]",
          "718:     def namespace(self):",
          "722:         if self.m_name == -1 or (self.m_event != START_TAG and self.m_event != END_TAG):",
          "",
          "[Added Lines]",
          "848:     def namespace(self) -> str:",
          "852:         if self.m_name == -1 or (",
          "853:             self.m_event != START_TAG and self.m_event != END_TAG",
          "854:         ):",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "729:         return self.sb[self.m_namespaceUri]",
          "731:     @property",
          "733:         \"\"\"",
          "734:         Returns the current namespace mapping as a dictionary",
          "",
          "[Removed Lines]",
          "732:     def nsmap(self):",
          "",
          "[Added Lines]",
          "864:     def nsmap(self) -> dict[str, str]:",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "750:             # Solve 2) & 4) by not including",
          "751:             if s_uri != \"\" and s_prefix != \"\":",
          "752:                 # solve 1) by using the last one in the list",
          "755:         return NSMAP",
          "757:     @property",
          "759:         \"\"\"",
          "760:         Return the String assosicated with the current text",
          "761:         \"\"\"",
          "",
          "[Removed Lines]",
          "753:                 NSMAP[s_prefix] = s_uri",
          "758:     def text(self):",
          "",
          "[Added Lines]",
          "885:                 NSMAP[s_prefix] = s_uri.strip()",
          "890:     def text(self) -> str:",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "765:         return self.sb[self.m_name]",
          "768:         \"\"\"",
          "769:         Legacy only!",
          "770:         use :py:attr:`~androguard.core.bytecodes.AXMLParser.name` instead",
          "771:         \"\"\"",
          "772:         return self.name",
          "775:         \"\"\"",
          "776:         Legacy only!",
          "777:         use :py:attr:`~androguard.core.bytecodes.AXMLParser.text` instead",
          "778:         \"\"\"",
          "779:         return self.text",
          "782:         \"\"\"",
          "783:         Legacy only!",
          "784:         use :py:attr:`~androguard.core.bytecodes.AXMLParser.namespace` instead",
          "",
          "[Removed Lines]",
          "767:     def getName(self):",
          "774:     def getText(self):",
          "781:     def getPrefix(self):",
          "",
          "[Added Lines]",
          "899:     def getName(self) -> str:",
          "906:     def getText(self) -> str:",
          "913:     def getPrefix(self) -> str:",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "799:         return offset",
          "802:         \"\"\"",
          "803:         Return the number of Attributes for a Tag",
          "804:         or -1 if not in a tag",
          "",
          "[Removed Lines]",
          "801:     def getAttributeCount(self):",
          "",
          "[Added Lines]",
          "933:     def getAttributeCount(self) -> int:",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "809:         return self.m_attribute_count",
          "812:         \"\"\"",
          "813:         Returns the numeric ID for the namespace URI of an attribute",
          "814:         \"\"\"",
          "",
          "[Removed Lines]",
          "811:     def getAttributeUri(self, index):",
          "",
          "[Added Lines]",
          "943:     def getAttributeUri(self, index: int):",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "820:         return uri",
          "823:         \"\"\"",
          "824:         Return the Namespace URI (if any) for the attribute",
          "825:         \"\"\"",
          "",
          "[Removed Lines]",
          "822:     def getAttributeNamespace(self, index):",
          "",
          "[Added Lines]",
          "954:     def getAttributeNamespace(self, index: int):",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "834:         return self.sb[uri]",
          "837:         \"\"\"",
          "838:         Returns the String which represents the attribute name",
          "839:         \"\"\"",
          "",
          "[Removed Lines]",
          "836:     def getAttributeName(self, index):",
          "",
          "[Added Lines]",
          "968:     def getAttributeName(self, index: int):",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "844:         res = self.sb[name]",
          "845:         # If the result is a (null) string, we need to look it up.",
          "847:             attr = self.m_resourceIDs[name]",
          "848:             if attr in public.SYSTEM_RESOURCES['attributes']['inverse']:",
          "855:         return res",
          "858:         \"\"\"",
          "859:         Return the type of the attribute at the given index",
          "",
          "[Removed Lines]",
          "846:         if not res or res == \":\":",
          "849:                 res = 'android:' + \\",
          "850:                     public.SYSTEM_RESOURCES['attributes']['inverse'][attr]",
          "851:             else:",
          "852:                 # Attach the HEX Number, so for multiple missing attributes we do not run",
          "853:                 # into problems.",
          "854:                 res = 'android:UNKNOWN_SYSTEM_ATTRIBUTE_{:08x}'.format(attr)",
          "857:     def getAttributeValueType(self, index):",
          "",
          "[Added Lines]",
          "978:         if name < len(self.m_resourceIDs):",
          "981:                 res = public.SYSTEM_RESOURCES['attributes']['inverse'][",
          "982:                     attr",
          "983:                 ].replace(\"_\", \":\")",
          "984:                 if res != self.sb[name]:",
          "985:                     self.packerwarning = True",
          "987:         if not res or res == \":\":",
          "988:             # Attach the HEX Number, so for multiple missing attributes we do not run",
          "989:             # into problems.",
          "990:             res = 'android:UNKNOWN_SYSTEM_ATTRIBUTE_{:08x}'.format(attr)",
          "993:     def getAttributeValueType(self, index: int):",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "865:         offset = self._get_attribute_offset(index)",
          "866:         return self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]",
          "869:         \"\"\"",
          "870:         Return the data of the attribute at the given index",
          "",
          "[Removed Lines]",
          "868:     def getAttributeValueData(self, index):",
          "",
          "[Added Lines]",
          "1004:     def getAttributeValueData(self, index: int):",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "895:         return ''",
          "899:     \"\"\"",
          "900:     Format a value based on type and data.",
          "901:     By default, no strings are looked up and \"<string>\" is returned.",
          "",
          "[Removed Lines]",
          "898: def format_value(_type, _data, lookup_string=lambda ix: \"<string>\"):",
          "",
          "[Added Lines]",
          "1034: def format_value(",
          "1035:     _type: int, _data: int, lookup_string=lambda ix: \"<string>\"",
          "1036: ) -> str:",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "935:         return \"true\"",
          "937:     elif _type == TYPE_DIMENSION:",
          "940:     elif _type == TYPE_FRACTION:",
          "943:     elif TYPE_FIRST_COLOR_INT <= _type <= TYPE_LAST_COLOR_INT:",
          "944:         return \"#%08X\" % _data",
          "",
          "[Removed Lines]",
          "938:         return \"{:f}{}\".format(complexToFloat(_data), DIMENSION_UNITS[_data & COMPLEX_UNIT_MASK])",
          "941:         return \"{:f}{}\".format(complexToFloat(_data) * 100, FRACTION_UNITS[_data & COMPLEX_UNIT_MASK])",
          "",
          "[Added Lines]",
          "1076:         return \"{:f}{}\".format(",
          "1077:             complexToFloat(_data), DIMENSION_UNITS[_data & COMPLEX_UNIT_MASK]",
          "1078:         )",
          "1081:         return \"{:f}{}\".format(",
          "1082:             complexToFloat(_data) * 100,",
          "1083:             FRACTION_UNITS[_data & COMPLEX_UNIT_MASK],",
          "1084:         )",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "957:     A Reference Implementation can be found at http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt/XMLNode.cpp",
          "958:     \"\"\"",
          "959:     __charrange = None",
          "960:     __replacement = None",
          "963:         logger.debug(\"AXMLPrinter\")",
          "965:         self.axml = AXMLParser(raw_buff)",
          "",
          "[Removed Lines]",
          "962:     def __init__(self, raw_buff):",
          "",
          "[Added Lines]",
          "1106:     def __init__(self, raw_buff: bytes) -> bytes:",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "973:             logger.debug(\"DEBUG ARSC TYPE {}\".format(_type))",
          "975:             if _type == START_TAG:",
          "976:                 uri = self._print_namespace(self.axml.namespace)",
          "977:                 uri, name = self._fix_name(uri, self.axml.name)",
          "978:                 tag = \"{}{}\".format(uri, name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1120:                 if not self.axml.name:  # Check if the name is empty",
          "1121:                     logger.debug(\"Empty tag name, skipping to next element\")",
          "1122:                     continue  # Skip this iteration",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "981:                 if comment:",
          "982:                     if self.root is None:",
          "983:                         logger.warning(",
          "985:                     else:",
          "986:                         cur[-1].append(etree.Comment(comment))",
          "992:                 for i in range(self.axml.getAttributeCount()):",
          "995:                     value = self._fix_value(self._get_attribute_value(i))",
          "999:                     if \"{}{}\".format(uri, name) in elem.attrib:",
          "1000:                         logger.warning(",
          "1002:                     elem.set(\"{}{}\".format(uri, name), value)",
          "1004:                 if self.root is None:",
          "",
          "[Removed Lines]",
          "984:                             \"Can not attach comment with content '{}' without root!\".format(comment))",
          "988:                 logger.debug(\"START_TAG: {} (line={})\".format(",
          "989:                     tag, self.axml.m_lineNumber))",
          "990:                 elem = etree.Element(tag, nsmap=self.axml.nsmap)",
          "993:                     uri = self._print_namespace(self.axml.getAttributeNamespace(i))",
          "994:                     uri, name = self._fix_name(uri, self.axml.getAttributeName(i))",
          "997:                     logger.debug(\"found an attribute: {}{}='{}'\".format(",
          "998:                         uri, name, value.encode(\"utf-8\")))",
          "1001:                             \"Duplicate attribute '{}{}'! Will overwrite!\".format(uri, name))",
          "",
          "[Added Lines]",
          "1131:                             \"Can not attach comment with content '{}' without root!\".format(",
          "1132:                                 comment",
          "1133:                             )",
          "1134:                         )",
          "1138:                 logger.debug(",
          "1139:                     \"START_TAG: {} (line={})\".format(",
          "1140:                         tag, self.axml.m_lineNumber",
          "1141:                     )",
          "1142:                 )",
          "1144:                 try:",
          "1145:                     elem = etree.Element(tag, nsmap=self.axml.nsmap)",
          "1146:                 except ValueError as e:",
          "1147:                     logger.error(e)",
          "1148:                     # nsmap= {'<!--': 'http://schemas.android.com/apk/res/android'} | pull/1056",
          "1149:                     if 'Invalid namespace prefix' in str(e):",
          "1150:                         corrected_nsmap = self.clean_and_replace_nsmap(",
          "1151:                             self.axml.nsmap, str(e).split(\"'\")[1]",
          "1152:                         )",
          "1153:                         elem = etree.Element(tag, nsmap=corrected_nsmap)",
          "1154:                     else:",
          "1155:                         raise",
          "1158:                     uri = self._print_namespace(",
          "1159:                         self.axml.getAttributeNamespace(i)",
          "1160:                     )",
          "1161:                     uri, name = self._fix_name(",
          "1162:                         uri, self.axml.getAttributeName(i)",
          "1163:                     )",
          "1166:                     logger.debug(",
          "1167:                         \"found an attribute: {}{}='{}'\".format(",
          "1168:                             uri, name, value.encode(\"utf-8\")",
          "1169:                         )",
          "1170:                     )",
          "1173:                             \"Duplicate attribute '{}{}'! Will overwrite!\".format(",
          "1174:                                 uri, name",
          "1175:                             )",
          "1176:                         )",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1007:                     if not cur:",
          "1008:                         # looks like we lost the root?",
          "1009:                         logger.error(",
          "1011:                         break",
          "1012:                     cur[-1].append(elem)",
          "1013:                 cur.append(elem)",
          "",
          "[Removed Lines]",
          "1010:                             \"No more elements available to attach to! Is the XML malformed?\")",
          "",
          "[Added Lines]",
          "1185:                             \"No more elements available to attach to! Is the XML malformed?\"",
          "1186:                         )",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1015:             if _type == END_TAG:",
          "1016:                 if not cur:",
          "1017:                     logger.warning(",
          "1020:                 name = self.axml.name",
          "1021:                 uri = self._print_namespace(self.axml.namespace)",
          "1022:                 tag = \"{}{}\".format(uri, name)",
          "1023:                 if cur[-1].tag != tag:",
          "1026:                 cur.pop()",
          "1027:             if _type == TEXT:",
          "1028:                 logger.debug(\"TEXT for {}\".format(cur[-1]))",
          "",
          "[Removed Lines]",
          "1018:                         \"Too many END_TAG! No more elements available to attach to!\")",
          "1024:                     logger.warning(\"Closing tag '{}' does not match current stack! At line number: {}. Is the XML malformed?\".format(",
          "1025:                         self.axml.name, self.axml.m_lineNumber))",
          "",
          "[Added Lines]",
          "1194:                         \"Too many END_TAG! No more elements available to attach to!\"",
          "1195:                     )",
          "1196:                 else:",
          "1197:                     if not self.axml.name:  # Check if the name is empty",
          "1198:                         logger.debug(",
          "1199:                             \"Empty tag name at END_TAG, skipping to next element\"",
          "1200:                         )",
          "1201:                         continue",
          "1207:                     logger.warning(",
          "1208:                         \"Closing tag '{}' does not match current stack! At line number: {}. Is the XML malformed?\".format(",
          "1209:                             self.axml.name, self.axml.m_lineNumber",
          "1210:                         )",
          "1211:                     )",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1031:                 # Check if all namespace mappings are closed",
          "1032:                 if len(self.axml.namespaces) > 0:",
          "1033:                     logger.warning(",
          "1035:                 break",
          "1038:         \"\"\"",
          "1039:         Returns the raw XML file without prettification applied.",
          "",
          "[Removed Lines]",
          "1034:                         \"Not all namespace mappings were closed! Malformed AXML?\")",
          "1037:     def get_buff(self):",
          "",
          "[Added Lines]",
          "1220:                         \"Not all namespace mappings were closed! Malformed AXML?\"",
          "1221:                     )",
          "1224:     def clean_and_replace_nsmap(self, nsmap, invalid_prefix):",
          "1225:         correct_prefix = 'android'",
          "1226:         corrected_nsmap = {}",
          "1227:         for prefix, uri in nsmap.items():",
          "1228:             if prefix.startswith(invalid_prefix):",
          "1229:                 corrected_nsmap[correct_prefix] = uri",
          "1230:             else:",
          "1231:                 corrected_nsmap[prefix] = uri",
          "1232:         return corrected_nsmap",
          "1234:     def get_buff(self) -> bytes:",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1042:         \"\"\"",
          "1043:         return self.get_xml(pretty=False)",
          "1046:         \"\"\"",
          "1047:         Get the XML as an UTF-8 string",
          "",
          "[Removed Lines]",
          "1045:     def get_xml(self, pretty=True):",
          "",
          "[Added Lines]",
          "1242:     def get_xml(self, pretty: bool = True) -> bytes:",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1050:         \"\"\"",
          "1051:         return etree.tostring(self.root, encoding=\"utf-8\", pretty_print=pretty)",
          "1054:         \"\"\"",
          "1055:         Get the XML as an ElementTree object",
          "",
          "[Removed Lines]",
          "1053:     def get_xml_obj(self):",
          "",
          "[Added Lines]",
          "1250:     def get_xml_obj(self) -> etree.Element:",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1058:         \"\"\"",
          "1059:         return self.root",
          "1062:         \"\"\"",
          "1063:         Return the state of the AXMLParser.",
          "1064:         If this flag is set to False, the parsing has failed, thus",
          "",
          "[Removed Lines]",
          "1061:     def is_valid(self):",
          "",
          "[Added Lines]",
          "1258:     def is_valid(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1066:         \"\"\"",
          "1067:         return self.axml.is_valid()",
          "1070:         \"\"\"",
          "1071:         Returns True if the AXML is likely to be packed",
          "",
          "[Removed Lines]",
          "1069:     def is_packed(self):",
          "",
          "[Added Lines]",
          "1266:     def is_packed(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1078:         :returns: True if packer detected, False otherwise",
          "1079:         \"\"\"",
          "1083:         \"\"\"",
          "1084:         Wrapper function for format_value to resolve the actual value of an attribute in a tag",
          "1085:         :param index: index of the current attribute",
          "",
          "[Removed Lines]",
          "1080:         return self.packerwarning",
          "1082:     def _get_attribute_value(self, index):",
          "",
          "[Added Lines]",
          "1277:         return self.packerwarning or self.axml.packerwarning",
          "1279:     def _get_attribute_value(self, index: int):",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1088:         _type = self.axml.getAttributeValueType(index)",
          "1089:         _data = self.axml.getAttributeValueData(index)",
          "1093:     def _fix_name(self, prefix, name):",
          "1094:         \"\"\"",
          "",
          "[Removed Lines]",
          "1091:         return format_value(_type, _data, lambda _: self.axml.getAttributeValue(index))",
          "",
          "[Added Lines]",
          "1288:         return format_value(",
          "1289:             _type, _data, lambda _: self.axml.getAttributeValue(index)",
          "1290:         )",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1114:         :rtype: tuple",
          "1115:         \"\"\"",
          "1116:         if not name[0].isalpha() and name[0] != \"_\":",
          "1119:             self.packerwarning = True",
          "1120:             name = \"_{}\".format(name)",
          "1122:             # Seems be a common thing...",
          "1123:             logger.info(",
          "1125:             prefix = self._print_namespace(self.axml.nsmap['android'])",
          "1126:             name = name[len(\"android:\"):]",
          "1127:             # It looks like this is some kind of packer... Not sure though.",
          "",
          "[Removed Lines]",
          "1117:             logger.warning(\"Invalid start for name '{}'. \"",
          "1118:                            \"XML name must start with a letter.\".format(name))",
          "1121:         if name.startswith(\"android:\") and prefix == '' and 'android' in self.axml.nsmap:",
          "1124:                 \"Name '{}' starts with 'android:' prefix but 'android' is a known prefix. Replacing prefix.\".format(name))",
          "",
          "[Added Lines]",
          "1316:             logger.warning(",
          "1317:                 \"Invalid start for name '{}'. \"",
          "1318:                 \"XML name must start with a letter.\".format(name)",
          "1319:             )",
          "1322:         if (",
          "1323:             name.startswith(\"android:\")",
          "1324:             and prefix == ''",
          "1325:             and 'android' in self.axml.nsmap",
          "1326:         ):",
          "1329:                 \"Name '{}' starts with 'android:' prefix but 'android' is a known prefix. Replacing prefix.\".format(",
          "1330:                     name",
          "1331:                 )",
          "1332:             )",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1131:             embedded_prefix, new_name = name.split(\":\", 1)",
          "1132:             if embedded_prefix in self.axml.nsmap:",
          "1133:                 logger.info(",
          "1136:                 name = new_name",
          "1137:             else:",
          "1138:                 # Print out an extra warning",
          "1141:         if not re.match(r\"^[a-zA-Z0-9._-]*$\", name):",
          "1143:             self.packerwarning = True",
          "1144:             name = re.sub(r\"[^a-zA-Z0-9._-]\", \"_\", name)",
          "",
          "[Removed Lines]",
          "1134:                     \"Prefix '{}' is in namespace mapping, assume that it is a prefix.\")",
          "1135:                 prefix = self._print_namespace(self.axml.nsmap[embedded_prefix])",
          "1139:                 logger.warning(\"Confused: name contains a unknown namespace prefix: '{}'. \"",
          "1140:                                \"This is either a broken AXML file or some attempt to break stuff.\".format(name))",
          "1142:             logger.warning(\"Name '{}' contains invalid characters!\".format(name))",
          "",
          "[Added Lines]",
          "1342:                     \"Prefix '{}' is in namespace mapping, assume that it is a prefix.\"",
          "1343:                 )",
          "1344:                 prefix = self._print_namespace(",
          "1345:                     self.axml.nsmap[embedded_prefix]",
          "1346:                 )",
          "1350:                 logger.warning(",
          "1351:                     \"Confused: name contains a unknown namespace prefix: '{}'. \"",
          "1352:                     \"This is either a broken AXML file or some attempt to break stuff.\".format(",
          "1353:                         name",
          "1354:                     )",
          "1355:                 )",
          "1357:             logger.warning(",
          "1358:                 \"Name '{}' contains invalid characters!\".format(name)",
          "1359:             )",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1158:         \"\"\"",
          "1159:         if not self.__charrange or not self.__replacement:",
          "1160:             self.__charrange = re.compile(",
          "1162:             self.__replacement = re.compile(",
          "1165:         # Reading string until \\x00. This is the same as aapt does.",
          "1166:         if \"\\x00\" in value:",
          "1167:             self.packerwarning = True",
          "1174:         if not self.__charrange.match(value):",
          "1176:             self.packerwarning = True",
          "1177:             value = self.__replacement.sub('_', value)",
          "1178:         return value",
          "",
          "[Removed Lines]",
          "1161:                 '^[\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$')",
          "1163:                 '[^\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]')",
          "1168:             logger.warning(\"Null byte found in attribute value at position {}: \"",
          "1169:                            \"Value(hex): '{}'\".format(",
          "1170:                                value.find(\"\\x00\"),",
          "1171:                                binascii.hexlify(value.encode(\"utf-8\"))))",
          "1172:             value = value[:value.find(\"\\x00\")]",
          "1175:             logger.warning(\"Invalid character in value found. Replacing with '_'.\")",
          "",
          "[Added Lines]",
          "1378:                 '^[\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$'",
          "1379:             )",
          "1381:                 '[^\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]'",
          "1382:             )",
          "1387:             logger.warning(",
          "1388:                 \"Null byte found in attribute value at position {}: \"",
          "1389:                 \"Value(hex): '{}'\".format(",
          "1390:                     value.find(\"\\x00\"), binascii.hexlify(value.encode(\"utf-8\"))",
          "1391:                 )",
          "1392:             )",
          "1393:             value = value[: value.find(\"\\x00\")]",
          "1396:             logger.warning(",
          "1397:                 \"Invalid character in value found. Replacing with '_'.\"",
          "1398:             )",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1182:             uri = \"{{{}}}\".format(uri)",
          "1183:         return uri",
          "1188: ACONFIGURATION_ORIENTATION_ANY = 0x0000",
          "1189: ACONFIGURATION_ORIENTATION_PORT = 0x0001",
          "",
          "[Removed Lines]",
          "1185: # See http://aospxref.com/android-13.0.0_r3/xref/frameworks/native/include/android/configuration.h#56",
          "",
          "[Added Lines]",
          "1409: # See http://aospxref.com/android-13.0.0_r3/xref/frameworks/native/include/android/configuration.h#56",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1201: ACONFIGURATION_DENSITY_XHIGH = 320",
          "1202: ACONFIGURATION_DENSITY_XXHIGH = 480",
          "1203: ACONFIGURATION_DENSITY_XXXHIGH = 640",
          "1206: ACONFIGURATION_KEYBOARD_ANY = 0x0000",
          "1207: ACONFIGURATION_KEYBOARD_NOKEYS = 0x0001",
          "1208: ACONFIGURATION_KEYBOARD_QWERTY = 0x0002",
          "",
          "[Removed Lines]",
          "1204: ACONFIGURATION_DENSITY_ANY = 0xfffe",
          "1205: ACONFIGURATION_DENSITY_NONE = 0xffff",
          "",
          "[Added Lines]",
          "1427: ACONFIGURATION_DENSITY_ANY = 0xFFFE",
          "1428: ACONFIGURATION_DENSITY_NONE = 0xFFFF",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1270: ACONFIGURATION_LAYOUTDIR = 0x4000",
          "1271: ACONFIGURATION_SCREEN_ROUND = 0x8000",
          "1272: ACONFIGURATION_COLOR_MODE = 0x10000",
          "1275: # See http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#946",
          "",
          "[Removed Lines]",
          "1273: ACONFIGURATION_MNC_ZERO = 0xffff",
          "",
          "[Added Lines]",
          "1496: ACONFIGURATION_MNC_ZERO = 0xFFFF",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1312: KEYSHIDDEN_YES = ACONFIGURATION_KEYSHIDDEN_YES",
          "1313: KEYSHIDDEN_SOFT = ACONFIGURATION_KEYSHIDDEN_SOFT",
          "1316: SHIFT_NAVHIDDEN = 2",
          "1317: NAVHIDDEN_ANY = ACONFIGURATION_NAVHIDDEN_ANY << SHIFT_NAVHIDDEN",
          "1318: NAVHIDDEN_NO = ACONFIGURATION_NAVHIDDEN_NO << SHIFT_NAVHIDDEN",
          "",
          "[Removed Lines]",
          "1315: MASK_NAVHIDDEN = 0x000c",
          "",
          "[Added Lines]",
          "1538: MASK_NAVHIDDEN = 0x000C",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1323: SDKVERSION_ANY = 0",
          "1324: MINORVERSION_ANY = 0",
          "1327: SCREENSIZE_ANY = ACONFIGURATION_SCREENSIZE_ANY",
          "1328: SCREENSIZE_SMALL = ACONFIGURATION_SCREENSIZE_SMALL",
          "1329: SCREENSIZE_NORMAL = ACONFIGURATION_SCREENSIZE_NORMAL",
          "",
          "[Removed Lines]",
          "1326: MASK_SCREENSIZE = 0x0f",
          "",
          "[Added Lines]",
          "1549: MASK_SCREENSIZE = 0x0F",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1342: LAYOUTDIR_LTR = ACONFIGURATION_LAYOUTDIR_LTR << SHIFT_LAYOUTDIR",
          "1343: LAYOUTDIR_RTL = ACONFIGURATION_LAYOUTDIR_RTL << SHIFT_LAYOUTDIR",
          "1346: UI_MODE_TYPE_ANY = ACONFIGURATION_UI_MODE_TYPE_ANY",
          "1347: UI_MODE_TYPE_NORMAL = ACONFIGURATION_UI_MODE_TYPE_NORMAL",
          "1348: UI_MODE_TYPE_DESK = ACONFIGURATION_UI_MODE_TYPE_DESK",
          "",
          "[Removed Lines]",
          "1345: MASK_UI_MODE_TYPE = 0x0f",
          "",
          "[Added Lines]",
          "1568: MASK_UI_MODE_TYPE = 0x0F",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1368: WIDE_COLOR_GAMUT_NO = ACONFIGURATION_WIDE_COLOR_GAMUT_NO",
          "1369: WIDE_COLOR_GAMUT_YES = ACONFIGURATION_WIDE_COLOR_GAMUT_YES",
          "1372: SHIFT_HDR = 2",
          "1373: HDR_ANY = ACONFIGURATION_HDR_ANY << SHIFT_HDR",
          "1374: HDR_NO = ACONFIGURATION_HDR_NO << SHIFT_HDR",
          "",
          "[Removed Lines]",
          "1371: MASK_HDR = 0x0c",
          "",
          "[Added Lines]",
          "1594: MASK_HDR = 0x0C",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1389:     It contains again many more chunks.",
          "1390:     \"\"\"",
          "1393:         \"\"\"",
          "1394:         :param bytes raw_buff: the raw bytes of the file",
          "1395:         \"\"\"",
          "",
          "[Removed Lines]",
          "1392:     def __init__(self, raw_buff):",
          "",
          "[Added Lines]",
          "1615:     def __init__(self, raw_buff: bytes) -> None:",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1399:         if self.buff_size < 8 or self.buff_size > 0xFFFFFFFF:",
          "1400:             raise ResParserError(",
          "1403:         self.analyzed = False",
          "1404:         self._resolved_strings = None",
          "",
          "[Removed Lines]",
          "1401:                 \"Invalid file size {} for a resources.arsc file!\".format(self.buff.size()))",
          "",
          "[Added Lines]",
          "1624:                 \"Invalid file size {} for a resources.arsc file!\".format(",
          "1625:                     self.buff_size",
          "1626:                 )",
          "1627:             )",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "1415:         # More sanity checks...",
          "1416:         if self.header.header_size != 12:",
          "1420:         if self.header.size > self.buff_size:",
          "1424:         if self.header.size < self.buff_size:",
          "1428:         # The ResTable_header contains the packageCount, i.e. the number of ResTable_package",
          "1429:         self.packageCount = unpack('<I', self.buff.read(4))[0]",
          "",
          "[Removed Lines]",
          "1417:             logger.warning(\"The ResTable_header has an unexpected header size! Expected 12 bytes, got {}.\".format(",
          "1418:                 self.header.header_size))",
          "1421:             raise ResParserError(\"The file seems to be truncated. Refuse to parse the file! Filesize: {}, declared size: {}\".format(",
          "1422:                 self.buff_size, self.header.size))",
          "1425:             logger.warning(\"The Resource file seems to have data appended to it. Filesize: {}, declared size: {}\".format(",
          "1426:                 self.buff_size, self.header.size))",
          "",
          "[Added Lines]",
          "1643:             logger.warning(",
          "1644:                 \"The ResTable_header has an unexpected header size! Expected 12 bytes, got {}.\".format(",
          "1645:                     self.header.header_size",
          "1646:                 )",
          "1647:             )",
          "1650:             raise ResParserError(",
          "1651:                 \"The file seems to be truncated. Refuse to parse the file! Filesize: {}, declared size: {}\".format(",
          "1652:                     self.buff_size, self.header.size",
          "1653:                 )",
          "1654:             )",
          "1657:             logger.warning(",
          "1658:                 \"The Resource file seems to have data appended to it. Filesize: {}, declared size: {}\".format(",
          "1659:                     self.buff_size, self.header.size",
          "1660:                 )",
          "1661:             )",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "1431:         # Even more sanity checks...",
          "1432:         if self.packageCount < 1:",
          "1433:             logger.warning(",
          "1436:         logger.debug(",
          "1439:         # skip to the start of the first chunk's data, skipping trailing header bytes (there should be none)",
          "1440:         self.buff.seek(self.header.start + self.header.header_size)",
          "",
          "[Removed Lines]",
          "1434:                 \"The number of packages is smaller than one. There should be at least one package!\")",
          "1437:             \"Parsed ResTable_header with {} package(s) inside.\".format(self.packageCount))",
          "",
          "[Added Lines]",
          "1669:                 \"The number of packages is smaller than one. There should be at least one package!\"",
          "1670:             )",
          "1673:             \"Parsed ResTable_header with {} package(s) inside.\".format(",
          "1674:                 self.packageCount",
          "1675:             )",
          "1676:         )",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "1447:             if res_header.end > self.header.end:",
          "1448:                 # this inner chunk crosses the boundary of the table chunk",
          "1449:                 logger.warning(",
          "1451:                 break",
          "1453:             if res_header.type == RES_STRING_POOL_TYPE:",
          "1454:                 # There should be only one StringPool per resource table.",
          "1455:                 if self.stringpool_main:",
          "1456:                     logger.warning(",
          "1458:                 else:",
          "1459:                     self.stringpool_main = StringBlock(self.buff, res_header)",
          "1462:             elif res_header.type == RES_TABLE_PACKAGE_TYPE:",
          "1463:                 if len(self.packages) > self.packageCount:",
          "1467:                 current_package = ARSCResTablePackage(self.buff, res_header)",
          "1468:                 package_name = current_package.get_name()",
          "1470:                 # After the Header, we have the resource type symbol table",
          "1473:                 type_sp_header = ARSCHeader(",
          "1475:                 mTableStrings = StringBlock(self.buff, type_sp_header)",
          "1477:                 # Next, we should have the resource key symbol table",
          "1480:                 key_sp_header = ARSCHeader(",
          "1482:                 mKeyStrings = StringBlock(self.buff, key_sp_header)",
          "1484:                 # Add them to the dict of read packages",
          "",
          "[Removed Lines]",
          "1450:                     \"Invalid chunk found! It is larger than the outer chunk: %s\", res_header)",
          "1457:                         \"Already found a ResStringPool_header, but there should be only one! Will not parse the Pool again.\")",
          "1460:                     logger.debug(\"Found the main string pool: %s\", self.stringpool_main)",
          "1464:                     raise ResParserError(\"Got more packages ({}) than expected ({})\".format(",
          "1465:                         len(self.packages), self.packageCount))",
          "1471:                 self.buff.seek(current_package.header.start",
          "1472:                                + current_package.typeStrings)",
          "1474:                     self.buff, expected_type=RES_STRING_POOL_TYPE)",
          "1478:                 self.buff.seek(current_package.header.start",
          "1479:                                + current_package.keyStrings)",
          "1481:                     self.buff, expected_type=RES_STRING_POOL_TYPE)",
          "",
          "[Added Lines]",
          "1689:                     \"Invalid chunk found! It is larger than the outer chunk: %s\",",
          "1690:                     res_header,",
          "1691:                 )",
          "1698:                         \"Already found a ResStringPool_header, but there should be only one! Will not parse the Pool again.\"",
          "1699:                     )",
          "1702:                     logger.debug(",
          "1703:                         \"Found the main string pool: %s\", self.stringpool_main",
          "1704:                     )",
          "1708:                     raise ResParserError(",
          "1709:                         \"Got more packages ({}) than expected ({})\".format(",
          "1710:                             len(self.packages), self.packageCount",
          "1711:                         )",
          "1712:                     )",
          "1718:                 self.buff.seek(",
          "1719:                     current_package.header.start + current_package.typeStrings",
          "1720:                 )",
          "1722:                     self.buff, expected_type=RES_STRING_POOL_TYPE",
          "1723:                 )",
          "1727:                 self.buff.seek(",
          "1728:                     current_package.header.start + current_package.keyStrings",
          "1729:                 )",
          "1731:                     self.buff, expected_type=RES_STRING_POOL_TYPE",
          "1732:                 )",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "1487:                 self.packages[package_name].append(mKeyStrings)",
          "1489:                 pc = PackageContext(",
          "1491:                 logger.debug(\"Constructed a PackageContext: %s\", pc)",
          "1493:                 # skip to the first header in this table package chunk",
          "",
          "[Removed Lines]",
          "1490:                     current_package, self.stringpool_main, mTableStrings, mKeyStrings)",
          "",
          "[Added Lines]",
          "1741:                     current_package,",
          "1742:                     self.stringpool_main,",
          "1743:                     mTableStrings,",
          "1744:                     mKeyStrings,",
          "1745:                 )",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "1496:                 # this looks more like we want: (???)",
          "1497:                 # FIXME it looks like that the two string pools we have read might not be concatenated to each other,",
          "1498:                 # thus jumping to the sum of the sizes might not be correct...",
          "1502:                 if next_idx != self.buff.tell():",
          "1503:                     # If this happens, we have a testfile ;)",
          "1504:                     logger.error(\"This looks like an odd resources.arsc file!\")",
          "1505:                     logger.error(",
          "1509:                     logger.error(",
          "1511:                     logger.error(\"Thank you!\")",
          "1513:                 self.buff.seek(next_idx)",
          "",
          "[Removed Lines]",
          "1499:                 next_idx = res_header.start + res_header.header_size + \\",
          "1500:                     type_sp_header.size + key_sp_header.size",
          "1506:                         \"Please report this error including the file you have parsed!\")",
          "1507:                     logger.error(\"next_idx = {}, current buffer position = {}\".format(",
          "1508:                         next_idx, self.buff.tell()))",
          "1510:                         \"Please open a issue at https://github.com/androguard/androguard/issues\")",
          "",
          "[Added Lines]",
          "1754:                 next_idx = (",
          "1755:                     res_header.start",
          "1756:                     + res_header.header_size",
          "1757:                     + type_sp_header.size",
          "1758:                     + key_sp_header.size",
          "1759:                 )",
          "1765:                         \"Please report this error including the file you have parsed!\"",
          "1766:                     )",
          "1768:                         \"next_idx = {}, current buffer position = {}\".format(",
          "1769:                             next_idx, self.buff.tell()",
          "1770:                         )",
          "1771:                     )",
          "1772:                     logger.error(",
          "1773:                         \"Please open a issue at https://github.com/androguard/androguard/issues\"",
          "1774:                     )",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "1516:                 while self.buff.tell() <= res_header.end - ARSCHeader.SIZE:",
          "1517:                     pkg_chunk_header = ARSCHeader(self.buff)",
          "1518:                     logger.debug(\"Found a header: {}\".format(pkg_chunk_header))",
          "1520:                         # we are way off the package chunk; bail out",
          "1521:                         break",
          "",
          "[Removed Lines]",
          "1519:                     if pkg_chunk_header.start + pkg_chunk_header.size > res_header.end:",
          "",
          "[Added Lines]",
          "1783:                     if (",
          "1784:                         pkg_chunk_header.start + pkg_chunk_header.size",
          "1785:                         > res_header.end",
          "1786:                     ):",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "1525:                     if pkg_chunk_header.type == RES_TABLE_TYPE_SPEC_TYPE:",
          "1526:                         self.packages[package_name].append(",
          "1529:                     elif pkg_chunk_header.type == RES_TABLE_TYPE_TYPE:",
          "1530:                         # Parse a RES_TABLE_TYPE",
          "1531:                         # http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt2/format/binary/BinaryResourceParser.cpp#311",
          "1532:                         a_res_type = ARSCResType(self.buff, pc)",
          "1533:                         self.packages[package_name].append(a_res_type)",
          "1534:                         self.resource_configs[package_name][a_res_type].add(",
          "1537:                         logger.debug(\"Config: {}\".format(a_res_type.config))",
          "1539:                         entries = []",
          "1540:                         for i in range(0, a_res_type.entryCount):",
          "1545:                         self.packages[package_name].append(entries)",
          "1550:                                 self.packages[package_name].append(ate)",
          "1551:                                 if ate.is_weak():",
          "1552:                                     # FIXME we are not sure how to implement the FLAG_WEAK!",
          "",
          "[Removed Lines]",
          "1527:                             ARSCResTypeSpec(self.buff, pc))",
          "1535:                             a_res_type.config)",
          "1541:                             current_package.mResId = current_package.mResId & 0xffff0000 | i",
          "1542:                             entries.append((unpack('<i', self.buff.read(4))[",
          "1543:                                            0], current_package.mResId))",
          "1547:                         for entry, res_id in entries:",
          "1548:                             if entry != -1:",
          "1549:                                 ate = ARSCResTableEntry(self.buff, res_id, pc)",
          "",
          "[Added Lines]",
          "1794:                             ARSCResTypeSpec(self.buff, pc)",
          "1795:                         )",
          "1800:                         start_of_chunk = self.buff.tell() - 8",
          "1801:                         expected_end_of_chunk = (",
          "1802:                             start_of_chunk + pkg_chunk_header.size",
          "1803:                         )",
          "1807:                             a_res_type.config",
          "1808:                         )",
          "1813:                         FLAG_OFFSET16 = 0x02",
          "1814:                         NO_ENTRY_16 = 0xFFFF",
          "1815:                         NO_ENTRY_32 = 0xFFFFFFFF",
          "1816:                         expected_entries_start = (",
          "1817:                             start_of_chunk + a_res_type.entriesStart",
          "1818:                         )",
          "1820:                         # Helper function to convert 16-bit offset to 32-bit",
          "1821:                         def offset_from16(off16):",
          "1822:                             return (",
          "1823:                                 NO_ENTRY_16",
          "1824:                                 if off16 == NO_ENTRY_16",
          "1825:                                 else off16 * 4",
          "1826:                             )",
          "1829:                             current_package.mResId = (",
          "1830:                                 current_package.mResId & 0xFFFF0000 | i",
          "1831:                             )",
          "1832:                             # Check if FLAG_OFFSET16 is set",
          "1833:                             if a_res_type.flags & FLAG_OFFSET16:",
          "1834:                                 # Read as 16-bit offset",
          "1835:                                 offset_16 = unpack('<H', self.buff.read(2))[0]",
          "1836:                                 offset = offset_from16(offset_16)",
          "1837:                                 if offset == NO_ENTRY_16:",
          "1838:                                     continue",
          "1839:                             else:",
          "1840:                                 # Read as 32-bit offset",
          "1841:                                 offset = unpack('<I', self.buff.read(4))[0]",
          "1842:                                 if offset == NO_ENTRY_32:",
          "1843:                                     continue",
          "1844:                             entries.append((offset, current_package.mResId))",
          "1848:                         base_offset = self.buff.tell()",
          "1849:                         if base_offset + ((4 - (base_offset % 4)) % 4) != expected_entries_start:",
          "1850:                             # FIXME: seems like I am missing 2 bytes here in some cases, though it does not affect the result",
          "1851:                             logger.warning(",
          "1852:                                 \"Something is off here! We are not where the entries should start.\"",
          "1853:                             )",
          "1854:                         base_offset = expected_entries_start",
          "1855:                         for entry_offset, res_id in entries:",
          "1856:                             if entry_offset != -1:",
          "1857:                                 ate = ARSCResTableEntry(",
          "1858:                                     self.buff,",
          "1859:                                     base_offset + entry_offset,",
          "1860:                                     expected_end_of_chunk,",
          "1861:                                     res_id,",
          "1862:                                     pc,",
          "1863:                                 )",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "1558:                                     # Not sure if this is a good solution though",
          "1559:                                     self.buff.seek(ate.start)",
          "1560:                     elif pkg_chunk_header.type == RES_TABLE_LIBRARY_TYPE:",
          "1562:                     else:",
          "1563:                         # Unknown / not-handled chunk type",
          "1564:                         logger.warning(",
          "1567:                     # skip to the next chunk",
          "1568:                     self.buff.seek(pkg_chunk_header.end)",
          "1569:             else:",
          "1570:                 # Unknown / not-handled chunk type",
          "1573:             # move to the next resource chunk",
          "1574:             self.buff.seek(res_header.end)",
          "",
          "[Removed Lines]",
          "1561:                         logger.warning(\"RES_TABLE_LIBRARY_TYPE chunk is not supported\")",
          "1565:                             \"Unknown chunk type encountered inside RES_TABLE_PACKAGE: %s\", pkg_chunk_header)",
          "1571:                 logger.warning(\"Unknown chunk type encountered: %s\", res_header)",
          "",
          "[Added Lines]",
          "1875:                         logger.warning(",
          "1876:                             \"RES_TABLE_LIBRARY_TYPE chunk is not supported\"",
          "1877:                         )",
          "1881:                             \"Unknown chunk type encountered inside RES_TABLE_PACKAGE: %s\",",
          "1882:                             pkg_chunk_header,",
          "1883:                         )",
          "1889:                 logger.warning(",
          "1890:                     \"Unknown chunk type encountered: %s\", res_header",
          "1891:                 )",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "1592:                         locale = a_res_type.config.get_language_and_region()",
          "1594:                         c_value = self.values[package_name].setdefault(",
          "1597:                         entries = self.packages[package_name][nb + 2]",
          "1598:                         nb_i = 0",
          "1599:                         for entry, res_id in entries:",
          "1600:                             if entry != -1:",
          "1607:                                 if ate.get_index() != -1:",
          "1608:                                     c_value[\"public\"].append(",
          "1612:                                 if a_res_type.get_type() not in c_value:",
          "1613:                                     c_value[a_res_type.get_type()] = []",
          "1615:                                 if a_res_type.get_type() == \"string\":",
          "1616:                                     c_value[\"string\"].append(",
          "1619:                                 elif a_res_type.get_type() == \"id\":",
          "1621:                                         c_value[\"id\"].append(",
          "1624:                                 elif a_res_type.get_type() == \"bool\":",
          "1626:                                         c_value[\"bool\"].append(",
          "1629:                                 elif a_res_type.get_type() == \"integer\":",
          "1633:                                 elif a_res_type.get_type() == \"color\":",
          "1637:                                 elif a_res_type.get_type() == \"dimen\":",
          "1641:                                 nb_i += 1",
          "1643:                 nb += 1",
          "1646:         return [ate.get_value(), ate.get_key_data()]",
          "1649:         x = [ate.get_value()]",
          "1650:         if ate.key.get_data() == 0:",
          "1651:             x.append(\"false\")",
          "",
          "[Removed Lines]",
          "1595:                             locale, {\"public\": []})",
          "1601:                                 ate = self.packages[package_name][nb + 3 + nb_i]",
          "1603:                                 self.resource_values[ate.mResId][a_res_type.config] = ate",
          "1604:                                 self.resource_keys[package_name][a_res_type.get_type(",
          "1605:                                 )][ate.get_value()] = ate.mResId",
          "1609:                                         (a_res_type.get_type(), ate.get_value(),",
          "1610:                                          ate.mResId))",
          "1617:                                         self.get_resource_string(ate))",
          "1620:                                     if not ate.is_complex():",
          "1622:                                             self.get_resource_id(ate))",
          "1625:                                     if not ate.is_complex():",
          "1627:                                             self.get_resource_bool(ate))",
          "1630:                                     c_value[\"integer\"].append(",
          "1631:                                         self.get_resource_integer(ate))",
          "1634:                                     c_value[\"color\"].append(",
          "1635:                                         self.get_resource_color(ate))",
          "1638:                                     c_value[\"dimen\"].append(",
          "1639:                                         self.get_resource_dimen(ate))",
          "1642:                         nb += 3 + nb_i - 1  # -1 to account for the nb+=1 on the next line",
          "1645:     def get_resource_string(self, ate):",
          "1648:     def get_resource_id(self, ate):",
          "",
          "[Added Lines]",
          "1915:                             locale, {\"public\": []}",
          "1916:                         )",
          "1922:                                 ate = self.packages[package_name][",
          "1923:                                     nb + 3 + nb_i",
          "1924:                                 ]",
          "1926:                                 self.resource_values[ate.mResId][",
          "1927:                                     a_res_type.config",
          "1928:                                 ] = ate",
          "1929:                                 self.resource_keys[package_name][",
          "1930:                                     a_res_type.get_type()",
          "1931:                                 ][ate.get_value()] = ate.mResId",
          "1935:                                         (",
          "1936:                                             a_res_type.get_type(),",
          "1937:                                             ate.get_value(),",
          "1938:                                             ate.mResId,",
          "1939:                                         )",
          "1940:                                     )",
          "1947:                                         self.get_resource_string(ate)",
          "1948:                                     )",
          "1951:                                     if (",
          "1952:                                         not ate.is_complex()",
          "1953:                                         and not ate.is_compact()",
          "1954:                                     ):",
          "1956:                                             self.get_resource_id(ate)",
          "1957:                                         )",
          "1960:                                     if (",
          "1961:                                         not ate.is_complex()",
          "1962:                                         and not ate.is_compact()",
          "1963:                                     ):",
          "1965:                                             self.get_resource_bool(ate)",
          "1966:                                         )",
          "1969:                                     if ate.is_compact():",
          "1970:                                         c_value[\"integer\"].append(ate.data)",
          "1971:                                     else:",
          "1972:                                         c_value[\"integer\"].append(",
          "1973:                                             self.get_resource_integer(ate)",
          "1974:                                         )",
          "1977:                                     if not ate.is_compact():",
          "1978:                                         c_value[\"color\"].append(",
          "1979:                                             self.get_resource_color(ate)",
          "1980:                                         )",
          "1983:                                     if not ate.is_compact():",
          "1984:                                         c_value[\"dimen\"].append(",
          "1985:                                             self.get_resource_dimen(ate)",
          "1986:                                         )",
          "1989:                         nb += (",
          "1990:                             3 + nb_i - 1",
          "1991:                         )  # -1 to account for the nb+=1 on the next line",
          "1994:     def get_resource_string(self, ate: ARSCResTableEntry) -> list:",
          "1997:     def get_resource_id(self, ate: ARSCResTableEntry) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "1653:             x.append(\"true\")",
          "1654:         return x",
          "1657:         x = [ate.get_value()]",
          "1658:         if ate.key.get_data() == 0:",
          "1659:             x.append(\"false\")",
          "",
          "[Removed Lines]",
          "1656:     def get_resource_bool(self, ate):",
          "",
          "[Added Lines]",
          "2005:     def get_resource_bool(self, ate: ARSCResTableEntry) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "1661:             x.append(\"true\")",
          "1662:         return x",
          "1665:         return [ate.get_value(), ate.key.get_data()]",
          "1668:         entry_data = ate.key.get_data()",
          "1669:         return [",
          "1670:             ate.get_value(),",
          "",
          "[Removed Lines]",
          "1664:     def get_resource_integer(self, ate):",
          "1667:     def get_resource_color(self, ate):",
          "",
          "[Added Lines]",
          "2013:     def get_resource_integer(self, ate: ARSCResTableEntry) -> list:",
          "2016:     def get_resource_color(self, ate: ARSCResTableEntry) -> list:",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "1672:                 ((entry_data >> 24) & 0xFF),",
          "1673:                 ((entry_data >> 16) & 0xFF),",
          "1674:                 ((entry_data >> 8) & 0xFF),",
          "1676:         ]",
          "1679:         try:",
          "1680:             return [",
          "1682:                     complexToFloat(ate.key.get_data()),",
          "1684:             ]",
          "1685:         except IndexError:",
          "1689:             return [ate.get_value(), ate.key.get_data()]",
          "1691:     # FIXME",
          "1693:         return [\"\", \"\"]",
          "1696:         \"\"\"",
          "1697:         Retrieve a list of all package names, which are available",
          "1698:         in the given resources.arsc.",
          "1699:         \"\"\"",
          "1700:         return list(self.packages.keys())",
          "1703:         \"\"\"",
          "1704:         Retrieve a list of all available locales in a given packagename.",
          "",
          "[Removed Lines]",
          "1675:                 (entry_data & 0xFF))",
          "1678:     def get_resource_dimen(self, ate):",
          "1681:                 ate.get_value(), \"{}{}\".format(",
          "1683:                     DIMENSION_UNITS[ate.key.get_data() & COMPLEX_UNIT_MASK])",
          "1686:             logger.debug(\"Out of range dimension unit index for {}: {}\".format(",
          "1687:                 complexToFloat(ate.key.get_data()),",
          "1688:                 ate.key.get_data() & COMPLEX_UNIT_MASK))",
          "1692:     def get_resource_style(self, ate):",
          "1695:     def get_packages_names(self):",
          "1702:     def get_locales(self, package_name):",
          "",
          "[Added Lines]",
          "2024:                 (entry_data & 0xFF),",
          "2025:             ),",
          "2028:     def get_resource_dimen(self, ate: ARSCResTableEntry) -> list:",
          "2031:                 ate.get_value(),",
          "2032:                 \"{}{}\".format(",
          "2034:                     DIMENSION_UNITS[ate.key.get_data() & COMPLEX_UNIT_MASK],",
          "2035:                 ),",
          "2038:             logger.debug(",
          "2039:                 \"Out of range dimension unit index for {}: {}\".format(",
          "2040:                     complexToFloat(ate.key.get_data()),",
          "2041:                     ate.key.get_data() & COMPLEX_UNIT_MASK,",
          "2042:                 )",
          "2043:             )",
          "2047:     def get_resource_style(self, ate: ARSCResTableEntry) -> list:",
          "2050:     def get_packages_names(self) -> list[str]:",
          "2057:     def get_locales(self, package_name: str) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "1708:         self._analyse()",
          "1709:         return list(self.values[package_name].keys())",
          "1712:         \"\"\"",
          "1713:         Retrieve a list of all types which are available in the given",
          "1714:         package and locale.",
          "",
          "[Removed Lines]",
          "1711:     def get_types(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2066:     def get_types(",
          "2067:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2068:     ) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "1719:         self._analyse()",
          "1720:         return list(self.values[package_name][locale].keys())",
          "1723:         \"\"\"",
          "1724:         Get the XML (as string) of all resources of type 'public'.",
          "",
          "[Removed Lines]",
          "1722:     def get_public_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2079:     def get_public_resources(",
          "2080:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2081:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "1737:         try:",
          "1738:             for i in self.values[package_name][locale][\"public\"]:",
          "1741:         except KeyError:",
          "1742:             pass",
          "",
          "[Removed Lines]",
          "1739:                 buff += '<public type=\"{}\" name=\"{}\" id=\"0x{:08x}\" />\\n'.format(",
          "1740:                     i[0], i[1], i[2])",
          "",
          "[Added Lines]",
          "2098:                 buff += (",
          "2099:                     '<public type=\"{}\" name=\"{}\" id=\"0x{:08x}\" />\\n'.format(",
          "2100:                         i[0], i[1], i[2]",
          "2101:                     )",
          "2102:                 )",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "1746:         return buff.encode('utf-8')",
          "1749:         \"\"\"",
          "1750:         Get the XML (as string) of all resources of type 'string'.",
          "",
          "[Removed Lines]",
          "1748:     def get_string_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2110:     def get_string_resources(",
          "2111:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2112:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "1775:         return buff.encode('utf-8')",
          "1778:         \"\"\"",
          "1779:         Get the XML (as string) of all resources of type 'string'.",
          "1780:         This is a combined variant, which has all locales and all package names",
          "",
          "[Removed Lines]",
          "1777:     def get_strings_resources(self):",
          "",
          "[Added Lines]",
          "2141:     def get_strings_resources(self) -> bytes:",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "1795:                 try:",
          "1796:                     for i in self.values[package_name][locale][\"string\"]:",
          "1797:                         buff += '<string name=\"{}\">{}</string>\\n'.format(",
          "1799:                 except KeyError:",
          "1800:                     pass",
          "",
          "[Removed Lines]",
          "1798:                             i[0], escape(i[1]))",
          "",
          "[Added Lines]",
          "2162:                             i[0], escape(i[1])",
          "2163:                         )",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "1809:         return buff.encode('utf-8')",
          "1812:         \"\"\"",
          "1813:         Get the XML (as string) of all resources of type 'id'.",
          "",
          "[Removed Lines]",
          "1811:     def get_id_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2176:     def get_id_resources(",
          "2177:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2178:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "1828:                 if len(i) == 1:",
          "1829:                     buff += '<item type=\"id\" name=\"%s\"/>\\n' % (i[0])",
          "1830:                 else:",
          "1833:         except KeyError:",
          "1834:             pass",
          "",
          "[Removed Lines]",
          "1831:                     buff += '<item type=\"id\" name=\"{}\">{}</item>\\n'.format(i[0],",
          "1832:                                                                            escape(i[1]))",
          "",
          "[Added Lines]",
          "2198:                     buff += '<item type=\"id\" name=\"{}\">{}</item>\\n'.format(",
          "2199:                         i[0], escape(i[1])",
          "2200:                     )",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "1838:         return buff.encode('utf-8')",
          "1841:         \"\"\"",
          "1842:         Get the XML (as string) of all resources of type 'bool'.",
          "",
          "[Removed Lines]",
          "1840:     def get_bool_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2208:     def get_bool_resources(",
          "2209:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2210:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "1863:         return buff.encode('utf-8')",
          "1866:         \"\"\"",
          "1867:         Get the XML (as string) of all resources of type 'integer'.",
          "",
          "[Removed Lines]",
          "1865:     def get_integer_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2235:     def get_integer_resources(",
          "2236:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2237:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "1888:         return buff.encode('utf-8')",
          "1891:         \"\"\"",
          "1892:         Get the XML (as string) of all resources of type 'color'.",
          "",
          "[Removed Lines]",
          "1890:     def get_color_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2262:     def get_color_resources(",
          "2263:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2264:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "1913:         return buff.encode('utf-8')",
          "1916:         \"\"\"",
          "1917:         Get the XML (as string) of all resources of type 'dimen'.",
          "",
          "[Removed Lines]",
          "1915:     def get_dimen_resources(self, package_name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2289:     def get_dimen_resources(",
          "2290:         self, package_name: str, locale: str = '\\x00\\x00'",
          "2291:     ) -> bytes:",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "1938:         return buff.encode('utf-8')",
          "1941:         \"\"\"",
          "1942:         Returns the tuple (resource_type, resource_name, resource_id)",
          "1943:         for the given resource_id.",
          "",
          "[Removed Lines]",
          "1940:     def get_id(self, package_name, rid, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2316:     def get_id(",
          "2317:         self, package_name: str, rid: int, locale: str = '\\x00\\x00'",
          "2318:     ) -> tuple:",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "1963:         This resolver deals with complex resources as well as with references.",
          "1964:         \"\"\"",
          "1967:             \"\"\"",
          "1968:             :param ARSCParser android_resources: A resource parser",
          "1969:             :param ARSCResTableConfig config: The desired configuration or None to resolve all.",
          "",
          "[Removed Lines]",
          "1966:         def __init__(self, android_resources, config=None):",
          "",
          "[Added Lines]",
          "2344:         def __init__(",
          "2345:             self,",
          "2346:             android_resources: ARSCParser,",
          "2347:             config: Union[ARSCResTableConfig, None] = None,",
          "2348:         ) -> None:",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "1971:             self.resources = android_resources",
          "1972:             self.wanted_config = config",
          "1975:             \"\"\"",
          "1976:             the given ID into the Resource and returns a list of matching resources.",
          "",
          "[Removed Lines]",
          "1974:         def resolve(self, res_id):",
          "",
          "[Added Lines]",
          "2356:         def resolve(self, res_id: int) -> list[tuple[ARSCResTableConfig, str]]:",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "1990:                 # deconstruct them and check if more candidates are generated",
          "1991:                 self.put_ate_value(result, ate, config)",
          "1994:             \"\"\"",
          "1995:             Put a ResTableEntry into the list of results",
          "1996:             :param list result: results array",
          "",
          "[Removed Lines]",
          "1993:         def put_ate_value(self, result, ate, config):",
          "",
          "[Added Lines]",
          "2375:         def put_ate_value(",
          "2376:             self,",
          "2377:             result: list,",
          "2378:             ate: ARSCResTableEntry,",
          "2379:             config: ARSCResTableConfig,",
          "2380:         ) -> None:",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "2002:                 complex_array = []",
          "2003:                 result.append((config, complex_array))",
          "2004:                 for _, item in ate.item.items:",
          "2006:             else:",
          "2010:             \"\"\"",
          "2011:             Put the tuple (ARSCResTableConfig, resolved string) into the result set",
          "2013:             :param list result: the result set",
          "2015:             :param ARSCResTableConfig config:",
          "2016:             :param ARSCResTableEntry parent: the originating entry",
          "2017:             :param bool complex_: True if the originating :class:`ARSCResTableEntry` was complex",
          "2018:             :return:",
          "2019:             \"\"\"",
          "2035:                 else:",
          "2039:         \"\"\"",
          "2040:         Return a list of resolved resource IDs with their corresponding configuration.",
          "2041:         It has a similar return type as :meth:`get_res_configs` but also handles complex entries",
          "",
          "[Removed Lines]",
          "2005:                     self.put_item_value(complex_array, item, config, ate, complex_=True)",
          "2007:                 self.put_item_value(result, ate.key, config, ate, complex_=False)",
          "2009:         def put_item_value(self, result, item, config, parent, complex_):",
          "2014:             :param ARSCResStringPoolRef item:",
          "2020:             if item.is_reference():",
          "2021:                 res_id = item.get_data()",
          "2022:                 if res_id:",
          "2023:                     # Infinite loop detection:",
          "2024:                     # TODO should this stay here or should be detect the loop much earlier?",
          "2025:                     if res_id == parent.mResId:",
          "2026:                         logger.warning(",
          "2027:                             \"Infinite loop detected at resource item {}. It references itself!\".format(parent))",
          "2028:                         return",
          "2030:                     self._resolve_into_result(",
          "2031:                         result, item.get_data(), self.wanted_config)",
          "2032:             else:",
          "2033:                 if complex_:",
          "2034:                     result.append(item.format_value())",
          "2036:                     result.append((config, item.format_value()))",
          "2038:     def get_resolved_res_configs(self, rid, config=None):",
          "",
          "[Added Lines]",
          "2392:                     self.put_item_value(",
          "2393:                         complex_array, item, config, ate, complex_=True",
          "2394:                     )",
          "2395:             elif ate.is_compact():",
          "2396:                 self.put_item_value(",
          "2397:                     result,",
          "2398:                     ate.data,",
          "2399:                     config,",
          "2400:                     ate,",
          "2401:                     complex_=False,",
          "2402:                     compact_=True,",
          "2403:                 )",
          "2405:                 self.put_item_value(",
          "2406:                     result, ate.key, config, ate, complex_=False",
          "2407:                 )",
          "2409:         def put_item_value(",
          "2410:             self,",
          "2411:             result: list,",
          "2412:             item: Union[ARSCResStringPoolRef, int],",
          "2413:             config: ARSCResTableConfig,",
          "2414:             parent: ARSCResTableEntry,",
          "2415:             complex_: bool,",
          "2416:             compact_: bool = False,",
          "2417:         ) -> None:",
          "2422:             :param ARSCResStringPoolRef | int item:",
          "2426:             :param bool compact_: True if the originating :class:`ARSCResTableEntry` was compact",
          "2429:             if isinstance(item, ARSCResStringPoolRef):",
          "2430:                 if item.is_reference():",
          "2431:                     res_id = item.get_data()",
          "2432:                     if res_id:",
          "2433:                         # Infinite loop detection:",
          "2434:                         # TODO should this stay here or should be detect the loop much earlier?",
          "2435:                         if res_id == parent.mResId:",
          "2436:                             logger.warning(",
          "2437:                                 \"Infinite loop detected at resource item {}. It references itself!\".format(",
          "2438:                                     parent",
          "2439:                                 )",
          "2440:                             )",
          "2441:                             return",
          "2443:                         self._resolve_into_result(",
          "2444:                             result, item.get_data(), self.wanted_config",
          "2445:                         )",
          "2447:                     if complex_:",
          "2448:                         result.append(item.format_value())",
          "2449:                     else:",
          "2450:                         result.append((config, item.format_value()))",
          "2451:             else:",
          "2452:                 if compact_:",
          "2453:                     result.append(",
          "2454:                         (config, parent.parent.stringpool_main.getString(item))",
          "2455:                     )",
          "2457:     def get_resolved_res_configs(",
          "2458:         self, rid: int, config: Union[ARSCResTableConfig, None] = None",
          "2459:     ) -> list[tuple[ARSCResTableConfig, str]]:",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "2051:         resolver = ARSCParser.ResourceResolver(self, config)",
          "2052:         return resolver.resolve(rid)",
          "2055:         self._analyse()",
          "2056:         if self._resolved_strings:",
          "2057:             return self._resolved_strings",
          "",
          "[Removed Lines]",
          "2054:     def get_resolved_strings(self):",
          "",
          "[Added Lines]",
          "2475:     def get_resolved_strings(self) -> list[str]:",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "2086:         self._resolved_strings = r",
          "2087:         return r",
          "2090:         \"\"\"",
          "2091:         Return the resources found with the ID `rid` and select",
          "2092:         the right one based on the configuration, or return all if no configuration was set.",
          "",
          "[Removed Lines]",
          "2089:     def get_res_configs(self, rid, config=None, fallback=True):",
          "",
          "[Added Lines]",
          "2510:     def get_res_configs(",
          "2511:         self,",
          "2512:         rid: int,",
          "2513:         config: Union[ARSCResTableConfig, None] = None,",
          "2514:         fallback: bool = True,",
          "2515:     ) -> list[ARSCResTableConfig]:",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "2104:         :param rid: resource id as int",
          "2105:         :param config: a config to resolve from, or None to get all results",
          "2106:         :param fallback: Enable the fallback for resolving default configuration (default: True)",
          "2108:         \"\"\"",
          "2109:         self._analyse()",
          "",
          "[Removed Lines]",
          "2107:         :return: a list of ARSCResTableConfig: ARSCResTableEntry",
          "",
          "[Added Lines]",
          "2533:         :return: a list of ARSCResTableConfig:",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "2116:         if rid not in self.resource_values:",
          "2117:             logger.warning(",
          "2119:             return []",
          "2121:         res_options = self.resource_values[rid]",
          "",
          "[Removed Lines]",
          "2118:                 \"The requested rid '0x{:08x}' could not be found in the list of resources.\".format(rid))",
          "",
          "[Added Lines]",
          "2544:                 \"The requested rid '0x{:08x}' could not be found in the list of resources.\".format(",
          "2545:                     rid",
          "2546:                 )",
          "2547:             )",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "2124:                 return [(config, res_options[config])]",
          "2125:             elif fallback and config == ARSCResTableConfig.default_config():",
          "2126:                 logger.warning(",
          "2128:                 return [list(self.resource_values[rid].items())[0]]",
          "2129:             else:",
          "2130:                 return []",
          "2131:         else:",
          "2132:             return list(res_options.items())",
          "2135:         self._analyse()",
          "2137:         try:",
          "",
          "[Removed Lines]",
          "2127:                     \"No default resource config could be found for the given rid '0x{:08x}', using fallback!\".format(rid))",
          "2134:     def get_string(self, package_name, name, locale='\\x00\\x00'):",
          "",
          "[Added Lines]",
          "2556:                     \"No default resource config could be found for the given rid '0x{:08x}', using fallback!\".format(",
          "2557:                         rid",
          "2558:                     )",
          "2559:                 )",
          "2566:     def get_string(",
          "2567:         self, package_name: str, name: str, locale: str = '\\x00\\x00'",
          "2568:     ) -> Union[str, None]:",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "2156:             package_name = self.get_packages_names()[0]",
          "2157:         result = collections.defaultdict(list)",
          "2160:             if res_type.get_package_name() == package_name and (",
          "2162:                 result[res_type.get_type()].extend(configs)",
          "2164:         return result",
          "2166:     @staticmethod",
          "2168:         \"\"\"",
          "2169:         Resolves an id from a binary XML file in the form \"@[package:]DEADBEEF\"",
          "2170:         and returns a tuple of package name and resource id.",
          "",
          "[Removed Lines]",
          "2159:         for res_type, configs in list(self.resource_configs[package_name].items()):",
          "2161:                     type_name is None or res_type.get_type() == type_name):",
          "2167:     def parse_id(name):",
          "",
          "[Added Lines]",
          "2593:         for res_type, configs in list(",
          "2594:             self.resource_configs[package_name].items()",
          "2595:         ):",
          "2597:                 type_name is None or res_type.get_type() == type_name",
          "2598:             ):",
          "2604:     def parse_id(name: str) -> tuple[str, str]:",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "2180:         if not name.startswith('@'):",
          "2181:             raise ValueError(",
          "2184:         # remove @",
          "2185:         name = name[1:]",
          "",
          "[Removed Lines]",
          "2182:                 \"Not a valid resource ID, must start with @: '{}'\".format(name))",
          "",
          "[Added Lines]",
          "2619:                 \"Not a valid resource ID, must start with @: '{}'\".format(name)",
          "2620:             )",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "2193:         if len(res_id) != 8:",
          "2194:             raise ValueError(",
          "2197:         try:",
          "2198:             return int(res_id, 16), package",
          "2199:         except ValueError:",
          "2200:             raise ValueError(\"ID is not a hex ID: '{}'\".format(res_id))",
          "2203:         \"\"\"",
          "2204:         Returns the XML name for a resource, including the package name if package is None.",
          "2205:         A full name might look like `@com.example:string/foobar`",
          "",
          "[Removed Lines]",
          "2195:                 \"Numerical ID is not 8 characters long: '{}'\".format(res_id))",
          "2202:     def get_resource_xml_name(self, r_id, package=None):",
          "",
          "[Added Lines]",
          "2633:                 \"Numerical ID is not 8 characters long: '{}'\".format(res_id)",
          "2634:             )",
          "2641:     def get_resource_xml_name(",
          "2642:         self, r_id: int, package: Union[str, None] = None",
          "2643:     ) -> str:",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "2239: class PackageContext:",
          "2241:         \"\"\"",
          "2242:         :param ARSCResTablePackage current_package:",
          "2243:         :param StringBlock stringpool_main:",
          "",
          "[Removed Lines]",
          "2240:     def __init__(self, current_package, stringpool_main, mTableStrings, mKeyStrings):",
          "",
          "[Added Lines]",
          "2681:     def __init__(",
          "2682:         self,",
          "2683:         current_package: ARSCResTablePackage,",
          "2684:         stringpool_main: StringBlock,",
          "2685:         mTableStrings: StringBlock,",
          "2686:         mKeyStrings: StringBlock,",
          "2687:     ) -> None:",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "2249:         self.mKeyStrings = mKeyStrings",
          "2250:         self.current_package = current_package",
          "2253:         return self.current_package.mResId",
          "2256:         self.current_package.mResId = mResId",
          "2259:         return self.current_package.get_name()",
          "2261:     def __repr__(self):",
          "2268: class ARSCHeader:",
          "",
          "[Removed Lines]",
          "2252:     def get_mResId(self):",
          "2255:     def set_mResId(self, mResId):",
          "2258:     def get_package_name(self):",
          "2262:         return \"<PackageContext {}, {}, {}, {}>\".format(self.current_package,",
          "2263:                                                         self.stringpool_main,",
          "2264:                                                         self.mTableStrings,",
          "2265:                                                         self.mKeyStrings)",
          "",
          "[Added Lines]",
          "2699:     def get_mResId(self) -> int:",
          "2702:     def set_mResId(self, mResId: int) -> None:",
          "2705:     def get_package_name(self) -> str:",
          "2709:         return \"<PackageContext {}, {}, {}, {}>\".format(",
          "2710:             self.current_package,",
          "2711:             self.stringpool_main,",
          "2712:             self.mTableStrings,",
          "2713:             self.mKeyStrings,",
          "2714:         )",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "2285:     # This is the minimal size such a header must have. There might be other header data too!",
          "2286:     SIZE = 2 + 2 + 4",
          "2289:         \"\"\"",
          "2291:         :param int expected_type: the type of the header which is expected.",
          "2292:         \"\"\"",
          "2293:         self.start = buff.tell()",
          "2294:         # Make sure we do not read over the buffer:",
          "2295:         if buff.raw.getbuffer().nbytes < self.start + self.SIZE:",
          "2296:             raise ResParserError(",
          "2299:         # Checking for dummy data between elements",
          "2300:         if possible_types:",
          "2301:             while True:",
          "2302:                 cur_pos = buff.tell()",
          "2303:                 self._type, self._header_size, self._size = unpack(",
          "2306:                 # cases where packers set the EndNamespace with zero size: check we are the end and add the prefix + uri",
          "2308:                     self._size = 24",
          "2310:                 if cur_pos == 0 or (",
          "2312:                     break",
          "2313:                 buff.seek(cur_pos)",
          "2314:                 buff.read(1)",
          "2316:         else:",
          "2317:             self._type, self._header_size, self._size = unpack(",
          "2320:         if expected_type and self._type != expected_type:",
          "2324:         # Assert that the read data will fit into the chunk.",
          "2325:         # The total size must be equal or larger than the header size",
          "2326:         if self._header_size < self.SIZE:",
          "2327:             raise ResParserError(",
          "2329:         if self._size < self.SIZE:",
          "2330:             raise ResParserError(",
          "2332:         if self._size < self._header_size:",
          "2333:             raise ResParserError(",
          "2338:     @property",
          "2340:         \"\"\"",
          "2341:         Type identifier for this chunk",
          "2342:         \"\"\"",
          "2343:         return self._type",
          "2345:     @property",
          "2347:         \"\"\"",
          "2348:         Size of the chunk header (in bytes).  Adding this value to",
          "2349:         the address of the chunk allows you to find its associated data",
          "",
          "[Removed Lines]",
          "2288:     def __init__(self, buff, expected_type=None, possible_types=None):",
          "2290:         :param androguard.core.bytecode.BuffHandle buff: the buffer set to the position where the header starts.",
          "2297:                 \"Can not read over the buffer size! Offset={}\".format(self.start))",
          "2304:                     '<HHL', buff.read(self.SIZE))",
          "2307:                 if self._size < self.SIZE and (buff.raw.getbuffer().nbytes == cur_pos + self._header_size + 4 + 4):",
          "2311:                         self._type in possible_types and self._header_size >= self.SIZE and self._size > self.SIZE):",
          "2315:                 logger.warning(\"Appears that dummy data are found between elements!\")",
          "2318:                 '<HHL', buff.read(self.SIZE))",
          "2321:             raise ResParserError(\"Header type is not equal the expected type: Got 0x{:04x}, wanted 0x{:04x}\".format(",
          "2322:                 self._type, expected_type))",
          "2328:                 \"declared header size is smaller than required size of {}! Offset={}\".format(self.SIZE, self.start))",
          "2331:                 \"declared chunk size is smaller than required size of {}! Offset={}\".format(self.SIZE, self.start))",
          "2334:                 \"declared chunk size ({}) is smaller than header size ({})! Offset={}\".format(self._size,",
          "2335:                                                                                               self._header_size,",
          "2336:                                                                                               self.start))",
          "2339:     def type(self):",
          "2346:     def header_size(self):",
          "",
          "[Added Lines]",
          "2737:     def __init__(",
          "2738:         self,",
          "2739:         buff: BinaryIO,",
          "2740:         expected_type: Union[int, None] = None,",
          "2741:         possible_types: Union[set[int], None] = None,",
          "2742:     ) -> None:",
          "2744:         :param buff: the buffer set to the position where the header starts.",
          "2751:                 \"Can not read over the buffer size! Offset={}\".format(",
          "2752:                     self.start",
          "2753:                 )",
          "2754:             )",
          "2761:                     '<HHL', buff.read(self.SIZE)",
          "2762:                 )",
          "2765:                 if self._size < self.SIZE and (",
          "2766:                     buff.raw.getbuffer().nbytes",
          "2767:                     == cur_pos + self._header_size + 4 + 4",
          "2768:                 ):",
          "2772:                     self._type in possible_types",
          "2773:                     and self._header_size >= self.SIZE",
          "2774:                     and self._size > self.SIZE",
          "2775:                 ):",
          "2779:                 logger.warning(",
          "2780:                     \"Appears that dummy data are found between elements!\"",
          "2781:                 )",
          "2784:                 '<HHL', buff.read(self.SIZE)",
          "2785:             )",
          "2788:             raise ResParserError(",
          "2789:                 \"Header type is not equal the expected type: Got 0x{:04x}, wanted 0x{:04x}\".format(",
          "2790:                     self._type, expected_type",
          "2791:                 )",
          "2792:             )",
          "2798:                 \"declared header size is smaller than required size of {}! Offset={}\".format(",
          "2799:                     self.SIZE, self.start",
          "2800:                 )",
          "2801:             )",
          "2804:                 \"declared chunk size is smaller than required size of {}! Offset={}\".format(",
          "2805:                     self.SIZE, self.start",
          "2806:                 )",
          "2807:             )",
          "2810:                 \"declared chunk size ({}) is smaller than header size ({})! Offset={}\".format(",
          "2811:                     self._size, self._header_size, self.start",
          "2812:                 )",
          "2813:             )",
          "2816:     def type(self) -> int:",
          "2823:     def header_size(self) -> int:",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "2352:         return self._header_size",
          "2354:     @property",
          "2356:         \"\"\"",
          "2357:         Total size of this chunk (in bytes).  This is the chunkSize plus",
          "2358:         the size of any data associated with the chunk.  Adding this value",
          "",
          "[Removed Lines]",
          "2355:     def size(self):",
          "",
          "[Added Lines]",
          "2832:     def size(self) -> int:",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "2363:         return self._size",
          "2365:     @property",
          "2367:         \"\"\"",
          "2368:         Get the absolute offset inside the file, where the chunk ends.",
          "2369:         This is equal to `ARSCHeader.start + ARSCHeader.size`.",
          "",
          "[Removed Lines]",
          "2366:     def end(self):",
          "",
          "[Added Lines]",
          "2843:     def end(self) -> int:",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "2371:         return self.start + self.size",
          "2373:     def __repr__(self):",
          "2380: class ARSCResTablePackage:",
          "",
          "[Removed Lines]",
          "2374:         return \"<ARSCHeader idx='0x{:08x}' type='{}' header_size='{}' size='{}'>\".format(self.start,",
          "2375:                                                                                          self.type,",
          "2376:                                                                                          self.header_size,",
          "2377:                                                                                          self.size)",
          "",
          "[Added Lines]",
          "2851:         return \"<ARSCHeader idx='0x{:08x}' type='{}' header_size='{}' size='{}'>\".format(",
          "2852:             self.start, self.type, self.header_size, self.size",
          "2853:         )",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "2384:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#861",
          "2385:     \"\"\"",
          "2388:         self.header = header",
          "2389:         self.start = buff.tell()",
          "2390:         self.id = unpack('<I', buff.read(4))[0]",
          "",
          "[Removed Lines]",
          "2387:     def __init__(self, buff, header):",
          "",
          "[Added Lines]",
          "2863:     def __init__(self, buff: BinaryIO, header: ARSCHeader) -> None:",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "2395:         self.lastPublicKey = unpack('<I', buff.read(4))[0]",
          "2396:         self.mResId = self.id << 24",
          "2399:         name = self.name.decode(\"utf-16\", 'replace')",
          "2401:         return name",
          "",
          "[Removed Lines]",
          "2398:     def get_name(self):",
          "2400:         name = name[:name.find(\"\\x00\")]",
          "",
          "[Added Lines]",
          "2874:     def get_name(self) -> None:",
          "2876:         name = name[: name.find(\"\\x00\")]",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "2406:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1327",
          "2407:     \"\"\"",
          "2410:         self.start = buff.tell()",
          "2411:         self.parent = parent",
          "2412:         self.id = unpack('<B', buff.read(1))[0]",
          "",
          "[Removed Lines]",
          "2409:     def __init__(self, buff, parent=None):",
          "",
          "[Added Lines]",
          "2885:     def __init__(",
          "2886:         self, buff: BinaryIO, parent: Union[PackageContext, None] = None",
          "2887:     ) -> None:",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "2435:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1364",
          "2436:     \"\"\"",
          "2439:         self.start = buff.tell()",
          "2440:         self.parent = parent",
          "2442:         self.id = unpack('<B', buff.read(1))[0]",
          "2443:         # TODO there is now FLAG_SPARSE: http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1401",
          "2445:         self.reserved = unpack('<H', buff.read(2))[0]",
          "2446:         if self.reserved != 0:",
          "2448:         self.entryCount = unpack('<I', buff.read(4))[0]",
          "2449:         self.entriesStart = unpack('<I', buff.read(4))[0]",
          "2452:         self.parent.set_mResId(self.mResId)",
          "2454:         self.config = ARSCResTableConfig(buff)",
          "2456:         logger.debug(\"Parsed {}\".format(self))",
          "2459:         return self.parent.mTableStrings.getString(self.id - 1)",
          "2462:         return self.parent.get_package_name()",
          "2464:     def __repr__(self):",
          "2473:         )",
          "",
          "[Removed Lines]",
          "2438:     def __init__(self, buff, parent=None):",
          "2444:         self.flags, = unpack('<B', buff.read(1))",
          "2447:             raise ResParserError(\"reserved must be zero!\")",
          "2451:         self.mResId = (0xff000000 & self.parent.get_mResId()) | self.id << 16",
          "2458:     def get_type(self):",
          "2461:     def get_package_name(self):",
          "2465:         return \"<ARSCResType(start=0x%x, id=0x%x, flags=0x%x, entryCount=%d, entriesStart=0x%x, mResId=0x%x, %s)>\" % (",
          "2466:             self.start,",
          "2467:             self.id,",
          "2468:             self.flags,",
          "2469:             self.entryCount,",
          "2470:             self.entriesStart,",
          "2471:             self.mResId,",
          "2472:             \"table:\" + self.parent.mTableStrings.getString(self.id - 1)",
          "",
          "[Added Lines]",
          "2916:     def __init__(",
          "2917:         self, buff: BinaryIO, parent: Union[PackageContext, None] = None",
          "2918:     ) -> None:",
          "2924:         (self.flags,) = unpack('<B', buff.read(1))",
          "2927:             logger.warning(\"reserved must be zero!\")",
          "2931:         self.mResId = (0xFF000000 & self.parent.get_mResId()) | self.id << 16",
          "2938:     def get_type(self) -> str:",
          "2941:     def get_package_name(self) -> str:",
          "2945:         return (",
          "2946:             \"<ARSCResType(start=0x%x, id=0x%x, flags=0x%x, entryCount=%d, entriesStart=0x%x, mResId=0x%x, %s)>\"",
          "2947:             % (",
          "2948:                 self.start,",
          "2949:                 self.id,",
          "2950:                 self.flags,",
          "2951:                 self.entryCount,",
          "2952:                 self.entriesStart,",
          "2953:                 self.mResId,",
          "2954:                 \"table:\" + self.parent.mTableStrings.getString(self.id - 1),",
          "2955:             )",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "2482:     See the definition of `ResTable_config` in",
          "2483:     http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#911",
          "2484:     \"\"\"",
          "2485:     @classmethod",
          "2486:     def default_config(cls):",
          "2487:         if not hasattr(cls, 'DEFAULT'):",
          "2488:             cls.DEFAULT = ARSCResTableConfig(None)",
          "2489:         return cls.DEFAULT",
          "2492:         if buff is not None:",
          "2493:             self.start = buff.tell()",
          "",
          "[Removed Lines]",
          "2491:     def __init__(self, buff=None, **kwargs):",
          "",
          "[Added Lines]",
          "2975:     def __init__(self, buff: Union[BinaryIO, None] = None, **kwargs) -> None:",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "2510:             # uint16_t density",
          "2511:             self.screenType = unpack('<I', buff.read(4))[0]",
          "2530:             # The next three fields seems to be optional",
          "2531:             if self.size >= 32:",
          "",
          "[Removed Lines]",
          "2513:             # struct of",
          "2514:             # uint8_t keyboard",
          "2515:             # uint8_t navigation",
          "2516:             # uint8_t inputFlags",
          "2517:             # uint8_t inputPad0",
          "2518:             self.input = unpack('<I', buff.read(4))[0]",
          "2520:             # struct of",
          "2521:             # uint16_t screenWidth",
          "2522:             # uint16_t screenHeight",
          "2523:             self.screenSize = unpack('<I', buff.read(4))[0]",
          "2525:             # struct of",
          "2526:             # uint16_t sdkVersion",
          "2527:             # uint16_t minorVersion  which should be always 0, as the meaning is not defined",
          "2528:             self.version = unpack('<I', buff.read(4))[0]",
          "",
          "[Added Lines]",
          "2997:             if self.size >= 20:",
          "2998:                 # struct of",
          "2999:                 # uint8_t keyboard",
          "3000:                 # uint8_t navigation",
          "3001:                 # uint8_t inputFlags",
          "3002:                 # uint8_t inputPad0",
          "3003:                 self.input = unpack('<I', buff.read(4))[0]",
          "3004:             else:",
          "3005:                 logger.debug(",
          "3006:                     \"This file does not have input flags! size={}\".format(",
          "3007:                         self.size",
          "3008:                     )",
          "3009:                 )",
          "3010:                 self.input = 0",
          "3012:             if self.size >= 24:",
          "3013:                 # struct of",
          "3014:                 # uint16_t screenWidth",
          "3015:                 # uint16_t screenHeight",
          "3016:                 self.screenSize = unpack('<I', buff.read(4))[0]",
          "3017:             else:",
          "3018:                 logger.debug(",
          "3019:                     \"This file does not have screenSize! size={}\".format(",
          "3020:                         self.size",
          "3021:                     )",
          "3022:                 )",
          "3023:                 self.screenSize = 0",
          "3025:             if self.size >= 28:",
          "3026:                 # struct of",
          "3027:                 # uint16_t sdkVersion",
          "3028:                 # uint16_t minorVersion  which should be always 0, as the meaning is not defined",
          "3029:                 self.version = unpack('<I', buff.read(4))[0]",
          "3030:             else:",
          "3031:                 logger.debug(",
          "3032:                     \"This file does not have version! size={}\".format(",
          "3033:                         self.size",
          "3034:                     )",
          "3035:                 )",
          "3036:                 self.version = 0",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "2533:                 # uint8_t screenLayout",
          "2534:                 # uint8_t uiMode",
          "2535:                 # uint16_t smallestScreenWidthDp",
          "2537:             else:",
          "2538:                 logger.debug(",
          "2540:                 self.screenConfig = 0",
          "2542:             if self.size >= 36:",
          "2543:                 # struct of",
          "2544:                 # uint16_t screenWidthDp",
          "2545:                 # uint16_t screenHeightDp",
          "2547:             else:",
          "2548:                 logger.debug(",
          "2550:                 self.screenSizeDp = 0",
          "2552:             if self.size >= 40:",
          "",
          "[Removed Lines]",
          "2536:                 self.screenConfig, = unpack('<I', buff.read(4))",
          "2539:                     \"This file does not have a screenConfig! size={}\".format(self.size))",
          "2546:                 self.screenSizeDp, = unpack('<I', buff.read(4))",
          "2549:                     \"This file does not have a screenSizeDp! size={}\".format(self.size))",
          "",
          "[Added Lines]",
          "3044:                 (self.screenConfig,) = unpack('<I', buff.read(4))",
          "3047:                     \"This file does not have a screenConfig! size={}\".format(",
          "3048:                         self.size",
          "3049:                     )",
          "3050:                 )",
          "3057:                 (self.screenSizeDp,) = unpack('<I', buff.read(4))",
          "3060:                     \"This file does not have a screenSizeDp! size={}\".format(",
          "3061:                         self.size",
          "3062:                     )",
          "3063:                 )",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "2560:                 # uint8_t screenLayout2",
          "2561:                 # uint8_t colorMode",
          "2562:                 # uint16_t screenConfigPad2",
          "2564:             else:",
          "2565:                 logger.debug(",
          "2567:                 self.screenConfig2 = 0",
          "2569:             self.exceedingSize = self.size - (buff.tell() - self.start)",
          "",
          "[Removed Lines]",
          "2563:                 self.screenConfig2, = unpack(\"<I\", buff.read(4))",
          "2566:                     \"This file does not have a screenConfig2! size={}\".format(self.size))",
          "",
          "[Added Lines]",
          "3077:                 (self.screenConfig2,) = unpack(\"<I\", buff.read(4))",
          "3080:                     \"This file does not have a screenConfig2! size={}\".format(",
          "3081:                         self.size",
          "3082:                     )",
          "3083:                 )",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "2574:         else:",
          "2575:             self.start = 0",
          "2576:             self.size = 0",
          "2613:             # TODO add this some day...",
          "2614:             self.screenConfig2 = 0",
          "",
          "[Removed Lines]",
          "2577:             self.imsi = \\",
          "2578:                 ((kwargs.pop('mcc', 0) & 0xffff) << 0) + \\",
          "2579:                 ((kwargs.pop('mnc', 0) & 0xffff) << 16)",
          "2581:             self.locale = 0",
          "2582:             for char_ix, char in kwargs.pop('locale', \"\")[0:4]:",
          "2583:                 self.locale += (ord(char) << (char_ix * 8))",
          "2585:             self.screenType = \\",
          "2586:                 ((kwargs.pop('orientation', 0) & 0xff) << 0) + \\",
          "2587:                 ((kwargs.pop('touchscreen', 0) & 0xff) << 8) + \\",
          "2588:                 ((kwargs.pop('density', 0) & 0xffff) << 16)",
          "2590:             self.input = \\",
          "2591:                 ((kwargs.pop('keyboard', 0) & 0xff) << 0) + \\",
          "2592:                 ((kwargs.pop('navigation', 0) & 0xff) << 8) + \\",
          "2593:                 ((kwargs.pop('inputFlags', 0) & 0xff) << 16) + \\",
          "2594:                 ((kwargs.pop('inputPad0', 0) & 0xff) << 24)",
          "2596:             self.screenSize = \\",
          "2597:                 ((kwargs.pop('screenWidth', 0) & 0xffff) << 0) + \\",
          "2598:                 ((kwargs.pop('screenHeight', 0) & 0xffff) << 16)",
          "2600:             self.version = \\",
          "2601:                 ((kwargs.pop('sdkVersion', 0) & 0xffff) << 0) + \\",
          "2602:                 ((kwargs.pop('minorVersion', 0) & 0xffff) << 16)",
          "2604:             self.screenConfig = \\",
          "2605:                 ((kwargs.pop('screenLayout', 0) & 0xff) << 0) + \\",
          "2606:                 ((kwargs.pop('uiMode', 0) & 0xff) << 8) + \\",
          "2607:                 ((kwargs.pop('smallestScreenWidthDp', 0) & 0xffff) << 16)",
          "2609:             self.screenSizeDp = \\",
          "2610:                 ((kwargs.pop('screenWidthDp', 0) & 0xffff) << 0) + \\",
          "2611:                 ((kwargs.pop('screenHeightDp', 0) & 0xffff) << 16)",
          "",
          "[Added Lines]",
          "3094:             self.imsi = ((kwargs.pop('mcc', 0) & 0xFFFF) << 0) + (",
          "3095:                 (kwargs.pop('mnc', 0) & 0xFFFF) << 16",
          "3096:             )",
          "3098:             temp_locale = kwargs.pop('locale', 0)",
          "3099:             if isinstance(temp_locale, str):",
          "3100:                 self.set_language_and_region(temp_locale)",
          "3101:             else:",
          "3102:                 self.locale = temp_locale",
          "3104:             for char_ix, char in kwargs.pop('locale', \"\")[0:4]:",
          "3105:                 self.locale += ord(char) << (char_ix * 8)",
          "3107:             self.screenType = (",
          "3108:                 ((kwargs.pop('orientation', 0) & 0xFF) << 0)",
          "3109:                 + ((kwargs.pop('touchscreen', 0) & 0xFF) << 8)",
          "3110:                 + ((kwargs.pop('density', 0) & 0xFFFF) << 16)",
          "3111:             )",
          "3113:             self.input = (",
          "3114:                 ((kwargs.pop('keyboard', 0) & 0xFF) << 0)",
          "3115:                 + ((kwargs.pop('navigation', 0) & 0xFF) << 8)",
          "3116:                 + ((kwargs.pop('inputFlags', 0) & 0xFF) << 16)",
          "3117:                 + ((kwargs.pop('inputPad0', 0) & 0xFF) << 24)",
          "3118:             )",
          "3120:             self.screenSize = (",
          "3121:                 (kwargs.pop('screenWidth', 0) & 0xFFFF) << 0",
          "3122:             ) + ((kwargs.pop('screenHeight', 0) & 0xFFFF) << 16)",
          "3124:             self.version = ((kwargs.pop('sdkVersion', 0) & 0xFFFF) << 0) + (",
          "3125:                 (kwargs.pop('minorVersion', 0) & 0xFFFF) << 16",
          "3126:             )",
          "3128:             self.screenConfig = (",
          "3129:                 ((kwargs.pop('screenLayout', 0) & 0xFF) << 0)",
          "3130:                 + ((kwargs.pop('uiMode', 0) & 0xFF) << 8)",
          "3131:                 + ((kwargs.pop('smallestScreenWidthDp', 0) & 0xFFFF) << 16)",
          "3132:             )",
          "3134:             self.screenSizeDp = (",
          "3135:                 (kwargs.pop('screenWidthDp', 0) & 0xFFFF) << 0",
          "3136:             ) + ((kwargs.pop('screenHeightDp', 0) & 0xFFFF) << 16)",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "2618:     def _unpack_language_or_region(self, char_in, char_base):",
          "2619:         char_out = \"\"",
          "2620:         if char_in[0] & 0x80:",
          "2624:             char_out += chr(first + char_base)",
          "2625:             char_out += chr(second + char_base)",
          "2626:             char_out += chr(third + char_base)",
          "",
          "[Removed Lines]",
          "2621:             first = char_in[1] & 0x1f",
          "2622:             second = ((char_in[1] & 0xe0) >> 5) + ((char_in[0] & 0x03) << 3)",
          "2623:             third = (char_in[0] & 0x7c) >> 2",
          "",
          "[Added Lines]",
          "3146:             first = char_in[1] & 0x1F",
          "3147:             second = ((char_in[1] & 0xE0) >> 5) + ((char_in[0] & 0x03) << 3)",
          "3148:             third = (char_in[0] & 0x7C) >> 2",
          "",
          "---------------",
          "--- Hunk 118 ---",
          "[Context before]",
          "2631:                 char_out += chr(char_in[1])",
          "2632:         return char_out",
          "2635:         \"\"\"",
          "2636:         Returns the combined language+region string or \\x00\\x00 for the default locale",
          "2637:         :return:",
          "2638:         \"\"\"",
          "2639:         if self.locale != 0:",
          "2640:             _language = self._unpack_language_or_region(",
          "2642:             _region = self._unpack_language_or_region(",
          "2644:             return (_language + \"-r\" + _region) if _region else _language",
          "2645:         return \"\\x00\\x00\"",
          "2648:         \"\"\"",
          "2649:         Here for legacy reasons.",
          "",
          "[Removed Lines]",
          "2634:     def get_language_and_region(self):",
          "2641:                 [self.locale & 0xff, (self.locale & 0xff00) >> 8, ], ord('a'))",
          "2643:                 [(self.locale & 0xff0000) >> 16, (self.locale & 0xff000000) >> 24, ], ord('0'))",
          "2647:     def get_config_name_friendly(self):",
          "",
          "[Added Lines]",
          "3159:     def _pack_language_or_region(self, char_in: str) -> list[int]:",
          "3160:         char_out = [0x00, 0x00]",
          "3161:         if len(char_in) != 2:",
          "3162:             return char_out",
          "3163:         char_out[0] = ord(char_in[0])",
          "3164:         char_out[1] = ord(char_in[1])",
          "3165:         return char_out",
          "3167:     def set_language_and_region(self, language_region):",
          "3168:         try:",
          "3169:             language, region = language_region.split(\"-r\")",
          "3170:         except ValueError:",
          "3171:             language, region = language_region, None",
          "3172:         language_bytes = self._pack_language_or_region(language)",
          "3173:         if region:",
          "3174:             region_bytes = self._pack_language_or_region(region)",
          "3175:         else:",
          "3176:             region_bytes = [0x00, 0x00]",
          "3177:         self.locale = (",
          "3178:             language_bytes[0]",
          "3179:             | (language_bytes[1] << 8)",
          "3180:             | (region_bytes[0] << 16)",
          "3181:             | (region_bytes[1] << 24)",
          "3182:         )",
          "3184:     def get_language_and_region(self) -> str:",
          "3191:                 [",
          "3192:                     self.locale & 0xFF,",
          "3193:                     (self.locale & 0xFF00) >> 8,",
          "3194:                 ],",
          "3195:                 ord('a'),",
          "3196:             )",
          "3198:                 [",
          "3199:                     (self.locale & 0xFF0000) >> 16,",
          "3200:                     (self.locale & 0xFF000000) >> 24,",
          "3201:                 ],",
          "3202:                 ord('0'),",
          "3203:             )",
          "3207:     def get_config_name_friendly(self) -> str:",
          "",
          "---------------",
          "--- Hunk 119 ---",
          "[Context before]",
          "2652:         \"\"\"",
          "2653:         return self.get_qualifier()",
          "2656:         \"\"\"",
          "2657:         Return resource name qualifier for the current configuration.",
          "2658:         for example",
          "",
          "[Removed Lines]",
          "2655:     def get_qualifier(self):",
          "",
          "[Added Lines]",
          "3215:     def get_qualifier(self) -> str:",
          "",
          "---------------",
          "--- Hunk 120 ---",
          "[Context before]",
          "2677:         if self.locale != 0:",
          "2678:             res.append(self.get_language_and_region())",
          "2681:         if (screenLayout & MASK_LAYOUTDIR) != 0:",
          "2682:             if screenLayout & MASK_LAYOUTDIR == LAYOUTDIR_LTR:",
          "2683:                 res.append(\"ldltr\")",
          "",
          "[Removed Lines]",
          "2680:         screenLayout = self.screenConfig & 0xff",
          "",
          "[Added Lines]",
          "3240:         screenLayout = self.screenConfig & 0xFF",
          "",
          "---------------",
          "--- Hunk 121 ---",
          "[Context before]",
          "2707:             elif screenLayout & MASK_SCREENSIZE == SCREENSIZE_XLARGE:",
          "2708:                 res.append(\"xlarge\")",
          "2709:             else:",
          "2711:         if (screenLayout & MASK_SCREENLONG) != 0:",
          "2712:             if screenLayout & MASK_SCREENLONG == SCREENLONG_NO:",
          "2713:                 res.append(\"notlong\")",
          "2714:             elif screenLayout & MASK_SCREENLONG == SCREENLONG_YES:",
          "2715:                 res.append(\"long\")",
          "2716:             else:",
          "2720:         if (screenLayout2 & MASK_SCREENROUND) != 0:",
          "2721:             if screenLayout2 & MASK_SCREENROUND == SCREENROUND_NO:",
          "2722:                 res.append(\"notround\")",
          "2723:             elif screenLayout2 & MASK_SCREENROUND == SCREENROUND_YES:",
          "2724:                 res.append(\"round\")",
          "2725:             else:",
          "2729:         if (colorMode & MASK_WIDE_COLOR_GAMUT) != 0:",
          "2730:             if colorMode & MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_NO:",
          "2731:                 res.append(\"nowidecg\")",
          "2732:             elif colorMode & MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_YES:",
          "2733:                 res.append(\"widecg\")",
          "2734:             else:",
          "2737:         if (colorMode & MASK_HDR) != 0:",
          "2738:             if colorMode & MASK_HDR == HDR_NO:",
          "",
          "[Removed Lines]",
          "2710:                 res.append(\"screenLayoutSize_%d\" % (screenLayout & MASK_SCREENSIZE))",
          "2717:                 res.append(\"screenLayoutLong_%d\" % (screenLayout & MASK_SCREENLONG))",
          "2719:         screenLayout2 = self.screenConfig2 & 0xff",
          "2726:                 res.append(\"screenRound_%d\" % (screenLayout2 & MASK_SCREENROUND))",
          "2728:         colorMode = (self.screenConfig2 & 0xff00) >> 8",
          "2735:                 res.append(\"wideColorGamut_%d\" % (colorMode & MASK_WIDE_COLOR_GAMUT))",
          "",
          "[Added Lines]",
          "3270:                 res.append(",
          "3271:                     \"screenLayoutSize_%d\" % (screenLayout & MASK_SCREENSIZE)",
          "3272:                 )",
          "3279:                 res.append(",
          "3280:                     \"screenLayoutLong_%d\" % (screenLayout & MASK_SCREENLONG)",
          "3281:                 )",
          "3283:         screenLayout2 = self.screenConfig2 & 0xFF",
          "3290:                 res.append(",
          "3291:                     \"screenRound_%d\" % (screenLayout2 & MASK_SCREENROUND)",
          "3292:                 )",
          "3294:         colorMode = (self.screenConfig2 & 0xFF00) >> 8",
          "3301:                 res.append(",
          "3302:                     \"wideColorGamut_%d\" % (colorMode & MASK_WIDE_COLOR_GAMUT)",
          "3303:                 )",
          "",
          "---------------",
          "--- Hunk 122 ---",
          "[Context before]",
          "2742:             else:",
          "2743:                 res.append(\"hdr_%d\" % (colorMode & MASK_HDR))",
          "2746:         if orientation != ORIENTATION_ANY:",
          "2747:             if orientation == ORIENTATION_PORT:",
          "2748:                 res.append(\"port\")",
          "",
          "[Removed Lines]",
          "2745:         orientation = self.screenType & 0xff",
          "",
          "[Added Lines]",
          "3313:         orientation = self.screenType & 0xFF",
          "",
          "---------------",
          "--- Hunk 123 ---",
          "[Context before]",
          "2753:             else:",
          "2754:                 res.append(\"orientation_%d\" % orientation)",
          "2757:         if (uiMode & MASK_UI_MODE_TYPE) != UI_MODE_TYPE_ANY:",
          "2758:             ui_mode = uiMode & MASK_UI_MODE_TYPE",
          "2759:             if ui_mode == UI_MODE_TYPE_DESK:",
          "",
          "[Removed Lines]",
          "2756:         uiMode = (self.screenConfig & 0xff00) >> 8",
          "",
          "[Added Lines]",
          "3324:         uiMode = (self.screenConfig & 0xFF00) >> 8",
          "",
          "---------------",
          "--- Hunk 124 ---",
          "[Context before]",
          "2779:             else:",
          "2780:                 res.append(\"uiModeNight_%d\" % (uiMode & MASK_UI_MODE_NIGHT))",
          "2783:         if density != DENSITY_DEFAULT:",
          "2784:             if density == DENSITY_LOW:",
          "2785:                 res.append(\"ldpi\")",
          "",
          "[Removed Lines]",
          "2782:         density = (self.screenType & 0xffff0000) >> 16",
          "",
          "[Added Lines]",
          "3350:         density = (self.screenType & 0xFFFF0000) >> 16",
          "",
          "---------------",
          "--- Hunk 125 ---",
          "[Context before]",
          "2802:             else:",
          "2803:                 res.append(\"%ddpi\" % (density))",
          "2806:         if touchscreen != TOUCHSCREEN_ANY:",
          "2807:             if touchscreen == TOUCHSCREEN_NOTOUCH:",
          "2808:                 res.append(\"notouch\")",
          "",
          "[Removed Lines]",
          "2805:         touchscreen = (self.screenType & 0xff00) >> 8",
          "",
          "[Added Lines]",
          "3373:         touchscreen = (self.screenType & 0xFF00) >> 8",
          "",
          "---------------",
          "--- Hunk 126 ---",
          "[Context before]",
          "2813:             else:",
          "2814:                 res.append(\"touchscreen_%d\" % touchscreen)",
          "2820:         if inputFlags & MASK_KEYSHIDDEN != 0:",
          "2821:             input_flags = inputFlags & MASK_KEYSHIDDEN",
          "",
          "[Removed Lines]",
          "2816:         keyboard = self.input & 0xff",
          "2817:         navigation = (self.input & 0xff00) >> 8",
          "2818:         inputFlags = (self.input & 0xff0000) >> 16",
          "",
          "[Added Lines]",
          "3384:         keyboard = self.input & 0xFF",
          "3385:         navigation = (self.input & 0xFF00) >> 8",
          "3386:         inputFlags = (self.input & 0xFF0000) >> 16",
          "",
          "---------------",
          "--- Hunk 127 ---",
          "[Context before]",
          "2860:         screenSize = self.screenSize",
          "2861:         if screenSize != 0:",
          "2864:             res.append(\"%dx%d\" % (screenWidth, screenHeight))",
          "2866:         version = self.version",
          "2867:         if version != 0:",
          "2870:             res.append(\"v%d\" % sdkVersion)",
          "2871:             if minorVersion != 0:",
          "2872:                 res.append(\".%d\" % minorVersion)",
          "2874:         return \"-\".join(res)",
          "2886:         return x",
          "2889:         \"\"\"",
          "2890:         Test if this is a default resource, which matches all",
          "",
          "[Removed Lines]",
          "2862:             screenWidth = self.screenSize & 0xffff",
          "2863:             screenHeight = (self.screenSize & 0xffff0000) >> 16",
          "2868:             sdkVersion = self.version & 0xffff",
          "2869:             minorVersion = (self.version & 0xffff0000) >> 16",
          "2876:     def get_language(self):",
          "2877:         x = self.locale & 0x0000ffff",
          "2878:         return chr(x & 0x00ff) + chr((x & 0xff00) >> 8)",
          "2880:     def get_country(self):",
          "2881:         x = (self.locale & 0xffff0000) >> 16",
          "2882:         return chr(x & 0x00ff) + chr((x & 0xff00) >> 8)",
          "2884:     def get_density(self):",
          "2885:         x = ((self.screenType >> 16) & 0xffff)",
          "2888:     def is_default(self):",
          "",
          "[Added Lines]",
          "3430:             screenWidth = self.screenSize & 0xFFFF",
          "3431:             screenHeight = (self.screenSize & 0xFFFF0000) >> 16",
          "3436:             sdkVersion = self.version & 0xFFFF",
          "3437:             minorVersion = (self.version & 0xFFFF0000) >> 16",
          "3444:     def get_language(self) -> str:",
          "3445:         x = self.locale & 0x0000FFFF",
          "3446:         return chr(x & 0x00FF) + chr((x & 0xFF00) >> 8)",
          "3448:     def get_country(self) -> str:",
          "3449:         x = (self.locale & 0xFFFF0000) >> 16",
          "3450:         return chr(x & 0x00FF) + chr((x & 0xFF00) >> 8)",
          "3452:     def get_density(self) -> str:",
          "3453:         x = (self.screenType >> 16) & 0xFFFF",
          "3456:     def is_default(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 128 ---",
          "[Context before]",
          "2914:         return self._get_tuple() == other._get_tuple()",
          "2916:     def __repr__(self):",
          "2920: class ARSCResTableEntry:",
          "2921:     \"\"\"",
          "2922:     A `ResTable_entry`.",
          "2925:     \"\"\"",
          "2926:     # If set, this is a complex entry, holding a set of name/value",
          "2927:     # mappings.  It is followed by an array of ResTable_map structures.",
          "2928:     FLAG_COMPLEX = 1",
          "",
          "[Removed Lines]",
          "2917:         return \"<ARSCResTableConfig '{}'={}>\".format(self.get_qualifier(), repr(self._get_tuple()))",
          "2924:     See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1458",
          "",
          "[Added Lines]",
          "3485:         return \"<ARSCResTableConfig '{}'={}>\".format(",
          "3486:             self.get_qualifier(), repr(self._get_tuple())",
          "3487:         )",
          "3494:     See https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h;l=1522;drc=442fcb158a5b2e23340b74ce2e29e5e1f5bf9d66;bpv=0;bpt=0",
          "",
          "---------------",
          "--- Hunk 129 ---",
          "[Context before]",
          "2936:     # linking with other resource tables.",
          "2937:     FLAG_WEAK = 4",
          "2941:         self.mResId = mResId",
          "2942:         self.parent = parent",
          "",
          "[Removed Lines]",
          "2939:     def __init__(self, buff, mResId, parent=None):",
          "2940:         self.start = buff.tell()",
          "",
          "[Added Lines]",
          "3510:     # If set, this is a compact entry with data type and value directly",
          "3511:     # encoded in this entry",
          "3512:     FLAG_COMPACT = 8",
          "3514:     def __init__(",
          "3515:         self,",
          "3516:         buff: BinaryIO,",
          "3517:         entry_offset: int,",
          "3518:         expected_end_of_chunk: int,",
          "3519:         mResId: int,",
          "3520:         parent: Union[PackageContext, None] = None,",
          "3521:     ) -> None:",
          "3522:         self.start = buff.seek(entry_offset)",
          "",
          "---------------",
          "--- Hunk 130 ---",
          "[Context before]",
          "2947:         self.index = unpack('<I', buff.read(4))[0]",
          "2949:         if self.is_complex():",
          "2951:         else:",
          "2952:             # If FLAG_COMPLEX is not set, a Res_value structure will follow",
          "2953:             self.key = ARSCResStringPoolRef(buff, self.parent)",
          "",
          "[Removed Lines]",
          "2950:             self.item = ARSCComplex(buff, parent)",
          "",
          "[Added Lines]",
          "3532:             self.item = ARSCComplex(buff, expected_end_of_chunk, parent)",
          "3533:         elif self.is_compact():",
          "3534:             self.key = self.size",
          "3535:             self.data = self.index",
          "3536:             self.datatype = (self.flags >> 8) & 0xFF",
          "",
          "---------------",
          "--- Hunk 131 ---",
          "[Context before]",
          "2955:         if self.is_weak():",
          "2956:             logger.debug(\"Parsed {}\".format(self))",
          "2959:         return self.index",
          "2962:         return self.parent.mKeyStrings.getString(self.index)",
          "2968:         return (self.flags & self.FLAG_PUBLIC) != 0",
          "2971:         return (self.flags & self.FLAG_COMPLEX) != 0",
          "2974:         return (self.flags & self.FLAG_WEAK) != 0",
          "2976:     def __repr__(self):",
          "2978:             self.start,",
          "2979:             self.mResId,",
          "2981:             self.flags,",
          "2986: class ARSCComplex:",
          "",
          "[Removed Lines]",
          "2958:     def get_index(self):",
          "2961:     def get_value(self):",
          "2964:     def get_key_data(self):",
          "2965:         return self.key.get_data_value()",
          "2967:     def is_public(self):",
          "2970:     def is_complex(self):",
          "2973:     def is_weak(self):",
          "2977:         return \"<ARSCResTableEntry idx='0x{:08x}' mResId='0x{:08x}' size='{}' flags='0x{:02x}' index='0x{:x}' holding={}>\".format(",
          "2980:             self.size,",
          "2982:             self.index,",
          "2983:             self.item if self.is_complex() else self.key)",
          "",
          "[Added Lines]",
          "3544:     def get_index(self) -> int:",
          "3547:     def get_value(self) -> str:",
          "3550:     def get_key_data(self) -> str:",
          "3551:         if self.is_compact():",
          "3552:             return self.parent.stringpool_main.getString(self.key)",
          "3553:         else:",
          "3554:             return self.key.get_data_value()",
          "3556:     def is_public(self) -> bool:",
          "3559:     def is_complex(self) -> bool:",
          "3562:     def is_compact(self) -> bool:",
          "3563:         return (self.flags & self.FLAG_COMPACT) != 0",
          "3565:     def is_weak(self) -> bool:",
          "3569:         return \"<ARSCResTableEntry idx='0x{:08x}' mResId='0x{:08x}' flags='0x{:02x}' holding={}>\".format(",
          "3573:             self.item if self.is_complex() else self.key,",
          "3574:         )",
          "",
          "---------------",
          "--- Hunk 132 ---",
          "[Context before]",
          "2994:     and http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1498 for `ResTable_map`",
          "2995:     \"\"\"",
          "2998:         self.start = buff.tell()",
          "2999:         self.parent = parent",
          "",
          "[Removed Lines]",
          "2997:     def __init__(self, buff, parent=None):",
          "",
          "[Added Lines]",
          "3588:     def __init__(",
          "3589:         self,",
          "3590:         buff: BinaryIO,",
          "3591:         expected_end_of_chunk: int,",
          "3592:         parent: Union[PackageContext, None] = None,",
          "3593:     ) -> None:",
          "",
          "---------------",
          "--- Hunk 133 ---",
          "[Context before]",
          "3006:         # these are structs of ResTable_ref and Res_value",
          "3007:         # ResTable_ref is a uint32_t.",
          "3008:         for i in range(0, self.count):",
          "3012:     def __repr__(self):",
          "3016: class ARSCResStringPoolRef:",
          "",
          "[Removed Lines]",
          "3009:             self.items.append((unpack('<I', buff.read(4))[",
          "3010:                               0], ARSCResStringPoolRef(buff, self.parent)))",
          "3013:         return \"<ARSCComplex idx='0x{:08x}' parent='{}' count='{}'>\".format(self.start, self.id_parent, self.count)",
          "",
          "[Added Lines]",
          "3605:             if buff.tell() + 4 > expected_end_of_chunk:",
          "3606:                 print(",
          "3607:                     f\"We are out of bound with this complex entry. Count: {self.count}\"",
          "3608:                 )",
          "3609:                 break",
          "3610:             self.items.append(",
          "3611:                 (",
          "3612:                     unpack('<I', buff.read(4))[0],",
          "3613:                     ARSCResStringPoolRef(buff, self.parent),",
          "3614:                 )",
          "3615:             )",
          "3618:         return \"<ARSCComplex idx='0x{:08x}' parent='{}' count='{}'>\".format(",
          "3619:             self.start, self.id_parent, self.count",
          "3620:         )",
          "",
          "---------------",
          "--- Hunk 134 ---",
          "[Context before]",
          "3021:     See: http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#262",
          "3022:     \"\"\"",
          "3025:         self.start = buff.tell()",
          "3026:         self.parent = parent",
          "3030:         try:",
          "3031:             if self.res0 != 0:",
          "3032:                 logger.warning(\"res0 must be always zero!\")",
          "",
          "[Removed Lines]",
          "3024:     def __init__(self, buff, parent=None):",
          "3028:         self.size, = unpack(\"<H\", buff.read(2))",
          "3029:         self.res0, = unpack(\"<B\", buff.read(1))",
          "",
          "[Added Lines]",
          "3631:     def __init__(",
          "3632:         self, buff: BinaryIO, parent: Union[PackageContext, None] = None",
          "3633:     ) -> None:",
          "3637:         (self.size,) = unpack(\"<H\", buff.read(2))",
          "3638:         (self.res0,) = unpack(\"<B\", buff.read(1))",
          "",
          "---------------",
          "--- Hunk 135 ---",
          "[Context before]",
          "3036:         except Exception as e:",
          "3037:             logger.error(e)",
          "3040:         return self.parent.stringpool_main.getString(self.data)",
          "3043:         return self.data",
          "3046:         return self.data_type",
          "3049:         return TYPE_TABLE[self.data_type]",
          "3052:         \"\"\"",
          "3053:         Return the formatted (interpreted) data according to `data_type`.",
          "3054:         \"\"\"",
          "3055:         return format_value(",
          "3059:         )",
          "3062:         \"\"\"",
          "3063:         Returns True if the Res_value is actually a reference to another resource",
          "3064:         \"\"\"",
          "",
          "[Removed Lines]",
          "3039:     def get_data_value(self):",
          "3042:     def get_data(self):",
          "3045:     def get_data_type(self):",
          "3048:     def get_data_type_string(self):",
          "3051:     def format_value(self):",
          "3056:             self.data_type,",
          "3057:             self.data,",
          "3058:             self.parent.stringpool_main.getString",
          "3061:     def is_reference(self):",
          "",
          "[Added Lines]",
          "3648:     def get_data_value(self) -> str:",
          "3651:     def get_data(self) -> int:",
          "3654:     def get_data_type(self) -> bytes:",
          "3657:     def get_data_type_string(self) -> str:",
          "3660:     def format_value(self) -> str:",
          "3665:             self.data_type, self.data, self.parent.stringpool_main.getString",
          "3668:     def is_reference(self) -> bool:",
          "",
          "---------------",
          "--- Hunk 136 ---",
          "[Context before]",
          "3069:             self.start,",
          "3070:             self.size,",
          "3071:             TYPE_TABLE.get(self.data_type, \"0x%x\" % self.data_type),",
          "3076:     \"\"\"",
          "3077:     Return a string containing all resources packages ordered by packagename, locale and type.",
          "",
          "[Removed Lines]",
          "3072:             self.data)",
          "3075: def get_arsc_info(arscobj):",
          "",
          "[Added Lines]",
          "3679:             self.data,",
          "3680:         )",
          "3683: def get_arsc_info(arscobj: ARSCParser) -> str:",
          "",
          "---------------",
          "--- Hunk 137 ---",
          "[Context before]",
          "3087:             for ttype in arscobj.get_types(package, locale):",
          "3088:                 buff += \"\\t\\t\" + ttype + \":\\n\"",
          "3089:                 try:",
          "3092:                     for i in tmp_buff:",
          "3093:                         buff += \"\\t\\t\\t\" + i + \"\\n\"",
          "3094:                 except AttributeError:",
          "",
          "[Removed Lines]",
          "3090:                     tmp_buff = getattr(arscobj, \"get_\" + ttype + \"_resources\")(",
          "3091:                         package, locale).decode(\"utf-8\", 'replace').split(\"\\n\")",
          "",
          "[Added Lines]",
          "3698:                     tmp_buff = (",
          "3699:                         getattr(arscobj, \"get_\" + ttype + \"_resources\")(",
          "3700:                             package, locale",
          "3701:                         )",
          "3702:                         .decode(\"utf-8\", 'replace')",
          "3703:                         .split(\"\\n\")",
          "3704:                     )",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/resources/public.py||mobsf/StaticAnalyzer/tools/androguard4/resources/public.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/resources/public.py -> mobsf/StaticAnalyzer/tools/androguard4/resources/public.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:                 _public_res[_type][_name] = _id",
          "22:     else:",
          "23:         raise Exception(",
          "26: SYSTEM_RESOURCES = {",
          "27:     \"attributes\": {",
          "28:         \"forward\": {k: v for k, v in _public_res['attr'].items()},",
          "30:     },",
          "31:     \"styles\": {",
          "32:         \"forward\": {k: v for k, v in _public_res['style'].items()},",
          "35: }",
          "",
          "[Removed Lines]",
          "24:             \"need to copy the sdk/platforms/android-?/data/res/values/public.xml here\")",
          "29:         \"inverse\": {v: k for k, v in _public_res['attr'].items()}",
          "33:         \"inverse\": {v: k for k, v in _public_res['style'].items()}",
          "34:     }",
          "",
          "[Added Lines]",
          "24:             \"need to copy the sdk/platforms/android-?/data/res/values/public.xml here\"",
          "25:         )",
          "30:         \"inverse\": {v: k for k, v in _public_res['attr'].items()},",
          "34:         \"inverse\": {v: k for k, v in _public_res['style'].items()},",
          "35:     },",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/types.py||mobsf/StaticAnalyzer/tools/androguard4/types.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/types.py -> mobsf/StaticAnalyzer/tools/androguard4/types.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: # The 'data' is either 0 or 1, for input \"false\" or \"true\" respectively.",
          "38: TYPE_INT_BOOLEAN = 0x12",
          "39: # Beginning of color integer flavors...",
          "41: # The 'data' is a raw integer value of the form #aarrggbb.",
          "43: # The 'data' is a raw integer value of the form #rrggbb.",
          "45: # The 'data' is a raw integer value of the form #argb.",
          "47: # The 'data' is a raw integer value of the form #rgb.",
          "49: # ...end of integer flavors.",
          "51: # ...end of integer flavors.",
          "",
          "[Removed Lines]",
          "40: TYPE_FIRST_COLOR_INT = 0x1c",
          "42: TYPE_INT_COLOR_ARGB8 = 0x1c",
          "44: TYPE_INT_COLOR_RGB8 = 0x1d",
          "46: TYPE_INT_COLOR_ARGB4 = 0x1e",
          "48: TYPE_INT_COLOR_RGB4 = 0x1f",
          "50: TYPE_LAST_COLOR_INT = 0x1f",
          "52: TYPE_LAST_INT = 0x1f",
          "",
          "[Added Lines]",
          "40: TYPE_FIRST_COLOR_INT = 0x1C",
          "42: TYPE_INT_COLOR_ARGB8 = 0x1C",
          "44: TYPE_INT_COLOR_RGB8 = 0x1D",
          "46: TYPE_INT_COLOR_ARGB4 = 0x1E",
          "48: TYPE_INT_COLOR_RGB4 = 0x1F",
          "50: TYPE_LAST_COLOR_INT = 0x1F",
          "52: TYPE_LAST_INT = 0x1F",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/tools/androguard4/util.py||mobsf/StaticAnalyzer/tools/androguard4/util.py": [
          "File: mobsf/StaticAnalyzer/tools/androguard4/util.py -> mobsf/StaticAnalyzer/tools/androguard4/util.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- coding: utf_8 -*-",
          "2: # flake8: noqa",
          "3: from typing import Union",
          "5: from asn1crypto.x509 import Name",
          "8: def get_certificate_name_string(",
          "9:     name: Union[dict, Name], short: bool = False, delimiter: str = ', '",
          "10: ) -> str:",
          "11:     \"\"\"",
          "12:     Format the Name type of a X509 Certificate in a human readable form.",
          "14:     :param name: Name object to return the DN from",
          "15:     :param short: Use short form (default: False)",
          "16:     :param delimiter: Delimiter string or character between two parts (default: ', ')",
          "18:     :type name: dict or :class:`asn1crypto.x509.Name`",
          "19:     :type short: boolean",
          "20:     :type delimiter: str",
          "22:     :rtype: str",
          "23:     \"\"\"",
          "24:     if isinstance(name, Name):  # asn1crypto.x509.Name):",
          "25:         name = name.native",
          "27:     # For the shortform, we have a lookup table",
          "28:     # See RFC4514 for more details",
          "29:     _ = {",
          "30:         'business_category': (\"businessCategory\", \"businessCategory\"),",
          "31:         'serial_number': (\"serialNumber\", \"serialNumber\"),",
          "32:         'country_name': (\"C\", \"countryName\"),",
          "33:         'postal_code': (\"postalCode\", \"postalCode\"),",
          "34:         'state_or_province_name': (\"ST\", \"stateOrProvinceName\"),",
          "35:         'locality_name': (\"L\", \"localityName\"),",
          "36:         'street_address': (\"street\", \"streetAddress\"),",
          "37:         'organization_name': (\"O\", \"organizationName\"),",
          "38:         'organizational_unit_name': (\"OU\", \"organizationalUnitName\"),",
          "39:         'title': (\"title\", \"title\"),",
          "40:         'common_name': (\"CN\", \"commonName\"),",
          "41:         'initials': (\"initials\", \"initials\"),",
          "42:         'generation_qualifier': (\"generationQualifier\", \"generationQualifier\"),",
          "43:         'surname': (\"SN\", \"surname\"),",
          "44:         'given_name': (\"GN\", \"givenName\"),",
          "45:         'name': (\"name\", \"name\"),",
          "46:         'pseudonym': (\"pseudonym\", \"pseudonym\"),",
          "47:         'dn_qualifier': (\"dnQualifier\", \"dnQualifier\"),",
          "48:         'telephone_number': (\"telephoneNumber\", \"telephoneNumber\"),",
          "49:         'email_address': (\"E\", \"emailAddress\"),",
          "50:         'domain_component': (\"DC\", \"domainComponent\"),",
          "51:         'name_distinguisher': (\"nameDistinguisher\", \"nameDistinguisher\"),",
          "52:         'organization_identifier': (",
          "53:             \"organizationIdentifier\",",
          "54:             \"organizationIdentifier\",",
          "55:         ),",
          "56:     }",
          "57:     return delimiter.join(",
          "58:         [",
          "59:             \"{}={}\".format(",
          "60:                 _.get(attr, (attr, attr))[0 if short else 1], name[attr]",
          "61:             )",
          "62:             for attr in name",
          "63:         ]",
          "64:     )",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/views/android/apk.py||mobsf/StaticAnalyzer/views/android/apk.py": [
          "File: mobsf/StaticAnalyzer/views/android/apk.py -> mobsf/StaticAnalyzer/views/android/apk.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:         app_dic['certz'] = get_hardcoded_cert_keystore(",
          "174:             checksum,",
          "175:             app_dic['files'])",
          "177:         andro_apk = parse_apk(",
          "178:             checksum,",
          "179:             app_dic['app_path'])",
          "",
          "[Removed Lines]",
          "176:         # Parse APK with Androguard",
          "",
          "[Added Lines]",
          "176:         # Parse APK with Androguard4",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/views/android/app.py||mobsf/StaticAnalyzer/views/android/app.py": [
          "File: mobsf/StaticAnalyzer/views/android/app.py -> mobsf/StaticAnalyzer/views/android/app.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: def parse_apk(checksum, app_path):",
          "20:     try:",
          "21:         msg = 'Parsing APK with androguard'",
          "22:         logger.info(msg)",
          "",
          "[Removed Lines]",
          "19:     \"\"\"Androguard APK.\"\"\"",
          "",
          "[Added Lines]",
          "19:     \"\"\"Androguard4 APK.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:         if a:",
          "36:             # Parsed Androguard APK Object",
          "37:             try:",
          "39:             except Exception:",
          "40:                 logger.warning('Failed to get app name from parsed APK object')",
          "41:         # Look for app_name in values folder.",
          "",
          "[Removed Lines]",
          "38:                 return a.get_app_name()",
          "",
          "[Added Lines]",
          "38:                 app_name = a.get_app_name()",
          "39:                 if app_name:",
          "40:                     return app_name",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/views/android/cert_analysis.py||mobsf/StaticAnalyzer/views/android/cert_analysis.py": [
          "File: mobsf/StaticAnalyzer/views/android/cert_analysis.py -> mobsf/StaticAnalyzer/views/android/cert_analysis.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:     find_java_binary,",
          "26:     gen_sha256_hash,",
          "27: )",
          "30: )",
          "32: logger = logging.getLogger(__name__)",
          "",
          "[Removed Lines]",
          "28: from mobsf.StaticAnalyzer.tools.androguard4.apk import (",
          "29:     get_certificate_name_string,",
          "",
          "[Added Lines]",
          "28: from mobsf.StaticAnalyzer.tools.androguard4 import (",
          "29:     util,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:     \"\"\"Get certificate details.\"\"\"",
          "78:     certlist = []",
          "79:     x509_cert = asn1crypto.x509.Certificate.load(data)",
          "81:     certlist.append(f'X.509 Subject: {subject}')",
          "82:     certlist.append(f'Signature Algorithm: {x509_cert.signature_algo}')",
          "83:     valid_from = x509_cert['tbs_certificate']['validity']['not_before'].native",
          "84:     certlist.append(f'Valid From: {valid_from}')",
          "85:     valid_to = x509_cert['tbs_certificate']['validity']['not_after'].native",
          "86:     certlist.append(f'Valid To: {valid_to}')",
          "88:     certlist.append(f'Issuer: {issuer}')",
          "89:     certlist.append(f'Serial Number: {hex(x509_cert.serial_number)}')",
          "90:     certlist.append(f'Hash Algorithm: {x509_cert.hash_algo}')",
          "",
          "[Removed Lines]",
          "80:     subject = get_certificate_name_string(x509_cert.subject, short=True)",
          "87:     issuer = get_certificate_name_string(x509_cert.issuer, short=True)",
          "",
          "[Added Lines]",
          "80:     subject = util.get_certificate_name_string(x509_cert.subject, short=True)",
          "87:     issuer = util.get_certificate_name_string(x509_cert.issuer, short=True)",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/views/android/jar_aar.py||mobsf/StaticAnalyzer/views/android/jar_aar.py": [
          "File: mobsf/StaticAnalyzer/views/android/jar_aar.py -> mobsf/StaticAnalyzer/views/android/jar_aar.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:             checksum,",
          "102:             app_dic['files'])",
          "103:         app_dic['playstore'] = {'error': True}",
          "105:         apk = parse_apk(",
          "106:             checksum,",
          "107:             app_dic['app_path'])",
          "",
          "[Removed Lines]",
          "104:         # Parse APK with Androguard",
          "",
          "[Added Lines]",
          "104:         # Parse APK with Androguard4",
          "",
          "---------------"
        ],
        "mobsf/StaticAnalyzer/views/android/manifest_utils.py||mobsf/StaticAnalyzer/views/android/manifest_utils.py": [
          "File: mobsf/StaticAnalyzer/views/android/manifest_utils.py -> mobsf/StaticAnalyzer/views/android/manifest_utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: def get_android_manifest_androguard(apk, app_dir):",
          "59:     try:",
          "60:         logger.info('Extracting AndroidManifest.xml with Androguard')",
          "61:         if not apk:",
          "",
          "[Removed Lines]",
          "58:     \"\"\"Get AndroidManifest.xml using Androguard.\"\"\"",
          "",
          "[Added Lines]",
          "58:     \"\"\"Get AndroidManifest.xml using Androguard4.\"\"\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d1c9cb1f4f432d32283f0080599778e2443903bd",
      "candidate_info": {
        "commit_hash": "d1c9cb1f4f432d32283f0080599778e2443903bd",
        "repo": "MobSF/Mobile-Security-Framework-MobSF",
        "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/d1c9cb1f4f432d32283f0080599778e2443903bd",
        "files": [
          "mobsf/MobSF/init.py",
          "mobsf/MobSF/settings.py",
          "pyproject.toml",
          "scripts/start_avd.ps1"
        ],
        "message": "DjangoQ2 config",
        "before_after_code_files": [
          "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
          "mobsf/MobSF/settings.py||mobsf/MobSF/settings.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ],
          "candidate": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py"
          ]
        }
      },
      "candidate_diff": {
        "mobsf/MobSF/init.py||mobsf/MobSF/init.py": [
          "File: mobsf/MobSF/init.py -> mobsf/MobSF/init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: logger = logging.getLogger(__name__)",
          "22: BANNER = r\"\"\"",
          "23:   __  __       _    ____  _____       _  _    ____",
          "24:  |  \\/  | ___ | |__/ ___||  ___|_   _| || |  |___ \\",
          "",
          "[Removed Lines]",
          "21: VERSION = '4.2.2'",
          "",
          "[Added Lines]",
          "21: VERSION = '4.2.3'",
          "",
          "---------------"
        ],
        "mobsf/MobSF/settings.py||mobsf/MobSF/settings.py": [
          "File: mobsf/MobSF/settings.py -> mobsf/MobSF/settings.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "344: Q_CLUSTER = {",
          "345:     'name': 'scan_queue',",
          "346:     'workers': int(os.getenv('MOBSF_ASYNC_WORKERS', 3)),",
          "348:     'timeout': 3600,",
          "349:     'retry': 3700,",
          "350:     'compress': True,",
          "351:     'label': 'scan_queue',",
          "352:     'orm': 'default',",
          "354:     'save_limit': -1,",
          "355: }",
          "356: QUEUE_MAX_SIZE = 100",
          "357: ASYNC_ANALYSIS = bool(os.getenv('MOBSF_ASYNC_ANALYSIS', '0') == '1')",
          "",
          "[Removed Lines]",
          "347:     'recycle': 10,",
          "353:     'max_attempts': 2,",
          "",
          "[Added Lines]",
          "347:     'recycle': 5,",
          "353:     'max_attempts': 1,",
          "355:     'ack_failures': True,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "17f3f028ff1c3138c4a2f78a36eb961ffbeda073",
      "candidate_info": {
        "commit_hash": "17f3f028ff1c3138c4a2f78a36eb961ffbeda073",
        "repo": "MobSF/Mobile-Security-Framework-MobSF",
        "commit_url": "https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/17f3f028ff1c3138c4a2f78a36eb961ffbeda073",
        "files": [
          "mobsf/MobSF/init.py",
          "poetry.lock",
          "pyproject.toml"
        ],
        "message": "HOTFIX: Libsast bump (#2443)\n\n* Libsast bump\n* Bump libsast to address match case",
        "before_after_code_files": [
          "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
          "poetry.lock||poetry.lock"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
            "poetry.lock||poetry.lock"
          ],
          "candidate": [
            "mobsf/MobSF/init.py||mobsf/MobSF/init.py",
            "poetry.lock||poetry.lock"
          ]
        }
      },
      "candidate_diff": {
        "mobsf/MobSF/init.py||mobsf/MobSF/init.py": [
          "File: mobsf/MobSF/init.py -> mobsf/MobSF/init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: logger = logging.getLogger(__name__)",
          "20: BANNER = r\"\"\"",
          "21:   __  __       _    ____  _____       _  _    _",
          "22:  |  \\/  | ___ | |__/ ___||  ___|_   _| || |  / |",
          "",
          "[Removed Lines]",
          "19: VERSION = '4.1.2'",
          "",
          "[Added Lines]",
          "19: VERSION = '4.1.3'",
          "",
          "---------------"
        ],
        "poetry.lock||poetry.lock": [
          "File: poetry.lock -> poetry.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "1033: [[package]]",
          "1034: name = \"libsast\"",
          "1036: description = \"A generic SAST library built on top of semgrep and regex\"",
          "1037: optional = false",
          "1039: files = [",
          "1042: ]",
          "1044: [package.dependencies]",
          "1045: pyyaml = \">=6.0\"",
          "1047: semgrep = {version = \"0.117.0\", markers = \"sys_platform != \\\"win32\\\"\"}",
          "1049: [[package]]",
          "",
          "[Removed Lines]",
          "1035: version = \"2.0.3\"",
          "1038: python-versions = \">=3.8,<4.0\"",
          "1040:     {file = \"libsast-2.0.3-py3-none-any.whl\", hash = \"sha256:2c70f9d94ff95c3302f0a038f05f381eb6a55c2acaeda717c5c1551006a74a2f\"},",
          "1041:     {file = \"libsast-2.0.3.tar.gz\", hash = \"sha256:8bf0ef3ad31864fcdcf073840c5875e9a2fcdb9f895617141f30c953e361577d\"},",
          "1046: requests = \">=2.27.1\"",
          "",
          "[Added Lines]",
          "1035: version = \"3.0.2\"",
          "1038: python-versions = \"<4.0,>=3.8\"",
          "1040:     {file = \"libsast-3.0.2-py3-none-any.whl\", hash = \"sha256:063a2ea80da9fc247077461aa2a608187aa1f68331455f421ab6328b13c6efa9\"},",
          "1041:     {file = \"libsast-3.0.2.tar.gz\", hash = \"sha256:f585328b1a927d1d47c776ae36db83860acc521f5f2a6fd7153aeae367c20d38\"},",
          "1046: requests = \"*\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2631: [[package]]",
          "2632: name = \"werkzeug\"",
          "2634: description = \"The comprehensive WSGI web application library.\"",
          "2635: optional = false",
          "2636: python-versions = \">=3.9\"",
          "2637: files = [",
          "2640: ]",
          "2642: [package.dependencies]",
          "",
          "[Removed Lines]",
          "2633: version = \"3.1.1\"",
          "2638:     {file = \"werkzeug-3.1.1-py3-none-any.whl\", hash = \"sha256:a71124d1ef06008baafa3d266c02f56e1836a5984afd6dd6c9230669d60d9fb5\"},",
          "2639:     {file = \"werkzeug-3.1.1.tar.gz\", hash = \"sha256:8cd39dfbdfc1e051965f156163e2974e52c210f130810e9ad36858f0fd3edad4\"},",
          "",
          "[Added Lines]",
          "2633: version = \"3.1.2\"",
          "2638:     {file = \"werkzeug-3.1.2-py3-none-any.whl\", hash = \"sha256:4f7d1a5de312c810a8a2c6f0b47e9f6a7cffb7c8322def35e4d4d9841ff85597\"},",
          "2639:     {file = \"werkzeug-3.1.2.tar.gz\", hash = \"sha256:f471a4cd167233077e9d2a8190c3471c5bc520c636a9e3c1e9300c33bced03bc\"},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2954: [metadata]",
          "2955: lock-version = \"2.0\"",
          "2956: python-versions = \"^3.10\"",
          "",
          "[Removed Lines]",
          "2957: content-hash = \"74559be720801d4d7d836adc55dcc44e431579985697660dab0881ee2f4c2036\"",
          "",
          "[Added Lines]",
          "2957: content-hash = \"d3a4b0b9830661273a8f67707718128a63952ab59d9e8f65bd897a80805c7609\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
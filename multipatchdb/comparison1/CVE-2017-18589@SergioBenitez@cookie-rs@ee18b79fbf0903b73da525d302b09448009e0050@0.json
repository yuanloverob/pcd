{
  "cve_id": "CVE-2017-18589",
  "cve_desc": "An issue was discovered in the cookie crate before 0.7.6 for Rust. Large integers in the Max-Age of a cookie cause a panic.",
  "repo": "SergioBenitez/cookie-rs",
  "patch_hash": "ee18b79fbf0903b73da525d302b09448009e0050",
  "patch_info": {
    "commit_hash": "ee18b79fbf0903b73da525d302b09448009e0050",
    "repo": "SergioBenitez/cookie-rs",
    "commit_url": "https://github.com/SergioBenitez/cookie-rs/commit/ee18b79fbf0903b73da525d302b09448009e0050",
    "files": [
      "src/parse.rs"
    ],
    "message": "Don't panic if passed in a large max age.\n\nDuration will panic if the number of seconds is greater than\n2^63/1000. This just caps the Max-Age to the highest value we\ncan parse.",
    "before_after_code_files": [
      "src/parse.rs||src/parse.rs"
    ]
  },
  "patch_diff": {
    "src/parse.rs||src/parse.rs": [
      "File: src/parse.rs -> src/parse.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: use std::borrow::Cow;",
      "2: use std::error::Error;",
      "3: use std::ascii::AsciiExt;",
      "4: use std::str::Utf8Error;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: use std::cmp;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "153:                 cookie.max_age = match v.parse() {",
      "154:                     Ok(val) if val <= 0 => Some(Duration::zero()),",
      "156:                     Err(_) => continue,",
      "157:                 };",
      "158:             }",
      "",
      "[Removed Lines]",
      "155:                     Ok(val) => Some(Duration::seconds(val)),",
      "",
      "[Added Lines]",
      "156:                     Ok(val) => {",
      "159:                         let val = cmp::min(val, Duration::max_value().num_seconds());",
      "160:                         Some(Duration::seconds(val))",
      "161:                     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "393:         assert_eq!(cookie, expected);",
      "394:     }",
      "395: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "402:     #[test]",
      "403:     fn do_not_panic_on_large_max_ages() {",
      "404:         let max_seconds = Duration::max_value().num_seconds();",
      "405:         let expected = Cookie::build(\"foo\", \"bar\")",
      "406:             .max_age(Duration::seconds(max_seconds))",
      "407:             .finish();",
      "408:         assert_eq_parse!(format!(\" foo=bar; Max-Age={:?}\", max_seconds + 1), expected);",
      "409:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c0112012c3ceedd12dccee2bea650d2082a027a2",
      "candidate_info": {
        "commit_hash": "c0112012c3ceedd12dccee2bea650d2082a027a2",
        "repo": "SergioBenitez/cookie-rs",
        "commit_url": "https://github.com/SergioBenitez/cookie-rs/commit/c0112012c3ceedd12dccee2bea650d2082a027a2",
        "files": [
          "Cargo.toml",
          "README.md",
          "src/builder.rs",
          "src/jar.rs",
          "src/lib.rs",
          "src/parse.rs"
        ],
        "message": "Improve docs and usability. Make parsing allocation free.\n\nThis is the largest change to the `Cookie` API and internals since the crate's\ninception. The following bullet points summarize the changes:\n\n  * `Cookie` parsing is allocation-free.\n  * All fields in `Cookie` can be set allocation-free.\n  * A `Cookie` can have a non-static lifetime.\n  * All methods in `Cookie` are documented with examples.\n  * A `Cookie` can be built via a new builder structure: `CookieBuilder`.\n  * `Cookie` fields are exposed via methods instead of directly.\n  * Custom, nonstandard cookie parameters are no longer supported.\n  * Additional parsing tests have been added.\n  * A suite of formatting tests has been added.\n  * A 'percent-encode' feature has been added for automatic percent encoding.\n  * Serde and Rustc serialization features have been removed.\n  * The top-level crate docs have been improved.\n  * The documenation URL now points to `docs.rs`.\n  * The entire crate has been `rustfmt`d where possible, removing tabs.\n  * The `max_age` field uses a `Duration` instead of an `i64`.",
        "before_after_code_files": [
          "src/builder.rs||src/builder.rs",
          "src/jar.rs||src/jar.rs",
          "src/lib.rs||src/lib.rs",
          "src/parse.rs||src/parse.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/parse.rs||src/parse.rs"
          ],
          "candidate": [
            "src/parse.rs||src/parse.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/builder.rs||src/builder.rs": [
          "File: src/builder.rs -> src/builder.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use std::borrow::Cow;",
          "3: use time::{Tm, Duration};",
          "5: use ::Cookie;",
          "35: #[derive(Debug, Clone)]",
          "36: pub struct CookieBuilder {",
          "38:     cookie: Cookie<'static>,",
          "39: }",
          "41: impl CookieBuilder {",
          "55:     #[inline(always)]",
          "56:     pub fn new<N, V>(name: N, value: V) -> CookieBuilder",
          "57:         where N: Into<Cow<'static, str>>,",
          "58:               V: Into<Cow<'static, str>>",
          "59:     {",
          "60:         CookieBuilder { cookie: Cookie::new(name, value) }",
          "61:     }",
          "81:     #[inline(always)]",
          "82:     pub fn expires(mut self, when: Tm) -> CookieBuilder {",
          "83:         self.cookie.set_expires(when);",
          "84:         self",
          "85:     }",
          "106:     #[inline(always)]",
          "107:     pub fn max_age(mut self, value: Duration) -> CookieBuilder {",
          "108:         self.cookie.set_max_age(value);",
          "109:         self",
          "110:     }",
          "125:     #[inline(always)]",
          "126:     pub fn domain<D: Into<Cow<'static, str>>>(mut self, value: D) -> CookieBuilder {",
          "127:         self.cookie.set_domain(value);",
          "128:         self",
          "129:     }",
          "144:     #[inline(always)]",
          "145:     pub fn path<P: Into<Cow<'static, str>>>(mut self, path: P) -> CookieBuilder {",
          "146:         self.cookie.set_path(path);",
          "147:         self",
          "148:     }",
          "163:     #[inline(always)]",
          "164:     pub fn secure(mut self, value: bool) -> CookieBuilder {",
          "165:         self.cookie.set_secure(value);",
          "166:         self",
          "167:     }",
          "182:     #[inline(always)]",
          "183:     pub fn http_only(mut self, value: bool) -> CookieBuilder {",
          "184:         self.cookie.set_http_only(value);",
          "185:         self",
          "186:     }",
          "204:     #[inline(always)]",
          "205:     pub fn finish(self) -> Cookie<'static> {",
          "206:         self.cookie",
          "207:     }",
          "208: }",
          "",
          "---------------"
        ],
        "src/jar.rs||src/jar.rs": [
          "File: src/jar.rs -> src/jar.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: use std::collections::{HashMap, HashSet};",
          "15: use std::cell::RefCell;",
          "16: use std::fmt;",
          "",
          "[Removed Lines]",
          "17: use time;",
          "19: use Cookie;",
          "",
          "[Added Lines]",
          "16: use std::borrow::Cow;",
          "18: use time::{self, Duration};",
          "20: use ::Cookie;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     write: Write,",
          "51: }",
          "77: struct Root {",
          "82: }",
          "85: pub struct Iter<'a> {",
          "86:     jar: &'a CookieJar<'a>,",
          "88: }",
          "90: impl<'a> CookieJar<'a> {",
          "",
          "[Removed Lines]",
          "53: type Read = fn(&Root, Cookie) -> Option<Cookie>;",
          "54: type Write = fn(&Root, Cookie) -> Cookie;",
          "56: #[cfg(feature = \"secure\")]",
          "57: type SigningKey = Vec<u8>;",
          "58: #[cfg(not(feature = \"secure\"))]",
          "59: type SigningKey = ();",
          "61: #[cfg(feature = \"secure\")]",
          "62: fn prepare_key(key: &[u8]) -> Vec<u8> {",
          "63:     if key.len() >= secure::MIN_KEY_LEN {",
          "64:         key.to_vec()",
          "65:     } else {",
          "68:         secure::prepare_key(key)",
          "69:     }",
          "70: }",
          "72: #[cfg(not(feature = \"secure\"))]",
          "73: fn prepare_key(_key: &[u8]) -> () {",
          "74:     ()",
          "75: }",
          "78:     map: RefCell<HashMap<String, Cookie>>,",
          "79:     new_cookies: RefCell<HashSet<String>>,",
          "80:     removed_cookies: RefCell<HashSet<String>>,",
          "81:     _key: SigningKey,",
          "87:     keys: Vec<String>,",
          "",
          "[Added Lines]",
          "52: type Read = fn(&Root, Cookie<'static>) -> Option<Cookie<'static>>;",
          "53: type Write = fn(&Root, Cookie<'static>) -> Cookie<'static>;",
          "56:     map: RefCell<HashMap<Cow<'static, str>, Cookie<'static>>>,",
          "57:     new_cookies: RefCell<HashSet<Cow<'static, str>>>,",
          "58:     removed_cookies: RefCell<HashSet<Cow<'static, str>>>,",
          "59:     _key: secure::SigningKey,",
          "65:     keys: Vec<Cow<'static, str>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:                 map: RefCell::new(HashMap::new()),",
          "98:                 new_cookies: RefCell::new(HashSet::new()),",
          "99:                 removed_cookies: RefCell::new(HashSet::new()),",
          "102:         }",
          "103:     }",
          "",
          "[Removed Lines]",
          "100:                 _key: prepare_key(key),",
          "101:             })",
          "",
          "[Added Lines]",
          "78:                 _key: secure::prepare_key(key),",
          "79:             }),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "121:         match self.flavor {",
          "122:             Flavor::Child(..) => panic!(\"can't add an original cookie to a child jar!\"),",
          "123:             Flavor::Root(ref mut root) => {",
          "126:             }",
          "127:         }",
          "128:     }",
          "",
          "[Removed Lines]",
          "120:     pub fn add_original(&mut self, cookie: Cookie) {",
          "124:                 let name = cookie.name.clone();",
          "125:                 root.map.borrow_mut().insert(name, cookie);",
          "",
          "[Added Lines]",
          "102:     pub fn add_original(&mut self, cookie: Cookie<'static>) {",
          "106:                 let name = cookie.name().to_string();",
          "107:                 root.map.borrow_mut().insert(name.into(), cookie);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "135:         let mut cur = self;",
          "136:         let root = self.root();",
          "137:         loop {",
          "",
          "[Removed Lines]",
          "134:     pub fn add(&self, mut cookie: Cookie) {",
          "",
          "[Added Lines]",
          "116:     pub fn add(&self, mut cookie: Cookie<'static>) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "143:                 Flavor::Root(..) => break,",
          "144:             }",
          "145:         }",
          "150:     }",
          "154:         let root = self.root();",
          "159:     }",
          "162:     pub fn clear(&self) {",
          "163:         let root = self.root();",
          "165:         root.map.borrow_mut().clear();",
          "166:         root.new_cookies.borrow_mut().clear();",
          "167:         root.removed_cookies.borrow_mut().extend(all_cookies);",
          "",
          "[Removed Lines]",
          "146:         let name = cookie.name.clone();",
          "147:         root.map.borrow_mut().insert(name.clone(), cookie);",
          "148:         root.removed_cookies.borrow_mut().remove(&name);",
          "149:         root.new_cookies.borrow_mut().insert(name);",
          "153:     pub fn remove(&self, cookie: &str) {",
          "155:         let cookie = cookie.to_string();",
          "156:         root.map.borrow_mut().remove(&cookie);",
          "157:         root.new_cookies.borrow_mut().remove(&cookie);",
          "158:         root.removed_cookies.borrow_mut().insert(cookie);",
          "164:         let all_cookies: Vec<_> = root.map.borrow().keys().map(|n| n.to_owned()).collect();",
          "",
          "[Added Lines]",
          "128:         let name = cookie.name().to_string();",
          "129:         root.map.borrow_mut().insert(name.clone().into(), cookie);",
          "130:         root.removed_cookies.borrow_mut().remove(&*name);",
          "131:         root.new_cookies.borrow_mut().insert(name.into());",
          "135:     pub fn remove<N: Into<Cow<'static, str>>>(&self, cookie_name: N) {",
          "137:         let name = cookie_name.into();",
          "138:         root.map.borrow_mut().remove(&name);",
          "139:         root.new_cookies.borrow_mut().remove(&name);",
          "140:         root.removed_cookies.borrow_mut().insert(name);",
          "146:         let all_cookies: Vec<_> = root.map",
          "147:             .borrow()",
          "148:             .keys()",
          "149:             .map(|n| n.to_owned())",
          "150:             .collect();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "176:         let root = self.root();",
          "179:         }",
          "181:     }",
          "",
          "[Removed Lines]",
          "174:     pub fn find(&self, name: &str) -> Option<Cookie> {",
          "175:         let name = name.to_string();",
          "177:         if root.removed_cookies.borrow().contains(&name) {",
          "178:             return None",
          "180:         root.map.borrow().get(&name).and_then(|c| self.try_read(root, c.clone()))",
          "",
          "[Added Lines]",
          "161:     pub fn find(&self, name: &str) -> Option<Cookie<'static>> {",
          "163:         if root.removed_cookies.borrow().contains(name) {",
          "164:             return None;",
          "166:         root.map.borrow().get(name).and_then(|c| self.try_read(root, c.clone()))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "203:         return CookieJar {",
          "204:             flavor: Flavor::Child(Child {",
          "205:                 parent: self,",
          "207:                 write: sign,",
          "209:         };",
          "213:         }",
          "215:             secure::sign(&root._key, cookie)",
          "216:         }",
          "217:     }",
          "",
          "[Removed Lines]",
          "206:                 read: design,",
          "208:             })",
          "211:         fn design(root: &Root, cookie: Cookie) -> Option<Cookie> {",
          "212:             secure::design(&root._key, cookie)",
          "214:         fn sign(root: &Root, cookie: Cookie) -> Cookie {",
          "",
          "[Added Lines]",
          "192:                 read: verify,",
          "194:             }),",
          "197:         fn verify(root: &Root, cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "198:             secure::verify(&root._key, cookie)",
          "201:         fn sign(root: &Root, cookie: Cookie<'static>) -> Cookie<'static> {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "243:                 parent: self,",
          "244:                 read: read,",
          "245:                 write: write,",
          "247:         };",
          "250:         }",
          "252:             secure::encrypt_and_sign(&root._key, cookie)",
          "253:         }",
          "254:     }",
          "",
          "[Removed Lines]",
          "246:             })",
          "248:         fn read(root: &Root, cookie: Cookie) -> Option<Cookie> {",
          "249:             secure::design_and_decrypt(&root._key, cookie)",
          "251:         fn write(root: &Root, cookie: Cookie) -> Cookie {",
          "",
          "[Added Lines]",
          "232:             }),",
          "235:         fn read(root: &Root, cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "236:             secure::verify_and_decrypt(&root._key, cookie)",
          "239:         fn write(root: &Root, cookie: Cookie<'static>) -> Cookie<'static> {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "263:                 parent: self,",
          "264:                 read: read,",
          "265:                 write: write,",
          "267:         };",
          "270:             Some(cookie)",
          "271:         }",
          "276:             let mut now = time::now();",
          "277:             now.tm_year += 20;",
          "279:             cookie",
          "280:         }",
          "281:     }",
          "286:         let mut ret = Vec::new();",
          "287:         let root = self.root();",
          "288:         for cookie in root.removed_cookies.borrow().iter() {",
          "289:             let mut c = Cookie::new(cookie.clone(), String::new());",
          "291:             let mut now = time::now();",
          "292:             now.tm_year -= 1;",
          "294:             ret.push(c);",
          "295:         }",
          "296:         let map = root.map.borrow();",
          "297:         for cookie in root.new_cookies.borrow().iter() {",
          "298:             ret.push(map.get(cookie).unwrap().clone());",
          "299:         }",
          "300:         return ret;",
          "301:     }",
          "304:         let mut jar = self;",
          "305:         loop {",
          "306:             match jar.flavor {",
          "307:                 Flavor::Child(Child { read, parent, .. }) => {",
          "308:                     cookie = match read(root, cookie) {",
          "310:                     };",
          "311:                     jar = parent;",
          "312:                 }",
          "",
          "[Removed Lines]",
          "266:             })",
          "269:         fn read(_root: &Root, cookie: Cookie) -> Option<Cookie> {",
          "273:         fn write(_root: &Root, mut cookie: Cookie) -> Cookie {",
          "275:             cookie.max_age = Some(3600 * 24 * 365 * 20);",
          "278:             cookie.expires = Some(now);",
          "285:     pub fn delta(&self) -> Vec<Cookie> {",
          "290:             c.max_age = Some(0);",
          "293:             c.expires = Some(now);",
          "303:     fn try_read(&self, root: &Root, mut cookie: Cookie) -> Option<Cookie> {",
          "309:                         Some(c) => c, None => return None,",
          "",
          "[Added Lines]",
          "254:             }),",
          "257:         fn read(_root: &Root, cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "261:         fn write(_root: &Root, mut cookie: Cookie<'static>) -> Cookie<'static> {",
          "263:             cookie.set_max_age(Duration::days(365 * 20));",
          "266:             cookie.set_expires(now);",
          "273:     pub fn delta(&self) -> Vec<Cookie<'static>> {",
          "278:             c.set_max_age(Duration::zero());",
          "281:             c.set_expires(now);",
          "293:     fn try_read(&self, root: &Root, mut cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "299:                         Some(c) => c,",
          "300:                         None => return None,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "324:     pub fn iter(&self) -> Iter {",
          "325:         let map = self.root().map.borrow();",
          "327:     }",
          "328: }",
          "",
          "[Removed Lines]",
          "326:         Iter { jar: self, keys: map.keys().cloned().collect() }",
          "",
          "[Added Lines]",
          "317:         Iter {",
          "318:             jar: self,",
          "319:             keys: map.keys().cloned().collect(),",
          "320:         }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "345: }",
          "347: impl<'a> Iterator for Iter<'a> {",
          "351:         loop {",
          "352:             let key = match self.keys.pop() {",
          "353:                 Some(v) => v,",
          "",
          "[Removed Lines]",
          "348:     type Item = Cookie;",
          "350:     fn next(&mut self) -> Option<Cookie> {",
          "",
          "[Added Lines]",
          "342:     type Item = Cookie<'static>;",
          "344:     fn next(&mut self) -> Option<Cookie<'static>> {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "367:     }",
          "368: }",
          "370: #[cfg(feature = \"secure\")]",
          "371: mod secure {",
          "372:     extern crate openssl;",
          "373:     extern crate rustc_serialize;",
          "376:     use self::openssl::{hash, memcmp, symm};",
          "377:     use self::openssl::pkey::PKey;",
          "378:     use self::openssl::sign::Signer;",
          "379:     use self::openssl::hash::MessageDigest;",
          "380:     use self::rustc_serialize::base64::{ToBase64, FromBase64, STANDARD};",
          "382:     pub const MIN_KEY_LEN: usize = 32;",
          "393:         cookie",
          "394:     }",
          "",
          "[Removed Lines]",
          "375:     use Cookie;",
          "389:     pub fn sign(key: &[u8], mut cookie: Cookie) -> Cookie {",
          "390:         let signature = dosign(key, &cookie.value);",
          "391:         cookie.value.push_str(\"--\");",
          "392:         cookie.value.push_str(&signature.to_base64(STANDARD));",
          "",
          "[Added Lines]",
          "365: #[cfg(not(feature = \"secure\"))]",
          "366: mod secure {",
          "367:     pub type SigningKey = ();",
          "369:     pub fn prepare_key(_key: &[u8]) -> () {",
          "370:         ()",
          "371:     }",
          "372: }",
          "379:     use ::Cookie;",
          "386:     pub type SigningKey = Vec<u8>;",
          "389:     pub fn prepare_key(key: &[u8]) -> Vec<u8> {",
          "390:         if key.len() >= MIN_KEY_LEN {",
          "391:             key.to_vec()",
          "392:         } else {",
          "394:             hash::hash(MessageDigest::sha256(), key).unwrap()",
          "395:         }",
          "396:     }",
          "403:     pub fn sign(key: &[u8], mut cookie: Cookie<'static>) -> Cookie<'static> {",
          "404:         let signature = dosign(key, cookie.value()).to_base64(STANDARD);",
          "405:         let new_cookie_val = format!(\"{}--{}\", cookie.value(), signature);",
          "406:         cookie.set_value(new_cookie_val);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "400:             _ => return None,",
          "401:         };",
          "402:         let val_len = val.len();",
          "404:         let text = &val[..val_len - ext.len() - 2];",
          "405:         let ext = match ext.from_base64() {",
          "407:         };",
          "409:         Some((text, ext))",
          "410:     }",
          "416:         };",
          "423:         }",
          "424:         Some(cookie)",
          "425:     }",
          "",
          "[Removed Lines]",
          "403:         if ext.len() == val_len { return None }",
          "406:             Ok(sig) => sig, Err(..) => return None,",
          "412:     pub fn design(key: &[u8], mut cookie: Cookie) -> Option<Cookie> {",
          "413:         let signed_value = cookie.value;",
          "414:         let (text, signature) = match split_value(&signed_value) {",
          "415:             Some(pair) => pair, None => return None",
          "417:         cookie.value = text.to_owned();",
          "419:         let expected = dosign(key, text);",
          "420:         if expected.len() != signature.len() ||",
          "421:            !memcmp::eq(&expected, &signature) {",
          "422:             return None",
          "",
          "[Added Lines]",
          "417:         if ext.len() == val_len {",
          "418:             return None;",
          "419:         }",
          "422:             Ok(sig) => sig,",
          "423:             Err(..) => return None,",
          "429:     pub fn verify(key: &[u8], mut cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "430:         let (text, signature) = match split_value(cookie.value()) {",
          "431:             Some((text, sig)) => (text.to_string(), sig),",
          "432:             None => return None,",
          "436:         let expected = dosign(key, &text);",
          "437:         if expected.len() != signature.len() || !memcmp::eq(&expected, &signature) {",
          "438:             return None;",
          "441:         cookie.set_value(text);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "439:         sign(key, cookie)",
          "440:     }",
          "",
          "[Removed Lines]",
          "436:     pub fn encrypt_and_sign(key: &[u8], mut cookie: Cookie) -> Cookie {",
          "437:         let encrypted_data = encrypt_data(key, &cookie.value);",
          "438:         cookie.value = encrypted_data;",
          "",
          "[Added Lines]",
          "454:     pub fn encrypt_and_sign(key: &[u8], mut cookie: Cookie<'static>) -> Cookie<'static> {",
          "455:         let encrypted_data = encrypt_data(key, cookie.value());",
          "456:         cookie.set_value(encrypted_data);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "443:         let iv = random_iv();",
          "444:         let iv_str = iv.to_base64(STANDARD);",
          "452:         encrypted_data.push_str(\"--\");",
          "453:         encrypted_data.push_str(&iv_str);",
          "454:         encrypted_data",
          "455:     }",
          "459:             Some(cookie) => cookie,",
          "461:         };",
          "469:     }",
          "471:     fn decrypt_data(key: &[u8], val: &str) -> Option<Vec<u8>> {",
          "472:         let (val, iv) = match split_value(val) {",
          "474:         };",
          "476:         let actual = match val.from_base64() {",
          "478:         };",
          "480:         Some(symm::decrypt(symm::Cipher::aes_256_cbc(),",
          "481:                            &key[..MIN_KEY_LEN],",
          "482:                            Some(&iv),",
          "484:     }",
          "486:     fn random_iv() -> Vec<u8> {",
          "487:         let mut ret = vec![0; 16];",
          "488:         openssl::rand::rand_bytes(&mut ret).unwrap();",
          "490:     }",
          "495: }",
          "497: #[cfg(test)]",
          "",
          "[Removed Lines]",
          "446:         let mut encrypted_data = symm::encrypt(symm::Cipher::aes_256_cbc(),",
          "447:                                                &key[..MIN_KEY_LEN],",
          "448:                                                Some(&iv),",
          "449:                                                val.as_bytes()).unwrap()",
          "450:                                                               .to_base64(STANDARD);",
          "457:     pub fn design_and_decrypt(key: &[u8], cookie: Cookie) -> Option<Cookie> {",
          "458:         let mut cookie = match design(key, cookie) {",
          "460:             None => return None",
          "463:         let decrypted_data = decrypt_data(key, &cookie.value)",
          "464:                                 .and_then(|data| String::from_utf8(data).ok());",
          "465:         match decrypted_data {",
          "466:             Some(val) => { cookie.value = val; Some(cookie) }",
          "467:             None => None",
          "468:         }",
          "473:             Some(pair) => pair, None => return None",
          "477:             Ok(actual) => actual, Err(_) => return None",
          "483:                            &actual).unwrap())",
          "489:         return ret",
          "492:     pub fn prepare_key(key: &[u8]) -> Vec<u8> {",
          "493:         hash::hash(MessageDigest::sha256(), key).unwrap()",
          "494:     }",
          "",
          "[Added Lines]",
          "464:         let cipher = symm::Cipher::aes_256_cbc();",
          "465:         let encrypted = symm::encrypt(cipher, &key[..MIN_KEY_LEN], Some(&iv), val.as_bytes());",
          "466:         let mut encrypted_data = encrypted.unwrap().to_base64(STANDARD);",
          "473:     pub fn verify_and_decrypt(key: &[u8], cookie: Cookie<'static>) -> Option<Cookie<'static>> {",
          "474:         let mut cookie = match verify(key, cookie) {",
          "476:             None => return None,",
          "479:         decrypt_data(key, cookie.value())",
          "480:             .and_then(|data| String::from_utf8(data).ok())",
          "481:             .map(move |val| {",
          "482:                 cookie.set_value(val);",
          "483:                 cookie",
          "484:             })",
          "489:             Some(pair) => pair,",
          "490:             None => return None,",
          "494:             Ok(actual) => actual,",
          "495:             Err(_) => return None,",
          "501:                            &actual)",
          "502:             .unwrap())",
          "508:         return ret;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "509:     fn simple() {",
          "510:         let c = CookieJar::new(KEY);",
          "514:         c.remove(\"test\");",
          "516:         assert!(c.find(\"test\").is_none());",
          "517:         assert!(c.find(\"test2\").is_some());",
          "520:         c.clear();",
          "522:         assert!(c.find(\"test\").is_none());",
          "",
          "[Removed Lines]",
          "512:         c.add(Cookie::new(\"test\".to_string(), \"\".to_string()));",
          "513:         c.add(Cookie::new(\"test2\".to_string(), \"\".to_string()));",
          "519:         c.add(Cookie::new(\"test3\".to_string(), \"\".to_string()));",
          "",
          "[Added Lines]",
          "528:         c.add(Cookie::new(\"test\", \"\"));",
          "529:         c.add(Cookie::new(\"test2\", \"\"));",
          "535:         c.add(Cookie::new(\"test3\", \"\"));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "527:     macro_rules! secure_behaviour {",
          "528:         ($c:ident, $secure:ident) => ({",
          "533:             let mut cookie = $c.find(\"test\").unwrap();",
          "535:             $c.add(cookie);",
          "536:             assert!($c.$secure().find(\"test\").is_none());",
          "538:             let mut cookie = $c.find(\"test\").unwrap();",
          "540:             $c.add(cookie);",
          "541:             assert!($c.$secure().find(\"test\").is_none());",
          "542:         })",
          "",
          "[Removed Lines]",
          "529:             $c.$secure().add(Cookie::new(\"test\".to_string(), \"test\".to_string()));",
          "530:             assert!($c.find(\"test\").unwrap().value != \"test\");",
          "531:             assert!($c.$secure().find(\"test\").unwrap().value == \"test\");",
          "534:             cookie.value.push('l');",
          "539:             cookie.value = \"foobar\".to_string();",
          "",
          "[Added Lines]",
          "545:             $c.$secure().add(Cookie::new(\"test\", \"test\"));",
          "546:             assert!($c.find(\"test\").unwrap().value() != \"test\");",
          "547:             assert!($c.$secure().find(\"test\").unwrap().value() == \"test\");",
          "550:             let new_val = format!(\"{}l\", cookie.value());",
          "551:             cookie.set_value(new_val);",
          "556:             cookie.set_value(\"foobar\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "560:     fn permanent() {",
          "561:         let c = CookieJar::new(KEY);",
          "565:         let cookie = c.find(\"test\").unwrap();",
          "570:     }",
          "573:     #[test]",
          "574:     fn chained() {",
          "575:         let c = CookieJar::new(KEY);",
          "580:         let cookie = c.signed().find(\"test\").unwrap();",
          "584:     }",
          "586:     #[cfg(features = \"secure\")]",
          "",
          "[Removed Lines]",
          "563:         c.permanent().add(Cookie::new(\"test\".to_string(), \"test\".to_string()));",
          "566:         assert_eq!(cookie.value, \"test\");",
          "567:         assert_eq!(c.permanent().find(\"test\").unwrap().value, \"test\");",
          "568:         assert!(cookie.expires.is_some());",
          "569:         assert!(cookie.max_age.is_some());",
          "572:     #[cfg(features = \"secure\")]",
          "577:         c.permanent().signed()",
          "578:          .add(Cookie::new(\"test\".to_string(), \"test\".to_string()));",
          "581:         assert_eq!(cookie.value, \"test\");",
          "582:         assert!(cookie.expires.is_some());",
          "583:         assert!(cookie.max_age.is_some());",
          "",
          "[Added Lines]",
          "580:         c.permanent().add(Cookie::new(\"test\", \"test\"));",
          "583:         assert_eq!(cookie.value(), \"test\");",
          "584:         assert_eq!(c.permanent().find(\"test\").unwrap().value(), \"test\");",
          "585:         assert!(cookie.expires().is_some());",
          "586:         assert!(cookie.max_age().is_some());",
          "589:     #[cfg(feature = \"secure\")]",
          "593:         c.permanent().signed().add(Cookie::new(\"test\", \"test\"));",
          "596:         assert_eq!(cookie.value(), \"test\");",
          "597:         assert!(cookie.expires().is_some());",
          "598:         assert!(cookie.max_age().is_some());",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "588:     fn iter() {",
          "589:         let mut c = CookieJar::new(KEY);",
          "605:         c.remove(\"test\");",
          "",
          "[Removed Lines]",
          "591:         c.add_original(Cookie::new(\"original\".to_string(),",
          "592:                                    \"original\".to_string()));",
          "594:         c.add(Cookie::new(\"test\".to_string(), \"test\".to_string()));",
          "595:         c.add(Cookie::new(\"test2\".to_string(), \"test2\".to_string()));",
          "596:         c.add(Cookie::new(\"test3\".to_string(), \"test3\".to_string()));",
          "597:         c.add(Cookie::new(\"test4\".to_string(), \"test4\".to_string()));",
          "599:         c.signed()",
          "600:          .add(Cookie::new(\"signed\".to_string(), \"signed\".to_string()));",
          "602:         c.encrypted()",
          "603:          .add(Cookie::new(\"encrypted\".to_string(), \"encrypted\".to_string()));",
          "",
          "[Added Lines]",
          "606:         c.add_original(Cookie::new(\"original\", \"original\"));",
          "608:         c.add(Cookie::new(\"test\", \"test\"));",
          "609:         c.add(Cookie::new(\"test2\", \"test2\"));",
          "610:         c.add(Cookie::new(\"test3\", \"test3\"));",
          "611:         c.add(Cookie::new(\"test4\", \"test4\"));",
          "613:         c.signed().add(Cookie::new(\"signed\", \"signed\"));",
          "615:         c.encrypted().add(Cookie::new(\"encrypted\", \"encrypted\"));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "614:         let signed_cookies = c.signed().iter().collect::<Vec<_>>();",
          "615:         assert_eq!(signed_cookies.len(), 2);",
          "618:     }",
          "619: }",
          "",
          "[Removed Lines]",
          "616:         assert!(signed_cookies[0].name == \"signed\" ||",
          "617:                 signed_cookies[1].name == \"signed\");",
          "",
          "[Added Lines]",
          "628:         assert!(signed_cookies[0].name == \"signed\" || signed_cookies[1].name == \"signed\");",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #![deny(missing_docs)]",
          "2: #![doc(html_root_url = \"http://alexcrichton.com/cookie-rs\")]",
          "3: #![cfg_attr(test, deny(warnings))]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23: extern crate time;",
          "27: use std::ascii::AsciiExt;",
          "29: use std::fmt;",
          "30: use std::str::FromStr;",
          "34: pub use jar::CookieJar;",
          "59: }",
          "78:         Cookie {",
          "81:             expires: None,",
          "82:             max_age: None,",
          "83:             domain: None,",
          "84:             path: None,",
          "85:             secure: false,",
          "88:         }",
          "89:     }",
          "115:         };",
          "197:     }",
          "202:     }",
          "203: }",
          "211:     }",
          "220:     }",
          "236:     }",
          "246:     }",
          "254:         match self.path {",
          "257:         }",
          "258:         match self.domain {",
          "269:         }",
          "275:     }",
          "282:     }",
          "342:     }",
          "350:     }",
          "356:     }",
          "362:     }",
          "387:         };",
          "394:     }",
          "426:     }",
          "427: }",
          "",
          "[Removed Lines]",
          "22: extern crate url;",
          "24: #[cfg(feature = \"serialize-rustc\")] extern crate rustc_serialize;",
          "25: #[cfg(feature = \"serialize-serde\")] extern crate serde;",
          "28: use std::collections::BTreeMap;",
          "32: #[cfg(feature = \"serialize-serde\")] use serde::{Serialize, Deserialize};",
          "35: mod jar;",
          "38: #[derive(PartialEq, Clone, Debug)]",
          "39: #[cfg_attr(feature = \"serialize-rustc\", derive(RustcEncodable, RustcDecodable))]",
          "40: pub struct Cookie {",
          "41:     #[allow(missing_docs)]",
          "42:     pub name: String,",
          "43:     #[allow(missing_docs)]",
          "44:     pub value: String,",
          "45:     #[allow(missing_docs)]",
          "46:     pub expires: Option<time::Tm>,",
          "47:     #[allow(missing_docs)]",
          "48:     pub max_age: Option<u64>,",
          "49:     #[allow(missing_docs)]",
          "50:     pub domain: Option<String>,",
          "51:     #[allow(missing_docs)]",
          "52:     pub path: Option<String>,",
          "53:     #[allow(missing_docs)]",
          "54:     pub secure: bool,",
          "55:     #[allow(missing_docs)]",
          "56:     pub httponly: bool,",
          "57:     #[allow(missing_docs)]",
          "58:     pub custom: BTreeMap<String, String>,",
          "62: #[derive(Debug)]",
          "63: pub struct Error(());",
          "65: impl Cookie {",
          "77:     pub fn new(name: String, value: String) -> Cookie {",
          "79:             name: name,",
          "80:             value: value,",
          "86:             httponly: false,",
          "87:             custom: BTreeMap::new(),",
          "103:     pub fn parse(s: &str) -> Result<Cookie, Error> {",
          "104:         macro_rules! unwrap_or_skip{ ($e:expr) => (",
          "105:             match $e { Some(s) => s, None => continue, }",
          "106:         ) }",
          "108:         let mut c = Cookie::new(String::new(), String::new());",
          "109:         let mut pairs = s.trim().split(';');",
          "110:         let keyval = match pairs.next() {",
          "111:             Some(s) => s,",
          "112:             _ => {",
          "113:                 return Err(Error(()));",
          "114:             }",
          "116:         let (name, value) = try!(split(keyval));",
          "117:         c.name = name.into();",
          "118:         if c.name.is_empty() {",
          "119:             return Err(Error(()));",
          "120:         }",
          "121:         c.value = value.into();",
          "123:         for attr in pairs {",
          "124:             let (k, v) = attr_split(attr);",
          "125:             match (&k.to_ascii_lowercase()[..], v) {",
          "126:                 (\"secure\", _) => c.secure = true,",
          "127:                 (\"httponly\", _) => c.httponly = true,",
          "128:                 (\"max-age\", Some(v)) => {",
          "133:                     let max_age: i64 = unwrap_or_skip!(v.parse().ok());",
          "134:                     c.max_age = Some(if max_age < 0 {",
          "135:                         0",
          "136:                     } else {",
          "137:                         max_age as u64",
          "138:                     });",
          "139:                 },",
          "140:                 (\"domain\", Some(v)) => {",
          "141:                     if v.is_empty() {",
          "142:                         continue;",
          "143:                     }",
          "145:                     let domain = if v.chars().next() == Some('.') {",
          "146:                         &v[1..]",
          "147:                     } else {",
          "148:                         v",
          "149:                     };",
          "150:                     c.domain = Some(domain.to_ascii_lowercase());",
          "151:                 }",
          "152:                 (\"path\", Some(v)) => c.path = Some(v.to_string()),",
          "153:                 (\"expires\", Some(v)) => {",
          "157:                     let tm = time::strptime(v, \"%a, %d %b %Y %H:%M:%S %Z\").or_else(|_| {",
          "158:                         time::strptime(v, \"%A, %d-%b-%y %H:%M:%S %Z\")",
          "159:                     }).or_else(|_| {",
          "160:                         time::strptime(v, \"%a, %d-%b-%Y %H:%M:%S %Z\")",
          "161:                     }).or_else(|_| {",
          "162:                         time::strptime(v, \"%a %b %d %H:%M:%S %Y\")",
          "163:                     });",
          "164:                     let tm = unwrap_or_skip!(tm.ok());",
          "165:                     c.expires = Some(tm);",
          "166:                 }",
          "167:                 (_, Some(v)) => {c.custom.insert(k.to_string(), v.to_string());}",
          "168:                 (_, _) => {}",
          "169:             }",
          "170:         }",
          "172:         return Ok(c);",
          "174:         fn attr_split<'a>(s: &'a str) -> (&'a str, Option<&'a str>) {",
          "175:             match s.find(\"=\") {",
          "176:                 Some(pos) => {",
          "177:                     let parts = s.split_at(pos);",
          "178:                     let value = parts.1[1..].trim();",
          "179:                     (parts.0.trim(), Some(value))",
          "180:                 }",
          "181:                 None => (s.trim(), None)",
          "182:             }",
          "183:         }",
          "185:         fn split<'a>(s: &'a str) -> Result<(&'a str, &'a str), Error> {",
          "186:             macro_rules! try {",
          "187:                 ($e:expr) => (match $e {",
          "188:                     Some(s) => s,",
          "189:                     None => return Err(Error(()))",
          "190:                 })",
          "191:             }",
          "192:             let mut parts = s.trim().splitn(2, '=');",
          "193:             let first = try!(parts.next()).trim();",
          "194:             let second = try!(parts.next()).trim();",
          "195:             Ok((first, second))",
          "196:         }",
          "200:     pub fn pair(&self) -> AttrVal {",
          "201:         AttrVal(&self.name, &self.value)",
          "205: #[cfg(feature = \"serialize-serde\")]",
          "206: impl Serialize for Cookie {",
          "207:     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>",
          "208:         where S: serde::Serializer",
          "209:     {",
          "210:         serializer.serialize_str(&*self.to_string())",
          "212: }",
          "214: #[cfg(feature = \"serialize-serde\")]",
          "215: impl Deserialize for Cookie {",
          "216:     fn deserialize<D>(deserializer: &mut D) -> Result<Cookie, D::Error>",
          "217:         where D: serde::Deserializer",
          "218:     {",
          "219:         deserializer.deserialize_string(CookieVisitor)",
          "221: }",
          "222: #[cfg(feature = \"serialize-serde\")]",
          "223: struct CookieVisitor;",
          "225: #[cfg(feature = \"serialize-serde\")]",
          "226: impl serde::de::Visitor for CookieVisitor {",
          "227:     type Value = Cookie;",
          "229:     fn visit_str<E>(&mut self, v: &str) -> Result<Cookie, E>",
          "230:         where E: serde::de::Error",
          "231:     {",
          "232:         match Cookie::parse(v) {",
          "233:             Ok(cookie) => Ok(cookie),",
          "234:             Err(_) => Err(serde::de::Error::custom(\"Could not parse serialized cookie!\"))",
          "235:         }",
          "237: }",
          "240: pub struct AttrVal<'a>(pub &'a str, pub &'a str);",
          "242: impl<'a> fmt::Display for AttrVal<'a> {",
          "243:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "244:         let AttrVal(ref attr, ref val) = *self;",
          "245:         write!(f, \"{}={}\", attr, val)",
          "247: }",
          "249: impl fmt::Display for Cookie {",
          "250:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "251:         try!(AttrVal(&self.name, &self.value).fmt(f));",
          "252:         if self.httponly { try!(write!(f, \"; HttpOnly\")); }",
          "253:         if self.secure { try!(write!(f, \"; Secure\")); }",
          "255:             Some(ref s) => try!(write!(f, \"; Path={}\", s)),",
          "256:             None => {}",
          "259:             Some(ref s) => try!(write!(f, \"; Domain={}\", s)),",
          "260:             None => {}",
          "261:         }",
          "262:         match self.max_age {",
          "263:             Some(n) => try!(write!(f, \"; Max-Age={}\", n)),",
          "264:             None => {}",
          "265:         }",
          "266:         match self.expires {",
          "267:             Some(ref t) => try!(write!(f, \"; Expires={}\", t.rfc822())),",
          "268:             None => {}",
          "271:         for (k, v) in self.custom.iter() {",
          "272:             try!(write!(f, \"; {}\", AttrVal(&k, &v)));",
          "273:         }",
          "274:         Ok(())",
          "276: }",
          "278: impl FromStr for Cookie {",
          "279:     type Err = Error;",
          "280:     fn from_str(s: &str) -> Result<Cookie, Error> {",
          "281:         Cookie::parse(s)",
          "283: }",
          "285: #[cfg(test)]",
          "286: mod tests {",
          "287:     use super::Cookie;",
          "289:     #[test]",
          "290:     fn parse() {",
          "291:         assert!(Cookie::parse(\"bar\").is_err());",
          "292:         assert!(Cookie::parse(\"=bar\").is_err());",
          "293:         assert!(Cookie::parse(\" =bar\").is_err());",
          "294:         assert!(Cookie::parse(\"foo=\").is_ok());",
          "295:         let mut expected = Cookie::new(\"foo\".to_string(), \"bar\".to_string());",
          "296:         assert_eq!(Cookie::parse(\"foo=bar\").ok().unwrap(), expected);",
          "297:         assert_eq!(Cookie::parse(\"foo = bar\").ok().unwrap(), expected);",
          "298:         assert_eq!(Cookie::parse(\" foo=bar \").ok().unwrap(), expected);",
          "299:         assert_eq!(Cookie::parse(\" foo=bar ;Domain=\").ok().unwrap(), expected);",
          "300:         assert_eq!(Cookie::parse(\" foo=bar ;Domain= \").ok().unwrap(), expected);",
          "301:         assert_eq!(Cookie::parse(\" foo=bar ;Ignored\").ok().unwrap(), expected);",
          "302:         expected.httponly = true;",
          "303:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly\").ok().unwrap(), expected);",
          "304:         assert_eq!(Cookie::parse(\" foo=bar ;httponly\").ok().unwrap(), expected);",
          "305:         assert_eq!(Cookie::parse(\" foo=bar ;HTTPONLY=whatever\").ok().unwrap(), expected);",
          "306:         assert_eq!(Cookie::parse(\" foo=bar ; sekure; HTTPONLY\").ok().unwrap(), expected);",
          "307:         expected.secure = true;",
          "308:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure\").ok().unwrap(), expected);",
          "309:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure=aaaa\").ok().unwrap(), expected);",
          "310:         expected.max_age = Some(0);",
          "311:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "312:                                   Max-Age=0\").ok().unwrap(), expected);",
          "313:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "314:                                   Max-Age = 0 \").ok().unwrap(), expected);",
          "315:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "316:                                   Max-Age=-1\").ok().unwrap(), expected);",
          "317:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "318:                                   Max-Age = -1 \").ok().unwrap(), expected);",
          "319:         expected.max_age = Some(4);",
          "320:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "321:                                   Max-Age=4\").ok().unwrap(), expected);",
          "322:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "323:                                   Max-Age = 4 \").ok().unwrap(), expected);",
          "324:         expected.path = Some(\"/foo\".to_string());",
          "325:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "326:                                   Max-Age=4; Path=/foo\").ok().unwrap(), expected);",
          "327:         expected.domain = Some(\"foo.com\".to_string());",
          "328:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "329:                                   Max-Age=4; Path=/foo; \\",
          "330:                                   Domain=foo.com\").ok().unwrap(), expected);",
          "331:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "332:                                   Max-Age=4; Path=/foo; \\",
          "333:                                   Domain=FOO.COM\").ok().unwrap(), expected);",
          "334:         expected.custom.insert(\"wut\".to_string(), \"lol\".to_string());",
          "335:         assert_eq!(Cookie::parse(\" foo=bar ;HttpOnly; Secure; \\",
          "336:                                   Max-Age=4; Path=/foo; \\",
          "337:                                   Domain=foo.com; wut=lol\").ok().unwrap(), expected);",
          "339:         assert_eq!(expected.to_string(),",
          "340:                    \"foo=bar; HttpOnly; Secure; Path=/foo; Domain=foo.com; \\",
          "341:                     Max-Age=4; wut=lol\");",
          "344:     #[test]",
          "345:     fn cookie_parse_error() {",
          "346:         match Cookie::parse(\"bar\") {",
          "347:             Ok(_) => assert!(false),",
          "348:             Err(_) => assert!(true),",
          "349:         }",
          "352:     #[test]",
          "353:     fn odd_characters() {",
          "354:         let expected = Cookie::new(\"foo\".to_string(), \"b%2Fr\".to_string());",
          "355:         assert_eq!(Cookie::parse(\"foo=b%2Fr\").ok().unwrap(), expected);",
          "358:     #[test]",
          "359:     fn pair() {",
          "360:         let cookie = Cookie::new(\"foo\".to_string(), \"bar\".to_string());",
          "361:         assert_eq!(cookie.pair().to_string(), \"foo=bar\".to_string());",
          "364:     #[cfg(feature = \"serialize-serde\")]",
          "365:     #[test]",
          "366:     fn test_serialize() {",
          "367:         #[cfg(feature = \"serialize-serde\")] extern crate serde_json;",
          "369:         use super::Cookie;",
          "370:         use time;",
          "371:         use std::collections::BTreeMap;",
          "373:         let mut custom = BTreeMap::new();",
          "374:         custom.insert(\"x86\".to_string(), \"rdi\".to_string());",
          "375:         custom.insert(\"arm\".to_string(), \"x0\".to_string());",
          "376:         let original = Cookie {",
          "377:             name: \"Hello\".to_owned(),",
          "378:             value: \"World!\".to_owned(),",
          "379:             expires: Some(time::strptime(\"Sun, 23 Nov 2014 20:00:00 UTC\",",
          "380:                                          \"%a, %d %b %Y %H:%M:%S %Z\").unwrap()),",
          "381:             max_age: Some(42),",
          "382:             domain: Some(\"servo.org\".to_owned()),",
          "383:             path: Some(\"/\".to_owned()),",
          "384:             secure: true,",
          "385:             httponly: false,",
          "386:             custom: custom",
          "389:         let serialized = serde_json::to_string(&original).unwrap();",
          "391:         let roundtrip: Cookie = serde_json::from_str(&serialized).unwrap();",
          "393:         assert_eq!(original, roundtrip);",
          "396:     #[cfg(feature = \"serialize-serde\")]",
          "397:     #[test]",
          "398:     fn test_serialize_odd_characters() {",
          "399:         #[cfg(feature = \"serialize-serde\")] extern crate serde_json;",
          "401:         use super::Cookie;",
          "402:         use time;",
          "403:         use std::collections::BTreeMap;",
          "405:         let mut custom = BTreeMap::new();",
          "406:         custom.insert(\"x86\".to_string(), \"rdi\".to_string());",
          "407:         custom.insert(\"arm\".to_string(), \"x0\".to_string());",
          "408:         let original = Cookie {",
          "409:             name: \"test\".to_owned(),",
          "410:             value: \"^start/foo=bar\\\\s,name@place:[test]|hello%3Bworld\".to_owned(),",
          "411:             expires: Some(time::strptime(\"Tue, 15 Jun 2016 20:00:00 UTC\",",
          "412:                                          \"%a, %d %b %Y %H:%M:%S %Z\").unwrap()),",
          "413:             max_age: Some(42),",
          "414:             domain: Some(\"example.com\".to_owned()),",
          "415:             path: Some(\"/\".to_owned()),",
          "416:             secure: true,",
          "417:             httponly: false,",
          "418:             custom: custom",
          "419:         };",
          "421:         let serialized = serde_json::to_string(&original).unwrap();",
          "423:         let roundtrip: Cookie = serde_json::from_str(&serialized).unwrap();",
          "425:         assert_eq!(original, roundtrip);",
          "",
          "[Added Lines]",
          "57: #[cfg(feature = \"percent-encode\")]",
          "58: extern crate url;",
          "60: mod builder;",
          "61: mod jar;",
          "62: mod parse;",
          "64: use std::borrow::Cow;",
          "69: use time::{Tm, Duration};",
          "70: #[cfg(feature = \"percent-encode\")]",
          "71: use url::percent_encoding::{USERINFO_ENCODE_SET, percent_encode};",
          "73: use parse::parse_cookie;",
          "74: pub use parse::ParseError;",
          "76: pub use builder::CookieBuilder;",
          "79: #[doc(hidden)]",
          "80: #[derive(Debug, Clone)]",
          "81: pub enum CookieStr {",
          "83:     Indexed(usize, usize),",
          "85:     Concrete(Cow<'static, str>),",
          "88: impl CookieStr {",
          "90:     pub fn is_indexed(&self) -> bool {",
          "91:         match *self {",
          "92:             CookieStr::Indexed(..) => true,",
          "93:             CookieStr::Concrete(..) => false,",
          "94:         }",
          "95:     }",
          "104:     pub fn to_str<'s>(&'s self, string: Option<&'s Cow<str>>) -> &'s str {",
          "105:         if self.is_indexed() && string.is_none() {",
          "106:             panic!(\"Cannot convert indexed str to str without base string!\")",
          "107:         }",
          "109:         match *self {",
          "110:             CookieStr::Indexed(i, j) => &string.unwrap()[i..j],",
          "111:             CookieStr::Concrete(ref cstr) => &*cstr,",
          "112:         }",
          "113:     }",
          "114: }",
          "143: #[derive(Debug, Clone)]",
          "144: pub struct Cookie<'c> {",
          "147:     cookie_string: Option<Cow<'c, str>>,",
          "149:     name: CookieStr,",
          "151:     value: CookieStr,",
          "153:     expires: Option<Tm>,",
          "155:     max_age: Option<Duration>,",
          "157:     domain: Option<CookieStr>,",
          "159:     path: Option<CookieStr>,",
          "161:     secure: bool,",
          "163:     http_only: bool,",
          "164: }",
          "166: impl Cookie<'static> {",
          "177:     #[inline(always)]",
          "178:     pub fn new<N, V>(name: N, value: V) -> Cookie<'static>",
          "179:         where N: Into<Cow<'static, str>>,",
          "180:               V: Into<Cow<'static, str>>",
          "181:     {",
          "183:             cookie_string: None,",
          "184:             name: CookieStr::Concrete(name.into()),",
          "185:             value: CookieStr::Concrete(value.into()),",
          "191:             http_only: false,",
          "209:     pub fn parse_static<S>(string: S) -> Result<Self, ParseError>",
          "210:         where S: Into<Cow<'static, str>>",
          "211:     {",
          "212:         let storage = string.into();",
          "227:         let parsed_cookie = unsafe {",
          "228:             let str_ptr: *const str = &*storage;",
          "229:             Cookie::parse(&*str_ptr)?",
          "232:         Ok(Cookie { cookie_string: Some(storage), ..parsed_cookie })",
          "246:     #[inline(always)]",
          "247:     pub fn build<N, V>(name: N, value: V) -> CookieBuilder",
          "248:         where N: Into<Cow<'static, str>>,",
          "249:               V: Into<Cow<'static, str>>",
          "250:     {",
          "251:         CookieBuilder::new(name, value)",
          "255: impl<'c> Cookie<'c> {",
          "267:     #[inline]",
          "268:     pub fn parse(s: &'c str) -> Result<Cookie<'c>, ParseError> {",
          "269:         parse_cookie(s)",
          "284:     #[inline]",
          "285:     pub fn into_owned(mut self) -> Cookie<'static> {",
          "286:         self.cookie_string = match self.cookie_string {",
          "287:             Some(storage) => Some(Cow::Owned(storage.into_owned())),",
          "288:             None => None,",
          "289:         };",
          "301:         unsafe { ::std::mem::transmute(self) }",
          "314:     #[inline]",
          "315:     pub fn name(&self) -> &str {",
          "316:         self.name.to_str(self.cookie_string.as_ref())",
          "317:     }",
          "329:     #[inline]",
          "330:     pub fn value(&self) -> &str {",
          "331:         self.value.to_str(self.cookie_string.as_ref())",
          "344:     #[inline(always)]",
          "345:     pub fn name_value(&self) -> (&str, &str) {",
          "346:         (self.name(), self.value())",
          "347:     }",
          "359:     #[inline]",
          "360:     pub fn http_only(&self) -> bool {",
          "361:         self.http_only",
          "374:     #[inline]",
          "375:     pub fn secure(&self) -> bool {",
          "376:         self.secure",
          "377:     }",
          "392:     #[inline]",
          "393:     pub fn max_age(&self) -> Option<Duration> {",
          "394:         self.max_age",
          "395:     }",
          "413:     #[inline]",
          "414:     pub fn path(&self) -> Option<&str> {",
          "416:             Some(ref c) => Some(c.to_str(self.cookie_string.as_ref())),",
          "417:             None => None,",
          "419:     }",
          "434:     #[inline]",
          "435:     pub fn domain(&self) -> Option<&str> {",
          "437:             Some(ref c) => Some(c.to_str(self.cookie_string.as_ref())),",
          "438:             None => None,",
          "440:     }",
          "457:     #[inline]",
          "458:     pub fn expires(&self) -> Option<Tm> {",
          "459:         self.expires",
          "475:     #[inline(always)]",
          "476:     pub fn set_name<N: Into<Cow<'static, str>>>(&mut self, name: N) {",
          "477:         self.name = CookieStr::Concrete(name.into())",
          "493:     #[inline(always)]",
          "494:     pub fn set_value<V: Into<Cow<'static, str>>>(&mut self, value: V) {",
          "495:         self.value = CookieStr::Concrete(value.into())",
          "496:     }",
          "511:     #[inline(always)]",
          "512:     pub fn set_http_only(&mut self, value: bool) {",
          "513:         self.http_only = value;",
          "529:     #[inline(always)]",
          "530:     pub fn set_secure(&mut self, value: bool) {",
          "531:         self.secure = value;",
          "553:     #[inline(always)]",
          "554:     pub fn set_max_age(&mut self, value: Duration) {",
          "555:         self.max_age = Some(value);",
          "571:     #[inline(always)]",
          "572:     pub fn set_path<P: Into<Cow<'static, str>>>(&mut self, path: P) {",
          "573:         self.path = Some(CookieStr::Concrete(path.into()));",
          "589:     #[inline(always)]",
          "590:     pub fn set_domain<D: Into<Cow<'static, str>>>(&mut self, domain: D) {",
          "591:         self.domain = Some(CookieStr::Concrete(domain.into()));",
          "592:     }",
          "615:     #[inline(always)]",
          "616:     pub fn set_expires(&mut self, time: Tm) {",
          "617:         self.expires = Some(time);",
          "618:     }",
          "619: }",
          "621: impl<'a, 'b> PartialEq<Cookie<'b>> for Cookie<'a> {",
          "622:     fn eq(&self, other: &Cookie<'b>) -> bool {",
          "623:         let so_far_so_good = self.name() == other.name()",
          "624:             && self.value() == other.value()",
          "625:             && self.http_only() == other.http_only()",
          "626:             && self.secure() == other.secure()",
          "627:             && self.max_age() == other.max_age()",
          "628:             && self.expires() == other.expires();",
          "630:         if !so_far_so_good {",
          "631:             return false;",
          "632:         }",
          "634:         match (self.path(), other.path()) {",
          "635:             (Some(a), Some(b)) if a.eq_ignore_ascii_case(b) => {}",
          "636:             (None, None) => {}",
          "637:             _ => return false,",
          "638:         };",
          "640:         match (self.domain(), other.domain()) {",
          "641:             (Some(a), Some(b)) if a.eq_ignore_ascii_case(b) => {}",
          "642:             (None, None) => {}",
          "643:             _ => return false,",
          "646:         true",
          "647:     }",
          "648: }",
          "650: impl<'c> fmt::Display for Cookie<'c> {",
          "651:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "653:         #[cfg(feature = \"percent-encode\")]",
          "654:         let name = percent_encode(self.name().as_bytes(), USERINFO_ENCODE_SET);",
          "655:         #[cfg(feature = \"percent-encode\")]",
          "656:         let value = percent_encode(self.value().as_bytes(), USERINFO_ENCODE_SET);",
          "659:         #[cfg(not(feature = \"percent-encode\"))]",
          "660:         let (name, value) = self.name_value();",
          "663:         write!(f, \"{}={}\", name, value)?;",
          "665:         if self.http_only() {",
          "666:             write!(f, \"; HttpOnly\")?;",
          "667:         }",
          "669:         if self.secure() {",
          "670:             write!(f, \"; Secure\")?;",
          "671:         }",
          "673:         if let Some(path) = self.path() {",
          "674:             write!(f, \"; Path={}\", path)?;",
          "675:         }",
          "677:         if let Some(domain) = self.domain() {",
          "678:             write!(f, \"; Domain={}\", domain)?;",
          "679:         }",
          "681:         if let Some(max_age) = self.max_age() {",
          "682:             write!(f, \"; Max-Age={}\", max_age.num_seconds())?;",
          "683:         }",
          "685:         if let Some(time) = self.expires() {",
          "686:             write!(f, \"; Expires={}\", time.rfc822())?;",
          "687:         }",
          "689:         Ok(())",
          "691: }",
          "693: impl FromStr for Cookie<'static> {",
          "694:     type Err = ParseError;",
          "696:     fn from_str(s: &str) -> Result<Cookie<'static>, ParseError> {",
          "697:         Cookie::parse(s).map(|c| c.into_owned())",
          "698:     }",
          "699: }",
          "701: #[cfg(test)]",
          "702: mod tests {",
          "703:     use ::Cookie;",
          "704:     use ::time::{strptime, Duration};",
          "706:     #[test]",
          "707:     fn format() {",
          "708:         let cookie = Cookie::new(\"foo\", \"bar\");",
          "709:         assert_eq!(&cookie.to_string(), \"foo=bar\");",
          "711:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "712:             .http_only(true).finish();",
          "713:         assert_eq!(&cookie.to_string(), \"foo=bar; HttpOnly\");",
          "715:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "716:             .max_age(Duration::seconds(10)).finish();",
          "717:         assert_eq!(&cookie.to_string(), \"foo=bar; Max-Age=10\");",
          "719:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "720:             .secure(true).finish();",
          "721:         assert_eq!(&cookie.to_string(), \"foo=bar; Secure\");",
          "723:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "724:             .path(\"/\").finish();",
          "725:         assert_eq!(&cookie.to_string(), \"foo=bar; Path=/\");",
          "727:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "728:             .domain(\"www.rust-lang.org\").finish();",
          "729:         assert_eq!(&cookie.to_string(), \"foo=bar; Domain=www.rust-lang.org\");",
          "731:         let time_str = \"Wed, 21 Oct 2015 07:28:00 GMT\";",
          "732:         let expires = strptime(time_str, \"%a, %d %b %Y %H:%M:%S %Z\").unwrap();",
          "733:         let cookie = Cookie::build(\"foo\", \"bar\")",
          "734:             .expires(expires).finish();",
          "735:         assert_eq!(&cookie.to_string(),",
          "736:                    \"foo=bar; Expires=Wed, 21 Oct 2015 07:28:00 GMT\");",
          "737:     }",
          "739:     #[test]",
          "740:     #[cfg(feature = \"percent-encode\")]",
          "741:     fn format_encoded() {",
          "742:         let cookie = Cookie::build(\"foo !?=\", \"bar;; a\").finish();",
          "743:         let cookie_str = cookie.to_string();",
          "744:         assert_eq!(&cookie_str, \"foo%20!%3F%3D=bar%3B%3B%20a\");",
          "746:         let cookie = Cookie::parse_static(cookie_str).unwrap();",
          "747:         assert_eq!(cookie.name_value(), (\"foo !?=\", \"bar;; a\"));",
          "",
          "---------------"
        ],
        "src/parse.rs||src/parse.rs": [
          "File: src/parse.rs -> src/parse.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use std::borrow::Cow;",
          "2: use std::error::Error;",
          "3: use std::ascii::AsciiExt;",
          "4: use std::str::Utf8Error;",
          "5: use std::fmt;",
          "6: use std::convert::From;",
          "8: use time::{self, Duration};",
          "9: #[cfg(feature = \"percent-encode\")]",
          "10: use url::percent_encoding::percent_decode;",
          "12: use ::{Cookie, CookieStr};",
          "15: #[derive(Debug, PartialEq, Eq, Clone, Copy)]",
          "16: pub enum ParseError {",
          "18:     MissingPair,",
          "20:     EmptyName,",
          "22:     Utf8Error(Utf8Error),",
          "24:     Internal,",
          "25: }",
          "27: impl ParseError {",
          "28:     pub fn as_str(&self) -> &'static str {",
          "29:         match *self {",
          "30:             ParseError::MissingPair => \"The cookie is missing a name/value pair.\",",
          "31:             ParseError::EmptyName => \"The cookie's name is empty.\",",
          "32:             ParseError::Utf8Error(_) => {",
          "33:                 \"Decoding the cookie's name or value resulted in invalid UTF-8.\"",
          "34:             }",
          "35:             ParseError::Internal => {",
          "36:                 \"There was an internal error parsing the cookie. Please report this.\"",
          "37:             }",
          "38:         }",
          "39:     }",
          "40: }",
          "42: impl fmt::Display for ParseError {",
          "43:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "44:         write!(f, \"{}\", self.as_str())",
          "45:     }",
          "46: }",
          "48: impl From<Utf8Error> for ParseError {",
          "49:     fn from(error: Utf8Error) -> ParseError {",
          "50:         ParseError::Utf8Error(error)",
          "51:     }",
          "52: }",
          "54: impl Error for ParseError {",
          "55:     fn description(&self) -> &str {",
          "56:         self.as_str()",
          "57:     }",
          "58: }",
          "60: fn indexes_of(needle: &str, haystack: &str) -> Option<(usize, usize)> {",
          "61:     let haystack_start = haystack.as_ptr() as usize;",
          "62:     let needle_start = needle.as_ptr() as usize;",
          "64:     if needle_start < haystack_start {",
          "65:         return None;",
          "66:     }",
          "68:     if (needle_start + needle.len()) > (haystack_start + haystack.len()) {",
          "69:         return None;",
          "70:     }",
          "72:     let start = needle_start - haystack_start;",
          "73:     let end = start + needle.len();",
          "74:     Some((start, end))",
          "75: }",
          "77: #[cfg(not(feature = \"percent-encode\"))]",
          "78: fn name_val(name: &str, val: &str, s: &str) -> Result<(CookieStr, CookieStr), ParseError> {",
          "79:     let name_indexes = indexes_of(name, s).expect(\"name sub\");",
          "80:     let value_indexes = indexes_of(val, s).expect(\"value sub\");",
          "81:     let name = CookieStr::Indexed(name_indexes.0, name_indexes.1);",
          "82:     let val = CookieStr::Indexed(value_indexes.0, value_indexes.1);",
          "83:     Ok((name, val))",
          "84: }",
          "86: #[cfg(feature = \"percent-encode\")]",
          "87: fn name_val(name: &str, val: &str, _: &str) -> Result<(CookieStr, CookieStr), ParseError> {",
          "88:     let decoded_name = percent_decode(name.as_bytes()).decode_utf8()?;",
          "89:     let decoded_value = percent_decode(val.as_bytes()).decode_utf8()?;",
          "90:     let name = CookieStr::Concrete(Cow::Owned(decoded_name.into_owned()));",
          "91:     let val = CookieStr::Concrete(Cow::Owned(decoded_value.into_owned()));",
          "93:     Ok((name, val))",
          "94: }",
          "96: pub fn parse_cookie(s: &str) -> Result<Cookie, ParseError> {",
          "97:     let mut attributes = s.split(';');",
          "98:     let key_value = match attributes.next() {",
          "99:         Some(s) => s,",
          "100:         _ => return Err(ParseError::Internal),",
          "101:     };",
          "104:     let mut splits = key_value.split('=');",
          "105:     let (name, value) = match (splits.next(), splits.next()) {",
          "106:         (Some(name), Some(val)) => (name.trim(), val.trim()),",
          "107:         (Some(_), None) => return Err(ParseError::MissingPair),",
          "108:         _ => return Err(ParseError::Internal),",
          "109:     };",
          "111:     if name.is_empty() {",
          "112:         return Err(ParseError::EmptyName);",
          "113:     }",
          "117:     let (name, value) = name_val(name, value, s)?;",
          "118:     let mut cookie = Cookie {",
          "119:         cookie_string: Some(Cow::Borrowed(s)),",
          "120:         name: name,",
          "121:         value: value,",
          "122:         expires: None,",
          "123:         max_age: None,",
          "124:         domain: None,",
          "125:         path: None,",
          "126:         secure: false,",
          "127:         http_only: false,",
          "128:     };",
          "130:     for attr in attributes {",
          "131:         let (key, value) = match attr.find('=') {",
          "132:             Some(i) => (attr[..i].trim(), Some(attr[(i + 1)..].trim())),",
          "133:             None => (attr.trim(), None),",
          "134:         };",
          "136:         match (&*key.to_ascii_lowercase(), value) {",
          "137:             (\"secure\", _) => cookie.secure = true,",
          "138:             (\"httponly\", _) => cookie.http_only = true,",
          "139:             (\"max-age\", Some(v)) => {",
          "143:                 cookie.max_age = match v.parse() {",
          "144:                     Ok(val) if val <= 0 => Some(Duration::zero()),",
          "145:                     Ok(val) => Some(Duration::seconds(val)),",
          "146:                     Err(_) => continue,",
          "147:                 };",
          "148:             }",
          "149:             (\"domain\", Some(v)) if !v.is_empty() => {",
          "150:                 let domain = match v.starts_with('.') {",
          "151:                     true => &v[1..],",
          "152:                     false => v,",
          "153:                 };",
          "155:                 let (i, j) = indexes_of(domain, s).expect(\"domain sub\");",
          "156:                 cookie.domain = Some(CookieStr::Indexed(i, j));",
          "157:             }",
          "158:             (\"path\", Some(v)) => {",
          "159:                 let (i, j) = indexes_of(v, s).expect(\"path sub\");",
          "160:                 cookie.path = Some(CookieStr::Indexed(i, j));",
          "161:             }",
          "162:             (\"expires\", Some(v)) => {",
          "166:                 let tm = time::strptime(v, \"%a, %d %b %Y %H:%M:%S %Z\")",
          "167:                     .or_else(|_| time::strptime(v, \"%A, %d-%b-%y %H:%M:%S %Z\"))",
          "168:                     .or_else(|_| time::strptime(v, \"%a, %d-%b-%Y %H:%M:%S %Z\"))",
          "169:                     .or_else(|_| time::strptime(v, \"%a %b %d %H:%M:%S %Y\"));",
          "171:                 if let Some(time) = tm.ok() {",
          "172:                     cookie.expires = Some(time)",
          "173:                 }",
          "174:             }",
          "175:             _ => {",
          "180:             }",
          "181:         }",
          "182:     }",
          "185:     Ok(cookie)",
          "186: }",
          "188: #[cfg(test)]",
          "189: mod tests {",
          "190:     use ::Cookie;",
          "191:     use ::time::{strptime, Duration};",
          "193:     macro_rules! assert_eq_parse {",
          "194:         ($string:expr, $expected:expr) => (",
          "195:             let cookie = match Cookie::parse($string) {",
          "196:                 Ok(cookie) => cookie,",
          "197:                 Err(e) => panic!(\"Failed to parse {:?}: {:?}\", $string, e)",
          "198:             };",
          "200:             assert_eq!(cookie, $expected);",
          "201:         )",
          "202:     }",
          "204:     macro_rules! assert_ne_parse {",
          "205:         ($string:expr, $expected:expr) => (",
          "206:             let cookie = match Cookie::parse($string) {",
          "207:                 Ok(cookie) => cookie,",
          "208:                 Err(e) => panic!(\"Failed to parse {:?}: {:?}\", $string, e)",
          "209:             };",
          "211:             assert_ne!(cookie, $expected);",
          "212:         )",
          "213:     }",
          "215:     #[test]",
          "216:     fn parse() {",
          "217:         assert!(Cookie::parse(\"bar\").is_err());",
          "218:         assert!(Cookie::parse(\"=bar\").is_err());",
          "219:         assert!(Cookie::parse(\" =bar\").is_err());",
          "220:         assert!(Cookie::parse(\"foo=\").is_ok());",
          "222:         let mut expected = Cookie::build(\"foo\", \"bar\").finish();",
          "223:         assert_eq_parse!(\"foo=bar\", expected);",
          "224:         assert_eq_parse!(\"foo = bar\", expected);",
          "225:         assert_eq_parse!(\" foo=bar \", expected);",
          "226:         assert_eq_parse!(\" foo=bar ;Domain=\", expected);",
          "227:         assert_eq_parse!(\" foo=bar ;Domain= \", expected);",
          "228:         assert_eq_parse!(\" foo=bar ;Ignored\", expected);",
          "230:         let mut unexpected = Cookie::build(\"foo\", \"bar\").http_only(false).finish();",
          "231:         assert_ne_parse!(\" foo=bar ;HttpOnly\", unexpected);",
          "232:         assert_ne_parse!(\" foo=bar; httponly\", unexpected);",
          "234:         expected.set_http_only(true);",
          "235:         assert_eq_parse!(\" foo=bar ;HttpOnly\", expected);",
          "236:         assert_eq_parse!(\" foo=bar ;httponly\", expected);",
          "237:         assert_eq_parse!(\" foo=bar ;HTTPONLY=whatever\", expected);",
          "238:         assert_eq_parse!(\" foo=bar ; sekure; HTTPONLY\", expected);",
          "240:         expected.set_secure(true);",
          "241:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure\", expected);",
          "242:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure=aaaa\", expected);",
          "244:         unexpected.set_http_only(true);",
          "245:         unexpected.set_secure(true);",
          "246:         assert_ne_parse!(\" foo=bar ;HttpOnly; skeure\", unexpected);",
          "247:         assert_ne_parse!(\" foo=bar ;HttpOnly; =secure\", unexpected);",
          "248:         assert_ne_parse!(\" foo=bar ;HttpOnly;\", unexpected);",
          "250:         unexpected.set_secure(false);",
          "251:         assert_ne_parse!(\" foo=bar ;HttpOnly; secure\", unexpected);",
          "252:         assert_ne_parse!(\" foo=bar ;HttpOnly; secure\", unexpected);",
          "253:         assert_ne_parse!(\" foo=bar ;HttpOnly; secure\", unexpected);",
          "255:         expected.set_max_age(Duration::zero());",
          "256:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=0\", expected);",
          "257:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = 0 \", expected);",
          "258:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=-1\", expected);",
          "259:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = -1 \", expected);",
          "261:         expected.set_max_age(Duration::minutes(1));",
          "262:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=60\", expected);",
          "263:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age =   60 \", expected);",
          "265:         expected.set_max_age(Duration::seconds(4));",
          "266:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4\", expected);",
          "267:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = 4 \", expected);",
          "269:         unexpected.set_secure(true);",
          "270:         unexpected.set_max_age(Duration::minutes(1));",
          "271:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=122\", unexpected);",
          "272:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = 38 \", unexpected);",
          "273:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=51\", unexpected);",
          "274:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = -1 \", unexpected);",
          "275:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age = 0\", unexpected);",
          "277:         expected.set_path(\"/\");",
          "278:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4; Path=/\", expected);",
          "279:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4;Path=/\", expected);",
          "281:         expected.set_path(\"/foo\");",
          "282:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4; Path=/foo\", expected);",
          "283:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4;Path=/foo\", expected);",
          "284:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4;path=/foo\", expected);",
          "285:         assert_eq_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4;path = /foo\", expected);",
          "287:         unexpected.set_max_age(Duration::seconds(4));",
          "288:         unexpected.set_path(\"/bar\");",
          "289:         assert_ne_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4; Path=/foo\", unexpected);",
          "290:         assert_ne_parse!(\"foo=bar;HttpOnly; Secure; Max-Age=4;Path=/baz\", unexpected);",
          "292:         expected.set_domain(\"www.foo.com\");",
          "293:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "294:             Domain=www.foo.com\", expected);",
          "296:         expected.set_domain(\"foo.com\");",
          "297:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "298:             Domain=foo.com\", expected);",
          "299:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "300:             Domain=FOO.COM\", expected);",
          "302:         unexpected.set_path(\"/foo\");",
          "303:         unexpected.set_domain(\"bar.com\");",
          "304:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "305:             Domain=foo.com\", unexpected);",
          "306:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "307:             Domain=FOO.COM\", unexpected);",
          "309:         let time_str = \"Wed, 21 Oct 2015 07:28:00 GMT\";",
          "310:         let expires = strptime(time_str, \"%a, %d %b %Y %H:%M:%S %Z\").unwrap();",
          "311:         expected.set_expires(expires);",
          "312:         assert_eq_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "313:             Domain=foo.com; Expires=Wed, 21 Oct 2015 07:28:00 GMT\", expected);",
          "315:         unexpected.set_domain(\"foo.com\");",
          "316:         let bad_expires = strptime(time_str, \"%a, %d %b %Y %H:%S:%M %Z\").unwrap();",
          "317:         expected.set_expires(bad_expires);",
          "318:         assert_ne_parse!(\" foo=bar ;HttpOnly; Secure; Max-Age=4; Path=/foo; \\",
          "319:             Domain=foo.com; Expires=Wed, 21 Oct 2015 07:28:00 GMT\", unexpected);",
          "320:     }",
          "322:     #[test]",
          "323:     #[cfg(not(feature = \"percent-encode\"))]",
          "324:     fn odd_characters() {",
          "325:         let expected = Cookie::new(\"foo\", \"b%2Fr\");",
          "326:         assert_eq_parse!(\"foo=b%2Fr\", expected);",
          "327:     }",
          "329:     #[test]",
          "330:     #[cfg(feature = \"percent-encode\")]",
          "331:     fn odd_characters() {",
          "332:         let expected = Cookie::new(\"foo\", \"b/r\");",
          "333:         assert_eq_parse!(\"foo=b%2Fr\", expected);",
          "334:     }",
          "335: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
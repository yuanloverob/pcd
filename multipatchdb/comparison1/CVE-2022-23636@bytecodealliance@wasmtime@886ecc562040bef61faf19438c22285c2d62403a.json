{
  "cve_id": "CVE-2022-23636",
  "cve_desc": "Wasmtime is an open source runtime for WebAssembly & WASI. Prior to versions 0.34.1 and 0.33.1, there exists a bug in the pooling instance allocator in Wasmtime's runtime where a failure to instantiate an instance for a module that defines an `externref` global will result in an invalid drop of a `VMExternRef` via an uninitialized pointer. A number of conditions listed in the GitHub Security Advisory must be true in order for an instance to be vulnerable to this issue. Maintainers believe that the effective impact of this bug is relatively small because the usage of `externref` is still uncommon and without a resource limiter configured on the `Store`, which is not the default configuration, it is only possible to trigger the bug from an error returned by `mprotect` or `VirtualAlloc`. Note that on Linux with the `uffd` feature enabled, it is only possible to trigger the bug from a resource limiter as the call to `mprotect` is skipped. The bug has been fixed in 0.34.1 and 0.33.1 and users are encouraged to upgrade as soon as possible. If it is not possible to upgrade to version 0.34.1 or 0.33.1 of the `wasmtime` crate, it is recommend that support for the reference types proposal be disabled by passing `false` to `Config::wasm_reference_types`. Doing so will prevent modules that use `externref` from being loaded entirely.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "886ecc562040bef61faf19438c22285c2d62403a",
  "patch_info": {
    "commit_hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/886ecc562040bef61faf19438c22285c2d62403a",
    "files": [
      "crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs",
      "tests/all/pooling_allocator.rs"
    ],
    "message": "Merge pull request from GHSA-88xq-w8cq-xfg7\n\nThis commit fixes the drop of an uninitialized `VMExternRef` for an `externref`\nglobal in an instance that failed to be allocated by the pooling instance\nallocator.\n\nThe following engine configuration (via `Config`) is required to be impacted by\nthis bug:\n\n* support for the reference types proposal must be enabled (this is the\n  default for `Config`).\n* a pooling allocation strategy must be configured via\n  `Config::allocation_strategy`, which is not the default allocation strategy.\n\nA module must be instantiated with the following characteristics:\n\n* The module defines at least one table or memory.\n* The module defines at least one `externref` global.\n\nDuring instantiation, one of the following must occur to cause the\ninstantiation to fail:\n\n* a call to `mprotect` or `VirtualAlloc` fails (e.g. out-of-memory conditions).\n* a resource limiter was configured in the associated Store (via `Store::limiter`\n  or `Store::limiter_async`) and the limiter returns false from the initial call\n  to grow_memory or grow_table.\n\nThis results in a partially-initialized instance being dropped and that attempts\nto drop the uninitialized `VMExternRef` representing the defined `externref` global.\n\nThe fix is to track whether or not the `VMContext` of the instance has been fully\ninitialized and skip the dropping of globals if not.",
    "before_after_code_files": [
      "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
      "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
    ]
  },
  "patch_diff": {
    "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
      "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "93:     host_state: Box<dyn Any + Send + Sync>,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "97:     vmctx_initialized: bool,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "119:             dropped_data: EntitySet::with_capacity(module.passive_data_map.len()),",
      "120:             host_state,",
      "121:             wasm_data,",
      "122:             vmctx: VMContext {",
      "123:                 _marker: std::marker::PhantomPinned,",
      "124:             },",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "126:             vmctx_initialized: false,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "733:     }",
      "735:     fn drop_globals(&mut self) {",
      "736:         for (idx, global) in self.module.globals.iter() {",
      "737:             let idx = match self.module.defined_global_index(idx) {",
      "738:                 Some(idx) => idx,",
      "739:                 None => continue,",
      "740:             };",
      "741:             match global.wasm_ty {",
      "743:                 WasmType::ExternRef => {}",
      "744:                 _ => continue,",
      "745:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "742:         if !self.vmctx_initialized {",
      "743:             return;",
      "744:         }",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
      "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "475: }",
      "477: unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationRequest) {",
      "478:     if let Some(store) = req.store.as_raw() {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "478:     assert!(!instance.vmctx_initialized);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "572:     initialize_vmcontext_globals(instance);",
      "573: }",
      "575: unsafe fn initialize_vmcontext_globals(instance: &Instance) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "577:     instance.vmctx_initialized = true;",
      "",
      "---------------"
    ],
    "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
      "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "512:     Ok(())",
      "513: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "515: #[test]",
      "516: fn drop_externref_global_during_module_init() -> Result<()> {",
      "517:     struct Limiter;",
      "519:     impl ResourceLimiter for Limiter {",
      "520:         fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {",
      "521:             false",
      "522:         }",
      "524:         fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {",
      "525:             false",
      "526:         }",
      "527:     }",
      "529:     let mut config = Config::new();",
      "530:     config.wasm_reference_types(true);",
      "531:     config.allocation_strategy(InstanceAllocationStrategy::Pooling {",
      "532:         strategy: PoolingAllocationStrategy::NextAvailable,",
      "533:         module_limits: Default::default(),",
      "534:         instance_limits: InstanceLimits { count: 1 },",
      "535:     });",
      "537:     let engine = Engine::new(&config)?;",
      "539:     let module = Module::new(",
      "540:         &engine,",
      "541:         r#\"",
      "542:             (module",
      "543:                 (global i32 (i32.const 1))",
      "544:                 (global i32 (i32.const 2))",
      "545:                 (global i32 (i32.const 3))",
      "546:                 (global i32 (i32.const 4))",
      "547:                 (global i32 (i32.const 5))",
      "548:             )",
      "549:         \"#,",
      "550:     )?;",
      "552:     let mut store = Store::new(&engine, Limiter);",
      "553:     drop(Instance::new(&mut store, &module, &[])?);",
      "554:     drop(store);",
      "556:     let module = Module::new(",
      "557:         &engine,",
      "558:         r#\"",
      "559:             (module",
      "560:                 (memory 1)",
      "561:                 (global (mut externref) (ref.null extern))",
      "562:             )",
      "563:         \"#,",
      "564:     )?;",
      "566:     let mut store = Store::new(&engine, Limiter);",
      "567:     store.limiter(|s| s);",
      "568:     assert!(Instance::new(&mut store, &module, &[]).is_err());",
      "570:     Ok(())",
      "571: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7c678a663184750ec2b57751cbbca451ad0f2106",
      "candidate_info": {
        "commit_hash": "7c678a663184750ec2b57751cbbca451ad0f2106",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/7c678a663184750ec2b57751cbbca451ad0f2106",
        "files": [
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Merge pull request from GHSA-88xq-w8cq-xfg7\n\nThis commit fixes the drop of an uninitialized `VMExternRef` for an `externref`\nglobal in an instance that failed to be allocated by the pooling instance\nallocator.\n\nThe following engine configuration (via `Config`) is required to be impacted by\nthis bug:\n\n* support for the reference types proposal must be enabled (this is the\n  default for `Config`).\n* a pooling allocation strategy must be configured via\n  `Config::allocation_strategy`, which is not the default allocation strategy.\n\nA module must be instantiated with the following characteristics:\n\n* The module defines at least one table or memory.\n* The module defines at least one `externref` global.\n\nDuring instantiation, one of the following must occur to cause the\ninstantiation to fail:\n\n* a call to `mprotect` or `VirtualAlloc` fails (e.g. out-of-memory conditions).\n* a resource limiter was configured in the associated Store (via `Store::limiter`\n  or `Store::limiter_async`) and the limiter returns false from the initial call\n  to grow_memory or grow_table.\n\nThis results in a partially-initialized instance being dropped and that attempts\nto drop the uninitialized `VMExternRef` representing the defined `externref` global.\n\nThe fix is to track whether or not the `VMContext` of the instance has been fully\ninitialized and skip the dropping of globals if not.",
        "before_after_code_files": [
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:     host_state: Box<dyn Any + Send + Sync>,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93:     vmctx_initialized: bool,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "698:     }",
          "700:     fn drop_globals(&mut self) {",
          "701:         for (idx, global) in self.module.globals.iter() {",
          "702:             let idx = match self.module.defined_global_index(idx) {",
          "703:                 Some(idx) => idx,",
          "704:                 None => continue,",
          "705:             };",
          "706:             match global.wasm_ty {",
          "708:                 WasmType::ExternRef => {}",
          "709:                 _ => continue,",
          "710:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "706:         if !self.vmctx_initialized {",
          "707:             return;",
          "708:         }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "461: }",
          "463: unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationRequest) {",
          "464:     if let Some(store) = req.store.as_raw() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "464:     assert!(!instance.vmctx_initialized);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "559:     initialize_vmcontext_globals(instance);",
          "560: }",
          "562: unsafe fn initialize_vmcontext_globals(instance: &Instance) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "564:     instance.vmctx_initialized = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "699:                 dropped_data: EntitySet::with_capacity(req.module.passive_data_map.len()),",
          "700:                 host_state,",
          "701:                 wasm_data: &*req.wasm_data,",
          "702:                 vmctx: VMContext {",
          "703:                     _marker: marker::PhantomPinned,",
          "704:                 },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "707:                 vmctx_initialized: false,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "364:                     dropped_data: EntitySet::new(),",
          "365:                     host_state: Box::new(()),",
          "366:                     wasm_data: &[],",
          "367:                     vmctx: VMContext {",
          "368:                         _marker: marker::PhantomPinned,",
          "369:                     },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "367:                     vmctx_initialized: false,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "497:         instance.module = self.empty_module.clone();",
          "498:         instance.offsets = VMOffsets::new(HostPtr, &self.empty_module);",
          "499:         instance.wasm_data = &[];",
          "501:         self.free_list.lock().unwrap().push(index);",
          "502:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "501:         instance.vmctx_initialized = false;",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "512:     Ok(())",
          "513: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "515: #[test]",
          "516: fn drop_externref_global_during_module_init() -> Result<()> {",
          "517:     struct Limiter;",
          "519:     impl ResourceLimiter for Limiter {",
          "520:         fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {",
          "521:             false",
          "522:         }",
          "524:         fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {",
          "525:             false",
          "526:         }",
          "527:     }",
          "529:     let mut config = Config::new();",
          "530:     config.wasm_reference_types(true);",
          "531:     config.allocation_strategy(InstanceAllocationStrategy::Pooling {",
          "532:         strategy: PoolingAllocationStrategy::NextAvailable,",
          "533:         module_limits: Default::default(),",
          "534:         instance_limits: InstanceLimits { count: 1 },",
          "535:     });",
          "537:     let engine = Engine::new(&config)?;",
          "539:     let module = Module::new(",
          "540:         &engine,",
          "541:         r#\"",
          "542:             (module",
          "543:                 (global i32 (i32.const 1))",
          "544:                 (global i32 (i32.const 2))",
          "545:                 (global i32 (i32.const 3))",
          "546:                 (global i32 (i32.const 4))",
          "547:                 (global i32 (i32.const 5))",
          "548:             )",
          "549:         \"#,",
          "550:     )?;",
          "552:     let mut store = Store::new(&engine, Limiter);",
          "553:     drop(Instance::new(&mut store, &module, &[])?);",
          "554:     drop(store);",
          "556:     let module = Module::new(",
          "557:         &engine,",
          "558:         r#\"",
          "559:             (module",
          "560:                 (memory 1)",
          "561:                 (global (mut externref) (ref.null extern))",
          "562:             )",
          "563:         \"#,",
          "564:     )?;",
          "566:     let mut store = Store::new(&engine, Limiter);",
          "567:     store.limiter(|s| s);",
          "568:     assert!(Instance::new(&mut store, &module, &[]).is_err());",
          "570:     Ok(())",
          "571: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef17a36852da61857d533d657f4c3006adbfd0cb",
      "candidate_info": {
        "commit_hash": "ef17a36852da61857d533d657f4c3006adbfd0cb",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/ef17a36852da61857d533d657f4c3006adbfd0cb",
        "files": [
          "RELEASES.md",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Port fix for `CVE-2022-23636` to `main`. (#3818)\n\n* Port fix for `CVE-2022-23636` to `main`.\n\nThis commit ports the fix for `CVE-2022-23636` to `main`, but performs a\nrefactoring that makes it unnecessary for the instance itself to track if it\nhas been initialized; such a change was not targeted enough for a security\npatch.\n\nThe pooling allocator will now only initialize an instance if all of its\nassociated resource creation succeeds. If the resource creation fails, no\ninstance is dropped as none was initialized.\n\nAlso updates `RELEASES.md` to include the related patch releases.\n\n* Add `Instance::new_at` to fully initialize an instance.\n\nAdded `Instance::new_at` to fully initialize an instance at a given address.\n\nThis will hopefully prevent the possibility that an `Instance` structure\ndoesn't have an initialized `VMContext` when it is dropped.",
        "before_after_code_files": [
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: use crate::table::{Table, TableElement, TableElementType};",
          "9: use crate::traphandlers::Trap;",
          "10: use crate::vmcontext::{",
          "13: };",
          "15: use anyhow::Error;",
          "16: use memoffset::offset_of;",
          "17: use more_asserts::assert_lt;",
          "",
          "[Removed Lines]",
          "11:     VMCallerCheckedAnyfunc, VMContext, VMFunctionImport, VMGlobalDefinition, VMGlobalImport,",
          "12:     VMInterrupts, VMMemoryDefinition, VMMemoryImport, VMTableDefinition, VMTableImport,",
          "14: use crate::{ExportFunction, ExportGlobal, ExportMemory, ExportTable, ModuleRuntimeInfo, Store};",
          "",
          "[Added Lines]",
          "11:     VMBuiltinFunctionsArray, VMCallerCheckedAnyfunc, VMContext, VMFunctionImport,",
          "12:     VMGlobalDefinition, VMGlobalImport, VMInterrupts, VMMemoryDefinition, VMMemoryImport,",
          "13:     VMTableDefinition, VMTableImport,",
          "14: };",
          "15: use crate::{",
          "16:     ExportFunction, ExportGlobal, ExportMemory, ExportTable, Imports, ModuleRuntimeInfo, Store,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: use std::sync::atomic::AtomicU64;",
          "25: use std::sync::Arc;",
          "26: use std::{mem, ptr, slice};",
          "28: use wasmtime_environ::{",
          "29:     packed_option::ReservedValue, DataIndex, DefinedGlobalIndex, DefinedMemoryIndex,",
          "30:     DefinedTableIndex, ElemIndex, EntityIndex, EntityRef, EntitySet, FuncIndex, GlobalIndex,",
          "31:     HostPtr, MemoryIndex, Module, PrimaryMap, TableIndex, TrapCode, VMOffsets, WasmType,",
          "32: };",
          "34: mod allocator;",
          "",
          "[Removed Lines]",
          "27: use wasmtime_environ::TableInitialization;",
          "",
          "[Added Lines]",
          "35: use wasmtime_environ::{GlobalInit, TableInitialization};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97: #[allow(clippy::cast_ptr_alignment)]",
          "98: impl Instance {",
          "102:         memories: PrimaryMap<DefinedMemoryIndex, Memory>,",
          "103:         tables: PrimaryMap<DefinedTableIndex, Table>,",
          "108:         let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());",
          "109:         let dropped_data = EntitySet::with_capacity(module.passive_data_map.len());",
          "120:             },",
          "122:     }",
          "",
          "[Removed Lines]",
          "100:     pub(crate) fn create_raw(",
          "101:         runtime_info: Arc<dyn ModuleRuntimeInfo>,",
          "104:         host_state: Box<dyn Any + Send + Sync>,",
          "105:     ) -> Instance {",
          "106:         let module = runtime_info.module();",
          "107:         let offsets = VMOffsets::new(HostPtr, &module);",
          "110:         Instance {",
          "111:             runtime_info,",
          "112:             offsets,",
          "113:             memories,",
          "114:             tables,",
          "115:             dropped_elements,",
          "116:             dropped_data,",
          "117:             host_state,",
          "118:             vmctx: VMContext {",
          "119:                 _marker: std::marker::PhantomPinned,",
          "121:         }",
          "",
          "[Added Lines]",
          "106:     unsafe fn new_at(",
          "107:         ptr: *mut Instance,",
          "108:         alloc_size: usize,",
          "109:         offsets: VMOffsets<HostPtr>,",
          "110:         req: InstanceAllocationRequest,",
          "113:     ) {",
          "115:         assert!(alloc_size >= Self::alloc_layout(&offsets).size());",
          "117:         let module = req.runtime_info.module();",
          "121:         ptr::write(",
          "122:             ptr,",
          "123:             Instance {",
          "124:                 runtime_info: req.runtime_info.clone(),",
          "125:                 offsets,",
          "126:                 memories,",
          "127:                 tables,",
          "128:                 dropped_elements,",
          "129:                 dropped_data,",
          "130:                 host_state: req.host_state,",
          "131:                 vmctx: VMContext {",
          "132:                     _marker: std::marker::PhantomPinned,",
          "133:                 },",
          "135:         );",
          "137:         (*ptr).initialize_vmctx(module, req.store, req.imports);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "450:         result",
          "451:     }",
          "456:             .unwrap();",
          "458:         Layout::from_size_align(size, align).unwrap()",
          "459:     }",
          "",
          "[Removed Lines]",
          "453:     fn alloc_layout(&self) -> Layout {",
          "454:         let size = mem::size_of_val(self)",
          "455:             .checked_add(usize::try_from(self.offsets.size_of_vmctx()).unwrap())",
          "457:         let align = mem::align_of_val(self);",
          "",
          "[Added Lines]",
          "469:     fn alloc_layout(offsets: &VMOffsets<HostPtr>) -> Layout {",
          "470:         let size = mem::size_of::<Self>()",
          "471:             .checked_add(usize::try_from(offsets.size_of_vmctx()).unwrap())",
          "473:         let align = mem::align_of::<Self>();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "855:         }",
          "856:     }",
          "859:         for (idx, global) in self.module().globals.iter() {",
          "860:             let idx = match self.module().defined_global_index(idx) {",
          "861:                 Some(idx) => idx,",
          "862:                 None => continue,",
          "863:             };",
          "864:             match global.wasm_ty {",
          "866:                 WasmType::ExternRef => {}",
          "867:                 _ => continue,",
          "868:             }",
          "",
          "[Removed Lines]",
          "858:     fn drop_globals(&mut self) {",
          "",
          "[Added Lines]",
          "879:     unsafe fn initialize_vmctx(&mut self, module: &Module, store: StorePtr, imports: Imports) {",
          "880:         assert!(std::ptr::eq(module, self.module().as_ref()));",
          "882:         if let Some(store) = store.as_raw() {",
          "886:             self.set_store(store);",
          "887:         }",
          "890:         let signatures = self.runtime_info.signature_ids();",
          "895:             &VMBuiltinFunctionsArray::INIT;",
          "898:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
          "899:         ptr::copy_nonoverlapping(",
          "900:             imports.functions.as_ptr(),",
          "901:             self.vmctx_plus_offset(self.offsets.vmctx_imported_functions_begin()),",
          "902:             imports.functions.len(),",
          "903:         );",
          "904:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
          "905:         ptr::copy_nonoverlapping(",
          "906:             imports.tables.as_ptr(),",
          "907:             self.vmctx_plus_offset(self.offsets.vmctx_imported_tables_begin()),",
          "908:             imports.tables.len(),",
          "909:         );",
          "910:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
          "911:         ptr::copy_nonoverlapping(",
          "912:             imports.memories.as_ptr(),",
          "913:             self.vmctx_plus_offset(self.offsets.vmctx_imported_memories_begin()),",
          "914:             imports.memories.len(),",
          "915:         );",
          "916:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
          "917:         ptr::copy_nonoverlapping(",
          "918:             imports.globals.as_ptr(),",
          "919:             self.vmctx_plus_offset(self.offsets.vmctx_imported_globals_begin()),",
          "920:             imports.globals.len(),",
          "921:         );",
          "930:         let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_tables_begin());",
          "931:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "932:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
          "933:             ptr = ptr.add(1);",
          "934:         }",
          "937:         let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_memories_begin());",
          "938:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "939:             ptr::write(ptr, self.memories[DefinedMemoryIndex::new(i)].vmmemory());",
          "940:             ptr = ptr.add(1);",
          "941:         }",
          "944:         self.initialize_vmctx_globals(module);",
          "945:     }",
          "947:     unsafe fn initialize_vmctx_globals(&mut self, module: &Module) {",
          "948:         let num_imports = module.num_imported_globals;",
          "949:         for (index, global) in module.globals.iter().skip(num_imports) {",
          "950:             let def_index = module.defined_global_index(index).unwrap();",
          "951:             let to = self.global_ptr(def_index);",
          "954:             ptr::write(to, VMGlobalDefinition::new());",
          "956:             match global.initializer {",
          "957:                 GlobalInit::I32Const(x) => *(*to).as_i32_mut() = x,",
          "958:                 GlobalInit::I64Const(x) => *(*to).as_i64_mut() = x,",
          "959:                 GlobalInit::F32Const(x) => *(*to).as_f32_bits_mut() = x,",
          "960:                 GlobalInit::F64Const(x) => *(*to).as_f64_bits_mut() = x,",
          "961:                 GlobalInit::V128Const(x) => *(*to).as_u128_mut() = x,",
          "962:                 GlobalInit::GetGlobal(x) => {",
          "963:                     let from = if let Some(def_x) = module.defined_global_index(x) {",
          "964:                         self.global(def_x)",
          "965:                     } else {",
          "966:                         &*self.imported_global(x).from",
          "967:                     };",
          "971:                     match global.wasm_ty {",
          "972:                         WasmType::ExternRef => {",
          "974:                         }",
          "975:                         _ => ptr::copy_nonoverlapping(from, to, 1),",
          "976:                     }",
          "977:                 }",
          "978:                 GlobalInit::RefFunc(f) => {",
          "980:                         as *const VMCallerCheckedAnyfunc;",
          "981:                 }",
          "982:                 GlobalInit::RefNullConst => match global.wasm_ty {",
          "984:                     WasmType::FuncRef => {}",
          "985:                     WasmType::ExternRef => {}",
          "986:                     ty => panic!(\"unsupported reference type for global: {:?}\", ty),",
          "987:                 },",
          "988:                 GlobalInit::Import => panic!(\"locally-defined global initialized as import\"),",
          "989:             }",
          "990:         }",
          "991:     }",
          "992: }",
          "994: impl Drop for Instance {",
          "995:     fn drop(&mut self) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "873:     }",
          "874: }",
          "883: #[derive(Hash, PartialEq, Eq)]",
          "884: pub struct InstanceHandle {",
          "",
          "[Removed Lines]",
          "876: impl Drop for Instance {",
          "877:     fn drop(&mut self) {",
          "878:         self.drop_globals();",
          "879:     }",
          "880: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use crate::memory::{DefaultMemoryCreator, Memory};",
          "4: use crate::table::Table;",
          "5: use crate::traphandlers::Trap;",
          "7: use crate::ModuleRuntimeInfo;",
          "8: use crate::Store;",
          "9: use anyhow::Result;",
          "",
          "[Removed Lines]",
          "6: use crate::vmcontext::{VMBuiltinFunctionsArray, VMCallerCheckedAnyfunc, VMGlobalDefinition};",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15: use std::sync::Arc;",
          "16: use thiserror::Error;",
          "17: use wasmtime_environ::{",
          "19:     MemoryInitializer, Module, PrimaryMap, TableInitialization, TableInitializer, TrapCode,",
          "21: };",
          "23: #[cfg(feature = \"pooling-allocator\")]",
          "",
          "[Removed Lines]",
          "18:     DefinedMemoryIndex, DefinedTableIndex, EntityRef, GlobalInit, InitMemory, MemoryInitialization,",
          "20:     WasmType, WASM_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "17:     DefinedMemoryIndex, DefinedTableIndex, HostPtr, InitMemory, MemoryInitialization,",
          "19:     VMOffsets, WasmType, WASM_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "427:     Ok(())",
          "428: }",
          "554: #[derive(Clone)]",
          "555: pub struct OnDemandInstanceAllocator {",
          "",
          "[Removed Lines]",
          "435: unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationRequest) {",
          "436:     if let Some(store) = req.store.as_raw() {",
          "440:         instance.set_store(store);",
          "441:     }",
          "443:     let module = req.runtime_info.module();",
          "446:     let signatures = req.runtime_info.signature_ids();",
          "451:         &VMBuiltinFunctionsArray::INIT;",
          "454:     debug_assert_eq!(req.imports.functions.len(), module.num_imported_funcs);",
          "455:     ptr::copy_nonoverlapping(",
          "456:         req.imports.functions.as_ptr(),",
          "457:         instance.vmctx_plus_offset(instance.offsets.vmctx_imported_functions_begin()),",
          "458:         req.imports.functions.len(),",
          "459:     );",
          "460:     debug_assert_eq!(req.imports.tables.len(), module.num_imported_tables);",
          "461:     ptr::copy_nonoverlapping(",
          "462:         req.imports.tables.as_ptr(),",
          "463:         instance.vmctx_plus_offset(instance.offsets.vmctx_imported_tables_begin()),",
          "464:         req.imports.tables.len(),",
          "465:     );",
          "466:     debug_assert_eq!(req.imports.memories.len(), module.num_imported_memories);",
          "467:     ptr::copy_nonoverlapping(",
          "468:         req.imports.memories.as_ptr(),",
          "469:         instance.vmctx_plus_offset(instance.offsets.vmctx_imported_memories_begin()),",
          "470:         req.imports.memories.len(),",
          "471:     );",
          "472:     debug_assert_eq!(req.imports.globals.len(), module.num_imported_globals);",
          "473:     ptr::copy_nonoverlapping(",
          "474:         req.imports.globals.as_ptr(),",
          "475:         instance.vmctx_plus_offset(instance.offsets.vmctx_imported_globals_begin()),",
          "476:         req.imports.globals.len(),",
          "477:     );",
          "486:     let mut ptr = instance.vmctx_plus_offset(instance.offsets.vmctx_tables_begin());",
          "487:     for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "488:         ptr::write(ptr, instance.tables[DefinedTableIndex::new(i)].vmtable());",
          "489:         ptr = ptr.add(1);",
          "490:     }",
          "493:     let mut ptr = instance.vmctx_plus_offset(instance.offsets.vmctx_memories_begin());",
          "494:     for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "495:         ptr::write(",
          "496:             ptr,",
          "497:             instance.memories[DefinedMemoryIndex::new(i)].vmmemory(),",
          "498:         );",
          "499:         ptr = ptr.add(1);",
          "500:     }",
          "503:     initialize_vmcontext_globals(instance, module);",
          "504: }",
          "506: unsafe fn initialize_vmcontext_globals(",
          "507:     instance: &mut Instance,",
          "508:     module: &Arc<wasmtime_environ::Module>,",
          "509: ) {",
          "510:     let num_imports = module.num_imported_globals;",
          "511:     for (index, global) in module.globals.iter().skip(num_imports) {",
          "512:         let def_index = module.defined_global_index(index).unwrap();",
          "513:         let to = instance.global_ptr(def_index);",
          "516:         ptr::write(to, VMGlobalDefinition::new());",
          "518:         match global.initializer {",
          "519:             GlobalInit::I32Const(x) => *(*to).as_i32_mut() = x,",
          "520:             GlobalInit::I64Const(x) => *(*to).as_i64_mut() = x,",
          "521:             GlobalInit::F32Const(x) => *(*to).as_f32_bits_mut() = x,",
          "522:             GlobalInit::F64Const(x) => *(*to).as_f64_bits_mut() = x,",
          "523:             GlobalInit::V128Const(x) => *(*to).as_u128_mut() = x,",
          "524:             GlobalInit::GetGlobal(x) => {",
          "525:                 let from = if let Some(def_x) = module.defined_global_index(x) {",
          "526:                     instance.global(def_x)",
          "527:                 } else {",
          "528:                     &*instance.imported_global(x).from",
          "529:                 };",
          "533:                 match global.wasm_ty {",
          "534:                     WasmType::ExternRef => *(*to).as_externref_mut() = from.as_externref().clone(),",
          "535:                     _ => ptr::copy_nonoverlapping(from, to, 1),",
          "536:                 }",
          "537:             }",
          "538:             GlobalInit::RefFunc(f) => {",
          "540:                     as *const VMCallerCheckedAnyfunc;",
          "541:             }",
          "542:             GlobalInit::RefNullConst => match global.wasm_ty {",
          "544:                 WasmType::FuncRef => {}",
          "545:                 WasmType::ExternRef => {}",
          "546:                 ty => panic!(\"unsupported reference type for global: {:?}\", ty),",
          "547:             },",
          "548:             GlobalInit::Import => panic!(\"locally-defined global initialized as import\"),",
          "549:         }",
          "550:     }",
          "551: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "647:     ) -> Result<InstanceHandle, InstantiationError> {",
          "648:         let memories = self.create_memories(&mut req.store, &req.runtime_info)?;",
          "649:         let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;",
          "670:     }",
          "672:     unsafe fn initialize(",
          "",
          "[Removed Lines]",
          "651:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "653:         let mut handle = {",
          "654:             let instance =",
          "655:                 Instance::create_raw(req.runtime_info.clone(), memories, tables, host_state);",
          "656:             let layout = instance.alloc_layout();",
          "657:             let instance_ptr = alloc::alloc(layout) as *mut Instance;",
          "658:             if instance_ptr.is_null() {",
          "659:                 alloc::handle_alloc_error(layout);",
          "660:             }",
          "661:             ptr::write(instance_ptr, instance);",
          "662:             InstanceHandle {",
          "663:                 instance: instance_ptr,",
          "664:             }",
          "665:         };",
          "667:         initialize_vmcontext(handle.instance_mut(), req);",
          "669:         Ok(handle)",
          "",
          "[Added Lines]",
          "526:         let module = req.runtime_info.module();",
          "527:         let offsets = VMOffsets::new(HostPtr, module);",
          "528:         let layout = Instance::alloc_layout(&offsets);",
          "529:         let instance_ptr = alloc::alloc(layout) as *mut Instance;",
          "531:         Instance::new_at(instance_ptr, layout.size(), offsets, req, memories, tables);",
          "533:         Ok(InstanceHandle {",
          "534:             instance: instance_ptr,",
          "535:         })",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "679:     }",
          "681:     unsafe fn deallocate(&self, handle: &InstanceHandle) {",
          "683:         ptr::drop_in_place(handle.instance);",
          "684:         alloc::dealloc(handle.instance.cast(), layout);",
          "685:     }",
          "",
          "[Removed Lines]",
          "682:         let layout = handle.instance().alloc_layout();",
          "",
          "[Added Lines]",
          "548:         let layout = Instance::alloc_layout(&handle.instance().offsets);",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: use super::{",
          "13: };",
          "14: use crate::{instance::Instance, Memory, Mmap, Table};",
          "16: use anyhow::{anyhow, bail, Context, Result};",
          "17: use libc::c_void;",
          "18: use std::convert::TryFrom;",
          "19: use std::mem;",
          "21: use std::sync::Mutex;",
          "22: use wasmtime_environ::{",
          "25: };",
          "27: mod index_allocator;",
          "",
          "[Removed Lines]",
          "11:     initialize_instance, initialize_vmcontext, InstanceAllocationRequest, InstanceAllocator,",
          "12:     InstanceHandle, InstantiationError,",
          "15: use crate::{MemFdSlot, ModuleRuntimeInfo};",
          "20: use std::sync::Arc;",
          "23:     DefinedMemoryIndex, HostPtr, MemoryStyle, Module, PrimaryMap, Tunables, VMOffsets,",
          "24:     VMOffsetsFields, WASM_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "11:     initialize_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,",
          "12:     InstantiationError,",
          "15: use crate::{MemFdSlot, ModuleRuntimeInfo, Store};",
          "22:     DefinedMemoryIndex, DefinedTableIndex, HostPtr, MemoryStyle, Module, PrimaryMap, Tunables,",
          "23:     VMOffsets, VMOffsetsFields, WASM_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "342:         &mut *(self.mapping.as_mut_ptr().add(index * self.instance_size) as *mut Instance)",
          "343:     }",
          "346:         &self,",
          "349:     ) -> Result<InstanceHandle, InstantiationError> {",
          "370:         }",
          "388:         Ok(InstanceHandle {",
          "390:         })",
          "391:     }",
          "",
          "[Removed Lines]",
          "345:     unsafe fn setup_instance(",
          "347:         index: usize,",
          "348:         mut req: InstanceAllocationRequest,",
          "350:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "351:         let instance_data = Instance::create_raw(",
          "352:             req.runtime_info.clone(),",
          "353:             PrimaryMap::default(),",
          "354:             PrimaryMap::default(),",
          "355:             host_state,",
          "356:         );",
          "358:         let instance = self.instance(index);",
          "364:         std::ptr::write(instance as _, instance_data);",
          "368:         if let Some(store) = req.store.as_raw() {",
          "369:             instance.set_store(store);",
          "372:         Self::set_instance_memories(",
          "373:             index,",
          "374:             instance,",
          "375:             &self.memories,",
          "376:             self.memories.max_wasm_pages,",
          "377:             &req.runtime_info,",
          "378:         )?;",
          "380:         Self::set_instance_tables(",
          "381:             instance,",
          "382:             self.tables.get(index).map(|x| x as *mut usize),",
          "383:             self.tables.max_elements,",
          "384:         )?;",
          "386:         initialize_vmcontext(instance, req);",
          "389:             instance: instance as _,",
          "",
          "[Added Lines]",
          "344:     unsafe fn initialize_instance(",
          "346:         instance_index: usize,",
          "347:         req: InstanceAllocationRequest,",
          "349:         let module = req.runtime_info.module();",
          "351:         let mut memories =",
          "352:             PrimaryMap::with_capacity(module.memory_plans.len() - module.num_imported_memories);",
          "353:         let mut tables =",
          "354:             PrimaryMap::with_capacity(module.table_plans.len() - module.num_imported_tables);",
          "358:         if let Err(e) = self.allocate_instance_resources(",
          "359:             instance_index,",
          "360:             req.runtime_info.as_ref(),",
          "361:             req.store.as_raw(),",
          "362:             &mut memories,",
          "363:             &mut tables,",
          "364:         ) {",
          "365:             self.deallocate_memories(instance_index, &mut memories);",
          "366:             self.deallocate_tables(instance_index, &mut tables);",
          "367:             return Err(e);",
          "370:         let instance_ptr = self.instance(instance_index) as _;",
          "372:         Instance::new_at(",
          "373:             instance_ptr,",
          "374:             self.instance_size,",
          "375:             VMOffsets::new(HostPtr, module),",
          "376:             req,",
          "377:             memories,",
          "378:             tables,",
          "379:         );",
          "382:             instance: instance_ptr,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "402:             alloc.alloc(req.runtime_info.unique_id()).index()",
          "403:         };",
          "412:                 Err(e)",
          "414:         }",
          "415:     }",
          "",
          "[Removed Lines]",
          "405:         unsafe {",
          "406:             self.setup_instance(index, req).or_else(|e| {",
          "408:                 let instance = self.instance(index);",
          "409:                 self.deallocate(&InstanceHandle {",
          "410:                     instance: instance as _,",
          "411:                 });",
          "413:             })",
          "",
          "[Added Lines]",
          "398:         match unsafe { self.initialize_instance(index, req) } {",
          "399:             Ok(handle) => Ok(handle),",
          "400:             Err(e) => {",
          "404:                 self.index_allocator.lock().unwrap().free(SlotId(index));",
          "406:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "427:         let instance = unsafe { &mut *handle.instance };",
          "",
          "[Removed Lines]",
          "430:         for ((def_mem_idx, memory), base) in",
          "431:             instance.memories.iter_mut().zip(self.memories.get(index))",
          "432:         {",
          "433:             let mut memory = mem::take(memory);",
          "434:             assert!(memory.is_static());",
          "436:             match memory {",
          "437:                 Memory::Static {",
          "438:                     memfd_slot: Some(mut memfd_slot),",
          "439:                     ..",
          "440:                 } => {",
          "445:                     if memfd_slot.clear_and_remain_ready().is_ok() {",
          "446:                         self.memories",
          "447:                             .return_memfd_slot(index, def_mem_idx, memfd_slot);",
          "448:                     }",
          "449:                 }",
          "451:                 _ => {",
          "455:                     #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "456:                     memory",
          "457:                         .reset_guard_pages()",
          "458:                         .expect(\"failed to reset guard pages\");",
          "460:                     drop(&mut memory);",
          "462:                     let size = memory.byte_size();",
          "463:                     drop(memory);",
          "464:                     decommit_memory_pages(base, size)",
          "465:                         .expect(\"failed to decommit linear memory pages\");",
          "466:                 }",
          "467:             }",
          "468:         }",
          "470:         instance.memories.clear();",
          "471:         instance.dropped_data.clear();",
          "474:         for (table, base) in instance.tables.values_mut().zip(self.tables.get(index)) {",
          "475:             let table = mem::take(table);",
          "476:             assert!(table.is_static());",
          "478:             let size = round_up_to_pow2(",
          "479:                 table.size() as usize * mem::size_of::<*mut u8>(),",
          "480:                 self.tables.page_size,",
          "481:             );",
          "483:             drop(table);",
          "484:             decommit_table_pages(base, size).expect(\"failed to decommit table pages\");",
          "485:         }",
          "",
          "[Added Lines]",
          "423:         self.deallocate_memories(index, &mut instance.memories);",
          "424:         self.deallocate_tables(index, &mut instance.tables);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "497:         self.index_allocator.lock().unwrap().free(SlotId(index));",
          "498:     }",
          "506:     ) -> Result<(), InstantiationError> {",
          "511:         for (memory_index, plan) in module",
          "512:             .memory_plans",
          "",
          "[Removed Lines]",
          "500:     fn set_instance_memories(",
          "501:         instance_idx: usize,",
          "502:         instance: &mut Instance,",
          "503:         memories: &MemoryPool,",
          "504:         max_pages: u64,",
          "505:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "507:         let module = instance.runtime_info.module();",
          "509:         assert!(instance.memories.is_empty());",
          "",
          "[Added Lines]",
          "439:     fn allocate_instance_resources(",
          "440:         &self,",
          "441:         instance_index: usize,",
          "442:         runtime_info: &dyn ModuleRuntimeInfo,",
          "443:         store: Option<*mut dyn Store>,",
          "444:         memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,",
          "445:         tables: &mut PrimaryMap<DefinedTableIndex, Table>,",
          "447:         self.allocate_memories(instance_index, runtime_info, store, memories)?;",
          "448:         self.allocate_tables(instance_index, runtime_info, store, tables)?;",
          "450:         Ok(())",
          "451:     }",
          "453:     fn allocate_memories(",
          "454:         &self,",
          "455:         instance_index: usize,",
          "456:         runtime_info: &dyn ModuleRuntimeInfo,",
          "457:         store: Option<*mut dyn Store>,",
          "458:         memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,",
          "459:     ) -> Result<(), InstantiationError> {",
          "460:         let module = runtime_info.module();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "520:             let memory = unsafe {",
          "521:                 std::slice::from_raw_parts_mut(",
          "524:                 )",
          "525:             };",
          "",
          "[Removed Lines]",
          "522:                     memories.get_base(instance_idx, defined_index),",
          "523:                     (max_pages as usize) * (WASM_PAGE_SIZE as usize),",
          "",
          "[Added Lines]",
          "473:                     self.memories.get_base(instance_index, defined_index),",
          "474:                     (self.memories.max_wasm_pages as usize) * (WASM_PAGE_SIZE as usize),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "528:                 .memfd_image(defined_index)",
          "529:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "530:             {",
          "532:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "531:                 let mut slot = memories.take_memfd_slot(instance_idx, defined_index);",
          "",
          "[Added Lines]",
          "482:                 let mut slot = self.memories.take_memfd_slot(instance_index, defined_index);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "547:                 slot.instantiate(initial_size as usize, Some(image))",
          "548:                     .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "551:                     Memory::new_static(plan, memory, None, Some(slot), unsafe {",
          "553:                     })",
          "554:                     .map_err(InstantiationError::Resource)?,",
          "555:                 );",
          "556:             } else {",
          "558:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
          "560:                     })",
          "561:                     .map_err(InstantiationError::Resource)?,",
          "562:                 );",
          "563:             }",
          "564:         }",
          "568:         Ok(())",
          "569:     }",
          "580:         for (_, plan) in module.table_plans.iter().skip(module.num_imported_tables) {",
          "583:             commit_table_pages(",
          "584:                 base as *mut u8,",
          "586:             )",
          "587:             .map_err(InstantiationError::Resource)?;",
          "593:             );",
          "594:         }",
          "601:         Ok(())",
          "602:     }",
          "603: }",
          "",
          "[Removed Lines]",
          "550:                 instance.memories.push(",
          "552:                         &mut *instance.store()",
          "557:                 instance.memories.push(",
          "559:                         &mut *instance.store()",
          "566:         assert!(instance.dropped_data.is_empty());",
          "571:     fn set_instance_tables(",
          "572:         instance: &mut Instance,",
          "573:         mut tables: impl Iterator<Item = *mut usize>,",
          "574:         max_elements: u32,",
          "575:     ) -> Result<(), InstantiationError> {",
          "576:         let module = instance.runtime_info.module();",
          "578:         assert!(instance.tables.is_empty());",
          "581:             let base = tables.next().unwrap();",
          "585:                 max_elements as usize * mem::size_of::<*mut u8>(),",
          "589:             let table = unsafe { std::slice::from_raw_parts_mut(base, max_elements as usize) };",
          "590:             instance.tables.push(",
          "591:                 Table::new_static(plan, table, unsafe { &mut *instance.store() })",
          "592:                     .map_err(InstantiationError::Resource)?,",
          "596:         assert!(instance.dropped_elements.is_empty());",
          "597:         instance",
          "598:             .dropped_elements",
          "599:             .resize(module.passive_elements.len());",
          "",
          "[Added Lines]",
          "501:                 memories.push(",
          "503:                         &mut *store.unwrap()",
          "508:                 memories.push(",
          "510:                         &mut *store.unwrap()",
          "520:     fn deallocate_memories(",
          "521:         &self,",
          "522:         instance_index: usize,",
          "523:         memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,",
          "524:     ) {",
          "526:         for ((def_mem_idx, memory), base) in",
          "527:             memories.iter_mut().zip(self.memories.get(instance_index))",
          "528:         {",
          "529:             let mut memory = mem::take(memory);",
          "530:             assert!(memory.is_static());",
          "532:             match memory {",
          "533:                 Memory::Static {",
          "534:                     memfd_slot: Some(mut memfd_slot),",
          "535:                     ..",
          "536:                 } => {",
          "541:                     if memfd_slot.clear_and_remain_ready().is_ok() {",
          "542:                         self.memories",
          "543:                             .return_memfd_slot(instance_index, def_mem_idx, memfd_slot);",
          "544:                     }",
          "545:                 }",
          "547:                 _ => {",
          "551:                     #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "552:                     memory",
          "553:                         .reset_guard_pages()",
          "554:                         .expect(\"failed to reset guard pages\");",
          "556:                     drop(&mut memory);",
          "558:                     let size = memory.byte_size();",
          "559:                     drop(memory);",
          "560:                     decommit_memory_pages(base, size)",
          "561:                         .expect(\"failed to decommit linear memory pages\");",
          "562:                 }",
          "563:             }",
          "564:         }",
          "565:     }",
          "567:     fn allocate_tables(",
          "568:         &self,",
          "569:         instance_index: usize,",
          "570:         runtime_info: &dyn ModuleRuntimeInfo,",
          "571:         store: Option<*mut dyn Store>,",
          "572:         tables: &mut PrimaryMap<DefinedTableIndex, Table>,",
          "573:     ) -> Result<(), InstantiationError> {",
          "574:         let module = runtime_info.module();",
          "575:         let mut bases = self.tables.get(instance_index);",
          "577:             let base = bases.next().unwrap() as _;",
          "581:                 self.tables.max_elements as usize * mem::size_of::<*mut u8>(),",
          "585:             tables.push(",
          "586:                 Table::new_static(",
          "587:                     plan,",
          "588:                     unsafe {",
          "589:                         std::slice::from_raw_parts_mut(base, self.tables.max_elements as usize)",
          "590:                     },",
          "591:                     unsafe { &mut *store.unwrap() },",
          "592:                 )",
          "593:                 .map_err(InstantiationError::Resource)?,",
          "600:     fn deallocate_tables(",
          "601:         &self,",
          "602:         instance_index: usize,",
          "603:         tables: &mut PrimaryMap<DefinedTableIndex, Table>,",
          "604:     ) {",
          "606:         for (table, base) in tables.values_mut().zip(self.tables.get(instance_index)) {",
          "607:             let table = mem::take(table);",
          "608:             assert!(table.is_static());",
          "610:             let size = round_up_to_pow2(",
          "611:                 table.size() as usize * mem::size_of::<*mut u8>(),",
          "612:                 self.tables.page_size,",
          "613:             );",
          "615:             drop(table);",
          "616:             decommit_table_pages(base, size).expect(\"failed to decommit table pages\");",
          "617:         }",
          "618:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1130: mod test {",
          "1131:     use super::*;",
          "1132:     use crate::{CompiledModuleId, Imports, MemoryMemFd, StorePtr, VMSharedSignatureIndex};",
          "1133:     use wasmtime_environ::{",
          "1134:         DefinedFuncIndex, DefinedMemoryIndex, EntityRef, FunctionInfo, Global, GlobalInit, Memory,",
          "1135:         MemoryPlan, ModuleType, SignatureIndex, Table, TablePlan, TableStyle, WasmType,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1149:     use std::sync::Arc;",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "549:     Ok(())",
          "550: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "552: #[test]",
          "553: fn drop_externref_global_during_module_init() -> Result<()> {",
          "554:     struct Limiter;",
          "556:     impl ResourceLimiter for Limiter {",
          "557:         fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {",
          "558:             false",
          "559:         }",
          "561:         fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {",
          "562:             false",
          "563:         }",
          "564:     }",
          "566:     let mut config = Config::new();",
          "567:     config.wasm_reference_types(true);",
          "568:     config.allocation_strategy(InstanceAllocationStrategy::Pooling {",
          "569:         strategy: PoolingAllocationStrategy::NextAvailable,",
          "570:         module_limits: Default::default(),",
          "571:         instance_limits: InstanceLimits { count: 1 },",
          "572:     });",
          "574:     let engine = Engine::new(&config)?;",
          "576:     let module = Module::new(",
          "577:         &engine,",
          "578:         r#\"",
          "579:             (module",
          "580:                 (global i32 (i32.const 1))",
          "581:                 (global i32 (i32.const 2))",
          "582:                 (global i32 (i32.const 3))",
          "583:                 (global i32 (i32.const 4))",
          "584:                 (global i32 (i32.const 5))",
          "585:             )",
          "586:         \"#,",
          "587:     )?;",
          "589:     let mut store = Store::new(&engine, Limiter);",
          "590:     drop(Instance::new(&mut store, &module, &[])?);",
          "591:     drop(store);",
          "593:     let module = Module::new(",
          "594:         &engine,",
          "595:         r#\"",
          "596:             (module",
          "597:                 (memory 1)",
          "598:                 (global (mut externref) (ref.null extern))",
          "599:             )",
          "600:         \"#,",
          "601:     )?;",
          "603:     let mut store = Store::new(&engine, Limiter);",
          "604:     store.limiter(|s| s);",
          "605:     assert!(Instance::new(&mut store, &module, &[]).is_err());",
          "607:     Ok(())",
          "608: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
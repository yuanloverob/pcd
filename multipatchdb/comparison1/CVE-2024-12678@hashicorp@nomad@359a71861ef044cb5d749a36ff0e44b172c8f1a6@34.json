{
  "cve_id": "CVE-2024-12678",
  "cve_desc": "Nomad Community and Nomad Enterprise (\"Nomad\") allocations are vulnerable to privilege escalation within a namespace through unredacted workload identity tokens. This vulnerability, identified as CVE-2024-12678, is fixed in Nomad Community Edition 1.9.4 and Nomad Enterprise 1.9.4, 1.8.8, and 1.7.16.",
  "repo": "hashicorp/nomad",
  "patch_hash": "359a71861ef044cb5d749a36ff0e44b172c8f1a6",
  "patch_info": {
    "commit_hash": "359a71861ef044cb5d749a36ff0e44b172c8f1a6",
    "repo": "hashicorp/nomad",
    "commit_url": "https://github.com/hashicorp/nomad/commit/359a71861ef044cb5d749a36ff0e44b172c8f1a6",
    "files": [
      ".changelog/24683.txt",
      "command/agent/node_endpoint.go",
      "nomad/alloc_endpoint.go",
      "nomad/structs/structs.go"
    ],
    "message": "Backport of sec: fix alloc workload identity namespace permission into release/1.9.x (#24685)\n\nCo-authored-by: Deniz Onur Duzgun <59659739+dduzgun-security@users.noreply.github.com>",
    "before_after_code_files": [
      "command/agent/node_endpoint.go||command/agent/node_endpoint.go",
      "nomad/alloc_endpoint.go||nomad/alloc_endpoint.go",
      "nomad/structs/structs.go||nomad/structs/structs.go"
    ]
  },
  "patch_diff": {
    "command/agent/node_endpoint.go||command/agent/node_endpoint.go": [
      "File: command/agent/node_endpoint.go -> command/agent/node_endpoint.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "105:   out.Allocs = make([]*structs.Allocation, 0)",
      "106:  }",
      "107:  for _, alloc := range out.Allocs {",
      "108:   alloc.SetEventDisplayMessages()",
      "109:  }",
      "110:  return out.Allocs, nil",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "108:   alloc = alloc.Sanitize()",
      "",
      "---------------"
    ],
    "nomad/alloc_endpoint.go||nomad/alloc_endpoint.go": [
      "File: nomad/alloc_endpoint.go -> nomad/alloc_endpoint.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "172:    }",
      "176:    if out != nil {",
      "178:     if !aclObj.AllowClientOp() && !allowNsOp(aclObj, out.Namespace) {",
      "179:      return structs.NewErrUnknownAllocation(args.AllocID)",
      "",
      "[Removed Lines]",
      "175:    reply.Alloc = out",
      "",
      "[Added Lines]",
      "176:     out = out.Sanitize()",
      "177:     reply.Alloc = out",
      "",
      "---------------"
    ],
    "nomad/structs/structs.go||nomad/structs/structs.go": [
      "File: nomad/structs/structs.go -> nomad/structs/structs.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "11199:  return a.ID",
      "11200: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11205: func (a *Allocation) Sanitize() *Allocation {",
      "11206:  if a == nil {",
      "11207:   return nil",
      "11208:  }",
      "11210:  if a.SignedIdentities == nil {",
      "11211:   return a",
      "11212:  }",
      "11214:  clean := a.Copy()",
      "11215:  clean.SignedIdentities = nil",
      "11216:  return clean",
      "11217: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "708136b8e608a2542af283fde8b80068848b8fb6",
      "candidate_info": {
        "commit_hash": "708136b8e608a2542af283fde8b80068848b8fb6",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/708136b8e608a2542af283fde8b80068848b8fb6",
        "files": [
          "client/client.go"
        ],
        "message": "backport of commit c52623d7d4a769a40caf41b414c8e5c6b9cf6c26 (#25248)\n\nCo-authored-by: David <ddl.tdh@gmail.com>",
        "before_after_code_files": [
          "client/client.go||client/client.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/hashicorp/nomad/pull/25471"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "client/client.go||client/client.go": [
          "File: client/client.go -> client/client.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3262: }",
          "3266:  metrics.SetGaugeWithLabels([]string{\"client\", \"host\", \"memory\", \"total\"}, float32(hStats.Memory.Total), baseLabels)",
          "3267:  metrics.SetGaugeWithLabels([]string{\"client\", \"host\", \"memory\", \"available\"}, float32(hStats.Memory.Available), baseLabels)",
          "3268:  metrics.SetGaugeWithLabels([]string{\"client\", \"host\", \"memory\", \"used\"}, float32(hStats.Memory.Used), baseLabels)",
          "",
          "[Removed Lines]",
          "3265: func (c *Client) setGaugeForMemoryStats(nodeID string, hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "[Added Lines]",
          "3265: func (c *Client) setGaugeForMemoryStats(hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3270: }",
          "3275:  labels := make([]metrics.Label, len(baseLabels))",
          "3276:  copy(labels, baseLabels)",
          "",
          "[Removed Lines]",
          "3273: func (c *Client) setGaugeForCPUStats(nodeID string, hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "[Added Lines]",
          "3273: func (c *Client) setGaugeForCPUStats(hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3293: }",
          "3298:  labels := make([]metrics.Label, len(baseLabels))",
          "3299:  copy(labels, baseLabels)",
          "",
          "[Removed Lines]",
          "3296: func (c *Client) setGaugeForDiskStats(nodeID string, hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "[Added Lines]",
          "3296: func (c *Client) setGaugeForDiskStats(hStats *hoststats.HostStats, baseLabels []metrics.Label) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3313: }",
          "3317:  node := c.GetConfig().Node",
          "3318:  total := node.NodeResources",
          "3319:  res := node.ReservedResources",
          "",
          "[Removed Lines]",
          "3316: func (c *Client) setGaugeForAllocationStats(nodeID string, baseLabels []metrics.Label) {",
          "",
          "[Added Lines]",
          "3316: func (c *Client) setGaugeForAllocationStats(baseLabels []metrics.Label) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3373: func (c *Client) emitHostStats() {",
          "3375:  hStats := c.hostStatsCollector.Stats()",
          "3376:  labels := c.labels()",
          "3379:  c.setGaugeForUptime(hStats, labels)",
          "3382: }",
          "3385: func (c *Client) emitClientMetrics() {",
          "3387:  labels := c.labels()",
          "3392:  blocked, migrating, pending, running, terminal := 0, 0, 0, 0, 0",
          "",
          "[Removed Lines]",
          "3374:  nodeID := c.NodeID()",
          "3378:  c.setGaugeForMemoryStats(nodeID, hStats, labels)",
          "3380:  c.setGaugeForCPUStats(nodeID, hStats, labels)",
          "3381:  c.setGaugeForDiskStats(nodeID, hStats, labels)",
          "3386:  nodeID := c.NodeID()",
          "3389:  c.setGaugeForAllocationStats(nodeID, labels)",
          "",
          "[Added Lines]",
          "3377:  c.setGaugeForMemoryStats(hStats, labels)",
          "3379:  c.setGaugeForCPUStats(hStats, labels)",
          "3380:  c.setGaugeForDiskStats(hStats, labels)",
          "3387:  c.setGaugeForAllocationStats(labels)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39c7d3d9a975e7bd208f3d2da976b34a9854b93d",
      "candidate_info": {
        "commit_hash": "39c7d3d9a975e7bd208f3d2da976b34a9854b93d",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/39c7d3d9a975e7bd208f3d2da976b34a9854b93d",
        "files": [
          "command/job_restart.go",
          "scheduler/generic_sched.go",
          "website/content/docs/commands/job/restart.mdx",
          "website/content/docs/configuration/server.mdx",
          "website/content/docs/job-specification/disconnect.mdx",
          "website/content/docs/job-specification/group.mdx",
          "website/content/docs/job-specification/migrate.mdx",
          "website/content/docs/job-specification/reschedule.mdx",
          "website/content/docs/job-specification/restart.mdx"
        ],
        "message": "Backport of docs: clarify reschedule, migrate, and replacement terminology into release/1.9.x (#25145)\n\nCo-authored-by: Tim Gross <tgross@hashicorp.com>",
        "before_after_code_files": [
          "command/job_restart.go||command/job_restart.go",
          "scheduler/generic_sched.go||scheduler/generic_sched.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/hashicorp/nomad/pull/25471"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "command/job_restart.go||command/job_restart.go": [
          "File: command/job_restart.go -> command/job_restart.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:   batch. It is also possible to specify additional time to wait between",
          "125:   batches.",
          "136:   clients. The command waits until the new allocations have client status",
          "140:   By default the command restarts all running tasks in-place with one",
          "141:   allocation per batch.",
          "",
          "[Removed Lines]",
          "127:   Allocations can be restarted in-place or rescheduled. When restarting",
          "128:   in-place the command may target specific tasks in the allocations, restart",
          "129:   only tasks that are currently running, or restart all tasks, even the ones",
          "130:   that have already run. Allocations can also be targeted by group. When both",
          "131:   groups and tasks are defined only the tasks for the allocations of those",
          "132:   groups are restarted.",
          "134:   When rescheduling, the current allocations are stopped triggering the Nomad",
          "135:   scheduler to create replacement allocations that may be placed in different",
          "137:   'ready' before proceeding with the remaining batches. Services health checks",
          "138:   are not taken into account.",
          "",
          "[Added Lines]",
          "127:   You may restart in-place or migrated allocations. When restarting in-place,",
          "128:   the command may target specific tasks in the allocations, restart only tasks",
          "129:   that are currently running, or restart all tasks, even the ones that have",
          "130:   already run. Groups and tasks can also target allocations.  When you define",
          "131:   both groups and tasks, Nomad restarts only the tasks for the allocations of",
          "132:   those groups.",
          "134:   When migrating, Nomad stops the current allocations, triggering the Nomad",
          "135:   scheduler to create new allocations that may be placed in different",
          "137:   'ready' before proceeding with the remaining batches. The command does not",
          "138:   consider service health checks.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "183:     proceed. If 'fail' the command exits immediately. Defaults to 'ask'.",
          "185:   -reschedule",
          "187:     in-place. Since the group is not modified the restart does not create a new",
          "188:     deployment, and so values defined in 'update' blocks, such as",
          "189:     'max_parallel', are not taken into account. This option cannot be used with",
          "190:     '-task'. Only jobs of type 'batch', 'service', and 'system' can be",
          "193:   -task=<task-name>",
          "194:     Specify the task to restart. Can be specified multiple times. If groups are",
          "",
          "[Removed Lines]",
          "186:     If set, allocations are stopped and rescheduled instead of restarted",
          "191:     rescheduled.",
          "",
          "[Added Lines]",
          "186:     If set, allocations are stopped and migrated instead of restarted",
          "191:     migrated. Note that despite the name of this flag, this command migrates but",
          "192:     does not reschedule allocations, so it ignores the 'reschedule' block.",
          "",
          "---------------"
        ],
        "scheduler/generic_sched.go||scheduler/generic_sched.go": [
          "File: scheduler/generic_sched.go -> scheduler/generic_sched.go"
        ]
      }
    },
    {
      "candidate_hash": "5ad790f8ef25667ac3d487890733064101e5aa4f",
      "candidate_info": {
        "commit_hash": "5ad790f8ef25667ac3d487890733064101e5aa4f",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/5ad790f8ef25667ac3d487890733064101e5aa4f",
        "files": [
          ".changelog/24849.txt",
          "nomad/event_endpoint.go",
          "nomad/event_endpoint_test.go",
          "nomad/state/state_store.go",
          "nomad/stream/event_broker.go",
          "nomad/stream/event_broker_test.go",
          "nomad/stream/subscription.go"
        ],
        "message": "Backport of Enable workload identity for event stream into release/1.9.x (#24927)",
        "before_after_code_files": [
          "nomad/event_endpoint.go||nomad/event_endpoint.go",
          "nomad/event_endpoint_test.go||nomad/event_endpoint_test.go",
          "nomad/state/state_store.go||nomad/state/state_store.go",
          "nomad/stream/event_broker.go||nomad/stream/event_broker.go",
          "nomad/stream/event_broker_test.go||nomad/stream/event_broker_test.go",
          "nomad/stream/subscription.go||nomad/stream/subscription.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/hashicorp/nomad/pull/25471"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "nomad/event_endpoint.go||nomad/event_endpoint.go": [
          "File: nomad/event_endpoint.go -> nomad/event_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  \"github.com/hashicorp/go-msgpack/v2/codec\"",
          "13:  \"github.com/hashicorp/nomad/helper/pointer\"",
          "14:  \"github.com/hashicorp/nomad/nomad/stream\"",
          "15:  \"github.com/hashicorp/nomad/nomad/structs\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13:  \"github.com/hashicorp/nomad/acl\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:   Topics:    args.Topics,",
          "62:   Index:     uint64(args.Index),",
          "63:   Namespace: args.Namespace,",
          "64:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65:   Authenticate: func() error {",
          "66:    if err := e.srv.Authenticate(nil, &args); err != nil {",
          "67:     return err",
          "68:    }",
          "69:    resolvedACL, err := e.srv.ResolveACL(&args)",
          "70:    if err != nil {",
          "71:     return err",
          "72:    }",
          "73:    return validateACL(args.Namespace, args.Topics, resolvedACL)",
          "74:   },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:  var subscription *stream.Subscription",
          "75:  var subErr error",
          "86:  if subErr != nil {",
          "87:   handleJsonResultError(subErr, pointer.Of(int64(500)), encoder)",
          "88:   return",
          "89:  }",
          "90:  defer subscription.Unsubscribe()",
          "92:  ctx, cancel := context.WithCancel(context.Background())",
          "93:  defer cancel()",
          "",
          "[Removed Lines]",
          "78:  var expiryTime *time.Time",
          "81:  if e.srv.config.ACLEnabled {",
          "82:   subscription, expiryTime, subErr = publisher.SubscribeWithACLCheck(subReq)",
          "83:  } else {",
          "84:   subscription, subErr = publisher.Subscribe(subReq)",
          "85:  }",
          "",
          "[Added Lines]",
          "88:  subscription, subErr = publisher.Subscribe(subReq)",
          "96:  var exp time.Time",
          "97:  if c := args.GetIdentity().GetClaims(); c != nil {",
          "98:   exp = c.Expiry.Time()",
          "99:  } else if t := args.GetIdentity().GetACLToken(); t != nil && t.ExpirationTime != nil {",
          "100:   exp = *t.ExpirationTime",
          "101:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:     return",
          "112:    }",
          "117:     select {",
          "118:     case errCh <- structs.ErrTokenExpired:",
          "119:     case <-ctx.Done():",
          "",
          "[Removed Lines]",
          "116:    if expiryTime != nil && expiryTime.Before(time.Now().UTC()) {",
          "",
          "[Added Lines]",
          "127:    if !exp.IsZero() && exp.Before(time.Now().UTC()) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:   Error: structs.NewRpcError(err, code),",
          "214:  })",
          "215: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228: func validateACL(namespace string, topics map[structs.Topic][]string, aclObj *acl.ACL) error {",
          "229:  for topic := range topics {",
          "230:   switch topic {",
          "231:   case structs.TopicDeployment,",
          "232:    structs.TopicEvaluation,",
          "233:    structs.TopicAllocation,",
          "234:    structs.TopicJob,",
          "235:    structs.TopicService:",
          "236:    if ok := aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob); !ok {",
          "237:     return structs.ErrPermissionDenied",
          "238:    }",
          "239:   case structs.TopicNode:",
          "240:    if ok := aclObj.AllowNodeRead(); !ok {",
          "241:     return structs.ErrPermissionDenied",
          "242:    }",
          "243:   case structs.TopicNodePool:",
          "246:    if ok := aclObj.IsManagement(); !ok {",
          "247:     return structs.ErrPermissionDenied",
          "248:    }",
          "249:   default:",
          "250:    if ok := aclObj.IsManagement(); !ok {",
          "251:     return structs.ErrPermissionDenied",
          "252:    }",
          "253:   }",
          "254:  }",
          "256:  return nil",
          "258: }",
          "",
          "---------------"
        ],
        "nomad/event_endpoint_test.go||nomad/event_endpoint_test.go": [
          "File: nomad/event_endpoint_test.go -> nomad/event_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:  }",
          "313: }",
          "316:  ci.Parallel(t)",
          "317:  require := require.New(t)",
          "334:  cases := []struct {",
          "335:   Name        string",
          "337:   Topics      map[structs.Topic][]string",
          "338:   Namespace   string",
          "341:  }{",
          "342:   {",
          "361:    Topics: map[structs.Topic][]string{",
          "362:     structs.TopicJob:        {\"*\"},",
          "363:     structs.TopicEvaluation: {\"*\"},",
          "364:     structs.TopicAllocation: {\"*\"},",
          "365:     structs.TopicDeployment: {\"*\"},",
          "366:    },",
          "367:    Namespace:   \"foo\",",
          "372:   },",
          "373:   {",
          "376:    Topics: map[structs.Topic][]string{",
          "377:     structs.TopicJob: {\"*\"}, // good",
          "378:    },",
          "379:    Namespace:   \"bar\", // bad",
          "383:    },",
          "384:   },",
          "385:   {",
          "388:    Topics: map[structs.Topic][]string{",
          "389:     structs.TopicAll: {\"*\"}, // bad",
          "390:    },",
          "391:    Namespace:   \"foo\",",
          "395:    },",
          "396:   },",
          "397:   {",
          "400:    Topics: map[structs.Topic][]string{",
          "401:     structs.TopicEvaluation: {\"*\"}, // good",
          "402:     structs.TopicNode:       {\"*\"}, // bad",
          "403:    },",
          "404:    Namespace:   \"foo\",",
          "408:    },",
          "409:   },",
          "410:   {",
          "413:    Topics: map[structs.Topic][]string{",
          "416:    },",
          "417:    Namespace:   \"foo\",",
          "422:   },",
          "423:  }",
          "425:  for _, tc := range cases {",
          "426:   t.Run(tc.Name, func(t *testing.T) {",
          "475:    require.NoError(err)",
          "509:   })",
          "510:  }",
          "511: }",
          "",
          "[Removed Lines]",
          "315: func TestEventStream_ACL(t *testing.T) {",
          "320:  s, _, cleanupS := TestACLServer(t, nil)",
          "321:  defer cleanupS()",
          "322:  testutil.WaitForLeader(t, s.RPC)",
          "324:  policyBad := mock.NamespacePolicy(\"other\", \"\", []string{acl.NamespaceCapabilityReadFS})",
          "325:  tokenBad := mock.CreatePolicyAndToken(t, s.State(), 1005, \"invalid\", policyBad)",
          "327:  policyNsGood := mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob})",
          "328:  tokenNsFoo := mock.CreatePolicyAndToken(t, s.State(), 1006, \"valid\", policyNsGood)",
          "330:  policyNsNode := mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob})",
          "331:  policyNsNode += \"\\n\" + mock.NodePolicy(\"read\")",
          "332:  tokenNsNode := mock.CreatePolicyAndToken(t, s.State(), 1007, \"validnNsNode\", policyNsNode)",
          "336:   Token       string",
          "339:   ExpectedErr string",
          "340:   PublishFn   func(p *stream.EventBroker)",
          "343:    Name:  \"no token\",",
          "344:    Token: \"\",",
          "345:    Topics: map[structs.Topic][]string{",
          "346:     structs.TopicAll: {\"*\"},",
          "347:    },",
          "348:    ExpectedErr: structs.ErrPermissionDenied.Error(),",
          "349:   },",
          "350:   {",
          "351:    Name:  \"bad token\",",
          "352:    Token: tokenBad.SecretID,",
          "353:    Topics: map[structs.Topic][]string{",
          "354:     structs.TopicAll: {\"*\"},",
          "355:    },",
          "356:    ExpectedErr: structs.ErrPermissionDenied.Error(),",
          "357:   },",
          "358:   {",
          "359:    Name:  \"job namespace token - correct ns\",",
          "360:    Token: tokenNsFoo.SecretID,",
          "368:    ExpectedErr: \"subscription closed by server\",",
          "369:    PublishFn: func(p *stream.EventBroker) {",
          "370:     p.Publish(&structs.Events{Index: uint64(1000), Events: []structs.Event{{Topic: \"Job\", Namespace: \"foo\", Payload: mock.Job()}}})",
          "371:    },",
          "374:    Name:  \"job namespace token - incorrect ns\",",
          "375:    Token: tokenNsFoo.SecretID,",
          "380:    ExpectedErr: structs.ErrPermissionDenied.Error(),",
          "381:    PublishFn: func(p *stream.EventBroker) {",
          "382:     p.Publish(&structs.Events{Index: uint64(1000), Events: []structs.Event{{Topic: \"Job\", Namespace: \"foo\", Payload: mock.Job()}}})",
          "386:    Name:  \"job namespace token - request management topic\",",
          "387:    Token: tokenNsFoo.SecretID,",
          "392:    ExpectedErr: structs.ErrPermissionDenied.Error(),",
          "393:    PublishFn: func(p *stream.EventBroker) {",
          "394:     p.Publish(&structs.Events{Index: uint64(1000), Events: []structs.Event{{Topic: \"Job\", Namespace: \"foo\", Payload: mock.Job()}}})",
          "398:    Name:  \"job namespace token - request invalid node topic\",",
          "399:    Token: tokenNsFoo.SecretID,",
          "405:    ExpectedErr: structs.ErrPermissionDenied.Error(),",
          "406:    PublishFn: func(p *stream.EventBroker) {",
          "407:     p.Publish(&structs.Events{Index: uint64(1000), Events: []structs.Event{{Topic: \"Job\", Namespace: \"foo\", Payload: mock.Job()}}})",
          "411:    Name:  \"job+node namespace token, valid\",",
          "412:    Token: tokenNsNode.SecretID,",
          "414:     structs.TopicEvaluation: {\"*\"}, // good",
          "415:     structs.TopicNode:       {\"*\"}, // good",
          "418:    ExpectedErr: \"subscription closed by server\",",
          "419:    PublishFn: func(p *stream.EventBroker) {",
          "420:     p.Publish(&structs.Events{Index: uint64(1000), Events: []structs.Event{{Topic: \"Node\", Payload: mock.Node()}}})",
          "421:    },",
          "427:    var ns string",
          "428:    if tc.Namespace != \"\" {",
          "429:     ns = tc.Namespace",
          "430:    }",
          "432:    req := structs.EventStreamRequest{",
          "433:     Topics: tc.Topics,",
          "434:     QueryOptions: structs.QueryOptions{",
          "435:      Region:    s.Region(),",
          "436:      Namespace: ns,",
          "437:      AuthToken: tc.Token,",
          "438:     },",
          "439:    }",
          "441:    handler, err := s.StreamingRpcHandler(\"Event.Stream\")",
          "442:    require.Nil(err)",
          "445:    p1, p2 := net.Pipe()",
          "446:    defer p1.Close()",
          "447:    defer p2.Close()",
          "449:    errCh := make(chan error)",
          "450:    streamMsg := make(chan *structs.EventStreamWrapper)",
          "452:    go handler(p2)",
          "455:    go func() {",
          "456:     decoder := codec.NewDecoder(p1, structs.MsgpackHandle)",
          "457:     for {",
          "458:      var msg structs.EventStreamWrapper",
          "459:      if err := decoder.Decode(&msg); err != nil {",
          "460:       if err == io.EOF || strings.Contains(err.Error(), \"closed\") {",
          "461:        return",
          "462:       }",
          "463:       errCh <- fmt.Errorf(\"error decoding: %w\", err)",
          "464:      }",
          "466:      streamMsg <- &msg",
          "467:     }",
          "468:    }()",
          "471:    encoder := codec.NewEncoder(p1, structs.MsgpackHandle)",
          "472:    require.Nil(encoder.Encode(req))",
          "474:    publisher, err := s.State().EventBroker()",
          "478:    node := mock.Node()",
          "480:    publisher.Publish(&structs.Events{Index: uint64(1), Events: []structs.Event{{Topic: \"test\", Payload: node}}})",
          "481:    publisher.Publish(&structs.Events{Index: uint64(2), Events: []structs.Event{{Topic: \"test\", Payload: node}}})",
          "483:    if tc.PublishFn != nil {",
          "484:     tc.PublishFn(publisher)",
          "485:    }",
          "487:    timeout := time.After(5 * time.Second)",
          "488:   OUTER:",
          "489:    for {",
          "490:     select {",
          "491:     case <-timeout:",
          "492:      t.Fatal(\"timeout waiting for events\")",
          "493:     case err := <-errCh:",
          "494:      t.Fatal(err)",
          "495:     case msg := <-streamMsg:",
          "497:      publisher.CloseAll()",
          "498:      if msg.Error == nil {",
          "499:       continue",
          "500:      }",
          "502:      if strings.Contains(msg.Error.Error(), tc.ExpectedErr) {",
          "503:       break OUTER",
          "504:      } else {",
          "505:       t.Fatalf(\"unexpected error %v\", msg.Error)",
          "506:      }",
          "507:     }",
          "508:    }",
          "",
          "[Added Lines]",
          "315: func TestEventStream_validateACL(t *testing.T) {",
          "323:   Policy      string",
          "324:   Management  bool",
          "325:   ExpectedErr error",
          "328:    Name: \"read-job topics - correct ns\",",
          "334:     structs.TopicService:    {\"*\"},",
          "336:    Policy:      mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "338:    Management:  false,",
          "339:    ExpectedErr: nil,",
          "342:    Name: \"read-job topic - incorrect ns\",",
          "346:    Policy:      mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "348:    Management:  false,",
          "349:    ExpectedErr: structs.ErrPermissionDenied,",
          "350:   },",
          "351:   {",
          "352:    Name: \"read all topics - correct policy\",",
          "353:    Topics: map[structs.Topic][]string{",
          "354:     structs.TopicAll: {\"*\"}, // bad",
          "356:    Policy:      \"\",",
          "357:    Namespace:   \"*\",",
          "358:    Management:  true,",
          "359:    ExpectedErr: nil,",
          "362:    Name: \"read all topics - incorrect policy\",",
          "366:    Policy:      mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "368:    Management:  false,",
          "369:    ExpectedErr: structs.ErrPermissionDenied,",
          "370:   },",
          "371:   {",
          "372:    Name: \"read node - valid policy\",",
          "373:    Topics: map[structs.Topic][]string{",
          "374:     structs.TopicNode: {\"*\"}, // bad",
          "376:    Policy:      mock.NodePolicy(acl.PolicyRead),",
          "377:    Namespace:   \"foo\",",
          "378:    Management:  false,",
          "379:    ExpectedErr: nil,",
          "382:    Name: \"read node - invalid policy\",",
          "387:    Policy:      mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "389:    Management:  false,",
          "390:    ExpectedErr: structs.ErrPermissionDenied,",
          "391:   },",
          "392:   {",
          "393:    Name: \"read node pool - correct policy\",",
          "394:    Topics: map[structs.Topic][]string{",
          "395:     structs.TopicNodePool: {\"*\"}, // bad",
          "397:    Policy:      \"\",",
          "398:    Namespace:   \"\",",
          "399:    Management:  true,",
          "400:    ExpectedErr: nil,",
          "403:    Name: \"read node pool - incorrect policy\",",
          "405:     structs.TopicNodePool: {\"*\"}, // bad",
          "407:    Policy:      mock.NamespacePolicy(\"foo\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "409:    Management:  false,",
          "410:    ExpectedErr: structs.ErrPermissionDenied,",
          "417:    p, err := acl.Parse(tc.Policy)",
          "420:    testACL, err := acl.NewACL(tc.Management, []*acl.Policy{p})",
          "421:    require.NoError(err)",
          "423:    err = validateACL(tc.Namespace, tc.Topics, testACL)",
          "424:    require.Equal(tc.ExpectedErr, err)",
          "",
          "---------------"
        ],
        "nomad/state/state_store.go||nomad/state/state_store.go": [
          "File: nomad/state/state_store.go -> nomad/state/state_store.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:  stopEventBroker func()",
          "123: }",
          "135: func NewStateStore(config *StateStoreConfig) (*StateStore, error) {",
          "136:  if err := config.Validate(); err != nil {",
          "",
          "[Removed Lines]",
          "125: type streamACLDelegate struct {",
          "126:  s *StateStore",
          "127: }",
          "129: func (a *streamACLDelegate) TokenProvider() stream.ACLTokenProvider {",
          "130:  resolver, _ := a.s.Snapshot()",
          "131:  return resolver",
          "132: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:  if config.EnablePublisher {",
          "158:    EventBufferSize: config.EventBufferSize,",
          "159:    Logger:          config.Logger,",
          "160:   })",
          "",
          "[Removed Lines]",
          "157:   broker, err := stream.NewEventBroker(ctx, &streamACLDelegate{s}, stream.EventBrokerCfg{",
          "",
          "[Added Lines]",
          "148:   broker, err := stream.NewEventBroker(ctx, stream.EventBrokerCfg{",
          "",
          "---------------"
        ],
        "nomad/stream/event_broker.go||nomad/stream/event_broker.go": [
          "File: nomad/stream/event_broker.go -> nomad/stream/event_broker.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: import (",
          "7:  \"context\"",
          "9:  \"fmt\"",
          "10:  \"sync\"",
          "11:  \"sync/atomic\"",
          "14:  \"github.com/armon/go-metrics\"",
          "17:  \"github.com/hashicorp/nomad/nomad/structs\"",
          "19:  \"github.com/hashicorp/go-hclog\"",
          "",
          "[Removed Lines]",
          "8:  \"errors\"",
          "12:  \"time\"",
          "15:  \"github.com/hashicorp/go-memdb\"",
          "16:  \"github.com/hashicorp/nomad/acl\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:  publishCh chan *structs.Events",
          "49:  aclCh chan structs.Event",
          "51:  logger hclog.Logger",
          "",
          "[Removed Lines]",
          "46:  aclDelegate ACLDelegate",
          "47:  aclCache    *structs.ACLCache[*acl.ACL]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "59:  if cfg.Logger == nil {",
          "60:   cfg.Logger = hclog.NewNullLogger()",
          "61:  }",
          "",
          "[Removed Lines]",
          "58: func NewEventBroker(ctx context.Context, aclDelegate ACLDelegate, cfg EventBrokerCfg) (*EventBroker, error) {",
          "",
          "[Added Lines]",
          "51: func NewEventBroker(ctx context.Context, cfg EventBrokerCfg) (*EventBroker, error) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "68:  buffer := newEventBuffer(cfg.EventBufferSize)",
          "69:  e := &EventBroker{",
          "76:   subscriptions: &subscriptions{",
          "77:    byToken: make(map[string]map[*SubscribeRequest]*Subscription),",
          "78:   },",
          "",
          "[Removed Lines]",
          "70:   logger:      cfg.Logger.Named(\"event_broker\"),",
          "71:   eventBuf:    buffer,",
          "72:   publishCh:   make(chan *structs.Events, 64),",
          "73:   aclCh:       make(chan structs.Event, 10),",
          "74:   aclDelegate: aclDelegate,",
          "75:   aclCache:    structs.NewACLCache[*acl.ACL](aclCacheSize),",
          "",
          "[Added Lines]",
          "63:   logger:    cfg.Logger.Named(\"event_broker\"),",
          "64:   eventBuf:  buffer,",
          "65:   publishCh: make(chan *structs.Events, 64),",
          "66:   aclCh:     make(chan structs.Event, 10),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "100:  for _, event := range events.Events {",
          "102:    e.aclCh <- event",
          "103:   }",
          "104:  }",
          "",
          "[Removed Lines]",
          "101:   if event.Topic == structs.TopicACLToken || event.Topic == structs.TopicACLPolicy {",
          "",
          "[Added Lines]",
          "92:   if event.Topic == structs.TopicACLToken || event.Topic == structs.TopicACLPolicy || event.Topic == structs.TopicACLRole {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "106:  e.publishCh <- events",
          "107: }",
          "",
          "[Removed Lines]",
          "113: func (e *EventBroker) SubscribeWithACLCheck(req *SubscribeRequest) (*Subscription, *time.Time, error) {",
          "114:  aclObj, expiryTime, err := aclObjFromSnapshotForTokenSecretID(e.aclDelegate.TokenProvider(), e.aclCache, req.Token)",
          "115:  if err != nil {",
          "116:   return nil, nil, structs.ErrPermissionDenied",
          "117:  }",
          "119:  if allowed := aclAllowsSubscription(aclObj, req); !allowed {",
          "120:   return nil, nil, structs.ErrPermissionDenied",
          "121:  }",
          "123:  sub, err := e.Subscribe(req)",
          "124:  if err != nil {",
          "125:   return nil, nil, err",
          "126:  }",
          "127:  return sub, expiryTime, nil",
          "128: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "162:  start.link.next.Store(head)",
          "163:  close(start.link.nextCh)",
          "165:  sub := newSubscription(req, start, e.subscriptions.unsubscribeFn(req))",
          "167:  e.subscriptions.add(req, sub)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "135:  if req.Authenticate == nil {",
          "136:   req.Authenticate = func() error {",
          "137:    return nil",
          "138:   }",
          "139:  } else if err := req.Authenticate(); err != nil {",
          "140:   return nil, err",
          "141:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "201:      continue",
          "202:     }",
          "222:     e.subscriptions.closeSubscriptionFunc(tokenSecretID, func(sub *Subscription) bool {",
          "224:     })",
          "226:    case *structs.ACLPolicyEvent, *structs.ACLRoleStreamEvent:",
          "",
          "[Removed Lines]",
          "205:     if e.aclDelegate == nil {",
          "206:      continue",
          "207:     }",
          "209:     aclObj, expiryTime, err := aclObjFromSnapshotForTokenSecretID(e.aclDelegate.TokenProvider(), e.aclCache, tokenSecretID)",
          "210:     if err != nil {",
          "211:      e.logger.Error(\"failed resolving ACL for secretID, closing subscriptions\", \"error\", err)",
          "212:      e.subscriptions.closeSubscriptionsForTokens([]string{tokenSecretID})",
          "213:      continue",
          "214:     }",
          "216:     if expiryTime != nil && expiryTime.Before(time.Now().UTC()) {",
          "217:      e.logger.Info(\"ACL token is expired, closing subscriptions\")",
          "218:      e.subscriptions.closeSubscriptionsForTokens([]string{tokenSecretID})",
          "219:      continue",
          "220:     }",
          "223:      return !aclAllowsSubscription(aclObj, sub.req)",
          "",
          "[Added Lines]",
          "183:      return sub.req.Authenticate() != nil",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "242:  e.mu.Lock()",
          "243:  defer e.mu.Unlock()",
          "251:  for tokenSecretID := range e.subscriptions.byToken {",
          "253:   if tokenSecretID == \"\" {",
          "254:    continue",
          "255:   }",
          "270:   e.subscriptions.closeSubscriptionFunc(tokenSecretID, func(sub *Subscription) bool {",
          "272:   })",
          "273:  }",
          "274: }",
          "386: func (s *Subscription) forceClose() {",
          "387:  if atomic.CompareAndSwapUint32(&s.state, subscriptionStateOpen, subscriptionStateClosed) {",
          "388:   close(s.forceClosed)",
          "",
          "[Removed Lines]",
          "246:  if e.aclDelegate == nil {",
          "247:   return",
          "248:  }",
          "250:  aclSnapshot := e.aclDelegate.TokenProvider()",
          "257:   aclObj, expiryTime, err := aclObjFromSnapshotForTokenSecretID(aclSnapshot, e.aclCache, tokenSecretID)",
          "258:   if err != nil {",
          "259:    e.logger.Debug(\"failed resolving ACL for secretID, closing subscriptions\", \"error\", err)",
          "260:    e.subscriptions.closeSubscriptionsForTokens([]string{tokenSecretID})",
          "261:    continue",
          "262:   }",
          "264:   if expiryTime != nil && expiryTime.Before(time.Now().UTC()) {",
          "265:    e.logger.Info(\"ACL token is expired, closing subscriptions\")",
          "266:    e.subscriptions.closeSubscriptionsForTokens([]string{tokenSecretID})",
          "267:    continue",
          "268:   }",
          "271:    return !aclAllowsSubscription(aclObj, sub.req)",
          "276: func aclObjFromSnapshotForTokenSecretID(",
          "277:  aclSnapshot ACLTokenProvider, aclCache *structs.ACLCache[*acl.ACL], tokenSecretID string) (",
          "280:  aclToken, err := aclSnapshot.ACLTokenBySecretID(nil, tokenSecretID)",
          "281:  if err != nil {",
          "282:   return nil, nil, err",
          "283:  }",
          "285:  if aclToken == nil {",
          "286:   return nil, nil, structs.ErrTokenNotFound",
          "287:  }",
          "288:  if aclToken.IsExpired(time.Now().UTC()) {",
          "289:   return nil, nil, structs.ErrTokenExpired",
          "290:  }",
          "293:  if aclToken.Type == structs.ACLManagementToken {",
          "294:   return acl.ManagementACL, aclToken.ExpirationTime, nil",
          "295:  }",
          "297:  aclPolicies := make([]*structs.ACLPolicy, 0, len(aclToken.Policies)+len(aclToken.Roles))",
          "299:  for _, policyName := range aclToken.Policies {",
          "300:   policy, err := aclSnapshot.ACLPolicyByName(nil, policyName)",
          "301:   if err != nil {",
          "302:    return nil, nil, errors.New(\"error finding acl policy\")",
          "303:   }",
          "304:   if policy == nil {",
          "307:    continue",
          "308:   }",
          "309:   aclPolicies = append(aclPolicies, policy)",
          "310:  }",
          "314:  for _, roleLink := range aclToken.Roles {",
          "316:   role, err := aclSnapshot.GetACLRoleByID(nil, roleLink.ID)",
          "317:   if err != nil {",
          "318:    return nil, nil, err",
          "319:   }",
          "320:   if role == nil {",
          "321:    continue",
          "322:   }",
          "324:   for _, policyLink := range role.Policies {",
          "325:    policy, err := aclSnapshot.ACLPolicyByName(nil, policyLink.Name)",
          "326:    if err != nil {",
          "327:     return nil, nil, errors.New(\"error finding acl policy\")",
          "328:    }",
          "329:    if policy == nil {",
          "332:     continue",
          "333:    }",
          "334:    aclPolicies = append(aclPolicies, policy)",
          "335:   }",
          "336:  }",
          "338:  aclObj, err := structs.CompileACLObject(aclCache, aclPolicies)",
          "339:  if err != nil {",
          "340:   return nil, nil, err",
          "341:  }",
          "342:  return aclObj, aclToken.ExpirationTime, nil",
          "343: }",
          "345: type ACLTokenProvider interface {",
          "346:  ACLTokenBySecretID(ws memdb.WatchSet, secretID string) (*structs.ACLToken, error)",
          "347:  ACLPolicyByName(ws memdb.WatchSet, policyName string) (*structs.ACLPolicy, error)",
          "348:  GetACLRoleByID(ws memdb.WatchSet, roleID string) (*structs.ACLRole, error)",
          "349: }",
          "351: type ACLDelegate interface {",
          "352:  TokenProvider() ACLTokenProvider",
          "353: }",
          "355: func aclAllowsSubscription(aclObj *acl.ACL, subReq *SubscribeRequest) bool {",
          "356:  for topic := range subReq.Topics {",
          "357:   switch topic {",
          "358:   case structs.TopicDeployment,",
          "359:    structs.TopicEvaluation,",
          "360:    structs.TopicAllocation,",
          "361:    structs.TopicJob,",
          "362:    structs.TopicService:",
          "363:    if ok := aclObj.AllowNsOp(subReq.Namespace, acl.NamespaceCapabilityReadJob); !ok {",
          "364:     return false",
          "365:    }",
          "366:   case structs.TopicNode:",
          "367:    if ok := aclObj.AllowNodeRead(); !ok {",
          "368:     return false",
          "369:    }",
          "370:   case structs.TopicNodePool:",
          "373:    if ok := aclObj.IsManagement(); !ok {",
          "374:     return false",
          "375:    }",
          "376:   default:",
          "377:    if ok := aclObj.IsManagement(); !ok {",
          "378:     return false",
          "379:    }",
          "380:   }",
          "381:  }",
          "383:  return true",
          "384: }",
          "",
          "[Added Lines]",
          "212:    return sub.req.Authenticate() != nil",
          "",
          "---------------"
        ],
        "nomad/stream/event_broker_test.go||nomad/stream/event_broker_test.go": [
          "File: nomad/stream/event_broker_test.go -> nomad/stream/event_broker_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:  \"testing\"",
          "10:  \"time\"",
          "14:  \"github.com/hashicorp/nomad/ci\"",
          "18:  \"github.com/hashicorp/nomad/nomad/structs\"",
          "21:  \"github.com/stretchr/testify/require\"",
          "22: )",
          "",
          "[Removed Lines]",
          "12:  \"github.com/hashicorp/go-memdb\"",
          "13:  \"github.com/hashicorp/nomad/acl\"",
          "15:  \"github.com/hashicorp/nomad/helper/pointer\"",
          "16:  \"github.com/hashicorp/nomad/helper/uuid\"",
          "17:  \"github.com/hashicorp/nomad/nomad/mock\"",
          "19:  \"github.com/shoenig/test/must\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32:  ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)",
          "33:  defer cancel()",
          "36:  require.NoError(t, err)",
          "38:  sub, err := publisher.Subscribe(subscription)",
          "",
          "[Removed Lines]",
          "35:  publisher, err := NewEventBroker(ctx, nil, EventBrokerCfg{EventBufferSize: 100})",
          "",
          "[Added Lines]",
          "29:  publisher, err := NewEventBroker(ctx, EventBrokerCfg{EventBufferSize: 100})",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:  ctx, cancel := context.WithCancel(context.Background())",
          "81:  t.Cleanup(cancel)",
          "84:  require.NoError(t, err)",
          "86:  sub1, err := publisher.Subscribe(&SubscribeRequest{})",
          "",
          "[Removed Lines]",
          "83:  publisher, err := NewEventBroker(ctx, nil, EventBrokerCfg{})",
          "",
          "[Added Lines]",
          "77:  publisher, err := NewEventBroker(ctx, EventBrokerCfg{})",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:  ctx, cancel := context.WithCancel(context.Background())",
          "112:  t.Cleanup(cancel)",
          "115:  require.NoError(t, err)",
          "",
          "[Removed Lines]",
          "114:  publisher, err := NewEventBroker(ctx, nil, EventBrokerCfg{})",
          "",
          "[Added Lines]",
          "108:  publisher, err := NewEventBroker(ctx, EventBrokerCfg{})",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "129:  require.Equal(t, subscriptionStateOpen, atomic.LoadUint32(&sub2.state))",
          "130: }",
          "133:  ci.Parallel(t)",
          "215:  }{",
          "216:   {",
          "221:    event: structs.Event{",
          "231:     Topic:   structs.TopicACLToken,",
          "233:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "234:    },",
          "235:   },",
          "236:   {",
          "241:    event: structs.Event{",
          "251:     Topic:   structs.TopicACLToken,",
          "252:     Type:    structs.TypeACLTokenUpserted,",
          "253:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "254:    },",
          "255:   },",
          "256:   {",
          "261:    event: structs.Event{",
          "271:     Topic:   structs.TopicACLToken,",
          "272:     Type:    structs.TypeACLTokenUpserted,",
          "273:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "274:    },",
          "275:   },",
          "276:   {",
          "281:    event: structs.Event{",
          "431:     Topic: structs.TopicACLPolicy,",
          "433:     Payload: &structs.ACLPolicyEvent{",
          "434:      ACLPolicy: &structs.ACLPolicy{",
          "435:       Name: \"some-policy\",",
          "436:      },",
          "437:     },",
          "438:    },",
          "439:   },",
          "440:   {",
          "445:    event: structs.Event{",
          "455:     Topic: structs.TopicACLPolicy,",
          "456:     Type:  structs.TypeACLPolicyUpserted,",
          "457:     Payload: &structs.ACLPolicyEvent{",
          "",
          "[Removed Lines]",
          "132: func TestEventBroker_handleACLUpdates_TokenDeleted(t *testing.T) {",
          "135:  ctx, cancel := context.WithCancel(context.Background())",
          "136:  t.Cleanup(cancel)",
          "138:  publisher, err := NewEventBroker(ctx, nil, EventBrokerCfg{})",
          "139:  require.NoError(t, err)",
          "141:  sub1, err := publisher.Subscribe(&SubscribeRequest{",
          "142:   Topics: map[structs.Topic][]string{",
          "143:    \"*\": {\"*\"},",
          "144:   },",
          "145:   Token: \"foo\",",
          "146:  })",
          "147:  require.NoError(t, err)",
          "148:  defer sub1.Unsubscribe()",
          "150:  aclEvent := structs.Event{",
          "151:   Topic:   structs.TopicACLToken,",
          "152:   Type:    structs.TypeACLTokenDeleted,",
          "153:   Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: \"foo\"}),",
          "154:  }",
          "156:  publisher.Publish(&structs.Events{Index: 100, Events: []structs.Event{aclEvent}})",
          "157:  for {",
          "158:   _, err := sub1.Next(ctx)",
          "159:   if err == ErrSubscriptionClosed {",
          "160:    break",
          "161:   }",
          "162:  }",
          "164:  out, err := sub1.Next(ctx)",
          "165:  require.Error(t, err)",
          "166:  require.Equal(t, ErrSubscriptionClosed, err)",
          "167:  require.Equal(t, structs.Events{}, out)",
          "168: }",
          "170: type fakeACLDelegate struct {",
          "171:  tokenProvider ACLTokenProvider",
          "172: }",
          "174: func (d *fakeACLDelegate) TokenProvider() ACLTokenProvider {",
          "175:  return d.tokenProvider",
          "176: }",
          "178: type fakeACLTokenProvider struct {",
          "179:  policy    *structs.ACLPolicy",
          "180:  policyErr error",
          "181:  token     *structs.ACLToken",
          "182:  tokenErr  error",
          "183:  role      *structs.ACLRole",
          "184:  roleErr   error",
          "185: }",
          "187: func (p *fakeACLTokenProvider) ACLTokenBySecretID(_ memdb.WatchSet, _ string) (*structs.ACLToken, error) {",
          "188:  return p.token, p.tokenErr",
          "189: }",
          "191: func (p *fakeACLTokenProvider) ACLPolicyByName(_ memdb.WatchSet, _ string) (*structs.ACLPolicy, error) {",
          "192:  return p.policy, p.policyErr",
          "193: }",
          "195: func (p *fakeACLTokenProvider) GetACLRoleByID(_ memdb.WatchSet, _ string) (*structs.ACLRole, error) {",
          "196:  return p.role, p.roleErr",
          "197: }",
          "199: func TestEventBroker_handleACLUpdates_policyUpdated(t *testing.T) {",
          "200:  ci.Parallel(t)",
          "202:  ctx, cancel := context.WithCancel(context.Background())",
          "203:  t.Cleanup(cancel)",
          "205:  secretID := \"some-secret-id\"",
          "206:  cases := []struct {",
          "207:   policyBeforeRules string",
          "208:   policyAfterRules  string",
          "209:   topics            map[structs.Topic][]string",
          "210:   desc              string",
          "211:   event             structs.Event",
          "212:   policyEvent       structs.Event",
          "213:   shouldUnsubscribe bool",
          "214:   initialSubErr     bool",
          "217:    desc:              \"subscribed to deployments and removed access\",",
          "218:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "219:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{}),",
          "220:    shouldUnsubscribe: true,",
          "222:     Topic: structs.TopicDeployment,",
          "223:     Type:  structs.TypeDeploymentUpdate,",
          "224:     Payload: structs.DeploymentEvent{",
          "225:      Deployment: &structs.Deployment{",
          "226:       ID: \"some-id\",",
          "227:      },",
          "228:     },",
          "229:    },",
          "230:    policyEvent: structs.Event{",
          "232:     Type:    structs.TypeACLTokenUpserted,",
          "237:    desc:              \"subscribed to evals and removed access\",",
          "238:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "239:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{}),",
          "240:    shouldUnsubscribe: true,",
          "242:     Topic: structs.TopicEvaluation,",
          "243:     Type:  structs.TypeEvalUpdated,",
          "244:     Payload: structs.EvaluationEvent{",
          "245:      Evaluation: &structs.Evaluation{",
          "246:       ID: \"some-id\",",
          "247:      },",
          "248:     },",
          "249:    },",
          "250:    policyEvent: structs.Event{",
          "257:    desc:              \"subscribed to allocs and removed access\",",
          "258:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "259:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{}),",
          "260:    shouldUnsubscribe: true,",
          "262:     Topic: structs.TopicAllocation,",
          "263:     Type:  structs.TypeAllocationUpdated,",
          "264:     Payload: structs.AllocationEvent{",
          "265:      Allocation: &structs.Allocation{",
          "266:       ID: \"some-id\",",
          "267:      },",
          "268:     },",
          "269:    },",
          "270:    policyEvent: structs.Event{",
          "277:    desc:              \"subscribed to nodes and removed access\",",
          "278:    policyBeforeRules: mock.NodePolicy(acl.PolicyRead),",
          "279:    policyAfterRules:  mock.NodePolicy(acl.PolicyDeny),",
          "280:    shouldUnsubscribe: true,",
          "282:     Topic: structs.TopicNode,",
          "283:     Type:  structs.TypeNodeRegistration,",
          "284:     Payload: structs.NodeStreamEvent{",
          "285:      Node: &structs.Node{",
          "286:       ID: \"some-id\",",
          "287:      },",
          "288:     },",
          "289:    },",
          "290:    policyEvent: structs.Event{",
          "291:     Topic:   structs.TopicACLToken,",
          "292:     Type:    structs.TypeACLTokenUpserted,",
          "293:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "294:    },",
          "295:   },",
          "296:   {",
          "297:    desc:              \"subscribed to evals in all namespaces and removed access\",",
          "298:    policyBeforeRules: mock.NamespacePolicy(\"*\", \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "299:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "300:    shouldUnsubscribe: true,",
          "301:    event: structs.Event{",
          "302:     Topic:     structs.TopicEvaluation,",
          "303:     Type:      structs.TypeEvalUpdated,",
          "304:     Namespace: \"foo\",",
          "305:     Payload: structs.EvaluationEvent{",
          "306:      Evaluation: &structs.Evaluation{",
          "307:       ID: \"some-id\",",
          "308:      },",
          "309:     },",
          "310:    },",
          "311:    policyEvent: structs.Event{",
          "312:     Topic:   structs.TopicACLToken,",
          "313:     Type:    structs.TypeACLTokenUpserted,",
          "314:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "315:    },",
          "316:   },",
          "317:   {",
          "318:    desc:              \"subscribed to deployments and no access change\",",
          "319:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "320:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "321:    shouldUnsubscribe: false,",
          "322:    event: structs.Event{",
          "323:     Topic: structs.TopicDeployment,",
          "324:     Type:  structs.TypeDeploymentUpdate,",
          "325:     Payload: structs.DeploymentEvent{",
          "326:      Deployment: &structs.Deployment{",
          "327:       ID: \"some-id\",",
          "328:      },",
          "329:     },",
          "330:    },",
          "331:    policyEvent: structs.Event{",
          "332:     Topic:   structs.TopicACLToken,",
          "333:     Type:    structs.TypeACLTokenUpserted,",
          "334:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "335:    },",
          "336:   },",
          "337:   {",
          "338:    desc:              \"subscribed to evals and no access change\",",
          "339:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "340:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "341:    shouldUnsubscribe: false,",
          "342:    event: structs.Event{",
          "343:     Topic: structs.TopicEvaluation,",
          "344:     Type:  structs.TypeEvalUpdated,",
          "345:     Payload: structs.EvaluationEvent{",
          "346:      Evaluation: &structs.Evaluation{",
          "347:       ID: \"some-id\",",
          "348:      },",
          "349:     },",
          "350:    },",
          "351:    policyEvent: structs.Event{",
          "352:     Topic:   structs.TopicACLToken,",
          "353:     Type:    structs.TypeACLTokenUpserted,",
          "354:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "355:    },",
          "356:   },",
          "357:   {",
          "358:    desc:              \"subscribed to allocs and no access change\",",
          "359:    policyBeforeRules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "360:    policyAfterRules:  mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "361:    shouldUnsubscribe: false,",
          "362:    event: structs.Event{",
          "363:     Topic: structs.TopicAllocation,",
          "364:     Type:  structs.TypeAllocationUpdated,",
          "365:     Payload: structs.AllocationEvent{",
          "366:      Allocation: &structs.Allocation{",
          "367:       ID: \"some-id\",",
          "368:      },",
          "369:     },",
          "370:    },",
          "371:    policyEvent: structs.Event{",
          "372:     Topic:   structs.TopicACLToken,",
          "373:     Type:    structs.TypeACLTokenUpserted,",
          "374:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "375:    },",
          "376:   },",
          "377:   {",
          "378:    desc:              \"subscribed to nodes and no access change\",",
          "379:    policyBeforeRules: mock.NodePolicy(acl.PolicyRead),",
          "380:    policyAfterRules:  mock.NodePolicy(acl.PolicyRead),",
          "381:    shouldUnsubscribe: false,",
          "382:    event: structs.Event{",
          "383:     Topic: structs.TopicNode,",
          "384:     Type:  structs.TypeNodeRegistration,",
          "385:     Payload: structs.NodeStreamEvent{",
          "386:      Node: &structs.Node{",
          "387:       ID: \"some-id\",",
          "388:      },",
          "389:     },",
          "390:    },",
          "391:    policyEvent: structs.Event{",
          "392:     Topic:   structs.TopicACLToken,",
          "393:     Type:    structs.TypeACLTokenUpserted,",
          "394:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "395:    },",
          "396:   },",
          "397:   {",
          "398:    desc:              \"initial token insufficient privileges\",",
          "399:    initialSubErr:     true,",
          "400:    policyBeforeRules: mock.NodePolicy(acl.PolicyDeny),",
          "401:    event: structs.Event{",
          "402:     Topic: structs.TopicNode,",
          "403:     Type:  structs.TypeNodeRegistration,",
          "404:     Payload: structs.NodeStreamEvent{",
          "405:      Node: &structs.Node{",
          "406:       ID: \"some-id\",",
          "407:      },",
          "408:     },",
          "409:    },",
          "410:    policyEvent: structs.Event{",
          "411:     Topic:   structs.TopicACLToken,",
          "412:     Type:    structs.TypeACLTokenUpserted,",
          "413:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: secretID}),",
          "414:    },",
          "415:   },",
          "416:   {",
          "417:    desc:              \"subscribed to nodes and policy change no change\",",
          "418:    policyBeforeRules: mock.NodePolicy(acl.PolicyRead),",
          "419:    policyAfterRules:  mock.NodePolicy(acl.PolicyWrite),",
          "420:    shouldUnsubscribe: false,",
          "421:    event: structs.Event{",
          "422:     Topic: structs.TopicNode,",
          "423:     Type:  structs.TypeNodeRegistration,",
          "424:     Payload: structs.NodeStreamEvent{",
          "425:      Node: &structs.Node{",
          "426:       ID: \"some-id\",",
          "427:      },",
          "428:     },",
          "429:    },",
          "430:    policyEvent: structs.Event{",
          "432:     Type:  structs.TypeACLPolicyUpserted,",
          "441:    desc:              \"subscribed to nodes and policy change no access\",",
          "442:    policyBeforeRules: mock.NodePolicy(acl.PolicyRead),",
          "443:    policyAfterRules:  mock.NodePolicy(acl.PolicyDeny),",
          "444:    shouldUnsubscribe: true,",
          "446:     Topic: structs.TopicNode,",
          "447:     Type:  structs.TypeNodeRegistration,",
          "448:     Payload: structs.NodeStreamEvent{",
          "449:      Node: &structs.Node{",
          "450:       ID: \"some-id\",",
          "451:      },",
          "452:     },",
          "453:    },",
          "454:    policyEvent: structs.Event{",
          "",
          "[Added Lines]",
          "126: func TestEventBroker_handleACLUpdates(t *testing.T) {",
          "129:  secretID := \"1234\"",
          "131:  testCases := []struct {",
          "132:   name           string",
          "133:   event          structs.Event",
          "134:   shouldPassAuth bool",
          "137:    name: \"token deleted\",",
          "140:     Type:    structs.TypeACLTokenDeleted,",
          "143:    shouldPassAuth: false, // shouldn't matter in token delete event",
          "146:    name: \"token updated - auth passes\",",
          "152:    shouldPassAuth: false,",
          "155:    name: \"token updated - auth fails\",",
          "161:    shouldPassAuth: true,",
          "164:    name: \"policy deleted\",",
          "167:     Type:  structs.TypeACLPolicyDeleted,",
          "174:    shouldPassAuth: false,",
          "177:    name: \"policy updated - auth passes\",",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "460:      },",
          "461:     },",
          "462:    },",
          "463:   },",
          "464:   {",
          "469:    event: structs.Event{",
          "479:     Topic: structs.TopicACLPolicy,",
          "481:     Payload: &structs.ACLPolicyEvent{",
          "482:      ACLPolicy: &structs.ACLPolicy{",
          "483:       Name: \"some-policy\",",
          "484:      },",
          "485:     },",
          "486:    },",
          "659:   },",
          "660:   {",
          "691:    event: structs.Event{",
          "744:    },",
          "745:   },",
          "746:   {",
          "757:    event: structs.Event{",
          "766:    },",
          "767:   },",
          "768:   {",
          "777:    event: structs.Event{",
          "806:      },",
          "807:     },",
          "911:    },",
          "913:   },",
          "914:  }",
          "988:    }",
          "1071:  }",
          "1073: }",
          "1075: func consumeSubscription(ctx context.Context, sub *Subscription) <-chan subNextResult {",
          "",
          "[Removed Lines]",
          "465:    desc:              \"subscribed to nodes policy deleted\",",
          "466:    policyBeforeRules: mock.NodePolicy(acl.PolicyRead),",
          "467:    policyAfterRules:  \"\",",
          "468:    shouldUnsubscribe: true,",
          "470:     Topic: structs.TopicNode,",
          "471:     Type:  structs.TypeNodeRegistration,",
          "472:     Payload: structs.NodeStreamEvent{",
          "473:      Node: &structs.Node{",
          "474:       ID: \"some-id\",",
          "475:      },",
          "476:     },",
          "477:    },",
          "478:    policyEvent: structs.Event{",
          "480:     Type:  structs.TypeACLPolicyDeleted,",
          "487:   },",
          "488:  }",
          "490:  for _, tc := range cases {",
          "491:   t.Run(tc.desc, func(t *testing.T) {",
          "493:    policy := &structs.ACLPolicy{",
          "494:     Name:  \"some-policy\",",
          "495:     Rules: tc.policyBeforeRules,",
          "496:    }",
          "497:    policy.SetHash()",
          "499:    tokenProvider := &fakeACLTokenProvider{",
          "500:     policy: policy,",
          "501:     token: &structs.ACLToken{",
          "502:      SecretID: secretID,",
          "503:      Policies: []string{policy.Name},",
          "504:     },",
          "505:    }",
          "507:    aclDelegate := &fakeACLDelegate{",
          "508:     tokenProvider: tokenProvider,",
          "509:    }",
          "511:    publisher, err := NewEventBroker(ctx, aclDelegate, EventBrokerCfg{})",
          "512:    require.NoError(t, err)",
          "514:    var ns string",
          "515:    if tc.event.Namespace != \"\" {",
          "516:     ns = tc.event.Namespace",
          "517:    } else {",
          "518:     ns = structs.DefaultNamespace",
          "519:    }",
          "521:    sub, expiryTime, err := publisher.SubscribeWithACLCheck(&SubscribeRequest{",
          "522:     Topics: map[structs.Topic][]string{",
          "523:      tc.event.Topic: {\"*\"},",
          "524:     },",
          "525:     Namespace: ns,",
          "526:     Token:     secretID,",
          "527:    })",
          "528:    require.Nil(t, expiryTime)",
          "530:    if tc.initialSubErr {",
          "531:     require.Error(t, err)",
          "532:     require.Nil(t, sub)",
          "533:     return",
          "534:    } else {",
          "535:     require.NoError(t, err)",
          "536:    }",
          "537:    publisher.Publish(&structs.Events{Index: 100, Events: []structs.Event{tc.event}})",
          "539:    ctx, cancel := context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "540:    defer cancel()",
          "541:    _, err = sub.Next(ctx)",
          "542:    require.NoError(t, err)",
          "545:    policyAfter := &structs.ACLPolicy{",
          "546:     Name:        \"some-new-policy\",",
          "547:     Rules:       tc.policyAfterRules,",
          "548:     ModifyIndex: 101, // The ModifyIndex is used to caclulate the acl cache key",
          "549:    }",
          "550:    policyAfter.SetHash()",
          "552:    tokenProvider.policy = policyAfter",
          "555:    publisher.Publish(&structs.Events{Index: 101, Events: []structs.Event{tc.policyEvent}})",
          "557:    publisher.Publish(&structs.Events{Index: 102, Events: []structs.Event{tc.event}})",
          "561:    ctx, cancel = context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "562:    defer cancel()",
          "563:    if tc.shouldUnsubscribe {",
          "564:     for {",
          "565:      _, err = sub.Next(ctx)",
          "566:      if err != nil {",
          "567:       if err == context.DeadlineExceeded {",
          "568:        require.Fail(t, err.Error())",
          "569:       }",
          "570:       if err == ErrSubscriptionClosed {",
          "571:        break",
          "572:       }",
          "573:      }",
          "574:     }",
          "575:    } else {",
          "576:     _, err = sub.Next(ctx)",
          "577:     require.NoError(t, err)",
          "578:    }",
          "580:    publisher.Publish(&structs.Events{Index: 103, Events: []structs.Event{tc.event}})",
          "582:    ctx, cancel = context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "583:    defer cancel()",
          "584:    _, err = sub.Next(ctx)",
          "585:    if tc.shouldUnsubscribe {",
          "586:     require.Equal(t, ErrSubscriptionClosed, err)",
          "587:    } else {",
          "588:     require.NoError(t, err)",
          "589:    }",
          "590:   })",
          "591:  }",
          "592: }",
          "594: func TestEventBroker_handleACLUpdates_roleUpdated(t *testing.T) {",
          "595:  ci.Parallel(t)",
          "597:  ctx, cancel := context.WithCancel(context.Background())",
          "598:  t.Cleanup(cancel)",
          "602:  tokenSecretID := uuid.Generate()",
          "603:  roleID := uuid.Generate()",
          "605:  cases := []struct {",
          "606:   name                  string",
          "607:   aclPolicy             *structs.ACLPolicy",
          "608:   roleBeforePolicyLinks []*structs.ACLRolePolicyLink",
          "609:   roleAfterPolicyLinks  []*structs.ACLRolePolicyLink",
          "610:   topics                map[structs.Topic][]string",
          "611:   event                 structs.Event",
          "612:   policyEvent           structs.Event",
          "613:   shouldUnsubscribe     bool",
          "614:   initialSubErr         bool",
          "615:  }{",
          "616:   {",
          "617:    name: \"deployments access policy link removed\",",
          "618:    aclPolicy: &structs.ACLPolicy{",
          "619:     Name: \"test-event-broker-acl-policy\",",
          "620:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "621:      acl.NamespaceCapabilityReadJob},",
          "622:     ),",
          "623:    },",
          "624:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "625:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{},",
          "626:    shouldUnsubscribe:     true,",
          "627:    event: structs.Event{",
          "628:     Topic:   structs.TopicDeployment,",
          "629:     Type:    structs.TypeDeploymentUpdate,",
          "630:     Payload: structs.DeploymentEvent{Deployment: &structs.Deployment{}},",
          "631:    },",
          "632:    policyEvent: structs.Event{",
          "633:     Topic:   structs.TopicACLToken,",
          "634:     Type:    structs.TypeACLTokenUpserted,",
          "635:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "636:    },",
          "637:   },",
          "638:   {",
          "639:    name: \"evaluations access policy link removed\",",
          "640:    aclPolicy: &structs.ACLPolicy{",
          "641:     Name: \"test-event-broker-acl-policy\",",
          "642:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "643:      acl.NamespaceCapabilityReadJob},",
          "644:     ),",
          "645:    },",
          "646:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "647:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{},",
          "648:    shouldUnsubscribe:     true,",
          "649:    event: structs.Event{",
          "650:     Topic:   structs.TopicEvaluation,",
          "651:     Type:    structs.TypeEvalUpdated,",
          "652:     Payload: structs.EvaluationEvent{Evaluation: &structs.Evaluation{}},",
          "653:    },",
          "654:    policyEvent: structs.Event{",
          "655:     Topic:   structs.TopicACLToken,",
          "656:     Type:    structs.TypeACLTokenUpserted,",
          "657:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "658:    },",
          "661:    name: \"allocations access policy link removed\",",
          "662:    aclPolicy: &structs.ACLPolicy{",
          "663:     Name: \"test-event-broker-acl-policy\",",
          "664:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "665:      acl.NamespaceCapabilityReadJob},",
          "666:     ),",
          "667:    },",
          "668:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "669:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{},",
          "670:    shouldUnsubscribe:     true,",
          "671:    event: structs.Event{",
          "672:     Topic:   structs.TopicAllocation,",
          "673:     Type:    structs.TypeAllocationUpdated,",
          "674:     Payload: structs.AllocationEvent{Allocation: &structs.Allocation{}},",
          "675:    },",
          "676:    policyEvent: structs.Event{",
          "677:     Topic:   structs.TopicACLToken,",
          "678:     Type:    structs.TypeACLTokenUpserted,",
          "679:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "680:    },",
          "681:   },",
          "682:   {",
          "683:    name: \"nodes access policy link removed\",",
          "684:    aclPolicy: &structs.ACLPolicy{",
          "685:     Name:  \"test-event-broker-acl-policy\",",
          "686:     Rules: mock.NodePolicy(acl.PolicyRead),",
          "687:    },",
          "688:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "689:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{},",
          "690:    shouldUnsubscribe:     true,",
          "692:     Topic:   structs.TopicNode,",
          "693:     Type:    structs.TypeNodeRegistration,",
          "694:     Payload: structs.NodeStreamEvent{Node: &structs.Node{}},",
          "695:    },",
          "696:    policyEvent: structs.Event{",
          "697:     Topic:   structs.TopicACLToken,",
          "698:     Type:    structs.TypeACLTokenUpserted,",
          "699:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "700:    },",
          "701:   },",
          "702:   {",
          "703:    name: \"deployment access no change\",",
          "704:    aclPolicy: &structs.ACLPolicy{",
          "705:     Name: \"test-event-broker-acl-policy\",",
          "706:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "707:      acl.NamespaceCapabilityReadJob},",
          "708:     ),",
          "709:    },",
          "710:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "711:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "712:    shouldUnsubscribe:     false,",
          "713:    event: structs.Event{",
          "714:     Topic:   structs.TopicDeployment,",
          "715:     Type:    structs.TypeDeploymentUpdate,",
          "716:     Payload: structs.DeploymentEvent{Deployment: &structs.Deployment{}},",
          "717:    },",
          "718:    policyEvent: structs.Event{",
          "719:     Topic:   structs.TopicACLToken,",
          "720:     Type:    structs.TypeACLTokenUpserted,",
          "721:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "722:    },",
          "723:   },",
          "724:   {",
          "725:    name: \"evaluations access no change\",",
          "726:    aclPolicy: &structs.ACLPolicy{",
          "727:     Name: \"test-event-broker-acl-policy\",",
          "728:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "729:      acl.NamespaceCapabilityReadJob},",
          "730:     ),",
          "731:    },",
          "732:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "733:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "734:    shouldUnsubscribe:     false,",
          "735:    event: structs.Event{",
          "736:     Topic:   structs.TopicEvaluation,",
          "737:     Type:    structs.TypeEvalUpdated,",
          "738:     Payload: structs.EvaluationEvent{Evaluation: &structs.Evaluation{}},",
          "739:    },",
          "740:    policyEvent: structs.Event{",
          "741:     Topic:   structs.TopicACLToken,",
          "742:     Type:    structs.TypeACLTokenUpserted,",
          "743:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "747:    name: \"allocations access no change\",",
          "748:    aclPolicy: &structs.ACLPolicy{",
          "749:     Name: \"test-event-broker-acl-policy\",",
          "750:     Rules: mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{",
          "751:      acl.NamespaceCapabilityReadJob},",
          "752:     ),",
          "753:    },",
          "754:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "755:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "756:    shouldUnsubscribe:     false,",
          "758:     Topic:   structs.TopicAllocation,",
          "759:     Type:    structs.TypeAllocationUpdated,",
          "760:     Payload: structs.AllocationEvent{Allocation: &structs.Allocation{}},",
          "761:    },",
          "762:    policyEvent: structs.Event{",
          "763:     Topic:   structs.TopicACLToken,",
          "764:     Type:    structs.TypeACLTokenUpserted,",
          "765:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "769:    name: \"nodes access no change\",",
          "770:    aclPolicy: &structs.ACLPolicy{",
          "771:     Name:  \"test-event-broker-acl-policy\",",
          "772:     Rules: mock.NodePolicy(acl.PolicyRead),",
          "773:    },",
          "774:    roleBeforePolicyLinks: []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "775:    roleAfterPolicyLinks:  []*structs.ACLRolePolicyLink{{Name: \"test-event-broker-acl-policy\"}},",
          "776:    shouldUnsubscribe:     false,",
          "778:     Topic:   structs.TopicNode,",
          "779:     Type:    structs.TypeNodeRegistration,",
          "780:     Payload: structs.NodeStreamEvent{Node: &structs.Node{}},",
          "781:    },",
          "782:    policyEvent: structs.Event{",
          "783:     Topic:   structs.TopicACLToken,",
          "784:     Type:    structs.TypeACLTokenUpserted,",
          "785:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tokenSecretID}),",
          "786:    },",
          "787:   },",
          "788:  }",
          "790:  for _, tc := range cases {",
          "791:   t.Run(tc.name, func(t *testing.T) {",
          "796:    tokenProvider := &fakeACLTokenProvider{",
          "797:     policy: tc.aclPolicy,",
          "798:     token: &structs.ACLToken{",
          "799:      SecretID: tokenSecretID,",
          "800:      Roles:    []*structs.ACLTokenRoleLink{{ID: roleID}},",
          "801:     },",
          "802:     role: &structs.ACLRole{",
          "803:      ID: uuid.Short(),",
          "804:      Policies: []*structs.ACLRolePolicyLink{",
          "805:       {Name: tc.aclPolicy.Name},",
          "808:    }",
          "809:    aclDelegate := &fakeACLDelegate{tokenProvider: tokenProvider}",
          "811:    publisher, err := NewEventBroker(ctx, aclDelegate, EventBrokerCfg{})",
          "812:    require.NoError(t, err)",
          "814:    ns := structs.DefaultNamespace",
          "815:    if tc.event.Namespace != \"\" {",
          "816:     ns = tc.event.Namespace",
          "817:    }",
          "819:    sub, expiryTime, err := publisher.SubscribeWithACLCheck(&SubscribeRequest{",
          "820:     Topics:    map[structs.Topic][]string{tc.event.Topic: {\"*\"}},",
          "821:     Namespace: ns,",
          "822:     Token:     tokenSecretID,",
          "823:    })",
          "824:    require.Nil(t, expiryTime)",
          "826:    if tc.initialSubErr {",
          "827:     require.Error(t, err)",
          "828:     require.Nil(t, sub)",
          "829:     return",
          "830:    }",
          "832:    require.NoError(t, err)",
          "833:    publisher.Publish(&structs.Events{Index: 100, Events: []structs.Event{tc.event}})",
          "835:    ctx, cancel := context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "836:    defer cancel()",
          "837:    _, err = sub.Next(ctx)",
          "838:    require.NoError(t, err)",
          "842:    tokenProvider.role.Policies = tc.roleAfterPolicyLinks",
          "845:    publisher.Publish(&structs.Events{Index: 101, Events: []structs.Event{tc.policyEvent}})",
          "846:    publisher.Publish(&structs.Events{Index: 102, Events: []structs.Event{tc.event}})",
          "850:    ctx, cancel = context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "851:    defer cancel()",
          "852:    if tc.shouldUnsubscribe {",
          "853:     for {",
          "854:      _, err = sub.Next(ctx)",
          "855:      if err != nil {",
          "856:       if err == context.DeadlineExceeded {",
          "857:        require.Fail(t, err.Error())",
          "858:       }",
          "859:       if err == ErrSubscriptionClosed {",
          "860:        break",
          "861:       }",
          "862:      }",
          "863:     }",
          "864:    } else {",
          "865:     _, err = sub.Next(ctx)",
          "866:     require.NoError(t, err)",
          "867:    }",
          "869:    publisher.Publish(&structs.Events{Index: 103, Events: []structs.Event{tc.event}})",
          "871:    ctx, cancel = context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "872:    defer cancel()",
          "873:    _, err = sub.Next(ctx)",
          "874:    if tc.shouldUnsubscribe {",
          "875:     require.Equal(t, ErrSubscriptionClosed, err)",
          "876:    } else {",
          "877:     require.NoError(t, err)",
          "878:    }",
          "879:   })",
          "880:  }",
          "881: }",
          "883: func TestEventBroker_handleACLUpdates_tokenExpiry(t *testing.T) {",
          "884:  ci.Parallel(t)",
          "886:  ctx, cancel := context.WithCancel(context.Background())",
          "887:  t.Cleanup(cancel)",
          "889:  cases := []struct {",
          "890:   name         string",
          "891:   inputToken   *structs.ACLToken",
          "892:   shouldExpire bool",
          "893:  }{",
          "894:   {",
          "895:    name: \"token does not expire\",",
          "896:    inputToken: &structs.ACLToken{",
          "897:     AccessorID:     uuid.Generate(),",
          "898:     SecretID:       uuid.Generate(),",
          "899:     ExpirationTime: pointer.Of(time.Now().Add(100000 * time.Hour).UTC()),",
          "900:     Type:           structs.ACLManagementToken,",
          "901:    },",
          "902:    shouldExpire: false,",
          "903:   },",
          "904:   {",
          "905:    name: \"token does expire\",",
          "906:    inputToken: &structs.ACLToken{",
          "907:     AccessorID:     uuid.Generate(),",
          "908:     SecretID:       uuid.Generate(),",
          "909:     ExpirationTime: pointer.Of(time.Now().Add(100000 * time.Hour).UTC()),",
          "910:     Type:           structs.ACLManagementToken,",
          "912:    shouldExpire: true,",
          "916:  for _, tc := range cases {",
          "917:   t.Run(tc.name, func(t *testing.T) {",
          "922:    tokenProvider := &fakeACLTokenProvider{token: tc.inputToken}",
          "923:    aclDelegate := &fakeACLDelegate{tokenProvider: tokenProvider}",
          "925:    publisher, err := NewEventBroker(ctx, aclDelegate, EventBrokerCfg{})",
          "926:    require.NoError(t, err)",
          "928:    fakeNodeEvent := structs.Event{",
          "929:     Topic:   structs.TopicNode,",
          "930:     Type:    structs.TypeNodeRegistration,",
          "931:     Payload: structs.NodeStreamEvent{Node: &structs.Node{}},",
          "932:    }",
          "934:    fakeTokenEvent := structs.Event{",
          "935:     Topic:   structs.TopicACLToken,",
          "936:     Type:    structs.TypeACLTokenUpserted,",
          "937:     Payload: structs.NewACLTokenEvent(&structs.ACLToken{SecretID: tc.inputToken.SecretID}),",
          "938:    }",
          "940:    sub, expiryTime, err := publisher.SubscribeWithACLCheck(&SubscribeRequest{",
          "941:     Topics: map[structs.Topic][]string{structs.TopicAll: {\"*\"}},",
          "942:     Token:  tc.inputToken.SecretID,",
          "943:    })",
          "944:    require.NoError(t, err)",
          "945:    require.NotNil(t, sub)",
          "946:    require.NotNil(t, expiryTime)",
          "950:    publisher.Publish(&structs.Events{Index: 100, Events: []structs.Event{fakeNodeEvent}})",
          "952:    ctx, cancel := context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "953:    defer cancel()",
          "954:    _, err = sub.Next(ctx)",
          "955:    require.NoError(t, err)",
          "959:    if tc.shouldExpire {",
          "960:     tokenProvider.token.ExpirationTime = pointer.Of(",
          "961:      time.Date(1987, time.April, 13, 8, 3, 0, 0, time.UTC),",
          "962:     )",
          "963:    }",
          "966:    publisher.Publish(&structs.Events{Index: 101, Events: []structs.Event{fakeTokenEvent}})",
          "967:    publisher.Publish(&structs.Events{Index: 102, Events: []structs.Event{fakeNodeEvent}})",
          "971:    ctx, cancel = context.WithDeadline(ctx, time.Now().Add(100*time.Millisecond))",
          "972:    defer cancel()",
          "974:    if tc.shouldExpire {",
          "975:     for {",
          "976:      if _, err = sub.Next(ctx); err != nil {",
          "977:       if err == context.DeadlineExceeded {",
          "978:        require.Fail(t, err.Error())",
          "979:       }",
          "980:       if err == ErrSubscriptionClosed {",
          "981:        break",
          "982:       }",
          "983:      }",
          "984:     }",
          "985:    } else {",
          "986:     _, err = sub.Next(ctx)",
          "987:     require.NoError(t, err)",
          "989:   })",
          "990:  }",
          "991: }",
          "993: func TestEventBroker_NodePool_ACL(t *testing.T) {",
          "994:  ci.Parallel(t)",
          "996:  ctx, cancel := context.WithCancel(context.Background())",
          "997:  t.Cleanup(cancel)",
          "999:  testCases := []struct {",
          "1000:   name        string",
          "1001:   token       *structs.ACLToken",
          "1002:   policy      *structs.ACLPolicy",
          "1003:   expectedErr string",
          "1004:  }{",
          "1005:   {",
          "1006:    name: \"management token\",",
          "1007:    token: &structs.ACLToken{",
          "1008:     AccessorID: uuid.Generate(),",
          "1009:     SecretID:   uuid.Generate(),",
          "1010:     Type:       structs.ACLManagementToken,",
          "1011:    },",
          "1012:   },",
          "1013:   {",
          "1014:    name: \"client token\",",
          "1015:    token: &structs.ACLToken{",
          "1016:     AccessorID: uuid.Generate(),",
          "1017:     SecretID:   uuid.Generate(),",
          "1018:     Type:       structs.ACLClientToken,",
          "1019:    },",
          "1020:    expectedErr: structs.ErrPermissionDenied.Error(),",
          "1021:   },",
          "1022:   {",
          "1023:    name: \"node pool read\",",
          "1024:    token: &structs.ACLToken{",
          "1025:     AccessorID: uuid.Generate(),",
          "1026:     SecretID:   uuid.Generate(),",
          "1027:     Type:       structs.ACLClientToken,",
          "1028:     Policies:   []string{\"node-pool-read\"},",
          "1029:    },",
          "1030:    policy: &structs.ACLPolicy{",
          "1031:     Name:  \"node-pool-read\",",
          "1032:     Rules: `node_pool \"*\" { policy = \"read\" }`,",
          "1033:    },",
          "1034:    expectedErr: structs.ErrPermissionDenied.Error(),",
          "1035:   },",
          "1036:   {",
          "1037:    name: \"node pool write\",",
          "1038:    token: &structs.ACLToken{",
          "1039:     AccessorID: uuid.Generate(),",
          "1040:     SecretID:   uuid.Generate(),",
          "1041:     Type:       structs.ACLClientToken,",
          "1042:     Policies:   []string{\"node-pool-write\"},",
          "1043:    },",
          "1044:    policy: &structs.ACLPolicy{",
          "1045:     Name:  \"node-pool-write\",",
          "1046:     Rules: `node_pool \"*\" { policy = \"write\" }`,",
          "1047:    },",
          "1048:    expectedErr: structs.ErrPermissionDenied.Error(),",
          "1049:   },",
          "1050:  }",
          "1052:  for _, tc := range testCases {",
          "1053:   t.Run(tc.name, func(t *testing.T) {",
          "1054:    tokenProvider := &fakeACLTokenProvider{token: tc.token, policy: tc.policy}",
          "1055:    aclDelegate := &fakeACLDelegate{tokenProvider: tokenProvider}",
          "1057:    publisher, err := NewEventBroker(ctx, aclDelegate, EventBrokerCfg{})",
          "1058:    must.NoError(t, err)",
          "1060:    _, _, err = publisher.SubscribeWithACLCheck(&SubscribeRequest{",
          "1061:     Topics: map[structs.Topic][]string{structs.TopicNodePool: {\"*\"}},",
          "1062:     Token:  tc.token.SecretID,",
          "1063:    })",
          "1065:    if tc.expectedErr != \"\" {",
          "1066:     must.ErrorContains(t, err, tc.expectedErr)",
          "1067:    } else {",
          "1068:     must.NoError(t, err)",
          "1069:    }",
          "1070:   })",
          "",
          "[Added Lines]",
          "187:    shouldPassAuth: true,",
          "190:    name: \"policy updated - auth fails\",",
          "193:     Type:  structs.TypeACLTokenUpserted,",
          "200:    shouldPassAuth: false,",
          "203:    name: \"role delete\",",
          "205:     Topic: structs.TopicACLRole,",
          "206:     Type:  structs.TypeACLRoleDeleted,",
          "207:     Payload: &structs.ACLRoleStreamEvent{",
          "208:      ACLRole: &structs.ACLRole{",
          "209:       ID: \"1234\",",
          "210:      },",
          "211:     },",
          "213:    shouldPassAuth: false,",
          "216:    name: \"role updated - auth passes\",",
          "218:     Topic: structs.TopicACLRole,",
          "219:     Type:  structs.TypeACLRoleUpserted,",
          "220:     Payload: &structs.ACLRoleStreamEvent{",
          "221:      ACLRole: &structs.ACLRole{",
          "222:       ID: \"1234\",",
          "223:      },",
          "224:     },",
          "226:    shouldPassAuth: true,",
          "229:    name: \"role updated - auth fails\",",
          "231:     Topic: structs.TopicACLRole,",
          "232:     Type:  structs.TypeACLRoleUpserted,",
          "233:     Payload: &structs.ACLRoleStreamEvent{",
          "234:      ACLRole: &structs.ACLRole{",
          "235:       ID: \"1234\",",
          "239:    shouldPassAuth: false,",
          "243:  for _, tc := range testCases {",
          "244:   ctx := context.Background()",
          "246:   publisher, err := NewEventBroker(ctx, EventBrokerCfg{})",
          "247:   require.NoError(t, err)",
          "249:   testSubReq := &SubscribeRequest{",
          "250:    Topics: map[structs.Topic][]string{",
          "251:     \"*\": {\"*\"},",
          "252:    },",
          "253:    Token: secretID,",
          "254:    Authenticate: func() error {",
          "255:     return nil",
          "256:    },",
          "257:   }",
          "259:   sub, err := publisher.Subscribe(testSubReq)",
          "260:   require.NoError(t, err)",
          "262:   if !tc.shouldPassAuth {",
          "263:    testSubReq.Authenticate = func() error {",
          "264:     return structs.ErrPermissionDenied",
          "266:   }",
          "269:   publisher.Publish(&structs.Events{Index: 100, Events: []structs.Event{tc.event}})",
          "271:   _, err = sub.Next(ctx)",
          "273:   ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)",
          "276:   _, err = sub.Next(ctx)",
          "277:   if !tc.shouldPassAuth {",
          "278:    require.ErrorIs(t, err, ErrSubscriptionClosed)",
          "279:   } else {",
          "280:    require.ErrorIs(t, err, context.DeadlineExceeded)",
          "281:   }",
          "283:   sub.Unsubscribe()",
          "284:   cancel()",
          "",
          "---------------"
        ],
        "nomad/stream/subscription.go||nomad/stream/subscription.go": [
          "File: nomad/stream/subscription.go -> nomad/stream/subscription.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  StartExactlyAtIndex bool",
          "62: }",
          "64: func newSubscription(req *SubscribeRequest, item *bufferItem, unsub func()) *Subscription {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:  Authenticate func() error",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "db4a6e4c32f1072def154fcdf6cbab9375798d5f",
      "candidate_info": {
        "commit_hash": "db4a6e4c32f1072def154fcdf6cbab9375798d5f",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/db4a6e4c32f1072def154fcdf6cbab9375798d5f",
        "files": [
          ".changelog/24240.txt",
          "ui/app/styles/core/navbar.scss"
        ],
        "message": "backport of commit ec53cccbc895aedd23a613f8ddf6855c4591d221 (#24252)\n\nCo-authored-by: Phil Renaud <phil.renaud@hashicorp.com>",
        "before_after_code_files": [
          "ui/app/styles/core/navbar.scss||ui/app/styles/core/navbar.scss"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/hashicorp/nomad/pull/25471"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ui/app/styles/core/navbar.scss||ui/app/styles/core/navbar.scss": [
          "File: ui/app/styles/core/navbar.scss -> ui/app/styles/core/navbar.scss",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:     }",
          "178:   }",
          "180:   .custom-label {",
          "181:     border-radius: 1rem;",
          "182:     padding: 0.25rem 1rem;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "180:   .profile-dropdown .hds-dropdown-toggle-button__text {",
          "181:     max-width: 150px;",
          "182:     overflow: hidden;",
          "183:     text-overflow: ellipsis;",
          "184:     white-space: nowrap;",
          "185:     direction: rtl;",
          "186:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64100b5fb4fd9469a80d67b9e2081ae24c0c2d50",
      "candidate_info": {
        "commit_hash": "64100b5fb4fd9469a80d67b9e2081ae24c0c2d50",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/64100b5fb4fd9469a80d67b9e2081ae24c0c2d50",
        "files": [
          ".changelog/24594.txt",
          "ui/app/models/task-group.js",
          "ui/app/models/task.js",
          "ui/app/templates/allocations/allocation/task/index.hbs",
          "ui/app/templates/components/job-page.hbs",
          "ui/app/templates/components/job-page/parts/meta.hbs",
          "ui/app/templates/jobs/job/task-group.hbs",
          "ui/mirage/factories/task-group.js",
          "ui/mirage/factories/task.js",
          "ui/tests/acceptance/task-detail-test.js",
          "ui/tests/acceptance/task-group-detail-test.js",
          "ui/tests/pages/allocations/task/detail.js",
          "ui/tests/pages/jobs/job/task-group.js",
          "ui/tests/unit/models/task-group-test.js",
          "ui/tests/unit/models/task-test.js"
        ],
        "message": "backport of commit 932c3ebfb0f9d2898066f84d6b7585112ec10f94 (#24696)\n\nCo-authored-by: Phil Renaud <phil.renaud@hashicorp.com>",
        "before_after_code_files": [
          "ui/app/models/task-group.js||ui/app/models/task-group.js",
          "ui/app/models/task.js||ui/app/models/task.js",
          "ui/app/templates/allocations/allocation/task/index.hbs||ui/app/templates/allocations/allocation/task/index.hbs",
          "ui/app/templates/components/job-page.hbs||ui/app/templates/components/job-page.hbs",
          "ui/app/templates/components/job-page/parts/meta.hbs||ui/app/templates/components/job-page/parts/meta.hbs",
          "ui/app/templates/jobs/job/task-group.hbs||ui/app/templates/jobs/job/task-group.hbs",
          "ui/mirage/factories/task-group.js||ui/mirage/factories/task-group.js",
          "ui/mirage/factories/task.js||ui/mirage/factories/task.js",
          "ui/tests/acceptance/task-detail-test.js||ui/tests/acceptance/task-detail-test.js",
          "ui/tests/acceptance/task-group-detail-test.js||ui/tests/acceptance/task-group-detail-test.js",
          "ui/tests/pages/allocations/task/detail.js||ui/tests/pages/allocations/task/detail.js",
          "ui/tests/pages/jobs/job/task-group.js||ui/tests/pages/jobs/job/task-group.js",
          "ui/tests/unit/models/task-group-test.js||ui/tests/unit/models/task-group-test.js",
          "ui/tests/unit/models/task-test.js||ui/tests/unit/models/task-test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/hashicorp/nomad/pull/25471"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ui/app/models/task-group.js||ui/app/models/task-group.js": [
          "File: ui/app/models/task-group.js -> ui/app/models/task-group.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:   @fragment('group-scaling') scaling;",
          "68:   get mergedMeta() {",
          "69:     return {",
          "70:       ...this.job.get('meta.raw'),",
          "72:     };",
          "73:   }",
          "",
          "[Removed Lines]",
          "65:   @attr() meta;",
          "67:   @computed('job.meta.raw', 'meta')",
          "71:       ...this.meta,",
          "",
          "[Added Lines]",
          "65:   @fragment('structured-attributes') meta;",
          "67:   @computed('job.meta.raw', 'meta.raw')",
          "71:       ...this.get('meta.raw'),",
          "",
          "---------------"
        ],
        "ui/app/models/task.js||ui/app/models/task.js": [
          "File: ui/app/models/task.js -> ui/app/models/task.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:   @fragmentArray('action', { defaultValue: () => [] })",
          "22:   actions;",
          "26:   @fragment('task-schedule') schedule;",
          "29:   get mergedMeta() {",
          "30:     return {",
          "31:       ...this.taskGroup.mergedMeta,",
          "33:     };",
          "34:   }",
          "",
          "[Removed Lines]",
          "24:   @attr() meta;",
          "28:   @computed('taskGroup.mergedMeta', 'meta')",
          "32:       ...this.meta,",
          "",
          "[Added Lines]",
          "24:   @fragment('structured-attributes') meta;",
          "28:   @computed('meta.raw', 'taskGroup.mergedMeta')",
          "32:       ...this.meta?.raw,",
          "",
          "---------------"
        ],
        "ui/app/templates/allocations/allocation/task/index.hbs||ui/app/templates/allocations/allocation/task/index.hbs": [
          "File: ui/app/templates/allocations/allocation/task/index.hbs -> ui/app/templates/allocations/allocation/task/index.hbs",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:       </ListTable>",
          "288:     </div>",
          "289:   </div>",
          "290: </section>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:   {{#if this.model.task.meta}}",
          "291:     <JobPage::Parts::Meta",
          "292:       @meta={{this.model.task.meta}}",
          "293:     />",
          "294:   {{/if}}",
          "",
          "---------------"
        ],
        "ui/app/templates/components/job-page.hbs||ui/app/templates/components/job-page.hbs": [
          "File: ui/app/templates/components/job-page.hbs -> ui/app/templates/components/job-page.hbs",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:       PlacementFailures=(component \"job-page/parts/placement-failures\" job=@job)",
          "23:       TaskGroups=(component \"job-page/parts/task-groups\" job=@job)",
          "24:       RecentAllocations=(component \"job-page/parts/recent-allocations\" job=@job activeTask=@activeTask setActiveTaskQueryParam=@setActiveTaskQueryParam)",
          "26:       DasRecommendations=(component",
          "27:         \"job-page/parts/das-recommendations\" job=@job",
          "28:       )",
          "",
          "[Removed Lines]",
          "25:       Meta=(component \"job-page/parts/meta\" job=@job)",
          "",
          "[Added Lines]",
          "25:       Meta=(component \"job-page/parts/meta\" meta=@job.meta)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     )",
          "37:   )",
          "",
          "[Removed Lines]",
          "38: }}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ui/app/templates/components/job-page/parts/meta.hbs||ui/app/templates/components/job-page/parts/meta.hbs": [
          "File: ui/app/templates/components/job-page/parts/meta.hbs -> ui/app/templates/components/job-page/parts/meta.hbs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:   SPDX-License-Identifier: BUSL-1.1",
          "4: ~}}",
          "7:   <div class=\"boxed-section\">",
          "8:     <div class=\"boxed-section-head\">",
          "9:       Meta",
          "",
          "[Removed Lines]",
          "6: {{#if @job.meta.structured}}",
          "",
          "[Added Lines]",
          "6: {{#if @meta.structured}}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:     <div class=\"boxed-section-body is-full-bleed\">",
          "12:       <AttributesTable",
          "13:         data-test-meta",
          "15:         @class=\"attributes-table\" />",
          "16:     </div>",
          "17:   </div>",
          "",
          "[Removed Lines]",
          "14:         @attributePairs={{@job.meta.structured.root}}",
          "",
          "[Added Lines]",
          "14:         @attributePairs={{@meta.structured.root}}",
          "",
          "---------------"
        ],
        "ui/app/templates/jobs/job/task-group.hbs||ui/app/templates/jobs/job/task-group.hbs": [
          "File: ui/app/templates/jobs/job/task-group.hbs -> ui/app/templates/jobs/job/task-group.hbs",
          "--- Hunk 1 ---",
          "[Context before]",
          "220:             </t.head>",
          "221:             <t.body @key=\"model.id\" as |row|>",
          "222:               <AllocationRow",
          "224:                   enumerated=true",
          "225:                   action=(action \"gotoAllocation\" row.model)",
          "226:                 }}",
          "",
          "[Removed Lines]",
          "223:                 {{keyboard-shortcut",
          "",
          "[Added Lines]",
          "223:                 {{keyboard-shortcut",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:       </div>",
          "361:     </div>",
          "362:   {{/if}}",
          "363: </section>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "364:   {{#if this.model.meta}}",
          "365:     <JobPage::Parts::Meta",
          "366:       @meta={{this.model.meta}}",
          "367:     />",
          "368:   {{/if}}",
          "",
          "---------------"
        ],
        "ui/mirage/factories/task-group.js||ui/mirage/factories/task-group.js": [
          "File: ui/mirage/factories/task-group.js -> ui/mirage/factories/task-group.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:   withPausedTasks: false,",
          "60:   afterCreate(group, server) {",
          "61:     let taskIds = [];",
          "62:     let volumes = Object.keys(group.volumes);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:   withTaskMeta: false,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:           })),",
          "115:           createRecommendations: group.createRecommendations,",
          "116:           withSchedule: group.withPausedTasks,",
          "117:         });",
          "118:       });",
          "119:       taskIds = tasks.mapBy('id');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120:           withMeta: group.withTaskMeta,",
          "",
          "---------------"
        ],
        "ui/mirage/factories/task.js||ui/mirage/factories/task.js": [
          "File: ui/mirage/factories/task.js -> ui/mirage/factories/task.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:   volumeMounts: [],",
          "29:   JobID: '',",
          "31:   name: (id) => `task-${dasherize(faker.hacker.noun())}-${id}`,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29:   meta: null,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:       });",
          "129:       task.update({ schedule: schedule });",
          "130:     }",
          "131:   },",
          "132: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:     if (task.withMeta) {",
          "135:       task.update({ meta: { raw: { foo: 'bar' } } });",
          "136:     }",
          "",
          "---------------"
        ],
        "ui/tests/acceptance/task-detail-test.js||ui/tests/acceptance/task-detail-test.js": [
          "File: ui/tests/acceptance/task-detail-test.js -> ui/tests/acceptance/task-detail-test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "213:     });",
          "214:   });",
          "216:   test('each recent event should list the time, type, and description of the event', async function (assert) {",
          "217:     const event = server.db.taskEvents.where({ taskStateId: task.id })[0];",
          "218:     const recentEvent = Task.events.objectAt(Task.events.length - 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215:   test('when a task group has metadata, the metadata table is shown', async function (assert) {",
          "216:     const job = server.create('job', {",
          "217:       createAllocations: false,",
          "218:     });",
          "219:     const taskGroup = server.create('task-group', {",
          "220:       job,",
          "221:       name: 'scaling',",
          "222:       count: 1,",
          "223:       withTaskMeta: true,",
          "224:     });",
          "225:     job.update({ taskGroupIds: [taskGroup.id] });",
          "226:     allocation = server.db.allocations[1];",
          "227:     server.db.taskStates.update(",
          "228:       { allocationId: allocation.id },",
          "229:       { state: 'running' }",
          "230:     );",
          "231:     const jobTask = taskGroup.tasks.models[0];",
          "232:     task = jobTask;",
          "233:     await Task.visit({ id: allocation.id, name: task.name });",
          "234:     assert.ok(Task.hasMeta);",
          "235:   });",
          "",
          "---------------"
        ],
        "ui/tests/acceptance/task-group-detail-test.js||ui/tests/acceptance/task-group-detail-test.js": [
          "File: ui/tests/acceptance/task-group-detail-test.js -> ui/tests/acceptance/task-group-detail-test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "453:     assert.notOk(TaskGroup.hasVolumes);",
          "454:   });",
          "456:   test('each row in the volumes table lists information about the volume', async function (assert) {",
          "457:     await TaskGroup.visit({ id: job.id, name: taskGroup.name });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "456:   test('when the task group has metadata, the metadata table is shown', async function (assert) {",
          "457:     job = server.create('job', {",
          "458:       meta: { raw: { a: 'b' } },",
          "459:     });",
          "460:     taskGroup = server.create('task-group', {",
          "461:       job,",
          "462:       meta: { raw: { foo: 'bar' } },",
          "463:     });",
          "464:     await TaskGroup.visit({ id: job.id, name: taskGroup.name });",
          "466:     assert.ok(TaskGroup.hasMeta);",
          "467:   });",
          "",
          "---------------"
        ],
        "ui/tests/pages/allocations/task/detail.js||ui/tests/pages/allocations/task/detail.js": [
          "File: ui/tests/pages/allocations/task/detail.js -> ui/tests/pages/allocations/task/detail.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:     clientSource: text('[data-test-volume-client-source]'),",
          "61:   }),",
          "63:   events: collection('[data-test-task-event]', {",
          "64:     time: text('[data-test-task-event-time]'),",
          "65:     type: text('[data-test-task-event-type]'),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:   hasMeta: isPresent('[data-test-meta]'),",
          "",
          "---------------"
        ],
        "ui/tests/pages/jobs/job/task-group.js||ui/tests/pages/jobs/job/task-group.js": [
          "File: ui/tests/pages/jobs/job/task-group.js -> ui/tests/pages/jobs/job/task-group.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:     permissions: text('[data-test-volume-permissions]'),",
          "55:   }),",
          "57:   hasScaleEvents: isPresent('[data-test-scale-events]'),",
          "58:   scaleEvents: collection(",
          "59:     '[data-test-scale-events] [data-test-accordion-head]',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57:   hasMeta: isPresent('[data-test-meta]'),",
          "",
          "---------------"
        ],
        "ui/tests/unit/models/task-group-test.js||ui/tests/unit/models/task-group-test.js": [
          "File: ui/tests/unit/models/task-group-test.js -> ui/tests/unit/models/task-group-test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:     const jobWithMeta = run(() =>",
          "77:       store.createRecord('job', {",
          "78:         name: 'example-with-meta',",
          "82:         taskGroups: [",
          "83:           {",
          "84:             name: 'one',",
          "86:           },",
          "87:           {",
          "88:             name: 'two',",
          "89:           },",
          "90:           {",
          "91:             name: 'three',",
          "93:           },",
          "94:           {",
          "95:             name: 'four',",
          "97:           },",
          "98:         ],",
          "99:       })",
          "",
          "[Removed Lines]",
          "79:         meta: store.createFragment('structured-attributes', {",
          "80:           raw: { a: 'b' },",
          "81:         }),",
          "85:             meta: { c: 'd' },",
          "92:             meta: null,",
          "96:             meta: {},",
          "",
          "[Added Lines]",
          "79:         meta: { raw: { a: 'b' } },",
          "83:             meta: { raw: { c: 'd' } },",
          "90:             meta: { raw: null },",
          "94:             meta: { raw: {} },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:         taskGroups: [",
          "115:           {",
          "116:             name: 'one',",
          "118:           },",
          "119:           {",
          "120:             name: 'two',",
          "121:           },",
          "122:           {",
          "123:             name: 'three',",
          "125:           },",
          "126:           {",
          "127:             name: 'four',",
          "129:           },",
          "130:         ],",
          "131:       })",
          "",
          "[Removed Lines]",
          "117:             meta: { c: 'd' },",
          "124:             meta: null,",
          "128:             meta: {},",
          "",
          "[Added Lines]",
          "115:             meta: { raw: { c: 'd' } },",
          "122:             meta: { raw: null },",
          "126:             meta: { raw: {} },",
          "",
          "---------------"
        ],
        "ui/tests/unit/models/task-test.js||ui/tests/unit/models/task-test.js": [
          "File: ui/tests/unit/models/task-test.js -> ui/tests/unit/models/task-test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:         taskGroups: [",
          "21:           {",
          "22:             name: 'one',",
          "24:             tasks: [",
          "25:               {",
          "26:                 name: 'task-one',",
          "28:               },",
          "29:               {",
          "30:                 name: 'task-two',",
          "31:               },",
          "32:               {",
          "33:                 name: 'task-three',",
          "35:               },",
          "36:               {",
          "37:                 name: 'task-four',",
          "39:               },",
          "40:             ],",
          "41:           },",
          "",
          "[Removed Lines]",
          "23:             meta: { a: 'b' },",
          "27:                 meta: { c: 'd' },",
          "34:                 meta: null,",
          "38:                 meta: {},",
          "",
          "[Added Lines]",
          "23:             meta: { raw: { a: 'b' } },",
          "27:                 meta: { raw: { c: 'd' } },",
          "34:                 meta: { raw: null },",
          "38:                 meta: { raw: {} },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:             tasks: [",
          "45:               {",
          "46:                 name: 'task-one',",
          "48:               },",
          "49:               {",
          "50:                 name: 'task-two',",
          "51:               },",
          "52:               {",
          "53:                 name: 'task-three',",
          "55:               },",
          "56:               {",
          "57:                 name: 'task-four',",
          "59:               },",
          "60:             ],",
          "61:           },",
          "",
          "[Removed Lines]",
          "47:                 meta: { c: 'd' },",
          "54:                 meta: null,",
          "58:                 meta: {},",
          "",
          "[Added Lines]",
          "47:                 meta: { raw: { c: 'd' } },",
          "54:                 meta: { raw: null },",
          "58:                 meta: { raw: {} },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
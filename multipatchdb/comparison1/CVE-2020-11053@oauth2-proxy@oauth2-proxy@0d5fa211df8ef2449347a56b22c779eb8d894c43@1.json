{
  "cve_id": "CVE-2020-11053",
  "cve_desc": "In OAuth2 Proxy before 5.1.1, there is an open redirect vulnerability. Users can provide a redirect address for the proxy to send the authenticated user to at the end of the authentication flow. This is expected to be the original URL that the user was trying to access. This redirect URL is checked within the proxy and validated before redirecting the user to prevent malicious actors providing redirects to potentially harmful sites. However, by crafting a redirect URL with HTML encoded whitespace characters the validation could be bypassed and allow a redirect to any URL provided. This has been patched in 5.1.1.",
  "repo": "oauth2-proxy/oauth2-proxy",
  "patch_hash": "0d5fa211df8ef2449347a56b22c779eb8d894c43",
  "patch_info": {
    "commit_hash": "0d5fa211df8ef2449347a56b22c779eb8d894c43",
    "repo": "oauth2-proxy/oauth2-proxy",
    "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/0d5fa211df8ef2449347a56b22c779eb8d894c43",
    "files": [
      "oauthproxy.go",
      "oauthproxy_test.go"
    ],
    "message": "Merge pull request from GHSA-j7px-6hwj-hpjg",
    "before_after_code_files": [
      "oauthproxy.go||oauthproxy.go",
      "oauthproxy_test.go||oauthproxy_test.go"
    ]
  },
  "patch_diff": {
    "oauthproxy.go||oauthproxy.go": [
      "File: oauthproxy.go -> oauthproxy.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "57: var (",
      "59:  ErrNeedsLogin = errors.New(\"redirect to login page\")",
      "60: )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63:  invalidRedirectRegex = regexp.MustCompile(`^/(\\s|\\v)?(/|\\\\)`)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "579: func (p *OAuthProxy) IsValidRedirect(redirect string) bool {",
      "580:  switch {",
      "582:   return true",
      "583:  case strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):",
      "584:   redirectURL, err := url.Parse(redirect)",
      "",
      "[Removed Lines]",
      "581:  case strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !strings.HasPrefix(redirect, \"/\\\\\"):",
      "",
      "[Added Lines]",
      "585:  case strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):",
      "",
      "---------------"
    ],
    "oauthproxy_test.go||oauthproxy_test.go": [
      "File: oauthproxy_test.go -> oauthproxy_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "322:    Redirect:       \"http://a.sub.anyport.bar:8081/redirect\",",
      "323:    ExpectedResult: true,",
      "324:   },",
      "325:  }",
      "327:  for _, tc := range testCases {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "325:   {",
      "326:    Desc:           \"openRedirect1\",",
      "327:    Redirect:       \"/\\\\evil.com\",",
      "328:    ExpectedResult: false,",
      "329:   },",
      "330:   {",
      "331:    Desc:           \"openRedirectSpace1\",",
      "332:    Redirect:       \"/ /evil.com\",",
      "333:    ExpectedResult: false,",
      "334:   },",
      "335:   {",
      "336:    Desc:           \"openRedirectSpace2\",",
      "337:    Redirect:       \"/ \\\\evil.com\",",
      "338:    ExpectedResult: false,",
      "339:   },",
      "340:   {",
      "341:    Desc:           \"openRedirectTab1\",",
      "342:    Redirect:       \"/\\t/evil.com\",",
      "343:    ExpectedResult: false,",
      "344:   },",
      "345:   {",
      "346:    Desc:           \"openRedirectTab2\",",
      "347:    Redirect:       \"/\\t\\\\evil.com\",",
      "348:    ExpectedResult: false,",
      "349:   },",
      "350:   {",
      "351:    Desc:           \"openRedirectVerticalTab1\",",
      "352:    Redirect:       \"/\\v/evil.com\",",
      "353:    ExpectedResult: false,",
      "354:   },",
      "355:   {",
      "356:    Desc:           \"openRedirectVerticalTab2\",",
      "357:    Redirect:       \"/\\v\\\\evil.com\",",
      "358:    ExpectedResult: false,",
      "359:   },",
      "360:   {",
      "361:    Desc:           \"openRedirectNewLine1\",",
      "362:    Redirect:       \"/\\n/evil.com\",",
      "363:    ExpectedResult: false,",
      "364:   },",
      "365:   {",
      "366:    Desc:           \"openRedirectNewLine2\",",
      "367:    Redirect:       \"/\\n\\\\evil.com\",",
      "368:    ExpectedResult: false,",
      "369:   },",
      "370:   {",
      "371:    Desc:           \"openRedirectCarriageReturn1\",",
      "372:    Redirect:       \"/\\r/evil.com\",",
      "373:    ExpectedResult: false,",
      "374:   },",
      "375:   {",
      "376:    Desc:           \"openRedirectCarriageReturn2\",",
      "377:    Redirect:       \"/\\r\\\\evil.com\",",
      "378:    ExpectedResult: false,",
      "379:   },",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2549b722d3044762438c9c2995bdb16d17954c95",
      "candidate_info": {
        "commit_hash": "2549b722d3044762438c9c2995bdb16d17954c95",
        "repo": "oauth2-proxy/oauth2-proxy",
        "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/2549b722d3044762438c9c2995bdb16d17954c95",
        "files": [
          "CHANGELOG.md",
          "oauthproxy.go",
          "oauthproxy_test.go"
        ],
        "message": "Add User & Groups to Userinfo",
        "before_after_code_files": [
          "oauthproxy.go||oauthproxy.go",
          "oauthproxy_test.go||oauthproxy_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ],
          "candidate": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ]
        }
      },
      "candidate_diff": {
        "oauthproxy.go||oauthproxy.go": [
          "File: oauthproxy.go -> oauthproxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "798:   http.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)",
          "799:   return",
          "800:  }",
          "801:  userInfo := struct {",
          "804:  }{",
          "805:   Email:             session.Email,",
          "806:   PreferredUsername: session.PreferredUsername,",
          "807:  }",
          "808:  rw.Header().Set(\"Content-Type\", \"application/json\")",
          "809:  rw.WriteHeader(http.StatusOK)",
          "810:  err = json.NewEncoder(rw).Encode(userInfo)",
          "",
          "[Removed Lines]",
          "802:   Email             string `json:\"email\"`",
          "803:   PreferredUsername string `json:\"preferredUsername,omitempty\"`",
          "",
          "[Added Lines]",
          "803:   User              string   `json:\"user\"`",
          "804:   Email             string   `json:\"email\"`",
          "805:   Groups            []string `json:\"groups,omitempty\"`",
          "806:   PreferredUsername string   `json:\"preferredUsername,omitempty\"`",
          "808:   User:              session.User,",
          "810:   Groups:            session.Groups,",
          "",
          "---------------"
        ],
        "oauthproxy_test.go||oauthproxy_test.go": [
          "File: oauthproxy_test.go -> oauthproxy_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1130:  }",
          "1132:  startSession := &sessions.SessionState{",
          "1134:  err = test.SaveSession(startSession)",
          "1135:  assert.NoError(t, err)",
          "1137:  test.proxy.ServeHTTP(test.rw, test.req)",
          "1138:  assert.Equal(t, http.StatusOK, test.rw.Code)",
          "1139:  bodyBytes, _ := ioutil.ReadAll(test.rw.Body)",
          "1141: }",
          "1143: func TestUserInfoEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {",
          "",
          "[Removed Lines]",
          "1133:   Email: \"john.doe@example.com\", AccessToken: \"my_access_token\"}",
          "1140:  assert.Equal(t, \"{\\\"email\\\":\\\"john.doe@example.com\\\"}\\n\", string(bodyBytes))",
          "",
          "[Added Lines]",
          "1133:   User:        \"john.doe\",",
          "1134:   Email:       \"john.doe@example.com\",",
          "1135:   Groups:      []string{\"example\", \"groups\"},",
          "1136:   AccessToken: \"my_access_token\",",
          "1137:  }",
          "1144:  assert.Equal(t, \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\", string(bodyBytes))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64ae31b5a098375cbdda8fcfe06ccc6da9f94740",
      "candidate_info": {
        "commit_hash": "64ae31b5a098375cbdda8fcfe06ccc6da9f94740",
        "repo": "oauth2-proxy/oauth2-proxy",
        "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/64ae31b5a098375cbdda8fcfe06ccc6da9f94740",
        "files": [
          "CHANGELOG.md",
          "contrib/oauth2-proxy_autocomplete.sh",
          "docs/configuration/configuration.md",
          "oauthproxy.go",
          "oauthproxy_test.go",
          "pkg/apis/options/options.go",
          "pkg/ip/net_set.go",
          "pkg/ip/net_set_test.go",
          "pkg/ip/parse_ip_net.go",
          "pkg/ip/realclientip.go",
          "pkg/validation/options.go",
          "pkg/validation/options_test.go"
        ],
        "message": "Implements --trusted-ip option (#552)\n\n* Implements --ip-whitelist option\n\n* Included IPWhitelist option to allow one-or-more selected CIDR ranges\n  to bypass OAuth2 authentication.\n* Adds IPWhitelist, a fast lookup table for multiple CIDR ranges.\n\n* Renamed IPWhitelist ipCIDRSet\n\n* Fixed unessesary pointer usage in ipCIDRSet\n\n* Update CHANGELOG.md\n\n* Update CHANGELOG.md\n\n* Updated to not use err.Error() in printf statements\n\n* Imrpoved language for --ip-whitelist descriptions.\n\n* Improve IP whitelist options error messages\n\n* Clarify options single-host normalization\n\n* Wrote a book about ipCIDRSet\n\n* Added comment to IsWhitelistedIP in oauthproxy.go\n\n* Rewrite oauthproxy test case as table driven\n\n* oops\n\n* Support whitelisting by low-level remote address\n\n* Added more test-cases, improved descriptions\n\n* Move ip_cidr_set.go to pkg/ip/net_set.go\n\n* Add more whitelist test use cases.\n\n* Oops\n\n* Use subtests for TestIPWhitelist\n\n* Add minimal tests for ip.NetSet\n\n* Use switch statment\n\n* Renamed ip-whitelist to whitelist-ip\n\n* Update documentation with a warning.\n\n* Update pkg/apis/options/options.go\n\n* Update CHANGELOG.md\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* Update pkg/ip/net_set_test.go\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* Update pkg/ip/net_set_test.go\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* Update pkg/ip/net_set_test.go\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* Apply suggestions from code review\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* fix fmt\n\n* Move ParseIPNet into abstraction\n\n* Add warning in case of --reverse-proxy\n\n* Update pkg/validation/options_test.go\n\n* Rename --whitelist-ip to --trusted-ip\n\n* Update oauthproxy.go\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>\n\n* fix\n\nCo-authored-by: Joel Speed <Joel.speed@hotmail.co.uk>",
        "before_after_code_files": [
          "contrib/oauth2-proxy_autocomplete.sh||contrib/oauth2-proxy_autocomplete.sh",
          "oauthproxy.go||oauthproxy.go",
          "oauthproxy_test.go||oauthproxy_test.go",
          "pkg/apis/options/options.go||pkg/apis/options/options.go",
          "pkg/ip/net_set.go||pkg/ip/net_set.go",
          "pkg/ip/net_set_test.go||pkg/ip/net_set_test.go",
          "pkg/ip/parse_ip_net.go||pkg/ip/parse_ip_net.go",
          "pkg/ip/realclientip.go||pkg/ip/realclientip.go",
          "pkg/validation/options.go||pkg/validation/options.go",
          "pkg/validation/options_test.go||pkg/validation/options_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ],
          "candidate": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ]
        }
      },
      "candidate_diff": {
        "contrib/oauth2-proxy_autocomplete.sh||contrib/oauth2-proxy_autocomplete.sh": [
          "File: contrib/oauth2-proxy_autocomplete.sh -> contrib/oauth2-proxy_autocomplete.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:    COMPREPLY=( $(compgen -W 'X-Real-IP X-Forwarded-For X-ProxyUser-IP' -- ${cur}) )",
          "25:    return 0",
          "26:    ;;",
          "28:    return 0",
          "29:    ;;",
          "30:  esac",
          "",
          "[Removed Lines]",
          "27:   --@(http-address|https-address|redirect-url|upstream|basic-auth-password|skip-auth-regex|flush-interval|extra-jwt-issuers|email-domain|whitelist-domain|keycloak-group|azure-tenant|bitbucket-team|bitbucket-repository|github-org|github-team|github-repo|github-token|gitlab-group|github-user|google-group|google-admin-email|google-service-account-json|client-id|client_secret|banner|footer|proxy-prefix|ping-path|cookie-name|cookie-secret|cookie-domain|cookie-path|cookie-expire|cookie-refresh|cookie-samesite|redist-sentinel-master-name|redist-sentinel-connection-urls|redist-cluster-connection-urls|logging-max-size|logging-max-age|logging-max-backups|standard-logging-format|request-logging-format|exclude-logging-paths|auth-logging-format|oidc-issuer-url|oidc-jwks-url|login-url|redeem-url|profile-url|resource|validate-url|scope|approval-prompt|signature-key|acr-values|jwt-key|pubjwk-url))",
          "",
          "[Added Lines]",
          "27:   --@(http-address|https-address|redirect-url|upstream|basic-auth-password|skip-auth-regex|flush-interval|extra-jwt-issuers|email-domain|whitelist-domain|trusted-ip|keycloak-group|azure-tenant|bitbucket-team|bitbucket-repository|github-org|github-team|github-repo|github-token|gitlab-group|github-user|google-group|google-admin-email|google-service-account-json|client-id|client_secret|banner|footer|proxy-prefix|ping-path|cookie-name|cookie-secret|cookie-domain|cookie-path|cookie-expire|cookie-refresh|cookie-samesite|redist-sentinel-master-name|redist-sentinel-connection-urls|redist-cluster-connection-urls|logging-max-size|logging-max-age|logging-max-backups|standard-logging-format|request-logging-format|exclude-logging-paths|auth-logging-format|oidc-issuer-url|oidc-jwks-url|login-url|redeem-url|profile-url|resource|validate-url|scope|approval-prompt|signature-key|acr-values|jwt-key|pubjwk-url))",
          "",
          "---------------"
        ],
        "oauthproxy.go||oauthproxy.go": [
          "File: oauthproxy.go -> oauthproxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "117:  compiledRegex           []*regexp.Regexp",
          "118:  templates               *template.Template",
          "119:  realClientIPParser      ipapi.RealClientIPParser",
          "120:  Banner                  string",
          "121:  Footer                  string",
          "122: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120:  trustedIPs              *ip.NetSet",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "304:  logger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domains:%s path:%s samesite:%s refresh:%s\", opts.Cookie.Name, opts.Cookie.Secure, opts.Cookie.HTTPOnly, opts.Cookie.Expire, strings.Join(opts.Cookie.Domains, \",\"), opts.Cookie.Path, opts.Cookie.SameSite, refresh)",
          "306:  return &OAuthProxy{",
          "307:   CookieName:     opts.Cookie.Name,",
          "308:   CSRFCookieName: fmt.Sprintf(\"%v_%v\", opts.Cookie.Name, \"csrf\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "307:  trustedIPs := ip.NewNetSet()",
          "308:  for _, ipStr := range opts.TrustedIPs {",
          "309:   if ipNet := ip.ParseIPNet(ipStr); ipNet != nil {",
          "310:    trustedIPs.AddIPNet(*ipNet)",
          "311:   } else {",
          "312:    return nil, fmt.Errorf(\"could not parse IP network (%s)\", ipStr)",
          "313:   }",
          "314:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "349:   PreferEmailToUser:       opts.PreferEmailToUser,",
          "350:   SkipProviderButton:      opts.SkipProviderButton,",
          "351:   templates:               loadTemplates(opts.CustomTemplatesDir),",
          "352:   Banner:                  opts.Banner,",
          "353:   Footer:                  opts.Footer,",
          "354:  }, nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:   trustedIPs:              trustedIPs,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "651: func (p *OAuthProxy) IsWhitelistedRequest(req *http.Request) bool {",
          "652:  isPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"",
          "654: }",
          "",
          "[Removed Lines]",
          "653:  return isPreflightRequestAllowed || p.IsWhitelistedPath(req.URL.Path)",
          "",
          "[Added Lines]",
          "664:  return isPreflightRequestAllowed || p.IsWhitelistedPath(req.URL.Path) || p.IsTrustedIP(req)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "678:  }",
          "679: }",
          "681: func (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {",
          "682:  if req.URL.Path != p.AuthOnlyPath && strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {",
          "683:   prepareNoCache(rw)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "693: func (p *OAuthProxy) IsTrustedIP(req *http.Request) bool {",
          "694:  if p.trustedIPs == nil {",
          "695:   return false",
          "696:  }",
          "698:  remoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)",
          "699:  if err != nil {",
          "700:   logger.Printf(\"Error obtaining real IP for trusted IP list: %v\", err)",
          "702:   return false",
          "703:  }",
          "705:  if remoteAddr == nil {",
          "706:   return false",
          "707:  }",
          "709:  return p.trustedIPs.Has(remoteAddr)",
          "710: }",
          "",
          "---------------"
        ],
        "oauthproxy_test.go||oauthproxy_test.go": [
          "File: oauthproxy_test.go -> oauthproxy_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1892:  opts.EmailDomains = []string{\"*\"}",
          "1893:  return opts",
          "1894: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1896: func TestTrustedIPs(t *testing.T) {",
          "1897:  tests := []struct {",
          "1898:   name               string",
          "1899:   trustedIPs         []string",
          "1900:   reverseProxy       bool",
          "1901:   realClientIPHeader string",
          "1902:   req                *http.Request",
          "1903:   expectTrusted      bool",
          "1904:  }{",
          "1906:   {",
          "1907:    name:               \"Default\",",
          "1908:    trustedIPs:         nil,",
          "1909:    reverseProxy:       false,",
          "1910:    realClientIPHeader: \"X-Real-IP\", // Default value",
          "1911:    req: func() *http.Request {",
          "1912:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1913:     return req",
          "1914:    }(),",
          "1915:    expectTrusted: false,",
          "1916:   },",
          "1918:   {",
          "1919:    name:               \"WithRemoteAddr\",",
          "1920:    trustedIPs:         []string{\"127.0.0.1\"},",
          "1921:    reverseProxy:       false,",
          "1922:    realClientIPHeader: \"X-Real-IP\", // Default value",
          "1923:    req: func() *http.Request {",
          "1924:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1925:     req.RemoteAddr = \"127.0.0.1:43670\"",
          "1926:     return req",
          "1927:    }(),",
          "1928:    expectTrusted: true,",
          "1929:   },",
          "1931:   {",
          "1932:    name:               \"IgnoresRemoteAddrInReverseProxyMode\",",
          "1933:    trustedIPs:         []string{\"127.0.0.1\"},",
          "1934:    reverseProxy:       true,",
          "1935:    realClientIPHeader: \"X-Real-IP\", // Default value",
          "1936:    req: func() *http.Request {",
          "1937:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1938:     req.RemoteAddr = \"127.0.0.1:44324\"",
          "1939:     return req",
          "1940:    }(),",
          "1941:    expectTrusted: false,",
          "1942:   },",
          "1944:   {",
          "1945:    name:               \"TrustsLocalhostInReverseProxyMode\",",
          "1946:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "1947:    reverseProxy:       true,",
          "1948:    realClientIPHeader: \"X-Forwarded-For\",",
          "1949:    req: func() *http.Request {",
          "1950:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1951:     req.Header.Add(\"X-Forwarded-For\", \"127.0.0.1\")",
          "1952:     return req",
          "1953:    }(),",
          "1954:    expectTrusted: true,",
          "1955:   },",
          "1957:   {",
          "1958:    name:               \"TrustsIP6LocalostInReverseProxyMode\",",
          "1959:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "1960:    reverseProxy:       true,",
          "1961:    realClientIPHeader: \"X-Forwarded-For\",",
          "1962:    req: func() *http.Request {",
          "1963:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1964:     req.Header.Add(\"X-Forwarded-For\", \"::1\")",
          "1965:     return req",
          "1966:    }(),",
          "1967:    expectTrusted: true,",
          "1968:   },",
          "1970:   {",
          "1971:    name:               \"DoesNotTrustRandomIP4Address\",",
          "1972:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "1973:    reverseProxy:       true,",
          "1974:    realClientIPHeader: \"X-Forwarded-For\",",
          "1975:    req: func() *http.Request {",
          "1976:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1977:     req.Header.Add(\"X-Forwarded-For\", \"12.34.56.78\")",
          "1978:     return req",
          "1979:    }(),",
          "1980:    expectTrusted: false,",
          "1981:   },",
          "1983:   {",
          "1984:    name:               \"DoesNotTrustRandomIP6Address\",",
          "1985:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "1986:    reverseProxy:       true,",
          "1987:    realClientIPHeader: \"X-Forwarded-For\",",
          "1988:    req: func() *http.Request {",
          "1989:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "1990:     req.Header.Add(\"X-Forwarded-For\", \"::2\")",
          "1991:     return req",
          "1992:    }(),",
          "1993:    expectTrusted: false,",
          "1994:   },",
          "1996:   {",
          "1997:    name:               \"RespectsCorrectHeaderInReverseProxyMode\",",
          "1998:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "1999:    reverseProxy:       true,",
          "2000:    realClientIPHeader: \"X-Forwarded-For\",",
          "2001:    req: func() *http.Request {",
          "2002:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "2003:     req.Header.Add(\"X-Real-IP\", \"::1\")",
          "2004:     return req",
          "2005:    }(),",
          "2006:    expectTrusted: false,",
          "2007:   },",
          "2009:   {",
          "2010:    name:               \"DoesNotTrustGarbageInReverseProxyMode\",",
          "2011:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "2012:    reverseProxy:       true,",
          "2013:    realClientIPHeader: \"X-Forwarded-For\",",
          "2014:    req: func() *http.Request {",
          "2015:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "2016:     req.Header.Add(\"X-Forwarded-For\", \"adsfljk29242as!!\")",
          "2017:     return req",
          "2018:    }(),",
          "2019:    expectTrusted: false,",
          "2020:   },",
          "2022:   {",
          "2023:    name:               \"DoesNotTrustGarbage\",",
          "2024:    trustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},",
          "2025:    reverseProxy:       false,",
          "2026:    realClientIPHeader: \"X-Real-IP\",",
          "2027:    req: func() *http.Request {",
          "2028:     req, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "2029:     req.RemoteAddr = \"adsfljk29242as!!\"",
          "2030:     return req",
          "2031:    }(),",
          "2032:    expectTrusted: false,",
          "2033:   },",
          "2034:  }",
          "2036:  for _, tt := range tests {",
          "2037:   t.Run(tt.name, func(t *testing.T) {",
          "2038:    opts := baseTestOptions()",
          "2039:    opts.Upstreams = []string{\"static://200\"}",
          "2040:    opts.TrustedIPs = tt.trustedIPs",
          "2041:    opts.ReverseProxy = tt.reverseProxy",
          "2042:    opts.RealClientIPHeader = tt.realClientIPHeader",
          "2043:    validation.Validate(opts)",
          "2045:    proxy, err := NewOAuthProxy(opts, func(string) bool { return true })",
          "2046:    assert.NoError(t, err)",
          "2047:    rw := httptest.NewRecorder()",
          "2049:    proxy.ServeHTTP(rw, tt.req)",
          "2050:    if tt.expectTrusted {",
          "2051:     assert.Equal(t, 200, rw.Code)",
          "2052:    } else {",
          "2053:     assert.Equal(t, 403, rw.Code)",
          "2054:    }",
          "2055:   })",
          "2056:  }",
          "2057: }",
          "",
          "---------------"
        ],
        "pkg/apis/options/options.go||pkg/apis/options/options.go": [
          "File: pkg/apis/options/options.go -> pkg/apis/options/options.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: type Options struct {",
          "40:  AuthenticatedEmailsFile  string   `flag:\"authenticated-emails-file\" cfg:\"authenticated_emails_file\"`",
          "41:  KeycloakGroup            string   `flag:\"keycloak-group\" cfg:\"keycloak_group\"`",
          "",
          "[Removed Lines]",
          "24:  ProxyPrefix        string `flag:\"proxy-prefix\" cfg:\"proxy_prefix\"`",
          "25:  PingPath           string `flag:\"ping-path\" cfg:\"ping_path\"`",
          "26:  PingUserAgent      string `flag:\"ping-user-agent\" cfg:\"ping_user_agent\"`",
          "27:  ProxyWebSockets    bool   `flag:\"proxy-websockets\" cfg:\"proxy_websockets\"`",
          "28:  HTTPAddress        string `flag:\"http-address\" cfg:\"http_address\"`",
          "29:  HTTPSAddress       string `flag:\"https-address\" cfg:\"https_address\"`",
          "30:  ReverseProxy       bool   `flag:\"reverse-proxy\" cfg:\"reverse_proxy\"`",
          "31:  RealClientIPHeader string `flag:\"real-client-ip-header\" cfg:\"real_client_ip_header\"`",
          "32:  ForceHTTPS         bool   `flag:\"force-https\" cfg:\"force_https\"`",
          "33:  RawRedirectURL     string `flag:\"redirect-url\" cfg:\"redirect_url\"`",
          "34:  ClientID           string `flag:\"client-id\" cfg:\"client_id\"`",
          "35:  ClientSecret       string `flag:\"client-secret\" cfg:\"client_secret\"`",
          "36:  ClientSecretFile   string `flag:\"client-secret-file\" cfg:\"client_secret_file\"`",
          "37:  TLSCertFile        string `flag:\"tls-cert-file\" cfg:\"tls_cert_file\"`",
          "38:  TLSKeyFile         string `flag:\"tls-key-file\" cfg:\"tls_key_file\"`",
          "",
          "[Added Lines]",
          "24:  ProxyPrefix        string   `flag:\"proxy-prefix\" cfg:\"proxy_prefix\"`",
          "25:  PingPath           string   `flag:\"ping-path\" cfg:\"ping_path\"`",
          "26:  PingUserAgent      string   `flag:\"ping-user-agent\" cfg:\"ping_user_agent\"`",
          "27:  ProxyWebSockets    bool     `flag:\"proxy-websockets\" cfg:\"proxy_websockets\"`",
          "28:  HTTPAddress        string   `flag:\"http-address\" cfg:\"http_address\"`",
          "29:  HTTPSAddress       string   `flag:\"https-address\" cfg:\"https_address\"`",
          "30:  ReverseProxy       bool     `flag:\"reverse-proxy\" cfg:\"reverse_proxy\"`",
          "31:  RealClientIPHeader string   `flag:\"real-client-ip-header\" cfg:\"real_client_ip_header\"`",
          "32:  TrustedIPs         []string `flag:\"trusted-ip\" cfg:\"trusted_ips\"`",
          "33:  ForceHTTPS         bool     `flag:\"force-https\" cfg:\"force_https\"`",
          "34:  RawRedirectURL     string   `flag:\"redirect-url\" cfg:\"redirect_url\"`",
          "35:  ClientID           string   `flag:\"client-id\" cfg:\"client_id\"`",
          "36:  ClientSecret       string   `flag:\"client-secret\" cfg:\"client_secret\"`",
          "37:  ClientSecretFile   string   `flag:\"client-secret-file\" cfg:\"client_secret_file\"`",
          "38:  TLSCertFile        string   `flag:\"tls-cert-file\" cfg:\"tls_cert_file\"`",
          "39:  TLSKeyFile         string   `flag:\"tls-key-file\" cfg:\"tls_key_file\"`",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "186:  flagSet.String(\"https-address\", \":443\", \"<addr>:<port> to listen on for HTTPS clients\")",
          "187:  flagSet.Bool(\"reverse-proxy\", false, \"are we running behind a reverse proxy, controls whether headers like X-Real-Ip are accepted\")",
          "188:  flagSet.String(\"real-client-ip-header\", \"X-Real-IP\", \"Header used to determine the real IP of the client (one of: X-Forwarded-For, X-Real-IP, or X-ProxyUser-IP)\")",
          "189:  flagSet.Bool(\"force-https\", false, \"force HTTPS redirect for HTTP requests\")",
          "190:  flagSet.String(\"tls-cert-file\", \"\", \"path to certificate file\")",
          "191:  flagSet.String(\"tls-key-file\", \"\", \"path to private key file\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190:  flagSet.StringSlice(\"trusted-ip\", []string{}, \"list of IPs or CIDR ranges to allow to bypass authentication. WARNING: trusting by IP has inherent security flaws, read the configuration documentation for more information.\")",
          "",
          "---------------"
        ],
        "pkg/ip/net_set.go||pkg/ip/net_set.go": [
          "File: pkg/ip/net_set.go -> pkg/ip/net_set.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package ip",
          "3: import (",
          "4:  \"fmt\"",
          "5:  \"net\"",
          "6: )",
          "18: type NetSet struct {",
          "19:  ip4NetMaps []ipNetMap",
          "20:  ip6NetMaps []ipNetMap",
          "21: }",
          "24: func NewNetSet() *NetSet {",
          "25:  return &NetSet{",
          "26:   ip4NetMaps: make([]ipNetMap, 0),",
          "27:   ip6NetMaps: make([]ipNetMap, 0),",
          "28:  }",
          "29: }",
          "32: func (w *NetSet) Has(ip net.IP) bool {",
          "33:  netMaps := w.getNetMaps(ip)",
          "36:  for _, netMap := range *netMaps {",
          "37:   if netMap.has(ip) {",
          "38:    return true",
          "39:   }",
          "40:  }",
          "41:  return false",
          "42: }",
          "45: func (w *NetSet) AddIPNet(ipNet net.IPNet) {",
          "46:  netMaps := w.getNetMaps(ipNet.IP)",
          "49:  ones, _ := ipNet.Mask.Size()",
          "51:  var netMap *ipNetMap",
          "54:  for i := 0; len(*netMaps) > i; i++ {",
          "55:   if netMapOnes, _ := (*netMaps)[i].mask.Size(); netMapOnes == ones {",
          "56:    netMap = &(*netMaps)[i]",
          "57:    break",
          "58:   }",
          "59:  }",
          "62:  if netMap == nil {",
          "63:   netMap = &ipNetMap{",
          "64:    mask: ipNet.Mask,",
          "65:    ips:  make(map[string]bool),",
          "66:   }",
          "69:   w.AddIPNet(ipNet)",
          "70:   return",
          "71:  }",
          "74:  netMap.ips[ipNet.IP.String()] = true",
          "75: }",
          "78: func (w *NetSet) getNetMaps(ip net.IP) (netMaps *[]ipNetMap) {",
          "79:  switch {",
          "80:  case ip.To4() != nil:",
          "81:   netMaps = &w.ip4NetMaps",
          "82:  case ip.To16() != nil:",
          "83:   netMaps = &w.ip6NetMaps",
          "84:  default:",
          "85:   panic(fmt.Sprintf(\"IP (%s) is neither 4-byte nor 16-byte?\", ip.String()))",
          "86:  }",
          "88:  return netMaps",
          "89: }",
          "92: type ipNetMap struct {",
          "93:  mask net.IPMask",
          "94:  ips  map[string]bool",
          "95: }",
          "98: func (m ipNetMap) has(ip net.IP) bool {",
          "100:  ipMasked := ip.Mask(m.mask)",
          "101:  if ipMasked == nil {",
          "102:   panic(fmt.Sprintf(",
          "103:    \"Mismatch in net.IPMask and net.IP protocol version, cannot apply mask %s to %s\",",
          "104:    m.mask.String(), ip.String()))",
          "105:  }",
          "108:  if _, ok := m.ips[ipMasked.String()]; ok {",
          "109:   return true",
          "110:  }",
          "111:  return false",
          "112: }",
          "",
          "---------------"
        ],
        "pkg/ip/net_set_test.go||pkg/ip/net_set_test.go": [
          "File: pkg/ip/net_set_test.go -> pkg/ip/net_set_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package ip",
          "3: import (",
          "4:  \"net\"",
          "5:  \"testing\"",
          "7:  \"github.com/stretchr/testify/assert\"",
          "8: )",
          "10: func TestEmptyNetSet(t *testing.T) {",
          "11:  set := NewNetSet()",
          "13:  ips := []string{",
          "14:   \"127.0.0.1\",",
          "15:   \"241.163.75.163\",",
          "16:   \"189.248.81.89\",",
          "17:   \"167.75.10.139\",",
          "18:   \"22.169.8.110\",",
          "19:   \"::1\",",
          "20:   \"114d:28ae:60a:7b12:b851:fd49:5ff9:9b9d\",",
          "21:   \"4e73:55a5:6cd:29c7:5db6:673a:4608:1a3f\",",
          "22:   \"f6b0:d7f3:8206:b529:ee3b:49ff:1b3b:9aac\",",
          "23:   \"09d8:a74c:652f:3763:b87d:f068:b593:b588\",",
          "24:  }",
          "25:  for _, ip := range ips {",
          "26:   assert.Falsef(t, set.Has(net.ParseIP(ip)), \"Empty NetSet must not have %q\", ip)",
          "27:  }",
          "28: }",
          "30: func TestV4ContainsEverything(t *testing.T) {",
          "31:  set := NewNetSet()",
          "32:  set.AddIPNet(net.IPNet{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)})",
          "34:  ip4s := []string{",
          "35:   \"127.0.0.1\",",
          "36:   \"250.169.183.192\",",
          "37:   \"175.125.175.160\",",
          "38:   \"178.244.137.158\",",
          "39:   \"190.13.12.194\",",
          "40:  }",
          "41:  for _, ip := range ip4s {",
          "42:   assert.Truef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"0.0.0.0/0\\\"} must have %q\", ip)",
          "43:  }",
          "44:  ip6s := []string{",
          "45:   \"::1\",",
          "46:   \"7261:ca92:c9a5:4b79:2e:8889:b769:1d62\",",
          "47:   \"f54f:10cb:e6a4:89f5:3366:1e3e:2d22:f68e\",",
          "48:   \"d1f3:be6:60d:361:1717:4fe6:9812:1a6c\",",
          "49:   \"7eaa:2a8:365c:b55f:67cd:96dd:602a:4385\",",
          "50:  }",
          "51:  for _, ip := range ip6s {",
          "52:   assert.Falsef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"0.0.0.0/0\\\"} must not have %q\", ip)",
          "53:  }",
          "54: }",
          "56: func TestV6ContainsEverything(t *testing.T) {",
          "57:  set := NewNetSet()",
          "58:  set.AddIPNet(net.IPNet{IP: net.ParseIP(\"::\"), Mask: net.CIDRMask(0, 128)})",
          "60:  ip4s := []string{",
          "61:   \"127.0.0.1\",",
          "62:   \"216.163.140.97\",",
          "63:   \"175.55.31.226\",",
          "64:   \"115.112.186.19\",",
          "65:   \"250.83.241.122\",",
          "66:  }",
          "67:  for _, ip := range ip4s {",
          "68:   assert.Falsef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"::/0\\\"} must not have %q\", ip)",
          "69:  }",
          "70:  ip6s := []string{",
          "71:   \"::1\",",
          "72:   \"fa3b:7f17:7521:d9f4:d855:51f9:4b63:de7f\",",
          "73:   \"4d47:c29:2479:41ce:69f9:3d33:306a:91c8\",",
          "74:   \"fe99:f364:f8cd:7a11:838:a36f:b9a1:965\",",
          "75:   \"fb9e:d809:881d:9cee:533d:1ba5:592e:ea9b\",",
          "76:  }",
          "77:  for _, ip := range ip6s {",
          "78:   assert.Truef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"::/0\\\"} must have %q\", ip)",
          "79:  }",
          "80: }",
          "82: func TestLocalhostOnly(t *testing.T) {",
          "83:  set := NewNetSet()",
          "84:  set.AddIPNet(net.IPNet{IP: net.ParseIP(\"127.0.0.0\"), Mask: net.CIDRMask(8, 32)})",
          "85:  set.AddIPNet(net.IPNet{IP: net.ParseIP(\"::1\"), Mask: net.CIDRMask(128, 128)})",
          "87:  included := []string{",
          "88:   \"127.0.0.1\",",
          "89:   \"127.196.199.162\",",
          "90:   \"127.78.85.40\",",
          "91:   \"127.205.171.240\",",
          "92:   \"127.121.187.93\",",
          "93:   \"127.5.217.10\",",
          "94:   \"127.22.172.251\",",
          "95:   \"127.12.60.198\",",
          "96:   \"127.110.240.252\",",
          "97:   \"::1\",",
          "98:  }",
          "99:  for _, ip := range included {",
          "100:   assert.Truef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"127.0.0.0/8\\\", \\\"::1\\\"} must have %q\", ip)",
          "101:  }",
          "102:  excluded := []string{",
          "103:   \"15.65.169.230\",",
          "104:   \"196.72.207.65\",",
          "105:   \"43.46.246.121\",",
          "106:   \"69.147.193.224\",",
          "107:   \"43.130.74.115\",",
          "108:   \"8375:b8f9:70bf:a247:f55e:b0c0:c24f:eebe\",",
          "109:   \"d325:aabf:ef49:2d46:ba47:1aa5:9e57:b0bf\",",
          "110:   \"d2f6:831:170:e04e:bd6d:7ae7:e14a:71c3\",",
          "111:   \"ca80:483f:bb7f:df2a:bceb:de5e:6129:9625\",",
          "112:   \"f3fe:f771:9138:5d63:8e83:7033:2e6f:4762\",",
          "113:  }",
          "114:  for _, ip := range excluded {",
          "115:   assert.Falsef(t, set.Has(net.ParseIP(ip)), \"NetSet{\\\"127.0.0.0/8\\\", \\\"::1\\\"} must not have %q\", ip)",
          "116:  }",
          "117: }",
          "",
          "---------------"
        ],
        "pkg/ip/parse_ip_net.go||pkg/ip/parse_ip_net.go": [
          "File: pkg/ip/parse_ip_net.go -> pkg/ip/parse_ip_net.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package ip",
          "3: import (",
          "4:  \"net\"",
          "5:  \"strings\"",
          "6: )",
          "8: func ParseIPNet(s string) *net.IPNet {",
          "9:  if !strings.ContainsRune(s, '/') {",
          "10:   ip := net.ParseIP(s)",
          "11:   if ip == nil {",
          "12:    return nil",
          "13:   }",
          "15:   var mask net.IPMask",
          "16:   switch {",
          "17:   case ip.To4() != nil:",
          "18:    mask = net.CIDRMask(32, 32)",
          "19:   case ip.To16() != nil:",
          "20:    mask = net.CIDRMask(128, 128)",
          "21:   default:",
          "22:    return nil",
          "23:   }",
          "25:   return &net.IPNet{",
          "26:    IP:   ip,",
          "27:    Mask: mask,",
          "28:   }",
          "29:  }",
          "31:  switch ip, ipNet, err := net.ParseCIDR(s); {",
          "32:  case err != nil:",
          "33:   return nil",
          "34:  case !ipNet.IP.Equal(ip):",
          "35:   return nil",
          "36:  default:",
          "37:   return ipNet",
          "38:  }",
          "39: }",
          "",
          "---------------"
        ],
        "pkg/ip/realclientip.go||pkg/ip/realclientip.go": [
          "File: pkg/ip/realclientip.go -> pkg/ip/realclientip.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:  return ip, nil",
          "59: }",
          "62: func getRemoteIP(req *http.Request) (net.IP, error) {",
          "63:  if ipStr, _, err := net.SplitHostPort(req.RemoteAddr); err != nil {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: func GetClientIP(p ipapi.RealClientIPParser, req *http.Request) (net.IP, error) {",
          "63:  if p != nil {",
          "64:   return p.GetRealClientIP(req.Header)",
          "65:  }",
          "66:  return getRemoteIP(req)",
          "67: }",
          "",
          "---------------"
        ],
        "pkg/validation/options.go||pkg/validation/options.go": [
          "File: pkg/validation/options.go -> pkg/validation/options.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "225:   })",
          "226:  }",
          "228:  if len(msgs) != 0 {",
          "229:   return fmt.Errorf(\"invalid configuration:\\n  %s\",",
          "230:    strings.Join(msgs, \"\\n  \"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228:  if len(o.TrustedIPs) > 0 && o.ReverseProxy {",
          "229:   fmt.Fprintln(os.Stderr, \"WARNING: trusting of IPs with --reverse-proxy poses risks if a header spoofing attack is possible.\")",
          "230:  }",
          "232:  for i, ipStr := range o.TrustedIPs {",
          "233:   if nil == ip.ParseIPNet(ipStr) {",
          "234:    msgs = append(msgs, fmt.Sprintf(\"trusted_ips[%d] (%s) could not be recognized\", i, ipStr))",
          "235:   }",
          "236:  }",
          "",
          "---------------"
        ],
        "pkg/validation/options_test.go||pkg/validation/options_test.go": [
          "File: pkg/validation/options_test.go -> pkg/validation/options_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"crypto\"",
          "5:  \"io/ioutil\"",
          "6:  \"net/url\"",
          "7:  \"os\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5:  \"errors\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "352:  assert.Nil(t, o.GetRealClientIPParser())",
          "353: }",
          "355: func TestProviderCAFilesError(t *testing.T) {",
          "356:  file, err := ioutil.TempFile(\"\", \"absent.*.crt\")",
          "357:  assert.NoError(t, err)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356: func TestIPCIDRSetOption(t *testing.T) {",
          "357:  tests := []struct {",
          "358:   name       string",
          "359:   trustedIPs []string",
          "360:   err        error",
          "361:  }{",
          "362:   {",
          "363:    \"TestSomeIPs\",",
          "364:    []string{\"127.0.0.1\", \"10.32.0.1/32\", \"43.36.201.0/24\", \"::1\", \"2a12:105:ee7:9234:0:0:0:0/64\"},",
          "365:    nil,",
          "366:   }, {",
          "367:    \"TestOverlappingIPs\",",
          "368:    []string{\"135.180.78.199\", \"135.180.78.199/32\", \"d910:a5a1:16f8:ddf5:e5b9:5cef:a65e:41f4\", \"d910:a5a1:16f8:ddf5:e5b9:5cef:a65e:41f4/128\"},",
          "369:    nil,",
          "370:   }, {",
          "371:    \"TestInvalidIPs\",",
          "372:    []string{\"[::1]\", \"alkwlkbn/32\"},",
          "373:    errors.New(",
          "374:     \"invalid configuration:\\n\" +",
          "375:      \"  trusted_ips[0] ([::1]) could not be recognized\\n\" +",
          "376:      \"  trusted_ips[1] (alkwlkbn/32) could not be recognized\",",
          "377:    ),",
          "378:   },",
          "379:  }",
          "381:  for _, tt := range tests {",
          "382:   t.Run(tt.name, func(t *testing.T) {",
          "383:    o := testOptions()",
          "384:    o.TrustedIPs = tt.trustedIPs",
          "385:    err := Validate(o)",
          "386:    if tt.err == nil {",
          "387:     assert.Nil(t, err)",
          "388:    } else {",
          "389:     assert.Equal(t, tt.err.Error(), err.Error())",
          "390:    }",
          "391:   })",
          "392:  }",
          "393: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9bbd6adce97057d2107d60b2a9494974bbc8a601",
      "candidate_info": {
        "commit_hash": "9bbd6adce97057d2107d60b2a9494974bbc8a601",
        "repo": "oauth2-proxy/oauth2-proxy",
        "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/9bbd6adce97057d2107d60b2a9494974bbc8a601",
        "files": [
          "http.go",
          "http_test.go",
          "logging_handler.go",
          "logging_handler_test.go",
          "main.go",
          "oauthproxy.go",
          "pkg/validation/logging.go",
          "pkg/validation/options.go"
        ],
        "message": "Integrate HealthCheck middleware",
        "before_after_code_files": [
          "http.go||http.go",
          "http_test.go||http_test.go",
          "logging_handler.go||logging_handler.go",
          "logging_handler_test.go||logging_handler_test.go",
          "main.go||main.go",
          "oauthproxy.go||oauthproxy.go",
          "pkg/validation/logging.go||pkg/validation/logging.go",
          "pkg/validation/options.go||pkg/validation/options.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "oauthproxy.go||oauthproxy.go"
          ],
          "candidate": [
            "oauthproxy.go||oauthproxy.go"
          ]
        }
      },
      "candidate_diff": {
        "http.go||http.go": [
          "File: http.go -> http.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:  \"strings\"",
          "10:  \"time\"",
          "12:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/apis/options\"",
          "13:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/logger\"",
          "14: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12:  \"github.com/justinas/alice\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:  }",
          "30: }",
          "72: func (s *Server) ServeHTTP() {",
          "73:  HTTPAddress := s.Opts.HTTPAddress",
          "",
          "[Removed Lines]",
          "33: const userAgentHeader = \"User-Agent\"",
          "34: const googleHealthCheckUserAgent = \"GoogleHC/1.0\"",
          "35: const rootPath = \"/\"",
          "38: func gcpHealthcheck(h http.Handler) http.Handler {",
          "39:  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {",
          "41:   if r.URL.EscapedPath() == \"/liveness_check\" {",
          "42:    w.WriteHeader(http.StatusOK)",
          "43:    w.Write([]byte(\"OK\"))",
          "44:    return",
          "45:   }",
          "46:   if r.URL.EscapedPath() == \"/readiness_check\" {",
          "47:    w.WriteHeader(http.StatusOK)",
          "48:    w.Write([]byte(\"OK\"))",
          "49:    return",
          "50:   }",
          "59:   if r.URL.Path == rootPath &&",
          "60:    r.Header.Get(userAgentHeader) == googleHealthCheckUserAgent &&",
          "61:    r.Method == http.MethodGet {",
          "63:    w.WriteHeader(http.StatusOK)",
          "64:    return",
          "65:   }",
          "67:   h.ServeHTTP(w, r)",
          "68:  })",
          "69: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "168:  return tc, nil",
          "169: }",
          "171: func redirectToHTTPS(opts *options.Options, h http.Handler) http.Handler {",
          "172:  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {",
          "173:   proto := r.Header.Get(\"X-Forwarded-Proto\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: func newRedirectToHTTPS(opts *options.Options) alice.Constructor {",
          "134:  return func(next http.Handler) http.Handler {",
          "135:   return redirectToHTTPS(opts, next)",
          "136:  }",
          "137: }",
          "",
          "---------------"
        ],
        "http_test.go||http_test.go": [
          "File: http_test.go -> http_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  \"github.com/stretchr/testify/assert\"",
          "12: )",
          "113: func TestRedirectToHTTPSTrue(t *testing.T) {",
          "114:  opts := options.NewOptions()",
          "115:  opts.ForceHTTPS = true",
          "",
          "[Removed Lines]",
          "14: const localhost = \"127.0.0.1\"",
          "15: const host = \"test-server\"",
          "17: func TestGCPHealthcheckLiveness(t *testing.T) {",
          "18:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "19:   w.Write([]byte(\"test\"))",
          "20:  }",
          "22:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "23:  rw := httptest.NewRecorder()",
          "24:  r, _ := http.NewRequest(\"GET\", \"/liveness_check\", nil)",
          "25:  r.RemoteAddr = localhost",
          "26:  r.Host = host",
          "27:  h.ServeHTTP(rw, r)",
          "29:  assert.Equal(t, 200, rw.Code)",
          "30:  assert.Equal(t, \"OK\", rw.Body.String())",
          "31: }",
          "33: func TestGCPHealthcheckReadiness(t *testing.T) {",
          "34:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "35:   w.Write([]byte(\"test\"))",
          "36:  }",
          "38:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "39:  rw := httptest.NewRecorder()",
          "40:  r, _ := http.NewRequest(\"GET\", \"/readiness_check\", nil)",
          "41:  r.RemoteAddr = localhost",
          "42:  r.Host = host",
          "43:  h.ServeHTTP(rw, r)",
          "45:  assert.Equal(t, 200, rw.Code)",
          "46:  assert.Equal(t, \"OK\", rw.Body.String())",
          "47: }",
          "49: func TestGCPHealthcheckNotHealthcheck(t *testing.T) {",
          "50:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "51:   w.Write([]byte(\"test\"))",
          "52:  }",
          "54:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "55:  rw := httptest.NewRecorder()",
          "56:  r, _ := http.NewRequest(\"GET\", \"/not_any_check\", nil)",
          "57:  r.RemoteAddr = localhost",
          "58:  r.Host = host",
          "59:  h.ServeHTTP(rw, r)",
          "61:  assert.Equal(t, \"test\", rw.Body.String())",
          "62: }",
          "64: func TestGCPHealthcheckIngress(t *testing.T) {",
          "65:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "66:   w.Write([]byte(\"test\"))",
          "67:  }",
          "69:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "70:  rw := httptest.NewRecorder()",
          "71:  r, _ := http.NewRequest(\"GET\", \"/\", nil)",
          "72:  r.RemoteAddr = localhost",
          "73:  r.Host = host",
          "74:  r.Header.Set(userAgentHeader, googleHealthCheckUserAgent)",
          "75:  h.ServeHTTP(rw, r)",
          "77:  assert.Equal(t, 200, rw.Code)",
          "78:  assert.Equal(t, \"\", rw.Body.String())",
          "79: }",
          "81: func TestGCPHealthcheckNotIngress(t *testing.T) {",
          "82:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "83:   w.Write([]byte(\"test\"))",
          "84:  }",
          "86:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "87:  rw := httptest.NewRecorder()",
          "88:  r, _ := http.NewRequest(\"GET\", \"/foo\", nil)",
          "89:  r.RemoteAddr = localhost",
          "90:  r.Host = host",
          "91:  r.Header.Set(userAgentHeader, googleHealthCheckUserAgent)",
          "92:  h.ServeHTTP(rw, r)",
          "94:  assert.Equal(t, \"test\", rw.Body.String())",
          "95: }",
          "97: func TestGCPHealthcheckNotIngressPut(t *testing.T) {",
          "98:  handler := func(w http.ResponseWriter, req *http.Request) {",
          "99:   w.Write([]byte(\"test\"))",
          "100:  }",
          "102:  h := gcpHealthcheck(http.HandlerFunc(handler))",
          "103:  rw := httptest.NewRecorder()",
          "104:  r, _ := http.NewRequest(\"PUT\", \"/\", nil)",
          "105:  r.RemoteAddr = localhost",
          "106:  r.Host = host",
          "107:  r.Header.Set(userAgentHeader, googleHealthCheckUserAgent)",
          "108:  h.ServeHTTP(rw, r)",
          "110:  assert.Equal(t, \"test\", rw.Body.String())",
          "111: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "logging_handler.go||logging_handler.go": [
          "File: logging_handler.go -> logging_handler.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  size     int",
          "22:  upstream string",
          "23:  authInfo string",
          "25: }",
          "",
          "[Removed Lines]",
          "24:  silent   bool",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:  url := *req.URL",
          "106:  responseLogger := &responseLogger{w: w}",
          "107:  h.handler.ServeHTTP(responseLogger, req)",
          "111: }",
          "",
          "[Removed Lines]",
          "108:  if !responseLogger.silent {",
          "109:   logger.PrintReq(responseLogger.authInfo, responseLogger.upstream, req, url, t, responseLogger.Status(), responseLogger.Size())",
          "110:  }",
          "",
          "[Added Lines]",
          "107:  logger.PrintReq(responseLogger.authInfo, responseLogger.upstream, req, url, t, responseLogger.Status(), responseLogger.Size())",
          "",
          "---------------"
        ],
        "logging_handler_test.go||logging_handler_test.go": [
          "File: logging_handler_test.go -> logging_handler_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:  \"fmt\"",
          "6:  \"net/http\"",
          "7:  \"net/http/httptest\"",
          "9:  \"strings\"",
          "10:  \"testing\"",
          "11:  \"time\"",
          "14:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/logger\"",
          "16: )",
          "18: func TestLoggingHandler_ServeHTTP(t *testing.T) {",
          "",
          "[Removed Lines]",
          "8:  \"net/url\"",
          "13:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/apis/options\"",
          "15:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/validation\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:   Format,",
          "23:   ExpectedLogMessage,",
          "24:   Path string",
          "27:  }{",
          "40:  }",
          "42:  for _, test := range tests {",
          "",
          "[Removed Lines]",
          "25:   ExcludePaths       []string",
          "26:   SilencePingLogging bool",
          "28:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{}, false},",
          "29:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{}, true},",
          "30:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{\"/ping\"}, false},",
          "31:   {logger.DefaultRequestLoggingFormat, \"\", \"/foo/bar\", []string{\"/foo/bar\"}, false},",
          "32:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{}, true},",
          "33:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/ping\"}, false},",
          "34:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/ping\"}, true},",
          "35:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/foo/bar\", \"/ping\"}, false},",
          "36:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/foo/bar\", []string{}, true},",
          "37:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/foo/bar\", []string{\"/ping\"}, false},",
          "38:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/ping\", []string{}, false},",
          "39:   {\"{{.RequestMethod}}\", \"\", \"/ping\", []string{\"/ping\"}, true},",
          "",
          "[Added Lines]",
          "22:   ExcludePaths []string",
          "24:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{}},",
          "25:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{}},",
          "26:   {logger.DefaultRequestLoggingFormat, fmt.Sprintf(\"127.0.0.1 - - [%s] test-server GET - \\\"/foo/bar\\\" HTTP/1.1 \\\"\\\" 200 4 0.000\\n\", logger.FormatTimestamp(ts)), \"/foo/bar\", []string{\"/ping\"}},",
          "27:   {logger.DefaultRequestLoggingFormat, \"\", \"/foo/bar\", []string{\"/foo/bar\"}},",
          "28:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{}},",
          "29:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/ping\"}},",
          "30:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/ping\"}},",
          "31:   {logger.DefaultRequestLoggingFormat, \"\", \"/ping\", []string{\"/foo/bar\", \"/ping\"}},",
          "32:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/foo/bar\", []string{}},",
          "33:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/foo/bar\", []string{\"/ping\"}},",
          "34:   {\"{{.RequestMethod}}\", \"GET\\n\", \"/ping\", []string{}},",
          "35:   {\"{{.RequestMethod}}\", \"\", \"/ping\", []string{\"/ping\"}},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "53:   logger.SetOutput(buf)",
          "54:   logger.SetReqTemplate(test.Format)",
          "58:   logger.SetExcludePaths(test.ExcludePaths)",
          "59:   h := LoggingHandler(http.HandlerFunc(handler))",
          "",
          "[Removed Lines]",
          "55:   if test.SilencePingLogging {",
          "56:    test.ExcludePaths = append(test.ExcludePaths, \"/ping\")",
          "57:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:   }",
          "71:  }",
          "72: }",
          "",
          "[Removed Lines]",
          "74: func TestLoggingHandler_PingUserAgent(t *testing.T) {",
          "75:  tests := []struct {",
          "76:   ExpectedLogMessage string",
          "77:   Path               string",
          "78:   SilencePingLogging bool",
          "79:   WithUserAgent      string",
          "80:  }{",
          "81:   {\"444\\n\", \"/foo\", true, \"Blah\"},",
          "82:   {\"444\\n\", \"/foo\", false, \"Blah\"},",
          "83:   {\"\", \"/ping\", true, \"Blah\"},",
          "84:   {\"200\\n\", \"/ping\", false, \"Blah\"},",
          "85:   {\"\", \"/ping\", true, \"PingMe!\"},",
          "86:   {\"\", \"/ping\", false, \"PingMe!\"},",
          "87:   {\"\", \"/foo\", true, \"PingMe!\"},",
          "88:   {\"\", \"/foo\", false, \"PingMe!\"},",
          "89:  }",
          "91:  for idx, test := range tests {",
          "92:   t.Run(fmt.Sprintf(\"%d\", idx), func(t *testing.T) {",
          "93:    opts := options.NewOptions()",
          "94:    opts.PingUserAgent = \"PingMe!\"",
          "95:    opts.SkipAuthRegex = []string{\"/foo\"}",
          "96:    opts.Upstreams = []string{\"static://444/foo\"}",
          "97:    opts.Logging.SilencePing = test.SilencePingLogging",
          "98:    if test.SilencePingLogging {",
          "99:     opts.Logging.ExcludePaths = []string{\"/ping\"}",
          "100:    }",
          "101:    opts.RawRedirectURL = \"localhost\"",
          "102:    validation.Validate(opts)",
          "104:    p := NewOAuthProxy(opts, func(email string) bool {",
          "105:     return true",
          "106:    })",
          "107:    p.provider = NewTestProvider(&url.URL{Host: \"localhost\"}, \"\")",
          "109:    buf := bytes.NewBuffer(nil)",
          "110:    logger.SetOutput(buf)",
          "111:    logger.SetReqEnabled(true)",
          "112:    logger.SetReqTemplate(\"{{.StatusCode}}\")",
          "114:    r, _ := http.NewRequest(\"GET\", test.Path, nil)",
          "115:    if test.WithUserAgent != \"\" {",
          "116:     r.Header.Set(\"User-Agent\", test.WithUserAgent)",
          "117:    }",
          "119:    h := LoggingHandler(p)",
          "120:    h.ServeHTTP(httptest.NewRecorder(), r)",
          "122:    actual := buf.String()",
          "123:    if !strings.Contains(actual, test.ExpectedLogMessage) {",
          "124:     t.Errorf(\"Log message was\\n%s\\ninstead of matching \\n%s\", actual, test.ExpectedLogMessage)",
          "125:    }",
          "126:   })",
          "127:  }",
          "128: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "main.go||main.go": [
          "File: main.go -> main.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"fmt\"",
          "5:  \"math/rand\"",
          "7:  \"os\"",
          "8:  \"os/signal\"",
          "9:  \"runtime\"",
          "",
          "[Removed Lines]",
          "6:  \"net/http\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:  \"syscall\"",
          "12:  \"time\"",
          "14:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/apis/options\"",
          "15:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/logger\"",
          "16:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/validation\"",
          "17: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13:  \"github.com/justinas/alice\"",
          "16:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/middleware\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72:  rand.Seed(time.Now().UnixNano())",
          "75:  if opts.GCPHealthChecks {",
          "77:  } else {",
          "79:  }",
          "80:  s := &Server{",
          "82:   Opts:    opts,",
          "83:   stop:    make(chan struct{}, 1),",
          "84:  }",
          "",
          "[Removed Lines]",
          "74:  var handler http.Handler",
          "76:   handler = redirectToHTTPS(opts, gcpHealthcheck(LoggingHandler(oauthproxy)))",
          "78:   handler = redirectToHTTPS(opts, LoggingHandler(oauthproxy))",
          "81:   Handler: handler,",
          "",
          "[Added Lines]",
          "75:  chain := alice.New()",
          "77:  if opts.ForceHTTPS {",
          "78:   chain = chain.Append(newRedirectToHTTPS(opts))",
          "79:  }",
          "81:  healthCheckPaths := []string{opts.PingPath}",
          "82:  healthCheckUserAgents := []string{opts.PingUserAgent}",
          "84:   healthCheckPaths = append(healthCheckPaths, \"/liveness_check\", \"/readiness_check\")",
          "85:   healthCheckUserAgents = append(healthCheckUserAgents, \"GoogleHC/1.0\")",
          "86:  }",
          "90:  if opts.Logging.SilencePing {",
          "91:   chain = chain.Append(middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents), LoggingHandler)",
          "93:   chain = chain.Append(LoggingHandler, middleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents))",
          "97:   Handler: chain.Then(oauthproxy),",
          "",
          "---------------"
        ],
        "oauthproxy.go||oauthproxy.go": [
          "File: oauthproxy.go -> oauthproxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:  Validator      func(string) bool",
          "83:  RobotsPath        string",
          "87:  SignInPath        string",
          "88:  SignOutPath       string",
          "89:  OAuthStartPath    string",
          "",
          "[Removed Lines]",
          "84:  PingPath          string",
          "85:  PingUserAgent     string",
          "86:  SilencePings      bool",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "313:   Validator:      validator,",
          "315:   RobotsPath:        \"/robots.txt\",",
          "319:   SignInPath:        fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),",
          "320:   SignOutPath:       fmt.Sprintf(\"%s/sign_out\", opts.ProxyPrefix),",
          "321:   OAuthStartPath:    fmt.Sprintf(\"%s/start\", opts.ProxyPrefix),",
          "",
          "[Removed Lines]",
          "316:   PingPath:          opts.PingPath,",
          "317:   PingUserAgent:     opts.PingUserAgent,",
          "318:   SilencePings:      opts.Logging.SilencePing,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "468:  fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")",
          "469: }",
          "483: func (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, code int, title string, message string) {",
          "484:  rw.WriteHeader(code)",
          "",
          "[Removed Lines]",
          "472: func (p *OAuthProxy) PingPage(rw http.ResponseWriter) {",
          "473:  if p.SilencePings {",
          "474:   if rl, ok := rw.(*responseLogger); ok {",
          "475:    rl.silent = true",
          "476:   }",
          "477:  }",
          "478:  rw.WriteHeader(http.StatusOK)",
          "479:  fmt.Fprintf(rw, \"OK\")",
          "480: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "684:  }",
          "685: }",
          "698: func (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {",
          "699:  if strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {",
          "700:   prepareNoCache(rw)",
          "",
          "[Removed Lines]",
          "689: func (p *OAuthProxy) IsPingRequest(req *http.Request) bool {",
          "691:  if req.URL.EscapedPath() == p.PingPath {",
          "692:   return true",
          "693:  }",
          "695:  return p.PingUserAgent != \"\" && req.Header.Get(\"User-Agent\") == p.PingUserAgent",
          "696: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "703:  switch path := req.URL.Path; {",
          "704:  case path == p.RobotsPath:",
          "705:   p.RobotsTxt(rw)",
          "708:  case p.IsWhitelistedRequest(req):",
          "709:   p.serveMux.ServeHTTP(rw, req)",
          "710:  case path == p.SignInPath:",
          "",
          "[Removed Lines]",
          "706:  case p.IsPingRequest(req):",
          "707:   p.PingPage(rw)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pkg/validation/logging.go||pkg/validation/logging.go": [
          "File: pkg/validation/logging.go -> pkg/validation/logging.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: )",
          "14:  if len(o.File.Filename) > 0 {",
          "",
          "[Removed Lines]",
          "12: func configureLogger(o options.Logging, pingPath string, msgs []string) []string {",
          "",
          "[Added Lines]",
          "12: func configureLogger(o options.Logging, msgs []string) []string {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:  logger.SetAuthTemplate(o.AuthFormat)",
          "49:  logger.SetReqTemplate(o.RequestFormat)",
          "57:  if !o.LocalTime {",
          "58:   logger.SetFlags(logger.Flags() | logger.LUTC)",
          "",
          "[Removed Lines]",
          "51:  excludePaths := o.ExcludePaths",
          "52:  if o.SilencePing {",
          "53:   excludePaths = append(excludePaths, pingPath)",
          "54:  }",
          "55:  logger.SetExcludePaths(excludePaths)",
          "",
          "[Added Lines]",
          "51:  logger.SetExcludePaths(o.ExcludePaths)",
          "",
          "---------------"
        ],
        "pkg/validation/options.go||pkg/validation/options.go": [
          "File: pkg/validation/options.go -> pkg/validation/options.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:  msgs = parseSignatureKey(o, msgs)",
          "266:  msgs = validateCookieName(o, msgs)",
          "269:  if o.ReverseProxy {",
          "270:   parser, err := ip.GetRealClientIPParser(o.RealClientIPHeader)",
          "",
          "[Removed Lines]",
          "267:  msgs = configureLogger(o.Logging, o.PingPath, msgs)",
          "",
          "[Added Lines]",
          "267:  msgs = configureLogger(o.Logging, msgs)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "65c228394fb1a18c824eb472be07b848dd595745",
      "candidate_info": {
        "commit_hash": "65c228394fb1a18c824eb472be07b848dd595745",
        "repo": "oauth2-proxy/oauth2-proxy",
        "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/65c228394fb1a18c824eb472be07b848dd595745",
        "files": [
          "CHANGELOG.md",
          "http.go",
          "main.go",
          "oauthproxy.go",
          "pkg/authentication/basic/htpasswd.go",
          "pkg/encryption/utils.go",
          "pkg/logger/logger.go",
          "pkg/middleware/stored_session.go",
          "pkg/upstream/http.go",
          "pkg/upstream/proxy.go",
          "pkg/util/util.go",
          "pkg/validation/logging.go",
          "pkg/validation/options.go",
          "providers/logingov.go",
          "validator.go",
          "watcher.go"
        ],
        "message": "Address gosec findings\n\nMostly handling unhandled errors appropriately.\nIf logging to STDERR fails, we panic. Added #nosec\ncomments to findings we are OK with.",
        "before_after_code_files": [
          "http.go||http.go",
          "main.go||main.go",
          "oauthproxy.go||oauthproxy.go",
          "pkg/authentication/basic/htpasswd.go||pkg/authentication/basic/htpasswd.go",
          "pkg/encryption/utils.go||pkg/encryption/utils.go",
          "pkg/logger/logger.go||pkg/logger/logger.go",
          "pkg/middleware/stored_session.go||pkg/middleware/stored_session.go",
          "pkg/upstream/http.go||pkg/upstream/http.go",
          "pkg/upstream/proxy.go||pkg/upstream/proxy.go",
          "pkg/util/util.go||pkg/util/util.go",
          "pkg/validation/logging.go||pkg/validation/logging.go",
          "pkg/validation/options.go||pkg/validation/options.go",
          "providers/logingov.go||providers/logingov.go",
          "validator.go||validator.go",
          "watcher.go||watcher.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "oauthproxy.go||oauthproxy.go"
          ],
          "candidate": [
            "oauthproxy.go||oauthproxy.go"
          ]
        }
      },
      "candidate_diff": {
        "http.go||http.go": [
          "File: http.go -> http.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:  if err != nil {",
          "125:   return",
          "126:  }",
          "129:  return tc, nil",
          "130: }",
          "",
          "[Removed Lines]",
          "127:  tc.SetKeepAlive(true)",
          "128:  tc.SetKeepAlivePeriod(3 * time.Minute)",
          "",
          "[Added Lines]",
          "127:  err = tc.SetKeepAlive(true)",
          "128:  if err != nil {",
          "129:   return nil, err",
          "130:  }",
          "131:  err = tc.SetKeepAlivePeriod(3 * time.Minute)",
          "132:  if err != nil {",
          "133:   return nil, err",
          "134:  }",
          "",
          "---------------"
        ],
        "main.go||main.go": [
          "File: main.go -> main.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  config := flagSet.String(\"config\", \"\", \"path to config file\")",
          "26:  showVersion := flagSet.Bool(\"version\", false, \"print version string\")",
          "30:  if *showVersion {",
          "31:   fmt.Printf(\"oauth2-proxy %s (built with %s)\\n\", VERSION, runtime.Version())",
          "",
          "[Removed Lines]",
          "28:  flagSet.Parse(os.Args[1:])",
          "",
          "[Added Lines]",
          "28:  err := flagSet.Parse(os.Args[1:])",
          "29:  if err != nil {",
          "30:   logger.Printf(\"ERROR: Failed to parse flags: %v\", err)",
          "31:   os.Exit(1)",
          "32:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:  }",
          "35:  legacyOpts := options.NewLegacyOptions()",
          "37:  if err != nil {",
          "38:   logger.Printf(\"ERROR: Failed to load config: %v\", err)",
          "39:   os.Exit(1)",
          "",
          "[Removed Lines]",
          "36:  err := options.Load(*config, flagSet, legacyOpts)",
          "",
          "[Added Lines]",
          "40:  err = options.Load(*config, flagSet, legacyOpts)",
          "",
          "---------------"
        ],
        "oauthproxy.go||oauthproxy.go": [
          "File: oauthproxy.go -> oauthproxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "365: func (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {",
          "366:  rw.WriteHeader(http.StatusOK)",
          "368: }",
          "",
          "[Removed Lines]",
          "367:  fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")",
          "",
          "[Added Lines]",
          "367:  _, err := fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")",
          "368:  if err != nil {",
          "369:   logger.Printf(\"Error writing robots.txt: %s\", err.Error())",
          "370:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "371:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "379:   Message:     message,",
          "380:   ProxyPrefix: p.ProxyPrefix,",
          "381:  }",
          "383: }",
          "386: func (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {",
          "387:  prepareNoCache(rw)",
          "389:  rw.WriteHeader(code)",
          "391:  redirectURL, err := p.GetRedirect(req)",
          "",
          "[Removed Lines]",
          "382:  p.templates.ExecuteTemplate(rw, \"error.html\", t)",
          "388:  p.ClearSessionCookie(rw, req)",
          "",
          "[Added Lines]",
          "386:  err := p.templates.ExecuteTemplate(rw, \"error.html\", t)",
          "387:  if err != nil {",
          "388:   logger.Printf(\"Error rendering error.html template: %s\", err.Error())",
          "389:   http.Error(rw, \"Internal Server Error\", http.StatusInternalServerError)",
          "390:  }",
          "396:  err := p.ClearSessionCookie(rw, req)",
          "397:  if err != nil {",
          "398:   logger.Printf(\"Error clearing session cookie: %s\", err.Error())",
          "399:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "400:   return",
          "401:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "419:  if p.providerNameOverride != \"\" {",
          "420:   t.ProviderName = p.providerNameOverride",
          "421:  }",
          "423: }",
          "427:  if req.Method != \"POST\" || p.basicAuthValidator == nil {",
          "428:   return \"\", false",
          "429:  }",
          "",
          "[Removed Lines]",
          "422:  p.templates.ExecuteTemplate(rw, \"sign_in.html\", t)",
          "426: func (p *OAuthProxy) ManualSignIn(rw http.ResponseWriter, req *http.Request) (string, bool) {",
          "",
          "[Added Lines]",
          "435:  err = p.templates.ExecuteTemplate(rw, \"sign_in.html\", t)",
          "436:  if err != nil {",
          "437:   logger.Printf(\"Error rendering sign_in.html template: %s\", err.Error())",
          "438:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "439:  }",
          "443: func (p *OAuthProxy) ManualSignIn(req *http.Request) (string, bool) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "632:   return",
          "633:  }",
          "636:  if ok {",
          "637:   session := &sessionsapi.SessionState{User: user}",
          "639:   http.Redirect(rw, req, redirect, http.StatusFound)",
          "640:  } else {",
          "641:   if p.SkipProviderButton {",
          "",
          "[Removed Lines]",
          "635:  user, ok := p.ManualSignIn(rw, req)",
          "638:   p.SaveSession(rw, req, session)",
          "",
          "[Added Lines]",
          "652:  user, ok := p.ManualSignIn(req)",
          "655:   err = p.SaveSession(rw, req, session)",
          "656:   if err != nil {",
          "657:    logger.Printf(\"Error saving session: %s\", err.Error())",
          "658:    p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "659:    return",
          "660:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "663:  }",
          "664:  rw.Header().Set(\"Content-Type\", \"application/json\")",
          "665:  rw.WriteHeader(http.StatusOK)",
          "667: }",
          "",
          "[Removed Lines]",
          "666:  json.NewEncoder(rw).Encode(userInfo)",
          "",
          "[Added Lines]",
          "688:  err = json.NewEncoder(rw).Encode(userInfo)",
          "689:  if err != nil {",
          "690:   logger.Printf(\"Error encoding user info: %s\", err.Error())",
          "691:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "692:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "674:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "675:   return",
          "676:  }",
          "678:  http.Redirect(rw, req, redirect, http.StatusFound)",
          "679: }",
          "",
          "[Removed Lines]",
          "677:  p.ClearSessionCookie(rw, req)",
          "",
          "[Added Lines]",
          "703:  err = p.ClearSessionCookie(rw, req)",
          "704:  if err != nil {",
          "705:   logger.Printf(\"Error clearing session cookie: %s\", err.Error())",
          "706:   p.ErrorPage(rw, 500, \"Internal Error\", err.Error())",
          "707:   return",
          "708:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "837:  if session != nil && session.Email != \"\" && !p.Validator(session.Email) {",
          "838:   logger.Printf(session.Email, req, logger.AuthFailure, \"Invalid authentication via session: removing session %s\", session)",
          "841:   return nil, ErrNeedsLogin",
          "842:  }",
          "",
          "[Removed Lines]",
          "840:   p.ClearSessionCookie(rw, req)",
          "",
          "[Added Lines]",
          "871:   err := p.ClearSessionCookie(rw, req)",
          "872:   if err != nil {",
          "873:    logger.Printf(\"Error clearing session cookie: %s\", err.Error())",
          "874:   }",
          "",
          "---------------"
        ],
        "pkg/authentication/basic/htpasswd.go||pkg/authentication/basic/htpasswd.go": [
          "File: pkg/authentication/basic/htpasswd.go -> pkg/authentication/basic/htpasswd.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: package basic",
          "3: import (",
          "5:  \"encoding/base64\"",
          "6:  \"encoding/csv\"",
          "7:  \"fmt\"",
          "",
          "[Removed Lines]",
          "4:  \"crypto/sha1\"",
          "",
          "[Added Lines]",
          "4:  \"crypto/sha1\" // #nosec G505",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: func NewHTPasswdValidator(path string) (Validator, error) {",
          "33:  if err != nil {",
          "34:   return nil, fmt.Errorf(\"could not open htpasswd file: %v\", err)",
          "35:  }",
          "37:  return newHtpasswd(r)",
          "38: }",
          "",
          "[Removed Lines]",
          "32:  r, err := os.Open(path)",
          "36:  defer r.Close()",
          "",
          "[Added Lines]",
          "32:  r, err := os.Open(path) // #nosec G304",
          "36:  defer func(c io.Closer) {",
          "37:   cerr := c.Close()",
          "38:   if cerr != nil {",
          "39:    logger.Fatalf(\"error closing the htpasswd file: %v\", cerr)",
          "40:   }",
          "41:  }(r)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:   return false",
          "84:  }",
          "87:  case sha1Pass:",
          "91:  case bcryptPass:",
          "93:  default:",
          "94:   return false",
          "95:  }",
          "",
          "[Removed Lines]",
          "86:  switch real := realPassword.(type) {",
          "88:   d := sha1.New()",
          "89:   d.Write([]byte(password))",
          "90:   return string(real) == base64.StdEncoding.EncodeToString(d.Sum(nil))",
          "92:   return bcrypt.CompareHashAndPassword([]byte(real), []byte(password)) == nil",
          "",
          "[Added Lines]",
          "91:  switch rp := realPassword.(type) {",
          "93:   d := sha1.New() // #nosec G401",
          "94:   _, err := d.Write([]byte(password))",
          "95:   if err != nil {",
          "96:    return false",
          "97:   }",
          "98:   return string(rp) == base64.StdEncoding.EncodeToString(d.Sum(nil))",
          "100:   return bcrypt.CompareHashAndPassword([]byte(rp), []byte(password)) == nil",
          "",
          "---------------"
        ],
        "pkg/encryption/utils.go||pkg/encryption/utils.go": [
          "File: pkg/encryption/utils.go -> pkg/encryption/utils.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"crypto/hmac\"",
          "6:  \"crypto/sha256\"",
          "7:  \"encoding/base64\"",
          "8:  \"fmt\"",
          "9:  \"hash\"",
          "10:  \"net/http\"",
          "11:  \"strconv\"",
          "12:  \"strings\"",
          "13:  \"time\"",
          "14: )",
          "",
          "[Removed Lines]",
          "5:  \"crypto/sha1\"",
          "",
          "[Added Lines]",
          "5:  \"crypto/rand\"",
          "6:  \"crypto/sha1\" // #nosec G505",
          "11:  \"io\"",
          "17:  \"github.com/oauth2-proxy/oauth2-proxy/pkg/logger\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76: func cookieSignature(signer func() hash.Hash, args ...string) string {",
          "77:  h := hmac.New(signer, []byte(args[0]))",
          "78:  for _, arg := range args[1:] {",
          "80:  }",
          "81:  var b []byte",
          "82:  b = h.Sum(b)",
          "",
          "[Removed Lines]",
          "79:   h.Write([]byte(arg))",
          "",
          "[Added Lines]",
          "83:   _, err := h.Write([]byte(arg))",
          "85:   if err != nil {",
          "86:    garbage := make([]byte, 16)",
          "87:    if _, err := io.ReadFull(rand.Reader, garbage); err != nil {",
          "88:     logger.Fatal(\"HMAC & RNG functions both failing. Shutting down for security\")",
          "89:    }",
          "90:    return base64.URLEncoding.EncodeToString(garbage)",
          "91:   }",
          "",
          "---------------"
        ],
        "pkg/logger/logger.go||pkg/logger/logger.go": [
          "File: pkg/logger/logger.go -> pkg/logger/logger.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "132:  l.mu.Lock()",
          "133:  defer l.mu.Unlock()",
          "136:   Timestamp: FormatTimestamp(now),",
          "137:   File:      file,",
          "138:   Message:   message,",
          "139:  })",
          "142: }",
          "",
          "[Removed Lines]",
          "135:  l.stdLogTemplate.Execute(l.writer, stdLogMessageData{",
          "141:  l.writer.Write([]byte(\"\\n\"))",
          "",
          "[Added Lines]",
          "135:  err := l.stdLogTemplate.Execute(l.writer, stdLogMessageData{",
          "140:  if err != nil {",
          "141:   panic(err)",
          "142:  }",
          "144:  _, err = l.writer.Write([]byte(\"\\n\"))",
          "145:  if err != nil {",
          "146:   panic(err)",
          "147:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:  l.mu.Lock()",
          "161:  defer l.mu.Unlock()",
          "164:   Client:        client,",
          "165:   Host:          req.Host,",
          "166:   Protocol:      req.Proto,",
          "",
          "[Removed Lines]",
          "163:  l.authTemplate.Execute(l.writer, authLogMessageData{",
          "",
          "[Added Lines]",
          "169:  err := l.authTemplate.Execute(l.writer, authLogMessageData{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:   Status:        string(status),",
          "172:   Message:       fmt.Sprintf(format, a...),",
          "173:  })",
          "176: }",
          "",
          "[Removed Lines]",
          "175:  l.writer.Write([]byte(\"\\n\"))",
          "",
          "[Added Lines]",
          "180:  if err != nil {",
          "181:   panic(err)",
          "182:  }",
          "184:  _, err = l.writer.Write([]byte(\"\\n\"))",
          "185:  if err != nil {",
          "186:   panic(err)",
          "187:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "208:  l.mu.Lock()",
          "209:  defer l.mu.Unlock()",
          "212:   Client:          client,",
          "213:   Host:            req.Host,",
          "214:   Protocol:        req.Proto,",
          "",
          "[Removed Lines]",
          "211:  l.reqTemplate.Execute(l.writer, reqLogMessageData{",
          "",
          "[Added Lines]",
          "223:  err := l.reqTemplate.Execute(l.writer, reqLogMessageData{",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "222:   UserAgent:       fmt.Sprintf(\"%q\", req.UserAgent()),",
          "223:   Username:        username,",
          "224:  })",
          "227: }",
          "",
          "[Removed Lines]",
          "226:  l.writer.Write([]byte(\"\\n\"))",
          "",
          "[Added Lines]",
          "237:  if err != nil {",
          "238:   panic(err)",
          "239:  }",
          "241:  _, err = l.writer.Write([]byte(\"\\n\"))",
          "242:  if err != nil {",
          "243:   panic(err)",
          "244:  }",
          "",
          "---------------"
        ],
        "pkg/middleware/stored_session.go||pkg/middleware/stored_session.go": [
          "File: pkg/middleware/stored_session.go -> pkg/middleware/stored_session.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:    logger.Printf(\"Error loading cookied session: %v, removing session\", err)",
          "77:   }",
          "",
          "[Removed Lines]",
          "76:    s.store.Clear(rw, req)",
          "",
          "[Added Lines]",
          "76:    err = s.store.Clear(rw, req)",
          "77:    if err != nil {",
          "78:     logger.Printf(\"Error removing session: %v\", err)",
          "79:    }",
          "",
          "---------------"
        ],
        "pkg/upstream/http.go||pkg/upstream/http.go": [
          "File: pkg/upstream/http.go -> pkg/upstream/http.go"
        ],
        "pkg/upstream/proxy.go||pkg/upstream/proxy.go": [
          "File: pkg/upstream/proxy.go -> pkg/upstream/proxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:    Message:     \"Error proxying to upstream server\",",
          "86:    ProxyPrefix: proxyPrefix,",
          "87:   }",
          "89:  }",
          "90: }",
          "",
          "[Removed Lines]",
          "88:   errorTemplate.Execute(rw, data)",
          "",
          "[Added Lines]",
          "88:   err := errorTemplate.Execute(rw, data)",
          "89:   if err != nil {",
          "90:    http.Error(rw, \"Internal Server Error\", http.StatusInternalServerError)",
          "91:   }",
          "",
          "---------------"
        ],
        "pkg/util/util.go||pkg/util/util.go": [
          "File: pkg/util/util.go -> pkg/util/util.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:  }",
          "13:  pool := x509.NewCertPool()",
          "14:  for _, path := range paths {",
          "16:   if err != nil {",
          "17:    return nil, fmt.Errorf(\"certificate authority file (%s) could not be read - %s\", path, err)",
          "18:   }",
          "",
          "[Removed Lines]",
          "15:   data, err := ioutil.ReadFile(path)",
          "",
          "[Added Lines]",
          "15:   data, err := ioutil.ReadFile(path) // #nosec G304",
          "",
          "---------------"
        ],
        "pkg/validation/logging.go||pkg/validation/logging.go": [
          "File: pkg/validation/logging.go -> pkg/validation/logging.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  if len(o.File.Filename) > 0 {",
          "17:   if err != nil {",
          "18:    if os.IsPermission(err) {",
          "19:     return append(msgs, \"unable to write to log file: \"+o.File.Filename)",
          "20:    }",
          "21:   }",
          "24:   logger.Printf(\"Redirecting logging to file: %s\", o.File.Filename)",
          "",
          "[Removed Lines]",
          "16:   file, err := os.OpenFile(o.File.Filename, os.O_WRONLY|os.O_CREATE, 0666)",
          "22:   file.Close()",
          "",
          "[Added Lines]",
          "16:   file, err := os.OpenFile(o.File.Filename, os.O_WRONLY|os.O_CREATE, 0600)",
          "22:   err = file.Close()",
          "23:   if err != nil {",
          "24:    return append(msgs, \"error closing the log file: \"+o.File.Filename)",
          "25:   }",
          "",
          "---------------"
        ],
        "pkg/validation/options.go||pkg/validation/options.go": [
          "File: pkg/validation/options.go -> pkg/validation/options.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:  }",
          "219:  if len(o.TrustedIPs) > 0 && o.ReverseProxy {",
          "221:  }",
          "223:  for i, ipStr := range o.TrustedIPs {",
          "",
          "[Removed Lines]",
          "220:   fmt.Fprintln(os.Stderr, \"WARNING: trusting of IPs with --reverse-proxy poses risks if a header spoofing attack is possible.\")",
          "",
          "[Added Lines]",
          "221:   _, err := fmt.Fprintln(os.Stderr, \"WARNING: trusting of IPs with --reverse-proxy poses risks if a header spoofing attack is possible.\")",
          "222:   if err != nil {",
          "223:    panic(err)",
          "224:   }",
          "",
          "---------------"
        ],
        "providers/logingov.go||providers/logingov.go": [
          "File: providers/logingov.go -> providers/logingov.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:    return nil, myerr",
          "116:   }",
          "117:   body, myerr := ioutil.ReadAll(resp.Body)",
          "119:   if myerr != nil {",
          "120:    return nil, myerr",
          "121:   }",
          "123:   var pubkeys jose.JSONWebKeySet",
          "124:   myerr = json.Unmarshal(body, &pubkeys)",
          "",
          "[Removed Lines]",
          "118:   resp.Body.Close()",
          "",
          "[Added Lines]",
          "121:   if myerr = resp.Body.Close(); myerr != nil {",
          "122:    return nil, myerr",
          "123:   }",
          "",
          "---------------"
        ],
        "validator.go||validator.go": [
          "File: validator.go -> validator.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"encoding/csv\"",
          "5:  \"fmt\"",
          "6:  \"os\"",
          "7:  \"strings\"",
          "8:  \"sync/atomic\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6:  \"io\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:  if err != nil {",
          "48:   logger.Fatalf(\"failed opening authenticated-emails-file=%q, %s\", um.usersFile, err)",
          "49:  }",
          "51:  csvReader := csv.NewReader(r)",
          "52:  csvReader.Comma = ','",
          "53:  csvReader.Comment = '#'",
          "",
          "[Removed Lines]",
          "50:  defer r.Close()",
          "",
          "[Added Lines]",
          "51:  defer func(c io.Closer) {",
          "52:   cerr := c.Close()",
          "53:   if cerr != nil {",
          "54:    logger.Fatalf(\"Error closing authenticated emails file: %s\", cerr)",
          "55:   }",
          "56:  }(r)",
          "",
          "---------------"
        ],
        "watcher.go||watcher.go": [
          "File: watcher.go -> watcher.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:   logger.Fatal(\"failed to create watcher for \", filename, \": \", err)",
          "42:  }",
          "43:  go func() {",
          "45:   for {",
          "46:    select {",
          "47:    case <-done:",
          "",
          "[Removed Lines]",
          "44:   defer watcher.Close()",
          "",
          "[Added Lines]",
          "44:   defer func(w *fsnotify.Watcher) {",
          "45:    cerr := w.Close()",
          "46:    if cerr != nil {",
          "47:     logger.Fatalf(\"error closing watcher: %s\", err)",
          "48:    }",
          "49:   }(watcher)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:     if event.Op&(fsnotify.Remove|fsnotify.Rename|fsnotify.Chmod) != 0 {",
          "57:      logger.Printf(\"watching interrupted on event: %s\", event)",
          "59:      WaitForReplacement(filename, event.Op, watcher)",
          "60:     }",
          "61:     logger.Printf(\"reloading after event: %s\", event)",
          "",
          "[Removed Lines]",
          "58:      watcher.Remove(filename)",
          "",
          "[Added Lines]",
          "63:      err = watcher.Remove(filename)",
          "64:      if err != nil {",
          "65:       logger.Printf(\"error removing watcher on %s: %s\", filename, err)",
          "66:      }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa6a785eafa29ecb32764c52ca75807f501cf090",
      "candidate_info": {
        "commit_hash": "fa6a785eafa29ecb32764c52ca75807f501cf090",
        "repo": "oauth2-proxy/oauth2-proxy",
        "commit_url": "https://github.com/oauth2-proxy/oauth2-proxy/commit/fa6a785eafa29ecb32764c52ca75807f501cf090",
        "files": [
          "oauthproxy.go",
          "oauthproxy_test.go"
        ],
        "message": "Improve handler vs helper organization in oauthproxy.go\n\nAdditionally, convert a lot of helper methods to be private",
        "before_after_code_files": [
          "oauthproxy.go||oauthproxy.go",
          "oauthproxy_test.go||oauthproxy_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ],
          "candidate": [
            "oauthproxy.go||oauthproxy.go",
            "oauthproxy_test.go||oauthproxy_test.go"
          ]
        }
      },
      "candidate_diff": {
        "oauthproxy.go||oauthproxy.go": [
          "File: oauthproxy.go -> oauthproxy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: )",
          "33: const (",
          "37:  applicationJSON = \"application/json\"",
          "38: )",
          "",
          "[Removed Lines]",
          "34:  httpScheme  = \"http\"",
          "35:  httpsScheme = \"https\"",
          "",
          "[Added Lines]",
          "34:  schemeHTTPS     = \"https\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "366:  return routes, nil",
          "367: }",
          "413: func (p *OAuthProxy) MakeCSRFCookie(req *http.Request, value string, expiration time.Duration, now time.Time) *http.Cookie {",
          "414:  return p.makeCookie(req, p.CSRFCookieName, value, expiration, now)",
          "",
          "[Removed Lines]",
          "371: func (p *OAuthProxy) GetOAuthRedirectURI(host string) string {",
          "373:  if p.redirectURL.Host != \"\" {",
          "374:   return p.redirectURL.String()",
          "375:  }",
          "376:  u := *p.redirectURL",
          "377:  if u.Scheme == \"\" {",
          "378:   if p.CookieSecure {",
          "379:    u.Scheme = httpsScheme",
          "380:   } else {",
          "381:    u.Scheme = httpScheme",
          "382:   }",
          "383:  }",
          "384:  u.Host = host",
          "385:  return u.String()",
          "386: }",
          "388: func (p *OAuthProxy) redeemCode(ctx context.Context, host, code string) (*sessionsapi.SessionState, error) {",
          "389:  if code == \"\" {",
          "390:   return nil, providers.ErrMissingCode",
          "391:  }",
          "392:  redirectURI := p.GetOAuthRedirectURI(host)",
          "393:  s, err := p.provider.Redeem(ctx, redirectURI, code)",
          "394:  if err != nil {",
          "395:   return nil, err",
          "396:  }",
          "397:  return s, nil",
          "398: }",
          "400: func (p *OAuthProxy) enrichSessionState(ctx context.Context, s *sessionsapi.SessionState) error {",
          "401:  var err error",
          "402:  if s.Email == \"\" {",
          "403:   s.Email, err = p.provider.GetEmailAddress(ctx, s)",
          "404:   if err != nil && !errors.Is(err, providers.ErrNotImplemented) {",
          "405:    return err",
          "406:   }",
          "407:  }",
          "409:  return p.provider.EnrichSession(ctx, s)",
          "410: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "466:  return p.sessionStore.Save(rw, req, s)",
          "467: }",
          "470: func (p *OAuthProxy) RobotsTxt(rw http.ResponseWriter) {",
          "471:  _, err := fmt.Fprintf(rw, \"User-agent: *\\nDisallow: /\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "425: func (p *OAuthProxy) IsValidRedirect(redirect string) bool {",
          "426:  switch {",
          "427:  case redirect == \"\":",
          "429:   return false",
          "430:  case strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):",
          "431:   return true",
          "432:  case strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):",
          "433:   redirectURL, err := url.Parse(redirect)",
          "434:   if err != nil {",
          "435:    logger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)",
          "436:    return false",
          "437:   }",
          "438:   redirectHostname := redirectURL.Hostname()",
          "440:   for _, domain := range p.whitelistDomains {",
          "441:    domainHostname, domainPort := splitHostPort(strings.TrimLeft(domain, \".\"))",
          "442:    if domainHostname == \"\" {",
          "443:     continue",
          "444:    }",
          "446:    if (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {",
          "451:     redirectPort := redirectURL.Port()",
          "452:     if (domainPort == \"*\") ||",
          "453:      (domainPort == redirectPort) ||",
          "454:      (domainPort == \"\" && redirectPort == \"\") {",
          "455:      return true",
          "456:     }",
          "457:    }",
          "458:   }",
          "460:   logger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)",
          "461:   return false",
          "462:  default:",
          "463:   logger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)",
          "464:   return false",
          "465:  }",
          "466: }",
          "468: func (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {",
          "469:  p.preAuthChain.Then(http.HandlerFunc(p.serveHTTP)).ServeHTTP(rw, req)",
          "470: }",
          "472: func (p *OAuthProxy) serveHTTP(rw http.ResponseWriter, req *http.Request) {",
          "473:  if req.URL.Path != p.AuthOnlyPath && strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {",
          "474:   prepareNoCache(rw)",
          "475:  }",
          "477:  switch path := req.URL.Path; {",
          "478:  case path == p.RobotsPath:",
          "479:   p.RobotsTxt(rw)",
          "480:  case p.IsAllowedRequest(req):",
          "481:   p.SkipAuthProxy(rw, req)",
          "482:  case path == p.SignInPath:",
          "483:   p.SignIn(rw, req)",
          "484:  case path == p.SignOutPath:",
          "485:   p.SignOut(rw, req)",
          "486:  case path == p.OAuthStartPath:",
          "487:   p.OAuthStart(rw, req)",
          "488:  case path == p.OAuthCallbackPath:",
          "489:   p.OAuthCallback(rw, req)",
          "490:  case path == p.AuthOnlyPath:",
          "491:   p.AuthOnly(rw, req)",
          "492:  case path == p.UserInfoPath:",
          "493:   p.UserInfo(rw, req)",
          "494:  default:",
          "495:   p.Proxy(rw, req)",
          "496:  }",
          "497: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "496:  }",
          "497: }",
          "500: func (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {",
          "501:  prepareNoCache(rw)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "530: func (p *OAuthProxy) IsAllowedRequest(req *http.Request) bool {",
          "531:  isPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"",
          "532:  return isPreflightRequestAllowed || p.isAllowedRoute(req) || p.isTrustedIP(req)",
          "533: }",
          "536: func (p *OAuthProxy) isAllowedRoute(req *http.Request) bool {",
          "537:  for _, route := range p.allowedRoutes {",
          "538:   if (route.method == \"\" || req.Method == route.method) && route.pathRegex.MatchString(req.URL.Path) {",
          "539:    return true",
          "540:   }",
          "541:  }",
          "542:  return false",
          "543: }",
          "546: func (p *OAuthProxy) isTrustedIP(req *http.Request) bool {",
          "547:  if p.trustedIPs == nil {",
          "548:   return false",
          "549:  }",
          "551:  remoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)",
          "552:  if err != nil {",
          "553:   logger.Errorf(\"Error obtaining real IP for trusted IP list: %v\", err)",
          "555:   return false",
          "556:  }",
          "558:  if remoteAddr == nil {",
          "559:   return false",
          "560:  }",
          "562:  return p.trustedIPs.Has(remoteAddr)",
          "563: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "507:  }",
          "508:  rw.WriteHeader(code)",
          "511:  if err != nil {",
          "512:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "513:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "",
          "[Removed Lines]",
          "510:  redirectURL, err := p.GetAppRedirect(req)",
          "",
          "[Added Lines]",
          "576:  redirectURL, err := p.getAppRedirect(req)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "566:  return \"\", false",
          "567: }",
          "581:  if err != nil {",
          "583:  }",
          "596:   }",
          "597:  }",
          "600: }",
          "617:  }",
          "627:  }",
          "629: }",
          "637:  }",
          "642:  }",
          "912: func (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {",
          "",
          "[Removed Lines]",
          "579: func (p *OAuthProxy) GetAppRedirect(req *http.Request) (string, error) {",
          "580:  err := req.ParseForm()",
          "582:   return \"\", err",
          "587:  type redirectGetter func(req *http.Request) string",
          "588:  for _, rdGetter := range []redirectGetter{",
          "589:   p.getRdQuerystringRedirect,",
          "590:   p.getXAuthRequestRedirect,",
          "591:   p.getXForwardedHeadersRedirect,",
          "592:   p.getURIRedirect,",
          "593:  } {",
          "594:   if redirect := rdGetter(req); redirect != \"\" {",
          "595:    return redirect, nil",
          "599:  return \"/\", nil",
          "602: func isForwardedRequest(req *http.Request) bool {",
          "603:  return requestutil.IsProxied(req) &&",
          "604:   req.Host != requestutil.GetRequestHost(req)",
          "605: }",
          "607: func (p *OAuthProxy) hasProxyPrefix(path string) bool {",
          "608:  return strings.HasPrefix(path, fmt.Sprintf(\"%s/\", p.ProxyPrefix))",
          "609: }",
          "613: func (p *OAuthProxy) getRdQuerystringRedirect(req *http.Request) string {",
          "614:  redirect := req.Form.Get(\"rd\")",
          "615:  if p.IsValidRedirect(redirect) {",
          "616:   return redirect",
          "618:  return \"\"",
          "619: }",
          "623: func (p *OAuthProxy) getXAuthRequestRedirect(req *http.Request) string {",
          "624:  redirect := req.Header.Get(\"X-Auth-Request-Redirect\")",
          "625:  if p.IsValidRedirect(redirect) {",
          "626:   return redirect",
          "628:  return \"\"",
          "634: func (p *OAuthProxy) getXForwardedHeadersRedirect(req *http.Request) string {",
          "635:  if !isForwardedRequest(req) {",
          "636:   return \"\"",
          "639:  uri := requestutil.GetRequestURI(req)",
          "640:  if p.hasProxyPrefix(uri) {",
          "641:   uri = \"/\"",
          "644:  redirect := fmt.Sprintf(",
          "645:   \"%s://%s%s\",",
          "646:   requestutil.GetRequestProto(req),",
          "647:   requestutil.GetRequestHost(req),",
          "648:   uri,",
          "649:  )",
          "651:  if p.IsValidRedirect(redirect) {",
          "652:   return redirect",
          "653:  }",
          "654:  return \"\"",
          "655: }",
          "661: func (p *OAuthProxy) getURIRedirect(req *http.Request) string {",
          "662:  redirect := requestutil.GetRequestURI(req)",
          "663:  if !p.IsValidRedirect(redirect) {",
          "664:   redirect = req.URL.RequestURI()",
          "665:  }",
          "667:  if p.hasProxyPrefix(redirect) {",
          "668:   return \"/\"",
          "669:  }",
          "670:  return redirect",
          "671: }",
          "677: func splitHostPort(hostport string) (host, port string) {",
          "678:  host = hostport",
          "680:  colon := strings.LastIndexByte(host, ':')",
          "681:  if colon != -1 && validOptionalPort(host[colon:]) {",
          "682:   host, port = host[:colon], host[colon+1:]",
          "683:  }",
          "685:  if strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {",
          "686:   host = host[1 : len(host)-1]",
          "687:  }",
          "689:  return",
          "690: }",
          "695: func validOptionalPort(port string) bool {",
          "696:  if port == \"\" || port == \":*\" {",
          "697:   return true",
          "698:  }",
          "699:  if port[0] != ':' {",
          "700:   return false",
          "701:  }",
          "702:  for _, b := range port[1:] {",
          "703:   if b < '0' || b > '9' {",
          "704:    return false",
          "705:   }",
          "706:  }",
          "707:  return true",
          "708: }",
          "711: func (p *OAuthProxy) IsValidRedirect(redirect string) bool {",
          "712:  switch {",
          "713:  case redirect == \"\":",
          "715:   return false",
          "716:  case strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):",
          "717:   return true",
          "718:  case strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):",
          "719:   redirectURL, err := url.Parse(redirect)",
          "720:   if err != nil {",
          "721:    logger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)",
          "722:    return false",
          "723:   }",
          "724:   redirectHostname := redirectURL.Hostname()",
          "726:   for _, domain := range p.whitelistDomains {",
          "727:    domainHostname, domainPort := splitHostPort(strings.TrimLeft(domain, \".\"))",
          "728:    if domainHostname == \"\" {",
          "729:     continue",
          "730:    }",
          "732:    if (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {",
          "737:     redirectPort := redirectURL.Port()",
          "738:     if (domainPort == \"*\") ||",
          "739:      (domainPort == redirectPort) ||",
          "740:      (domainPort == \"\" && redirectPort == \"\") {",
          "741:      return true",
          "742:     }",
          "743:    }",
          "744:   }",
          "746:   logger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)",
          "747:   return false",
          "748:  default:",
          "749:   logger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)",
          "750:   return false",
          "751:  }",
          "752: }",
          "755: func (p *OAuthProxy) IsAllowedRequest(req *http.Request) bool {",
          "756:  isPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"",
          "757:  return isPreflightRequestAllowed || p.isAllowedRoute(req) || p.IsTrustedIP(req)",
          "758: }",
          "761: func (p *OAuthProxy) isAllowedRoute(req *http.Request) bool {",
          "762:  for _, route := range p.allowedRoutes {",
          "763:   if (route.method == \"\" || req.Method == route.method) && route.pathRegex.MatchString(req.URL.Path) {",
          "764:    return true",
          "765:   }",
          "766:  }",
          "767:  return false",
          "768: }",
          "771: var noCacheHeaders = map[string]string{",
          "772:  \"Expires\":         time.Unix(0, 0).Format(time.RFC1123),",
          "773:  \"Cache-Control\":   \"no-cache, no-store, must-revalidate, max-age=0\",",
          "774:  \"X-Accel-Expires\": \"0\", // https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/",
          "775: }",
          "778: func prepareNoCache(w http.ResponseWriter) {",
          "780:  for k, v := range noCacheHeaders {",
          "781:   w.Header().Set(k, v)",
          "782:  }",
          "783: }",
          "786: func (p *OAuthProxy) IsTrustedIP(req *http.Request) bool {",
          "787:  if p.trustedIPs == nil {",
          "788:   return false",
          "789:  }",
          "791:  remoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)",
          "792:  if err != nil {",
          "793:   logger.Errorf(\"Error obtaining real IP for trusted IP list: %v\", err)",
          "795:   return false",
          "796:  }",
          "798:  if remoteAddr == nil {",
          "799:   return false",
          "800:  }",
          "802:  return p.trustedIPs.Has(remoteAddr)",
          "803: }",
          "805: func (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {",
          "806:  p.preAuthChain.Then(http.HandlerFunc(p.serveHTTP)).ServeHTTP(rw, req)",
          "807: }",
          "809: func (p *OAuthProxy) serveHTTP(rw http.ResponseWriter, req *http.Request) {",
          "810:  if req.URL.Path != p.AuthOnlyPath && strings.HasPrefix(req.URL.Path, p.ProxyPrefix) {",
          "811:   prepareNoCache(rw)",
          "812:  }",
          "814:  switch path := req.URL.Path; {",
          "815:  case path == p.RobotsPath:",
          "816:   p.RobotsTxt(rw)",
          "817:  case p.IsAllowedRequest(req):",
          "818:   p.SkipAuthProxy(rw, req)",
          "819:  case path == p.SignInPath:",
          "820:   p.SignIn(rw, req)",
          "821:  case path == p.SignOutPath:",
          "822:   p.SignOut(rw, req)",
          "823:  case path == p.OAuthStartPath:",
          "824:   p.OAuthStart(rw, req)",
          "825:  case path == p.OAuthCallbackPath:",
          "826:   p.OAuthCallback(rw, req)",
          "827:  case path == p.AuthOnlyPath:",
          "828:   p.AuthOnly(rw, req)",
          "829:  case path == p.UserInfoPath:",
          "830:   p.UserInfo(rw, req)",
          "831:  default:",
          "832:   p.Proxy(rw, req)",
          "833:  }",
          "834: }",
          "837: func (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {",
          "838:  redirect, err := p.GetAppRedirect(req)",
          "839:  if err != nil {",
          "840:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "841:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "842:   return",
          "843:  }",
          "845:  user, ok := p.ManualSignIn(req)",
          "846:  if ok {",
          "847:   session := &sessionsapi.SessionState{User: user}",
          "848:   err = p.SaveSession(rw, req, session)",
          "849:   if err != nil {",
          "850:    logger.Printf(\"Error saving session: %v\", err)",
          "851:    p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "852:    return",
          "853:   }",
          "854:   http.Redirect(rw, req, redirect, http.StatusFound)",
          "855:  } else {",
          "856:   if p.SkipProviderButton {",
          "857:    p.OAuthStart(rw, req)",
          "858:   } else {",
          "859:    p.SignInPage(rw, req, http.StatusOK)",
          "860:   }",
          "861:  }",
          "862: }",
          "865: func (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {",
          "867:  session, err := p.getAuthenticatedSession(rw, req)",
          "868:  if err != nil {",
          "869:   http.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)",
          "870:   return",
          "871:  }",
          "873:  userInfo := struct {",
          "874:   User              string   `json:\"user\"`",
          "875:   Email             string   `json:\"email\"`",
          "876:   Groups            []string `json:\"groups,omitempty\"`",
          "877:   PreferredUsername string   `json:\"preferredUsername,omitempty\"`",
          "878:  }{",
          "879:   User:              session.User,",
          "880:   Email:             session.Email,",
          "881:   Groups:            session.Groups,",
          "882:   PreferredUsername: session.PreferredUsername,",
          "883:  }",
          "885:  rw.Header().Set(\"Content-Type\", \"application/json\")",
          "886:  rw.WriteHeader(http.StatusOK)",
          "887:  err = json.NewEncoder(rw).Encode(userInfo)",
          "888:  if err != nil {",
          "889:   logger.Printf(\"Error encoding user info: %v\", err)",
          "890:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "891:  }",
          "892: }",
          "895: func (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {",
          "896:  redirect, err := p.GetAppRedirect(req)",
          "897:  if err != nil {",
          "898:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "899:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "900:   return",
          "901:  }",
          "902:  err = p.ClearSessionCookie(rw, req)",
          "903:  if err != nil {",
          "904:   logger.Errorf(\"Error clearing session cookie: %v\", err)",
          "905:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "906:   return",
          "907:  }",
          "908:  http.Redirect(rw, req, redirect, http.StatusFound)",
          "909: }",
          "",
          "[Added Lines]",
          "636: func (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {",
          "637:  redirect, err := p.getAppRedirect(req)",
          "639:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "640:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "641:   return",
          "644:  user, ok := p.ManualSignIn(req)",
          "645:  if ok {",
          "646:   session := &sessionsapi.SessionState{User: user}",
          "647:   err = p.SaveSession(rw, req, session)",
          "648:   if err != nil {",
          "649:    logger.Printf(\"Error saving session: %v\", err)",
          "650:    p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "651:    return",
          "652:   }",
          "653:   http.Redirect(rw, req, redirect, http.StatusFound)",
          "654:  } else {",
          "655:   if p.SkipProviderButton {",
          "656:    p.OAuthStart(rw, req)",
          "657:   } else {",
          "658:    p.SignInPage(rw, req, http.StatusOK)",
          "664: func (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {",
          "666:  session, err := p.getAuthenticatedSession(rw, req)",
          "667:  if err != nil {",
          "668:   http.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)",
          "669:   return",
          "670:  }",
          "672:  userInfo := struct {",
          "673:   User              string   `json:\"user\"`",
          "674:   Email             string   `json:\"email\"`",
          "675:   Groups            []string `json:\"groups,omitempty\"`",
          "676:   PreferredUsername string   `json:\"preferredUsername,omitempty\"`",
          "677:  }{",
          "678:   User:              session.User,",
          "679:   Email:             session.Email,",
          "680:   Groups:            session.Groups,",
          "681:   PreferredUsername: session.PreferredUsername,",
          "684:  rw.Header().Set(\"Content-Type\", \"application/json\")",
          "685:  rw.WriteHeader(http.StatusOK)",
          "686:  err = json.NewEncoder(rw).Encode(userInfo)",
          "687:  if err != nil {",
          "688:   logger.Printf(\"Error encoding user info: %v\", err)",
          "689:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "694: func (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {",
          "695:  redirect, err := p.getAppRedirect(req)",
          "696:  if err != nil {",
          "697:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "698:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "699:   return",
          "701:  err = p.ClearSessionCookie(rw, req)",
          "702:  if err != nil {",
          "703:   logger.Errorf(\"Error clearing session cookie: %v\", err)",
          "704:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "705:   return",
          "707:  http.Redirect(rw, req, redirect, http.StatusFound)",
          "708: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "918:   return",
          "919:  }",
          "920:  p.SetCSRFCookie(rw, req, nonce)",
          "922:  if err != nil {",
          "923:   logger.Errorf(\"Error obtaining redirect: %v\", err)",
          "924:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", err.Error())",
          "925:   return",
          "926:  }",
          "928:  http.Redirect(rw, req, p.provider.GetLoginURL(redirectURI, fmt.Sprintf(\"%v:%v\", nonce, redirect)), http.StatusFound)",
          "929: }",
          "",
          "[Removed Lines]",
          "921:  redirect, err := p.GetAppRedirect(req)",
          "927:  redirectURI := p.GetOAuthRedirectURI(requestutil.GetRequestHost(req))",
          "",
          "[Added Lines]",
          "720:  redirect, err := p.getAppRedirect(req)",
          "726:  redirectURI := p.getOAuthRedirectURI(req)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "947:   return",
          "948:  }",
          "951:  if err != nil {",
          "952:   logger.Errorf(\"Error redeeming code during OAuth2 callback: %v\", err)",
          "953:   p.ErrorPage(rw, http.StatusInternalServerError, \"Internal Server Error\", \"Internal Error\")",
          "",
          "[Removed Lines]",
          "950:  session, err := p.redeemCode(req.Context(), requestutil.GetRequestHost(req), req.Form.Get(\"code\"))",
          "",
          "[Added Lines]",
          "749:  session, err := p.redeemCode(req)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1006:  }",
          "1007: }",
          "1011: func (p *OAuthProxy) AuthOnly(rw http.ResponseWriter, req *http.Request) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "808: func (p *OAuthProxy) redeemCode(req *http.Request) (*sessionsapi.SessionState, error) {",
          "809:  code := req.Form.Get(\"code\")",
          "810:  if code == \"\" {",
          "811:   return nil, providers.ErrMissingCode",
          "812:  }",
          "814:  redirectURI := p.getOAuthRedirectURI(req)",
          "815:  s, err := p.provider.Redeem(req.Context(), redirectURI, code)",
          "816:  if err != nil {",
          "817:   return nil, err",
          "818:  }",
          "819:  return s, nil",
          "820: }",
          "822: func (p *OAuthProxy) enrichSessionState(ctx context.Context, s *sessionsapi.SessionState) error {",
          "823:  var err error",
          "824:  if s.Email == \"\" {",
          "825:   s.Email, err = p.provider.GetEmailAddress(ctx, s)",
          "826:   if err != nil && !errors.Is(err, providers.ErrNotImplemented) {",
          "827:    return err",
          "828:   }",
          "829:  }",
          "831:  return p.provider.EnrichSession(ctx, s)",
          "832: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1023:  }",
          "1027:  p.headersChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {",
          "1028:   rw.WriteHeader(http.StatusAccepted)",
          "1029:  })).ServeHTTP(rw, req)",
          "",
          "[Removed Lines]",
          "1026:  p.addHeadersForProxying(rw, req, session)",
          "",
          "[Added Lines]",
          "851:  p.addHeadersForProxying(rw, session)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1041:  switch err {",
          "1042:  case nil:",
          "1045:   p.headersChain.Then(p.serveMux).ServeHTTP(rw, req)",
          "1046:  case ErrNeedsLogin:",
          "1048:   if isAjax(req) {",
          "1051:    return",
          "1052:   }",
          "",
          "[Removed Lines]",
          "1044:   p.addHeadersForProxying(rw, req, session)",
          "1050:    p.ErrorJSON(rw, http.StatusUnauthorized)",
          "",
          "[Added Lines]",
          "869:   p.addHeadersForProxying(rw, session)",
          "875:    p.errorJSON(rw, http.StatusUnauthorized)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1066:   p.ErrorPage(rw, http.StatusInternalServerError,",
          "1067:    \"Internal Error\", \"Internal Error\")",
          "1068:  }",
          "1070: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "894: }",
          "897: var noCacheHeaders = map[string]string{",
          "898:  \"Expires\":         time.Unix(0, 0).Format(time.RFC1123),",
          "899:  \"Cache-Control\":   \"no-cache, no-store, must-revalidate, max-age=0\",",
          "900:  \"X-Accel-Expires\": \"0\", // https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/",
          "901: }",
          "904: func prepareNoCache(w http.ResponseWriter) {",
          "906:  for k, v := range noCacheHeaders {",
          "907:   w.Header().Set(k, v)",
          "908:  }",
          "909: }",
          "914: func (p *OAuthProxy) getOAuthRedirectURI(req *http.Request) string {",
          "916:  if p.redirectURL.Host != \"\" {",
          "917:   return p.redirectURL.String()",
          "918:  }",
          "921:  rd := *p.redirectURL",
          "922:  rd.Host = requestutil.GetRequestHost(req)",
          "923:  rd.Scheme = requestutil.GetRequestProto(req)",
          "927:  if p.CookieSecure {",
          "928:   rd.Scheme = schemeHTTPS",
          "929:  }",
          "930:  return rd.String()",
          "931: }",
          "943: func (p *OAuthProxy) getAppRedirect(req *http.Request) (string, error) {",
          "944:  err := req.ParseForm()",
          "945:  if err != nil {",
          "946:   return \"\", err",
          "947:  }",
          "951:  type redirectGetter func(req *http.Request) string",
          "952:  for _, rdGetter := range []redirectGetter{",
          "953:   p.getRdQuerystringRedirect,",
          "954:   p.getXAuthRequestRedirect,",
          "955:   p.getXForwardedHeadersRedirect,",
          "956:   p.getURIRedirect,",
          "957:  } {",
          "958:   if redirect := rdGetter(req); redirect != \"\" {",
          "959:    return redirect, nil",
          "960:   }",
          "961:  }",
          "963:  return \"/\", nil",
          "964: }",
          "966: func isForwardedRequest(req *http.Request) bool {",
          "967:  return requestutil.IsProxied(req) &&",
          "968:   req.Host != requestutil.GetRequestHost(req)",
          "969: }",
          "971: func (p *OAuthProxy) hasProxyPrefix(path string) bool {",
          "972:  return strings.HasPrefix(path, fmt.Sprintf(\"%s/\", p.ProxyPrefix))",
          "973: }",
          "977: func (p *OAuthProxy) getRdQuerystringRedirect(req *http.Request) string {",
          "978:  redirect := req.Form.Get(\"rd\")",
          "979:  if p.IsValidRedirect(redirect) {",
          "980:   return redirect",
          "981:  }",
          "982:  return \"\"",
          "983: }",
          "987: func (p *OAuthProxy) getXAuthRequestRedirect(req *http.Request) string {",
          "988:  redirect := req.Header.Get(\"X-Auth-Request-Redirect\")",
          "989:  if p.IsValidRedirect(redirect) {",
          "990:   return redirect",
          "991:  }",
          "992:  return \"\"",
          "993: }",
          "998: func (p *OAuthProxy) getXForwardedHeadersRedirect(req *http.Request) string {",
          "999:  if !isForwardedRequest(req) {",
          "1000:   return \"\"",
          "1001:  }",
          "1003:  uri := requestutil.GetRequestURI(req)",
          "1004:  if p.hasProxyPrefix(uri) {",
          "1005:   uri = \"/\"",
          "1006:  }",
          "1008:  redirect := fmt.Sprintf(",
          "1009:   \"%s://%s%s\",",
          "1010:   requestutil.GetRequestProto(req),",
          "1011:   requestutil.GetRequestHost(req),",
          "1012:   uri,",
          "1013:  )",
          "1015:  if p.IsValidRedirect(redirect) {",
          "1016:   return redirect",
          "1017:  }",
          "1018:  return \"\"",
          "1019: }",
          "1025: func (p *OAuthProxy) getURIRedirect(req *http.Request) string {",
          "1026:  redirect := requestutil.GetRequestURI(req)",
          "1027:  if !p.IsValidRedirect(redirect) {",
          "1028:   redirect = req.URL.RequestURI()",
          "1029:  }",
          "1031:  if p.hasProxyPrefix(redirect) {",
          "1032:   return \"/\"",
          "1033:  }",
          "1034:  return redirect",
          "1035: }",
          "1041: func splitHostPort(hostport string) (host, port string) {",
          "1042:  host = hostport",
          "1044:  colon := strings.LastIndexByte(host, ':')",
          "1045:  if colon != -1 && validOptionalPort(host[colon:]) {",
          "1046:   host, port = host[:colon], host[colon+1:]",
          "1047:  }",
          "1049:  if strings.HasPrefix(host, \"[\") && strings.HasSuffix(host, \"]\") {",
          "1050:   host = host[1 : len(host)-1]",
          "1051:  }",
          "1053:  return",
          "1054: }",
          "1059: func validOptionalPort(port string) bool {",
          "1060:  if port == \"\" || port == \":*\" {",
          "1061:   return true",
          "1062:  }",
          "1063:  if port[0] != ':' {",
          "1064:   return false",
          "1065:  }",
          "1066:  for _, b := range port[1:] {",
          "1067:   if b < '0' || b > '9' {",
          "1068:    return false",
          "1069:   }",
          "1070:  }",
          "1071:  return true",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1153: }",
          "1157:  if session.Email == \"\" {",
          "1158:   rw.Header().Set(\"GAP-Auth\", session.User)",
          "1159:  } else {",
          "",
          "[Removed Lines]",
          "1156: func (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, req *http.Request, session *sessionsapi.SessionState) {",
          "",
          "[Added Lines]",
          "1158: func (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, session *sessionsapi.SessionState) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1181:  return false",
          "1182: }",
          "1186:  rw.Header().Set(\"Content-Type\", applicationJSON)",
          "1187:  rw.WriteHeader(code)",
          "1188: }",
          "",
          "[Removed Lines]",
          "1185: func (p *OAuthProxy) ErrorJSON(rw http.ResponseWriter, code int) {",
          "",
          "[Added Lines]",
          "1187: func (p *OAuthProxy) errorJSON(rw http.ResponseWriter, code int) {",
          "",
          "---------------"
        ],
        "oauthproxy_test.go||oauthproxy_test.go": [
          "File: oauthproxy_test.go -> oauthproxy_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "415:   t.Fatal(err)",
          "416:  }",
          "420: }",
          "422: func Test_enrichSession(t *testing.T) {",
          "",
          "[Removed Lines]",
          "418:  _, err = proxy.redeemCode(context.Background(), \"www.example.com\", \"\")",
          "419:  assert.Error(t, err)",
          "",
          "[Added Lines]",
          "418:  req := httptest.NewRequest(http.MethodGet, \"/\", nil)",
          "419:  _, err = proxy.redeemCode(req)",
          "420:  assert.Equal(t, providers.ErrMissingCode, err)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1749:  }",
          "1750: }",
          "1753:  opts := baseTestOptions()",
          "1754:  opts.WhitelistDomains = append(opts.WhitelistDomains, \".example.com\", \".example.com:8443\")",
          "1755:  err := validation.Validate(opts)",
          "",
          "[Removed Lines]",
          "1752: func TestGetRedirect(t *testing.T) {",
          "",
          "[Added Lines]",
          "1753: func Test_getAppRedirect(t *testing.T) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1900:    req = middleware.AddRequestScope(req, &middleware.RequestScope{",
          "1901:     ReverseProxy: tt.reverseProxy,",
          "1902:    })",
          "1905:    assert.NoError(t, err)",
          "1906:    assert.Equal(t, tt.expectedRedirect, redirect)",
          "",
          "[Removed Lines]",
          "1903:    redirect, err := proxy.GetAppRedirect(req)",
          "",
          "[Added Lines]",
          "1904:    redirect, err := proxy.getAppRedirect(req)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
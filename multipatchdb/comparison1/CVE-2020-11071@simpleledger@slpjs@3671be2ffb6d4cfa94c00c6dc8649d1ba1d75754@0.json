{
  "cve_id": "CVE-2020-11071",
  "cve_desc": "SLPJS (npm package slpjs) before version 0.27.2, has a vulnerability where users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This is fixed in version 0.27.2.",
  "repo": "simpleledger/slpjs",
  "patch_hash": "3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754",
  "patch_info": {
    "commit_hash": "3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754",
    "repo": "simpleledger/slpjs",
    "commit_url": "https://github.com/simpleledger/slpjs/commit/3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754",
    "files": [
      "lib/localvalidator.ts"
    ],
    "message": "fix false negative case for MINT transactions\n\nSee the newly added unit test case for this issue.\nCurrently there are 151 unit tests.",
    "before_after_code_files": [
      "lib/localvalidator.ts||lib/localvalidator.ts"
    ]
  },
  "patch_diff": {
    "lib/localvalidator.ts||lib/localvalidator.ts": [
      "File: lib/localvalidator.ts -> lib/localvalidator.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "282:                     }",
      "283:                 } catch (_) {}",
      "284:             }",
      "286:                 this.cachedValidations[txid].validity = false;",
      "287:                 this.cachedValidations[txid].waiting = false;",
      "289:                 return this.cachedValidations[txid].validity!;",
      "290:             }",
      "291:         }",
      "",
      "[Removed Lines]",
      "285:             if (this.cachedValidations[txid].parents.length !== 1) {",
      "288:                 this.cachedValidations[txid].invalidReason = \"MINT transaction must have 1 valid baton parent.\";",
      "",
      "[Added Lines]",
      "285:             if (this.cachedValidations[txid].parents.length < 1) {",
      "288:                 this.cachedValidations[txid].invalidReason = \"MINT transaction must have at least 1 candidate baton parent input.\";",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "344:         const parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];",
      "349:                 this.cachedValidations[txid].validity = false;",
      "350:                 this.cachedValidations[txid].waiting = false;",
      "351:                 this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\";",
      "",
      "[Removed Lines]",
      "345:         for (let i = 0; i < parentTxids.length; i++) {",
      "346:             const valid = await this.isValidSlpTxid(parentTxids[i]);",
      "347:             this.cachedValidations[txid].parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
      "348:             if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT && !valid) {",
      "",
      "[Added Lines]",
      "345:         for (const id of parentTxids) {",
      "346:             const valid = await this.isValidSlpTxid(id);",
      "347:             this.cachedValidations[txid].parents.filter(p => p.txid === id).map(p => p.valid = valid);",
      "348:         }",
      "351:         if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT) {",
      "352:             if (this.cachedValidations[txid].parents.filter(p => p.valid && p.inputQty === null).length !== 1) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7f27c4cf11591efe6301280742c533ece9237d2e",
      "candidate_info": {
        "commit_hash": "7f27c4cf11591efe6301280742c533ece9237d2e",
        "repo": "simpleledger/slpjs",
        "commit_url": "https://github.com/simpleledger/slpjs/commit/7f27c4cf11591efe6301280742c533ece9237d2e",
        "files": [
          "lib/localvalidator.ts",
          "lib/slp.ts"
        ],
        "message": "updates to validator for NFT1 and general updates",
        "before_after_code_files": [
          "lib/localvalidator.ts||lib/localvalidator.ts",
          "lib/slp.ts||lib/slp.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/localvalidator.ts||lib/localvalidator.ts"
          ],
          "candidate": [
            "lib/localvalidator.ts||lib/localvalidator.ts"
          ]
        }
      },
      "candidate_diff": {
        "lib/localvalidator.ts||lib/localvalidator.ts": [
          "File: lib/localvalidator.ts -> lib/localvalidator.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: import * as Bitcore from 'bitcore-lib-cash';",
          "6: import BigNumber from 'bignumber.js';",
          "9: export type GetRawTransactionsAsync = (txid: string[]) => Promise<string[]>;",
          "11: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))",
          "",
          "[Removed Lines]",
          "8: export interface Validation { validity: boolean|null; parents: Parent[], details: SlpTransactionDetails|null, invalidReason: string|null }",
          "",
          "[Added Lines]",
          "8: export interface Validation { validity: boolean|null; parents: Parent[], details: SlpTransactionDetails|null, invalidReason: string|null, waiting: boolean }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:     addValidationFromStore(hex: string, isValid: boolean) {",
          "44:         let id = (<Buffer>this.BITBOX.Crypto.sha256(this.BITBOX.Crypto.sha256(Buffer.from(hex, 'hex'))).reverse()).toString('hex');",
          "45:         if(!this.cachedValidations[id])",
          "47:         if(!this.cachedRawTransactions[id])",
          "48:             this.cachedRawTransactions[id] = hex;",
          "49:     }",
          "51:     async waitForCurrentValidationProcessing(txid: string) {",
          "53:         let cached: Validation = this.cachedValidations[txid];",
          "55:         while(true) {",
          "58:             await sleep(10);",
          "59:         }",
          "60:     }",
          "64:         while(true) {",
          "67:             await sleep(10);",
          "68:         }",
          "71:     }",
          "73:     async retrieveRawTransaction(txid: string) {",
          "74:         if(this.cachedRawTransactions[txid])",
          "75:             return this.cachedRawTransactions[txid];",
          "76:         this.cachedRawTransactions[txid] = (await this.getRawTransactions([txid]))[0]",
          "77:         if(this.cachedRawTransactions[txid]) {",
          "79:             if(!re.test(this.cachedRawTransactions[txid]))",
          "80:                 throw Error(\"Transaction data not provided (regex failed).\")",
          "81:             return this.cachedRawTransactions[txid];",
          "",
          "[Removed Lines]",
          "46:             this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null }",
          "56:             if(typeof cached.validity === 'boolean')",
          "57:                 break",
          "62:     async waitForTransactionPreProcessing(txid: string){",
          "65:             if(this.cachedRawTransactions[txid] && (this.cachedValidations[txid].details || typeof this.cachedValidations.validity === 'boolean'))",
          "66:                 break",
          "70:         return",
          "78:             let re = /^([A-Fa-f0-9]{2}){60,}$/;",
          "",
          "[Added Lines]",
          "46:             this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false }",
          "55:             if(typeof cached.validity === 'boolean') {",
          "56:                 cached.waiting = false;",
          "57:                 break;",
          "58:             }",
          "63:     async waitForTransactionDownloadToComplete(txid: string){",
          "65:             if(this.cachedRawTransactions[txid] && this.cachedRawTransactions[txid] !== \"waiting\") {",
          "66:                 break;",
          "67:             }",
          "75:         this.cachedRawTransactions[txid] = \"waiting\";",
          "78:             let re = /^([A-Fa-f0-9]{2}){60,}$/;  // assume minimum 60 byte transaction size.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:         return valid;",
          "95:     }",
          "97:     async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {",
          "98:         if(!this.cachedValidations[txid]) {",
          "100:             await this.retrieveRawTransaction(txid);",
          "101:         }",
          "103:             return this.cachedValidations[txid].validity!;",
          "109:             await this.waitForCurrentValidationProcessing(txid);",
          "112:         let txn: Bitcore.Transaction = new Bitcore.Transaction(this.cachedRawTransactions[txid])",
          "",
          "[Removed Lines]",
          "99:             this.cachedValidations[txid] = { validity: null, parents: [], details: null, invalidReason: null }",
          "102:         else if(typeof this.cachedValidations[txid].validity === 'boolean')",
          "106:         if(!this.cachedRawTransactions[txid])",
          "107:             await this.waitForTransactionPreProcessing(txid);",
          "108:         if(this.cachedValidations[txid].details)",
          "",
          "[Added Lines]",
          "113:             this.cachedValidations[txid] = {",
          "114:                 validity: null,",
          "115:                 parents: [],",
          "116:                 details: null,",
          "117:                 invalidReason: null,",
          "118:                 waiting: false",
          "119:             }",
          "123:         else if(typeof this.cachedValidations[txid].validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "125:         }",
          "134:         if(!this.cachedRawTransactions[txid] || this.cachedRawTransactions[txid] === \"waiting\") {",
          "135:             if(this.cachedRawTransactions[txid] !== \"waiting\")",
          "136:                 this.retrieveRawTransaction(txid);",
          "139:             await this.waitForTransactionDownloadToComplete(txid);",
          "140:         }",
          "143:         if(this.cachedValidations[txid].waiting) {",
          "145:             if(typeof this.cachedValidations[txid].validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "146:                 return this.cachedValidations[txid].validity!;",
          "147:             }",
          "148:         }",
          "150:         this.cachedValidations[txid].waiting = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116:             if(slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "117:                 slpmsg.tokenIdHex = txid;",
          "118:         } catch(e) {",
          "119:             this.cachedValidations[txid].invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\"",
          "121:         }",
          "124:         if(tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "125:             this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";",
          "126:             return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.",
          "127:         } else {",
          "129:         }",
          "132:         if(tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "133:             this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";",
          "134:             return false; // Don't save boolean result to cache incase cache is ever used with different token type.",
          "135:         } else {",
          "137:         }",
          "140:         if(slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "142:                 let input_txid = txn.inputs[0].prevTxId.toString('hex');",
          "143:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "144:                 let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);",
          "",
          "[Removed Lines]",
          "120:             return this.cachedValidations[txid].validity = false;",
          "128:             this.cachedValidations[txid].invalidReason = null;",
          "136:             this.cachedValidations[txid].invalidReason = null;",
          "141:             if(slpmsg.versionType === 0x41) {",
          "",
          "[Added Lines]",
          "160:             this.cachedValidations[txid].validity = false;",
          "161:             this.cachedValidations[txid].waiting = false;",
          "163:             return this.cachedValidations[txid].validity!;",
          "168:             this.cachedValidations[txid].waiting = false;",
          "172:             if(this.cachedValidations[txid].validity !== false)",
          "173:                 this.cachedValidations[txid].invalidReason = null;",
          "178:             this.cachedValidations[txid].validity = null;",
          "179:             this.cachedValidations[txid].waiting = false;",
          "183:             if(this.cachedValidations[txid].validity !== false)",
          "184:                 this.cachedValidations[txid].invalidReason = null;",
          "190:             if(slpmsg.versionType === 0x41) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:                     input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);",
          "148:                 } catch(_) { }",
          "149:                 if(!input_slpmsg || input_slpmsg.versionType !== 0x81) {",
          "150:                     this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";",
          "152:                 }",
          "153:                 let nft_parent_dag_validity = await this.isValidSlpTxid(input_txid, undefined, 0x81);",
          "157:                     this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\"",
          "159:                 }",
          "162:             }",
          "163:         }",
          "164:         else if (slpmsg.transactionType === SlpTransactionType.MINT) {",
          "",
          "[Removed Lines]",
          "151:                     return this.cachedValidations[txid].validity = false;",
          "154:                 if(nft_parent_dag_validity) {",
          "155:                     return this.cachedValidations[txid].validity = true;",
          "156:                 } else {",
          "158:                     return this.cachedValidations[txid].validity = false;",
          "160:             } else {",
          "161:                 return this.cachedValidations[txid].validity = true;",
          "",
          "[Added Lines]",
          "201:                     this.cachedValidations[txid].validity = false;",
          "202:                     this.cachedValidations[txid].waiting = false;",
          "204:                     return this.cachedValidations[txid].validity!;",
          "205:                 }",
          "207:                 if(input_slpmsg.transactionType === SlpTransactionType.SEND &&",
          "208:                     (!input_slpmsg.sendOutputs![1].isGreaterThan(0)))",
          "209:                 {",
          "210:                     this.cachedValidations[txid].validity = false;",
          "211:                     this.cachedValidations[txid].waiting = false;",
          "212:                     this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "213:                     return this.cachedValidations[txid].validity!;",
          "214:                 } else if(input_slpmsg.transactionType === SlpTransactionType.GENESIS ||",
          "215:                             input_slpmsg.transactionType === SlpTransactionType.MINT &&",
          "216:                             (!input_slpmsg.genesisOrMintQuantity!.isGreaterThan(0)))",
          "217:                 {",
          "218:                     this.cachedValidations[txid].validity = false;",
          "219:                     this.cachedValidations[txid].waiting = false;",
          "220:                     this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "221:                     return this.cachedValidations[txid].validity!;",
          "225:                 this.cachedValidations[txid].validity = nft_parent_dag_validity;",
          "226:                 this.cachedValidations[txid].waiting = false;",
          "227:                 if(!nft_parent_dag_validity) {",
          "230:                 return this.cachedValidations[txid].validity!;",
          "231:             }",
          "234:             else {",
          "235:                 this.cachedValidations[txid].validity = true;",
          "236:                 this.cachedValidations[txid].waiting = false;",
          "237:                 return this.cachedValidations[txid].validity!;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "186:                 } catch(_) {}",
          "187:             }",
          "188:             if(this.cachedValidations[txid].parents.length !== 1) {",
          "189:                 this.cachedValidations[txid].invalidReason = \"MINT transaction must have 1 valid baton parent.\"",
          "191:             }",
          "192:         }",
          "193:         else if(slpmsg.transactionType === SlpTransactionType.SEND) {",
          "",
          "[Removed Lines]",
          "190:                 return this.cachedValidations[txid].validity = false;",
          "",
          "[Added Lines]",
          "265:                 this.cachedValidations[txid].validity = false;",
          "266:                 this.cachedValidations[txid].waiting = false;",
          "268:                 return this.cachedValidations[txid].validity!;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "234:             if(tokenOutQty.isGreaterThan(tokenInQty)) {",
          "235:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than possible token inputs.\"",
          "237:             }",
          "238:         }",
          "241:         let parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];",
          "242:         for(let i = 0; i < parentTxids.length; i++) {",
          "244:             this.cachedValidations[txid].parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
          "245:             if(this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "246:                 this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\"",
          "248:             }",
          "249:         }",
          "",
          "[Removed Lines]",
          "236:                 return this.cachedValidations[txid].validity = false;",
          "243:             let valid = await this.isValidSlpTxid(parentTxids[i])",
          "247:                 return this.cachedValidations[txid].validity = false;",
          "",
          "[Added Lines]",
          "313:                 this.cachedValidations[txid].validity = false;",
          "314:                 this.cachedValidations[txid].waiting = false;",
          "316:                 return this.cachedValidations[txid].validity!;",
          "324:             let valid = await this.isValidSlpTxid(parentTxids[i])",
          "327:                 this.cachedValidations[txid].validity = false;",
          "328:                 this.cachedValidations[txid].waiting = false;",
          "330:                 return this.cachedValidations[txid].validity!;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "253:             let validInputQty = this.cachedValidations[txid].parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t }, new BigNumber(0));",
          "254:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new BigNumber(0))",
          "255:             if(tokenOutQty.isGreaterThan(validInputQty)) {",
          "256:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than valid token inputs.\"",
          "258:             }",
          "259:         }",
          "",
          "[Removed Lines]",
          "257:                 return this.cachedValidations[txid].validity = false;",
          "",
          "[Added Lines]",
          "339:                 this.cachedValidations[txid].validity = false;",
          "340:                 this.cachedValidations[txid].waiting = false;",
          "342:                 return this.cachedValidations[txid].validity!;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "262:         if(this.cachedValidations[txid].parents.filter(p => p.valid).length > 0) {",
          "263:             let validVersionType = this.cachedValidations[txid].parents.find(p => p.valid!)!.versionType;",
          "264:             if(this.cachedValidations[txid].details!.versionType !== validVersionType) {",
          "265:                 this.cachedValidations[txid].invalidReason = \"SLP version/type mismatch from valid parent.\"",
          "267:             }",
          "268:         }",
          "271:     }",
          "273:     async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "",
          "[Removed Lines]",
          "266:                 return this.cachedValidations[txid].validity = false;",
          "270:         return this.cachedValidations[txid].validity = true;",
          "",
          "[Added Lines]",
          "350:                 this.cachedValidations[txid].validity = false;",
          "351:                 this.cachedValidations[txid].waiting = false;",
          "353:                 return this.cachedValidations[txid].validity!;",
          "356:         this.cachedValidations[txid].validity = true;",
          "357:         this.cachedValidations[txid].waiting = false;",
          "358:         return this.cachedValidations[txid].validity!;",
          "",
          "---------------"
        ],
        "lib/slp.ts||lib/slp.ts": [
          "File: lib/slp.ts -> lib/slp.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "740:                 throw Error(\"Bad Genesis quantity buffer\")",
          "741:             if(chunks[9]!.length !== 8)",
          "742:                 throw Error(\"Genesis quantity must be provided as an 8-byte buffer\")",
          "745:                 throw Error(\"NFT1 child token must have GENESIS quantity of 1.\")",
          "746:         }",
          "747:         else if(slpMsg.transactionType === SlpTransactionType.SEND) {",
          "",
          "[Removed Lines]",
          "743:             slpMsg.genesisOrMintQuantity = Utils.buffer2BigNumber(chunks[9]!);",
          "744:             if(slpMsg.versionType === 0x41 && slpMsg.genesisOrMintQuantity !== new BigNumber(1))",
          "",
          "[Added Lines]",
          "743:             slpMsg.genesisOrMintQuantity = Utils.buffer2BigNumber(chunks[9]!);",
          "744:             if(slpMsg.versionType === 0x41 && !slpMsg.genesisOrMintQuantity.isEqualTo(1))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3f402dfc91da3a5c91969025afea0bacbc4033e3",
      "candidate_info": {
        "commit_hash": "3f402dfc91da3a5c91969025afea0bacbc4033e3",
        "repo": "simpleledger/slpjs",
        "commit_url": "https://github.com/simpleledger/slpjs/commit/3f402dfc91da3a5c91969025afea0bacbc4033e3",
        "files": [
          "lib/localvalidator.ts"
        ],
        "message": "linting",
        "before_after_code_files": [
          "lib/localvalidator.ts||lib/localvalidator.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/localvalidator.ts||lib/localvalidator.ts"
          ],
          "candidate": [
            "lib/localvalidator.ts||lib/localvalidator.ts"
          ]
        }
      },
      "candidate_diff": {
        "lib/localvalidator.ts||lib/localvalidator.ts": [
          "File: lib/localvalidator.ts -> lib/localvalidator.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: export type GetRawTransactionsAsync = (txid: string[]) => Promise<string[]>;",
          "15: interface Parent {",
          "16:     txid: string;",
          "",
          "[Removed Lines]",
          "1: import { SlpTransactionType, SlpTransactionDetails, logger } from '../index';",
          "2: import { SlpValidator, Slp } from './slp';",
          "4: import { BITBOX } from 'bitbox-sdk';",
          "5: import * as Bitcore from 'bitcore-lib-cash';",
          "6: import BigNumber from 'bignumber.js';",
          "8: import { Crypto } from './crypto';",
          "10: export interface Validation { validity: boolean|null; parents: Parent[], details: SlpTransactionDetails|null, invalidReason: string|null, waiting: boolean }",
          "13: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))",
          "",
          "[Added Lines]",
          "1: import { SlpTransactionType, SlpTransactionDetails, logger } from \"../index\";",
          "2: import { SlpValidator, Slp } from \"./slp\";",
          "4: import { BITBOX } from \"bitbox-sdk\";",
          "5: import * as Bitcore from \"bitcore-lib-cash\";",
          "6: import BigNumber from \"bignumber.js\";",
          "8: import { Crypto } from \"./crypto\";",
          "10: export interface Validation { validity: boolean|null; parents: Parent[]; details: SlpTransactionDetails|null; invalidReason: string|null; waiting: boolean; }",
          "13: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23: export class LocalValidator implements SlpValidator {",
          "24:     BITBOX: BITBOX;",
          "27:     getRawTransactions: GetRawTransactionsAsync;",
          "28:     slp: Slp;",
          "31:     constructor(BITBOX: BITBOX, getRawTransactions: GetRawTransactionsAsync, logger?: logger) {",
          "37:             this.logger = logger;",
          "38:         this.BITBOX = BITBOX;",
          "39:         this.getRawTransactions = getRawTransactions;",
          "40:         this.slp = new Slp(BITBOX);",
          "",
          "[Removed Lines]",
          "25:     cachedRawTransactions: { [txid: string]: string }",
          "26:     cachedValidations: { [txid: string]: Validation }",
          "29:     logger: logger = { log: (s: string)=>null }",
          "32:         if(!BITBOX)",
          "33:             throw Error(\"Must provide BITBOX instance to class constructor.\")",
          "34:         if(!getRawTransactions)",
          "35:             throw Error(\"Must provide method getRawTransactions to class constructor.\")",
          "36:         if(logger)",
          "",
          "[Added Lines]",
          "25:     cachedRawTransactions: { [txid: string]: string };",
          "26:     cachedValidations: { [txid: string]: Validation };",
          "29:     logger: logger = { log: (s: string) => null };",
          "32:         if (!BITBOX) {",
          "33:             throw Error(\"Must provide BITBOX instance to class constructor.\");",
          "34:         }",
          "35:         if (!getRawTransactions) {",
          "36:             throw Error(\"Must provide method getRawTransactions to class constructor.\");",
          "37:         }",
          "38:         if (logger) {",
          "40:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45:     addValidationFromStore(hex: string, isValid: boolean) {",
          "46:         const id = Crypto.txid(Buffer.from(hex, \"hex\")).toString(\"hex\");",
          "50:             this.cachedRawTransactions[id] = hex;",
          "51:     }",
          "53:     async waitForCurrentValidationProcessing(txid: string) {",
          "58:                 cached.waiting = false;",
          "59:                 break;",
          "60:             }",
          "",
          "[Removed Lines]",
          "47:         if(!this.cachedValidations[id])",
          "48:             this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false }",
          "49:         if(!this.cachedRawTransactions[id])",
          "54:         let cached: Validation = this.cachedValidations[txid];",
          "56:         while(true) {",
          "57:             if(typeof cached.validity === 'boolean') {",
          "",
          "[Added Lines]",
          "50:         if (!this.cachedValidations[id]) {",
          "51:             this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false };",
          "52:         }",
          "53:         if (!this.cachedRawTransactions[id]) {",
          "55:         }",
          "59:         const cached: Validation = this.cachedValidations[txid];",
          "61:         while (true) {",
          "62:             if (typeof cached.validity === \"boolean\") {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "63:     }",
          "65:     async waitForTransactionDownloadToComplete(txid: string){",
          "68:                 break;",
          "69:             }",
          "70:             await sleep(10);",
          "",
          "[Removed Lines]",
          "66:         while(true) {",
          "67:             if(this.cachedRawTransactions[txid] && this.cachedRawTransactions[txid] !== \"waiting\") {",
          "",
          "[Added Lines]",
          "71:         while (true) {",
          "72:             if (this.cachedRawTransactions[txid] && this.cachedRawTransactions[txid] !== \"waiting\") {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "96:     async isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {",
          "97:         this.logger.log(\"SLPJS Validating: \" + txid);",
          "99:         this.logger.log(\"SLPJS Result: \" + valid + \" (\" + txid + \")\");",
          "101:             this.logger.log(\"SLPJS Invalid Reason: \" + this.cachedValidations[txid].invalidReason);",
          "104:         return valid;",
          "105:     }",
          "120:     async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {",
          "130:             await this.retrieveRawTransaction(txid);",
          "131:         }",
          "134:             return this.cachedValidations[txid].validity!;",
          "135:         }",
          "",
          "[Removed Lines]",
          "98:         let valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);",
          "100:         if(!valid && this.cachedValidations[txid].invalidReason)",
          "102:         else if(!valid)",
          "103:             this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\")",
          "122:         if(!this.cachedValidations[txid]) {",
          "123:             this.cachedValidations[txid] = {",
          "124:                 validity: null,",
          "125:                 parents: [],",
          "126:                 details: null,",
          "127:                 invalidReason: null,",
          "128:                 waiting: false",
          "129:             }",
          "133:         else if(typeof this.cachedValidations[txid].validity === 'boolean') {",
          "",
          "[Added Lines]",
          "103:         const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);",
          "105:         if (!valid && this.cachedValidations[txid].invalidReason) {",
          "107:         } else if (!valid) {",
          "108:             this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\");",
          "109:         }",
          "128:         if (!this.cachedValidations[txid]) {",
          "129:             this.cachedValidations[txid] = {",
          "130:                 validity: null,",
          "131:                 parents: [],",
          "132:                 details: null,",
          "133:                 invalidReason: null,",
          "134:                 waiting: false,",
          "135:             };",
          "139:         else if (typeof this.cachedValidations[txid].validity === \"boolean\") {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "146:                 this.retrieveRawTransaction(txid);",
          "149:             await this.waitForTransactionDownloadToComplete(txid);",
          "150:         }",
          "154:             await this.waitForCurrentValidationProcessing(txid);",
          "156:                 return this.cachedValidations[txid].validity!;",
          "157:             }",
          "158:         }",
          "",
          "[Removed Lines]",
          "144:         if(!this.cachedRawTransactions[txid] || this.cachedRawTransactions[txid] === \"waiting\") {",
          "145:             if(this.cachedRawTransactions[txid] !== \"waiting\")",
          "153:         if(this.cachedValidations[txid].waiting) {",
          "155:             if(typeof this.cachedValidations[txid].validity === 'boolean') {",
          "",
          "[Added Lines]",
          "150:         if (!this.cachedRawTransactions[txid] || this.cachedRawTransactions[txid] === \"waiting\") {",
          "151:             if (this.cachedRawTransactions[txid] !== \"waiting\") {",
          "153:             }",
          "160:         if (this.cachedValidations[txid].waiting) {",
          "162:             if (typeof this.cachedValidations[txid].validity === \"boolean\") {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "160:         this.cachedValidations[txid].waiting = true;",
          "164:         let slpmsg: SlpTransactionDetails;",
          "165:         try {",
          "168:                 slpmsg.tokenIdHex = txid;",
          "170:             this.cachedValidations[txid].validity = false;",
          "171:             this.cachedValidations[txid].waiting = false;",
          "173:             return this.cachedValidations[txid].validity!;",
          "174:         }",
          "178:             this.cachedValidations[txid].waiting = false;",
          "179:             this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";",
          "180:             return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.",
          "181:         } else {",
          "183:                 this.cachedValidations[txid].invalidReason = null;",
          "184:         }",
          "188:             this.cachedValidations[txid].validity = null;",
          "189:             this.cachedValidations[txid].waiting = false;",
          "190:             this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";",
          "191:             return false; // Don't save boolean result to cache incase cache is ever used with different token type.",
          "192:         } else {",
          "194:                 this.cachedValidations[txid].invalidReason = null;",
          "195:         }",
          "204:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "205:                 let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);",
          "206:                 let input_slpmsg;",
          "207:                 try {",
          "208:                     input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);",
          "211:                     this.cachedValidations[txid].validity = false;",
          "212:                     this.cachedValidations[txid].waiting = false;",
          "213:                     this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";",
          "214:                     return this.cachedValidations[txid].validity!;",
          "215:                 }",
          "219:                 {",
          "220:                     this.cachedValidations[txid].validity = false;",
          "221:                     this.cachedValidations[txid].waiting = false;",
          "222:                     this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "223:                     return this.cachedValidations[txid].validity!;",
          "225:                             input_slpmsg.transactionType === SlpTransactionType.MINT) &&",
          "227:                 {",
          "228:                     this.cachedValidations[txid].validity = false;",
          "229:                     this.cachedValidations[txid].waiting = false;",
          "",
          "[Removed Lines]",
          "163:         let txn: Bitcore.Transaction = new Bitcore.Transaction(this.cachedRawTransactions[txid])",
          "166:             slpmsg = this.cachedValidations[txid].details = this.slp.parseSlpOutputScript(txn.outputs[0]._scriptBuffer)",
          "167:             if(slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "169:         } catch(e) {",
          "172:             this.cachedValidations[txid].invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\"",
          "177:         if(tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "182:             if(this.cachedValidations[txid].validity !== false)",
          "187:         if(tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "193:             if(this.cachedValidations[txid].validity !== false)",
          "198:         if(slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "200:             if(slpmsg.versionType === 0x41) {",
          "203:                 let input_txid = txn.inputs[0].prevTxId.toString('hex');",
          "209:                 } catch(_) { }",
          "210:                 if(!input_slpmsg || input_slpmsg.versionType !== 0x81) {",
          "217:                 if(input_slpmsg.transactionType === SlpTransactionType.SEND &&",
          "218:                     (!input_slpmsg.sendOutputs![1].isGreaterThan(0)))",
          "224:                 } else if((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||",
          "226:                             !input_slpmsg.genesisOrMintQuantity!.isGreaterThan(0))",
          "",
          "[Added Lines]",
          "170:         const txn: Bitcore.Transaction = new Bitcore.Transaction(this.cachedRawTransactions[txid]);",
          "174:             slpmsg = this.cachedValidations[txid].details = this.slp.parseSlpOutputScript(txn.outputs[0]._scriptBuffer);",
          "175:             if (slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "177:             }",
          "178:         } catch (e) {",
          "181:             this.cachedValidations[txid].invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";",
          "186:         if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "191:             if (this.cachedValidations[txid].validity !== false) {",
          "193:             }",
          "197:         if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "203:             if (this.cachedValidations[txid].validity !== false) {",
          "205:             }",
          "209:         if (slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "211:             if (slpmsg.versionType === 0x41) {",
          "214:                 let input_txid = txn.inputs[0].prevTxId.toString(\"hex\");",
          "220:                 } catch (_) { }",
          "221:                 if (!input_slpmsg || input_slpmsg.versionType !== 0x81) {",
          "228:                 if (input_slpmsg.transactionType === SlpTransactionType.SEND &&",
          "229:                     (!input_slpmsg.sendOutputs![1].isGreaterThan(0)))",
          "235:                 } else if ((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||",
          "237:                             !input_slpmsg.genesisOrMintQuantity!.isGreaterThan(0))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "234:                 let nft_parent_dag_validity = await this.isValidSlpTxid(input_txid, undefined, 0x81);",
          "235:                 this.cachedValidations[txid].validity = nft_parent_dag_validity;",
          "236:                 this.cachedValidations[txid].waiting = false;",
          "239:                 }",
          "240:                 return this.cachedValidations[txid].validity!;",
          "244:             else {",
          "",
          "[Removed Lines]",
          "237:                 if(!nft_parent_dag_validity) {",
          "238:                     this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\"",
          "241:             }",
          "",
          "[Added Lines]",
          "248:                 if (!nft_parent_dag_validity) {",
          "249:                     this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";",
          "252:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "248:             }",
          "249:         }",
          "250:         else if (slpmsg.transactionType === SlpTransactionType.MINT) {",
          "254:                 let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);",
          "255:                 try {",
          "258:                         input_slpmsg.tokenIdHex = input_txid;",
          "265:                                     versionType: input_slpmsg.versionType,",
          "266:                                     valid: null,",
          "269:                             }",
          "270:                         }",
          "271:                     }",
          "273:             }",
          "275:                 this.cachedValidations[txid].validity = false;",
          "276:                 this.cachedValidations[txid].waiting = false;",
          "278:                 return this.cachedValidations[txid].validity!;",
          "279:             }",
          "280:         }",
          "283:             let tokenInQty = new BigNumber(0);",
          "287:                 let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);",
          "288:                 try {",
          "291:                         input_slpmsg.tokenIdHex = input_txid;",
          "303:                             }",
          "304:                         }",
          "315:                             }",
          "316:                         }",
          "317:                     }",
          "319:             }",
          "323:                 this.cachedValidations[txid].validity = false;",
          "324:                 this.cachedValidations[txid].waiting = false;",
          "326:                 return this.cachedValidations[txid].validity!;",
          "327:             }",
          "328:         }",
          "335:             this.cachedValidations[txid].parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
          "337:                 this.cachedValidations[txid].validity = false;",
          "338:                 this.cachedValidations[txid].waiting = false;",
          "340:                 return this.cachedValidations[txid].validity!;",
          "341:             }",
          "342:         }",
          "349:                 this.cachedValidations[txid].validity = false;",
          "350:                 this.cachedValidations[txid].waiting = false;",
          "352:                 return this.cachedValidations[txid].validity!;",
          "353:             }",
          "354:         }",
          "360:                 this.cachedValidations[txid].validity = false;",
          "361:                 this.cachedValidations[txid].waiting = false;",
          "363:                 return this.cachedValidations[txid].validity!;",
          "364:             }",
          "365:         }",
          "",
          "[Removed Lines]",
          "251:             for(let i = 0; i < txn.inputs.length; i++) {",
          "252:                 let input_txid = txn.inputs[i].prevTxId.toString('hex')",
          "253:                 let input_txhex = await this.retrieveRawTransaction(input_txid)",
          "256:                     let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer)",
          "257:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "259:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "260:                         if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "261:                             if(txn.inputs[i].outputIndex === input_slpmsg.batonVout) {",
          "262:                                 this.cachedValidations[txid].parents.push({",
          "263:                                     txid: txn.inputs[i].prevTxId.toString('hex'),",
          "264:                                     vout: txn.inputs[i].outputIndex,",
          "267:                                     inputQty: null",
          "268:                                 })",
          "272:                 } catch(_) {}",
          "274:             if(this.cachedValidations[txid].parents.length !== 1) {",
          "277:                 this.cachedValidations[txid].invalidReason = \"MINT transaction must have 1 valid baton parent.\"",
          "281:         else if(slpmsg.transactionType === SlpTransactionType.SEND) {",
          "282:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new BigNumber(0))",
          "284:             for(let i = 0; i < txn.inputs.length; i++) {",
          "285:                 let input_txid = txn.inputs[i].prevTxId.toString('hex')",
          "286:                 let input_txhex = await this.retrieveRawTransaction(input_txid)",
          "289:                     let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer)",
          "290:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "292:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "293:                         if(input_slpmsg.transactionType === SlpTransactionType.SEND) {",
          "294:                             if(txn.inputs[i].outputIndex <= input_slpmsg.sendOutputs!.length-1) {",
          "295:                                 tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].outputIndex])",
          "296:                                 this.cachedValidations[txid].parents.push({",
          "297:                                     txid: txn.inputs[i].prevTxId.toString('hex'),",
          "298:                                     vout: txn.inputs[i].outputIndex,",
          "299:                                     versionType: input_slpmsg.versionType,",
          "300:                                     valid: null,",
          "301:                                     inputQty: input_slpmsg.sendOutputs![txn.inputs[i].outputIndex]",
          "302:                                 })",
          "305:                         else if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "306:                             if(txn.inputs[i].outputIndex === 1) {",
          "307:                                 tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!)",
          "308:                                 this.cachedValidations[txid].parents.push({",
          "309:                                     txid: txn.inputs[i].prevTxId.toString('hex'),",
          "310:                                     vout: txn.inputs[i].outputIndex,",
          "311:                                     versionType: input_slpmsg.versionType,",
          "312:                                     valid: null,",
          "313:                                     inputQty: input_slpmsg.genesisOrMintQuantity",
          "314:                                 })",
          "318:                 } catch(_) {}",
          "322:             if(tokenOutQty.isGreaterThan(tokenInQty)) {",
          "325:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than possible token inputs.\"",
          "332:         let parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];",
          "333:         for(let i = 0; i < parentTxids.length; i++) {",
          "334:             let valid = await this.isValidSlpTxid(parentTxids[i])",
          "336:             if(this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "339:                 this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\"",
          "345:         if(this.cachedValidations[txid].details!.transactionType === SlpTransactionType.SEND) {",
          "346:             let validInputQty = this.cachedValidations[txid].parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t }, new BigNumber(0));",
          "347:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new BigNumber(0))",
          "348:             if(tokenOutQty.isGreaterThan(validInputQty)) {",
          "351:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than valid token inputs.\"",
          "357:         if(this.cachedValidations[txid].parents.filter(p => p.valid).length > 0) {",
          "358:             let validVersionType = this.cachedValidations[txid].parents.find(p => p.valid!)!.versionType;",
          "359:             if(this.cachedValidations[txid].details!.versionType !== validVersionType) {",
          "362:                 this.cachedValidations[txid].invalidReason = \"SLP version/type mismatch from valid parent.\"",
          "",
          "[Added Lines]",
          "262:             for (let i = 0; i < txn.inputs.length; i++) {",
          "263:                 let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");",
          "264:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "267:                     let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);",
          "268:                     if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "270:                     }",
          "271:                     if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "272:                         if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "273:                             if (txn.inputs[i].outputIndex === input_slpmsg.batonVout) {",
          "274:                                 this.cachedValidations[txid].parents.push({",
          "275:                                     txid: txn.inputs[i].prevTxId.toString(\"hex\"),",
          "276:                                     vout: txn.inputs[i].outputIndex!,",
          "279:                                     inputQty: null,",
          "280:                                 });",
          "284:                 } catch (_) {}",
          "286:             if (this.cachedValidations[txid].parents.length !== 1) {",
          "289:                 this.cachedValidations[txid].invalidReason = \"MINT transaction must have 1 valid baton parent.\";",
          "293:         else if (slpmsg.transactionType === SlpTransactionType.SEND) {",
          "294:             const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));",
          "296:             for (let i = 0; i < txn.inputs.length; i++) {",
          "297:                 let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");",
          "298:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "301:                     let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);",
          "302:                     if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "304:                     }",
          "305:                     if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "306:                         if (input_slpmsg.transactionType === SlpTransactionType.SEND) {",
          "307:                             if (txn.inputs[i].outputIndex! <= input_slpmsg.sendOutputs!.length - 1) {",
          "308:                                 tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]);",
          "309:                                 this.cachedValidations[txid].parents.push({",
          "310:                                     txid: txn.inputs[i].prevTxId.toString(\"hex\"),",
          "311:                                     vout: txn.inputs[i].outputIndex!,",
          "312:                                     versionType: input_slpmsg.versionType,",
          "313:                                     valid: null,",
          "314:                                     inputQty: input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]",
          "315:                                 });",
          "318:                         else if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "319:                             if (txn.inputs[i].outputIndex === 1) {",
          "320:                                 tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!);",
          "321:                                 this.cachedValidations[txid].parents.push({",
          "322:                                     txid: txn.inputs[i].prevTxId.toString(\"hex\"),",
          "323:                                     vout: txn.inputs[i].outputIndex!,",
          "324:                                     versionType: input_slpmsg.versionType,",
          "325:                                     valid: null,",
          "326:                                     inputQty: input_slpmsg.genesisOrMintQuantity",
          "327:                                 });",
          "331:                 } catch (_) {}",
          "335:             if (tokenOutQty.isGreaterThan(tokenInQty)) {",
          "338:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than possible token inputs.\";",
          "345:         const parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];",
          "346:         for (let i = 0; i < parentTxids.length; i++) {",
          "347:             const valid = await this.isValidSlpTxid(parentTxids[i]);",
          "349:             if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "352:                 this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\";",
          "358:         if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.SEND) {",
          "359:             const validInputQty = this.cachedValidations[txid].parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t; }, new BigNumber(0));",
          "360:             const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));",
          "361:             if (tokenOutQty.isGreaterThan(validInputQty)) {",
          "364:                 this.cachedValidations[txid].invalidReason = \"Token outputs are greater than valid token inputs.\";",
          "370:         if (this.cachedValidations[txid].parents.filter(p => p.valid).length > 0) {",
          "371:             const validVersionType = this.cachedValidations[txid].parents.find(p => p.valid!)!.versionType;",
          "372:             if (this.cachedValidations[txid].details!.versionType !== validVersionType) {",
          "375:                 this.cachedValidations[txid].invalidReason = \"SLP version/type mismatch from valid parent.\";",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "369:     }",
          "371:     async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "373:         for (let i = 0; i < txids.length; i++) {",
          "375:         }",
          "376:         return res.filter((id: string) => id.length > 0);",
          "377:     }",
          "",
          "[Removed Lines]",
          "372:         let res = [];",
          "374:             res.push((await this.isValidSlpTxid(txids[i])) ? txids[i] : '')",
          "",
          "[Added Lines]",
          "385:         const res = [];",
          "387:             res.push((await this.isValidSlpTxid(txids[i])) ? txids[i] : \"\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
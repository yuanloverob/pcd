{
  "cve_id": "CVE-2020-15500",
  "cve_desc": "An issue was discovered in server.js in TileServer GL through 3.0.0. The content of the key GET parameter is reflected unsanitized in an HTTP response for the application's main page, causing reflected XSS.",
  "repo": "maptiler/tileserver-gl",
  "patch_hash": "10431d70d0f0d7b7950ae2c02aea0850c7566621",
  "patch_info": {
    "commit_hash": "10431d70d0f0d7b7950ae2c02aea0850c7566621",
    "repo": "maptiler/tileserver-gl",
    "commit_url": "https://github.com/maptiler/tileserver-gl/commit/10431d70d0f0d7b7950ae2c02aea0850c7566621",
    "files": [
      "src/serve_style.js",
      "src/server.js",
      "src/utils.js"
    ],
    "message": "Fix reflected XSS in 'key' parameter. Fixes #461",
    "before_after_code_files": [
      "src/serve_style.js||src/serve_style.js",
      "src/server.js||src/server.js",
      "src/utils.js||src/utils.js"
    ]
  },
  "patch_diff": {
    "src/serve_style.js||src/serve_style.js": [
      "File: src/serve_style.js -> src/serve_style.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "17:   }",
      "18:   const queryParams = [];",
      "19:   if (!opt_nokey && req.query.key) {",
      "21:   }",
      "22:   let query = '';",
      "23:   if (queryParams.length) {",
      "",
      "[Removed Lines]",
      "20:     queryParams.unshift(`key=${req.query.key}`);",
      "",
      "[Added Lines]",
      "20:     queryParams.unshift(`key=${encodeURIComponent(req.query.key)}`);",
      "",
      "---------------"
    ],
    "src/server.js||src/server.js": [
      "File: src/server.js -> src/server.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "244:   app.get('/styles.json', (req, res, next) => {",
      "245:     const result = [];",
      "247:     for (const id of Object.keys(serving.styles)) {",
      "248:       const styleJSON = serving.styles[id].styleJSON;",
      "249:       result.push({",
      "",
      "[Removed Lines]",
      "246:     const query = req.query.key ? (`?key=${req.query.key}`) : '';",
      "",
      "[Added Lines]",
      "246:     const query = req.query.key ? (`?key=${encodeURIComponent(req.query.key)}`) : '';",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319:           data['public_url'] = opts.publicUrl || '/';",
      "320:           data['is_light'] = isLight;",
      "321:           data['key_query_part'] =",
      "324:           if (template === 'wmts') res.set('Content-Type', 'text/xml');",
      "325:           return res.status(200).send(compiled(data));",
      "326:         });",
      "",
      "[Removed Lines]",
      "322:             req.query.key ? `key=${req.query.key}&amp;` : '';",
      "323:           data['key_query'] = req.query.key ? `?key=${req.query.key}` : '';",
      "",
      "[Added Lines]",
      "322:             req.query.key ? `key=${encodeURIComponent(req.query.key)}&amp;` : '';",
      "323:           data['key_query'] = req.query.key ? `?key=${encodeURIComponent(req.query.key)}` : '';",
      "",
      "---------------"
    ],
    "src/utils.js||src/utils.js": [
      "File: src/utils.js -> src/utils.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:   const key = req.query.key;",
      "41:   const queryParams = [];",
      "42:   if (req.query.key) {",
      "44:   }",
      "45:   if (req.query.style) {",
      "46:     queryParams.push(`style=${req.query.style}`);",
      "",
      "[Removed Lines]",
      "43:     queryParams.push(`key=${req.query.key}`);",
      "",
      "[Added Lines]",
      "43:     queryParams.push(`key=${encodeURIComponent(req.query.key)}`);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cb700181d3ffca65fbd3eb2edb3ff8bff175452c",
      "candidate_info": {
        "commit_hash": "cb700181d3ffca65fbd3eb2edb3ff8bff175452c",
        "repo": "maptiler/tileserver-gl",
        "commit_url": "https://github.com/maptiler/tileserver-gl/commit/cb700181d3ffca65fbd3eb2edb3ff8bff175452c",
        "files": [
          "src/serve_data.js",
          "src/serve_rendered.js",
          "src/serve_style.js",
          "src/server.js"
        ],
        "message": "Refactor style/rendered/data serving to allow for dynamic adding/removing of items",
        "before_after_code_files": [
          "src/serve_data.js||src/serve_data.js",
          "src/serve_rendered.js||src/serve_rendered.js",
          "src/serve_style.js||src/serve_style.js",
          "src/server.js||src/server.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/serve_style.js||src/serve_style.js",
            "src/server.js||src/server.js"
          ],
          "candidate": [
            "src/serve_style.js||src/serve_style.js",
            "src/server.js||src/server.js"
          ]
        }
      },
      "candidate_diff": {
        "src/serve_data.js||src/serve_data.js": [
          "File: src/serve_data.js -> src/serve_data.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: const utils = require('./utils');",
          "35:       }",
          "37:         if (err) {",
          "56:         }",
          "58:       });",
          "59:     });",
          "80:     }",
          "88:         }",
          "103:           }",
          "137:           }",
          "141:       }",
          "142:     });",
          "155: };",
          "",
          "[Removed Lines]",
          "15: module.exports = (options, repo, params, id, styles, publicUrl) => {",
          "16:   const app = express().disable('x-powered-by');",
          "18:   const mbtilesFile = path.resolve(options.paths.mbtiles, params.mbtiles);",
          "19:   let tileJSON = {",
          "20:     'tiles': params.domains || options.domains",
          "21:   };",
          "23:   repo[id] = tileJSON;",
          "25:   const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "26:   if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "27:     throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "28:   }",
          "29:   let source;",
          "30:   const sourceInfoPromise = new Promise((resolve, reject) => {",
          "31:     source = new MBTiles(mbtilesFile, err => {",
          "32:       if (err) {",
          "33:         reject(err);",
          "34:         return;",
          "36:       source.getInfo((err, info) => {",
          "38:           reject(err);",
          "39:           return;",
          "40:         }",
          "41:         tileJSON['name'] = id;",
          "42:         tileJSON['format'] = 'pbf';",
          "44:         Object.assign(tileJSON, info);",
          "46:         tileJSON['tilejson'] = '2.0.0';",
          "47:         delete tileJSON['filesize'];",
          "48:         delete tileJSON['mtime'];",
          "49:         delete tileJSON['scheme'];",
          "51:         Object.assign(tileJSON, params.tilejson || {});",
          "52:         utils.fixTileJSONCenter(tileJSON);",
          "54:         if (options.dataDecoratorFunc) {",
          "55:           tileJSON = options.dataDecoratorFunc(id, 'tilejson', tileJSON);",
          "57:         resolve();",
          "60:   });",
          "62:   const tilePattern = `/${id}/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format([\\\\w.]+)`;",
          "64:   app.get(tilePattern, (req, res, next) => {",
          "65:     const z = req.params.z | 0;",
          "66:     const x = req.params.x | 0;",
          "67:     const y = req.params.y | 0;",
          "68:     let format = req.params.format;",
          "69:     if (format === options.pbfAlias) {",
          "70:       format = 'pbf';",
          "71:     }",
          "72:     if (format !== tileJSON.format &&",
          "73:         !(format === 'geojson' && tileJSON.format === 'pbf')) {",
          "74:       return res.status(404).send('Invalid format');",
          "75:     }",
          "76:     if (z < tileJSON.minzoom || 0 || x < 0 || y < 0 ||",
          "77:         z > tileJSON.maxzoom ||",
          "78:         x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "79:       return res.status(404).send('Out of bounds');",
          "81:     source.getTile(z, x, y, (err, data, headers) => {",
          "82:       let isGzipped;",
          "83:       if (err) {",
          "84:         if (/does not exist/.test(err.message)) {",
          "85:           return res.status(204).send();",
          "86:         } else {",
          "87:           return res.status(500).send(err.message);",
          "89:       } else {",
          "90:         if (data == null) {",
          "91:           return res.status(404).send('Not found');",
          "92:         } else {",
          "93:           if (tileJSON['format'] === 'pbf') {",
          "94:             isGzipped = data.slice(0, 2).indexOf(",
          "95:               Buffer.from([0x1f, 0x8b])) === 0;",
          "96:             if (options.dataDecoratorFunc) {",
          "97:               if (isGzipped) {",
          "98:                 data = zlib.unzipSync(data);",
          "99:                 isGzipped = false;",
          "100:               }",
          "101:               data = options.dataDecoratorFunc(id, 'data', data, z, x, y);",
          "102:             }",
          "104:           if (format === 'pbf') {",
          "105:             headers['Content-Type'] = 'application/x-protobuf';",
          "106:           } else if (format === 'geojson') {",
          "107:             headers['Content-Type'] = 'application/json';",
          "109:             if (isGzipped) {",
          "110:               data = zlib.unzipSync(data);",
          "111:               isGzipped = false;",
          "112:             }",
          "114:             const tile = new VectorTile(new Pbf(data));",
          "115:             const geojson = {",
          "116:               \"type\": \"FeatureCollection\",",
          "117:               \"features\": []",
          "118:             };",
          "119:             for (let layerName in tile.layers) {",
          "120:               const layer = tile.layers[layerName];",
          "121:               for (let i = 0; i < layer.length; i++) {",
          "122:                 const feature = layer.feature(i);",
          "123:                 const featureGeoJSON = feature.toGeoJSON(x, y, z);",
          "124:                 featureGeoJSON.properties.layer = layerName;",
          "125:                 geojson.features.push(featureGeoJSON);",
          "126:               }",
          "127:             }",
          "128:             data = JSON.stringify(geojson);",
          "129:           }",
          "130:           delete headers['ETag']; // do not trust the tile ETag -- regenerate",
          "131:           headers['Content-Encoding'] = 'gzip';",
          "132:           res.set(headers);",
          "134:           if (!isGzipped) {",
          "135:             data = zlib.gzipSync(data);",
          "136:             isGzipped = true;",
          "139:           return res.status(200).send(data);",
          "140:         }",
          "143:   });",
          "145:   app.get(`/${id}.json`, (req, res, next) => {",
          "146:     const info = clone(tileJSON);",
          "147:     info.tiles = utils.getTileUrls(req, info.tiles,",
          "148:                                    `data/${id}`, info.format, publicUrl, {",
          "149:                                      'pbf': options.pbfAlias",
          "150:                                    });",
          "151:     return res.send(info);",
          "152:   });",
          "154:   return sourceInfoPromise.then(() => app);",
          "",
          "[Added Lines]",
          "15: module.exports = {",
          "16:   init: (options, repo) => {",
          "17:     const app = express().disable('x-powered-by');",
          "19:     app.get('/:id/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format([\\\\w.]+)', (req, res, next) => {",
          "20:       const item = repo[req.params.id];",
          "21:       if (!item) {",
          "22:         return res.sendStatus(404);",
          "23:       }",
          "24:       let tileJSONFormat = item.tileJSON.format;",
          "25:       const z = req.params.z | 0;",
          "26:       const x = req.params.x | 0;",
          "27:       const y = req.params.y | 0;",
          "28:       let format = req.params.format;",
          "29:       if (format === options.pbfAlias) {",
          "30:         format = 'pbf';",
          "31:       }",
          "32:       if (format !== tileJSONFormat &&",
          "33:           !(format === 'geojson' && tileJSONFormat === 'pbf')) {",
          "34:         return res.status(404).send('Invalid format');",
          "36:       if (z < item.tileJSON.minzoom || 0 || x < 0 || y < 0 ||",
          "37:           z > item.tileJSON.maxzoom ||",
          "38:           x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "39:         return res.status(404).send('Out of bounds');",
          "40:       }",
          "41:       item.source.getTile(z, x, y, (err, data, headers) => {",
          "42:         let isGzipped;",
          "44:           if (/does not exist/.test(err.message)) {",
          "45:             return res.status(204).send();",
          "46:           } else {",
          "47:             return res.status(500).send(err.message);",
          "48:           }",
          "49:         } else {",
          "50:           if (data == null) {",
          "51:             return res.status(404).send('Not found');",
          "52:           } else {",
          "53:             if (tileJSONFormat === 'pbf') {",
          "54:               isGzipped = data.slice(0, 2).indexOf(",
          "55:                 Buffer.from([0x1f, 0x8b])) === 0;",
          "56:               if (options.dataDecoratorFunc) {",
          "57:                 if (isGzipped) {",
          "58:                   data = zlib.unzipSync(data);",
          "59:                   isGzipped = false;",
          "60:                 }",
          "61:                 data = options.dataDecoratorFunc(id, 'data', data, z, x, y);",
          "62:               }",
          "63:             }",
          "64:             if (format === 'pbf') {",
          "65:               headers['Content-Type'] = 'application/x-protobuf';",
          "66:             } else if (format === 'geojson') {",
          "67:               headers['Content-Type'] = 'application/json';",
          "69:               if (isGzipped) {",
          "70:                 data = zlib.unzipSync(data);",
          "71:                 isGzipped = false;",
          "72:               }",
          "74:               const tile = new VectorTile(new Pbf(data));",
          "75:               const geojson = {",
          "76:                 \"type\": \"FeatureCollection\",",
          "77:                 \"features\": []",
          "78:               };",
          "79:               for (let layerName in tile.layers) {",
          "80:                 const layer = tile.layers[layerName];",
          "81:                 for (let i = 0; i < layer.length; i++) {",
          "82:                   const feature = layer.feature(i);",
          "83:                   const featureGeoJSON = feature.toGeoJSON(x, y, z);",
          "84:                   featureGeoJSON.properties.layer = layerName;",
          "85:                   geojson.features.push(featureGeoJSON);",
          "86:                 }",
          "87:               }",
          "88:               data = JSON.stringify(geojson);",
          "89:             }",
          "90:             delete headers['ETag']; // do not trust the tile ETag -- regenerate",
          "91:             headers['Content-Encoding'] = 'gzip';",
          "92:             res.set(headers);",
          "94:             if (!isGzipped) {",
          "95:               data = zlib.gzipSync(data);",
          "96:               isGzipped = true;",
          "97:             }",
          "99:             return res.status(200).send(data);",
          "100:           }",
          "105:     app.get('/:id.json', (req, res, next) => {",
          "106:       const item = repo[req.params.id];",
          "107:       if (!item) {",
          "108:         return res.sendStatus(404);",
          "109:       }",
          "110:       const info = clone(item.tileJSON);",
          "111:       info.tiles = utils.getTileUrls(req, info.tiles,",
          "112:                                      `data/${req.params.id}`, info.format, item.publicUrl, {",
          "113:                                        'pbf': options.pbfAlias",
          "114:                                      });",
          "115:       return res.send(info);",
          "116:     });",
          "118:     return app;",
          "119:   },",
          "120:   add: (options, repo, params, id, publicUrl) => {",
          "121:     const mbtilesFile = path.resolve(options.paths.mbtiles, params.mbtiles);",
          "122:     let tileJSON = {",
          "123:       'tiles': params.domains || options.domains",
          "124:     };",
          "126:     const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "127:     if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "128:       throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "130:     let source;",
          "131:     const sourceInfoPromise = new Promise((resolve, reject) => {",
          "132:       source = new MBTiles(mbtilesFile, err => {",
          "133:         if (err) {",
          "134:           reject(err);",
          "135:           return;",
          "137:         source.getInfo((err, info) => {",
          "138:           if (err) {",
          "139:             reject(err);",
          "140:             return;",
          "142:           tileJSON['name'] = id;",
          "143:           tileJSON['format'] = 'pbf';",
          "145:           Object.assign(tileJSON, info);",
          "147:           tileJSON['tilejson'] = '2.0.0';",
          "148:           delete tileJSON['filesize'];",
          "149:           delete tileJSON['mtime'];",
          "150:           delete tileJSON['scheme'];",
          "152:           Object.assign(tileJSON, params.tilejson || {});",
          "153:           utils.fixTileJSONCenter(tileJSON);",
          "155:           if (options.dataDecoratorFunc) {",
          "156:             tileJSON = options.dataDecoratorFunc(id, 'tilejson', tileJSON);",
          "158:           resolve();",
          "159:         });",
          "160:       });",
          "161:     });",
          "163:     return sourceInfoPromise.then(() => {",
          "164:       repo[id] = {",
          "165:         tileJSON,",
          "166:         publicUrl,",
          "167:         source",
          "170:   }",
          "",
          "---------------"
        ],
        "src/serve_rendered.js||src/serve_rendered.js": [
          "File: src/serve_rendered.js -> src/serve_rendered.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: const utils = require('./utils');",
          "27: const FLOAT_PATTERN = '[+-]?(?:\\\\d+|\\\\d+\\.?\\\\d+)';",
          "29: const getScale = scale => (scale || '@1x').slice(1, 2) | 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: const httpTester = /^(http(s)?:)?\\/\\//;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61: function createEmptyResponse(format, color, callback) {",
          "62:   if (!format || format === 'pbf') {",
          "64:     return;",
          "65:   }",
          "",
          "[Removed Lines]",
          "63:     callback(null, {data: cachedEmptyResponses['']});",
          "",
          "[Added Lines]",
          "64:     callback(null, { data: cachedEmptyResponses[''] });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:   const cacheKey = `${format},${color}`;",
          "75:   const data = cachedEmptyResponses[cacheKey];",
          "76:   if (data) {",
          "78:     return;",
          "79:   }",
          "",
          "[Removed Lines]",
          "77:     callback(null, {data: data});",
          "",
          "[Added Lines]",
          "78:     callback(null, { data: data });",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92:     if (!err) {",
          "93:       cachedEmptyResponses[cacheKey] = buffer;",
          "94:     }",
          "96:   });",
          "97: }",
          "106:   }",
          "234:         }",
          "235:       });",
          "246:     });",
          "268:       }",
          "271:       }",
          "316:       }",
          "323:         }",
          "357:             }",
          "359:           });",
          "421:       }",
          "428:         }",
          "454:         }",
          "467:         }",
          "478:         }",
          "490:       });",
          "532:         if (transformer) {",
          "534:         }",
          "649:       }",
          "694:     };",
          "719:       }",
          "765:     });",
          "777: };",
          "",
          "[Removed Lines]",
          "95:     callback(null, {data: buffer});",
          "99: module.exports = (options, repo, params, id, publicUrl, dataResolver) => {",
          "100:   const app = express().disable('x-powered-by');",
          "102:   const maxScaleFactor = Math.min(Math.floor(options.maxScaleFactor || 3), 9);",
          "103:   let scalePattern = '';",
          "104:   for (let i = 2; i <= maxScaleFactor; i++) {",
          "105:     scalePattern += i.toFixed();",
          "107:   scalePattern = `@[${scalePattern}]x`;",
          "109:   const lastModified = new Date().toUTCString();",
          "111:   const watermark = params.watermark || options.watermark;",
          "113:   const styleFile = params.style;",
          "114:   const map = {",
          "115:     renderers: [],",
          "116:     sources: {}",
          "117:   };",
          "119:   const existingFonts = {};",
          "120:   const fontListingPromise = new Promise((resolve, reject) => {",
          "121:     fs.readdir(options.paths.fonts, (err, files) => {",
          "122:       if (err) {",
          "123:         reject(err);",
          "124:         return;",
          "125:       }",
          "126:       for (const file of files) {",
          "127:         fs.stat(path.join(options.paths.fonts, file), (err, stats) => {",
          "128:           if (err) {",
          "129:             reject(err);",
          "130:             return;",
          "131:           }",
          "132:           if (stats.isDirectory()) {",
          "133:             existingFonts[path.basename(file)] = true;",
          "134:           }",
          "135:         });",
          "136:       }",
          "137:       resolve();",
          "138:     });",
          "139:   });",
          "141:   let styleJSON;",
          "142:   const createPool = (ratio, min, max) => {",
          "143:     const createRenderer = (ratio, createCallback) => {",
          "144:       const renderer = new mbgl.Map({",
          "145:         mode: \"tile\",",
          "146:         ratio: ratio,",
          "147:         request: (req, callback) => {",
          "148:           const protocol = req.url.split(':')[0];",
          "150:           if (protocol === 'sprites') {",
          "151:             const dir = options.paths[protocol];",
          "152:             const file = unescape(req.url).substring(protocol.length + 3);",
          "153:             fs.readFile(path.join(dir, file), (err, data) => {",
          "154:               callback(err, { data: data });",
          "155:             });",
          "156:           } else if (protocol === 'fonts') {",
          "157:             const parts = req.url.split('/');",
          "158:             const fontstack = unescape(parts[2]);",
          "159:             const range = parts[3].split('.')[0];",
          "160:             utils.getFontsPbf(",
          "161:               null, options.paths[protocol], fontstack, range, existingFonts",
          "162:             ).then(concated => {",
          "163:               callback(null, { data: concated });",
          "164:             }, err => {",
          "165:               callback(err, { data: null });",
          "166:             });",
          "167:           } else if (protocol === 'mbtiles') {",
          "168:             const parts = req.url.split('/');",
          "169:             const sourceId = parts[2];",
          "170:             const source = map.sources[sourceId];",
          "171:             const sourceInfo = styleJSON.sources[sourceId];",
          "172:             const z = parts[3] | 0,",
          "173:               x = parts[4] | 0,",
          "174:               y = parts[5].split('.')[0] | 0,",
          "175:               format = parts[5].split('.')[1];",
          "176:             source.getTile(z, x, y, (err, data, headers) => {",
          "177:               if (err) {",
          "178:                 if (options.verbose) console.log('MBTiles error, serving empty', err);",
          "179:                 createEmptyResponse(sourceInfo.format, sourceInfo.color, callback);",
          "180:                 return;",
          "181:               }",
          "183:               const response = {};",
          "184:               if (headers['Last-Modified']) {",
          "185:                 response.modified = new Date(headers['Last-Modified']);",
          "186:               }",
          "188:               if (format === 'pbf') {",
          "189:                 try {",
          "190:                   response.data = zlib.unzipSync(data);",
          "191:                 } catch (err) {",
          "192:                   console.log(\"Skipping incorrect header for tile mbtiles://%s/%s/%s/%s.pbf\", id, z, x, y);",
          "193:                 }",
          "194:                 if (options.dataDecoratorFunc) {",
          "195:                   response.data = options.dataDecoratorFunc(",
          "196:                     sourceId, 'data', response.data, z, x, y);",
          "197:                 }",
          "198:               } else {",
          "199:                 response.data = data;",
          "200:               }",
          "202:               callback(null, response);",
          "203:             });",
          "204:           } else if (protocol === 'http' || protocol === 'https') {",
          "205:             request({",
          "206:               url: req.url,",
          "207:               encoding: null,",
          "208:               gzip: true",
          "209:             }, (err, res, body) => {",
          "210:               const parts = url.parse(req.url);",
          "211:               const extension = path.extname(parts.pathname).toLowerCase();",
          "212:               const format = extensionToFormat[extension] || '';",
          "213:               if (err || res.statusCode < 200 || res.statusCode >= 300) {",
          "215:                 createEmptyResponse(format, '', callback);",
          "216:                 return;",
          "217:               }",
          "219:               const response = {};",
          "220:               if (res.headers.modified) {",
          "221:                 response.modified = new Date(res.headers.modified);",
          "222:               }",
          "223:               if (res.headers.expires) {",
          "224:                 response.expires = new Date(res.headers.expires);",
          "225:               }",
          "226:               if (res.headers.etag) {",
          "227:                 response.etag = res.headers.etag;",
          "228:               }",
          "230:               response.data = body;",
          "231:               callback(null, response);",
          "232:             });",
          "233:           }",
          "236:       renderer.load(styleJSON);",
          "237:       createCallback(null, renderer);",
          "238:     };",
          "239:     return new advancedPool.Pool({",
          "240:       min: min,",
          "241:       max: max,",
          "242:       create: createRenderer.bind(null, ratio),",
          "243:       destroy: renderer => {",
          "244:         renderer.release();",
          "245:       }",
          "247:   };",
          "249:   const styleJSONPath = path.resolve(options.paths.styles, styleFile);",
          "250:   styleJSON = clone(require(styleJSONPath));",
          "252:   const httpTester = /^(http(s)?:)?\\/\\//;",
          "253:   if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "254:     styleJSON.sprite = 'sprites://' +",
          "255:         styleJSON.sprite",
          "256:             .replace('{style}', path.basename(styleFile, '.json'))",
          "257:             .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleJSONPath)));",
          "258:   }",
          "259:   if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "260:     styleJSON.glyphs = `fonts://${styleJSON.glyphs}`;",
          "261:   }",
          "263:   for (const layer of (styleJSON.layers || [])) {",
          "264:     if (layer && layer.paint) {",
          "266:       if (layer.paint['fill-extrusion-height']) {",
          "267:         layer.paint['fill-extrusion-height'] = 0;",
          "269:       if (layer.paint['fill-extrusion-base']) {",
          "270:         layer.paint['fill-extrusion-base'] = 0;",
          "272:     }",
          "273:   }",
          "275:   const tileJSON = {",
          "276:     'tilejson': '2.0.0',",
          "277:     'name': styleJSON.name,",
          "278:     'attribution': '',",
          "279:     'minzoom': 0,",
          "280:     'maxzoom': 20,",
          "281:     'bounds': [-180, -85.0511, 180, 85.0511],",
          "282:     'format': 'png',",
          "283:     'type': 'baselayer'",
          "284:   };",
          "285:   const attributionOverride = params.tilejson && params.tilejson.attribution;",
          "286:   Object.assign(tileJSON, params.tilejson || {});",
          "287:   tileJSON.tiles = params.domains || options.domains;",
          "288:   utils.fixTileJSONCenter(tileJSON);",
          "290:   let dataProjWGStoInternalWGS = null;",
          "292:   const queue = [];",
          "293:   for (const name of Object.keys(styleJSON.sources)) {",
          "294:     let source = styleJSON.sources[name];",
          "295:     const url = source.url;",
          "297:     if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "299:       delete source.url;",
          "301:       let mbtilesFile = url.substring('mbtiles://'.length);",
          "302:       const fromData = mbtilesFile[0] === '{' &&",
          "303:         mbtilesFile[mbtilesFile.length - 1] === '}';",
          "305:       if (fromData) {",
          "306:         mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "307:         const mapsTo = (params.mapping || {})[mbtilesFile];",
          "308:         if (mapsTo) {",
          "309:           mbtilesFile = mapsTo;",
          "310:         }",
          "311:         mbtilesFile = dataResolver(mbtilesFile);",
          "312:         if (!mbtilesFile) {",
          "313:           console.error(`ERROR: data \"${mbtilesFile}\" not found!`);",
          "314:           process.exit(1);",
          "315:         }",
          "318:       queue.push(new Promise((resolve, reject) => {",
          "319:         mbtilesFile = path.resolve(options.paths.mbtiles, mbtilesFile);",
          "320:         const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "321:         if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "322:           throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "324:         map.sources[name] = new MBTiles(mbtilesFile, err => {",
          "325:           map.sources[name].getInfo((err, info) => {",
          "326:             if (err) {",
          "327:               console.error(err);",
          "328:               return;",
          "329:             }",
          "331:             if (!dataProjWGStoInternalWGS && info.proj4) {",
          "333:               const to3857 = proj4('EPSG:3857');",
          "334:               const toDataProj = proj4(info.proj4);",
          "335:               dataProjWGStoInternalWGS = xy => to3857.inverse(toDataProj.forward(xy));",
          "336:             }",
          "338:             const type = source.type;",
          "339:             Object.assign(source, info);",
          "340:             source.type = type;",
          "341:             source.tiles = [",
          "343:               `mbtiles://${name}/{z}/{x}/{y}.${info.format || 'pbf'}`",
          "344:             ];",
          "345:             delete source.scheme;",
          "347:             if (options.dataDecoratorFunc) {",
          "348:               source = options.dataDecoratorFunc(name, 'tilejson', source);",
          "349:             }",
          "351:             if (!attributionOverride &&",
          "352:                 source.attribution && source.attribution.length > 0) {",
          "353:               if (tileJSON.attribution.length > 0) {",
          "354:                 tileJSON.attribution += '; ';",
          "355:               }",
          "356:               tileJSON.attribution += source.attribution;",
          "358:             resolve();",
          "360:         });",
          "361:       }));",
          "362:     }",
          "363:   }",
          "365:   const renderersReadyPromise = Promise.all(queue).then(() => {",
          "367:     const minPoolSizes = options.minRendererPoolSizes || [8, 4, 2];",
          "368:     const maxPoolSizes = options.maxRendererPoolSizes || [16, 8, 4];",
          "369:     for (let s = 1; s <= maxScaleFactor; s++) {",
          "370:       const i = Math.min(minPoolSizes.length - 1, s - 1);",
          "371:       const j = Math.min(maxPoolSizes.length - 1, s - 1);",
          "372:       const minPoolSize = minPoolSizes[i];",
          "373:       const maxPoolSize = Math.max(minPoolSize, maxPoolSizes[j]);",
          "374:       map.renderers[s] = createPool(s, minPoolSize, maxPoolSize);",
          "375:     }",
          "376:   });",
          "378:   repo[id] = tileJSON;",
          "380:   const tilePattern = `/${id}/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`;",
          "382:   const respondImage = (z, lon, lat, bearing, pitch,",
          "383:                         width, height, scale, format, res, next,",
          "384:                         opt_overlay) => {",
          "385:     if (Math.abs(lon) > 180 || Math.abs(lat) > 85.06 ||",
          "386:       lon !== lon || lat !== lat) {",
          "387:       return res.status(400).send('Invalid center');",
          "388:     }",
          "389:     if (Math.min(width, height) <= 0 ||",
          "390:       Math.max(width, height) * scale > (options.maxSize || 2048) ||",
          "391:       width !== width || height !== height) {",
          "392:       return res.status(400).send('Invalid size');",
          "393:     }",
          "394:     if (format === 'png' || format === 'webp') {",
          "395:     } else if (format === 'jpg' || format === 'jpeg') {",
          "396:       format = 'jpeg';",
          "397:     } else {",
          "398:       return res.status(400).send('Invalid format');",
          "399:     }",
          "401:     const pool = map.renderers[scale];",
          "402:     pool.acquire((err, renderer) => {",
          "403:       const mbglZ = Math.max(0, z - 1);",
          "404:       const params = {",
          "405:         zoom: mbglZ,",
          "406:         center: [lon, lat],",
          "407:         bearing: bearing,",
          "408:         pitch: pitch,",
          "409:         width: width,",
          "410:         height: height",
          "411:       };",
          "412:       if (z === 0) {",
          "413:         params.width *= 2;",
          "414:         params.height *= 2;",
          "415:       }",
          "417:       const tileMargin = Math.max(options.tileMargin || 0, 0);",
          "418:       if (z > 2 && tileMargin > 0) {",
          "419:         params.width += tileMargin * 2;",
          "420:         params.height += tileMargin * 2;",
          "423:       renderer.render(params, (err, data) => {",
          "424:         pool.release(renderer);",
          "425:         if (err) {",
          "426:           console.error(err);",
          "427:           return;",
          "430:         const image = sharp(data, {",
          "431:           raw: {",
          "432:             width: params.width * scale,",
          "433:             height: params.height * scale,",
          "434:             channels: 4",
          "435:           }",
          "436:         });",
          "438:         if (z > 2 && tileMargin > 0) {",
          "439:           image.extract({",
          "440:             left: tileMargin * scale,",
          "441:             top: tileMargin * scale,",
          "442:             width: width * scale,",
          "443:             height: height * scale",
          "444:           });",
          "445:         }",
          "447:         if (z === 0) {",
          "449:           image.resize(width * scale, height * scale);",
          "450:         }",
          "452:         if (opt_overlay) {",
          "453:           image.composite([{ input: opt_overlay }]);",
          "455:         if (watermark) {",
          "456:           const canvas = createCanvas(scale * width, scale * height);",
          "457:           const ctx = canvas.getContext('2d');",
          "458:           ctx.scale(scale, scale);",
          "459:           ctx.font = '10px sans-serif';",
          "460:           ctx.strokeWidth = '1px';",
          "461:           ctx.strokeStyle = 'rgba(255,255,255,.4)';",
          "462:           ctx.strokeText(watermark, 5, height - 5);",
          "463:           ctx.fillStyle = 'rgba(0,0,0,.4)';",
          "464:           ctx.fillText(watermark, 5, height - 5);",
          "466:           image.composite([{ input: canvas.toBuffer() }]);",
          "469:         const formatQuality = (params.formatQuality || {})[format] ||",
          "470:           (options.formatQuality || {})[format];",
          "472:         if (format === 'png') {",
          "473:           image.png({ adaptiveFiltering: false });",
          "474:         } else if (format === 'jpeg') {",
          "475:           image.jpeg({ quality: formatQuality || 80 });",
          "476:         } else if (format === 'webp') {",
          "477:           image.webp({ quality: formatQuality || 90 });",
          "479:         image.toBuffer((err, buffer, info) => {",
          "480:           if (!buffer) {",
          "481:             return res.status(404).send('Not found');",
          "482:           }",
          "484:           res.set({",
          "485:             'Last-Modified': lastModified,",
          "486:             'Content-Type': `image/${format}`",
          "487:           });",
          "488:           return res.status(200).send(buffer);",
          "489:         });",
          "491:     });",
          "492:   };",
          "494:   app.get(tilePattern, (req, res, next) => {",
          "495:     const modifiedSince = req.get('if-modified-since'), cc = req.get('cache-control');",
          "496:     if (modifiedSince && (!cc || cc.indexOf('no-cache') === -1)) {",
          "497:       if (new Date(lastModified) <= new Date(modifiedSince)) {",
          "498:         return res.sendStatus(304);",
          "499:       }",
          "500:     }",
          "502:     const z = req.params.z | 0,",
          "503:       x = req.params.x | 0,",
          "504:       y = req.params.y | 0,",
          "505:       scale = getScale(req.params.scale),",
          "506:       format = req.params.format;",
          "507:     if (z < 0 || x < 0 || y < 0 ||",
          "508:         z > 20 || x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "509:       return res.status(404).send('Out of bounds');",
          "510:     }",
          "511:     const tileSize = 256;",
          "512:     const tileCenter = mercator.ll([",
          "513:       ((x + 0.5) / (1 << z)) * (256 << z),",
          "514:       ((y + 0.5) / (1 << z)) * (256 << z)",
          "515:     ], z);",
          "516:     return respondImage(z, tileCenter[0], tileCenter[1], 0, 0,",
          "517:                         tileSize, tileSize, scale, format, res, next);",
          "518:   });",
          "520:   const extractPathFromQuery = (query, transformer) => {",
          "521:     const pathParts = (query.path || '').split('|');",
          "522:     const path = [];",
          "523:     for (const pair of pathParts) {",
          "524:       const pairParts = pair.split(',');",
          "525:       if (pairParts.length === 2) {",
          "526:         let pair;",
          "527:         if (query.latlng === '1' || query.latlng === 'true') {",
          "528:           pair = [+(pairParts[1]), +(pairParts[0])];",
          "529:         } else {",
          "530:           pair = [+(pairParts[0]), +(pairParts[1])];",
          "531:         }",
          "533:           pair = transformer(pair);",
          "535:         path.push(pair);",
          "536:       }",
          "537:     }",
          "538:     return path;",
          "539:   };",
          "541:   const renderOverlay = (z, x, y, bearing, pitch, w, h, scale,",
          "542:                          path, query) => {",
          "543:     if (!path || path.length < 2) {",
          "544:       return null;",
          "545:     }",
          "546:     const precisePx = (ll, zoom) => {",
          "547:       const px = mercator.px(ll, 20);",
          "548:       const scale = Math.pow(2, zoom - 20);",
          "549:       return [px[0] * scale, px[1] * scale];",
          "550:     };",
          "552:     const center = precisePx([x, y], z);",
          "554:     const mapHeight = 512 * (1 << z);",
          "555:     const maxEdge = center[1] + h / 2;",
          "556:     const minEdge = center[1] - h / 2;",
          "557:     if (maxEdge > mapHeight) {",
          "558:       center[1] -= (maxEdge - mapHeight);",
          "559:     } else if (minEdge < 0) {",
          "560:       center[1] -= minEdge;",
          "561:     }",
          "563:     const canvas = createCanvas(scale * w, scale * h);",
          "564:     const ctx = canvas.getContext('2d');",
          "565:     ctx.scale(scale, scale);",
          "566:     if (bearing) {",
          "567:       ctx.translate(w / 2, h / 2);",
          "568:       ctx.rotate(-bearing / 180 * Math.PI);",
          "569:       ctx.translate(-center[0], -center[1]);",
          "570:     } else {",
          "572:       ctx.translate(-center[0] + w / 2, -center[1] + h / 2);",
          "573:     }",
          "574:     const lineWidth = query.width !== undefined ?",
          "575:       parseFloat(query.width) : 1;",
          "576:     ctx.lineWidth = lineWidth;",
          "577:     ctx.strokeStyle = query.stroke || 'rgba(0,64,255,0.7)';",
          "578:     ctx.fillStyle = query.fill || 'rgba(255,255,255,0.4)';",
          "579:     ctx.beginPath();",
          "580:     for (const pair of path) {",
          "581:       const px = precisePx(pair, z);",
          "582:       ctx.lineTo(px[0], px[1]);",
          "583:     }",
          "584:     if (path[0][0] === path[path.length - 1][0] &&",
          "585:       path[0][1] === path[path.length - 1][1]) {",
          "586:       ctx.closePath();",
          "587:     }",
          "588:     ctx.fill();",
          "589:     if (lineWidth > 0) {",
          "590:       ctx.stroke();",
          "591:     }",
          "593:     return canvas.toBuffer();",
          "594:   };",
          "596:   const calcZForBBox = (bbox, w, h, query) => {",
          "597:     let z = 25;",
          "599:     const padding = query.padding !== undefined ?",
          "600:       parseFloat(query.padding) : 0.1;",
          "602:     const minCorner = mercator.px([bbox[0], bbox[3]], z),",
          "603:       maxCorner = mercator.px([bbox[2], bbox[1]], z);",
          "604:     const w_ = w / (1 + 2 * padding);",
          "605:     const h_ = h / (1 + 2 * padding);",
          "607:     z -= Math.max(",
          "608:       Math.log((maxCorner[0] - minCorner[0]) / w_),",
          "609:       Math.log((maxCorner[1] - minCorner[1]) / h_)",
          "610:     ) / Math.LN2;",
          "612:     z = Math.max(Math.log(Math.max(w, h) / 256) / Math.LN2, Math.min(25, z));",
          "614:     return z;",
          "615:   };",
          "617:   if (options.serveStaticMaps !== false) {",
          "618:     const staticPattern =",
          "619:       `/${id}/static/:raw(raw)?/%s/:width(\\\\d+)x:height(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`;",
          "621:     const centerPattern =",
          "622:       util.format(':x(%s),:y(%s),:z(%s)(@:bearing(%s)(,:pitch(%s))?)?',",
          "623:         FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN,",
          "624:         FLOAT_PATTERN, FLOAT_PATTERN);",
          "626:     app.get(util.format(staticPattern, centerPattern), (req, res, next) => {",
          "627:       const raw = req.params.raw;",
          "628:       let z = +req.params.z,",
          "629:         x = +req.params.x,",
          "630:         y = +req.params.y,",
          "631:         bearing = +(req.params.bearing || '0'),",
          "632:         pitch = +(req.params.pitch || '0'),",
          "633:         w = req.params.width | 0,",
          "634:         h = req.params.height | 0,",
          "635:         scale = getScale(req.params.scale),",
          "636:         format = req.params.format;",
          "638:       if (z < 0) {",
          "639:         return res.status(404).send('Invalid zoom');",
          "640:       }",
          "642:       const transformer = raw ?",
          "643:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "645:       if (transformer) {",
          "646:         const ll = transformer([x, y]);",
          "647:         x = ll[0];",
          "648:         y = ll[1];",
          "651:       const path = extractPathFromQuery(req.query, transformer);",
          "652:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "653:         path, req.query);",
          "655:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "656:                           res, next, overlay);",
          "657:     });",
          "659:     const serveBounds = (req, res, next) => {",
          "660:       const raw = req.params.raw;",
          "661:       const bbox = [+req.params.minx, +req.params.miny,",
          "662:         +req.params.maxx, +req.params.maxy];",
          "663:       let center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];",
          "665:       const transformer = raw ?",
          "666:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "668:       if (transformer) {",
          "669:         const minCorner = transformer(bbox.slice(0, 2));",
          "670:         const maxCorner = transformer(bbox.slice(2));",
          "671:         bbox[0] = minCorner[0];",
          "672:         bbox[1] = minCorner[1];",
          "673:         bbox[2] = maxCorner[0];",
          "674:         bbox[3] = maxCorner[1];",
          "675:         center = transformer(center);",
          "676:       }",
          "678:       const w = req.params.width | 0,",
          "679:         h = req.params.height | 0,",
          "680:         scale = getScale(req.params.scale),",
          "681:         format = req.params.format;",
          "683:       const z = calcZForBBox(bbox, w, h, req.query),",
          "684:         x = center[0],",
          "685:         y = center[1],",
          "686:         bearing = 0,",
          "687:         pitch = 0;",
          "689:       const path = extractPathFromQuery(req.query, transformer);",
          "690:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "691:         path, req.query);",
          "692:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "693:         res, next, overlay);",
          "696:     const boundsPattern =",
          "697:       util.format(':minx(%s),:miny(%s),:maxx(%s),:maxy(%s)',",
          "698:         FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN);",
          "700:     app.get(util.format(staticPattern, boundsPattern), serveBounds);",
          "702:     app.get(`/${id}/static/`, (req, res, next) => {",
          "703:       for (let key in req.query) {",
          "704:         req.query[key.toLowerCase()] = req.query[key];",
          "705:       }",
          "706:       req.params.raw = true;",
          "707:       req.params.format = (req.query.format || 'image/png').split('/').pop();",
          "708:       const bbox = (req.query.bbox || '').split(',');",
          "709:       req.params.minx = bbox[0];",
          "710:       req.params.miny = bbox[1];",
          "711:       req.params.maxx = bbox[2];",
          "712:       req.params.maxy = bbox[3];",
          "713:       req.params.width = req.query.width || '256';",
          "714:       req.params.height = req.query.height || '256';",
          "715:       if (req.query.scale) {",
          "716:         req.params.width /= req.query.scale;",
          "717:         req.params.height /= req.query.scale;",
          "718:         req.params.scale = `@${req.query.scale}`;",
          "721:       return serveBounds(req, res, next);",
          "722:     });",
          "724:     const autoPattern = 'auto';",
          "726:     app.get(util.format(staticPattern, autoPattern), (req, res, next) => {",
          "727:       const raw = req.params.raw;",
          "728:       const w = req.params.width | 0,",
          "729:         h = req.params.height | 0,",
          "730:         bearing = 0,",
          "731:         pitch = 0,",
          "732:         scale = getScale(req.params.scale),",
          "733:         format = req.params.format;",
          "735:       const transformer = raw ?",
          "736:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "738:       const path = extractPathFromQuery(req.query, transformer);",
          "739:       if (path.length < 2) {",
          "740:         return res.status(400).send('Invalid path');",
          "741:       }",
          "743:       const bbox = [Infinity, Infinity, -Infinity, -Infinity];",
          "744:       for (const pair of path) {",
          "745:         bbox[0] = Math.min(bbox[0], pair[0]);",
          "746:         bbox[1] = Math.min(bbox[1], pair[1]);",
          "747:         bbox[2] = Math.max(bbox[2], pair[0]);",
          "748:         bbox[3] = Math.max(bbox[3], pair[1]);",
          "749:       }",
          "751:       const bbox_ = mercator.convert(bbox, '900913');",
          "752:       const center = mercator.inverse(",
          "753:         [(bbox_[0] + bbox_[2]) / 2, (bbox_[1] + bbox_[3]) / 2]",
          "754:       );",
          "756:       const z = calcZForBBox(bbox, w, h, req.query),",
          "757:         x = center[0],",
          "758:         y = center[1];",
          "760:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "761:         path, req.query);",
          "763:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "764:                           res, next, overlay);",
          "766:   }",
          "768:   app.get(`/${id}.json`, (req, res, next) => {",
          "769:     const info = clone(tileJSON);",
          "770:     info.tiles = utils.getTileUrls(req, info.tiles,",
          "771:                                    `styles/${id}`, info.format, publicUrl);",
          "772:     return res.send(info);",
          "773:   });",
          "775:   return Promise.all([fontListingPromise, renderersReadyPromise]).then(() => app);",
          "",
          "[Added Lines]",
          "96:     callback(null, { data: buffer });",
          "100: const extractPathFromQuery = (query, transformer) => {",
          "101:   const pathParts = (query.path || '').split('|');",
          "102:   const path = [];",
          "103:   for (const pair of pathParts) {",
          "104:     const pairParts = pair.split(',');",
          "105:     if (pairParts.length === 2) {",
          "106:       let pair;",
          "107:       if (query.latlng === '1' || query.latlng === 'true') {",
          "108:         pair = [+(pairParts[1]), +(pairParts[0])];",
          "109:       } else {",
          "110:         pair = [+(pairParts[0]), +(pairParts[1])];",
          "111:       }",
          "112:       if (transformer) {",
          "113:         pair = transformer(pair);",
          "114:       }",
          "115:       path.push(pair);",
          "116:     }",
          "117:   }",
          "118:   return path;",
          "119: };",
          "121: const renderOverlay = (z, x, y, bearing, pitch, w, h, scale,",
          "122:   path, query) => {",
          "123:   if (!path || path.length < 2) {",
          "124:     return null;",
          "126:   const precisePx = (ll, zoom) => {",
          "127:     const px = mercator.px(ll, 20);",
          "128:     const scale = Math.pow(2, zoom - 20);",
          "129:     return [px[0] * scale, px[1] * scale];",
          "130:   };",
          "132:   const center = precisePx([x, y], z);",
          "134:   const mapHeight = 512 * (1 << z);",
          "135:   const maxEdge = center[1] + h / 2;",
          "136:   const minEdge = center[1] - h / 2;",
          "137:   if (maxEdge > mapHeight) {",
          "138:     center[1] -= (maxEdge - mapHeight);",
          "139:   } else if (minEdge < 0) {",
          "140:     center[1] -= minEdge;",
          "141:   }",
          "143:   const canvas = createCanvas(scale * w, scale * h);",
          "144:   const ctx = canvas.getContext('2d');",
          "145:   ctx.scale(scale, scale);",
          "146:   if (bearing) {",
          "147:     ctx.translate(w / 2, h / 2);",
          "148:     ctx.rotate(-bearing / 180 * Math.PI);",
          "149:     ctx.translate(-center[0], -center[1]);",
          "150:   } else {",
          "152:     ctx.translate(-center[0] + w / 2, -center[1] + h / 2);",
          "153:   }",
          "154:   const lineWidth = query.width !== undefined ?",
          "155:     parseFloat(query.width) : 1;",
          "156:   ctx.lineWidth = lineWidth;",
          "157:   ctx.strokeStyle = query.stroke || 'rgba(0,64,255,0.7)';",
          "158:   ctx.fillStyle = query.fill || 'rgba(255,255,255,0.4)';",
          "159:   ctx.beginPath();",
          "160:   for (const pair of path) {",
          "161:     const px = precisePx(pair, z);",
          "162:     ctx.lineTo(px[0], px[1]);",
          "163:   }",
          "164:   if (path[0][0] === path[path.length - 1][0] &&",
          "165:     path[0][1] === path[path.length - 1][1]) {",
          "166:     ctx.closePath();",
          "167:   }",
          "168:   ctx.fill();",
          "169:   if (lineWidth > 0) {",
          "170:     ctx.stroke();",
          "171:   }",
          "173:   return canvas.toBuffer();",
          "174: };",
          "176: const calcZForBBox = (bbox, w, h, query) => {",
          "177:   let z = 25;",
          "179:   const padding = query.padding !== undefined ?",
          "180:     parseFloat(query.padding) : 0.1;",
          "182:   const minCorner = mercator.px([bbox[0], bbox[3]], z),",
          "183:     maxCorner = mercator.px([bbox[2], bbox[1]], z);",
          "184:   const w_ = w / (1 + 2 * padding);",
          "185:   const h_ = h / (1 + 2 * padding);",
          "187:   z -= Math.max(",
          "188:     Math.log((maxCorner[0] - minCorner[0]) / w_),",
          "189:     Math.log((maxCorner[1] - minCorner[1]) / h_)",
          "190:   ) / Math.LN2;",
          "192:   z = Math.max(Math.log(Math.max(w, h) / 256) / Math.LN2, Math.min(25, z));",
          "194:   return z;",
          "195: };",
          "197: const existingFonts = {};",
          "198: let maxScaleFactor = 2;",
          "200: module.exports = {",
          "201:   init: (options, repo) => {",
          "202:     const fontListingPromise = new Promise((resolve, reject) => {",
          "203:       fs.readdir(options.paths.fonts, (err, files) => {",
          "204:         if (err) {",
          "205:           reject(err);",
          "206:           return;",
          "208:         for (const file of files) {",
          "209:           fs.stat(path.join(options.paths.fonts, file), (err, stats) => {",
          "210:             if (err) {",
          "211:               reject(err);",
          "212:               return;",
          "213:             }",
          "214:             if (stats.isDirectory()) {",
          "215:               existingFonts[path.basename(file)] = true;",
          "216:             }",
          "217:           });",
          "218:         }",
          "219:         resolve();",
          "223:     maxScaleFactor = Math.min(Math.floor(options.maxScaleFactor || 3), 9);",
          "224:     let scalePattern = '';",
          "225:     for (let i = 2; i <= maxScaleFactor; i++) {",
          "226:       scalePattern += i.toFixed();",
          "227:     }",
          "228:     scalePattern = `@[${scalePattern}]x`;",
          "230:     const app = express().disable('x-powered-by');",
          "232:     const respondImage = (item, z, lon, lat, bearing, pitch,",
          "233:       width, height, scale, format, res, next,",
          "234:       opt_overlay) => {",
          "235:       if (Math.abs(lon) > 180 || Math.abs(lat) > 85.06 ||",
          "236:         lon !== lon || lat !== lat) {",
          "237:         return res.status(400).send('Invalid center');",
          "239:       if (Math.min(width, height) <= 0 ||",
          "240:         Math.max(width, height) * scale > (options.maxSize || 2048) ||",
          "241:         width !== width || height !== height) {",
          "242:         return res.status(400).send('Invalid size');",
          "244:       if (format === 'png' || format === 'webp') {",
          "245:       } else if (format === 'jpg' || format === 'jpeg') {",
          "246:         format = 'jpeg';",
          "247:       } else {",
          "248:         return res.status(400).send('Invalid format');",
          "251:       const pool = item.map.renderers[scale];",
          "252:       pool.acquire((err, renderer) => {",
          "253:         const mbglZ = Math.max(0, z - 1);",
          "254:         const params = {",
          "255:           zoom: mbglZ,",
          "256:           center: [lon, lat],",
          "257:           bearing: bearing,",
          "258:           pitch: pitch,",
          "259:           width: width,",
          "260:           height: height",
          "261:         };",
          "262:         if (z === 0) {",
          "263:           params.width *= 2;",
          "264:           params.height *= 2;",
          "267:         const tileMargin = Math.max(options.tileMargin || 0, 0);",
          "268:         if (z > 2 && tileMargin > 0) {",
          "269:           params.width += tileMargin * 2;",
          "270:           params.height += tileMargin * 2;",
          "271:         }",
          "273:         renderer.render(params, (err, data) => {",
          "274:           pool.release(renderer);",
          "275:           if (err) {",
          "276:             console.error(err);",
          "277:             return;",
          "278:           }",
          "280:           const image = sharp(data, {",
          "281:             raw: {",
          "282:               width: params.width * scale,",
          "283:               height: params.height * scale,",
          "284:               channels: 4",
          "288:           if (z > 2 && tileMargin > 0) {",
          "289:             image.extract({",
          "290:               left: tileMargin * scale,",
          "291:               top: tileMargin * scale,",
          "292:               width: width * scale,",
          "293:               height: height * scale",
          "294:             });",
          "295:           }",
          "297:           if (z === 0) {",
          "299:             image.resize(width * scale, height * scale);",
          "300:           }",
          "302:           if (opt_overlay) {",
          "303:             image.composite([{ input: opt_overlay }]);",
          "304:           }",
          "305:           if (item.watermark) {",
          "306:             const canvas = createCanvas(scale * width, scale * height);",
          "307:             const ctx = canvas.getContext('2d');",
          "308:             ctx.scale(scale, scale);",
          "309:             ctx.font = '10px sans-serif';",
          "310:             ctx.strokeWidth = '1px';",
          "311:             ctx.strokeStyle = 'rgba(255,255,255,.4)';",
          "312:             ctx.strokeText(item.watermark, 5, height - 5);",
          "313:             ctx.fillStyle = 'rgba(0,0,0,.4)';",
          "314:             ctx.fillText(item.watermark, 5, height - 5);",
          "316:             image.composite([{ input: canvas.toBuffer() }]);",
          "317:           }",
          "319:           const formatQuality = (options.formatQuality || {})[format];",
          "321:           if (format === 'png') {",
          "322:             image.png({ adaptiveFiltering: false });",
          "323:           } else if (format === 'jpeg') {",
          "324:             image.jpeg({ quality: formatQuality || 80 });",
          "325:           } else if (format === 'webp') {",
          "326:             image.webp({ quality: formatQuality || 90 });",
          "327:           }",
          "328:           image.toBuffer((err, buffer, info) => {",
          "329:             if (!buffer) {",
          "330:               return res.status(404).send('Not found');",
          "331:             }",
          "333:             res.set({",
          "334:               'Last-Modified': item.lastModified,",
          "335:               'Content-Type': `image/${format}`",
          "336:             });",
          "337:             return res.status(200).send(buffer);",
          "338:           });",
          "339:         });",
          "340:       });",
          "341:     };",
          "343:     app.get(`/:id/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`, (req, res, next) => {",
          "344:       const item = repo[req.params.id];",
          "345:       if (!item) {",
          "346:         return res.sendStatus(404);",
          "349:       const modifiedSince = req.get('if-modified-since'), cc = req.get('cache-control');",
          "350:       if (modifiedSince && (!cc || cc.indexOf('no-cache') === -1)) {",
          "351:         if (new Date(item.lastModified) <= new Date(modifiedSince)) {",
          "352:           return res.sendStatus(304);",
          "354:       }",
          "356:       const z = req.params.z | 0,",
          "357:         x = req.params.x | 0,",
          "358:         y = req.params.y | 0,",
          "359:         scale = getScale(req.params.scale),",
          "360:         format = req.params.format;",
          "361:       if (z < 0 || x < 0 || y < 0 ||",
          "362:         z > 20 || x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "363:         return res.status(404).send('Out of bounds');",
          "364:       }",
          "365:       const tileSize = 256;",
          "366:       const tileCenter = mercator.ll([",
          "367:         ((x + 0.5) / (1 << z)) * (256 << z),",
          "368:         ((y + 0.5) / (1 << z)) * (256 << z)",
          "369:       ], z);",
          "370:       return respondImage(item, z, tileCenter[0], tileCenter[1], 0, 0,",
          "371:         tileSize, tileSize, scale, format, res, next);",
          "372:     });",
          "374:     if (options.serveStaticMaps !== false) {",
          "375:       const staticPattern =",
          "376:         `/:id/static/:raw(raw)?/%s/:width(\\\\d+)x:height(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`;",
          "378:       const centerPattern =",
          "379:         util.format(':x(%s),:y(%s),:z(%s)(@:bearing(%s)(,:pitch(%s))?)?',",
          "380:           FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN,",
          "381:           FLOAT_PATTERN, FLOAT_PATTERN);",
          "383:       app.get(util.format(staticPattern, centerPattern), (req, res, next) => {",
          "384:         const item = repo[req.params.id];",
          "385:         if (!item) {",
          "386:           return res.sendStatus(404);",
          "388:         const raw = req.params.raw;",
          "389:         let z = +req.params.z,",
          "390:           x = +req.params.x,",
          "391:           y = +req.params.y,",
          "392:           bearing = +(req.params.bearing || '0'),",
          "393:           pitch = +(req.params.pitch || '0'),",
          "394:           w = req.params.width | 0,",
          "395:           h = req.params.height | 0,",
          "396:           scale = getScale(req.params.scale),",
          "397:           format = req.params.format;",
          "399:         if (z < 0) {",
          "400:           return res.status(404).send('Invalid zoom');",
          "403:         const transformer = raw ?",
          "404:           mercator.inverse.bind(mercator) : item.dataProjWGStoInternalWGS;",
          "406:         if (transformer) {",
          "407:           const ll = transformer([x, y]);",
          "408:           x = ll[0];",
          "409:           y = ll[1];",
          "412:         const path = extractPathFromQuery(req.query, transformer);",
          "413:         const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "414:           path, req.query);",
          "416:         return respondImage(item, z, x, y, bearing, pitch, w, h, scale, format,",
          "417:           res, next, overlay);",
          "420:       const serveBounds = (req, res, next) => {",
          "421:         const item = repo[req.params.id];",
          "422:         if (!item) {",
          "423:           return res.sendStatus(404);",
          "424:         }",
          "425:         const raw = req.params.raw;",
          "426:         const bbox = [+req.params.minx, +req.params.miny,",
          "427:         +req.params.maxx, +req.params.maxy];",
          "428:         let center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];",
          "430:         const transformer = raw ?",
          "431:           mercator.inverse.bind(mercator) : item.dataProjWGStoInternalWGS;",
          "434:           const minCorner = transformer(bbox.slice(0, 2));",
          "435:           const maxCorner = transformer(bbox.slice(2));",
          "436:           bbox[0] = minCorner[0];",
          "437:           bbox[1] = minCorner[1];",
          "438:           bbox[2] = maxCorner[0];",
          "439:           bbox[3] = maxCorner[1];",
          "440:           center = transformer(center);",
          "443:         const w = req.params.width | 0,",
          "444:           h = req.params.height | 0,",
          "445:           scale = getScale(req.params.scale),",
          "446:           format = req.params.format;",
          "448:         const z = calcZForBBox(bbox, w, h, req.query),",
          "449:           x = center[0],",
          "450:           y = center[1],",
          "451:           bearing = 0,",
          "452:           pitch = 0;",
          "454:         const path = extractPathFromQuery(req.query, transformer);",
          "455:         const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "456:           path, req.query);",
          "457:         return respondImage(item, z, x, y, bearing, pitch, w, h, scale, format,",
          "458:           res, next, overlay);",
          "459:       };",
          "461:       const boundsPattern =",
          "462:         util.format(':minx(%s),:miny(%s),:maxx(%s),:maxy(%s)',",
          "463:           FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN);",
          "465:       app.get(util.format(staticPattern, boundsPattern), serveBounds);",
          "467:       app.get('/:id/static/', (req, res, next) => {",
          "468:         for (let key in req.query) {",
          "469:           req.query[key.toLowerCase()] = req.query[key];",
          "470:         }",
          "471:         req.params.raw = true;",
          "472:         req.params.format = (req.query.format || 'image/png').split('/').pop();",
          "473:         const bbox = (req.query.bbox || '').split(',');",
          "474:         req.params.minx = bbox[0];",
          "475:         req.params.miny = bbox[1];",
          "476:         req.params.maxx = bbox[2];",
          "477:         req.params.maxy = bbox[3];",
          "478:         req.params.width = req.query.width || '256';",
          "479:         req.params.height = req.query.height || '256';",
          "480:         if (req.query.scale) {",
          "481:           req.params.width /= req.query.scale;",
          "482:           req.params.height /= req.query.scale;",
          "483:           req.params.scale = `@${req.query.scale}`;",
          "484:         }",
          "486:         return serveBounds(req, res, next);",
          "487:       });",
          "489:       const autoPattern = 'auto';",
          "491:       app.get(util.format(staticPattern, autoPattern), (req, res, next) => {",
          "492:         const item = repo[req.params.id];",
          "493:         if (!item) {",
          "494:           return res.sendStatus(404);",
          "495:         }",
          "496:         const raw = req.params.raw;",
          "497:         const w = req.params.width | 0,",
          "498:           h = req.params.height | 0,",
          "499:           bearing = 0,",
          "500:           pitch = 0,",
          "501:           scale = getScale(req.params.scale),",
          "502:           format = req.params.format;",
          "504:         const transformer = raw ?",
          "505:           mercator.inverse.bind(mercator) : item.dataProjWGStoInternalWGS;",
          "507:         const path = extractPathFromQuery(req.query, transformer);",
          "508:         if (path.length < 2) {",
          "509:           return res.status(400).send('Invalid path');",
          "510:         }",
          "512:         const bbox = [Infinity, Infinity, -Infinity, -Infinity];",
          "513:         for (const pair of path) {",
          "514:           bbox[0] = Math.min(bbox[0], pair[0]);",
          "515:           bbox[1] = Math.min(bbox[1], pair[1]);",
          "516:           bbox[2] = Math.max(bbox[2], pair[0]);",
          "517:           bbox[3] = Math.max(bbox[3], pair[1]);",
          "518:         }",
          "520:         const bbox_ = mercator.convert(bbox, '900913');",
          "521:         const center = mercator.inverse(",
          "522:           [(bbox_[0] + bbox_[2]) / 2, (bbox_[1] + bbox_[3]) / 2]",
          "523:         );",
          "525:         const z = calcZForBBox(bbox, w, h, req.query),",
          "526:           x = center[0],",
          "527:           y = center[1];",
          "529:         const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "530:           path, req.query);",
          "532:         return respondImage(item, z, x, y, bearing, pitch, w, h, scale, format,",
          "533:           res, next, overlay);",
          "534:       });",
          "535:     }",
          "537:     app.get('/:id.json', (req, res, next) => {",
          "538:       const item = repo[req.params.id];",
          "539:       if (!item) {",
          "540:         return res.sendStatus(404);",
          "542:       const info = clone(item.tileJSON);",
          "543:       info.tiles = utils.getTileUrls(req, info.tiles,",
          "544:         `styles/${req.params.id}`, info.format, item.publicUrl);",
          "545:       return res.send(info);",
          "546:     });",
          "548:     return Promise.all([fontListingPromise]).then(() => app);",
          "549:   },",
          "550:   add: (options, repo, params, id, publicUrl, dataResolver) => {",
          "551:     const map = {",
          "552:       renderers: [],",
          "553:       sources: {}",
          "554:     };",
          "556:     let styleJSON;",
          "557:     const createPool = (ratio, min, max) => {",
          "558:       const createRenderer = (ratio, createCallback) => {",
          "559:         const renderer = new mbgl.Map({",
          "560:           mode: \"tile\",",
          "561:           ratio: ratio,",
          "562:           request: (req, callback) => {",
          "563:             const protocol = req.url.split(':')[0];",
          "565:             if (protocol === 'sprites') {",
          "566:               const dir = options.paths[protocol];",
          "567:               const file = unescape(req.url).substring(protocol.length + 3);",
          "568:               fs.readFile(path.join(dir, file), (err, data) => {",
          "569:                 callback(err, { data: data });",
          "570:               });",
          "571:             } else if (protocol === 'fonts') {",
          "572:               const parts = req.url.split('/');",
          "573:               const fontstack = unescape(parts[2]);",
          "574:               const range = parts[3].split('.')[0];",
          "575:               utils.getFontsPbf(",
          "576:                 null, options.paths[protocol], fontstack, range, existingFonts",
          "577:               ).then(concated => {",
          "578:                 callback(null, { data: concated });",
          "579:               }, err => {",
          "580:                 callback(err, { data: null });",
          "581:               });",
          "582:             } else if (protocol === 'mbtiles') {",
          "583:               const parts = req.url.split('/');",
          "584:               const sourceId = parts[2];",
          "585:               const source = map.sources[sourceId];",
          "586:               const sourceInfo = styleJSON.sources[sourceId];",
          "587:               const z = parts[3] | 0,",
          "588:                 x = parts[4] | 0,",
          "589:                 y = parts[5].split('.')[0] | 0,",
          "590:                 format = parts[5].split('.')[1];",
          "591:               source.getTile(z, x, y, (err, data, headers) => {",
          "592:                 if (err) {",
          "593:                   if (options.verbose) console.log('MBTiles error, serving empty', err);",
          "594:                   createEmptyResponse(sourceInfo.format, sourceInfo.color, callback);",
          "595:                   return;",
          "596:                 }",
          "598:                 const response = {};",
          "599:                 if (headers['Last-Modified']) {",
          "600:                   response.modified = new Date(headers['Last-Modified']);",
          "601:                 }",
          "603:                 if (format === 'pbf') {",
          "604:                   try {",
          "605:                     response.data = zlib.unzipSync(data);",
          "606:                   } catch (err) {",
          "607:                     console.log(\"Skipping incorrect header for tile mbtiles://%s/%s/%s/%s.pbf\", id, z, x, y);",
          "608:                   }",
          "609:                   if (options.dataDecoratorFunc) {",
          "610:                     response.data = options.dataDecoratorFunc(",
          "611:                       sourceId, 'data', response.data, z, x, y);",
          "612:                   }",
          "613:                 } else {",
          "614:                   response.data = data;",
          "615:                 }",
          "617:                 callback(null, response);",
          "618:               });",
          "619:             } else if (protocol === 'http' || protocol === 'https') {",
          "620:               request({",
          "621:                 url: req.url,",
          "622:                 encoding: null,",
          "623:                 gzip: true",
          "624:               }, (err, res, body) => {",
          "625:                 const parts = url.parse(req.url);",
          "626:                 const extension = path.extname(parts.pathname).toLowerCase();",
          "627:                 const format = extensionToFormat[extension] || '';",
          "628:                 if (err || res.statusCode < 200 || res.statusCode >= 300) {",
          "630:                   createEmptyResponse(format, '', callback);",
          "631:                   return;",
          "632:                 }",
          "634:                 const response = {};",
          "635:                 if (res.headers.modified) {",
          "636:                   response.modified = new Date(res.headers.modified);",
          "637:                 }",
          "638:                 if (res.headers.expires) {",
          "639:                   response.expires = new Date(res.headers.expires);",
          "640:                 }",
          "641:                 if (res.headers.etag) {",
          "642:                   response.etag = res.headers.etag;",
          "643:                 }",
          "645:                 response.data = body;",
          "646:                 callback(null, response);",
          "647:               });",
          "648:             }",
          "649:           }",
          "650:         });",
          "651:         renderer.load(styleJSON);",
          "652:         createCallback(null, renderer);",
          "653:       };",
          "654:       return new advancedPool.Pool({",
          "655:         min: min,",
          "656:         max: max,",
          "657:         create: createRenderer.bind(null, ratio),",
          "658:         destroy: renderer => {",
          "659:           renderer.release();",
          "660:         }",
          "661:       });",
          "664:     const styleFile = params.style;",
          "665:     const styleJSONPath = path.resolve(options.paths.styles, styleFile);",
          "666:     styleJSON = clone(require(styleJSONPath));",
          "668:     if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "669:       styleJSON.sprite = 'sprites://' +",
          "670:         styleJSON.sprite",
          "671:           .replace('{style}', path.basename(styleFile, '.json'))",
          "672:           .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleJSONPath)));",
          "673:     }",
          "674:     if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "675:       styleJSON.glyphs = `fonts://${styleJSON.glyphs}`;",
          "676:     }",
          "678:     for (const layer of (styleJSON.layers || [])) {",
          "679:       if (layer && layer.paint) {",
          "681:         if (layer.paint['fill-extrusion-height']) {",
          "682:           layer.paint['fill-extrusion-height'] = 0;",
          "683:         }",
          "684:         if (layer.paint['fill-extrusion-base']) {",
          "685:           layer.paint['fill-extrusion-base'] = 0;",
          "686:         }",
          "688:     }",
          "690:     const tileJSON = {",
          "691:       'tilejson': '2.0.0',",
          "692:       'name': styleJSON.name,",
          "693:       'attribution': '',",
          "694:       'minzoom': 0,",
          "695:       'maxzoom': 20,",
          "696:       'bounds': [-180, -85.0511, 180, 85.0511],",
          "697:       'format': 'png',",
          "698:       'type': 'baselayer'",
          "699:     };",
          "700:     const attributionOverride = params.tilejson && params.tilejson.attribution;",
          "701:     Object.assign(tileJSON, params.tilejson || {});",
          "702:     tileJSON.tiles = params.domains || options.domains;",
          "703:     utils.fixTileJSONCenter(tileJSON);",
          "705:     repo[id] = {",
          "706:       tileJSON,",
          "707:       publicUrl,",
          "708:       map,",
          "709:       dataProjWGStoInternalWGS: null,",
          "710:       lastModified: new Date().toUTCString(),",
          "711:       watermark: params.watermark || options.watermark",
          "712:     };",
          "714:     const queue = [];",
          "715:     for (const name of Object.keys(styleJSON.sources)) {",
          "716:       let source = styleJSON.sources[name];",
          "717:       const url = source.url;",
          "719:       if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "721:         delete source.url;",
          "723:         let mbtilesFile = url.substring('mbtiles://'.length);",
          "724:         const fromData = mbtilesFile[0] === '{' &&",
          "725:           mbtilesFile[mbtilesFile.length - 1] === '}';",
          "727:         if (fromData) {",
          "728:           mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "729:           const mapsTo = (params.mapping || {})[mbtilesFile];",
          "730:           if (mapsTo) {",
          "731:             mbtilesFile = mapsTo;",
          "732:           }",
          "733:           mbtilesFile = dataResolver(mbtilesFile);",
          "734:           if (!mbtilesFile) {",
          "735:             console.error(`ERROR: data \"${mbtilesFile}\" not found!`);",
          "736:             process.exit(1);",
          "737:           }",
          "738:         }",
          "740:         queue.push(new Promise((resolve, reject) => {",
          "741:           mbtilesFile = path.resolve(options.paths.mbtiles, mbtilesFile);",
          "742:           const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "743:           if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "744:             throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "745:           }",
          "746:           map.sources[name] = new MBTiles(mbtilesFile, err => {",
          "747:             map.sources[name].getInfo((err, info) => {",
          "748:               if (err) {",
          "749:                 console.error(err);",
          "750:                 return;",
          "751:               }",
          "753:               if (!repo[id].dataProjWGStoInternalWGS && info.proj4) {",
          "755:                 const to3857 = proj4('EPSG:3857');",
          "756:                 const toDataProj = proj4(info.proj4);",
          "757:                 repo[id].dataProjWGStoInternalWGS = xy => to3857.inverse(toDataProj.forward(xy));",
          "758:               }",
          "760:               const type = source.type;",
          "761:               Object.assign(source, info);",
          "762:               source.type = type;",
          "763:               source.tiles = [",
          "765:                 `mbtiles://${name}/{z}/{x}/{y}.${info.format || 'pbf'}`",
          "766:               ];",
          "767:               delete source.scheme;",
          "769:               if (options.dataDecoratorFunc) {",
          "770:                 source = options.dataDecoratorFunc(name, 'tilejson', source);",
          "771:               }",
          "773:               if (!attributionOverride &&",
          "774:                 source.attribution && source.attribution.length > 0) {",
          "775:                 if (tileJSON.attribution.length > 0) {",
          "776:                   tileJSON.attribution += '; ';",
          "777:                 }",
          "778:                 tileJSON.attribution += source.attribution;",
          "779:               }",
          "780:               resolve();",
          "781:             });",
          "782:           });",
          "783:         }));",
          "784:       }",
          "785:     }",
          "787:     const renderersReadyPromise = Promise.all(queue).then(() => {",
          "789:       const minPoolSizes = options.minRendererPoolSizes || [8, 4, 2];",
          "790:       const maxPoolSizes = options.maxRendererPoolSizes || [16, 8, 4];",
          "791:       for (let s = 1; s <= maxScaleFactor; s++) {",
          "792:         const i = Math.min(minPoolSizes.length - 1, s - 1);",
          "793:         const j = Math.min(maxPoolSizes.length - 1, s - 1);",
          "794:         const minPoolSize = minPoolSizes[i];",
          "795:         const maxPoolSize = Math.max(minPoolSize, maxPoolSizes[j]);",
          "796:         map.renderers[s] = createPool(s, minPoolSize, maxPoolSize);",
          "797:       }",
          "800:     return Promise.all([renderersReadyPromise]);",
          "801:   }",
          "",
          "---------------"
        ],
        "src/serve_style.js||src/serve_style.js": [
          "File: src/serve_style.js -> src/serve_style.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: const utils = require('./utils');",
          "47:   }",
          "59:   }",
          "62:   }",
          "70:       }",
          "74:       }",
          "78:       }",
          "91:     }",
          "94:     }",
          "102:     }",
          "119: };",
          "",
          "[Removed Lines]",
          "11: module.exports = (options, repo, params, id, publicUrl, reportTiles, reportFont) => {",
          "12:   const app = express().disable('x-powered-by');",
          "14:   const styleFile = path.resolve(options.paths.styles, params.style);",
          "16:   const styleJSON = clone(require(styleFile));",
          "17:   for (const name of Object.keys(styleJSON.sources)) {",
          "18:     const source = styleJSON.sources[name];",
          "19:     const url = source.url;",
          "20:     if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "21:       let mbtilesFile = url.substring('mbtiles://'.length);",
          "22:       const fromData = mbtilesFile[0] === '{' &&",
          "23:         mbtilesFile[mbtilesFile.length - 1] === '}';",
          "25:       if (fromData) {",
          "26:         mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "27:         const mapsTo = (params.mapping || {})[mbtilesFile];",
          "28:         if (mapsTo) {",
          "29:           mbtilesFile = mapsTo;",
          "30:         }",
          "31:       }",
          "32:       const identifier = reportTiles(mbtilesFile, fromData);",
          "33:       source.url = `local://data/${identifier}.json`;",
          "34:     }",
          "35:   }",
          "37:   for(let obj of styleJSON.layers) {",
          "38:     if (obj['type'] === 'symbol') {",
          "39:       const fonts = (obj['layout'] || {})['text-font'];",
          "40:       if (fonts && fonts.length) {",
          "41:         fonts.forEach(reportFont);",
          "42:       } else {",
          "43:         reportFont('Open Sans Regular');",
          "44:         reportFont('Arial Unicode MS Regular');",
          "45:       }",
          "46:     }",
          "49:   let spritePath;",
          "51:   const httpTester = /^(http(s)?:)?\\/\\//;",
          "52:   if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "53:     spritePath = path.join(options.paths.sprites,",
          "54:         styleJSON.sprite",
          "55:             .replace('{style}', path.basename(styleFile, '.json'))",
          "56:             .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleFile)))",
          "57:             );",
          "58:     styleJSON.sprite = `local://styles/${id}/sprite`;",
          "60:   if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "61:     styleJSON.glyphs = 'local://fonts/{fontstack}/{range}.pbf';",
          "64:   repo[id] = styleJSON;",
          "66:   app.get(`/${id}/style.json`, (req, res, next) => {",
          "67:     const fixUrl = (url, opt_nokey) => {",
          "68:       if (!url || (typeof url !== 'string') || url.indexOf('local://') !== 0) {",
          "69:         return url;",
          "71:       const queryParams = [];",
          "72:       if (!opt_nokey && req.query.key) {",
          "73:         queryParams.unshift(`key=${req.query.key}`);",
          "75:       let query = '';",
          "76:       if (queryParams.length) {",
          "77:         query = `?${queryParams.join('&')}`;",
          "79:       return url.replace(",
          "80:         'local://', utils.getPublicUrl(publicUrl, req)) + query;",
          "81:     };",
          "83:     const styleJSON_ = clone(styleJSON);",
          "84:     for (const name of Object.keys(styleJSON_.sources)) {",
          "85:       const source = styleJSON_.sources[name];",
          "86:       source.url = fixUrl(source.url);",
          "87:     }",
          "89:     if (styleJSON_.sprite) {",
          "90:       styleJSON_.sprite = fixUrl(styleJSON_.sprite, true);",
          "92:     if (styleJSON_.glyphs) {",
          "93:       styleJSON_.glyphs = fixUrl(styleJSON_.glyphs, false);",
          "95:     return res.send(styleJSON_);",
          "96:   });",
          "98:   app.get(`/${id}/sprite:scale(@[23]x)?.:format([\\\\w]+)`,",
          "99:     (req, res, next) => {",
          "100:     if (!spritePath) {",
          "101:       return res.status(404).send('File not found');",
          "103:         const scale = req.params.scale,",
          "104:           format = req.params.format;",
          "105:         const filename = `${spritePath + (scale || '')}.${format}`;",
          "106:         return fs.readFile(filename, (err, data) => {",
          "107:       if (err) {",
          "108:         console.log('Sprite load error:', filename);",
          "109:         return res.status(404).send('File not found');",
          "110:       } else {",
          "111:         if (format === 'json') res.header('Content-type', 'application/json');",
          "112:         if (format === 'png') res.header('Content-type', 'image/png');",
          "113:         return res.send(data);",
          "114:       }",
          "115:     });",
          "116:   });",
          "118:   return Promise.resolve(app);",
          "",
          "[Added Lines]",
          "11: const httpTester = /^(http(s)?:)?\\/\\//;",
          "13: const fixUrl = (req, url, publicUrl, opt_nokey) => {",
          "14:   if (!url || (typeof url !== 'string') || url.indexOf('local://') !== 0) {",
          "15:     return url;",
          "17:   const queryParams = [];",
          "18:   if (!opt_nokey && req.query.key) {",
          "19:     queryParams.unshift(`key=${req.query.key}`);",
          "21:   let query = '';",
          "22:   if (queryParams.length) {",
          "23:     query = `?${queryParams.join('&')}`;",
          "25:   return url.replace(",
          "26:     'local://', utils.getPublicUrl(publicUrl, req)) + query;",
          "27: };",
          "29: module.exports = {",
          "30:   init: (options, repo) => {",
          "31:     const app = express().disable('x-powered-by');",
          "33:     app.get('/:id/style.json', (req, res, next) => {",
          "34:       const item = repo[req.params.id];",
          "35:       if (!item) {",
          "36:         return res.sendStatus(404);",
          "38:       const styleJSON_ = clone(item.styleJSON);",
          "39:       for (const name of Object.keys(styleJSON_.sources)) {",
          "40:         const source = styleJSON_.sources[name];",
          "41:         source.url = fixUrl(req, source.url, item.publicUrl);",
          "44:       if (styleJSON_.sprite) {",
          "45:         styleJSON_.sprite = fixUrl(req, styleJSON_.sprite, item.publicUrl, true);",
          "47:       if (styleJSON_.glyphs) {",
          "48:         styleJSON_.glyphs = fixUrl(req, styleJSON_.glyphs, item.publicUrl, false);",
          "49:       }",
          "50:       return res.send(styleJSON_);",
          "51:     });",
          "53:     app.get('/:id/sprite:scale(@[23]x)?.:format([\\\\w]+)', (req, res, next) => {",
          "54:       const item = repo[req.params.id];",
          "55:       if (!item || !item.spritePath) {",
          "56:         return res.sendStatus(404);",
          "57:       }",
          "58:       const scale = req.params.scale,",
          "59:         format = req.params.format;",
          "60:       const filename = `${item.spritePath + (scale || '')}.${format}`;",
          "61:       return fs.readFile(filename, (err, data) => {",
          "62:         if (err) {",
          "63:           console.log('Sprite load error:', filename);",
          "64:           return res.sendStatus(404);",
          "65:         } else {",
          "66:           if (format === 'json') res.header('Content-type', 'application/json');",
          "67:           if (format === 'png') res.header('Content-type', 'image/png');",
          "68:           return res.send(data);",
          "69:         }",
          "70:       });",
          "71:     });",
          "73:     return app;",
          "74:   },",
          "75:   add: (options, repo, params, id, publicUrl, reportTiles, reportFont) => {",
          "76:     const styleFile = path.resolve(options.paths.styles, params.style);",
          "78:     const styleJSON = clone(require(styleFile));",
          "79:     for (const name of Object.keys(styleJSON.sources)) {",
          "80:       const source = styleJSON.sources[name];",
          "81:       const url = source.url;",
          "82:       if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "83:         let mbtilesFile = url.substring('mbtiles://'.length);",
          "84:         const fromData = mbtilesFile[0] === '{' &&",
          "85:           mbtilesFile[mbtilesFile.length - 1] === '}';",
          "87:         if (fromData) {",
          "88:           mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "89:           const mapsTo = (params.mapping || {})[mbtilesFile];",
          "90:           if (mapsTo) {",
          "91:             mbtilesFile = mapsTo;",
          "92:           }",
          "93:         }",
          "94:         const identifier = reportTiles(mbtilesFile, fromData);",
          "95:         source.url = `local://data/${identifier}.json`;",
          "96:       }",
          "99:     for (let obj of styleJSON.layers) {",
          "100:       if (obj['type'] === 'symbol') {",
          "101:         const fonts = (obj['layout'] || {})['text-font'];",
          "102:         if (fonts && fonts.length) {",
          "103:           fonts.forEach(reportFont);",
          "104:         } else {",
          "105:           reportFont('Open Sans Regular');",
          "106:           reportFont('Arial Unicode MS Regular');",
          "107:         }",
          "108:       }",
          "111:     let spritePath;",
          "113:     if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "114:       spritePath = path.join(options.paths.sprites,",
          "115:         styleJSON.sprite",
          "116:           .replace('{style}', path.basename(styleFile, '.json'))",
          "117:           .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleFile)))",
          "118:       );",
          "119:       styleJSON.sprite = `local://styles/${id}/sprite`;",
          "120:     }",
          "121:     if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "122:       styleJSON.glyphs = 'local://fonts/{fontstack}/{range}.pbf';",
          "125:     repo[id] = {",
          "126:       styleJSON,",
          "127:       spritePath,",
          "128:       publicUrl,",
          "129:       name: styleJSON.name",
          "130:     };",
          "131:   }",
          "",
          "---------------"
        ],
        "src/server.js||src/server.js": [
          "File: src/server.js -> src/server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:     app.use(cors());",
          "104:   }",
          "106:   for (const id of Object.keys(config.styles || {})) {",
          "107:     const item = config.styles[id];",
          "108:     if (!item.style || item.style.length === 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   app.use('/data/', serve_data.init(options, serving.data));",
          "107:   app.use('/styles/', serve_style.init(options, serving.styles));",
          "108:   if (serve_rendered) {",
          "109:     startupPromises.push(",
          "110:       serve_rendered.init(options, serving.rendered)",
          "111:         .then(sub => {",
          "112:           app.use('/styles/', sub);",
          "113:         })",
          "114:     );",
          "115:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     }",
          "113:     if (item.serve_data !== false) {",
          "115:         (mbtiles, fromData) => {",
          "116:           let dataItemId;",
          "117:           for (const id of Object.keys(data)) {",
          "",
          "[Removed Lines]",
          "114:       startupPromises.push(serve_style(options, serving.styles, item, id, opts.publicUrl,",
          "",
          "[Added Lines]",
          "125:       serve_style.add(options, serving.styles, item, id, opts.publicUrl,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "140:           }",
          "141:         }, font => {",
          "142:           serving.fonts[font] = true;",
          "146:     }",
          "147:     if (item.serve_rendered !== false) {",
          "148:       if (serve_rendered) {",
          "157:               }",
          "159:             }",
          "164:       } else {",
          "165:         item.serve_rendered = false;",
          "166:       }",
          "",
          "[Removed Lines]",
          "143:         }).then(sub => {",
          "144:           app.use('/styles/', sub);",
          "145:         }));",
          "149:         startupPromises.push(",
          "150:           serve_rendered(options, serving.rendered, item, id, opts.publicUrl,",
          "151:             mbtiles => {",
          "152:               let mbtilesFile;",
          "153:               for (const id of Object.keys(data)) {",
          "154:                 if (id === mbtiles) {",
          "155:                   mbtilesFile = data[id].mbtiles;",
          "156:                 }",
          "158:               return mbtilesFile;",
          "160:           ).then(sub => {",
          "161:             app.use('/styles/', sub);",
          "162:           })",
          "163:         );",
          "",
          "[Added Lines]",
          "154:         });",
          "158:         startupPromises.push(serve_rendered.add(options, serving.rendered, item, id, opts.publicUrl,",
          "159:           mbtiles => {",
          "160:             let mbtilesFile;",
          "161:             for (const id of Object.keys(data)) {",
          "162:               if (id === mbtiles) {",
          "163:                 mbtilesFile = data[id].mbtiles;",
          "166:             return mbtilesFile;",
          "167:           }",
          "168:         ));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "181:     }",
          "183:     startupPromises.push(",
          "187:     );",
          "188:   }",
          "",
          "[Removed Lines]",
          "184:       serve_data(options, serving.data, item, id, serving.styles, opts.publicUrl).then(sub => {",
          "185:         app.use('/data/', sub);",
          "186:       })",
          "",
          "[Added Lines]",
          "189:       serve_data.add(options, serving.data, item, id, opts.publicUrl)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "191:     const result = [];",
          "192:     const query = req.query.key ? (`?key=${req.query.key}`) : '';",
          "193:     for (const id of Object.keys(serving.styles)) {",
          "195:       result.push({",
          "196:         version: styleJSON.version,",
          "197:         name: styleJSON.name,",
          "",
          "[Removed Lines]",
          "194:       const styleJSON = serving.styles[id];",
          "",
          "[Added Lines]",
          "197:       const styleJSON = serving.styles[id].styleJSON;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "205:   const addTileJSONs = (arr, req, type) => {",
          "206:     for (const id of Object.keys(serving[type])) {",
          "208:       let path = '';",
          "209:       if (type === 'rendered') {",
          "210:         path = `styles/${id}`;",
          "211:       } else {",
          "212:         path = `${type}/${id}`;",
          "",
          "[Removed Lines]",
          "207:       const info = clone(serving[type][id]);",
          "",
          "[Added Lines]",
          "210:       let info = clone(serving[type][id]);",
          "213:         info = info.tileJSON;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "283:       style.serving_data = serving.styles[id];",
          "284:       style.serving_rendered = serving.rendered[id];",
          "285:       if (style.serving_rendered) {",
          "287:         if (center) {",
          "288:           style.viewer_hash = `#${center[2]}/${center[1].toFixed(5)}/${center[0].toFixed(5)}`;",
          "",
          "[Removed Lines]",
          "286:         const center = style.serving_rendered.center;",
          "",
          "[Added Lines]",
          "290:         const center = style.serving_rendered.tileJSON.center;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "292:         }",
          "294:         style.xyz_link = utils.getTileUrls(",
          "297:       }",
          "298:     }",
          "299:     const data = clone(serving.data || {});",
          "",
          "[Removed Lines]",
          "295:           req, style.serving_rendered.tiles,",
          "296:           `styles/${id}`, style.serving_rendered.format, opts.publicUrl)[0];",
          "",
          "[Added Lines]",
          "299:           req, style.serving_rendered.tileJSON.tiles,",
          "300:           `styles/${id}`, style.serving_rendered.tileJSON.format, opts.publicUrl)[0];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f8be27844e23a3dd42d717c51277d71ecd85f4a",
      "candidate_info": {
        "commit_hash": "7f8be27844e23a3dd42d717c51277d71ecd85f4a",
        "repo": "maptiler/tileserver-gl",
        "commit_url": "https://github.com/maptiler/tileserver-gl/commit/7f8be27844e23a3dd42d717c51277d71ecd85f4a",
        "files": [
          "src/main.js",
          "src/serve_data.js",
          "src/serve_font.js",
          "src/serve_rendered.js",
          "src/serve_style.js",
          "src/server.js",
          "src/utils.js"
        ],
        "message": "Update code to ES6\n\n* var  ->  let / const\n* [].forEach  ->  for (... of ...)\n* '...' + var  ->  template strings  `...${var}`\n* function  ->  arrow functions `=>`\n* use === and !==  instead of == and !=",
        "before_after_code_files": [
          "src/main.js||src/main.js",
          "src/serve_data.js||src/serve_data.js",
          "src/serve_font.js||src/serve_font.js",
          "src/serve_rendered.js||src/serve_rendered.js",
          "src/serve_style.js||src/serve_style.js",
          "src/server.js||src/server.js",
          "src/utils.js||src/utils.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/serve_style.js||src/serve_style.js",
            "src/server.js||src/server.js",
            "src/utils.js||src/utils.js"
          ],
          "candidate": [
            "src/serve_style.js||src/serve_style.js",
            "src/server.js||src/server.js",
            "src/utils.js||src/utils.js"
          ]
        }
      },
      "candidate_diff": {
        "src/main.js||src/main.js": [
          "File: src/main.js -> src/main.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: 'use strict';",
          "15:   args.splice(2, 0, '--mbtiles');",
          "16: }",
          "19:   .description('tileserver-gl startup options')",
          "20:   .usage('tileserver-gl [mbtiles] [options]')",
          "21:   .option(",
          "",
          "[Removed Lines]",
          "5: var fs = require('fs'),",
          "6:     path = require('path'),",
          "7:     request = require('request');",
          "9: var mbtiles = require('@mapbox/mbtiles');",
          "11: var packageJson = require('../package');",
          "13: var args = process.argv;",
          "14: if (args.length >= 3 && args[2][0] != '-') {",
          "18: var opts = require('commander')",
          "",
          "[Added Lines]",
          "5: const fs = require('fs');",
          "6: const path = require('path');",
          "7: const request = require('request');",
          "9: const MBTiles = require('@mapbox/mbtiles');",
          "11: const packageJson = require('../package');",
          "13: const args = process.argv;",
          "14: if (args.length >= 3 && args[2][0] !== '-') {",
          "18: const opts = require('commander')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:   )",
          "69:   .parse(args);",
          "75:   if (publicUrl && publicUrl.lastIndexOf('/') !== publicUrl.length - 1) {",
          "76:     publicUrl += '/';",
          "77:   }",
          "",
          "[Removed Lines]",
          "71: console.log('Starting ' + packageJson.name + ' v' + packageJson.version);",
          "73: var startServer = function(configPath, config) {",
          "74:   var publicUrl = opts.public_url;",
          "",
          "[Added Lines]",
          "71: console.log(`Starting ${packageJson.name} v${packageJson.version}`);",
          "73: const startServer = (configPath, config) => {",
          "74:   let publicUrl = opts.public_url;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:   });",
          "90: };",
          "95:   mbtilesFile = path.resolve(process.cwd(), mbtilesFile);",
          "98:   if (!mbtilesStats.isFile() || mbtilesStats.size === 0) {",
          "100:     process.exit(1);",
          "101:   }",
          "104:       if (err || !info) {",
          "105:         console.log('ERROR: Metadata missing in the MBTiles.');",
          "108:         process.exit(1);",
          "109:       }",
          "115:         \"options\": {",
          "116:           \"paths\": {",
          "117:             \"root\": styleDir,",
          "",
          "[Removed Lines]",
          "92: var startWithMBTiles = function(mbtilesFile) {",
          "93:   console.log('Automatically creating config file for ' + mbtilesFile);",
          "97:   var mbtilesStats = fs.statSync(mbtilesFile);",
          "99:     console.log('ERROR: Not valid MBTiles file: ' + mbtilesFile);",
          "102:   var instance = new mbtiles(mbtilesFile, function(err) {",
          "103:     instance.getInfo(function(err, info) {",
          "106:         console.log('       Make sure ' + path.basename(mbtilesFile) +",
          "107:                     ' is valid MBTiles.');",
          "110:       var bounds = info.bounds;",
          "112:       var styleDir = path.resolve(__dirname, \"../node_modules/tileserver-gl-styles/\");",
          "114:       var config = {",
          "",
          "[Added Lines]",
          "92: const startWithMBTiles = (mbtilesFile) => {",
          "93:   console.log(`Automatically creating config file for ${mbtilesFile}`);",
          "97:   const mbtilesStats = fs.statSync(mbtilesFile);",
          "99:     console.log(`ERROR: Not valid MBTiles file: ${mbtilesFile}`);",
          "102:   const instance = new MBTiles(mbtilesFile, (err) => {",
          "103:     if (err) {",
          "104:       console.log('ERROR: Unable to open MBTiles.');",
          "105:       console.log(`       Make sure ${path.basename(mbtilesFile)} is valid MBTiles.`);",
          "106:       process.exit(1);",
          "107:     }",
          "109:     instance.getInfo((err, info) => {",
          "112:         console.log(`       Make sure ${path.basename(mbtilesFile)} is valid MBTiles.`);",
          "115:       const bounds = info.bounds;",
          "117:       const styleDir = path.resolve(__dirname, \"../node_modules/tileserver-gl-styles/\");",
          "119:       const config = {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "124:         \"data\": {}",
          "125:       };",
          "132:           \"mbtiles\": path.basename(mbtilesFile)",
          "133:         };",
          "141:           if (fs.existsSync(styleFile)) {",
          "144:               ((styleJSON || {}).metadata || {})['openmaptiles:version'] || 'x';",
          "154:                     )",
          "155:                   )",
          "156:                 )",
          "",
          "[Removed Lines]",
          "127:       if (info.format == 'pbf' &&",
          "128:           info.name.toLowerCase().indexOf('openmaptiles') > -1) {",
          "129:         var omtV = (info.version || '').split('.');",
          "131:         config['data']['v' + omtV[0]] = {",
          "136:         var styles = fs.readdirSync(path.resolve(styleDir, 'styles'));",
          "137:         for (var i = 0; i < styles.length; i++) {",
          "138:           var styleName = styles[i];",
          "139:           var styleFileRel = styleName + '/style.json';",
          "140:           var styleFile = path.resolve(styleDir, 'styles', styleFileRel);",
          "142:             var styleJSON = require(styleFile);",
          "143:             var omtVersionCompatibility =",
          "145:             var m = omtVersionCompatibility.toLowerCase().split('.');",
          "147:             var isCompatible = !(",
          "148:               m[0] != 'x' && (",
          "149:                 m[0] != omtV[0] || (",
          "150:                   (m[1] || 'x') != 'x' && (",
          "151:                     m[1] != omtV[1] || (",
          "152:                       (m[2] || 'x') != 'x' &&",
          "153:                       m[2] != omtV[2]",
          "",
          "[Added Lines]",
          "132:       if (info.format === 'pbf' &&",
          "133:         info.name.toLowerCase().indexOf('openmaptiles') > -1) {",
          "134:         const omtV = (info.version || '').split('.');",
          "136:         config['data'][`v${omtV[0]}`] = {",
          "141:         const styles = fs.readdirSync(path.resolve(styleDir, 'styles'));",
          "142:         for (let styleName of styles) {",
          "143:           const styleFileRel = styleName + '/style.json';",
          "144:           const styleFile = path.resolve(styleDir, 'styles', styleFileRel);",
          "146:             const styleJSON = require(styleFile);",
          "147:             const omtVersionCompatibility =",
          "149:             const m = omtVersionCompatibility.toLowerCase().split('.');",
          "151:             const isCompatible = !(",
          "152:               m[0] !== 'x' && (",
          "153:                 m[0] !== omtV[0] || (",
          "154:                   (m[1] || 'x') !== 'x' && (",
          "155:                     m[1] !== omtV[1] || (",
          "156:                       (m[2] || 'x') !== 'x' &&",
          "157:                       m[2] !== omtV[2]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "158:             );",
          "160:             if (isCompatible) {",
          "162:                 \"style\": styleFileRel,",
          "163:                 \"tilejson\": {",
          "164:                   \"bounds\": bounds",
          "165:                 }",
          "166:               };",
          "168:             } else {",
          "171:             }",
          "172:           }",
          "173:         }",
          "174:       } else {",
          "177:         config['data'][(info.id || 'mbtiles')",
          "178:                            .replace(/\\//g, '_')",
          "180:                            .replace(/\\?/g, '_')] = {",
          "181:           \"mbtiles\": path.basename(mbtilesFile)",
          "182:         };",
          "",
          "[Removed Lines]",
          "161:               var styleObject = {",
          "167:               config['styles'][styleName] = styleObject;",
          "169:               console.log('Style', styleName, 'requires OpenMapTiles version',",
          "170:               omtVersionCompatibility, 'but mbtiles is version', info.version);",
          "175:         console.log('WARN: MBTiles not in \"openmaptiles\" format. ' +",
          "176:                     'Serving raw data only...');",
          "179:                            .replace(/\\:/g, '_')",
          "",
          "[Added Lines]",
          "165:               config['styles'][styleName] = {",
          "172:               console.log(`Style ${styleName} requires OpenMapTiles version ${omtVersionCompatibility} but mbtiles is version ${info.version}`);",
          "177:         console.log(`WARN: MBTiles not in \"openmaptiles\" format. Serving raw data only...`);",
          "180:                            .replace(/:/g, '_')",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "193:   });",
          "194: };",
          "197:   if (err || !stats.isFile() || stats.size === 0) {",
          "199:     if (!mbtiles) {",
          "204:         if (filename.endsWith('.mbtiles')) {",
          "206:           if (mbTilesStats.isFile() && mbTilesStats.size > 0) {",
          "207:             mbtiles = filename;",
          "208:             break;",
          "",
          "[Removed Lines]",
          "196: fs.stat(path.resolve(opts.config), function(err, stats) {",
          "198:     var mbtiles = opts.mbtiles;",
          "201:       var files = fs.readdirSync(process.cwd());",
          "202:       for (var i=0; i < files.length; i++) {",
          "203:         var filename = files[i];",
          "205:           var mbTilesStats = fs.statSync(filename);",
          "",
          "[Added Lines]",
          "197: fs.stat(path.resolve(opts.config), (err, stats) => {",
          "199:     let mbtiles = opts.mbtiles;",
          "202:       const files = fs.readdirSync(process.cwd());",
          "203:       for (let filename of files) {",
          "205:           const mbTilesStats = fs.statSync(filename);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "210:         }",
          "211:       }",
          "212:       if (mbtiles) {",
          "214:         return startWithMBTiles(mbtiles);",
          "215:       } else {",
          "223:         return request.get(url).pipe(stream);",
          "224:       }",
          "225:     }",
          "",
          "[Removed Lines]",
          "213:         console.log('No MBTiles specified, using ' + mbtiles);",
          "216:         var url = 'https://github.com/klokantech/tileserver-gl/releases/download/v1.3.0/zurich_switzerland.mbtiles';",
          "217:         var filename = 'zurich_switzerland.mbtiles';",
          "218:         var stream = fs.createWriteStream(filename);",
          "219:         console.log('Downloading sample data (' + filename + ') from ' + url);",
          "220:         stream.on('finish', function() {",
          "221:           return startWithMBTiles(filename);",
          "222:         });",
          "",
          "[Added Lines]",
          "213:         console.log(`No MBTiles specified, using ${mbtiles}`);",
          "216:         const url = 'https://github.com/klokantech/tileserver-gl/releases/download/v1.3.0/zurich_switzerland.mbtiles';",
          "217:         const filename = 'zurich_switzerland.mbtiles';",
          "218:         const stream = fs.createWriteStream(filename);",
          "219:         console.log(`Downloading sample data (${filename}) from ${url}`);",
          "220:         stream.on('finish', () => startWithMBTiles(filename));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "227:       return startWithMBTiles(mbtiles);",
          "228:     }",
          "229:   } else {",
          "231:     return startServer(opts.config, null);",
          "232:   }",
          "233: });",
          "",
          "[Removed Lines]",
          "230:     console.log('Using specified config file from ' + opts.config);",
          "",
          "[Added Lines]",
          "228:     console.log(`Using specified config file from ${opts.config}`);",
          "",
          "---------------"
        ],
        "src/serve_data.js||src/serve_data.js": [
          "File: src/serve_data.js -> src/serve_data.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: 'use strict';",
          "14: try {",
          "15:   tileshrinkGl = require('tileshrink-gl');",
          "16:   global.addStyleParam = true;",
          "17: } catch (e) {}",
          "26:     'tiles': params.domains || options.domains",
          "27:   };",
          "31:   repo[id] = tileJSON;",
          "36:   }",
          "40:       if (err) {",
          "41:         reject(err);",
          "42:         return;",
          "43:       }",
          "45:         if (err) {",
          "46:           reject(err);",
          "47:           return;",
          "",
          "[Removed Lines]",
          "3: var fs = require('fs'),",
          "4:     path = require('path'),",
          "5:     zlib = require('zlib');",
          "7: var clone = require('clone'),",
          "8:     express = require('express'),",
          "9:     mbtiles = require('@mapbox/mbtiles'),",
          "10:     pbf = require('pbf'),",
          "11:     VectorTile = require('@mapbox/vector-tile').VectorTile;",
          "13: var tileshrinkGl;",
          "19: var utils = require('./utils');",
          "21: module.exports = function(options, repo, params, id, styles, publicUrl) {",
          "22:   var app = express().disable('x-powered-by');",
          "24:   var mbtilesFile = path.resolve(options.paths.mbtiles, params.mbtiles);",
          "25:   var tileJSON = {",
          "29:   var shrinkers = {};",
          "33:   var mbtilesFileStats = fs.statSync(mbtilesFile);",
          "34:   if (!mbtilesFileStats.isFile() || mbtilesFileStats.size == 0) {",
          "35:     throw Error('Not valid MBTiles file: ' + mbtilesFile);",
          "37:   var source;",
          "38:   var sourceInfoPromise = new Promise(function(resolve, reject) {",
          "39:     source = new mbtiles(mbtilesFile, function(err) {",
          "44:       source.getInfo(function(err, info) {",
          "",
          "[Added Lines]",
          "3: const fs = require('fs');",
          "4: const path = require('path');",
          "5: const zlib = require('zlib');",
          "7: const clone = require('clone');",
          "8: const express = require('express');",
          "9: const MBTiles = require('@mapbox/mbtiles');",
          "10: const Pbf = require('pbf');",
          "11: const VectorTile = require('@mapbox/vector-tile').VectorTile;",
          "13: let tileshrinkGl;",
          "19: const utils = require('./utils');",
          "21: module.exports = (options, repo, params, id, styles, publicUrl) => {",
          "22:   const app = express().disable('x-powered-by');",
          "24:   const mbtilesFile = path.resolve(options.paths.mbtiles, params.mbtiles);",
          "25:   let tileJSON = {",
          "29:   const shrinkers = {};",
          "33:   const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "34:   if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "35:     throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "37:   let source;",
          "38:   const sourceInfoPromise = new Promise((resolve, reject) => {",
          "39:     source = new MBTiles(mbtilesFile, err => {",
          "44:       source.getInfo((err, info) => {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:     });",
          "68:   });",
          "78:       format = 'pbf';",
          "79:     }",
          "82:       return res.status(404).send('Invalid format');",
          "83:     }",
          "84:     if (z < tileJSON.minzoom || 0 || x < 0 || y < 0 ||",
          "",
          "[Removed Lines]",
          "70:   var tilePattern = '/' + id + '/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format([\\\\w.]+)';",
          "72:   app.get(tilePattern, function(req, res, next) {",
          "73:     var z = req.params.z | 0,",
          "74:         x = req.params.x | 0,",
          "75:         y = req.params.y | 0;",
          "76:     var format = req.params.format;",
          "77:     if (format == options.pbfAlias) {",
          "80:     if (format != tileJSON.format &&",
          "81:         !(format == 'geojson' && tileJSON.format == 'pbf')) {",
          "",
          "[Added Lines]",
          "70:   const tilePattern = `/${id}/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+).:format([\\\\w.]+)`;",
          "72:   app.get(tilePattern, (req, res, next) => {",
          "73:     const z = req.params.z | 0;",
          "74:     const x = req.params.x | 0;",
          "75:     const y = req.params.y | 0;",
          "76:     let format = req.params.format;",
          "77:     if (format === options.pbfAlias) {",
          "80:     if (format !== tileJSON.format &&",
          "81:         !(format === 'geojson' && tileJSON.format === 'pbf')) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "86:         x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "87:       return res.status(404).send('Out of bounds');",
          "88:     }",
          "90:       if (err) {",
          "91:         if (/does not exist/.test(err.message)) {",
          "92:           return res.status(204).send();",
          "",
          "[Removed Lines]",
          "89:     source.getTile(z, x, y, function(err, data, headers) {",
          "",
          "[Added Lines]",
          "89:     source.getTile(z, x, y, (err, data, headers) => {",
          "90:       let isGzipped;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "97:         if (data == null) {",
          "98:           return res.status(404).send('Not found');",
          "99:         } else {",
          "104:             if (style && tileshrinkGl) {",
          "105:               if (!shrinkers[style]) {",
          "107:                 if (styleJSON) {",
          "111:                     if (source &&",
          "114:                       sourceName = sourceName_;",
          "115:                     }",
          "116:                   }",
          "",
          "[Removed Lines]",
          "100:           if (tileJSON['format'] == 'pbf') {",
          "101:             var isGzipped = data.slice(0,2).indexOf(",
          "102:                 new Buffer([0x1f, 0x8b])) === 0;",
          "103:             var style = req.query.style;",
          "106:                 var styleJSON = styles[style];",
          "108:                   var sourceName = null;",
          "109:                   for (var sourceName_ in styleJSON.sources) {",
          "110:                     var source = styleJSON.sources[sourceName_];",
          "112:                         source.type == 'vector' &&",
          "113:                         source.url.endsWith('/' + id + '.json')) {",
          "",
          "[Added Lines]",
          "101:           if (tileJSON['format'] === 'pbf') {",
          "102:             isGzipped = data.slice(0, 2).indexOf(",
          "103:               new Buffer([0x1f, 0x8b])) === 0;",
          "104:             const style = req.query.style;",
          "107:                 const styleJSON = styles[style];",
          "109:                   let sourceName = null;",
          "110:                   for (let sourceName_ in styleJSON.sources) {",
          "111:                     const source = styleJSON.sources[sourceName_];",
          "113:                         source.type === 'vector' &&",
          "114:                         source.url.endsWith(`/${id}.json`)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "134:               data = options.dataDecoratorFunc(id, 'data', data, z, x, y);",
          "135:             }",
          "136:           }",
          "138:             headers['Content-Type'] = 'application/x-protobuf';",
          "140:             headers['Content-Type'] = 'application/json';",
          "142:             if (isGzipped) {",
          "",
          "[Removed Lines]",
          "137:           if (format == 'pbf') {",
          "139:           } else if (format == 'geojson') {",
          "",
          "[Added Lines]",
          "138:           if (format === 'pbf') {",
          "140:           } else if (format === 'geojson') {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "144:               isGzipped = false;",
          "145:             }",
          "149:               \"type\": \"FeatureCollection\",",
          "150:               \"features\": []",
          "151:             };",
          "157:                 featureGeoJSON.properties.layer = layerName;",
          "158:                 geojson.features.push(featureGeoJSON);",
          "159:               }",
          "",
          "[Removed Lines]",
          "147:             var tile = new VectorTile(new pbf(data));",
          "148:             var geojson = {",
          "152:             for (var layerName in tile.layers) {",
          "153:               var layer = tile.layers[layerName];",
          "154:               for (var i = 0; i < layer.length; i++) {",
          "155:                 var feature = layer.feature(i);",
          "156:                 var featureGeoJSON = feature.toGeoJSON(x, y, z);",
          "",
          "[Added Lines]",
          "148:             const tile = new VectorTile(new Pbf(data));",
          "149:             const geojson = {",
          "153:             for (let layerName in tile.layers) {",
          "154:               const layer = tile.layers[layerName];",
          "155:               for (let i = 0; i < layer.length; i++) {",
          "156:                 const feature = layer.feature(i);",
          "157:                 const featureGeoJSON = feature.toGeoJSON(x, y, z);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "175:     });",
          "176:   });",
          "180:     info.tiles = utils.getTileUrls(req, info.tiles,",
          "182:                                      'pbf': options.pbfAlias",
          "183:                                    });",
          "184:     return res.send(info);",
          "185:   });",
          "190: };",
          "",
          "[Removed Lines]",
          "178:   app.get('/' + id + '.json', function(req, res, next) {",
          "179:     var info = clone(tileJSON);",
          "181:                                    'data/' + id, info.format, publicUrl, {",
          "187:   return sourceInfoPromise.then(function() {",
          "188:     return app;",
          "189:   });",
          "",
          "[Added Lines]",
          "179:   app.get(`/${id}.json`, (req, res, next) => {",
          "180:     const info = clone(tileJSON);",
          "182:                                    `data/${id}`, info.format, publicUrl, {",
          "188:   return sourceInfoPromise.then(() => app);",
          "",
          "---------------"
        ],
        "src/serve_font.js||src/serve_font.js": [
          "File: src/serve_font.js -> src/serve_font.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: 'use strict';",
          "20:       if (err) {",
          "21:         reject(err);",
          "22:         return;",
          "23:       }",
          "26:           if (err) {",
          "27:             reject(err);",
          "28:             return;",
          "29:           }",
          "30:           if (stats.isDirectory() &&",
          "32:             existingFonts[path.basename(file)] = true;",
          "33:           }",
          "34:         });",
          "36:       resolve();",
          "37:     });",
          "38:   });",
          "45:     utils.getFontsPbf(options.serveAllFonts ? null : allowedFonts,",
          "47:         res.header('Content-type', 'application/x-protobuf');",
          "48:         res.header('Last-Modified', lastModified);",
          "49:         return res.send(concated);",
          "53:     );",
          "54:   });",
          "57:     res.header('Content-type', 'application/json');",
          "58:     return res.send(",
          "59:       Object.keys(options.serveAllFonts ? existingFonts : allowedFonts).sort()",
          "60:     );",
          "61:   });",
          "66: };",
          "",
          "[Removed Lines]",
          "3: var clone = require('clone'),",
          "4:     express = require('express'),",
          "5:     fs = require('fs'),",
          "6:     path = require('path');",
          "8: var utils = require('./utils');",
          "10: module.exports = function(options, allowedFonts) {",
          "11:   var app = express().disable('x-powered-by');",
          "13:   var lastModified = new Date().toUTCString();",
          "15:   var fontPath = options.paths.fonts;",
          "17:   var existingFonts = {};",
          "18:   var fontListingPromise = new Promise(function(resolve, reject) {",
          "19:     fs.readdir(options.paths.fonts, function(err, files) {",
          "24:       files.forEach(function(file) {",
          "25:         fs.stat(path.join(fontPath, file), function(err, stats) {",
          "31:               fs.existsSync(path.join(fontPath, file, '0-255.pbf'))) {",
          "35:       });",
          "40:   app.get('/fonts/:fontstack/:range([\\\\d]+-[\\\\d]+).pbf',",
          "41:       function(req, res, next) {",
          "42:     var fontstack = decodeURI(req.params.fontstack);",
          "43:     var range = req.params.range;",
          "46:       fontPath, fontstack, range, existingFonts).then(function(concated) {",
          "50:       }, function(err) {",
          "51:         return res.status(400).send(err);",
          "52:       }",
          "56:   app.get('/fonts.json', function(req, res, next) {",
          "63:   return fontListingPromise.then(function() {",
          "64:     return app;",
          "65:   });",
          "",
          "[Added Lines]",
          "3: const clone = require('clone');",
          "4: const express = require('express');",
          "5: const fs = require('fs');",
          "6: const path = require('path');",
          "8: const utils = require('./utils');",
          "10: module.exports = (options, allowedFonts) => {",
          "11:   const app = express().disable('x-powered-by');",
          "13:   const lastModified = new Date().toUTCString();",
          "15:   const fontPath = options.paths.fonts;",
          "17:   const existingFonts = {};",
          "18:   const fontListingPromise = new Promise((resolve, reject) => {",
          "19:     fs.readdir(options.paths.fonts, (err, files) => {",
          "24:       for (const file of files) {",
          "25:         fs.stat(path.join(fontPath, file), (err, stats) => {",
          "31:             fs.existsSync(path.join(fontPath, file, '0-255.pbf'))) {",
          "35:       }",
          "40:   app.get('/fonts/:fontstack/:range([\\\\d]+-[\\\\d]+).pbf', (req, res, next) => {",
          "41:     const fontstack = decodeURI(req.params.fontstack);",
          "42:     const range = req.params.range;",
          "45:       fontPath, fontstack, range, existingFonts).then(concated => {",
          "49:       }, err => res.status(400).send(err)",
          "53:   app.get('/fonts.json', (req, res, next) => {",
          "60:   return fontListingPromise.then(() => app);",
          "",
          "---------------"
        ],
        "src/serve_rendered.js||src/serve_rendered.js": [
          "File: src/serve_rendered.js -> src/serve_rendered.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: 'use strict';",
          "14: const { createCanvas } = require('canvas');",
          "35:     console.log('mbgl:', e);",
          "36:   }",
          "37: });",
          "",
          "[Removed Lines]",
          "3: var advancedPool = require('advanced-pool'),",
          "4:     fs = require('fs'),",
          "5:     path = require('path'),",
          "6:     url = require('url'),",
          "7:     util = require('util'),",
          "8:     zlib = require('zlib');",
          "12: var sharp = require('sharp');",
          "16: var clone = require('clone'),",
          "17:     Color = require('color'),",
          "18:     express = require('express'),",
          "19:     mercator = new (require('@mapbox/sphericalmercator'))(),",
          "20:     mbgl = require('@mapbox/mapbox-gl-native'),",
          "21:     mbtiles = require('@mapbox/mbtiles'),",
          "22:     proj4 = require('proj4'),",
          "23:     request = require('request');",
          "25: var utils = require('./utils');",
          "27: var FLOAT_PATTERN = '[+-]?(?:\\\\d+|\\\\d+\\.?\\\\d+)';",
          "29: var getScale = function(scale) {",
          "30:   return (scale || '@1x').slice(1, 2) | 0;",
          "31: };",
          "33: mbgl.on('message', function(e) {",
          "34:   if (e.severity == 'WARNING' || e.severity == 'ERROR') {",
          "",
          "[Added Lines]",
          "3: const advancedPool = require('advanced-pool');",
          "4: const fs = require('fs');",
          "5: const path = require('path');",
          "6: const url = require('url');",
          "7: const util = require('util');",
          "8: const zlib = require('zlib');",
          "12: const sharp = require('sharp');",
          "16: const clone = require('clone');",
          "17: const Color = require('color');",
          "18: const express = require('express');",
          "19: const mercator = new (require('@mapbox/sphericalmercator'))();",
          "20: const mbgl = require('@mapbox/mapbox-gl-native');",
          "21: const MBTiles = require('@mapbox/mbtiles');",
          "22: const proj4 = require('proj4');",
          "23: const request = require('request');",
          "25: const utils = require('./utils');",
          "27: const FLOAT_PATTERN = '[+-]?(?:\\\\d+|\\\\d+\\.?\\\\d+)';",
          "29: const getScale = scale => (scale || '@1x').slice(1, 2) | 0;",
          "31: mbgl.on('message', e => {",
          "32:   if (e.severity === 'WARNING' || e.severity === 'ERROR') {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:   '.jpg': 'jpeg',",
          "44:   '.jpeg': 'jpeg',",
          "45:   '.png': 'png',",
          "",
          "[Removed Lines]",
          "42: var extensionToFormat = {",
          "",
          "[Added Lines]",
          "40: const extensionToFormat = {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:   '': new Buffer(0)",
          "55: };",
          "",
          "[Removed Lines]",
          "53: var cachedEmptyResponses = {",
          "",
          "[Added Lines]",
          "51: const cachedEmptyResponses = {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:     color = 'rgba(255,255,255,0)';",
          "74:   }",
          "78:   if (data) {",
          "79:     callback(null, {data: data});",
          "80:     return;",
          "81:   }",
          "87:   sharp(new Buffer(array), {",
          "88:     raw: {",
          "89:       width: 1,",
          "90:       height: 1,",
          "91:       channels: channels",
          "92:     }",
          "94:     if (!err) {",
          "95:       cachedEmptyResponses[cacheKey] = buffer;",
          "96:     }",
          "",
          "[Removed Lines]",
          "76:   var cacheKey = format + ',' + color;",
          "77:   var data = cachedEmptyResponses[cacheKey];",
          "84:   var color = new Color(color);",
          "85:   var array = color.array();",
          "86:   var channels = array.length == 4 && format != 'jpeg' ? 4 : 3;",
          "93:   }).toFormat(format).toBuffer(function(err, buffer, info) {",
          "",
          "[Added Lines]",
          "74:   const cacheKey = `${format},${color}`;",
          "75:   const data = cachedEmptyResponses[cacheKey];",
          "82:   color = new Color(color);",
          "83:   const array = color.array();",
          "84:   const channels = array.length === 4 && format !== 'jpeg' ? 4 : 3;",
          "91:   }).toFormat(format).toBuffer((err, buffer, info) => {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "98:   });",
          "99: }",
          "107:     scalePattern += i.toFixed();",
          "108:   }",
          "119:     renderers: [],",
          "120:     sources: {}",
          "121:   };",
          "126:       if (err) {",
          "127:         reject(err);",
          "128:         return;",
          "129:       }",
          "132:           if (err) {",
          "133:             reject(err);",
          "134:             return;",
          "",
          "[Removed Lines]",
          "101: module.exports = function(options, repo, params, id, publicUrl, dataResolver) {",
          "102:   var app = express().disable('x-powered-by');",
          "104:   var maxScaleFactor = Math.min(Math.floor(options.maxScaleFactor || 3), 9);",
          "105:   var scalePattern = '';",
          "106:   for (var i = 2; i <= maxScaleFactor; i++) {",
          "109:   scalePattern = '@[' + scalePattern + ']x';",
          "111:   var lastModified = new Date().toUTCString();",
          "113:   var rootPath = options.paths.root;",
          "115:   var watermark = params.watermark || options.watermark;",
          "117:   var styleFile = params.style;",
          "118:   var map = {",
          "123:   var existingFonts = {};",
          "124:   var fontListingPromise = new Promise(function(resolve, reject) {",
          "125:     fs.readdir(options.paths.fonts, function(err, files) {",
          "130:       files.forEach(function(file) {",
          "131:         fs.stat(path.join(options.paths.fonts, file), function(err, stats) {",
          "",
          "[Added Lines]",
          "99: module.exports = (options, repo, params, id, publicUrl, dataResolver) => {",
          "100:   const app = express().disable('x-powered-by');",
          "102:   const maxScaleFactor = Math.min(Math.floor(options.maxScaleFactor || 3), 9);",
          "103:   let scalePattern = '';",
          "104:   for (let i = 2; i <= maxScaleFactor; i++) {",
          "107:   scalePattern = `@[${scalePattern}]x`;",
          "109:   const lastModified = new Date().toUTCString();",
          "111:   const watermark = params.watermark || options.watermark;",
          "113:   const styleFile = params.style;",
          "114:   const map = {",
          "119:   const existingFonts = {};",
          "120:   const fontListingPromise = new Promise((resolve, reject) => {",
          "121:     fs.readdir(options.paths.fonts, (err, files) => {",
          "126:       for (const file of files) {",
          "127:         fs.stat(path.join(options.paths.fonts, file), (err, stats) => {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "137:             existingFonts[path.basename(file)] = true;",
          "138:           }",
          "139:         });",
          "141:       resolve();",
          "142:     });",
          "143:   });",
          "149:         ratio: ratio,",
          "157:               callback(err, { data: data });",
          "158:             });",
          "163:             utils.getFontsPbf(",
          "164:               null, options.paths[protocol], fontstack, range, existingFonts",
          "169:             });",
          "180:               if (err) {",
          "181:                 if (options.verbose) console.log('MBTiles error, serving empty', err);",
          "182:                 createEmptyResponse(sourceInfo.format, sourceInfo.color, callback);",
          "183:                 return;",
          "184:               }",
          "187:               if (headers['Last-Modified']) {",
          "188:                 response.modified = new Date(headers['Last-Modified']);",
          "189:               }",
          "192:                 try {",
          "193:                   response.data = zlib.unzipSync(data);",
          "196:                   console.log(\"Skipping incorrect header for tile mbtiles://%s/%s/%s/%s.pbf\", id, z, x, y);",
          "197:                 }",
          "198:                 if (options.dataDecoratorFunc) {",
          "",
          "[Removed Lines]",
          "140:       });",
          "145:   var styleJSON;",
          "146:   var createPool = function(ratio, min, max) {",
          "147:     var createRenderer = function(ratio, createCallback) {",
          "148:       var renderer = new mbgl.Map({",
          "150:         request: function(req, callback) {",
          "151:           var protocol = req.url.split(':')[0];",
          "153:           if (protocol == 'sprites') {",
          "154:             var dir = options.paths[protocol];",
          "155:             var file = unescape(req.url).substring(protocol.length + 3);",
          "156:             fs.readFile(path.join(dir, file), function(err, data) {",
          "159:           } else if (protocol == 'fonts') {",
          "160:             var parts = req.url.split('/');",
          "161:             var fontstack = unescape(parts[2]);",
          "162:             var range = parts[3].split('.')[0];",
          "165:             ).then(function(concated) {",
          "166:               callback(null, {data: concated});",
          "167:             }, function(err) {",
          "168:               callback(err, {data: null});",
          "170:           } else if (protocol == 'mbtiles') {",
          "171:             var parts = req.url.split('/');",
          "172:             var sourceId = parts[2];",
          "173:             var source = map.sources[sourceId];",
          "174:             var sourceInfo = styleJSON.sources[sourceId];",
          "175:             var z = parts[3] | 0,",
          "176:                 x = parts[4] | 0,",
          "177:                 y = parts[5].split('.')[0] | 0,",
          "178:                 format = parts[5].split('.')[1];",
          "179:             source.getTile(z, x, y, function(err, data, headers) {",
          "186:               var response = {};",
          "191:               if (format == 'pbf') {",
          "194:                 }",
          "195:                 catch (err) {",
          "",
          "[Added Lines]",
          "136:       }",
          "141:   let styleJSON;",
          "142:   const createPool = (ratio, min, max) => {",
          "143:     const createRenderer = (ratio, createCallback) => {",
          "144:       const renderer = new mbgl.Map({",
          "146:         request: (req, callback) => {",
          "147:           const protocol = req.url.split(':')[0];",
          "149:           if (protocol === 'sprites') {",
          "150:             const dir = options.paths[protocol];",
          "151:             const file = unescape(req.url).substring(protocol.length + 3);",
          "152:             fs.readFile(path.join(dir, file), (err, data) => {",
          "155:           } else if (protocol === 'fonts') {",
          "156:             const parts = req.url.split('/');",
          "157:             const fontstack = unescape(parts[2]);",
          "158:             const range = parts[3].split('.')[0];",
          "161:             ).then(concated => {",
          "162:               callback(null, { data: concated });",
          "163:             }, err => {",
          "164:               callback(err, { data: null });",
          "166:           } else if (protocol === 'mbtiles') {",
          "167:             const parts = req.url.split('/');",
          "168:             const sourceId = parts[2];",
          "169:             const source = map.sources[sourceId];",
          "170:             const sourceInfo = styleJSON.sources[sourceId];",
          "171:             const z = parts[3] | 0,",
          "172:               x = parts[4] | 0,",
          "173:               y = parts[5].split('.')[0] | 0,",
          "174:               format = parts[5].split('.')[1];",
          "175:             source.getTile(z, x, y, (err, data, headers) => {",
          "182:               const response = {};",
          "187:               if (format === 'pbf') {",
          "190:                 } catch (err) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "206:               callback(null, response);",
          "207:             });",
          "209:             request({",
          "236:             });",
          "237:           }",
          "238:         }",
          "",
          "[Removed Lines]",
          "208:           } else if (protocol == 'http' || protocol == 'https') {",
          "210:                 url: req.url,",
          "211:                 encoding: null,",
          "212:                 gzip: true",
          "213:             }, function(err, res, body) {",
          "214:                 var parts = url.parse(req.url);",
          "215:                 var extension = path.extname(parts.pathname).toLowerCase();",
          "216:                 var format = extensionToFormat[extension] || '';",
          "217:                 if (err || res.statusCode < 200 || res.statusCode >= 300) {",
          "219:                   createEmptyResponse(format, '', callback);",
          "220:                   return;",
          "221:                 }",
          "223:                 var response = {};",
          "224:                 if (res.headers.modified) {",
          "225:                   response.modified = new Date(res.headers.modified);",
          "226:                 }",
          "227:                 if (res.headers.expires) {",
          "228:                   response.expires = new Date(res.headers.expires);",
          "229:                 }",
          "230:                 if (res.headers.etag) {",
          "231:                   response.etag = res.headers.etag;",
          "232:                 }",
          "234:                 response.data = body;",
          "235:                 callback(null, response);",
          "",
          "[Added Lines]",
          "203:           } else if (protocol === 'http' || protocol === 'https') {",
          "205:               url: req.url,",
          "206:               encoding: null,",
          "207:               gzip: true",
          "208:             }, (err, res, body) => {",
          "209:               const parts = url.parse(req.url);",
          "210:               const extension = path.extname(parts.pathname).toLowerCase();",
          "211:               const format = extensionToFormat[extension] || '';",
          "212:               if (err || res.statusCode < 200 || res.statusCode >= 300) {",
          "214:                 createEmptyResponse(format, '', callback);",
          "215:                 return;",
          "216:               }",
          "218:               const response = {};",
          "219:               if (res.headers.modified) {",
          "220:                 response.modified = new Date(res.headers.modified);",
          "221:               }",
          "222:               if (res.headers.expires) {",
          "223:                 response.expires = new Date(res.headers.expires);",
          "224:               }",
          "225:               if (res.headers.etag) {",
          "226:                 response.etag = res.headers.etag;",
          "227:               }",
          "229:               response.data = body;",
          "230:               callback(null, response);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "244:       min: min,",
          "245:       max: max,",
          "246:       create: createRenderer.bind(null, ratio),",
          "248:         renderer.release();",
          "249:       }",
          "250:     });",
          "251:   };",
          "254:   styleJSON = clone(require(styleJSONPath));",
          "257:   if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "258:     styleJSON.sprite = 'sprites://' +",
          "259:         styleJSON.sprite",
          "",
          "[Removed Lines]",
          "247:       destroy: function(renderer) {",
          "253:   var styleJSONPath = path.resolve(options.paths.styles, styleFile);",
          "256:   var httpTester = /^(http(s)?:)?\\/\\//;",
          "",
          "[Added Lines]",
          "242:       destroy: renderer => {",
          "248:   const styleJSONPath = path.resolve(options.paths.styles, styleFile);",
          "251:   const httpTester = /^(http(s)?:)?\\/\\//;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "261:             .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleJSONPath)));",
          "262:   }",
          "263:   if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "265:   }",
          "268:     if (layer && layer.paint) {",
          "270:       if (layer.paint['fill-extrusion-height']) {",
          "",
          "[Removed Lines]",
          "264:     styleJSON.glyphs = 'fonts://' + styleJSON.glyphs;",
          "267:   (styleJSON.layers || []).forEach(function(layer) {",
          "",
          "[Added Lines]",
          "259:     styleJSON.glyphs = `fonts://${styleJSON.glyphs}`;",
          "262:   for (const layer of (styleJSON.layers || [])) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "274:         layer.paint['fill-extrusion-base'] = 0;",
          "275:       }",
          "276:     }",
          "280:     'tilejson': '2.0.0',",
          "281:     'name': styleJSON.name,",
          "282:     'attribution': '',",
          "",
          "[Removed Lines]",
          "277:   });",
          "279:   var tileJSON = {",
          "",
          "[Added Lines]",
          "272:   }",
          "274:   const tileJSON = {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "286:     'format': 'png',",
          "287:     'type': 'baselayer'",
          "288:   };",
          "290:   Object.assign(tileJSON, params.tilejson || {});",
          "291:   tileJSON.tiles = params.domains || options.domains;",
          "292:   utils.fixTileJSONCenter(tileJSON);",
          "301:     if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "303:       delete source.url;",
          "309:       if (fromData) {",
          "310:         mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "312:         if (mapsTo) {",
          "313:           mbtilesFile = mapsTo;",
          "314:         }",
          "315:         mbtilesFile = dataResolver(mbtilesFile);",
          "316:         if (!mbtilesFile) {",
          "318:           process.exit(1);",
          "319:         }",
          "320:       }",
          "323:         mbtilesFile = path.resolve(options.paths.mbtiles, mbtilesFile);",
          "327:         }",
          "330:             if (err) {",
          "331:               console.error(err);",
          "332:               return;",
          "",
          "[Removed Lines]",
          "289:   var attributionOverride = params.tilejson && params.tilejson.attribution;",
          "294:   var dataProjWGStoInternalWGS = null;",
          "296:   var queue = [];",
          "297:   Object.keys(styleJSON.sources).forEach(function(name) {",
          "298:     var source = styleJSON.sources[name];",
          "299:     var url = source.url;",
          "305:       var mbtilesFile = url.substring('mbtiles://'.length);",
          "306:       var fromData = mbtilesFile[0] == '{' &&",
          "307:                      mbtilesFile[mbtilesFile.length - 1] == '}';",
          "311:         var mapsTo = (params.mapping || {})[mbtilesFile];",
          "317:           console.error('ERROR: data \"' + mbtilesFile + '\" not found!');",
          "322:       queue.push(new Promise(function(resolve, reject) {",
          "324:         var mbtilesFileStats = fs.statSync(mbtilesFile);",
          "325:         if (!mbtilesFileStats.isFile() || mbtilesFileStats.size == 0) {",
          "326:           throw Error('Not valid MBTiles file: ' + mbtilesFile);",
          "328:         map.sources[name] = new mbtiles(mbtilesFile, function(err) {",
          "329:           map.sources[name].getInfo(function(err, info) {",
          "",
          "[Added Lines]",
          "284:   const attributionOverride = params.tilejson && params.tilejson.attribution;",
          "289:   let dataProjWGStoInternalWGS = null;",
          "291:   const queue = [];",
          "292:   for (const name of Object.keys(styleJSON.sources)) {",
          "293:     let source = styleJSON.sources[name];",
          "294:     const url = source.url;",
          "300:       let mbtilesFile = url.substring('mbtiles://'.length);",
          "301:       const fromData = mbtilesFile[0] === '{' &&",
          "302:         mbtilesFile[mbtilesFile.length - 1] === '}';",
          "306:         const mapsTo = (params.mapping || {})[mbtilesFile];",
          "312:           console.error(`ERROR: data \"${mbtilesFile}\" not found!`);",
          "317:       queue.push(new Promise((resolve, reject) => {",
          "319:         const mbtilesFileStats = fs.statSync(mbtilesFile);",
          "320:         if (!mbtilesFileStats.isFile() || mbtilesFileStats.size === 0) {",
          "321:           throw Error(`Not valid MBTiles file: ${mbtilesFile}`);",
          "323:         map.sources[name] = new MBTiles(mbtilesFile, err => {",
          "324:           map.sources[name].getInfo((err, info) => {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "335:             if (!dataProjWGStoInternalWGS && info.proj4) {",
          "342:             }",
          "345:             Object.assign(source, info);",
          "346:             source.type = type;",
          "347:             source.tiles = [",
          "350:             ];",
          "351:             delete source.scheme;",
          "",
          "[Removed Lines]",
          "337:               var to3857 = proj4('EPSG:3857');",
          "338:               var toDataProj = proj4(info.proj4);",
          "339:               dataProjWGStoInternalWGS = function(xy) {",
          "340:                 return to3857.inverse(toDataProj.forward(xy));",
          "341:               };",
          "344:             var type = source.type;",
          "349:               'mbtiles://' + name + '/{z}/{x}/{y}.' + (info.format || 'pbf')",
          "",
          "[Added Lines]",
          "332:               const to3857 = proj4('EPSG:3857');",
          "333:               const toDataProj = proj4(info.proj4);",
          "334:               dataProjWGStoInternalWGS = xy => to3857.inverse(toDataProj.forward(xy));",
          "337:             const type = source.type;",
          "342:               `mbtiles://${name}/{z}/{x}/{y}.${info.format || 'pbf'}`",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "366:         });",
          "367:       }));",
          "368:     }",
          "380:       map.renderers[s] = createPool(s, minPoolSize, maxPoolSize);",
          "381:     }",
          "382:   });",
          "384:   repo[id] = tileJSON;",
          "392:     if (Math.abs(lon) > 180 || Math.abs(lat) > 85.06 ||",
          "394:       return res.status(400).send('Invalid center');",
          "395:     }",
          "396:     if (Math.min(width, height) <= 0 ||",
          "399:       return res.status(400).send('Invalid size');",
          "400:     }",
          "403:       format = 'jpeg';",
          "404:     } else {",
          "405:       return res.status(400).send('Invalid format');",
          "406:     }",
          "412:         zoom: mbglZ,",
          "413:         center: [lon, lat],",
          "414:         bearing: bearing,",
          "",
          "[Removed Lines]",
          "369:   });",
          "371:   var renderersReadyPromise = Promise.all(queue).then(function() {",
          "373:     var minPoolSizes = options.minRendererPoolSizes || [8, 4, 2];",
          "374:     var maxPoolSizes = options.maxRendererPoolSizes || [16, 8, 4];",
          "375:     for (var s = 1; s <= maxScaleFactor; s++) {",
          "376:       var i = Math.min(minPoolSizes.length - 1, s - 1);",
          "377:       var j = Math.min(maxPoolSizes.length - 1, s - 1);",
          "378:       var minPoolSize = minPoolSizes[i];",
          "379:       var maxPoolSize = Math.max(minPoolSize, maxPoolSizes[j]);",
          "386:   var tilePattern = '/' + id + '/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+)' +",
          "387:                     ':scale(' + scalePattern + ')?\\.:format([\\\\w]+)';",
          "389:   var respondImage = function(z, lon, lat, bearing, pitch,",
          "390:                               width, height, scale, format, res, next,",
          "391:                               opt_overlay) {",
          "393:         lon != lon || lat != lat) {",
          "397:         Math.max(width, height) * scale > (options.maxSize || 2048) ||",
          "398:         width != width || height != height) {",
          "401:     if (format == 'png' || format == 'webp') {",
          "402:     } else if (format == 'jpg' || format == 'jpeg') {",
          "408:     var pool = map.renderers[scale];",
          "409:     pool.acquire(function(err, renderer) {",
          "410:       var mbglZ = Math.max(0, z - 1);",
          "411:       var params = {",
          "",
          "[Added Lines]",
          "362:   }",
          "364:   const renderersReadyPromise = Promise.all(queue).then(() => {",
          "366:     const minPoolSizes = options.minRendererPoolSizes || [8, 4, 2];",
          "367:     const maxPoolSizes = options.maxRendererPoolSizes || [16, 8, 4];",
          "368:     for (let s = 1; s <= maxScaleFactor; s++) {",
          "369:       const i = Math.min(minPoolSizes.length - 1, s - 1);",
          "370:       const j = Math.min(maxPoolSizes.length - 1, s - 1);",
          "371:       const minPoolSize = minPoolSizes[i];",
          "372:       const maxPoolSize = Math.max(minPoolSize, maxPoolSizes[j]);",
          "379:   const tilePattern = `/${id}/:z(\\\\d+)/:x(\\\\d+)/:y(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`;",
          "381:   const respondImage = (z, lon, lat, bearing, pitch,",
          "382:                         width, height, scale, format, res, next,",
          "383:                         opt_overlay) => {",
          "385:       lon !== lon || lat !== lat) {",
          "389:       Math.max(width, height) * scale > (options.maxSize || 2048) ||",
          "390:       width !== width || height !== height) {",
          "393:     if (format === 'png' || format === 'webp') {",
          "394:     } else if (format === 'jpg' || format === 'jpeg') {",
          "400:     const pool = map.renderers[scale];",
          "401:     pool.acquire((err, renderer) => {",
          "402:       const mbglZ = Math.max(0, z - 1);",
          "403:       const params = {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "416:         width: width,",
          "417:         height: height",
          "418:       };",
          "420:         params.width *= 2;",
          "421:         params.height *= 2;",
          "422:       }",
          "425:       if (z > 2 && tileMargin > 0) {",
          "426:         params.width += tileMargin * 2 * scale;",
          "427:         params.height += tileMargin * 2 * scale;",
          "428:       }",
          "431:         pool.release(renderer);",
          "432:         if (err) {",
          "433:           console.error(err);",
          "434:           return;",
          "435:         }",
          "438:           raw: {",
          "439:             width: params.width * scale,",
          "440:             height: params.height * scale,",
          "",
          "[Removed Lines]",
          "419:       if (z == 0) {",
          "424:       var tileMargin = Math.max(options.tileMargin || 0, 0);",
          "430:       renderer.render(params, function(err, data) {",
          "437:         var image = sharp(data, {",
          "",
          "[Added Lines]",
          "411:       if (z === 0) {",
          "416:       const tileMargin = Math.max(options.tileMargin || 0, 0);",
          "422:       renderer.render(params, (err, data) => {",
          "429:         const image = sharp(data, {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "443:         });",
          "445:         if (z > 2 && tileMargin > 0) {",
          "447:         }",
          "451:           image.resize(width * scale, height * scale);",
          "452:         }",
          "",
          "[Removed Lines]",
          "446:             image.extract({ left: tileMargin * scale, top: tileMargin * scale, width: width * scale, height: height * scale });",
          "449:         if (z == 0) {",
          "",
          "[Added Lines]",
          "438:           image.extract({",
          "439:             left: tileMargin * scale,",
          "440:             top: tileMargin * scale,",
          "441:             width: width * scale,",
          "442:             height: height * scale",
          "443:           });",
          "446:         if (z === 0) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "455:           image.composite([{ input: opt_overlay }]);",
          "456:         }",
          "457:         if (watermark) {",
          "460:           ctx.scale(scale, scale);",
          "461:           ctx.font = '10px sans-serif';",
          "462:           ctx.strokeWidth = '1px';",
          "",
          "[Removed Lines]",
          "458:           var canvas = createCanvas(scale * width, scale * height);",
          "459:           var ctx = canvas.getContext('2d');",
          "",
          "[Added Lines]",
          "455:           const canvas = createCanvas(scale * width, scale * height);",
          "456:           const ctx = canvas.getContext('2d');",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "468:           image.composite([{ input: canvas.toBuffer() }]);",
          "469:         }",
          "480:         }",
          "482:           if (!buffer) {",
          "483:             return res.status(404).send('Not found');",
          "484:           }",
          "486:           res.set({",
          "487:             'Last-Modified': lastModified,",
          "489:           });",
          "490:           return res.status(200).send(buffer);",
          "491:         });",
          "",
          "[Removed Lines]",
          "471:         var formatQuality = (params.formatQuality || {})[format] ||",
          "472:                             (options.formatQuality || {})[format];",
          "474:         if (format == 'png') {",
          "475:           image.png({adaptiveFiltering: false});",
          "476:         } else if (format == 'jpeg') {",
          "477:           image.jpeg({quality: formatQuality || 80});",
          "478:         } else if (format == 'webp') {",
          "479:           image.webp({quality: formatQuality || 90});",
          "481:         image.toBuffer(function(err, buffer, info) {",
          "488:             'Content-Type': 'image/' + format",
          "",
          "[Added Lines]",
          "468:         const formatQuality = (params.formatQuality || {})[format] ||",
          "469:           (options.formatQuality || {})[format];",
          "471:         if (format === 'png') {",
          "472:           image.png({ adaptiveFiltering: false });",
          "473:         } else if (format === 'jpeg') {",
          "474:           image.jpeg({ quality: formatQuality || 80 });",
          "475:         } else if (format === 'webp') {",
          "476:           image.webp({ quality: formatQuality || 90 });",
          "478:         image.toBuffer((err, buffer, info) => {",
          "485:             'Content-Type': `image/${format}`",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "493:     });",
          "494:   };",
          "499:       if (new Date(lastModified) <= new Date(modifiedSince)) {",
          "500:         return res.sendStatus(304);",
          "501:       }",
          "502:     }",
          "509:     if (z < 0 || x < 0 || y < 0 ||",
          "510:         z > 20 || x >= Math.pow(2, z) || y >= Math.pow(2, z)) {",
          "511:       return res.status(404).send('Out of bounds');",
          "512:     }",
          "515:       ((x + 0.5) / (1 << z)) * (256 << z),",
          "516:       ((y + 0.5) / (1 << z)) * (256 << z)",
          "517:     ], z);",
          "",
          "[Removed Lines]",
          "496:   app.get(tilePattern, function(req, res, next) {",
          "497:     var modifiedSince = req.get('if-modified-since'), cc = req.get('cache-control');",
          "498:     if (modifiedSince && (!cc || cc.indexOf('no-cache') == -1)) {",
          "504:     var z = req.params.z | 0,",
          "505:         x = req.params.x | 0,",
          "506:         y = req.params.y | 0,",
          "507:         scale = getScale(req.params.scale),",
          "508:         format = req.params.format;",
          "513:     var tileSize = 256;",
          "514:     var tileCenter = mercator.ll([",
          "",
          "[Added Lines]",
          "493:   app.get(tilePattern, (req, res, next) => {",
          "494:     const modifiedSince = req.get('if-modified-since'), cc = req.get('cache-control');",
          "495:     if (modifiedSince && (!cc || cc.indexOf('no-cache') === -1)) {",
          "501:     const z = req.params.z | 0,",
          "502:       x = req.params.x | 0,",
          "503:       y = req.params.y | 0,",
          "504:       scale = getScale(req.params.scale),",
          "505:       format = req.params.format;",
          "510:     const tileSize = 256;",
          "511:     const tileCenter = mercator.ll([",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "519:                         tileSize, tileSize, scale, format, res, next);",
          "520:   });",
          "530:           pair = [+(pairParts[1]), +(pairParts[0])];",
          "531:         } else {",
          "532:           pair = [+(pairParts[0]), +(pairParts[1])];",
          "",
          "[Removed Lines]",
          "522:   var extractPathFromQuery = function(query, transformer) {",
          "523:     var pathParts = (query.path || '').split('|');",
          "524:     var path = [];",
          "525:     pathParts.forEach(function(pair) {",
          "526:       var pairParts = pair.split(',');",
          "527:       if (pairParts.length == 2) {",
          "528:         var pair;",
          "529:         if (query.latlng == '1' || query.latlng == 'true') {",
          "",
          "[Added Lines]",
          "519:   const extractPathFromQuery = (query, transformer) => {",
          "520:     const pathParts = (query.path || '').split('|');",
          "521:     const path = [];",
          "522:     for (const pair of pathParts) {",
          "523:       const pairParts = pair.split(',');",
          "524:       if (pairParts.length === 2) {",
          "525:         let pair;",
          "526:         if (query.latlng === '1' || query.latlng === 'true') {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "536:         }",
          "537:         path.push(pair);",
          "538:       }",
          "540:     return path;",
          "541:   };",
          "545:     if (!path || path.length < 2) {",
          "546:       return null;",
          "547:     }",
          "551:       return [px[0] * scale, px[1] * scale];",
          "552:     };",
          "559:     if (maxEdge > mapHeight) {",
          "560:       center[1] -= (maxEdge - mapHeight);",
          "561:     } else if (minEdge < 0) {",
          "562:       center[1] -= minEdge;",
          "563:     }",
          "567:     ctx.scale(scale, scale);",
          "568:     if (bearing) {",
          "569:       ctx.translate(w / 2, h / 2);",
          "",
          "[Removed Lines]",
          "539:     });",
          "543:   var renderOverlay = function(z, x, y, bearing, pitch, w, h, scale,",
          "544:                                path, query) {",
          "548:     var precisePx = function(ll, zoom) {",
          "549:       var px = mercator.px(ll, 20);",
          "550:       var scale = Math.pow(2, zoom - 20);",
          "554:     var center = precisePx([x, y], z);",
          "556:     var mapHeight = 512 * (1 << z);",
          "557:     var maxEdge = center[1] + h / 2;",
          "558:     var minEdge = center[1] - h / 2;",
          "565:     var canvas = createCanvas(scale * w, scale * h);",
          "566:     var ctx = canvas.getContext('2d');",
          "",
          "[Added Lines]",
          "536:     }",
          "540:   const renderOverlay = (z, x, y, bearing, pitch, w, h, scale,",
          "541:                          path, query) => {",
          "545:     const precisePx = (ll, zoom) => {",
          "546:       const px = mercator.px(ll, 20);",
          "547:       const scale = Math.pow(2, zoom - 20);",
          "551:     const center = precisePx([x, y], z);",
          "553:     const mapHeight = 512 * (1 << z);",
          "554:     const maxEdge = center[1] + h / 2;",
          "555:     const minEdge = center[1] - h / 2;",
          "562:     const canvas = createCanvas(scale * w, scale * h);",
          "563:     const ctx = canvas.getContext('2d');",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "574:       ctx.translate(-center[0] + w / 2, -center[1] + h / 2);",
          "575:     }",
          "578:     ctx.lineWidth = lineWidth;",
          "579:     ctx.strokeStyle = query.stroke || 'rgba(0,64,255,0.7)';",
          "580:     ctx.fillStyle = query.fill || 'rgba(255,255,255,0.4)';",
          "581:     ctx.beginPath();",
          "584:       ctx.lineTo(px[0], px[1]);",
          "588:       ctx.closePath();",
          "589:     }",
          "590:     ctx.fill();",
          "",
          "[Removed Lines]",
          "576:     var lineWidth = query.width !== undefined ?",
          "577:                     parseFloat(query.width) : 1;",
          "582:     path.forEach(function(pair) {",
          "583:       var px = precisePx(pair, z);",
          "585:     });",
          "586:     if (path[0][0] == path[path.length - 1][0] &&",
          "587:         path[0][1] == path[path.length - 1][1]) {",
          "",
          "[Added Lines]",
          "573:     const lineWidth = query.width !== undefined ?",
          "574:       parseFloat(query.width) : 1;",
          "579:     for (const pair of path) {",
          "580:       const px = precisePx(pair, z);",
          "582:     }",
          "583:     if (path[0][0] === path[path.length - 1][0] &&",
          "584:       path[0][1] === path[path.length - 1][1]) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "595:     return canvas.toBuffer();",
          "596:   };",
          "609:     z -= Math.max(",
          "610:       Math.log((maxCorner[0] - minCorner[0]) / w_),",
          "",
          "[Removed Lines]",
          "598:   var calcZForBBox = function(bbox, w, h, query) {",
          "599:     var z = 25;",
          "601:     var padding = query.padding !== undefined ?",
          "602:                   parseFloat(query.padding) : 0.1;",
          "604:     var minCorner = mercator.px([bbox[0], bbox[3]], z),",
          "605:         maxCorner = mercator.px([bbox[2], bbox[1]], z);",
          "606:     var w_ = w / (1 + 2 * padding);",
          "607:     var h_ = h / (1 + 2 * padding);",
          "",
          "[Added Lines]",
          "595:   const calcZForBBox = (bbox, w, h, query) => {",
          "596:     let z = 25;",
          "598:     const padding = query.padding !== undefined ?",
          "599:       parseFloat(query.padding) : 0.1;",
          "601:     const minCorner = mercator.px([bbox[0], bbox[3]], z),",
          "602:       maxCorner = mercator.px([bbox[2], bbox[1]], z);",
          "603:     const w_ = w / (1 + 2 * padding);",
          "604:     const h_ = h / (1 + 2 * padding);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "617:   };",
          "619:   if (options.serveStaticMaps !== false) {",
          "641:       if (z < 0) {",
          "642:         return res.status(404).send('Invalid zoom');",
          "643:       }",
          "646:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "648:       if (transformer) {",
          "650:         x = ll[0];",
          "651:         y = ll[1];",
          "652:       }",
          "658:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "659:                           res, next, overlay);",
          "660:     });",
          "669:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "671:       if (transformer) {",
          "674:         bbox[0] = minCorner[0];",
          "675:         bbox[1] = minCorner[1];",
          "676:         bbox[2] = maxCorner[0];",
          "",
          "[Removed Lines]",
          "620:     var staticPattern =",
          "621:         '/' + id + '/static/:raw(raw)?/%s/:width(\\\\d+)x:height(\\\\d+)' +",
          "622:         ':scale(' + scalePattern + ')?\\.:format([\\\\w]+)';",
          "624:     var centerPattern =",
          "625:         util.format(':x(%s),:y(%s),:z(%s)(@:bearing(%s)(,:pitch(%s))?)?',",
          "626:                     FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN,",
          "627:                     FLOAT_PATTERN, FLOAT_PATTERN);",
          "629:     app.get(util.format(staticPattern, centerPattern), function(req, res, next) {",
          "630:       var raw = req.params.raw;",
          "631:       var z = +req.params.z,",
          "632:           x = +req.params.x,",
          "633:           y = +req.params.y,",
          "634:           bearing = +(req.params.bearing || '0'),",
          "635:           pitch = +(req.params.pitch || '0'),",
          "636:           w = req.params.width | 0,",
          "637:           h = req.params.height | 0,",
          "638:           scale = getScale(req.params.scale),",
          "639:           format = req.params.format;",
          "645:       var transformer = raw ?",
          "649:         var ll = transformer([x, y]);",
          "654:       var path = extractPathFromQuery(req.query, transformer);",
          "655:       var overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "656:                                   path, req.query);",
          "662:     var serveBounds = function(req, res, next) {",
          "663:       var raw = req.params.raw;",
          "664:       var bbox = [+req.params.minx, +req.params.miny,",
          "665:                   +req.params.maxx, +req.params.maxy];",
          "666:       var center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];",
          "668:       var transformer = raw ?",
          "672:         var minCorner = transformer(bbox.slice(0, 2));",
          "673:         var maxCorner = transformer(bbox.slice(2));",
          "",
          "[Added Lines]",
          "617:     const staticPattern =",
          "618:       `/${id}/static/:raw(raw)?/%s/:width(\\\\d+)x:height(\\\\d+):scale(${scalePattern})?.:format([\\\\w]+)`;",
          "620:     const centerPattern =",
          "621:       util.format(':x(%s),:y(%s),:z(%s)(@:bearing(%s)(,:pitch(%s))?)?',",
          "622:         FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN,",
          "623:         FLOAT_PATTERN, FLOAT_PATTERN);",
          "625:     app.get(util.format(staticPattern, centerPattern), (req, res, next) => {",
          "626:       const raw = req.params.raw;",
          "627:       let z = +req.params.z,",
          "628:         x = +req.params.x,",
          "629:         y = +req.params.y,",
          "630:         bearing = +(req.params.bearing || '0'),",
          "631:         pitch = +(req.params.pitch || '0'),",
          "632:         w = req.params.width | 0,",
          "633:         h = req.params.height | 0,",
          "634:         scale = getScale(req.params.scale),",
          "635:         format = req.params.format;",
          "641:       const transformer = raw ?",
          "645:         const ll = transformer([x, y]);",
          "650:       const path = extractPathFromQuery(req.query, transformer);",
          "651:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "652:         path, req.query);",
          "658:     const serveBounds = (req, res, next) => {",
          "659:       const raw = req.params.raw;",
          "660:       const bbox = [+req.params.minx, +req.params.miny,",
          "661:         +req.params.maxx, +req.params.maxy];",
          "662:       let center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];",
          "664:       const transformer = raw ?",
          "668:         const minCorner = transformer(bbox.slice(0, 2));",
          "669:         const maxCorner = transformer(bbox.slice(2));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "678:         center = transformer(center);",
          "679:       }",
          "695:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "697:     };",
          "703:     app.get(util.format(staticPattern, boundsPattern), serveBounds);",
          "707:         req.query[key.toLowerCase()] = req.query[key];",
          "708:       }",
          "709:       req.params.raw = true;",
          "710:       req.params.format = (req.query.format || 'image/png').split('/').pop();",
          "712:       req.params.minx = bbox[0];",
          "713:       req.params.miny = bbox[1];",
          "714:       req.params.maxx = bbox[2];",
          "",
          "[Removed Lines]",
          "681:       var w = req.params.width | 0,",
          "682:           h = req.params.height | 0,",
          "683:           scale = getScale(req.params.scale),",
          "684:           format = req.params.format;",
          "686:       var z = calcZForBBox(bbox, w, h, req.query),",
          "687:           x = center[0],",
          "688:           y = center[1],",
          "689:           bearing = 0,",
          "690:           pitch = 0;",
          "692:       var path = extractPathFromQuery(req.query, transformer);",
          "693:       var overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "694:                                   path, req.query);",
          "696:                           res, next, overlay);",
          "699:     var boundsPattern =",
          "700:         util.format(':minx(%s),:miny(%s),:maxx(%s),:maxy(%s)',",
          "701:                     FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN);",
          "705:     app.get('/' + id + '/static/', function(req, res, next) {",
          "706:       for (var key in req.query) {",
          "711:       var bbox = (req.query.bbox || '').split(',');",
          "",
          "[Added Lines]",
          "677:       const w = req.params.width | 0,",
          "678:         h = req.params.height | 0,",
          "679:         scale = getScale(req.params.scale),",
          "680:         format = req.params.format;",
          "682:       const z = calcZForBBox(bbox, w, h, req.query),",
          "683:         x = center[0],",
          "684:         y = center[1],",
          "685:         bearing = 0,",
          "686:         pitch = 0;",
          "688:       const path = extractPathFromQuery(req.query, transformer);",
          "689:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "690:         path, req.query);",
          "692:         res, next, overlay);",
          "695:     const boundsPattern =",
          "696:       util.format(':minx(%s),:miny(%s),:maxx(%s),:maxy(%s)',",
          "697:         FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN, FLOAT_PATTERN);",
          "701:     app.get(`/${id}/static/`, (req, res, next) => {",
          "702:       for (let key in req.query) {",
          "707:       const bbox = (req.query.bbox || '').split(',');",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "718:       if (req.query.scale) {",
          "719:         req.params.width /= req.query.scale;",
          "720:         req.params.height /= req.query.scale;",
          "722:       }",
          "724:       return serveBounds(req, res, next);",
          "725:     });",
          "739:         mercator.inverse.bind(mercator) : dataProjWGStoInternalWGS;",
          "742:       if (path.length < 2) {",
          "743:         return res.status(400).send('Invalid path');",
          "744:       }",
          "748:         bbox[0] = Math.min(bbox[0], pair[0]);",
          "749:         bbox[1] = Math.min(bbox[1], pair[1]);",
          "750:         bbox[2] = Math.max(bbox[2], pair[0]);",
          "751:         bbox[3] = Math.max(bbox[3], pair[1]);",
          "756:         [(bbox_[0] + bbox_[2]) / 2, (bbox_[1] + bbox_[3]) / 2]",
          "757:       );",
          "766:       return respondImage(z, x, y, bearing, pitch, w, h, scale, format,",
          "767:                           res, next, overlay);",
          "768:     });",
          "769:   }",
          "773:     info.tiles = utils.getTileUrls(req, info.tiles,",
          "775:     return res.send(info);",
          "776:   });",
          "782: };",
          "",
          "[Removed Lines]",
          "721:         req.params.scale = '@' + req.query.scale;",
          "727:     var autoPattern = 'auto';",
          "729:     app.get(util.format(staticPattern, autoPattern), function(req, res, next) {",
          "730:       var raw = req.params.raw;",
          "731:       var w = req.params.width | 0,",
          "732:           h = req.params.height | 0,",
          "733:           bearing = 0,",
          "734:           pitch = 0,",
          "735:           scale = getScale(req.params.scale),",
          "736:           format = req.params.format;",
          "738:       var transformer = raw ?",
          "741:       var path = extractPathFromQuery(req.query, transformer);",
          "746:       var bbox = [Infinity, Infinity, -Infinity, -Infinity];",
          "747:       path.forEach(function(pair) {",
          "752:       });",
          "754:       var bbox_ = mercator.convert(bbox, '900913');",
          "755:       var center = mercator.inverse(",
          "759:       var z = calcZForBBox(bbox, w, h, req.query),",
          "760:           x = center[0],",
          "761:           y = center[1];",
          "763:       var overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "764:                                   path, req.query);",
          "771:   app.get('/' + id + '.json', function(req, res, next) {",
          "772:     var info = clone(tileJSON);",
          "774:                                    'styles/' + id, info.format, publicUrl);",
          "778:   return Promise.all([fontListingPromise, renderersReadyPromise]).then(function() {",
          "779:     return app;",
          "780:   });",
          "",
          "[Added Lines]",
          "717:         req.params.scale = `@${req.query.scale}`;",
          "723:     const autoPattern = 'auto';",
          "725:     app.get(util.format(staticPattern, autoPattern), (req, res, next) => {",
          "726:       const raw = req.params.raw;",
          "727:       const w = req.params.width | 0,",
          "728:         h = req.params.height | 0,",
          "729:         bearing = 0,",
          "730:         pitch = 0,",
          "731:         scale = getScale(req.params.scale),",
          "732:         format = req.params.format;",
          "734:       const transformer = raw ?",
          "737:       const path = extractPathFromQuery(req.query, transformer);",
          "742:       const bbox = [Infinity, Infinity, -Infinity, -Infinity];",
          "743:       for (const pair of path) {",
          "748:       }",
          "750:       const bbox_ = mercator.convert(bbox, '900913');",
          "751:       const center = mercator.inverse(",
          "755:       const z = calcZForBBox(bbox, w, h, req.query),",
          "756:         x = center[0],",
          "757:         y = center[1];",
          "759:       const overlay = renderOverlay(z, x, y, bearing, pitch, w, h, scale,",
          "760:         path, req.query);",
          "767:   app.get(`/${id}.json`, (req, res, next) => {",
          "768:     const info = clone(tileJSON);",
          "770:                                    `styles/${id}`, info.format, publicUrl);",
          "774:   return Promise.all([fontListingPromise, renderersReadyPromise]).then(() => app);",
          "",
          "---------------"
        ],
        "src/serve_style.js||src/serve_style.js": [
          "File: src/serve_style.js -> src/serve_style.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: 'use strict';",
          "20:     if (url && url.lastIndexOf('mbtiles:', 0) === 0) {",
          "25:       if (fromData) {",
          "26:         mbtilesFile = mbtilesFile.substr(1, mbtilesFile.length - 2);",
          "28:         if (mapsTo) {",
          "29:           mbtilesFile = mapsTo;",
          "30:         }",
          "31:       }",
          "34:     }",
          "40:       if (fonts && fonts.length) {",
          "41:         fonts.forEach(reportFont);",
          "42:       } else {",
          "",
          "[Removed Lines]",
          "3: var path = require('path'),",
          "4:     fs = require('fs');",
          "6: var clone = require('clone'),",
          "7:     express = require('express');",
          "9: var utils = require('./utils');",
          "11: module.exports = function(options, repo, params, id, publicUrl, reportTiles, reportFont) {",
          "12:   var app = express().disable('x-powered-by');",
          "14:   var styleFile = path.resolve(options.paths.styles, params.style);",
          "16:   var styleJSON = clone(require(styleFile));",
          "17:   Object.keys(styleJSON.sources).forEach(function(name) {",
          "18:     var source = styleJSON.sources[name];",
          "19:     var url = source.url;",
          "21:       var mbtilesFile = url.substring('mbtiles://'.length);",
          "22:       var fromData = mbtilesFile[0] == '{' &&",
          "23:                      mbtilesFile[mbtilesFile.length - 1] == '}';",
          "27:         var mapsTo = (params.mapping || {})[mbtilesFile];",
          "32:       var identifier = reportTiles(mbtilesFile, fromData);",
          "33:       source.url = 'local://data/' + identifier + '.json';",
          "35:   });",
          "37:   styleJSON.layers.forEach(function(obj) {",
          "38:     if (obj['type'] == 'symbol') {",
          "39:       var fonts = (obj['layout'] || {})['text-font'];",
          "",
          "[Added Lines]",
          "3: const path = require('path');",
          "4: const fs = require('fs');",
          "6: const clone = require('clone');",
          "7: const express = require('express');",
          "9: const utils = require('./utils');",
          "11: module.exports = (options, repo, params, id, publicUrl, reportTiles, reportFont) => {",
          "12:   const app = express().disable('x-powered-by');",
          "14:   const styleFile = path.resolve(options.paths.styles, params.style);",
          "16:   const styleJSON = clone(require(styleFile));",
          "17:   for (const name of Object.keys(styleJSON.sources)) {",
          "18:     const source = styleJSON.sources[name];",
          "19:     const url = source.url;",
          "21:       let mbtilesFile = url.substring('mbtiles://'.length);",
          "22:       const fromData = mbtilesFile[0] === '{' &&",
          "23:         mbtilesFile[mbtilesFile.length - 1] === '}';",
          "27:         const mapsTo = (params.mapping || {})[mbtilesFile];",
          "32:       const identifier = reportTiles(mbtilesFile, fromData);",
          "33:       source.url = `local://data/${identifier}.json`;",
          "35:   }",
          "37:   for(let obj of styleJSON.layers) {",
          "38:     if (obj['type'] === 'symbol') {",
          "39:       const fonts = (obj['layout'] || {})['text-font'];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:         reportFont('Arial Unicode MS Regular');",
          "45:       }",
          "46:     }",
          "52:   if (styleJSON.sprite && !httpTester.test(styleJSON.sprite)) {",
          "53:     spritePath = path.join(options.paths.sprites,",
          "54:         styleJSON.sprite",
          "55:             .replace('{style}', path.basename(styleFile, '.json'))",
          "56:             .replace('{styleJsonFolder}', path.relative(options.paths.sprites, path.dirname(styleFile)))",
          "57:             );",
          "59:   }",
          "60:   if (styleJSON.glyphs && !httpTester.test(styleJSON.glyphs)) {",
          "61:     styleJSON.glyphs = 'local://fonts/{fontstack}/{range}.pbf';",
          "",
          "[Removed Lines]",
          "47:   });",
          "49:   var spritePath;",
          "51:   var httpTester = /^(http(s)?:)?\\/\\//;",
          "58:     styleJSON.sprite = 'local://styles/' + id + '/sprite';",
          "",
          "[Added Lines]",
          "47:   }",
          "49:   let spritePath;",
          "51:   const httpTester = /^(http(s)?:)?\\/\\//;",
          "58:     styleJSON.sprite = `local://styles/${id}/sprite`;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:   repo[id] = styleJSON;",
          "68:       if (!url || (typeof url !== 'string') || url.indexOf('local://') !== 0) {",
          "69:         return url;",
          "70:       }",
          "72:       if (!opt_nostyle && global.addStyleParam) {",
          "74:       }",
          "75:       if (!opt_nokey && req.query.key) {",
          "77:       }",
          "79:       if (queryParams.length) {",
          "81:       }",
          "82:       return url.replace(",
          "84:     };",
          "89:       source.url = fixUrl(source.url);",
          "92:     if (styleJSON_.sprite) {",
          "93:       styleJSON_.sprite = fixUrl(styleJSON_.sprite, true, true);",
          "",
          "[Removed Lines]",
          "66:   app.get('/' + id + '/style.json', function(req, res, next) {",
          "67:     var fixUrl = function(url, opt_nokey, opt_nostyle) {",
          "71:       var queryParams = [];",
          "73:         queryParams.push('style=' + id);",
          "76:         queryParams.unshift('key=' + req.query.key);",
          "78:       var query = '';",
          "80:         query = '?' + queryParams.join('&');",
          "83:           'local://', utils.getPublicUrl(publicUrl, req)) + query;",
          "86:     var styleJSON_ = clone(styleJSON);",
          "87:     Object.keys(styleJSON_.sources).forEach(function(name) {",
          "88:       var source = styleJSON_.sources[name];",
          "90:     });",
          "",
          "[Added Lines]",
          "66:   app.get(`/${id}/style.json`, (req, res, next) => {",
          "67:     const fixUrl = (url, opt_nokey, opt_nostyle) => {",
          "71:       const queryParams = [];",
          "73:         queryParams.push(`style=${id}`);",
          "76:         queryParams.unshift(`key=${req.query.key}`);",
          "78:       let query = '';",
          "80:         query = `?${queryParams.join('&')}`;",
          "83:         'local://', utils.getPublicUrl(publicUrl, req)) + query;",
          "86:     const styleJSON_ = clone(styleJSON);",
          "87:     for (const name of Object.keys(styleJSON_.sources)) {",
          "88:       const source = styleJSON_.sources[name];",
          "90:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98:     return res.send(styleJSON_);",
          "99:   });",
          "103:     if (!spritePath) {",
          "104:       return res.status(404).send('File not found');",
          "105:     }",
          "110:       if (err) {",
          "111:         console.log('Sprite load error:', filename);",
          "112:         return res.status(404).send('File not found');",
          "113:       } else {",
          "116:         return res.send(data);",
          "117:       }",
          "118:     });",
          "",
          "[Removed Lines]",
          "101:   app.get('/' + id + '/sprite:scale(@[23]x)?\\.:format([\\\\w]+)',",
          "102:       function(req, res, next) {",
          "106:     var scale = req.params.scale,",
          "107:         format = req.params.format;",
          "108:     var filename = spritePath + (scale || '') + '.' + format;",
          "109:     return fs.readFile(filename, function(err, data) {",
          "114:         if (format == 'json') res.header('Content-type', 'application/json');",
          "115:         if (format == 'png') res.header('Content-type', 'image/png');",
          "",
          "[Added Lines]",
          "101:   app.get(`/${id}/sprite:scale(@[23]x)?.:format([\\\\w]+)`,",
          "102:     (req, res, next) => {",
          "106:         const scale = req.params.scale,",
          "107:           format = req.params.format;",
          "108:         const filename = `${spritePath + (scale || '')}.${format}`;",
          "109:         return fs.readFile(filename, (err, data) => {",
          "114:         if (format === 'json') res.header('Content-type', 'application/json');",
          "115:         if (format === 'png') res.header('Content-type', 'image/png');",
          "",
          "---------------"
        ],
        "src/server.js||src/server.js": [
          "File: src/server.js -> src/server.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: process.env.UV_THREADPOOL_SIZE =",
          "5:     Math.ceil(Math.max(4, require('os').cpus().length * 1.5));",
          "26: if (!isLight) {",
          "28:   serve_rendered = require('./serve_rendered');",
          "",
          "[Removed Lines]",
          "7: var fs = require('fs'),",
          "8:     path = require('path');",
          "10: var clone = require('clone'),",
          "11:     cors = require('cors'),",
          "12:     enableShutdown = require('http-shutdown'),",
          "13:     express = require('express'),",
          "14:     handlebars = require('handlebars'),",
          "15:     mercator = new (require('@mapbox/sphericalmercator'))(),",
          "16:     morgan = require('morgan');",
          "18: var packageJson = require('../package'),",
          "19:     serve_font = require('./serve_font'),",
          "20:     serve_rendered = null,",
          "21:     serve_style = require('./serve_style'),",
          "22:     serve_data = require('./serve_data'),",
          "23:     utils = require('./utils');",
          "25: var isLight = packageJson.name.slice(-6) == '-light';",
          "",
          "[Added Lines]",
          "7: const fs = require('fs');",
          "8: const path = require('path');",
          "10: const clone = require('clone');",
          "11: const cors = require('cors');",
          "12: const enableShutdown = require('http-shutdown');",
          "13: const express = require('express');",
          "14: const handlebars = require('handlebars');",
          "15: const mercator = new (require('@mapbox/sphericalmercator'))();",
          "16: const morgan = require('morgan');",
          "18: const packageJson = require('../package');",
          "19: const serve_font = require('./serve_font');",
          "20: const serve_style = require('./serve_style');",
          "21: const serve_data = require('./serve_data');",
          "22: const utils = require('./utils');",
          "24: let serve_rendered = null;",
          "25: const isLight = packageJson.name.slice(-6) === '-light';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: function start(opts) {",
          "32:   console.log('Starting server');",
          "42:   app.enable('trust proxy');",
          "44:   if (process.env.NODE_ENV !== 'test') {",
          "47:     app.use(morgan(logFormat, {",
          "48:       stream: opts.logFile ? fs.createWriteStream(opts.logFile, { flags: 'a' }) : process.stdout,",
          "50:     }));",
          "51:   }",
          "55:   if (opts.configPath) {",
          "56:     configPath = path.resolve(opts.configPath);",
          "57:     try {",
          "",
          "[Removed Lines]",
          "34:   var app = express().disable('x-powered-by'),",
          "35:       serving = {",
          "36:         styles: {},",
          "37:         rendered: {},",
          "38:         data: {},",
          "39:         fonts: {}",
          "40:       };",
          "45:     var defaultLogFormat = process.env.NODE_ENV == 'production' ? 'tiny' : 'dev';",
          "46:     var logFormat = opts.logFormat || defaultLogFormat;",
          "49:       skip: function(req, res) { return opts.silent && (res.statusCode == 200 || res.statusCode == 304) }",
          "53:   var config = opts.config || null;",
          "54:   var configPath = null;",
          "",
          "[Added Lines]",
          "34:   const app = express().disable('x-powered-by'),",
          "35:     serving = {",
          "36:       styles: {},",
          "37:       rendered: {},",
          "38:       data: {},",
          "39:       fonts: {}",
          "40:     };",
          "45:     const defaultLogFormat = process.env.NODE_ENV === 'production' ? 'tiny' : 'dev';",
          "46:     const logFormat = opts.logFormat || defaultLogFormat;",
          "49:       skip: (req, res) => opts.silent && (res.statusCode === 200 || res.statusCode === 304)",
          "53:   let config = opts.config || null;",
          "54:   let configPath = null;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "67:     process.exit(1);",
          "68:   }",
          "72:   options.paths = paths;",
          "73:   paths.root = path.resolve(",
          "74:     configPath ? path.dirname(configPath) : process.cwd(),",
          "",
          "[Removed Lines]",
          "70:   var options = config.options || {};",
          "71:   var paths = options.paths || {};",
          "",
          "[Added Lines]",
          "70:   const options = config.options || {};",
          "71:   const paths = options.paths || {};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "78:   paths.sprites = path.resolve(paths.root, paths.sprites || '');",
          "79:   paths.mbtiles = path.resolve(paths.root, paths.mbtiles || '');",
          "84:     if (!fs.existsSync(paths[type])) {",
          "86:       process.exit(1);",
          "87:     }",
          "88:   };",
          "",
          "[Removed Lines]",
          "81:   var startupPromises = [];",
          "83:   var checkPath = function(type) {",
          "85:       console.error('The specified path for \"' + type + '\" does not exist (' + paths[type] + ').');",
          "",
          "[Added Lines]",
          "81:   const startupPromises = [];",
          "83:   const checkPath = type => {",
          "85:       console.error(`The specified path for \"${type}\" does not exist (${paths[type]}).`);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "97:     } catch (e) {}",
          "98:   }",
          "102:   if (opts.cors) {",
          "103:     app.use(cors());",
          "104:   }",
          "111:     }",
          "113:     if (item.serve_data !== false) {",
          "114:       startupPromises.push(serve_style(options, serving.styles, item, id, opts.publicUrl,",
          "118:             if (fromData) {",
          "120:                 dataItemId = id;",
          "121:               }",
          "122:             } else {",
          "124:                 dataItemId = id;",
          "125:               }",
          "126:             }",
          "128:           if (dataItemId) { // mbtiles exist in the data config",
          "129:             return dataItemId;",
          "130:           } else if (fromData) {",
          "132:             process.exit(1);",
          "133:           } else {",
          "135:             while (data[id]) id += '_';",
          "136:             data[id] = {",
          "137:               'mbtiles': mbtiles",
          "138:             };",
          "139:             return id;",
          "140:           }",
          "142:           serving.fonts[font] = true;",
          "144:           app.use('/styles/', sub);",
          "145:         }));",
          "146:     }",
          "",
          "[Removed Lines]",
          "100:   var data = clone(config.data || {});",
          "106:   Object.keys(config.styles || {}).forEach(function(id) {",
          "107:     var item = config.styles[id];",
          "108:     if (!item.style || item.style.length == 0) {",
          "109:       console.log('Missing \"style\" property for ' + id);",
          "110:       return;",
          "115:         function(mbtiles, fromData) {",
          "116:           var dataItemId;",
          "117:           Object.keys(data).forEach(function(id) {",
          "119:               if (id == mbtiles) {",
          "123:               if (data[id].mbtiles == mbtiles) {",
          "127:           });",
          "131:             console.log('ERROR: data \"' + mbtiles + '\" not found!');",
          "134:             var id = mbtiles.substr(0, mbtiles.lastIndexOf('.')) || mbtiles;",
          "141:         }, function(font) {",
          "143:         }).then(function(sub) {",
          "",
          "[Added Lines]",
          "100:   const data = clone(config.data || {});",
          "106:   for (const id of Object.keys(config.styles || {})) {",
          "107:     const item = config.styles[id];",
          "108:     if (!item.style || item.style.length === 0) {",
          "109:       console.log(`Missing \"style\" property for ${id}`);",
          "110:       continue;",
          "115:         (mbtiles, fromData) => {",
          "116:           let dataItemId;",
          "117:           for (const id of Object.keys(data)) {",
          "119:               if (id === mbtiles) {",
          "123:               if (data[id].mbtiles === mbtiles) {",
          "127:           }",
          "131:             console.log(`ERROR: data \"${mbtiles}\" not found!`);",
          "134:             let id = mbtiles.substr(0, mbtiles.lastIndexOf('.')) || mbtiles;",
          "141:         }, font => {",
          "143:         }).then(sub => {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "148:       if (serve_rendered) {",
          "149:         startupPromises.push(",
          "150:           serve_rendered(options, serving.rendered, item, id, opts.publicUrl,",
          "155:                   mbtilesFile = data[id].mbtiles;",
          "156:                 }",
          "158:               return mbtilesFile;",
          "159:             }",
          "161:             app.use('/styles/', sub);",
          "162:           })",
          "163:         );",
          "",
          "[Removed Lines]",
          "151:             function(mbtiles) {",
          "152:               var mbtilesFile;",
          "153:               Object.keys(data).forEach(function(id) {",
          "154:                 if (id == mbtiles) {",
          "157:               });",
          "160:           ).then(function(sub) {",
          "",
          "[Added Lines]",
          "151:             mbtiles => {",
          "152:               let mbtilesFile;",
          "153:               for (const id of Object.keys(data)) {",
          "154:                 if (id === mbtiles) {",
          "157:               }",
          "160:           ).then(sub => {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "165:         item.serve_rendered = false;",
          "166:       }",
          "167:     }",
          "170:   startupPromises.push(",
          "172:       app.use('/', sub);",
          "173:     })",
          "174:   );",
          "181:     }",
          "183:     startupPromises.push(",
          "185:         app.use('/data/', sub);",
          "186:       })",
          "187:     );",
          "195:       result.push({",
          "196:         version: styleJSON.version,",
          "197:         name: styleJSON.name,",
          "198:         id: id,",
          "201:       });",
          "203:     res.send(result);",
          "204:   });",
          "212:       } else {",
          "214:       }",
          "215:       info.tiles = utils.getTileUrls(req, info.tiles, path, info.format, opts.publicUrl, {",
          "216:         'pbf': options.pbfAlias",
          "217:       });",
          "218:       arr.push(info);",
          "220:     return arr;",
          "221:   };",
          "224:     res.send(addTileJSONs([], req, 'rendered'));",
          "225:   });",
          "227:     res.send(addTileJSONs([], req, 'data'));",
          "228:   });",
          "230:     res.send(addTileJSONs(addTileJSONs([], req, 'rendered'), req, 'data'));",
          "231:   });",
          "",
          "[Removed Lines]",
          "168:   });",
          "171:     serve_font(options, serving.fonts).then(function(sub) {",
          "176:   Object.keys(data).forEach(function(id) {",
          "177:     var item = data[id];",
          "178:     if (!item.mbtiles || item.mbtiles.length == 0) {",
          "179:       console.log('Missing \"mbtiles\" property for ' + id);",
          "180:       return;",
          "184:       serve_data(options, serving.data, item, id, serving.styles, opts.publicUrl).then(function(sub) {",
          "188:   });",
          "190:   app.get('/styles.json', function(req, res, next) {",
          "191:     var result = [];",
          "192:     var query = req.query.key ? ('?key=' + req.query.key) : '';",
          "193:     Object.keys(serving.styles).forEach(function(id) {",
          "194:       var styleJSON = serving.styles[id];",
          "199:         url: utils.getPublicUrl(opts.publicUrl, req) +",
          "200:              'styles/' + id + '/style.json' + query",
          "202:     });",
          "206:   var addTileJSONs = function(arr, req, type) {",
          "207:     Object.keys(serving[type]).forEach(function(id) {",
          "208:       var info = clone(serving[type][id]);",
          "209:       var path = '';",
          "210:       if (type == 'rendered') {",
          "211:         path = 'styles/' + id;",
          "213:         path = type + '/' + id;",
          "219:     });",
          "223:   app.get('/rendered.json', function(req, res, next) {",
          "226:   app.get('/data.json', function(req, res, next) {",
          "229:   app.get('/index.json', function(req, res, next) {",
          "",
          "[Added Lines]",
          "168:   }",
          "171:     serve_font(options, serving.fonts).then(sub => {",
          "176:   for (const id of Object.keys(data)) {",
          "177:     const item = data[id];",
          "178:     if (!item.mbtiles || item.mbtiles.length === 0) {",
          "179:       console.log(`Missing \"mbtiles\" property for ${id}`);",
          "180:       continue;",
          "184:       serve_data(options, serving.data, item, id, serving.styles, opts.publicUrl).then(sub => {",
          "188:   }",
          "190:   app.get('/styles.json', (req, res, next) => {",
          "191:     const result = [];",
          "192:     const query = req.query.key ? (`?key=${req.query.key}`) : '';",
          "193:     for (const id of Object.keys(serving.styles)) {",
          "194:       const styleJSON = serving.styles[id];",
          "199:         url: `${utils.getPublicUrl(opts.publicUrl, req)}styles/${id}/style.json${query}`",
          "201:     }",
          "205:   const addTileJSONs = (arr, req, type) => {",
          "206:     for (const id of Object.keys(serving[type])) {",
          "207:       const info = clone(serving[type][id]);",
          "208:       let path = '';",
          "209:       if (type === 'rendered') {",
          "210:         path = `styles/${id}`;",
          "212:         path = `${type}/${id}`;",
          "218:     }",
          "222:   app.get('/rendered.json', (req, res, next) => {",
          "225:   app.get('/data.json', (req, res, next) => {",
          "228:   app.get('/index.json', (req, res, next) => {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "235:   app.use('/', express.static(path.join(__dirname, '../public/resources')));",
          "241:       if (options.frontPage === false) {",
          "242:         return;",
          "243:       } else if (options.frontPage &&",
          "245:         templateFile = path.resolve(paths.root, options.frontPage);",
          "246:       }",
          "247:     }",
          "250:         if (err) {",
          "252:           reject(err);",
          "253:           return;",
          "254:         }",
          "259:           if (dataGetter) {",
          "260:             data = dataGetter(req);",
          "261:             if (!data) {",
          "262:               return res.status(404).send('Not found');",
          "263:             }",
          "264:           }",
          "266:           data['public_url'] = opts.publicUrl || '/';",
          "267:           data['is_light'] = isLight;",
          "268:           data['key_query_part'] =",
          "271:           if (template === 'wmts') res.set('Content-Type', 'text/xml');",
          "272:           return res.status(200).send(compiled(data));",
          "273:         });",
          "",
          "[Removed Lines]",
          "237:   var templates = path.join(__dirname, '../public/templates');",
          "238:   var serveTemplate = function(urlPath, template, dataGetter) {",
          "239:     var templateFile = templates + '/' + template + '.tmpl';",
          "240:     if (template == 'index') {",
          "244:                  options.frontPage.constructor === String) {",
          "248:     startupPromises.push(new Promise(function(resolve, reject) {",
          "249:       fs.readFile(templateFile, function(err, content) {",
          "251:           err = new Error('Template not found: ' + err.message);",
          "255:         var compiled = handlebars.compile(content.toString());",
          "257:         app.use(urlPath, function(req, res, next) {",
          "258:           var data = {};",
          "265:           data['server_version'] = packageJson.name + ' v' + packageJson.version;",
          "269:               req.query.key ? 'key=' + req.query.key + '&amp;' : '';",
          "270:           data['key_query'] = req.query.key ? '?key=' + req.query.key : '';",
          "",
          "[Added Lines]",
          "236:   const templates = path.join(__dirname, '../public/templates');",
          "237:   const serveTemplate = (urlPath, template, dataGetter) => {",
          "238:     let templateFile = `${templates}/${template}.tmpl`;",
          "239:     if (template === 'index') {",
          "243:         options.frontPage.constructor === String) {",
          "247:     startupPromises.push(new Promise((resolve, reject) => {",
          "248:       fs.readFile(templateFile, (err, content) => {",
          "250:           err = new Error(`Template not found: ${err.message}`);",
          "254:         const compiled = handlebars.compile(content.toString());",
          "256:         app.use(urlPath, (req, res, next) => {",
          "257:           let data = {};",
          "264:           data['server_version'] = `${packageJson.name} v${packageJson.version}`;",
          "268:             req.query.key ? `key=${req.query.key}&amp;` : '';",
          "269:           data['key_query'] = req.query.key ? `?key=${req.query.key}` : '';",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "276:     }));",
          "277:   };",
          "283:       style.name = (serving.styles[id] || serving.rendered[id] || {}).name;",
          "284:       style.serving_data = serving.styles[id];",
          "285:       style.serving_rendered = serving.rendered[id];",
          "286:       if (style.serving_rendered) {",
          "288:         if (center) {",
          "297:         }",
          "303:       }",
          "309:       if (center) {",
          "313:       }",
          "315:       if (!data_.is_vector) {",
          "316:         if (center) {",
          "321:         }",
          "328:       }",
          "329:       if (data_.filesize) {",
          "332:         if (size > 1024) {",
          "333:           suffix = 'MB';",
          "334:           size /= 1024;",
          "",
          "[Removed Lines]",
          "279:   serveTemplate('/$', 'index', function(req) {",
          "280:     var styles = clone(config.styles || {});",
          "281:     Object.keys(styles).forEach(function(id) {",
          "282:       var style = styles[id];",
          "287:         var center = style.serving_rendered.center;",
          "289:           style.viewer_hash = '#' + center[2] + '/' +",
          "290:                               center[1].toFixed(5) + '/' +",
          "291:                               center[0].toFixed(5);",
          "293:           var centerPx = mercator.px([center[0], center[1]], center[2]);",
          "294:           style.thumbnail = center[2] + '/' +",
          "295:               Math.floor(centerPx[0] / 256) + '/' +",
          "296:               Math.floor(centerPx[1] / 256) + '.png';",
          "299:         var tiles = utils.getTileUrls(",
          "300:             req, style.serving_rendered.tiles,",
          "301:             'styles/' + id, style.serving_rendered.format, opts.publicUrl);",
          "302:         style.xyz_link = tiles[0];",
          "304:     });",
          "305:     var data = clone(serving.data || {});",
          "306:     Object.keys(data).forEach(function(id) {",
          "307:       var data_ = data[id];",
          "308:       var center = data_.center;",
          "310:         data_.viewer_hash = '#' + center[2] + '/' +",
          "311:                             center[1].toFixed(5) + '/' +",
          "312:                             center[0].toFixed(5);",
          "314:       data_.is_vector = data_.format == 'pbf';",
          "317:           var centerPx = mercator.px([center[0], center[1]], center[2]);",
          "318:           data_.thumbnail = center[2] + '/' +",
          "319:               Math.floor(centerPx[0] / 256) + '/' +",
          "320:               Math.floor(centerPx[1] / 256) + '.' + data_.format;",
          "323:         var tiles = utils.getTileUrls(",
          "324:             req, data_.tiles, 'data/' + id, data_.format, opts.publicUrl, {",
          "325:               'pbf': options.pbfAlias",
          "326:             });",
          "327:         data_.xyz_link = tiles[0];",
          "330:         var suffix = 'kB';",
          "331:         var size = parseInt(data_.filesize, 10) / 1024;",
          "",
          "[Added Lines]",
          "278:   serveTemplate('/$', 'index', req => {",
          "279:     const styles = clone(config.styles || {});",
          "280:     for (const id of Object.keys(styles)) {",
          "281:       const style = styles[id];",
          "286:         const center = style.serving_rendered.center;",
          "288:           style.viewer_hash = `#${center[2]}/${center[1].toFixed(5)}/${center[0].toFixed(5)}`;",
          "290:           const centerPx = mercator.px([center[0], center[1]], center[2]);",
          "291:           style.thumbnail = `${center[2]}/${Math.floor(centerPx[0] / 256)}/${Math.floor(centerPx[1] / 256)}.png`;",
          "294:         style.xyz_link = utils.getTileUrls(",
          "295:           req, style.serving_rendered.tiles,",
          "296:           `styles/${id}`, style.serving_rendered.format, opts.publicUrl)[0];",
          "298:     }",
          "299:     const data = clone(serving.data || {});",
          "300:     for (const id of Object.keys(data)) {",
          "301:       const data_ = data[id];",
          "302:       const center = data_.center;",
          "304:         data_.viewer_hash = `#${center[2]}/${center[1].toFixed(5)}/${center[0].toFixed(5)}`;",
          "306:       data_.is_vector = data_.format === 'pbf';",
          "309:           const centerPx = mercator.px([center[0], center[1]], center[2]);",
          "310:           data_.thumbnail = `${center[2]}/${Math.floor(centerPx[0] / 256)}/${Math.floor(centerPx[1] / 256)}.${data_.format}`;",
          "313:         data_.xyz_link = utils.getTileUrls(",
          "314:           req, data_.tiles, `data/${id}`, data_.format, opts.publicUrl, {",
          "315:             'pbf': options.pbfAlias",
          "316:           })[0];",
          "319:         let suffix = 'kB';",
          "320:         let size = parseInt(data_.filesize, 10) / 1024;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "337:           suffix = 'GB';",
          "338:           size /= 1024;",
          "339:         }",
          "341:       }",
          "343:     return {",
          "344:       styles: Object.keys(styles).length ? styles : null,",
          "345:       data: Object.keys(data).length ? data : null",
          "346:     };",
          "347:   });",
          "352:     if (!style) {",
          "353:       return null;",
          "354:     }",
          "",
          "[Removed Lines]",
          "340:         data_.formatted_filesize = size.toFixed(2) + ' ' + suffix;",
          "342:     });",
          "349:   serveTemplate('/styles/:id/$', 'viewer', function(req) {",
          "350:     var id = req.params.id;",
          "351:     var style = clone((config.styles || {})[id]);",
          "",
          "[Added Lines]",
          "329:         data_.formatted_filesize = `${size.toFixed(2)} ${suffix}`;",
          "331:     }",
          "338:   serveTemplate('/styles/:id/$', 'viewer', req => {",
          "339:     const id = req.params.id;",
          "340:     const style = clone((config.styles || {})[id]);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "364:     return res.redirect(301, '/styles/' + req.params.id + '/');",
          "365:   });",
          "370:     if (!wmts) {",
          "371:       return null;",
          "372:     }",
          "",
          "[Removed Lines]",
          "367:   serveTemplate('/styles/:id/wmts.xml', 'wmts', function(req) {",
          "368:     var id = req.params.id;",
          "369:     var wmts = clone((config.styles || {})[id]);",
          "",
          "[Added Lines]",
          "356:   serveTemplate('/styles/:id/wmts.xml', 'wmts', req => {",
          "357:     const id = req.params.id;",
          "358:     const wmts = clone((config.styles || {})[id]);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "375:     }",
          "376:     wmts.id = id;",
          "377:     wmts.name = (serving.styles[id] || serving.rendered[id]).name;",
          "379:     return wmts;",
          "380:   });",
          "385:     if (!data) {",
          "386:       return null;",
          "387:     }",
          "388:     data.id = id;",
          "390:     return data;",
          "391:   });",
          "395:     console.log('Startup complete');",
          "396:     startupComplete = true;",
          "397:   });",
          "399:     if (startupComplete) {",
          "400:       return res.status(200).send('OK');",
          "401:     } else {",
          "",
          "[Removed Lines]",
          "378:     wmts.baseUrl = (req.get('X-Forwarded-Protocol')?req.get('X-Forwarded-Protocol'):req.protocol) + '://' + req.get('host');",
          "382:   serveTemplate('/data/:id/$', 'data', function(req) {",
          "383:     var id = req.params.id;",
          "384:     var data = clone(serving.data[id]);",
          "389:     data.is_vector = data.format == 'pbf';",
          "393:   var startupComplete = false;",
          "394:   var startupPromise = Promise.all(startupPromises).then(function() {",
          "398:   app.get('/health', function(req, res, next) {",
          "",
          "[Added Lines]",
          "367:     wmts.baseUrl = `${req.get('X-Forwarded-Protocol') ? req.get('X-Forwarded-Protocol') : req.protocol}://${req.get('host')}`;",
          "371:   serveTemplate('/data/:id/$', 'data', req => {",
          "372:     const id = req.params.id;",
          "373:     const data = clone(serving.data[id]);",
          "378:     data.is_vector = data.format === 'pbf';",
          "382:   let startupComplete = false;",
          "383:   const startupPromise = Promise.all(startupPromises).then(() => {",
          "387:   app.get('/health', (req, res, next) => {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "403:     }",
          "404:   });",
          "408:     if (address.indexOf('::') === 0) {",
          "410:     }",
          "412:   });",
          "",
          "[Removed Lines]",
          "406:   var server = app.listen(process.env.PORT || opts.port, process.env.BIND || opts.bind, function() {",
          "407:     var address = this.address().address;",
          "409:       address = '[' + address + ']'; // literal IPv6 address",
          "411:     console.log('Listening at http://%s:%d/', address, this.address().port);",
          "",
          "[Added Lines]",
          "395:   const server = app.listen(process.env.PORT || opts.port, process.env.BIND || opts.bind, function () {",
          "396:     let address = this.address().address;",
          "398:       address = `[${address}]`; // literal IPv6 address",
          "400:     console.log(`Listening at http://${address}:${this.address().port}/`);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "421:   };",
          "422: }",
          "428:     console.error(err.message);",
          "429:     process.exit(1);",
          "430:   });",
          "433:     process.exit();",
          "434:   });",
          "437:     console.log('Stopping server and reloading config');",
          "441:         delete require.cache[key];",
          "442:       }",
          "445:       running.server = restarted.server;",
          "446:       running.app = restarted.app;",
          "447:     });",
          "",
          "[Removed Lines]",
          "424: module.exports = function(opts) {",
          "425:   var running = start(opts);",
          "427:   running.startupPromise.catch(function(err) {",
          "432:   process.on('SIGINT', function() {",
          "436:   process.on('SIGHUP', function() {",
          "439:     running.server.shutdown(function() {",
          "440:       for (var key in require.cache) {",
          "444:       var restarted = start(opts);",
          "",
          "[Added Lines]",
          "413: module.exports = opts => {",
          "414:   const running = start(opts);",
          "416:   running.startupPromise.catch(err => {",
          "421:   process.on('SIGINT', () => {",
          "425:   process.on('SIGHUP', () => {",
          "428:     running.server.shutdown(() => {",
          "429:       for (const key in require.cache) {",
          "433:       const restarted = start(opts);",
          "",
          "---------------"
        ],
        "src/utils.js||src/utils.js": [
          "File: src/utils.js -> src/utils.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: 'use strict';",
          "16:   if (domains) {",
          "17:     if (domains.constructor === String && domains.length > 0) {",
          "18:       domains = domains.split(',');",
          "19:     }",
          "26:       if (domain.indexOf('*') !== -1) {",
          "27:         if (relativeSubdomainsUsable) {",
          "29:           newParts.unshift(domain.replace('*', hostParts[0]));",
          "30:           newDomains.push(newParts.join('.'));",
          "31:         }",
          "32:       } else {",
          "33:         newDomains.push(domain);",
          "34:       }",
          "36:     domains = newDomains;",
          "37:   }",
          "38:   if (!domains || domains.length == 0) {",
          "39:     domains = [req.headers.host];",
          "40:   }",
          "44:   if (req.query.key) {",
          "46:   }",
          "47:   if (req.query.style) {",
          "49:   }",
          "52:   if (aliases && aliases[format]) {",
          "53:     format = aliases[format];",
          "54:   }",
          "57:   if (!publicUrl) {",
          "62:   } else {",
          "64:   }",
          "66:   return uris;",
          "67: };",
          "70:   if (tileJSON.bounds && !tileJSON.center) {",
          "73:     tileJSON.center = [",
          "74:       (tileJSON.bounds[0] + tileJSON.bounds[2]) / 2,",
          "75:       (tileJSON.bounds[1] + tileJSON.bounds[3]) / 2,",
          "",
          "[Removed Lines]",
          "3: var path = require('path'),",
          "4:     fs = require('fs');",
          "6: var clone = require('clone'),",
          "7:     glyphCompose = require('glyph-pbf-composite');",
          "10: module.exports.getPublicUrl = function(publicUrl, req) {",
          "11:   return publicUrl || (req.protocol + '://' + req.headers.host + '/')",
          "12: }",
          "14: module.exports.getTileUrls = function(req, domains, path, format, publicUrl, aliases) {",
          "20:     var host = req.headers.host;",
          "21:     var hostParts = host.split('.');",
          "22:     var relativeSubdomainsUsable = hostParts.length > 1 &&",
          "23:         !/^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\:[0-9]+)?$/.test(host);",
          "24:     var newDomains = [];",
          "25:     domains.forEach(function(domain) {",
          "28:           var newParts = hostParts.slice(1);",
          "35:     });",
          "42:   var key = req.query.key;",
          "43:   var queryParams = [];",
          "45:     queryParams.push('key=' + req.query.key);",
          "48:     queryParams.push('style=' + req.query.style);",
          "50:   var query = queryParams.length > 0 ? ('?' + queryParams.join('&')) : '';",
          "56:   var uris = [];",
          "58:     domains.forEach(function(domain) {",
          "59:       uris.push(req.protocol + '://' + domain + '/' + path +",
          "60:                 '/{z}/{x}/{y}.' + format + query);",
          "61:     });",
          "63:     uris.push(publicUrl + path + '/{z}/{x}/{y}.' + format + query)",
          "69: module.exports.fixTileJSONCenter = function(tileJSON) {",
          "71:     var fitWidth = 1024;",
          "72:     var tiles = fitWidth / 256;",
          "",
          "[Added Lines]",
          "3: const path = require('path');",
          "4: const fs = require('fs');",
          "6: const clone = require('clone');",
          "7: const glyphCompose = require('glyph-pbf-composite');",
          "10: module.exports.getPublicUrl = (publicUrl, req) => publicUrl || `${req.protocol}://${req.headers.host}/`;",
          "12: module.exports.getTileUrls = (req, domains, path, format, publicUrl, aliases) => {",
          "18:     const host = req.headers.host;",
          "19:     const hostParts = host.split('.');",
          "20:     const relativeSubdomainsUsable = hostParts.length > 1 &&",
          "21:       !/^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\:[0-9]+)?$/.test(host);",
          "22:     const newDomains = [];",
          "23:     for (const domain of domains) {",
          "26:           const newParts = hostParts.slice(1);",
          "33:     }",
          "40:   const key = req.query.key;",
          "41:   const queryParams = [];",
          "43:     queryParams.push(`key=${req.query.key}`);",
          "46:     queryParams.push(`style=${req.query.style}`);",
          "48:   const query = queryParams.length > 0 ? (`?${queryParams.join('&')}`) : '';",
          "54:   const uris = [];",
          "56:     for (const domain of domains) {",
          "57:       uris.push(`${req.protocol}://${domain}/${path}/{z}/{x}/{y}.${format}${query}`);",
          "58:     }",
          "60:     uris.push(`${publicUrl}${path}/{z}/{x}/{y}.${format}${query}`)",
          "66: module.exports.fixTileJSONCenter = tileJSON => {",
          "68:     const fitWidth = 1024;",
          "69:     const tiles = fitWidth / 256;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:   }",
          "82: };",
          "103:             if (!fallbacks[fallbackName]) {",
          "108:             }",
          "115:           }",
          "116:         } else {",
          "118:         }",
          "130:     queue.push(",
          "131:       getFontPbf(allowedFonts, fontPath, font, range, clone(allowedFonts || fallbacks))",
          "132:     );",
          "138: };",
          "",
          "[Removed Lines]",
          "84: var getFontPbf = function(allowedFonts, fontPath, name, range, fallbacks) {",
          "85:   return new Promise(function(resolve, reject) {",
          "86:     if (!allowedFonts || (allowedFonts[name] && fallbacks)) {",
          "87:       var filename = path.join(fontPath, name, range + '.pbf');",
          "88:       if (!fallbacks) {",
          "89:         fallbacks = clone(allowedFonts || {});",
          "90:       }",
          "91:       delete fallbacks[name];",
          "92:       fs.readFile(filename, function(err, data) {",
          "93:         if (err) {",
          "94:           console.error('ERROR: Font not found:', name);",
          "95:           if (fallbacks && Object.keys(fallbacks).length) {",
          "96:             var fallbackName;",
          "98:             var fontStyle = name.split(' ').pop();",
          "99:             if (['Regular', 'Bold', 'Italic'].indexOf(fontStyle) < 0) {",
          "100:               fontStyle = 'Regular';",
          "101:             }",
          "102:             fallbackName = 'Noto Sans ' + fontStyle;",
          "104:               fallbackName = 'Open Sans ' + fontStyle;",
          "105:               if (!fallbacks[fallbackName]) {",
          "106:                 fallbackName = Object.keys(fallbacks)[0];",
          "107:               }",
          "110:             console.error('ERROR: Trying to use', fallbackName, 'as a fallback');",
          "111:             delete fallbacks[fallbackName];",
          "112:             getFontPbf(null, fontPath, fallbackName, range, fallbacks).then(resolve, reject);",
          "113:           } else {",
          "114:             reject('Font load error: ' + name);",
          "117:           resolve(data);",
          "119:       });",
          "120:     } else {",
          "121:       reject('Font not allowed: ' + name);",
          "122:     }",
          "123:   });",
          "124: };",
          "126: module.exports.getFontsPbf = function(allowedFonts, fontPath, names, range, fallbacks) {",
          "127:   var fonts = names.split(',');",
          "128:   var queue = [];",
          "129:   fonts.forEach(function(font) {",
          "133:   });",
          "135:   return Promise.all(queue).then(function(values) {",
          "136:     return glyphCompose.combine(values);",
          "137:   });",
          "",
          "[Added Lines]",
          "81: const getFontPbf = (allowedFonts, fontPath, name, range, fallbacks) => new Promise((resolve, reject) => {",
          "82:   if (!allowedFonts || (allowedFonts[name] && fallbacks)) {",
          "83:     const filename = path.join(fontPath, name, `${range}.pbf`);",
          "84:     if (!fallbacks) {",
          "85:       fallbacks = clone(allowedFonts || {});",
          "86:     }",
          "87:     delete fallbacks[name];",
          "88:     fs.readFile(filename, (err, data) => {",
          "89:       if (err) {",
          "90:         console.error(`ERROR: Font not found: ${name}`);",
          "91:         if (fallbacks && Object.keys(fallbacks).length) {",
          "92:           let fallbackName;",
          "94:           let fontStyle = name.split(' ').pop();",
          "95:           if (['Regular', 'Bold', 'Italic'].indexOf(fontStyle) < 0) {",
          "96:             fontStyle = 'Regular';",
          "97:           }",
          "98:           fallbackName = `Noto Sans ${fontStyle}`;",
          "99:           if (!fallbacks[fallbackName]) {",
          "100:             fallbackName = `Open Sans ${fontStyle}`;",
          "102:               fallbackName = Object.keys(fallbacks)[0];",
          "106:           console.error(`ERROR: Trying to use ${fallbackName} as a fallback`);",
          "107:           delete fallbacks[fallbackName];",
          "108:           getFontPbf(null, fontPath, fallbackName, range, fallbacks).then(resolve, reject);",
          "110:           reject(`Font load error: ${name}`);",
          "112:       } else {",
          "113:         resolve(data);",
          "114:       }",
          "115:     });",
          "116:   } else {",
          "117:     reject(`Font not allowed: ${name}`);",
          "118:   }",
          "119: });",
          "121: module.exports.getFontsPbf = (allowedFonts, fontPath, names, range, fallbacks) => {",
          "122:   const fonts = names.split(',');",
          "123:   const queue = [];",
          "124:   for (const font of fonts) {",
          "128:   }",
          "130:   return Promise.all(queue).then(values => glyphCompose.combine(values));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
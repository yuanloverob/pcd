{
  "cve_id": "CVE-2020-35871",
  "cve_desc": "An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via an Auxdata API data race.",
  "repo": "rusqlite/rusqlite",
  "patch_hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
  "patch_info": {
    "commit_hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
    "repo": "rusqlite/rusqlite",
    "commit_url": "https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
    "files": [
      "src/functions.rs"
    ],
    "message": "Actually fix auxdata api...",
    "before_after_code_files": [
      "src/functions.rs||src/functions.rs"
    ]
  },
  "patch_diff": {
    "src/functions.rs||src/functions.rs": [
      "File: src/functions.rs -> src/functions.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "71: use std::os::raw::{c_int, c_void};",
      "72: use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};",
      "73: use std::ptr;",
      "74: use std::slice;",
      "76: use crate::ffi;",
      "77: use crate::ffi::sqlite3_context;",
      "",
      "[Removed Lines]",
      "70: use std::any::TypeId;",
      "",
      "[Added Lines]",
      "57: use std::any::Any;",
      "62: use std::sync::Arc;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "174:         unsafe { ValueRef::from_value(arg) }",
      "175:     }",
      "185:         unsafe {",
      "186:             ffi::sqlite3_set_auxdata(",
      "187:                 self.ctx,",
      "188:                 arg,",
      "191:             )",
      "192:         };",
      "193:     }",
      "200:         if p.is_null() {",
      "201:             Ok(None)",
      "202:         } else {",
      "209:         }",
      "210:     }",
      "211: }",
      "",
      "[Removed Lines]",
      "180:     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {",
      "181:         let boxed = Box::into_raw(Box::new(AuxData {",
      "182:             id: TypeId::of::<T>(),",
      "183:             value,",
      "184:         }));",
      "189:                 boxed as *mut c_void,",
      "190:                 Some(free_boxed_value::<AuxData<T>>),",
      "198:     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {",
      "199:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };",
      "203:             let id = unsafe { (*p).id };",
      "204:             if TypeId::of::<T>() != id {",
      "205:                 Err(Error::GetAuxWrongType)",
      "206:             } else {",
      "207:                 Ok(Some(unsafe { &(*p).value }))",
      "208:             }",
      "213: #[repr(C)]",
      "214: struct AuxData<T: 'static> {",
      "215:     id: TypeId,",
      "216:     value: T,",
      "217: }",
      "",
      "[Added Lines]",
      "166:     pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>",
      "167:     where",
      "168:         T: Send + Sync + 'static,",
      "169:         E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,",
      "170:         F: FnOnce(ValueRef<'_>) -> Result<T, E>,",
      "171:     {",
      "172:         if let Some(v) = self.get_aux(arg)? {",
      "173:             Ok(v)",
      "174:         } else {",
      "175:             let vr = self.get_raw(arg as usize);",
      "176:             self.set_aux(",
      "177:                 arg,",
      "178:                 func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,",
      "179:             )",
      "180:         }",
      "181:     }",
      "186:     pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {",
      "187:         let orig: Arc<T> = Arc::new(value);",
      "188:         let inner: AuxInner = orig.clone();",
      "189:         let outer = Box::new(inner);",
      "190:         let raw: *mut AuxInner = Box::into_raw(outer);",
      "195:                 raw as *mut _,",
      "196:                 Some(free_boxed_value::<AuxInner>),",
      "199:         Ok(orig)",
      "206:     pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {",
      "207:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };",
      "211:             let v: AuxInner = AuxInner::clone(unsafe { &*p });",
      "212:             v.downcast::<T>()",
      "213:                 .map(Some)",
      "214:                 .map_err(|_| Error::GetAuxWrongType)",
      "219: type AuxInner = Arc<dyn Any + Send + Sync + 'static>;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "777:     fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {",
      "778:         assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");",
      "792:         let is_match = {",
      "795:             let text = ctx",
      "796:                 .get_raw(1)",
      "797:                 .as_str()",
      "798:                 .map_err(|e| Error::UserFunctionError(e.into()))?;",
      "801:         };",
      "807:         Ok(is_match)",
      "808:     }",
      "",
      "[Removed Lines]",
      "780:         let saved_re: Option<&Regex> = ctx.get_aux(0)?;",
      "781:         let new_re = match saved_re {",
      "782:             None => {",
      "783:                 let s = ctx.get::<String>(0)?;",
      "784:                 match Regex::new(&s) {",
      "785:                     Ok(r) => Some(r),",
      "786:                     Err(err) => return Err(Error::UserFunctionError(Box::new(err))),",
      "787:                 }",
      "788:             }",
      "789:             Some(_) => None,",
      "790:         };",
      "793:             let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());",
      "800:             re.is_match(text)",
      "803:         if let Some(re) = new_re {",
      "804:             ctx.set_aux(0, re);",
      "805:         }",
      "",
      "[Added Lines]",
      "781:         type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;",
      "782:         let regexp: std::sync::Arc<Regex> = ctx",
      "783:             .get_or_create_aux(0, |vr| -> Result<_, BoxError> {",
      "784:                 Ok(Regex::new(vr.as_str()?)?)",
      "785:             })?;",
      "793:             regexp.is_match(text)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "878:         let db = Connection::open_in_memory().unwrap();",
      "879:         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {",
      "880:             if !ctx.get::<bool>(1)? {",
      "882:             } else {",
      "883:                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));",
      "885:             }",
      "886:             Ok(true)",
      "887:         })",
      "",
      "[Removed Lines]",
      "881:                 ctx.set_aux::<i64>(0, 100);",
      "884:                 assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));",
      "",
      "[Added Lines]",
      "870:                 ctx.set_aux::<i64>(0, 100)?;",
      "873:                 assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1b27ce0541a136b50492a816550e170b9913803f",
      "candidate_info": {
        "commit_hash": "1b27ce0541a136b50492a816550e170b9913803f",
        "repo": "rusqlite/rusqlite",
        "commit_url": "https://github.com/rusqlite/rusqlite/commit/1b27ce0541a136b50492a816550e170b9913803f",
        "files": [
          "src/functions.rs"
        ],
        "message": "Docs for new aux api",
        "before_after_code_files": [
          "src/functions.rs||src/functions.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/rusqlite/rusqlite/pull/701"
        ],
        "olp_code_files": {
          "patch": [
            "src/functions.rs||src/functions.rs"
          ],
          "candidate": [
            "src/functions.rs||src/functions.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/functions.rs||src/functions.rs": [
          "File: src/functions.rs -> src/functions.rs"
        ]
      }
    },
    {
      "candidate_hash": "da94f8eba66ba01fe54bc0673c705e3f7fb831eb",
      "candidate_info": {
        "commit_hash": "da94f8eba66ba01fe54bc0673c705e3f7fb831eb",
        "repo": "rusqlite/rusqlite",
        "commit_url": "https://github.com/rusqlite/rusqlite/commit/da94f8eba66ba01fe54bc0673c705e3f7fb831eb",
        "files": [
          "src/backup.rs",
          "src/blob/mod.rs",
          "src/blob/pos_io.rs",
          "src/busy.rs",
          "src/cache.rs",
          "src/collation.rs",
          "src/column.rs",
          "src/config.rs",
          "src/functions.rs",
          "src/hooks.rs",
          "src/lib.rs",
          "src/limits.rs",
          "src/pragma.rs",
          "src/row.rs",
          "src/session.rs",
          "src/statement.rs",
          "src/trace.rs",
          "src/transaction.rs",
          "src/types/chrono.rs",
          "src/types/from_sql.rs",
          "src/types/mod.rs",
          "src/types/serde_json.rs",
          "src/types/time.rs",
          "src/types/to_sql.rs",
          "src/types/url.rs",
          "src/unlock_notify.rs",
          "src/vtab/array.rs",
          "src/vtab/csvtab.rs",
          "src/vtab/series.rs",
          "tests/vtab.rs"
        ],
        "message": "Make tests return Result",
        "before_after_code_files": [
          "src/backup.rs||src/backup.rs",
          "src/blob/mod.rs||src/blob/mod.rs",
          "src/blob/pos_io.rs||src/blob/pos_io.rs",
          "src/busy.rs||src/busy.rs",
          "src/cache.rs||src/cache.rs",
          "src/collation.rs||src/collation.rs",
          "src/column.rs||src/column.rs",
          "src/config.rs||src/config.rs",
          "src/functions.rs||src/functions.rs",
          "src/hooks.rs||src/hooks.rs",
          "src/lib.rs||src/lib.rs",
          "src/limits.rs||src/limits.rs",
          "src/pragma.rs||src/pragma.rs",
          "src/row.rs||src/row.rs",
          "src/session.rs||src/session.rs",
          "src/statement.rs||src/statement.rs",
          "src/trace.rs||src/trace.rs",
          "src/transaction.rs||src/transaction.rs",
          "src/types/chrono.rs||src/types/chrono.rs",
          "src/types/from_sql.rs||src/types/from_sql.rs",
          "src/types/mod.rs||src/types/mod.rs",
          "src/types/serde_json.rs||src/types/serde_json.rs",
          "src/types/time.rs||src/types/time.rs",
          "src/types/to_sql.rs||src/types/to_sql.rs",
          "src/types/url.rs||src/types/url.rs",
          "src/unlock_notify.rs||src/unlock_notify.rs",
          "src/vtab/array.rs||src/vtab/array.rs",
          "src/vtab/csvtab.rs||src/vtab/csvtab.rs",
          "src/vtab/series.rs||src/vtab/series.rs",
          "tests/vtab.rs||tests/vtab.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/functions.rs||src/functions.rs"
          ],
          "candidate": [
            "src/functions.rs||src/functions.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/backup.rs||src/backup.rs": [
          "File: src/backup.rs -> src/backup.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "310: #[cfg(test)]",
          "311: mod test {",
          "312:     use super::Backup;",
          "314:     use std::time::Duration;",
          "316:     #[test]",
          "319:         let sql = \"BEGIN;",
          "320:                    CREATE TABLE foo(x INTEGER);",
          "321:                    INSERT INTO foo VALUES(42);",
          "322:                    END;\";",
          "327:         {",
          "330:         }",
          "335:         assert_eq!(42, the_answer);",
          "339:         {",
          "344:         }",
          "349:         assert_eq!(42 + 43, the_answer);",
          "350:     }",
          "352:     #[test]",
          "355:         let sql = \"BEGIN;",
          "356:                    CREATE TEMPORARY TABLE foo(x INTEGER);",
          "357:                    INSERT INTO foo VALUES(42);",
          "358:                    END;\";",
          "363:         {",
          "364:             let backup =",
          "368:         }",
          "373:         assert_eq!(42, the_answer);",
          "377:         {",
          "378:             let backup =",
          "384:         }",
          "389:         assert_eq!(42 + 43, the_answer);",
          "390:     }",
          "392:     #[test]",
          "395:         let sql = \"ATTACH DATABASE ':memory:' AS my_attached;",
          "396:                    BEGIN;",
          "397:                    CREATE TABLE my_attached.foo(x INTEGER);",
          "398:                    INSERT INTO my_attached.foo VALUES(42);",
          "399:                    END;\";",
          "404:         {",
          "405:             let backup = Backup::new_with_names(",
          "",
          "[Removed Lines]",
          "313:     use crate::{Connection, DatabaseName};",
          "317:     fn test_backup() {",
          "318:         let src = Connection::open_in_memory().unwrap();",
          "323:         src.execute_batch(sql).unwrap();",
          "325:         let mut dst = Connection::open_in_memory().unwrap();",
          "328:             let backup = Backup::new(&src, &mut dst).unwrap();",
          "329:             backup.step(-1).unwrap();",
          "332:         let the_answer: i64 = dst",
          "333:             .query_row(\"SELECT x FROM foo\", [], |r| r.get(0))",
          "334:             .unwrap();",
          "337:         src.execute_batch(\"INSERT INTO foo VALUES(43)\").unwrap();",
          "340:             let backup = Backup::new(&src, &mut dst).unwrap();",
          "341:             backup",
          "342:                 .run_to_completion(5, Duration::from_millis(250), None)",
          "343:                 .unwrap();",
          "346:         let the_answer: i64 = dst",
          "347:             .query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "348:             .unwrap();",
          "353:     fn test_backup_temp() {",
          "354:         let src = Connection::open_in_memory().unwrap();",
          "359:         src.execute_batch(sql).unwrap();",
          "361:         let mut dst = Connection::open_in_memory().unwrap();",
          "365:                 Backup::new_with_names(&src, DatabaseName::Temp, &mut dst, DatabaseName::Main)",
          "366:                     .unwrap();",
          "367:             backup.step(-1).unwrap();",
          "370:         let the_answer: i64 = dst",
          "371:             .query_row(\"SELECT x FROM foo\", [], |r| r.get(0))",
          "372:             .unwrap();",
          "375:         src.execute_batch(\"INSERT INTO foo VALUES(43)\").unwrap();",
          "379:                 Backup::new_with_names(&src, DatabaseName::Temp, &mut dst, DatabaseName::Main)",
          "380:                     .unwrap();",
          "381:             backup",
          "382:                 .run_to_completion(5, Duration::from_millis(250), None)",
          "383:                 .unwrap();",
          "386:         let the_answer: i64 = dst",
          "387:             .query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "388:             .unwrap();",
          "393:     fn test_backup_attached() {",
          "394:         let src = Connection::open_in_memory().unwrap();",
          "400:         src.execute_batch(sql).unwrap();",
          "402:         let mut dst = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "313:     use crate::{Connection, DatabaseName, Result};",
          "317:     fn test_backup() -> Result<()> {",
          "318:         let src = Connection::open_in_memory()?;",
          "323:         src.execute_batch(sql)?;",
          "325:         let mut dst = Connection::open_in_memory()?;",
          "328:             let backup = Backup::new(&src, &mut dst)?;",
          "329:             backup.step(-1)?;",
          "332:         let the_answer: i64 = dst.query_row(\"SELECT x FROM foo\", [], |r| r.get(0))?;",
          "335:         src.execute_batch(\"INSERT INTO foo VALUES(43)\")?;",
          "338:             let backup = Backup::new(&src, &mut dst)?;",
          "339:             backup.run_to_completion(5, Duration::from_millis(250), None)?;",
          "342:         let the_answer: i64 = dst.query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?;",
          "344:         Ok(())",
          "348:     fn test_backup_temp() -> Result<()> {",
          "349:         let src = Connection::open_in_memory()?;",
          "354:         src.execute_batch(sql)?;",
          "356:         let mut dst = Connection::open_in_memory()?;",
          "360:                 Backup::new_with_names(&src, DatabaseName::Temp, &mut dst, DatabaseName::Main)?;",
          "361:             backup.step(-1)?;",
          "364:         let the_answer: i64 = dst.query_row(\"SELECT x FROM foo\", [], |r| r.get(0))?;",
          "367:         src.execute_batch(\"INSERT INTO foo VALUES(43)\")?;",
          "371:                 Backup::new_with_names(&src, DatabaseName::Temp, &mut dst, DatabaseName::Main)?;",
          "372:             backup.run_to_completion(5, Duration::from_millis(250), None)?;",
          "375:         let the_answer: i64 = dst.query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?;",
          "377:         Ok(())",
          "381:     fn test_backup_attached() -> Result<()> {",
          "382:         let src = Connection::open_in_memory()?;",
          "388:         src.execute_batch(sql)?;",
          "390:         let mut dst = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "407:                 DatabaseName::Attached(\"my_attached\"),",
          "408:                 &mut dst,",
          "409:                 DatabaseName::Main,",
          "413:         }",
          "418:         assert_eq!(42, the_answer);",
          "422:         {",
          "423:             let backup = Backup::new_with_names(",
          "",
          "[Removed Lines]",
          "410:             )",
          "411:             .unwrap();",
          "412:             backup.step(-1).unwrap();",
          "415:         let the_answer: i64 = dst",
          "416:             .query_row(\"SELECT x FROM foo\", [], |r| r.get(0))",
          "417:             .unwrap();",
          "420:         src.execute_batch(\"INSERT INTO foo VALUES(43)\").unwrap();",
          "",
          "[Added Lines]",
          "398:             )?;",
          "399:             backup.step(-1)?;",
          "402:         let the_answer: i64 = dst.query_row(\"SELECT x FROM foo\", [], |r| r.get(0))?;",
          "405:         src.execute_batch(\"INSERT INTO foo VALUES(43)\")?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "425:                 DatabaseName::Attached(\"my_attached\"),",
          "426:                 &mut dst,",
          "427:                 DatabaseName::Main,",
          "433:         }",
          "438:         assert_eq!(42 + 43, the_answer);",
          "439:     }",
          "440: }",
          "",
          "[Removed Lines]",
          "428:             )",
          "429:             .unwrap();",
          "430:             backup",
          "431:                 .run_to_completion(5, Duration::from_millis(250), None)",
          "432:                 .unwrap();",
          "435:         let the_answer: i64 = dst",
          "436:             .query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "437:             .unwrap();",
          "",
          "[Added Lines]",
          "413:             )?;",
          "414:             backup.run_to_completion(5, Duration::from_millis(250), None)?;",
          "417:         let the_answer: i64 = dst.query_row(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?;",
          "419:         Ok(())",
          "",
          "---------------"
        ],
        "src/blob/mod.rs||src/blob/mod.rs": [
          "File: src/blob/mod.rs -> src/blob/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "434:     }",
          "436:     #[test]",
          "443:         assert_eq!(4, blob.write(b\"Clob\").unwrap());",
          "444:         assert_eq!(6, blob.write(b\"567890xxxxxx\").unwrap()); // cannot write past 10",
          "445:         assert_eq!(0, blob.write(b\"5678\").unwrap()); // still cannot write past 10",
          "453:         let mut bytes = [0u8; 5];",
          "454:         assert_eq!(5, blob.read(&mut bytes[..]).unwrap());",
          "455:         assert_eq!(&bytes, b\"Clob5\");",
          "",
          "[Removed Lines]",
          "437:     fn test_blob() {",
          "438:         let (db, rowid) = db_with_test_blob().unwrap();",
          "440:         let mut blob = db",
          "441:             .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "442:             .unwrap();",
          "447:         blob.reopen(rowid).unwrap();",
          "448:         blob.close().unwrap();",
          "450:         blob = db",
          "451:             .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, true)",
          "452:             .unwrap();",
          "",
          "[Added Lines]",
          "437:     fn test_blob() -> Result<()> {",
          "438:         let (db, rowid) = db_with_test_blob()?;",
          "440:         let mut blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "445:         blob.reopen(rowid)?;",
          "446:         blob.close()?;",
          "448:         blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, true)?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "470:         assert_eq!(5, blob.read(&mut bytes[..]).unwrap());",
          "471:         assert_eq!(&bytes, b\"56789\");",
          "474:         assert_eq!(5, blob.read(&mut bytes[..]).unwrap());",
          "475:         assert_eq!(&bytes, b\"Clob5\");",
          "",
          "[Removed Lines]",
          "473:         blob.reopen(rowid).unwrap();",
          "",
          "[Added Lines]",
          "469:         blob.reopen(rowid)?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:         assert!(blob.write_all(b\"0123456789x\").is_err());",
          "486:     }",
          "488:     #[test]",
          "495:         assert_eq!(8, blob.write(b\"one\\ntwo\\n\").unwrap());",
          "498:         let mut reader = BufReader::new(blob);",
          "500:         let mut line = String::new();",
          "",
          "[Removed Lines]",
          "484:         blob.reopen(rowid).unwrap();",
          "489:     fn test_blob_in_bufreader() {",
          "490:         let (db, rowid) = db_with_test_blob().unwrap();",
          "492:         let mut blob = db",
          "493:             .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "494:             .unwrap();",
          "497:         blob.reopen(rowid).unwrap();",
          "",
          "[Added Lines]",
          "480:         blob.reopen(rowid)?;",
          "482:         Ok(())",
          "486:     fn test_blob_in_bufreader() -> Result<()> {",
          "487:         let (db, rowid) = db_with_test_blob()?;",
          "489:         let mut blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "492:         blob.reopen(rowid)?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "508:         line.truncate(0);",
          "509:         assert_eq!(2, reader.read_line(&mut line).unwrap());",
          "510:         assert_eq!(\"\\0\\0\", line);",
          "511:     }",
          "513:     #[test]",
          "517:         {",
          "521:             let mut writer = BufWriter::new(blob);",
          "",
          "[Removed Lines]",
          "514:     fn test_blob_in_bufwriter() {",
          "515:         let (db, rowid) = db_with_test_blob().unwrap();",
          "518:             let blob = db",
          "519:                 .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "520:                 .unwrap();",
          "",
          "[Added Lines]",
          "506:         Ok(())",
          "510:     fn test_blob_in_bufwriter() -> Result<()> {",
          "511:         let (db, rowid) = db_with_test_blob()?;",
          "514:             let blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "529:         {",
          "534:             let mut bytes = [0u8; 10];",
          "535:             assert_eq!(10, blob.read(&mut bytes[..]).unwrap());",
          "536:             assert_eq!(b\"0123456701\", &bytes);",
          "537:         }",
          "539:         {",
          "543:             let mut writer = BufWriter::new(blob);",
          "",
          "[Removed Lines]",
          "531:             let mut blob = db",
          "532:                 .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "533:                 .unwrap();",
          "540:             let blob = db",
          "541:                 .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "542:                 .unwrap();",
          "",
          "[Added Lines]",
          "525:             let mut blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "532:             let blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "550:         {",
          "555:             let mut bytes = [0u8; 10];",
          "556:             assert_eq!(10, blob.read(&mut bytes[..]).unwrap());",
          "557:             assert_eq!(b\"aaaaaaaaaa\", &bytes);",
          "558:         }",
          "559:     }",
          "560: }",
          "",
          "[Removed Lines]",
          "552:             let mut blob = db",
          "553:                 .blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)",
          "554:                 .unwrap();",
          "",
          "[Added Lines]",
          "542:             let mut blob = db.blob_open(DatabaseName::Main, \"test\", \"content\", rowid, false)?;",
          "546:             Ok(())",
          "",
          "---------------"
        ],
        "src/blob/pos_io.rs||src/blob/pos_io.rs": [
          "File: src/blob/pos_io.rs -> src/blob/pos_io.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "195: #[cfg(test)]",
          "196: mod test {",
          "199:     use std::io::Seek as _;",
          "201:     #[test]",
          "209:         let rowid = db.last_insert_rowid();",
          "214:         blob.seek(std::io::SeekFrom::Start(1)).unwrap();",
          "",
          "[Removed Lines]",
          "197:     use crate::{Connection, DatabaseName};",
          "202:     fn test_pos_io() {",
          "203:         let db = Connection::open_in_memory().unwrap();",
          "204:         db.execute_batch(\"CREATE TABLE test_table(content BLOB);\")",
          "205:             .unwrap();",
          "206:         db.execute(\"INSERT INTO test_table(content) VALUES (ZEROBLOB(10))\", [])",
          "207:             .unwrap();",
          "210:         let mut blob = db",
          "211:             .blob_open(DatabaseName::Main, \"test_table\", \"content\", rowid, false)",
          "212:             .unwrap();",
          "",
          "[Added Lines]",
          "197:     use crate::{Connection, DatabaseName, Result};",
          "202:     fn test_pos_io() -> Result<()> {",
          "203:         let db = Connection::open_in_memory()?;",
          "204:         db.execute_batch(\"CREATE TABLE test_table(content BLOB);\")?;",
          "205:         db.execute(\"INSERT INTO test_table(content) VALUES (ZEROBLOB(10))\", [])?;",
          "208:         let mut blob = db.blob_open(DatabaseName::Main, \"test_table\", \"content\", rowid, false)?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:         let end_pos = blob.seek(std::io::SeekFrom::Current(0)).unwrap();",
          "276:         assert_eq!(end_pos, 1);",
          "277:     }",
          "278: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273:         Ok(())",
          "",
          "---------------"
        ],
        "src/busy.rs||src/busy.rs": [
          "File: src/busy.rs -> src/busy.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:     use crate::{Connection, Error, ErrorCode, Result, TransactionBehavior};",
          "88:     #[test]",
          "90:         let temp_dir = tempfile::tempdir().unwrap();",
          "91:         let path = temp_dir.path().join(\"test.db3\");",
          "98:         let r: Result<()> = db2.query_row(\"PRAGMA schema_version\", [], |_| unreachable!());",
          "99:         match r.unwrap_err() {",
          "100:             Error::SqliteFailure(err, _) => {",
          "",
          "[Removed Lines]",
          "89:     fn test_default_busy() {",
          "93:         let mut db1 = Connection::open(&path).unwrap();",
          "94:         let tx1 = db1",
          "95:             .transaction_with_behavior(TransactionBehavior::Exclusive)",
          "96:             .unwrap();",
          "97:         let db2 = Connection::open(&path).unwrap();",
          "",
          "[Added Lines]",
          "89:     fn test_default_busy() -> Result<()> {",
          "93:         let mut db1 = Connection::open(&path)?;",
          "94:         let tx1 = db1.transaction_with_behavior(TransactionBehavior::Exclusive)?;",
          "95:         let db2 = Connection::open(&path)?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:             }",
          "103:             err => panic!(\"Unexpected error {}\", err),",
          "104:         }",
          "106:     }",
          "108:     #[test]",
          "",
          "[Removed Lines]",
          "105:         tx1.rollback().unwrap();",
          "",
          "[Added Lines]",
          "103:         tx1.rollback()",
          "",
          "---------------"
        ],
        "src/cache.rs||src/cache.rs": [
          "File: src/cache.rs -> src/cache.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "175: #[cfg(test)]",
          "176: mod test {",
          "177:     use super::StatementCache;",
          "179:     use fallible_iterator::FallibleIterator;",
          "181:     impl StatementCache {",
          "",
          "[Removed Lines]",
          "178:     use crate::Connection;",
          "",
          "[Added Lines]",
          "178:     use crate::{Connection, Result};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:     }",
          "195:     #[test]",
          "198:         let cache = &db.cache;",
          "199:         let initial_capacity = cache.capacity();",
          "200:         assert_eq!(0, cache.len());",
          "",
          "[Removed Lines]",
          "196:     fn test_cache() {",
          "197:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "196:     fn test_cache() -> Result<()> {",
          "197:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "203:         let sql = \"PRAGMA schema_version\";",
          "204:         {",
          "206:             assert_eq!(0, cache.len());",
          "208:         }",
          "209:         assert_eq!(1, cache.len());",
          "211:         {",
          "213:             assert_eq!(0, cache.len());",
          "215:         }",
          "216:         assert_eq!(1, cache.len());",
          "218:         cache.clear();",
          "219:         assert_eq!(0, cache.len());",
          "220:         assert_eq!(initial_capacity, cache.capacity());",
          "221:     }",
          "223:     #[test]",
          "226:         let cache = &db.cache;",
          "228:         let sql = \"PRAGMA schema_version\";",
          "229:         {",
          "231:             assert_eq!(0, cache.len());",
          "233:         }",
          "234:         assert_eq!(1, cache.len());",
          "",
          "[Removed Lines]",
          "205:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "207:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "212:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "214:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "224:     fn test_set_capacity() {",
          "225:         let db = Connection::open_in_memory().unwrap();",
          "230:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "232:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "",
          "[Added Lines]",
          "205:             let mut stmt = db.prepare_cached(sql)?;",
          "207:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "212:             let mut stmt = db.prepare_cached(sql)?;",
          "214:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "221:         Ok(())",
          "225:     fn test_set_capacity() -> Result<()> {",
          "226:         let db = Connection::open_in_memory()?;",
          "231:             let mut stmt = db.prepare_cached(sql)?;",
          "233:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237:         assert_eq!(0, cache.len());",
          "239:         {",
          "241:             assert_eq!(0, cache.len());",
          "243:         }",
          "244:         assert_eq!(0, cache.len());",
          "246:         db.set_prepared_statement_cache_capacity(8);",
          "247:         {",
          "249:             assert_eq!(0, cache.len());",
          "251:         }",
          "252:         assert_eq!(1, cache.len());",
          "253:     }",
          "255:     #[test]",
          "258:         let cache = &db.cache;",
          "260:         let sql = \"PRAGMA schema_version\";",
          "261:         {",
          "263:             assert_eq!(0, cache.len());",
          "265:             stmt.discard();",
          "266:         }",
          "267:         assert_eq!(0, cache.len());",
          "268:     }",
          "270:     #[test]",
          "273:         db.execute_batch(",
          "274:             r#\"",
          "275:             CREATE TABLE foo (x INT);",
          "276:             INSERT INTO foo VALUES (1);",
          "277:         \"#,",
          "281:         let sql = \"SELECT * FROM foo\";",
          "283:         {",
          "289:         }",
          "291:         db.execute_batch(",
          "",
          "[Removed Lines]",
          "240:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "242:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "248:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "250:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "256:     fn test_discard() {",
          "257:         let db = Connection::open_in_memory().unwrap();",
          "262:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "264:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "271:     fn test_ddl() {",
          "272:         let db = Connection::open_in_memory().unwrap();",
          "278:         )",
          "279:         .unwrap();",
          "284:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "285:             assert_eq!(",
          "286:                 Ok(Some(1i32)),",
          "287:                 stmt.query([]).unwrap().map(|r| r.get(0)).next()",
          "288:             );",
          "",
          "[Added Lines]",
          "241:             let mut stmt = db.prepare_cached(sql)?;",
          "243:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "249:             let mut stmt = db.prepare_cached(sql)?;",
          "251:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "254:         Ok(())",
          "258:     fn test_discard() -> Result<()> {",
          "259:         let db = Connection::open_in_memory()?;",
          "264:             let mut stmt = db.prepare_cached(sql)?;",
          "266:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "270:         Ok(())",
          "274:     fn test_ddl() -> Result<()> {",
          "275:         let db = Connection::open_in_memory()?;",
          "281:         )?;",
          "286:             let mut stmt = db.prepare_cached(sql)?;",
          "287:             assert_eq!(Ok(Some(1i32)), stmt.query([])?.map(|r| r.get(0)).next());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "293:             ALTER TABLE foo ADD COLUMN y INT;",
          "294:             UPDATE foo SET y = 2;",
          "295:         \"#,",
          "299:         {",
          "301:             assert_eq!(",
          "302:                 Ok(Some((1i32, 2i32))),",
          "307:             );",
          "308:         }",
          "309:     }",
          "311:     #[test]",
          "316:         conn.close().expect(\"connection not closed\");",
          "317:     }",
          "319:     #[test]",
          "322:         let cache = &db.cache;",
          "323:         assert_eq!(0, cache.len());",
          "326:         let sql = \"PRAGMA schema_version; \";",
          "327:         {",
          "329:             assert_eq!(0, cache.len());",
          "331:         }",
          "332:         assert_eq!(1, cache.len());",
          "334:         {",
          "336:             assert_eq!(0, cache.len());",
          "338:         }",
          "339:         assert_eq!(1, cache.len());",
          "340:     }",
          "342:     #[test]",
          "346:     }",
          "347: }",
          "",
          "[Removed Lines]",
          "296:         )",
          "297:         .unwrap();",
          "300:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "303:                 stmt.query([])",
          "304:                     .unwrap()",
          "305:                     .map(|r| Ok((r.get(0)?, r.get(1)?)))",
          "306:                     .next()",
          "312:     fn test_connection_close() {",
          "313:         let conn = Connection::open_in_memory().unwrap();",
          "314:         conn.prepare_cached(\"SELECT * FROM sqlite_master;\").unwrap();",
          "320:     fn test_cache_key() {",
          "321:         let db = Connection::open_in_memory().unwrap();",
          "328:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "330:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "335:             let mut stmt = db.prepare_cached(sql).unwrap();",
          "337:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0)).unwrap());",
          "343:     fn test_empty_stmt() {",
          "344:         let conn = Connection::open_in_memory().unwrap();",
          "345:         conn.prepare_cached(\"\").unwrap();",
          "",
          "[Added Lines]",
          "295:         )?;",
          "298:             let mut stmt = db.prepare_cached(sql)?;",
          "301:                 stmt.query([])?.map(|r| Ok((r.get(0)?, r.get(1)?))).next()",
          "304:         Ok(())",
          "308:     fn test_connection_close() -> Result<()> {",
          "309:         let conn = Connection::open_in_memory()?;",
          "310:         conn.prepare_cached(\"SELECT * FROM sqlite_master;\")?;",
          "313:         Ok(())",
          "317:     fn test_cache_key() -> Result<()> {",
          "318:         let db = Connection::open_in_memory()?;",
          "325:             let mut stmt = db.prepare_cached(sql)?;",
          "327:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "332:             let mut stmt = db.prepare_cached(sql)?;",
          "334:             assert_eq!(0, stmt.query_row([], |r| r.get::<_, i64>(0))?);",
          "337:         Ok(())",
          "341:     fn test_empty_stmt() -> Result<()> {",
          "342:         let conn = Connection::open_in_memory()?;",
          "343:         conn.prepare_cached(\"\")?;",
          "344:         Ok(())",
          "",
          "---------------"
        ],
        "src/collation.rs||src/collation.rs": [
          "File: src/collation.rs -> src/collation.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:     }",
          "173:     #[test]",
          "180:     }",
          "183:         db.execute_batch(",
          "184:             \"CREATE TABLE foo (bar);",
          "185:              INSERT INTO foo (bar) VALUES ('Ma\u00dfe');",
          "186:              INSERT INTO foo (bar) VALUES ('MASSE');\",",
          "194:     }",
          "196:     fn collation_needed(db: &Connection, collation_name: &str) -> Result<()> {",
          "",
          "[Removed Lines]",
          "174:     fn test_unicase() {",
          "175:         let db = Connection::open_in_memory().unwrap();",
          "177:         db.create_collation(\"unicase\", unicase_compare).unwrap();",
          "179:         collate(db);",
          "182:     fn collate(db: Connection) {",
          "187:         )",
          "188:         .unwrap();",
          "189:         let mut stmt = db",
          "190:             .prepare(\"SELECT DISTINCT bar COLLATE unicase FROM foo ORDER BY 1\")",
          "191:             .unwrap();",
          "192:         let rows = stmt.query([]).unwrap();",
          "193:         assert_eq!(rows.count().unwrap(), 1);",
          "",
          "[Added Lines]",
          "174:     fn test_unicase() -> Result<()> {",
          "175:         let db = Connection::open_in_memory()?;",
          "177:         db.create_collation(\"unicase\", unicase_compare)?;",
          "179:         collate(db)",
          "182:     fn collate(db: Connection) -> Result<()> {",
          "187:         )?;",
          "188:         let mut stmt = db.prepare(\"SELECT DISTINCT bar COLLATE unicase FROM foo ORDER BY 1\")?;",
          "189:         let rows = stmt.query([])?;",
          "190:         assert_eq!(rows.count()?, 1);",
          "191:         Ok(())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:     }",
          "204:     #[test]",
          "209:     }",
          "210: }",
          "",
          "[Removed Lines]",
          "205:     fn test_collation_needed() {",
          "206:         let db = Connection::open_in_memory().unwrap();",
          "207:         db.collation_needed(collation_needed).unwrap();",
          "208:         collate(db);",
          "",
          "[Added Lines]",
          "203:     fn test_collation_needed() -> Result<()> {",
          "204:         let db = Connection::open_in_memory()?;",
          "205:         db.collation_needed(collation_needed)?;",
          "206:         collate(db)",
          "",
          "---------------"
        ],
        "src/column.rs||src/column.rs": [
          "File: src/column.rs -> src/column.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "177: #[cfg(test)]",
          "178: mod test {",
          "181:     #[test]",
          "182:     #[cfg(feature = \"column_decltype\")]",
          "184:         use super::Column;",
          "188:         let columns = query.columns();",
          "189:         let column_names: Vec<&str> = columns.iter().map(Column::name).collect();",
          "190:         assert_eq!(",
          "",
          "[Removed Lines]",
          "179:     use crate::Connection;",
          "183:     fn test_columns() {",
          "186:         let db = Connection::open_in_memory().unwrap();",
          "187:         let query = db.prepare(\"SELECT * FROM sqlite_master\").unwrap();",
          "",
          "[Added Lines]",
          "179:     use crate::{Connection, Result};",
          "183:     fn test_columns() -> Result<()> {",
          "186:         let db = Connection::open_in_memory()?;",
          "187:         let query = db.prepare(\"SELECT * FROM sqlite_master\")?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "196:             &column_types[..3],",
          "197:             &[Some(\"text\"), Some(\"text\"), Some(\"text\"),]",
          "198:         );",
          "199:     }",
          "201:     #[test]",
          "203:         use crate::{types::Type, Error};",
          "205:         db.execute_batch(",
          "206:             \"BEGIN;",
          "207:              CREATE TABLE foo(x INTEGER, y TEXT);",
          "208:              INSERT INTO foo VALUES(4, NULL);",
          "209:              END;\",",
          "215:         match row.get::<_, String>(0).unwrap_err() {",
          "216:             Error::InvalidColumnType(idx, name, ty) => {",
          "217:                 assert_eq!(idx, 0);",
          "",
          "[Removed Lines]",
          "202:     fn test_column_name_in_error() {",
          "204:         let db = Connection::open_in_memory().unwrap();",
          "210:         )",
          "211:         .unwrap();",
          "212:         let mut stmt = db.prepare(\"SELECT x as renamed, y FROM foo\").unwrap();",
          "213:         let mut rows = stmt.query([]).unwrap();",
          "214:         let row = rows.next().unwrap().unwrap();",
          "",
          "[Added Lines]",
          "199:         Ok(())",
          "203:     fn test_column_name_in_error() -> Result<()> {",
          "205:         let db = Connection::open_in_memory()?;",
          "211:         )?;",
          "212:         let mut stmt = db.prepare(\"SELECT x as renamed, y FROM foo\")?;",
          "213:         let mut rows = stmt.query([])?;",
          "214:         let row = rows.next()?.unwrap();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232:                 panic!(\"Unexpected error type: {:?}\", e);",
          "233:             }",
          "234:         }",
          "235:     }",
          "236: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "235:         Ok(())",
          "",
          "---------------"
        ],
        "src/config.rs||src/config.rs": [
          "File: src/config.rs -> src/config.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "122: #[cfg(test)]",
          "123: mod test {",
          "124:     use super::DbConfig;",
          "127:     #[test]",
          "132:         assert_eq!(",
          "133:             db.set_db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_FKEY, opposite),",
          "134:             Ok(opposite)",
          "",
          "[Removed Lines]",
          "125:     use crate::Connection;",
          "128:     fn test_db_config() {",
          "129:         let db = Connection::open_in_memory().unwrap();",
          "131:         let opposite = !db.db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_FKEY).unwrap();",
          "",
          "[Added Lines]",
          "125:     use crate::{Connection, Result};",
          "128:     fn test_db_config() -> Result<()> {",
          "129:         let db = Connection::open_in_memory()?;",
          "131:         let opposite = !db.db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_FKEY)?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:             Ok(opposite)",
          "139:         );",
          "144:         assert_eq!(",
          "145:             db.set_db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_TRIGGER, opposite),",
          "146:             Ok(opposite)",
          "",
          "[Removed Lines]",
          "141:         let opposite = !db",
          "142:             .db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_TRIGGER)",
          "143:             .unwrap();",
          "",
          "[Added Lines]",
          "141:         let opposite = !db.db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_TRIGGER)?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:             db.db_config(DbConfig::SQLITE_DBCONFIG_ENABLE_TRIGGER),",
          "150:             Ok(opposite)",
          "151:         );",
          "152:     }",
          "153: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:         Ok(())",
          "",
          "---------------"
        ],
        "src/functions.rs||src/functions.rs": [
          "File: src/functions.rs -> src/functions.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "761:     }",
          "763:     #[test]",
          "766:         db.create_scalar_function(",
          "767:             \"half\",",
          "768:             1,",
          "769:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "770:             half,",
          "773:         let result: Result<f64> = db.query_row(\"SELECT half(6)\", [], |r| r.get(0));",
          "776:     }",
          "778:     #[test]",
          "781:         db.create_scalar_function(",
          "782:             \"half\",",
          "783:             1,",
          "784:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "785:             half,",
          "788:         let result: Result<f64> = db.query_row(\"SELECT half(6)\", [], |r| r.get(0));",
          "792:         let result: Result<f64> = db.query_row(\"SELECT half(6)\", [], |r| r.get(0));",
          "793:         assert!(result.is_err());",
          "794:     }",
          "",
          "[Removed Lines]",
          "764:     fn test_function_half() {",
          "765:         let db = Connection::open_in_memory().unwrap();",
          "771:         )",
          "772:         .unwrap();",
          "775:         assert!((3f64 - result.unwrap()).abs() < EPSILON);",
          "779:     fn test_remove_function() {",
          "780:         let db = Connection::open_in_memory().unwrap();",
          "786:         )",
          "787:         .unwrap();",
          "789:         assert!((3f64 - result.unwrap()).abs() < EPSILON);",
          "791:         db.remove_function(\"half\", 1).unwrap();",
          "",
          "[Added Lines]",
          "764:     fn test_function_half() -> Result<()> {",
          "765:         let db = Connection::open_in_memory()?;",
          "771:         )?;",
          "774:         assert!((3f64 - result?).abs() < EPSILON);",
          "775:         Ok(())",
          "779:     fn test_remove_function() -> Result<()> {",
          "780:         let db = Connection::open_in_memory()?;",
          "786:         )?;",
          "788:         assert!((3f64 - result?).abs() < EPSILON);",
          "790:         db.remove_function(\"half\", 1)?;",
          "793:         Ok(())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "817:     }",
          "819:     #[test]",
          "822:         db.execute_batch(",
          "823:             \"BEGIN;",
          "824:              CREATE TABLE foo (x string);",
          "",
          "[Removed Lines]",
          "820:     fn test_function_regexp_with_auxilliary() {",
          "821:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "820:     fn test_function_regexp_with_auxilliary() -> Result<()> {",
          "821:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "826:              INSERT INTO foo VALUES ('lXsi');",
          "827:              INSERT INTO foo VALUES ('lisX');",
          "828:              END;\",",
          "831:         db.create_scalar_function(",
          "832:             \"regexp\",",
          "833:             2,",
          "834:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "835:             regexp_with_auxilliary,",
          "839:         let result: Result<bool> =",
          "840:             db.query_row(\"SELECT regexp('l.s[aeiouy]', 'lisa')\", [], |r| r.get(0));",
          "844:         let result: Result<i64> = db.query_row(",
          "845:             \"SELECT COUNT(*) FROM foo WHERE regexp('l.s[aeiouy]', x) == 1\",",
          "",
          "[Removed Lines]",
          "829:         )",
          "830:         .unwrap();",
          "836:         )",
          "837:         .unwrap();",
          "842:         assert_eq!(true, result.unwrap());",
          "",
          "[Added Lines]",
          "829:         )?;",
          "835:         )?;",
          "840:         assert_eq!(true, result?);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "847:             |r| r.get(0),",
          "848:         );",
          "851:     }",
          "853:     #[test]",
          "856:         db.create_scalar_function(",
          "857:             \"my_concat\",",
          "858:             -1,",
          "",
          "[Removed Lines]",
          "850:         assert_eq!(2, result.unwrap());",
          "854:     fn test_varargs_function() {",
          "855:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "848:         assert_eq!(2, result?);",
          "849:         Ok(())",
          "853:     fn test_varargs_function() -> Result<()> {",
          "854:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "868:                 Ok(ret)",
          "869:             },",
          "873:         for &(expected, query) in &[",
          "874:             (\"\", \"SELECT my_concat()\"),",
          "875:             (\"onetwo\", \"SELECT my_concat('one', 'two')\"),",
          "876:             (\"abc\", \"SELECT my_concat('a', 'b', 'c')\"),",
          "877:         ] {",
          "879:             assert_eq!(expected, result);",
          "880:         }",
          "881:     }",
          "883:     #[test]",
          "886:         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {",
          "887:             if !ctx.get::<bool>(1)? {",
          "888:                 ctx.set_aux::<i64>(0, 100)?;",
          "889:             } else {",
          "890:                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));",
          "892:             }",
          "893:             Ok(true)",
          "905:         assert!(res);",
          "906:     }",
          "908:     struct Sum;",
          "",
          "[Removed Lines]",
          "870:         )",
          "871:         .unwrap();",
          "878:             let result: String = db.query_row(query, [], |r| r.get(0)).unwrap();",
          "884:     fn test_get_aux_type_checking() {",
          "885:         let db = Connection::open_in_memory().unwrap();",
          "891:                 assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);",
          "894:         })",
          "895:         .unwrap();",
          "897:         let res: bool = db",
          "898:             .query_row(",
          "899:                 \"SELECT example(0, i) FROM (SELECT 0 as i UNION SELECT 1)\",",
          "900:                 [],",
          "901:                 |r| r.get(0),",
          "902:             )",
          "903:             .unwrap();",
          "",
          "[Added Lines]",
          "869:         )?;",
          "876:             let result: String = db.query_row(query, [], |r| r.get(0))?;",
          "879:         Ok(())",
          "883:     fn test_get_aux_type_checking() -> Result<()> {",
          "884:         let db = Connection::open_in_memory()?;",
          "890:                 assert_eq!(*ctx.get_aux::<i64>(0)?.unwrap(), 100);",
          "893:         })?;",
          "895:         let res: bool = db.query_row(",
          "896:             \"SELECT example(0, i) FROM (SELECT 0 as i UNION SELECT 1)\",",
          "897:             [],",
          "898:             |r| r.get(0),",
          "899:         )?;",
          "902:         Ok(())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "939:     }",
          "941:     #[test]",
          "944:         db.create_aggregate_function(",
          "945:             \"my_sum\",",
          "946:             1,",
          "947:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "948:             Sum,",
          "953:         let no_result = \"SELECT my_sum(i) FROM (SELECT 2 AS i WHERE 1 <> 1)\";",
          "955:         assert!(result.is_none());",
          "957:         let single_sum = \"SELECT my_sum(i) FROM (SELECT 2 AS i UNION ALL SELECT 2)\";",
          "959:         assert_eq!(4, result);",
          "961:         let dual_sum = \"SELECT my_sum(i), my_sum(j) FROM (SELECT 2 AS i, 1 AS j UNION ALL SELECT \\",
          "962:                         2, 1)\";",
          "966:         assert_eq!((4, 2), result);",
          "967:     }",
          "969:     #[test]",
          "972:         db.create_aggregate_function(",
          "973:             \"my_count\",",
          "974:             -1,",
          "975:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "976:             Count,",
          "981:         let no_result = \"SELECT my_count(i) FROM (SELECT 2 AS i WHERE 1 <> 1)\";",
          "983:         assert_eq!(result, 0);",
          "985:         let single_sum = \"SELECT my_count(i) FROM (SELECT 2 AS i UNION ALL SELECT 2)\";",
          "987:         assert_eq!(2, result);",
          "988:     }",
          "990:     #[cfg(feature = \"window\")]",
          "",
          "[Removed Lines]",
          "942:     fn test_sum() {",
          "943:         let db = Connection::open_in_memory().unwrap();",
          "949:         )",
          "950:         .unwrap();",
          "954:         let result: Option<i64> = db.query_row(no_result, [], |r| r.get(0)).unwrap();",
          "958:         let result: i64 = db.query_row(single_sum, [], |r| r.get(0)).unwrap();",
          "963:         let result: (i64, i64) = db",
          "964:             .query_row(dual_sum, [], |r| Ok((r.get(0)?, r.get(1)?)))",
          "965:             .unwrap();",
          "970:     fn test_count() {",
          "971:         let db = Connection::open_in_memory().unwrap();",
          "977:         )",
          "978:         .unwrap();",
          "982:         let result: i64 = db.query_row(no_result, [], |r| r.get(0)).unwrap();",
          "986:         let result: i64 = db.query_row(single_sum, [], |r| r.get(0)).unwrap();",
          "",
          "[Added Lines]",
          "939:     fn test_sum() -> Result<()> {",
          "940:         let db = Connection::open_in_memory()?;",
          "946:         )?;",
          "950:         let result: Option<i64> = db.query_row(no_result, [], |r| r.get(0))?;",
          "954:         let result: i64 = db.query_row(single_sum, [], |r| r.get(0))?;",
          "959:         let result: (i64, i64) = db.query_row(dual_sum, [], |r| Ok((r.get(0)?, r.get(1)?)))?;",
          "961:         Ok(())",
          "965:     fn test_count() -> Result<()> {",
          "966:         let db = Connection::open_in_memory()?;",
          "972:         )?;",
          "976:         let result: i64 = db.query_row(no_result, [], |r| r.get(0))?;",
          "980:         let result: i64 = db.query_row(single_sum, [], |r| r.get(0))?;",
          "982:         Ok(())",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1002:     #[test]",
          "1003:     #[cfg(feature = \"window\")]",
          "1005:         use fallible_iterator::FallibleIterator;",
          "1008:         db.create_window_function(",
          "1009:             \"sumint\",",
          "1010:             1,",
          "1011:             FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,",
          "1012:             Sum,",
          "1015:         db.execute_batch(",
          "1016:             \"CREATE TABLE t3(x, y);",
          "1017:              INSERT INTO t3 VALUES('a', 4),",
          "",
          "[Removed Lines]",
          "1004:     fn test_window() {",
          "1007:         let db = Connection::open_in_memory().unwrap();",
          "1013:         )",
          "1014:         .unwrap();",
          "",
          "[Added Lines]",
          "999:     fn test_window() -> Result<()> {",
          "1002:         let db = Connection::open_in_memory()?;",
          "1008:         )?;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1019:                      ('c', 3),",
          "1020:                      ('d', 8),",
          "1021:                      ('e', 1);\",",
          "1028:                    ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING",
          "1029:                  ) AS sum_y",
          "1030:                  FROM t3 ORDER BY x;\",",
          "1034:         let results: Vec<(String, i64)> = stmt",
          "1037:             .map(|row| Ok((row.get(\"x\")?, row.get(\"sum_y\")?)))",
          "1040:         let expected = vec![",
          "1041:             (\"a\".to_owned(), 9),",
          "1042:             (\"b\".to_owned(), 12),",
          "",
          "[Removed Lines]",
          "1022:         )",
          "1023:         .unwrap();",
          "1025:         let mut stmt = db",
          "1026:             .prepare(",
          "1027:                 \"SELECT x, sumint(y) OVER (",
          "1031:             )",
          "1032:             .unwrap();",
          "1035:             .query([])",
          "1036:             .unwrap()",
          "1038:             .collect()",
          "1039:             .unwrap();",
          "",
          "[Added Lines]",
          "1016:         )?;",
          "1018:         let mut stmt = db.prepare(",
          "1019:             \"SELECT x, sumint(y) OVER (",
          "1023:         )?;",
          "1026:             .query([])?",
          "1028:             .collect()?;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1045:             (\"e\".to_owned(), 9),",
          "1046:         ];",
          "1047:         assert_eq!(expected, results);",
          "1048:     }",
          "1049: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1037:         Ok(())",
          "",
          "---------------"
        ],
        "src/hooks.rs||src/hooks.rs": [
          "File: src/hooks.rs -> src/hooks.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "305: #[cfg(test)]",
          "306: mod test {",
          "307:     use super::Action;",
          "309:     use std::sync::atomic::{AtomicBool, Ordering};",
          "311:     #[test]",
          "315:         let mut called = false;",
          "316:         db.commit_hook(Some(|| {",
          "317:             called = true;",
          "318:             false",
          "319:         }));",
          "322:         assert!(called);",
          "323:     }",
          "325:     #[test]",
          "329:         fn hook() -> bool {",
          "330:             true",
          "",
          "[Removed Lines]",
          "308:     use crate::Connection;",
          "312:     fn test_commit_hook() {",
          "313:         let db = Connection::open_in_memory().unwrap();",
          "320:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")",
          "321:             .unwrap();",
          "326:     fn test_fn_commit_hook() {",
          "327:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "308:     use crate::{Connection, Result};",
          "312:     fn test_commit_hook() -> Result<()> {",
          "313:         let db = Connection::open_in_memory()?;",
          "320:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")?;",
          "322:         Ok(())",
          "326:     fn test_fn_commit_hook() -> Result<()> {",
          "327:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "333:         db.commit_hook(Some(hook));",
          "334:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")",
          "335:             .unwrap_err();",
          "336:     }",
          "338:     #[test]",
          "342:         let mut called = false;",
          "343:         db.rollback_hook(Some(|| {",
          "344:             called = true;",
          "345:         }));",
          "348:         assert!(called);",
          "349:     }",
          "351:     #[test]",
          "355:         let mut called = false;",
          "356:         db.update_hook(Some(|action, db: &str, tbl: &str, row_id| {",
          "",
          "[Removed Lines]",
          "339:     fn test_rollback_hook() {",
          "340:         let db = Connection::open_in_memory().unwrap();",
          "346:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); ROLLBACK;\")",
          "347:             .unwrap();",
          "352:     fn test_update_hook() {",
          "353:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "336:         Ok(())",
          "340:     fn test_rollback_hook() -> Result<()> {",
          "341:         let db = Connection::open_in_memory()?;",
          "347:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); ROLLBACK;\")?;",
          "349:         Ok(())",
          "353:     fn test_update_hook() -> Result<()> {",
          "354:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "360:             assert_eq!(1, row_id);",
          "361:             called = true;",
          "362:         }));",
          "365:         assert!(called);",
          "366:     }",
          "368:     #[test]",
          "372:         static CALLED: AtomicBool = AtomicBool::new(false);",
          "373:         db.progress_handler(",
          "",
          "[Removed Lines]",
          "363:         db.execute_batch(\"CREATE TABLE foo (t TEXT)\").unwrap();",
          "364:         db.execute_batch(\"INSERT INTO foo VALUES ('lisa')\").unwrap();",
          "369:     fn test_progress_handler() {",
          "370:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "364:         db.execute_batch(\"CREATE TABLE foo (t TEXT)\")?;",
          "365:         db.execute_batch(\"INSERT INTO foo VALUES ('lisa')\")?;",
          "367:         Ok(())",
          "371:     fn test_progress_handler() -> Result<()> {",
          "372:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "377:                 false",
          "378:             }),",
          "379:         );",
          "382:         assert!(CALLED.load(Ordering::Relaxed));",
          "383:     }",
          "385:     #[test]",
          "389:         fn handler() -> bool {",
          "390:             true",
          "",
          "[Removed Lines]",
          "380:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")",
          "381:             .unwrap();",
          "386:     fn test_progress_handler_interrupt() {",
          "387:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "382:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")?;",
          "384:         Ok(())",
          "388:     fn test_progress_handler_interrupt() -> Result<()> {",
          "389:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "393:         db.progress_handler(1, Some(handler));",
          "394:         db.execute_batch(\"BEGIN; CREATE TABLE foo (t TEXT); COMMIT;\")",
          "395:             .unwrap_err();",
          "396:     }",
          "397: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "398:         Ok(())",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1060:     }",
          "1062:     #[test]",
          "1064:         use std::time::Duration;",
          "1065:         let tmp = tempfile::tempdir().unwrap();",
          "1066:         let path = tmp.path().join(\"transactions.db3\");",
          "1072:             BEGIN; CREATE TABLE foo(x INTEGER);",
          "1073:             INSERT INTO foo VALUES(42); END;\",",
          "1084:         {",
          "1095:             let _ = tx2.execute(\"INSERT INTO foo VALUES(?1)\", [2]);",
          "1097:             let _ = tx1.commit();",
          "",
          "[Removed Lines]",
          "1063:     fn test_concurrent_transactions_busy_commit() {",
          "1068:         Connection::open(&path)",
          "1069:             .expect(\"create temp db\")",
          "1070:             .execute_batch(",
          "1071:                 \"",
          "1074:             )",
          "1075:             .expect(\"create temp db\");",
          "1077:         let mut db1 =",
          "1078:             Connection::open_with_flags(&path, OpenFlags::SQLITE_OPEN_READ_WRITE).unwrap();",
          "1079:         let mut db2 = Connection::open_with_flags(&path, OpenFlags::SQLITE_OPEN_READ_ONLY).unwrap();",
          "1081:         db1.busy_timeout(Duration::from_millis(0)).unwrap();",
          "1082:         db2.busy_timeout(Duration::from_millis(0)).unwrap();",
          "1085:             let tx1 = db1.transaction().unwrap();",
          "1086:             let tx2 = db2.transaction().unwrap();",
          "1089:             tx1.query_row(\"SELECT x FROM foo LIMIT 1\", [], |_| Ok(()))",
          "1090:                 .unwrap();",
          "1091:             tx2.query_row(\"SELECT x FROM foo LIMIT 1\", [], |_| Ok(()))",
          "1092:                 .unwrap();",
          "1094:             tx1.execute(\"INSERT INTO foo VALUES(?1)\", &[&1]).unwrap();",
          "",
          "[Added Lines]",
          "1063:     fn test_concurrent_transactions_busy_commit() -> Result<()> {",
          "1068:         Connection::open(&path)?.execute_batch(",
          "1069:             \"",
          "1072:         )?;",
          "1074:         let mut db1 = Connection::open_with_flags(&path, OpenFlags::SQLITE_OPEN_READ_WRITE)?;",
          "1075:         let mut db2 = Connection::open_with_flags(&path, OpenFlags::SQLITE_OPEN_READ_ONLY)?;",
          "1077:         db1.busy_timeout(Duration::from_millis(0))?;",
          "1078:         db2.busy_timeout(Duration::from_millis(0))?;",
          "1081:             let tx1 = db1.transaction()?;",
          "1082:             let tx2 = db2.transaction()?;",
          "1085:             tx1.query_row(\"SELECT x FROM foo LIMIT 1\", [], |_| Ok(()))?;",
          "1086:             tx2.query_row(\"SELECT x FROM foo LIMIT 1\", [], |_| Ok(()))?;",
          "1088:             tx1.execute(\"INSERT INTO foo VALUES(?1)\", &[&1])?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1104:         let _ = db2",
          "1105:             .transaction()",
          "1106:             .expect(\"commit should have closed transaction\");",
          "1107:     }",
          "1109:     #[test]",
          "1111:         let temp_dir = tempfile::tempdir().unwrap();",
          "1112:         let path = temp_dir.path().join(\"test.db3\");",
          "1114:         {",
          "1116:             let sql = \"BEGIN;",
          "1117:                    CREATE TABLE foo(x INTEGER);",
          "1118:                    INSERT INTO foo VALUES(42);",
          "1119:                    END;\";",
          "1121:         }",
          "1123:         let path_string = path.to_str().unwrap();",
          "1125:         let the_answer: Result<i64> = db.query_row(\"SELECT x FROM foo\", [], |r| r.get(0));",
          "1128:     }",
          "1130:     #[test]",
          "",
          "[Removed Lines]",
          "1110:     fn test_persistence() {",
          "1115:             let db = Connection::open(&path).unwrap();",
          "1120:             db.execute_batch(sql).unwrap();",
          "1124:         let db = Connection::open(&path_string).unwrap();",
          "1127:         assert_eq!(42i64, the_answer.unwrap());",
          "",
          "[Added Lines]",
          "1101:         Ok(())",
          "1105:     fn test_persistence() -> Result<()> {",
          "1110:             let db = Connection::open(&path)?;",
          "1115:             db.execute_batch(sql)?;",
          "1119:         let db = Connection::open(&path_string)?;",
          "1122:         assert_eq!(42i64, the_answer?);",
          "1123:         Ok(())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1158:     #[cfg(unix)]",
          "1159:     #[test]",
          "1161:         use std::ffi::OsStr;",
          "1162:         use std::fs::File;",
          "1163:         use std::os::unix::ffi::OsStrExt;",
          "",
          "[Removed Lines]",
          "1160:     fn test_invalid_unicode_file_names() {",
          "",
          "[Added Lines]",
          "1156:     fn test_invalid_unicode_file_names() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1166:         let path = temp_dir.path();",
          "1167:         if File::create(path.join(OsStr::from_bytes(&[0xFE]))).is_err() {",
          "1170:         }",
          "1171:         let db_path = path.join(OsStr::from_bytes(&[0xFF]));",
          "1172:         {",
          "1174:             let sql = \"BEGIN;",
          "1175:                    CREATE TABLE foo(x INTEGER);",
          "1176:                    INSERT INTO foo VALUES(42);",
          "1177:                    END;\";",
          "1179:         }",
          "1182:         let the_answer: Result<i64> = db.query_row(\"SELECT x FROM foo\", [], |r| r.get(0));",
          "1185:     }",
          "1187:     #[test]",
          "1189:         let db = checked_memory_handle();",
          "",
          "[Removed Lines]",
          "1169:             return;",
          "1173:             let db = Connection::open(&db_path).unwrap();",
          "1178:             db.execute_batch(sql).unwrap();",
          "1181:         let db = Connection::open(&db_path).unwrap();",
          "1184:         assert_eq!(42i64, the_answer.unwrap());",
          "1188:     fn test_close_retry() {",
          "",
          "[Added Lines]",
          "1165:             return Ok(());",
          "1169:             let db = Connection::open(&db_path)?;",
          "1174:             db.execute_batch(sql)?;",
          "1177:         let db = Connection::open(&db_path)?;",
          "1180:         assert_eq!(42i64, the_answer?);",
          "1181:         Ok(())",
          "1185:     fn test_close_retry() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1199:             let raw_db = db.db.borrow_mut().db;",
          "1200:             let sql = \"SELECT 1\";",
          "1201:             let mut raw_stmt: *mut ffi::sqlite3_stmt = ptr::null_mut();",
          "1203:             let rc = unsafe {",
          "1204:                 ffi::sqlite3_prepare_v2(",
          "1205:                     raw_db,",
          "",
          "[Removed Lines]",
          "1202:             let cstring = str_to_cstring(sql).unwrap();",
          "",
          "[Added Lines]",
          "1199:             let cstring = str_to_cstring(sql)?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1223:         assert_eq!(ffi::SQLITE_OK, unsafe { ffi::sqlite3_finalize(raw_stmt) });",
          "1225:         db.close().unwrap();",
          "1226:     }",
          "1228:     #[test]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1223:         Ok(())",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1237:     }",
          "1239:     #[test]",
          "1241:         let db = checked_memory_handle();",
          "1242:         let sql = \"BEGIN;",
          "1243:                    CREATE TABLE foo(x INTEGER);",
          "",
          "[Removed Lines]",
          "1240:     fn test_execute_batch() {",
          "",
          "[Added Lines]",
          "1238:     fn test_execute_batch() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1246:                    INSERT INTO foo VALUES(3);",
          "1247:                    INSERT INTO foo VALUES(4);",
          "1248:                    END;\";",
          "1254:         assert!(db.execute_batch(\"INVALID SQL\").is_err());",
          "1255:     }",
          "1257:     #[test]",
          "1259:         let db = checked_memory_handle();",
          "1271:         assert_eq!(",
          "1272:             3i32,",
          "1275:         );",
          "1276:     }",
          "1278:     #[test]",
          "",
          "[Removed Lines]",
          "1249:         db.execute_batch(sql).unwrap();",
          "1251:         db.execute_batch(\"UPDATE foo SET x = 3 WHERE x < 3\")",
          "1252:             .unwrap();",
          "1258:     fn test_execute() {",
          "1260:         db.execute_batch(\"CREATE TABLE foo(x INTEGER)\").unwrap();",
          "1262:         assert_eq!(",
          "1263:             1,",
          "1264:             db.execute(\"INSERT INTO foo(x) VALUES (?)\", [1i32]).unwrap()",
          "1265:         );",
          "1266:         assert_eq!(",
          "1267:             1,",
          "1268:             db.execute(\"INSERT INTO foo(x) VALUES (?)\", [2i32]).unwrap()",
          "1269:         );",
          "1273:             db.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "1274:                 .unwrap()",
          "",
          "[Added Lines]",
          "1247:         db.execute_batch(sql)?;",
          "1249:         db.execute_batch(\"UPDATE foo SET x = 3 WHERE x < 3\")?;",
          "1252:         Ok(())",
          "1256:     fn test_execute() -> Result<()> {",
          "1258:         db.execute_batch(\"CREATE TABLE foo(x INTEGER)\")?;",
          "1260:         assert_eq!(1, db.execute(\"INSERT INTO foo(x) VALUES (?)\", [1i32])?);",
          "1261:         assert_eq!(1, db.execute(\"INSERT INTO foo(x) VALUES (?)\", [2i32])?);",
          "1265:             db.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?",
          "1267:         Ok(())",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1302:     }",
          "1304:     #[test]",
          "1306:         let db = checked_memory_handle();",
          "1310:         assert_eq!(stmt.column_count(), 1);",
          "1311:         assert_eq!(stmt.column_names(), vec![\"x\"]);",
          "1314:         assert_eq!(stmt.column_count(), 2);",
          "1315:         assert_eq!(stmt.column_names(), vec![\"a\", \"b\"]);",
          "1316:     }",
          "1318:     #[test]",
          "1320:         let db = checked_memory_handle();",
          "1336:     }",
          "1338:     #[test]",
          "1340:         let db = checked_memory_handle();",
          "1351:         {",
          "1353:             let mut v = Vec::<i32>::new();",
          "1357:             }",
          "1359:             assert_eq!(v, [3i32, 2, 1]);",
          "1360:         }",
          "1362:         {",
          "1364:             let mut v = Vec::<i32>::new();",
          "1368:             }",
          "1370:             assert_eq!(v, [2i32, 1]);",
          "1371:         }",
          "1372:     }",
          "1374:     #[test]",
          "1376:         let db = checked_memory_handle();",
          "1377:         let sql = \"BEGIN;",
          "1378:                    CREATE TABLE foo(x INTEGER, y TEXT);",
          "",
          "[Removed Lines]",
          "1305:     fn test_prepare_column_names() {",
          "1307:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\").unwrap();",
          "1309:         let stmt = db.prepare(\"SELECT * FROM foo\").unwrap();",
          "1313:         let stmt = db.prepare(\"SELECT x AS a, x AS b FROM foo\").unwrap();",
          "1319:     fn test_prepare_execute() {",
          "1321:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\").unwrap();",
          "1323:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(x) VALUES(?)\").unwrap();",
          "1324:         assert_eq!(insert_stmt.execute([1i32]).unwrap(), 1);",
          "1325:         assert_eq!(insert_stmt.execute([2i32]).unwrap(), 1);",
          "1326:         assert_eq!(insert_stmt.execute([3i32]).unwrap(), 1);",
          "1328:         assert_eq!(insert_stmt.execute([\"hello\".to_string()]).unwrap(), 1);",
          "1329:         assert_eq!(insert_stmt.execute([\"goodbye\".to_string()]).unwrap(), 1);",
          "1330:         assert_eq!(insert_stmt.execute([types::Null]).unwrap(), 1);",
          "1332:         let mut update_stmt = db.prepare(\"UPDATE foo SET x=? WHERE x<?\").unwrap();",
          "1333:         assert_eq!(update_stmt.execute([3i32, 3i32]).unwrap(), 2);",
          "1334:         assert_eq!(update_stmt.execute([3i32, 3i32]).unwrap(), 0);",
          "1335:         assert_eq!(update_stmt.execute([8i32, 8i32]).unwrap(), 3);",
          "1339:     fn test_prepare_query() {",
          "1341:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\").unwrap();",
          "1343:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(x) VALUES(?)\").unwrap();",
          "1344:         assert_eq!(insert_stmt.execute([1i32]).unwrap(), 1);",
          "1345:         assert_eq!(insert_stmt.execute([2i32]).unwrap(), 1);",
          "1346:         assert_eq!(insert_stmt.execute([3i32]).unwrap(), 1);",
          "1348:         let mut query = db",
          "1349:             .prepare(\"SELECT x FROM foo WHERE x < ? ORDER BY x DESC\")",
          "1350:             .unwrap();",
          "1352:             let mut rows = query.query([4i32]).unwrap();",
          "1355:             while let Some(row) = rows.next().unwrap() {",
          "1356:                 v.push(row.get(0).unwrap());",
          "1363:             let mut rows = query.query([3i32]).unwrap();",
          "1366:             while let Some(row) = rows.next().unwrap() {",
          "1367:                 v.push(row.get(0).unwrap());",
          "1375:     fn test_query_map() {",
          "",
          "[Added Lines]",
          "1297:     fn test_prepare_column_names() -> Result<()> {",
          "1299:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\")?;",
          "1301:         let stmt = db.prepare(\"SELECT * FROM foo\")?;",
          "1305:         let stmt = db.prepare(\"SELECT x AS a, x AS b FROM foo\")?;",
          "1308:         Ok(())",
          "1312:     fn test_prepare_execute() -> Result<()> {",
          "1314:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\")?;",
          "1316:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(x) VALUES(?)\")?;",
          "1317:         assert_eq!(insert_stmt.execute([1i32])?, 1);",
          "1318:         assert_eq!(insert_stmt.execute([2i32])?, 1);",
          "1319:         assert_eq!(insert_stmt.execute([3i32])?, 1);",
          "1321:         assert_eq!(insert_stmt.execute([\"hello\".to_string()])?, 1);",
          "1322:         assert_eq!(insert_stmt.execute([\"goodbye\".to_string()])?, 1);",
          "1323:         assert_eq!(insert_stmt.execute([types::Null])?, 1);",
          "1325:         let mut update_stmt = db.prepare(\"UPDATE foo SET x=? WHERE x<?\")?;",
          "1326:         assert_eq!(update_stmt.execute([3i32, 3i32])?, 2);",
          "1327:         assert_eq!(update_stmt.execute([3i32, 3i32])?, 0);",
          "1328:         assert_eq!(update_stmt.execute([8i32, 8i32])?, 3);",
          "1329:         Ok(())",
          "1333:     fn test_prepare_query() -> Result<()> {",
          "1335:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\")?;",
          "1337:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(x) VALUES(?)\")?;",
          "1338:         assert_eq!(insert_stmt.execute([1i32])?, 1);",
          "1339:         assert_eq!(insert_stmt.execute([2i32])?, 1);",
          "1340:         assert_eq!(insert_stmt.execute([3i32])?, 1);",
          "1342:         let mut query = db.prepare(\"SELECT x FROM foo WHERE x < ? ORDER BY x DESC\")?;",
          "1344:             let mut rows = query.query([4i32])?;",
          "1347:             while let Some(row) = rows.next()? {",
          "1348:                 v.push(row.get(0)?);",
          "1355:             let mut rows = query.query([3i32])?;",
          "1358:             while let Some(row) = rows.next()? {",
          "1359:                 v.push(row.get(0)?);",
          "1364:         Ok(())",
          "1368:     fn test_query_map() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1381:                    INSERT INTO foo VALUES(2, \\\"world\\\");",
          "1382:                    INSERT INTO foo VALUES(1, \\\"!\\\");",
          "1383:                    END;\";",
          "1390:     }",
          "1392:     #[test]",
          "1394:         let db = checked_memory_handle();",
          "1395:         let sql = \"BEGIN;",
          "1396:                    CREATE TABLE foo(x INTEGER);",
          "",
          "[Removed Lines]",
          "1384:         db.execute_batch(sql).unwrap();",
          "1386:         let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\").unwrap();",
          "1387:         let results: Result<Vec<String>> = query.query([]).unwrap().map(|row| row.get(1)).collect();",
          "1389:         assert_eq!(results.unwrap().concat(), \"hello, world!\");",
          "1393:     fn test_query_row() {",
          "",
          "[Added Lines]",
          "1377:         db.execute_batch(sql)?;",
          "1379:         let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\")?;",
          "1380:         let results: Result<Vec<String>> = query.query([])?.map(|row| row.get(1)).collect();",
          "1382:         assert_eq!(results?.concat(), \"hello, world!\");",
          "1383:         Ok(())",
          "1387:     fn test_query_row() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1399:                    INSERT INTO foo VALUES(3);",
          "1400:                    INSERT INTO foo VALUES(4);",
          "1401:                    END;\";",
          "1404:         assert_eq!(",
          "1405:             10i64,",
          "1408:         );",
          "1410:         let result: Result<i64> = db.query_row(\"SELECT x FROM foo WHERE x > 5\", [], |r| r.get(0));",
          "",
          "[Removed Lines]",
          "1402:         db.execute_batch(sql).unwrap();",
          "1406:             db.query_row::<i64, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "1407:                 .unwrap()",
          "",
          "[Added Lines]",
          "1396:         db.execute_batch(sql)?;",
          "1400:             db.query_row::<i64, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1416:         let bad_query_result = db.query_row(\"NOT A PROPER QUERY; test123\", [], |_| Ok(()));",
          "1418:         assert!(bad_query_result.is_err());",
          "1419:     }",
          "1421:     #[test]",
          "1423:         let db = checked_memory_handle();",
          "1425:         let result: Result<i64> = db.query_row(\"SELECT 1 WHERE 0 <> 0\", [], |r| r.get(0));",
          "1426:         let result = result.optional();",
          "1428:             None => (),",
          "1429:             _ => panic!(\"Unexpected result\"),",
          "1430:         }",
          "1432:         let result: Result<i64> = db.query_row(\"SELECT 1 WHERE 0 == 0\", [], |r| r.get(0));",
          "1433:         let result = result.optional();",
          "1435:             Some(1) => (),",
          "1436:             _ => panic!(\"Unexpected result\"),",
          "1437:         }",
          "",
          "[Removed Lines]",
          "1422:     fn test_optional() {",
          "1427:         match result.unwrap() {",
          "1434:         match result.unwrap() {",
          "",
          "[Added Lines]",
          "1412:         Ok(())",
          "1416:     fn test_optional() -> Result<()> {",
          "1421:         match result? {",
          "1428:         match result? {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1439:         let bad_query_result: Result<i64> = db.query_row(\"NOT A PROPER QUERY\", [], |r| r.get(0));",
          "1440:         let bad_query_result = bad_query_result.optional();",
          "1441:         assert!(bad_query_result.is_err());",
          "1442:     }",
          "1444:     #[test]",
          "1446:         let db = checked_memory_handle();",
          "1448:         assert_eq!(",
          "1449:             \"memory\",",
          "1452:         );",
          "1453:         assert_eq!(",
          "1454:             \"off\",",
          "1457:         );",
          "1458:     }",
          "1460:     #[test]",
          "1462:         let db = checked_memory_handle();",
          "1465:         let err = db.prepare(\"SELECT * FROM does_not_exist\").unwrap_err();",
          "1466:         assert!(format!(\"{}\", err).contains(\"does_not_exist\"));",
          "1467:     }",
          "1469:     #[test]",
          "1471:         let db = checked_memory_handle();",
          "1476:         assert_eq!(db.last_insert_rowid(), 1);",
          "1479:         for _ in 0i32..9 {",
          "1481:         }",
          "1482:         assert_eq!(db.last_insert_rowid(), 10);",
          "1483:     }",
          "1485:     #[test]",
          "",
          "[Removed Lines]",
          "1445:     fn test_pragma_query_row() {",
          "1450:             db.query_row::<String, _, _>(\"PRAGMA journal_mode\", [], |r| r.get(0))",
          "1451:                 .unwrap()",
          "1455:             db.query_row::<String, _, _>(\"PRAGMA journal_mode=off\", [], |r| r.get(0))",
          "1456:                 .unwrap()",
          "1461:     fn test_prepare_failures() {",
          "1463:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\").unwrap();",
          "1470:     fn test_last_insert_rowid() {",
          "1472:         db.execute_batch(\"CREATE TABLE foo(x INTEGER PRIMARY KEY)\")",
          "1473:             .unwrap();",
          "1474:         db.execute_batch(\"INSERT INTO foo DEFAULT VALUES\").unwrap();",
          "1478:         let mut stmt = db.prepare(\"INSERT INTO foo DEFAULT VALUES\").unwrap();",
          "1480:             stmt.execute([]).unwrap();",
          "",
          "[Added Lines]",
          "1436:         Ok(())",
          "1440:     fn test_pragma_query_row() -> Result<()> {",
          "1445:             db.query_row::<String, _, _>(\"PRAGMA journal_mode\", [], |r| r.get(0))?",
          "1449:             db.query_row::<String, _, _>(\"PRAGMA journal_mode=off\", [], |r| r.get(0))?",
          "1451:         Ok(())",
          "1455:     fn test_prepare_failures() -> Result<()> {",
          "1457:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\")?;",
          "1461:         Ok(())",
          "1465:     fn test_last_insert_rowid() -> Result<()> {",
          "1467:         db.execute_batch(\"CREATE TABLE foo(x INTEGER PRIMARY KEY)\")?;",
          "1468:         db.execute_batch(\"INSERT INTO foo DEFAULT VALUES\")?;",
          "1472:         let mut stmt = db.prepare(\"INSERT INTO foo DEFAULT VALUES\")?;",
          "1474:             stmt.execute([])?;",
          "1477:         Ok(())",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1494:     #[test]",
          "1495:     #[cfg(feature = \"modern_sqlite\")]",
          "1497:         let db = checked_memory_handle();",
          "1498:         assert!(!db.is_busy());",
          "1500:         assert!(!db.is_busy());",
          "1501:         {",
          "1503:             assert!(!db.is_busy());",
          "1505:             assert!(db.is_busy());",
          "1506:             assert!(row.is_some());",
          "1507:         }",
          "1508:         assert!(!db.is_busy());",
          "1509:     }",
          "1511:     #[test]",
          "1513:         let db = checked_memory_handle();",
          "1514:         let query = \"SELECT 12345\";",
          "1517:         assert!(format!(\"{:?}\", stmt).contains(query));",
          "1518:     }",
          "1520:     #[test]",
          "1524:         #[cfg(feature = \"modern_sqlite\")]",
          "",
          "[Removed Lines]",
          "1496:     fn test_is_busy() {",
          "1499:         let mut stmt = db.prepare(\"PRAGMA schema_version\").unwrap();",
          "1502:             let mut rows = stmt.query([]).unwrap();",
          "1504:             let row = rows.next().unwrap();",
          "1512:     fn test_statement_debugging() {",
          "1515:         let stmt = db.prepare(query).unwrap();",
          "1521:     fn test_notnull_constraint_error() {",
          "",
          "[Added Lines]",
          "1491:     fn test_is_busy() -> Result<()> {",
          "1494:         let mut stmt = db.prepare(\"PRAGMA schema_version\")?;",
          "1497:             let mut rows = stmt.query([])?;",
          "1499:             let row = rows.next()?;",
          "1504:         Ok(())",
          "1508:     fn test_statement_debugging() -> Result<()> {",
          "1511:         let stmt = db.prepare(query)?;",
          "1514:         Ok(())",
          "1518:     fn test_notnull_constraint_error() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1529:         fn check_extended_code(_extended_code: c_int) {}",
          "1531:         let db = checked_memory_handle();",
          "1534:         let result = db.execute(\"INSERT INTO foo (x) VALUES (NULL)\", []);",
          "1535:         assert!(result.is_err());",
          "",
          "[Removed Lines]",
          "1532:         db.execute_batch(\"CREATE TABLE foo(x NOT NULL)\").unwrap();",
          "",
          "[Added Lines]",
          "1529:         db.execute_batch(\"CREATE TABLE foo(x NOT NULL)\")?;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1541:             }",
          "1542:             err => panic!(\"Unexpected error {}\", err),",
          "1543:         }",
          "1544:     }",
          "1546:     #[test]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1541:         Ok(())",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1556:     #[test]",
          "1557:     #[cfg(feature = \"functions\")]",
          "1559:         let db = checked_memory_handle();",
          "1561:         let interrupt_handle = db.get_interrupt_handle();",
          "",
          "[Removed Lines]",
          "1558:     fn test_interrupt() {",
          "",
          "[Added Lines]",
          "1556:     fn test_interrupt() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1568:                 interrupt_handle.interrupt();",
          "1569:                 Ok(0)",
          "1570:             },",
          "1580:         match result.unwrap_err() {",
          "1581:             Error::SqliteFailure(err, _) => {",
          "",
          "[Removed Lines]",
          "1571:         )",
          "1572:         .unwrap();",
          "1574:         let mut stmt = db",
          "1575:             .prepare(\"SELECT interrupt() FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)\")",
          "1576:             .unwrap();",
          "1578:         let result: Result<Vec<i32>> = stmt.query([]).unwrap().map(|r| r.get(0)).collect();",
          "",
          "[Added Lines]",
          "1569:         )?;",
          "1571:         let mut stmt =",
          "1572:             db.prepare(\"SELECT interrupt() FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)\")?;",
          "1574:         let result: Result<Vec<i32>> = stmt.query([])?.map(|r| r.get(0)).collect();",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1585:                 panic!(\"Unexpected error {}\", err);",
          "1586:             }",
          "1587:         }",
          "1588:     }",
          "1590:     #[test]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1584:         Ok(())",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1604:     }",
          "1606:     #[test]",
          "1608:         let db = checked_memory_handle();",
          "1610:         let vals = [\"foobar\", \"1234\", \"qwerty\"];",
          "1612:         for (i, v) in vals.iter().enumerate() {",
          "1613:             let i_to_insert = i as i64;",
          "1615:         }",
          "1622:             let expect = vals[i as usize];",
          "1624:             assert_eq!(x, expect);",
          "1625:         }",
          "1626:     }",
          "1628:     #[test]",
          "1630:         let db = checked_memory_handle();",
          "1631:         let handle = unsafe { db.handle() };",
          "1632:         {",
          "1635:         }",
          "1636:         db.close().unwrap();",
          "1637:     }",
          "1639:     mod query_and_then_tests {",
          "",
          "[Removed Lines]",
          "1607:     fn test_get_raw() {",
          "1609:         db.execute_batch(\"CREATE TABLE foo(i, x);\").unwrap();",
          "1611:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(i, x) VALUES(?, ?)\").unwrap();",
          "1614:             assert_eq!(insert_stmt.execute(params![i_to_insert, v]).unwrap(), 1);",
          "1617:         let mut query = db.prepare(\"SELECT i, x FROM foo\").unwrap();",
          "1618:         let mut rows = query.query([]).unwrap();",
          "1620:         while let Some(row) = rows.next().unwrap() {",
          "1621:             let i = row.get_raw(0).as_i64().unwrap();",
          "1623:             let x = row.get_raw(\"x\").as_str().unwrap();",
          "1629:     fn test_from_handle() {",
          "1633:             let db = unsafe { Connection::from_handle(handle) }.unwrap();",
          "1634:             db.execute_batch(\"PRAGMA VACUUM\").unwrap();",
          "",
          "[Added Lines]",
          "1604:     fn test_get_raw() -> Result<()> {",
          "1606:         db.execute_batch(\"CREATE TABLE foo(i, x);\")?;",
          "1608:         let mut insert_stmt = db.prepare(\"INSERT INTO foo(i, x) VALUES(?, ?)\")?;",
          "1611:             assert_eq!(insert_stmt.execute(params![i_to_insert, v])?, 1);",
          "1614:         let mut query = db.prepare(\"SELECT i, x FROM foo\")?;",
          "1615:         let mut rows = query.query([])?;",
          "1617:         while let Some(row) = rows.next()? {",
          "1618:             let i = row.get_raw(0).as_i64()?;",
          "1620:             let x = row.get_raw(\"x\").as_str()?;",
          "1623:         Ok(())",
          "1627:     fn test_from_handle() -> Result<()> {",
          "1631:             let db = unsafe { Connection::from_handle(handle) }?;",
          "1632:             db.execute_batch(\"PRAGMA VACUUM\")?;",
          "1635:         Ok(())",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1677:         type CustomResult<T> = Result<T, CustomError>;",
          "1679:         #[test]",
          "1681:             let db = checked_memory_handle();",
          "1682:             let sql = \"BEGIN;",
          "1683:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "",
          "[Removed Lines]",
          "1680:         fn test_query_and_then() {",
          "",
          "[Added Lines]",
          "1679:         fn test_query_and_then() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1686:                        INSERT INTO foo VALUES(2, \\\"world\\\");",
          "1687:                        INSERT INTO foo VALUES(1, \\\"!\\\");",
          "1688:                        END;\";",
          "1698:         }",
          "1700:         #[test]",
          "1702:             let db = checked_memory_handle();",
          "1703:             let sql = \"BEGIN;",
          "1704:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "",
          "[Removed Lines]",
          "1689:             db.execute_batch(sql).unwrap();",
          "1691:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\").unwrap();",
          "1692:             let results: Result<Vec<String>> = query",
          "1693:                 .query_and_then([], |row| row.get(1))",
          "1694:                 .unwrap()",
          "1695:                 .collect();",
          "1697:             assert_eq!(results.unwrap().concat(), \"hello, world!\");",
          "1701:         fn test_query_and_then_fails() {",
          "",
          "[Added Lines]",
          "1688:             db.execute_batch(sql)?;",
          "1690:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\")?;",
          "1691:             let results: Result<Vec<String>> =",
          "1692:                 query.query_and_then([], |row| row.get(1))?.collect();",
          "1694:             assert_eq!(results?.concat(), \"hello, world!\");",
          "1695:             Ok(())",
          "1699:         fn test_query_and_then_fails() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1707:                        INSERT INTO foo VALUES(2, \\\"world\\\");",
          "1708:                        INSERT INTO foo VALUES(1, \\\"!\\\");",
          "1709:                        END;\";",
          "1718:             match bad_type.unwrap_err() {",
          "1719:                 Error::InvalidColumnType(..) => (),",
          "1720:                 err => panic!(\"Unexpected error {}\", err),",
          "1721:             }",
          "1728:             match bad_idx.unwrap_err() {",
          "1729:                 Error::InvalidColumnIndex(_) => (),",
          "1730:                 err => panic!(\"Unexpected error {}\", err),",
          "1731:             }",
          "1732:         }",
          "1734:         #[test]",
          "1736:             let db = checked_memory_handle();",
          "1737:             let sql = \"BEGIN;",
          "1738:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "",
          "[Removed Lines]",
          "1710:             db.execute_batch(sql).unwrap();",
          "1712:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\").unwrap();",
          "1713:             let bad_type: Result<Vec<f64>> = query",
          "1714:                 .query_and_then([], |row| row.get(1))",
          "1715:                 .unwrap()",
          "1716:                 .collect();",
          "1723:             let bad_idx: Result<Vec<String>> = query",
          "1724:                 .query_and_then([], |row| row.get(3))",
          "1725:                 .unwrap()",
          "1726:                 .collect();",
          "1735:         fn test_query_and_then_custom_error() {",
          "",
          "[Added Lines]",
          "1708:             db.execute_batch(sql)?;",
          "1710:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\")?;",
          "1711:             let bad_type: Result<Vec<f64>> = query.query_and_then([], |row| row.get(1))?.collect();",
          "1718:             let bad_idx: Result<Vec<String>> =",
          "1719:                 query.query_and_then([], |row| row.get(3))?.collect();",
          "1725:             Ok(())",
          "1729:         fn test_query_and_then_custom_error() -> CustomResult<()> {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1741:                        INSERT INTO foo VALUES(2, \\\"world\\\");",
          "1742:                        INSERT INTO foo VALUES(1, \\\"!\\\");",
          "1743:                        END;\";",
          "1747:             let results: CustomResult<Vec<String>> = query",
          "1750:                 .collect();",
          "1753:         }",
          "1755:         #[test]",
          "1757:             let db = checked_memory_handle();",
          "1758:             let sql = \"BEGIN;",
          "1759:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "",
          "[Removed Lines]",
          "1744:             db.execute_batch(sql).unwrap();",
          "1746:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\").unwrap();",
          "1748:                 .query_and_then([], |row| row.get(1).map_err(CustomError::Sqlite))",
          "1749:                 .unwrap()",
          "1752:             assert_eq!(results.unwrap().concat(), \"hello, world!\");",
          "1756:         fn test_query_and_then_custom_error_fails() {",
          "",
          "[Added Lines]",
          "1738:             db.execute_batch(sql)?;",
          "1740:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\")?;",
          "1742:                 .query_and_then([], |row| row.get(1).map_err(CustomError::Sqlite))?",
          "1745:             assert_eq!(results?.concat(), \"hello, world!\");",
          "1746:             Ok(())",
          "1750:         fn test_query_and_then_custom_error_fails() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1762:                        INSERT INTO foo VALUES(2, \\\"world\\\");",
          "1763:                        INSERT INTO foo VALUES(1, \\\"!\\\");",
          "1764:                        END;\";",
          "1768:             let bad_type: CustomResult<Vec<f64>> = query",
          "1771:                 .collect();",
          "1773:             match bad_type.unwrap_err() {",
          "",
          "[Removed Lines]",
          "1765:             db.execute_batch(sql).unwrap();",
          "1767:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\").unwrap();",
          "1769:                 .query_and_then([], |row| row.get(1).map_err(CustomError::Sqlite))",
          "1770:                 .unwrap()",
          "",
          "[Added Lines]",
          "1759:             db.execute_batch(sql)?;",
          "1761:             let mut query = db.prepare(\"SELECT x, y FROM foo ORDER BY x DESC\")?;",
          "1763:                 .query_and_then([], |row| row.get(1).map_err(CustomError::Sqlite))?",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1776:             }",
          "1778:             let bad_idx: CustomResult<Vec<String>> = query",
          "1781:                 .collect();",
          "1783:             match bad_idx.unwrap_err() {",
          "",
          "[Removed Lines]",
          "1779:                 .query_and_then([], |row| row.get(3).map_err(CustomError::Sqlite))",
          "1780:                 .unwrap()",
          "",
          "[Added Lines]",
          "1772:                 .query_and_then([], |row| row.get(3).map_err(CustomError::Sqlite))?",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1786:             }",
          "1788:             let non_sqlite_err: CustomResult<Vec<String>> = query",
          "1791:                 .collect();",
          "1793:             match non_sqlite_err.unwrap_err() {",
          "1794:                 CustomError::SomeError => (),",
          "1795:                 err => panic!(\"Unexpected error {}\", err),",
          "1796:             }",
          "1797:         }",
          "1799:         #[test]",
          "1801:             let db = checked_memory_handle();",
          "1802:             let sql = \"BEGIN;",
          "1803:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "1804:                        INSERT INTO foo VALUES(4, \\\"hello\\\");",
          "1805:                        END;\";",
          "1808:             let query = \"SELECT x, y FROM foo ORDER BY x DESC\";",
          "1809:             let results: CustomResult<String> =",
          "1810:                 db.query_row_and_then(query, [], |row| row.get(1).map_err(CustomError::Sqlite));",
          "1813:         }",
          "1815:         #[test]",
          "1817:             let db = checked_memory_handle();",
          "1818:             let sql = \"BEGIN;",
          "1819:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "1820:                        INSERT INTO foo VALUES(4, \\\"hello\\\");",
          "1821:                        END;\";",
          "1824:             let query = \"SELECT x, y FROM foo ORDER BY x DESC\";",
          "1825:             let bad_type: CustomResult<f64> =",
          "",
          "[Removed Lines]",
          "1789:                 .query_and_then([], |_| Err(CustomError::SomeError))",
          "1790:                 .unwrap()",
          "1800:         fn test_query_row_and_then_custom_error() {",
          "1806:             db.execute_batch(sql).unwrap();",
          "1812:             assert_eq!(results.unwrap(), \"hello\");",
          "1816:         fn test_query_row_and_then_custom_error_fails() {",
          "1822:             db.execute_batch(sql).unwrap();",
          "",
          "[Added Lines]",
          "1781:                 .query_and_then([], |_| Err(CustomError::SomeError))?",
          "1788:             Ok(())",
          "1792:         fn test_query_row_and_then_custom_error() -> CustomResult<()> {",
          "1798:             db.execute_batch(sql)?;",
          "1804:             assert_eq!(results?, \"hello\");",
          "1805:             Ok(())",
          "1809:         fn test_query_row_and_then_custom_error_fails() -> Result<()> {",
          "1815:             db.execute_batch(sql)?;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1845:                 CustomError::SomeError => (),",
          "1846:                 err => panic!(\"Unexpected error {}\", err),",
          "1847:             }",
          "1848:         }",
          "1849:     }",
          "1851:     #[test]",
          "1853:         let db = checked_memory_handle();",
          "1854:         let sql = \"BEGIN;",
          "1855:                        CREATE TABLE foo(x INTEGER, y TEXT);",
          "1856:                        INSERT INTO foo VALUES(4, \\\"hello\\\");",
          "1857:                        END;\";",
          "1860:         db.query_row(\"SELECT * FROM foo\", [], |r| {",
          "1861:             assert_eq!(2, r.column_count());",
          "1862:             Ok(())",
          "1863:         })",
          "1865:     }",
          "1866:     #[test]",
          "1868:         let db = checked_memory_handle();",
          "1870:         let b: Box<dyn ToSql> = Box::new(5);",
          "1872:         db.query_row(\"SELECT x FROM foo\", [], |r| {",
          "1873:             assert_eq!(5, r.get_unwrap::<_, i32>(0));",
          "1874:             Ok(())",
          "1875:         })",
          "1877:     }",
          "1879:     #[test]",
          "1881:         let db = checked_memory_handle();",
          "1882:         db.query_row(",
          "1883:             \"SELECT",
          "",
          "[Removed Lines]",
          "1852:     fn test_dynamic() {",
          "1858:         db.execute_batch(sql).unwrap();",
          "1864:         .unwrap();",
          "1867:     fn test_dyn_box() {",
          "1869:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\").unwrap();",
          "1871:         db.execute(\"INSERT INTO foo VALUES(?)\", [b]).unwrap();",
          "1876:         .unwrap();",
          "1880:     fn test_params() {",
          "",
          "[Added Lines]",
          "1841:             Ok(())",
          "1846:     fn test_dynamic() -> Result<()> {",
          "1852:         db.execute_batch(sql)?;",
          "1860:     fn test_dyn_box() -> Result<()> {",
          "1862:         db.execute_batch(\"CREATE TABLE foo(x INTEGER);\")?;",
          "1864:         db.execute(\"INSERT INTO foo VALUES(?)\", [b])?;",
          "1872:     fn test_params() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1894:                 Ok(())",
          "1895:             },",
          "1896:         )",
          "1898:     }",
          "1900:     #[test]",
          "1901:     #[cfg(not(feature = \"extra_check\"))]",
          "1903:         let db = checked_memory_handle();",
          "1907:     }",
          "1909:     #[test]",
          "1911:         let db = checked_memory_handle();",
          "1912:         let sql = r\"",
          "1913:              CREATE TABLE tbl1 (col);",
          "",
          "[Removed Lines]",
          "1897:         .unwrap();",
          "1902:     fn test_alter_table() {",
          "1904:         db.execute_batch(\"CREATE TABLE x(t);\").unwrap();",
          "1906:         db.execute(\"ALTER TABLE x RENAME TO y;\", []).unwrap();",
          "1910:     fn test_batch() {",
          "",
          "[Added Lines]",
          "1893:     fn test_alter_table() -> Result<()> {",
          "1895:         db.execute_batch(\"CREATE TABLE x(t);\")?;",
          "1897:         db.execute(\"ALTER TABLE x RENAME TO y;\", [])",
          "1901:     fn test_batch() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1915:              \";",
          "1916:         let batch = Batch::new(&db, sql);",
          "1917:         for stmt in batch {",
          "1920:         }",
          "1921:     }",
          "1922: }",
          "",
          "[Removed Lines]",
          "1918:             let mut stmt = stmt.unwrap();",
          "1919:             stmt.execute([]).unwrap();",
          "",
          "[Added Lines]",
          "1909:             let mut stmt = stmt?;",
          "1910:             stmt.execute([])?;",
          "1912:         Ok(())",
          "",
          "---------------"
        ],
        "src/limits.rs||src/limits.rs": [
          "File: src/limits.rs -> src/limits.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #[cfg(test)]",
          "28: mod test {",
          "29:     use crate::ffi::Limit;",
          "32:     #[test]",
          "35:         db.set_limit(Limit::SQLITE_LIMIT_LENGTH, 1024);",
          "36:         assert_eq!(1024, db.limit(Limit::SQLITE_LIMIT_LENGTH));",
          "",
          "[Removed Lines]",
          "30:     use crate::Connection;",
          "33:     fn test_limit() {",
          "34:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "30:     use crate::{Connection, Result};",
          "33:     fn test_limit() -> Result<()> {",
          "34:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:             db.set_limit(Limit::SQLITE_LIMIT_WORKER_THREADS, 2);",
          "71:             assert_eq!(2, db.limit(Limit::SQLITE_LIMIT_WORKER_THREADS));",
          "72:         }",
          "73:     }",
          "74: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:         Ok(())",
          "",
          "---------------"
        ],
        "src/pragma.rs||src/pragma.rs": [
          "File: src/pragma.rs -> src/pragma.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "314: mod test {",
          "315:     use super::Sql;",
          "316:     use crate::pragma;",
          "319:     #[test]",
          "325:         assert_eq!(0, user_version);",
          "326:     }",
          "328:     #[test]",
          "329:     #[cfg(feature = \"modern_sqlite\")]",
          "334:                 row.get(0)",
          "337:         assert_eq!(0, user_version);",
          "338:     }",
          "340:     #[test]",
          "343:         let mut user_version = -1;",
          "344:         db.pragma_query(None, \"user_version\", |row| {",
          "345:             user_version = row.get(0)?;",
          "346:             Ok(())",
          "349:         assert_eq!(0, user_version);",
          "350:     }",
          "352:     #[test]",
          "355:         let mut user_version = -1;",
          "356:         db.pragma_query(Some(DatabaseName::Main), \"user_version\", |row| {",
          "357:             user_version = row.get(0)?;",
          "358:             Ok(())",
          "361:         assert_eq!(0, user_version);",
          "362:     }",
          "364:     #[test]",
          "367:         let mut columns = Vec::new();",
          "368:         db.pragma(None, \"table_info\", &\"sqlite_master\", |row| {",
          "369:             let column: String = row.get(1)?;",
          "370:             columns.push(column);",
          "371:             Ok(())",
          "374:         assert_eq!(5, columns.len());",
          "375:     }",
          "377:     #[test]",
          "378:     #[cfg(feature = \"modern_sqlite\")]",
          "382:         let mut columns = Vec::new();",
          "386:             let row = row;",
          "388:             columns.push(column);",
          "389:         }",
          "390:         assert_eq!(5, columns.len());",
          "391:     }",
          "393:     #[test]",
          "397:     }",
          "399:     #[test]",
          "405:         assert_eq!(\"off\", &journal_mode);",
          "406:     }",
          "408:     #[test]",
          "",
          "[Removed Lines]",
          "317:     use crate::{Connection, DatabaseName};",
          "320:     fn pragma_query_value() {",
          "321:         let db = Connection::open_in_memory().unwrap();",
          "322:         let user_version: i32 = db",
          "323:             .pragma_query_value(None, \"user_version\", |row| row.get(0))",
          "324:             .unwrap();",
          "330:     fn pragma_func_query_value() {",
          "331:         let db = Connection::open_in_memory().unwrap();",
          "332:         let user_version: i32 = db",
          "333:             .query_row(\"SELECT user_version FROM pragma_user_version\", [], |row| {",
          "335:             })",
          "336:             .unwrap();",
          "341:     fn pragma_query_no_schema() {",
          "342:         let db = Connection::open_in_memory().unwrap();",
          "347:         })",
          "348:         .unwrap();",
          "353:     fn pragma_query_with_schema() {",
          "354:         let db = Connection::open_in_memory().unwrap();",
          "359:         })",
          "360:         .unwrap();",
          "365:     fn pragma() {",
          "366:         let db = Connection::open_in_memory().unwrap();",
          "372:         })",
          "373:         .unwrap();",
          "379:     fn pragma_func() {",
          "380:         let db = Connection::open_in_memory().unwrap();",
          "381:         let mut table_info = db.prepare(\"SELECT * FROM pragma_table_info(?)\").unwrap();",
          "383:         let mut rows = table_info.query(&[\"sqlite_master\"]).unwrap();",
          "385:         while let Some(row) = rows.next().unwrap() {",
          "387:             let column: String = row.get(1).unwrap();",
          "394:     fn pragma_update() {",
          "395:         let db = Connection::open_in_memory().unwrap();",
          "396:         db.pragma_update(None, \"user_version\", &1).unwrap();",
          "400:     fn pragma_update_and_check() {",
          "401:         let db = Connection::open_in_memory().unwrap();",
          "402:         let journal_mode: String = db",
          "403:             .pragma_update_and_check(None, \"journal_mode\", &\"OFF\", |row| row.get(0))",
          "404:             .unwrap();",
          "",
          "[Added Lines]",
          "317:     use crate::{Connection, DatabaseName, Result};",
          "320:     fn pragma_query_value() -> Result<()> {",
          "321:         let db = Connection::open_in_memory()?;",
          "322:         let user_version: i32 = db.pragma_query_value(None, \"user_version\", |row| row.get(0))?;",
          "324:         Ok(())",
          "329:     fn pragma_func_query_value() -> Result<()> {",
          "330:         let db = Connection::open_in_memory()?;",
          "331:         let user_version: i32 =",
          "332:             db.query_row(\"SELECT user_version FROM pragma_user_version\", [], |row| {",
          "334:             })?;",
          "336:         Ok(())",
          "340:     fn pragma_query_no_schema() -> Result<()> {",
          "341:         let db = Connection::open_in_memory()?;",
          "346:         })?;",
          "348:         Ok(())",
          "352:     fn pragma_query_with_schema() -> Result<()> {",
          "353:         let db = Connection::open_in_memory()?;",
          "358:         })?;",
          "360:         Ok(())",
          "364:     fn pragma() -> Result<()> {",
          "365:         let db = Connection::open_in_memory()?;",
          "371:         })?;",
          "373:         Ok(())",
          "378:     fn pragma_func() -> Result<()> {",
          "379:         let db = Connection::open_in_memory()?;",
          "380:         let mut table_info = db.prepare(\"SELECT * FROM pragma_table_info(?)\")?;",
          "382:         let mut rows = table_info.query(&[\"sqlite_master\"])?;",
          "384:         while let Some(row) = rows.next()? {",
          "386:             let column: String = row.get(1)?;",
          "390:         Ok(())",
          "394:     fn pragma_update() -> Result<()> {",
          "395:         let db = Connection::open_in_memory()?;",
          "396:         db.pragma_update(None, \"user_version\", &1)",
          "400:     fn pragma_update_and_check() -> Result<()> {",
          "401:         let db = Connection::open_in_memory()?;",
          "402:         let journal_mode: String =",
          "403:             db.pragma_update_and_check(None, \"journal_mode\", &\"OFF\", |row| row.get(0))?;",
          "405:         Ok(())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "428:     }",
          "430:     #[test]",
          "433:         let r = db.pragma_update(None, \"locking_mode\", &\"exclusive\");",
          "434:         if cfg!(feature = \"extra_check\") {",
          "435:             r.unwrap_err();",
          "436:         } else {",
          "438:         }",
          "439:     }",
          "440: }",
          "",
          "[Removed Lines]",
          "431:     fn locking_mode() {",
          "432:         let db = Connection::open_in_memory().unwrap();",
          "437:             r.unwrap();",
          "",
          "[Added Lines]",
          "431:     fn locking_mode() -> Result<()> {",
          "432:         let db = Connection::open_in_memory()?;",
          "437:             r?;",
          "439:         Ok(())",
          "",
          "---------------"
        ],
        "src/row.rs||src/row.rs": [
          "File: src/row.rs -> src/row.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: #[cfg(test)]",
          "414: mod tests {",
          "415:     #![allow(clippy::redundant_closure)] // false positives due to lifetime issues; clippy issue #5594",
          "417:     #[test]",
          "420:         use std::convert::TryFrom;",
          "423:         conn.execute(",
          "424:             \"CREATE TABLE test (a INTEGER)\",",
          "425:             crate::params_from_iter(std::iter::empty::<&dyn ToSql>()),",
          "433:         assert_eq!(val, (42,));",
          "434:         let fail = conn.query_row(\"SELECT a FROM test\", [], |row| <(u32, u32)>::try_from(row));",
          "435:         assert!(fail.is_err());",
          "436:     }",
          "438:     #[test]",
          "441:         use std::convert::TryFrom;",
          "453:         assert_eq!(val, (42, 47));",
          "454:         let fail = conn.query_row(\"SELECT a, b FROM test\", [], |row| {",
          "455:             <(u32, u32, u32)>::try_from(row)",
          "456:         });",
          "457:         assert!(fail.is_err());",
          "458:     }",
          "460:     #[test]",
          "463:         use std::convert::TryFrom;",
          "465:         let create_table = \"CREATE TABLE test (",
          "",
          "[Removed Lines]",
          "418:     fn test_try_from_row_for_tuple_1() {",
          "419:         use crate::{Connection, ToSql};",
          "422:         let conn = Connection::open_in_memory().expect(\"failed to create in-memoory database\");",
          "426:         )",
          "427:         .expect(\"failed to create table\");",
          "428:         conn.execute(\"INSERT INTO test VALUES (42)\", [])",
          "429:             .expect(\"failed to insert value\");",
          "430:         let val = conn",
          "431:             .query_row(\"SELECT a FROM test\", [], |row| <(u32,)>::try_from(row))",
          "432:             .expect(\"failed to query row\");",
          "439:     fn test_try_from_row_for_tuple_2() {",
          "440:         use crate::Connection;",
          "443:         let conn = Connection::open_in_memory().expect(\"failed to create in-memoory database\");",
          "444:         conn.execute(\"CREATE TABLE test (a INTEGER, b INTEGER)\", [])",
          "445:             .expect(\"failed to create table\");",
          "446:         conn.execute(\"INSERT INTO test VALUES (42, 47)\", [])",
          "447:             .expect(\"failed to insert value\");",
          "448:         let val = conn",
          "449:             .query_row(\"SELECT a, b FROM test\", [], |row| {",
          "450:                 <(u32, u32)>::try_from(row)",
          "451:             })",
          "452:             .expect(\"failed to query row\");",
          "461:     fn test_try_from_row_for_tuple_16() {",
          "462:         use crate::Connection;",
          "",
          "[Added Lines]",
          "416:     use crate::{Connection, Result};",
          "419:     fn test_try_from_row_for_tuple_1() -> Result<()> {",
          "420:         use crate::ToSql;",
          "423:         let conn = Connection::open_in_memory()?;",
          "427:         )?;",
          "428:         conn.execute(\"INSERT INTO test VALUES (42)\", [])?;",
          "429:         let val = conn.query_row(\"SELECT a FROM test\", [], |row| <(u32,)>::try_from(row))?;",
          "433:         Ok(())",
          "437:     fn test_try_from_row_for_tuple_2() -> Result<()> {",
          "440:         let conn = Connection::open_in_memory()?;",
          "441:         conn.execute(\"CREATE TABLE test (a INTEGER, b INTEGER)\", [])?;",
          "442:         conn.execute(\"INSERT INTO test VALUES (42, 47)\", [])?;",
          "443:         let val = conn.query_row(\"SELECT a, b FROM test\", [], |row| {",
          "444:             <(u32, u32)>::try_from(row)",
          "445:         })?;",
          "451:         Ok(())",
          "455:     fn test_try_from_row_for_tuple_16() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519:             u32,",
          "520:         );",
          "531:         assert_eq!(val.0, 0);",
          "532:         assert_eq!(val.1, 1);",
          "",
          "[Removed Lines]",
          "522:         let conn = Connection::open_in_memory().expect(\"failed to create in-memoory database\");",
          "523:         conn.execute(create_table, [])",
          "524:             .expect(\"failed to create table\");",
          "525:         conn.execute(insert_values, [])",
          "526:             .expect(\"failed to insert value\");",
          "527:         let val = conn",
          "528:             .query_row(\"SELECT * FROM test\", [], |row| BigTuple::try_from(row))",
          "529:             .expect(\"failed to query row\");",
          "",
          "[Added Lines]",
          "515:         let conn = Connection::open_in_memory()?;",
          "516:         conn.execute(create_table, [])?;",
          "517:         conn.execute(insert_values, [])?;",
          "518:         let val = conn.query_row(\"SELECT * FROM test\", [], |row| BigTuple::try_from(row))?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "546:         assert_eq!(val.15, 15);",
          "549:     }",
          "550: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "538:         Ok(())",
          "",
          "---------------"
        ],
        "src/session.rs||src/session.rs": [
          "File: src/session.rs -> src/session.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "782:     use super::{Changeset, ChangesetIter, ConflictAction, ConflictType, Session};",
          "783:     use crate::hooks::Action;",
          "792:         assert!(session.is_empty());",
          "799:     }",
          "807:         assert!(session.is_empty());",
          "813:         let mut output = Vec::new();",
          "816:     }",
          "818:     #[test]",
          "823:         assert!(item.is_some());",
          "825:         let item = item.unwrap();",
          "827:         assert_eq!(\"foo\", op.table_name());",
          "828:         assert_eq!(1, op.number_of_columns());",
          "829:         assert_eq!(Action::SQLITE_INSERT, op.code());",
          "830:         assert_eq!(false, op.indirect());",
          "833:         assert_eq!(&[1], pk);",
          "836:         assert_eq!(Ok(\"bar\"), new_value.as_str());",
          "837:     }",
          "839:     #[test]",
          "842:         assert!(!output.is_empty());",
          "843:         assert_eq!(14, output.len());",
          "845:         let input: &mut dyn Read = &mut output.as_slice();",
          "848:         assert!(item.is_some());",
          "849:     }",
          "851:     #[test]",
          "859:         static CALLED: AtomicBool = AtomicBool::new(false);",
          "860:         db.apply(",
          "",
          "[Removed Lines]",
          "784:     use crate::Connection;",
          "786:     fn one_changeset() -> Changeset {",
          "787:         let db = Connection::open_in_memory().unwrap();",
          "788:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")",
          "789:             .unwrap();",
          "791:         let mut session = Session::new(&db).unwrap();",
          "794:         session.attach(None).unwrap();",
          "795:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])",
          "796:             .unwrap();",
          "798:         session.changeset().unwrap()",
          "801:     fn one_changeset_strm() -> Vec<u8> {",
          "802:         let db = Connection::open_in_memory().unwrap();",
          "803:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")",
          "804:             .unwrap();",
          "806:         let mut session = Session::new(&db).unwrap();",
          "809:         session.attach(None).unwrap();",
          "810:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])",
          "811:             .unwrap();",
          "814:         session.changeset_strm(&mut output).unwrap();",
          "815:         output",
          "819:     fn test_changeset() {",
          "820:         let changeset = one_changeset();",
          "821:         let mut iter = changeset.iter().unwrap();",
          "822:         let item = iter.next().unwrap();",
          "826:         let op = item.op().unwrap();",
          "832:         let pk = item.pk().unwrap();",
          "835:         let new_value = item.new_value(0).unwrap();",
          "840:     fn test_changeset_strm() {",
          "841:         let output = one_changeset_strm();",
          "846:         let mut iter = ChangesetIter::start_strm(&input).unwrap();",
          "847:         let item = iter.next().unwrap();",
          "852:     fn test_changeset_apply() {",
          "853:         let changeset = one_changeset();",
          "855:         let db = Connection::open_in_memory().unwrap();",
          "856:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")",
          "857:             .unwrap();",
          "",
          "[Added Lines]",
          "784:     use crate::{Connection, Result};",
          "786:     fn one_changeset() -> Result<Changeset> {",
          "787:         let db = Connection::open_in_memory()?;",
          "788:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")?;",
          "790:         let mut session = Session::new(&db)?;",
          "793:         session.attach(None)?;",
          "794:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])?;",
          "796:         session.changeset()",
          "799:     fn one_changeset_strm() -> Result<Vec<u8>> {",
          "800:         let db = Connection::open_in_memory()?;",
          "801:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")?;",
          "803:         let mut session = Session::new(&db)?;",
          "806:         session.attach(None)?;",
          "807:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])?;",
          "810:         session.changeset_strm(&mut output)?;",
          "811:         Ok(output)",
          "815:     fn test_changeset() -> Result<()> {",
          "816:         let changeset = one_changeset()?;",
          "817:         let mut iter = changeset.iter()?;",
          "818:         let item = iter.next()?;",
          "822:         let op = item.op()?;",
          "828:         let pk = item.pk()?;",
          "831:         let new_value = item.new_value(0)?;",
          "833:         Ok(())",
          "837:     fn test_changeset_strm() -> Result<()> {",
          "838:         let output = one_changeset_strm()?;",
          "843:         let mut iter = ChangesetIter::start_strm(&input)?;",
          "844:         let item = iter.next()?;",
          "846:         Ok(())",
          "850:     fn test_changeset_apply() -> Result<()> {",
          "851:         let changeset = one_changeset()?;",
          "853:         let db = Connection::open_in_memory()?;",
          "854:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "864:                 CALLED.store(true, Ordering::Relaxed);",
          "865:                 ConflictAction::SQLITE_CHANGESET_OMIT",
          "866:             },",
          "870:         assert!(!CALLED.load(Ordering::Relaxed));",
          "876:         assert_eq!(1, check);",
          "",
          "[Removed Lines]",
          "867:         )",
          "868:         .unwrap();",
          "871:         let check = db",
          "872:             .query_row(\"SELECT 1 FROM foo WHERE t = ?\", &[\"bar\"], |row| {",
          "873:                 row.get::<_, i32>(0)",
          "874:             })",
          "875:             .unwrap();",
          "",
          "[Added Lines]",
          "864:         )?;",
          "867:         let check = db.query_row(\"SELECT 1 FROM foo WHERE t = ?\", &[\"bar\"], |row| {",
          "868:             row.get::<_, i32>(0)",
          "869:         })?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "886:                 assert_eq!(Ok(\"bar\"), conflict.as_str());",
          "887:                 ConflictAction::SQLITE_CHANGESET_OMIT",
          "888:             },",
          "891:         assert!(CALLED.load(Ordering::Relaxed));",
          "892:     }",
          "894:     #[test]",
          "902:         let mut input = output.as_slice();",
          "903:         db.apply_strm(",
          "904:             &mut input,",
          "905:             None::<fn(&str) -> bool>,",
          "906:             |_conflict_type, _item| ConflictAction::SQLITE_CHANGESET_OMIT,",
          "915:         assert_eq!(1, check);",
          "916:     }",
          "918:     #[test]",
          "925:         assert!(session.is_empty());",
          "931:         assert!(!session.is_empty());",
          "932:     }",
          "934:     #[test]",
          "939:         assert!(session.is_enabled());",
          "940:         session.set_enabled(false);",
          "941:         assert!(!session.is_enabled());",
          "942:     }",
          "944:     #[test]",
          "949:         assert!(!session.is_indirect());",
          "950:         session.set_indirect(true);",
          "951:         assert!(session.is_indirect());",
          "952:     }",
          "953: }",
          "",
          "[Removed Lines]",
          "889:         )",
          "890:         .unwrap();",
          "895:     fn test_changeset_apply_strm() {",
          "896:         let output = one_changeset_strm();",
          "898:         let db = Connection::open_in_memory().unwrap();",
          "899:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")",
          "900:             .unwrap();",
          "907:         )",
          "908:         .unwrap();",
          "910:         let check = db",
          "911:             .query_row(\"SELECT 1 FROM foo WHERE t = ?\", &[\"bar\"], |row| {",
          "912:                 row.get::<_, i32>(0)",
          "913:             })",
          "914:             .unwrap();",
          "919:     fn test_session_empty() {",
          "920:         let db = Connection::open_in_memory().unwrap();",
          "921:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")",
          "922:             .unwrap();",
          "924:         let mut session = Session::new(&db).unwrap();",
          "927:         session.attach(None).unwrap();",
          "928:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])",
          "929:             .unwrap();",
          "935:     fn test_session_set_enabled() {",
          "936:         let db = Connection::open_in_memory().unwrap();",
          "938:         let mut session = Session::new(&db).unwrap();",
          "945:     fn test_session_set_indirect() {",
          "946:         let db = Connection::open_in_memory().unwrap();",
          "948:         let mut session = Session::new(&db).unwrap();",
          "",
          "[Added Lines]",
          "883:         )?;",
          "885:         Ok(())",
          "889:     fn test_changeset_apply_strm() -> Result<()> {",
          "890:         let output = one_changeset_strm()?;",
          "892:         let db = Connection::open_in_memory()?;",
          "893:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")?;",
          "900:         )?;",
          "902:         let check = db.query_row(\"SELECT 1 FROM foo WHERE t = ?\", &[\"bar\"], |row| {",
          "903:             row.get::<_, i32>(0)",
          "904:         })?;",
          "906:         Ok(())",
          "910:     fn test_session_empty() -> Result<()> {",
          "911:         let db = Connection::open_in_memory()?;",
          "912:         db.execute_batch(\"CREATE TABLE foo(t TEXT PRIMARY KEY NOT NULL);\")?;",
          "914:         let mut session = Session::new(&db)?;",
          "917:         session.attach(None)?;",
          "918:         db.execute(\"INSERT INTO foo (t) VALUES (?);\", &[\"bar\"])?;",
          "921:         Ok(())",
          "925:     fn test_session_set_enabled() -> Result<()> {",
          "926:         let db = Connection::open_in_memory()?;",
          "928:         let mut session = Session::new(&db)?;",
          "932:         Ok(())",
          "936:     fn test_session_set_indirect() -> Result<()> {",
          "937:         let db = Connection::open_in_memory()?;",
          "939:         let mut session = Session::new(&db)?;",
          "943:         Ok(())",
          "",
          "---------------"
        ],
        "src/statement.rs||src/statement.rs": [
          "File: src/statement.rs -> src/statement.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "941:     #[test]",
          "942:     #[allow(deprecated)]",
          "947:         assert_eq!(",
          "950:             1",
          "951:         );",
          "952:         assert_eq!(",
          "955:             1",
          "956:         );",
          "957:         assert_eq!(",
          "958:             db.execute(",
          "959:                 \"INSERT INTO foo(x) VALUES (:x)\",",
          "960:                 crate::named_params! {\":x\": 3i32}",
          "963:             1",
          "964:         );",
          "",
          "[Removed Lines]",
          "943:     fn test_execute_named() {",
          "944:         let db = Connection::open_in_memory().unwrap();",
          "945:         db.execute_batch(\"CREATE TABLE foo(x INTEGER)\").unwrap();",
          "948:             db.execute_named(\"INSERT INTO foo(x) VALUES (:x)\", &[(\":x\", &1i32)])",
          "949:                 .unwrap(),",
          "953:             db.execute(\"INSERT INTO foo(x) VALUES (:x)\", &[(\":x\", &2i32)])",
          "954:                 .unwrap(),",
          "961:             )",
          "962:             .unwrap(),",
          "",
          "[Added Lines]",
          "943:     fn test_execute_named() -> Result<()> {",
          "944:         let db = Connection::open_in_memory()?;",
          "945:         db.execute_batch(\"CREATE TABLE foo(x INTEGER)\")?;",
          "948:             db.execute_named(\"INSERT INTO foo(x) VALUES (:x)\", &[(\":x\", &1i32)])?,",
          "952:             db.execute(\"INSERT INTO foo(x) VALUES (:x)\", &[(\":x\", &2i32)])?,",
          "959:             )?,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "969:                 \"SELECT SUM(x) FROM foo WHERE x > :x\",",
          "970:                 &[(\":x\", &0i32)],",
          "971:                 |r| r.get(0)",
          "974:         );",
          "975:         assert_eq!(",
          "976:             5i32,",
          "",
          "[Removed Lines]",
          "972:             )",
          "973:             .unwrap()",
          "",
          "[Added Lines]",
          "969:             )?",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "978:                 \"SELECT SUM(x) FROM foo WHERE x > :x\",",
          "979:                 &[(\":x\", &1i32)],",
          "980:                 |r| r.get(0)",
          "983:         );",
          "984:     }",
          "986:     #[test]",
          "987:     #[allow(deprecated)]",
          "990:         let sql = \"CREATE TABLE test (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, flag \\",
          "991:                    INTEGER)\";",
          "1002:         assert_eq!(",
          "1003:             1i32,",
          "1006:         );",
          "1007:         assert_eq!(",
          "1008:             1i32,",
          "1011:         );",
          "1012:     }",
          "1014:     #[test]",
          "1015:     #[allow(deprecated)]",
          "1018:         let sql = r#\"",
          "1019:         CREATE TABLE test (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, flag INTEGER);",
          "1020:         INSERT INTO test(id, name) VALUES (1, \"one\");",
          "1021:         \"#;",
          "1028:         {",
          "1031:             assert_eq!(Ok(1), id);",
          "1032:         }",
          "1035:         {",
          "1038:             assert_eq!(Ok(1), id);",
          "1039:         }",
          "1040:     }",
          "1042:     #[test]",
          "1043:     #[allow(deprecated)]",
          "1046:         let sql = r#\"",
          "1047:         CREATE TABLE test (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, flag INTEGER);",
          "1048:         INSERT INTO test(id, name) VALUES (1, \"one\");",
          "1049:         \"#;",
          "1056:         {",
          "1065:             assert_eq!(2, doubled_id);",
          "1066:         }",
          "1068:         {",
          "1077:             assert_eq!(2, doubled_id);",
          "1078:         }",
          "1079:     }",
          "1081:     #[test]",
          "1082:     #[allow(deprecated)]",
          "1085:         let sql = r#\"",
          "1086:         CREATE TABLE test (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, flag INTEGER);",
          "1087:         INSERT INTO test(id, name) VALUES (1, \"one\");",
          "1088:         INSERT INTO test(id, name) VALUES (2, \"one\");",
          "1089:         \"#;",
          "1108:         assert_eq!(1, doubled_id);",
          "",
          "[Removed Lines]",
          "981:             )",
          "982:             .unwrap()",
          "988:     fn test_stmt_execute_named() {",
          "989:         let db = Connection::open_in_memory().unwrap();",
          "992:         db.execute_batch(sql).unwrap();",
          "994:         let mut stmt = db",
          "995:             .prepare(\"INSERT INTO test (name) VALUES (:name)\")",
          "996:             .unwrap();",
          "997:         stmt.execute_named(&[(\":name\", &\"one\")]).unwrap();",
          "999:         let mut stmt = db",
          "1000:             .prepare(\"SELECT COUNT(*) FROM test WHERE name = :name\")",
          "1001:             .unwrap();",
          "1004:             stmt.query_row_named::<i32, _>(&[(\":name\", &\"one\")], |r| r.get(0))",
          "1005:                 .unwrap()",
          "1009:             stmt.query_row::<i32, _, _>(&[(\":name\", &\"one\")], |r| r.get(0))",
          "1010:                 .unwrap()",
          "1016:     fn test_query_named() {",
          "1017:         let db = Connection::open_in_memory().unwrap();",
          "1022:         db.execute_batch(sql).unwrap();",
          "1024:         let mut stmt = db",
          "1025:             .prepare(\"SELECT id FROM test where name = :name\")",
          "1026:             .unwrap();",
          "1029:             let mut rows = stmt.query_named(&[(\":name\", &\"one\")]).unwrap();",
          "1030:             let id: Result<i32> = rows.next().unwrap().unwrap().get(0);",
          "1036:             let mut rows = stmt.query(&[(\":name\", &\"one\")]).unwrap();",
          "1037:             let id: Result<i32> = rows.next().unwrap().unwrap().get(0);",
          "1044:     fn test_query_map_named() {",
          "1045:         let db = Connection::open_in_memory().unwrap();",
          "1050:         db.execute_batch(sql).unwrap();",
          "1052:         let mut stmt = db",
          "1053:             .prepare(\"SELECT id FROM test where name = :name\")",
          "1054:             .unwrap();",
          "1057:             let mut rows = stmt",
          "1058:                 .query_map_named(&[(\":name\", &\"one\")], |row| {",
          "1059:                     let id: Result<i32> = row.get(0);",
          "1060:                     id.map(|i| 2 * i)",
          "1061:                 })",
          "1062:                 .unwrap();",
          "1064:             let doubled_id: i32 = rows.next().unwrap().unwrap();",
          "1069:             let mut rows = stmt",
          "1070:                 .query_map(&[(\":name\", &\"one\")], |row| {",
          "1071:                     let id: Result<i32> = row.get(0);",
          "1072:                     id.map(|i| 2 * i)",
          "1073:                 })",
          "1074:                 .unwrap();",
          "1076:             let doubled_id: i32 = rows.next().unwrap().unwrap();",
          "1083:     fn test_query_and_then_named() {",
          "1084:         let db = Connection::open_in_memory().unwrap();",
          "1090:         db.execute_batch(sql).unwrap();",
          "1092:         let mut stmt = db",
          "1093:             .prepare(\"SELECT id FROM test where name = :name ORDER BY id ASC\")",
          "1094:             .unwrap();",
          "1095:         let mut rows = stmt",
          "1096:             .query_and_then_named(&[(\":name\", &\"one\")], |row| {",
          "1097:                 let id: i32 = row.get(0)?;",
          "1098:                 if id == 1 {",
          "1099:                     Ok(id)",
          "1100:                 } else {",
          "1101:                     Err(Error::SqliteSingleThreadedMode)",
          "1102:                 }",
          "1103:             })",
          "1104:             .unwrap();",
          "1107:         let doubled_id: i32 = rows.next().unwrap().unwrap();",
          "",
          "[Added Lines]",
          "977:             )?",
          "979:         Ok(())",
          "984:     fn test_stmt_execute_named() -> Result<()> {",
          "985:         let db = Connection::open_in_memory()?;",
          "988:         db.execute_batch(sql)?;",
          "990:         let mut stmt = db.prepare(\"INSERT INTO test (name) VALUES (:name)\")?;",
          "991:         stmt.execute_named(&[(\":name\", &\"one\")])?;",
          "993:         let mut stmt = db.prepare(\"SELECT COUNT(*) FROM test WHERE name = :name\")?;",
          "996:             stmt.query_row_named::<i32, _>(&[(\":name\", &\"one\")], |r| r.get(0))?",
          "1000:             stmt.query_row::<i32, _, _>(&[(\":name\", &\"one\")], |r| r.get(0))?",
          "1002:         Ok(())",
          "1007:     fn test_query_named() -> Result<()> {",
          "1008:         let db = Connection::open_in_memory()?;",
          "1013:         db.execute_batch(sql)?;",
          "1015:         let mut stmt = db.prepare(\"SELECT id FROM test where name = :name\")?;",
          "1018:             let mut rows = stmt.query_named(&[(\":name\", &\"one\")])?;",
          "1019:             let id: Result<i32> = rows.next()?.unwrap().get(0);",
          "1025:             let mut rows = stmt.query(&[(\":name\", &\"one\")])?;",
          "1026:             let id: Result<i32> = rows.next()?.unwrap().get(0);",
          "1029:         Ok(())",
          "1034:     fn test_query_map_named() -> Result<()> {",
          "1035:         let db = Connection::open_in_memory()?;",
          "1040:         db.execute_batch(sql)?;",
          "1042:         let mut stmt = db.prepare(\"SELECT id FROM test where name = :name\")?;",
          "1045:             let mut rows = stmt.query_map_named(&[(\":name\", &\"one\")], |row| {",
          "1046:                 let id: Result<i32> = row.get(0);",
          "1047:                 id.map(|i| 2 * i)",
          "1048:             })?;",
          "1050:             let doubled_id: i32 = rows.next().unwrap()?;",
          "1055:             let mut rows = stmt.query_map(&[(\":name\", &\"one\")], |row| {",
          "1056:                 let id: Result<i32> = row.get(0);",
          "1057:                 id.map(|i| 2 * i)",
          "1058:             })?;",
          "1060:             let doubled_id: i32 = rows.next().unwrap()?;",
          "1063:         Ok(())",
          "1068:     fn test_query_and_then_named() -> Result<()> {",
          "1069:         let db = Connection::open_in_memory()?;",
          "1075:         db.execute_batch(sql)?;",
          "1077:         let mut stmt = db.prepare(\"SELECT id FROM test where name = :name ORDER BY id ASC\")?;",
          "1078:         let mut rows = stmt.query_and_then_named(&[(\":name\", &\"one\")], |row| {",
          "1079:             let id: i32 = row.get(0)?;",
          "1080:             if id == 1 {",
          "1081:                 Ok(id)",
          "1082:             } else {",
          "1083:                 Err(Error::SqliteSingleThreadedMode)",
          "1084:             }",
          "1085:         })?;",
          "1088:         let doubled_id: i32 = rows.next().unwrap()?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1114:             Err(Error::SqliteSingleThreadedMode) => (),",
          "1115:             Err(_) => panic!(\"invalid Err\"),",
          "1116:         }",
          "1117:     }",
          "1119:     #[test]",
          "1122:         let sql = r#\"",
          "1123:         CREATE TABLE test (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, flag INTEGER);",
          "1124:         INSERT INTO test(id, name) VALUES (1, \"one\");",
          "1125:         INSERT INTO test(id, name) VALUES (2, \"one\");",
          "1126:         \"#;",
          "1145:         assert_eq!(1, doubled_id);",
          "",
          "[Removed Lines]",
          "1120:     fn test_query_and_then_by_name() {",
          "1121:         let db = Connection::open_in_memory().unwrap();",
          "1127:         db.execute_batch(sql).unwrap();",
          "1129:         let mut stmt = db",
          "1130:             .prepare(\"SELECT id FROM test where name = :name ORDER BY id ASC\")",
          "1131:             .unwrap();",
          "1132:         let mut rows = stmt",
          "1133:             .query_and_then(&[(\":name\", &\"one\")], |row| {",
          "1134:                 let id: i32 = row.get(0)?;",
          "1135:                 if id == 1 {",
          "1136:                     Ok(id)",
          "1137:                 } else {",
          "1138:                     Err(Error::SqliteSingleThreadedMode)",
          "1139:                 }",
          "1140:             })",
          "1141:             .unwrap();",
          "1144:         let doubled_id: i32 = rows.next().unwrap().unwrap();",
          "",
          "[Added Lines]",
          "1098:         Ok(())",
          "1102:     fn test_query_and_then_by_name() -> Result<()> {",
          "1103:         let db = Connection::open_in_memory()?;",
          "1109:         db.execute_batch(sql)?;",
          "1111:         let mut stmt = db.prepare(\"SELECT id FROM test where name = :name ORDER BY id ASC\")?;",
          "1112:         let mut rows = stmt.query_and_then(&[(\":name\", &\"one\")], |row| {",
          "1113:             let id: i32 = row.get(0)?;",
          "1114:             if id == 1 {",
          "1115:                 Ok(id)",
          "1116:             } else {",
          "1117:                 Err(Error::SqliteSingleThreadedMode)",
          "1118:             }",
          "1119:         })?;",
          "1122:         let doubled_id: i32 = rows.next().unwrap()?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1151:             Err(Error::SqliteSingleThreadedMode) => (),",
          "1152:             Err(_) => panic!(\"invalid Err\"),",
          "1153:         }",
          "1154:     }",
          "1156:     #[test]",
          "1157:     #[allow(deprecated)]",
          "1160:         let sql = \"CREATE TABLE test (x TEXT, y TEXT)\";",
          "1171:         assert!(result.is_none());",
          "1172:     }",
          "1174:     #[test]",
          "1175:     fn test_raw_binding() -> Result<()> {",
          "1177:         db.execute_batch(\"CREATE TABLE test (name TEXT, value INTEGER)\")?;",
          "1178:         {",
          "1179:             let mut stmt = db.prepare(\"INSERT INTO test (name, value) VALUES (:name, ?3)\")?;",
          "",
          "[Removed Lines]",
          "1158:     fn test_unbound_parameters_are_null() {",
          "1159:         let db = Connection::open_in_memory().unwrap();",
          "1161:         db.execute_batch(sql).unwrap();",
          "1163:         let mut stmt = db",
          "1164:             .prepare(\"INSERT INTO test (x, y) VALUES (:x, :y)\")",
          "1165:             .unwrap();",
          "1166:         stmt.execute_named(&[(\":x\", &\"one\")]).unwrap();",
          "1168:         let result: Option<String> = db",
          "1169:             .query_row(\"SELECT y FROM test WHERE x = 'one'\", [], |row| row.get(0))",
          "1170:             .unwrap();",
          "1176:         let db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "1132:         Ok(())",
          "1137:     fn test_unbound_parameters_are_null() -> Result<()> {",
          "1138:         let db = Connection::open_in_memory()?;",
          "1140:         db.execute_batch(sql)?;",
          "1142:         let mut stmt = db.prepare(\"INSERT INTO test (x, y) VALUES (:x, :y)\")?;",
          "1143:         stmt.execute_named(&[(\":x\", &\"one\")])?;",
          "1145:         let result: Option<String> =",
          "1146:             db.query_row(\"SELECT y FROM test WHERE x = 'one'\", [], |row| row.get(0))?;",
          "1148:         Ok(())",
          "1153:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1203:     }",
          "1205:     #[test]",
          "1208:         let sql = \"CREATE TABLE test (x TEXT, y TEXT)\";",
          "1220:         assert_eq!(result, \"one\");",
          "1221:     }",
          "1223:     #[test]",
          "1233:         match stmt.insert(&[&1i32]).unwrap_err() {",
          "1234:             Error::StatementChangedRows(0) => (),",
          "1235:             err => panic!(\"Unexpected error {}\", err),",
          "1236:         }",
          "1240:         match multi.insert([]).unwrap_err() {",
          "1241:             Error::StatementChangedRows(2) => (),",
          "1242:             err => panic!(\"Unexpected error {}\", err),",
          "1243:         }",
          "1244:     }",
          "1246:     #[test]",
          "1250:         db.execute_batch(",
          "1251:             r\"",
          "1252:             CREATE TABLE foo(x INTEGER);",
          "1253:             CREATE TABLE bar(x INTEGER);",
          "1254:         \",",
          "1272:     }",
          "1274:     #[test]",
          "1277:         let sql = \"BEGIN;",
          "1278:                    CREATE TABLE foo(x INTEGER);",
          "1279:                    INSERT INTO foo VALUES(1);",
          "1280:                    INSERT INTO foo VALUES(2);",
          "1281:                    END;\";",
          "1287:     }",
          "1289:     #[test]",
          "1292:         let sql = \"BEGIN;",
          "1293:                    CREATE TABLE foo(x INTEGER, y INTEGER);",
          "1294:                    INSERT INTO foo VALUES(1, 3);",
          "1295:                    INSERT INTO foo VALUES(2, 4);",
          "1296:                    END;\";",
          "1299:         let y: Result<i64> = stmt.query_row([1i32], |r| r.get(0));",
          "1301:     }",
          "1303:     #[test]",
          "1306:         let sql = \"BEGIN;",
          "1307:                    CREATE TABLE foo(x INTEGER, y INTEGER);",
          "1308:                    INSERT INTO foo VALUES(1, 3);",
          "1309:                    END;\";",
          "1312:         let y: Result<i64> = stmt.query_row([], |r| r.get(\"y\"));",
          "1314:     }",
          "1316:     #[test]",
          "1319:         let sql = \"BEGIN;",
          "1320:                    CREATE TABLE foo(x INTEGER, y INTEGER);",
          "1321:                    INSERT INTO foo VALUES(1, 3);",
          "1322:                    END;\";",
          "1325:         let y: Result<i64> = stmt.query_row([], |r| r.get(\"y\"));",
          "1327:     }",
          "1329:     #[test]",
          "1330:     #[cfg(feature = \"modern_sqlite\")]",
          "1335:         assert_eq!(Some(\"SELECT 1\".to_owned()), stmt.expanded_sql());",
          "1336:     }",
          "1338:     #[test]",
          "1342:         db.query_row(",
          "1343:             \"SELECT ?1, ?2, ?3\",",
          "1344:             &[&1u8 as &dyn ToSql, &\"one\", &Some(\"one\")],",
          "1345:             |row| row.get::<_, u8>(0),",
          "1349:         let data = vec![1, 2, 3];",
          "1350:         db.query_row(\"SELECT ?1, ?2, ?3\", params_from_iter(&data), |row| {",
          "1351:             row.get::<_, u8>(0)",
          "1354:         db.query_row(",
          "1355:             \"SELECT ?1, ?2, ?3\",",
          "1356:             params_from_iter(data.as_slice()),",
          "1357:             |row| row.get::<_, u8>(0),",
          "1360:         db.query_row(\"SELECT ?1, ?2, ?3\", params_from_iter(data), |row| {",
          "1361:             row.get::<_, u8>(0)",
          "1365:         use std::collections::BTreeSet;",
          "1366:         let data: BTreeSet<String> = [\"one\", \"two\", \"three\"]",
          "",
          "[Removed Lines]",
          "1206:     fn test_unbound_parameters_are_reused() {",
          "1207:         let db = Connection::open_in_memory().unwrap();",
          "1209:         db.execute_batch(sql).unwrap();",
          "1211:         let mut stmt = db",
          "1212:             .prepare(\"INSERT INTO test (x, y) VALUES (:x, :y)\")",
          "1213:             .unwrap();",
          "1214:         stmt.execute(&[(\":x\", &\"one\")]).unwrap();",
          "1215:         stmt.execute(&[(\":y\", &\"two\")]).unwrap();",
          "1217:         let result: String = db",
          "1218:             .query_row(\"SELECT x FROM test WHERE y = 'two'\", [], |row| row.get(0))",
          "1219:             .unwrap();",
          "1224:     fn test_insert() {",
          "1225:         let db = Connection::open_in_memory().unwrap();",
          "1226:         db.execute_batch(\"CREATE TABLE foo(x INTEGER UNIQUE)\")",
          "1227:             .unwrap();",
          "1228:         let mut stmt = db",
          "1229:             .prepare(\"INSERT OR IGNORE INTO foo (x) VALUES (?)\")",
          "1230:             .unwrap();",
          "1231:         assert_eq!(stmt.insert(&[&1i32]).unwrap(), 1);",
          "1232:         assert_eq!(stmt.insert(&[&2i32]).unwrap(), 2);",
          "1237:         let mut multi = db",
          "1238:             .prepare(\"INSERT INTO foo (x) SELECT 3 UNION ALL SELECT 4\")",
          "1239:             .unwrap();",
          "1247:     fn test_insert_different_tables() {",
          "1249:         let db = Connection::open_in_memory().unwrap();",
          "1255:         )",
          "1256:         .unwrap();",
          "1258:         assert_eq!(",
          "1259:             db.prepare(\"INSERT INTO foo VALUES (10)\")",
          "1260:                 .unwrap()",
          "1261:                 .insert([])",
          "1262:                 .unwrap(),",
          "1263:             1",
          "1264:         );",
          "1265:         assert_eq!(",
          "1266:             db.prepare(\"INSERT INTO bar VALUES (10)\")",
          "1267:                 .unwrap()",
          "1268:                 .insert([])",
          "1269:                 .unwrap(),",
          "1270:             1",
          "1271:         );",
          "1275:     fn test_exists() {",
          "1276:         let db = Connection::open_in_memory().unwrap();",
          "1282:         db.execute_batch(sql).unwrap();",
          "1283:         let mut stmt = db.prepare(\"SELECT 1 FROM foo WHERE x = ?\").unwrap();",
          "1284:         assert!(stmt.exists([1i32]).unwrap());",
          "1285:         assert!(stmt.exists(&[&2i32]).unwrap());",
          "1286:         assert!(!stmt.exists([&0i32]).unwrap());",
          "1290:     fn test_query_row() {",
          "1291:         let db = Connection::open_in_memory().unwrap();",
          "1297:         db.execute_batch(sql).unwrap();",
          "1298:         let mut stmt = db.prepare(\"SELECT y FROM foo WHERE x = ?\").unwrap();",
          "1300:         assert_eq!(3i64, y.unwrap());",
          "1304:     fn test_query_by_column_name() {",
          "1305:         let db = Connection::open_in_memory().unwrap();",
          "1310:         db.execute_batch(sql).unwrap();",
          "1311:         let mut stmt = db.prepare(\"SELECT y FROM foo\").unwrap();",
          "1313:         assert_eq!(3i64, y.unwrap());",
          "1317:     fn test_query_by_column_name_ignore_case() {",
          "1318:         let db = Connection::open_in_memory().unwrap();",
          "1323:         db.execute_batch(sql).unwrap();",
          "1324:         let mut stmt = db.prepare(\"SELECT y as Y FROM foo\").unwrap();",
          "1326:         assert_eq!(3i64, y.unwrap());",
          "1331:     fn test_expanded_sql() {",
          "1332:         let db = Connection::open_in_memory().unwrap();",
          "1333:         let stmt = db.prepare(\"SELECT ?\").unwrap();",
          "1334:         stmt.bind_parameter(&1, 1).unwrap();",
          "1339:     fn test_bind_parameters() {",
          "1340:         let db = Connection::open_in_memory().unwrap();",
          "1346:         )",
          "1347:         .unwrap();",
          "1352:         })",
          "1353:         .unwrap();",
          "1358:         )",
          "1359:         .unwrap();",
          "1362:         })",
          "1363:         .unwrap();",
          "",
          "[Added Lines]",
          "1183:     fn test_unbound_parameters_are_reused() -> Result<()> {",
          "1184:         let db = Connection::open_in_memory()?;",
          "1186:         db.execute_batch(sql)?;",
          "1188:         let mut stmt = db.prepare(\"INSERT INTO test (x, y) VALUES (:x, :y)\")?;",
          "1189:         stmt.execute(&[(\":x\", &\"one\")])?;",
          "1190:         stmt.execute(&[(\":y\", &\"two\")])?;",
          "1192:         let result: String =",
          "1193:             db.query_row(\"SELECT x FROM test WHERE y = 'two'\", [], |row| row.get(0))?;",
          "1195:         Ok(())",
          "1199:     fn test_insert() -> Result<()> {",
          "1200:         let db = Connection::open_in_memory()?;",
          "1201:         db.execute_batch(\"CREATE TABLE foo(x INTEGER UNIQUE)\")?;",
          "1202:         let mut stmt = db.prepare(\"INSERT OR IGNORE INTO foo (x) VALUES (?)\")?;",
          "1203:         assert_eq!(stmt.insert(&[&1i32])?, 1);",
          "1204:         assert_eq!(stmt.insert(&[&2i32])?, 2);",
          "1209:         let mut multi = db.prepare(\"INSERT INTO foo (x) SELECT 3 UNION ALL SELECT 4\")?;",
          "1214:         Ok(())",
          "1218:     fn test_insert_different_tables() -> Result<()> {",
          "1220:         let db = Connection::open_in_memory()?;",
          "1226:         )?;",
          "1228:         assert_eq!(db.prepare(\"INSERT INTO foo VALUES (10)\")?.insert([])?, 1);",
          "1229:         assert_eq!(db.prepare(\"INSERT INTO bar VALUES (10)\")?.insert([])?, 1);",
          "1230:         Ok(())",
          "1234:     fn test_exists() -> Result<()> {",
          "1235:         let db = Connection::open_in_memory()?;",
          "1241:         db.execute_batch(sql)?;",
          "1242:         let mut stmt = db.prepare(\"SELECT 1 FROM foo WHERE x = ?\")?;",
          "1243:         assert!(stmt.exists([1i32])?);",
          "1244:         assert!(stmt.exists(&[&2i32])?);",
          "1245:         assert!(!stmt.exists([&0i32])?);",
          "1246:         Ok(())",
          "1250:     fn test_query_row() -> Result<()> {",
          "1251:         let db = Connection::open_in_memory()?;",
          "1257:         db.execute_batch(sql)?;",
          "1258:         let mut stmt = db.prepare(\"SELECT y FROM foo WHERE x = ?\")?;",
          "1260:         assert_eq!(3i64, y?);",
          "1261:         Ok(())",
          "1265:     fn test_query_by_column_name() -> Result<()> {",
          "1266:         let db = Connection::open_in_memory()?;",
          "1271:         db.execute_batch(sql)?;",
          "1272:         let mut stmt = db.prepare(\"SELECT y FROM foo\")?;",
          "1274:         assert_eq!(3i64, y?);",
          "1275:         Ok(())",
          "1279:     fn test_query_by_column_name_ignore_case() -> Result<()> {",
          "1280:         let db = Connection::open_in_memory()?;",
          "1285:         db.execute_batch(sql)?;",
          "1286:         let mut stmt = db.prepare(\"SELECT y as Y FROM foo\")?;",
          "1288:         assert_eq!(3i64, y?);",
          "1289:         Ok(())",
          "1294:     fn test_expanded_sql() -> Result<()> {",
          "1295:         let db = Connection::open_in_memory()?;",
          "1296:         let stmt = db.prepare(\"SELECT ?\")?;",
          "1297:         stmt.bind_parameter(&1, 1)?;",
          "1299:         Ok(())",
          "1303:     fn test_bind_parameters() -> Result<()> {",
          "1304:         let db = Connection::open_in_memory()?;",
          "1310:         )?;",
          "1315:         })?;",
          "1320:         )?;",
          "1323:         })?;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1369:             .collect();",
          "1370:         db.query_row(\"SELECT ?1, ?2, ?3\", params_from_iter(&data), |row| {",
          "1371:             row.get::<_, String>(0)",
          "1375:         let data = [0; 3];",
          "1376:         db.query_row(\"SELECT ?1, ?2, ?3\", params_from_iter(&data), |row| {",
          "1377:             row.get::<_, u8>(0)",
          "1380:         db.query_row(\"SELECT ?1, ?2, ?3\", params_from_iter(data.iter()), |row| {",
          "1381:             row.get::<_, u8>(0)",
          "1384:     }",
          "1386:     #[test]",
          "1390:         assert_eq!(0, stmt.column_count());",
          "1391:         assert!(stmt.parameter_index(\"test\").is_ok());",
          "1392:         assert!(stmt.step().is_err());",
          "1393:         stmt.reset();",
          "1394:         assert!(stmt.execute([]).is_err());",
          "1395:     }",
          "1397:     #[test]",
          "1401:     }",
          "1403:     #[test]",
          "1407:         assert_eq!(1, stmt.column_count());",
          "1408:     }",
          "1410:     #[test]",
          "1414:         assert_eq!(0, stmt.column_count());",
          "1415:     }",
          "1417:     #[test]",
          "1424:         assert_eq!(\"UTF-16le\", encoding);",
          "1426:         let expected = \"\u30c6\u30b9\u30c8\";",
          "1432:         assert_eq!(expected, actual);",
          "1433:     }",
          "1435:     #[test]",
          "1438:         let expected = \"a\\x00b\";",
          "1442:         assert_eq!(expected, actual);",
          "1443:     }",
          "1444: }",
          "",
          "[Removed Lines]",
          "1372:         })",
          "1373:         .unwrap();",
          "1378:         })",
          "1379:         .unwrap();",
          "1382:         })",
          "1383:         .unwrap();",
          "1387:     fn test_empty_stmt() {",
          "1388:         let conn = Connection::open_in_memory().unwrap();",
          "1389:         let mut stmt = conn.prepare(\"\").unwrap();",
          "1398:     fn test_comment_stmt() {",
          "1399:         let conn = Connection::open_in_memory().unwrap();",
          "1400:         conn.prepare(\"/*SELECT 1;*/\").unwrap();",
          "1404:     fn test_comment_and_sql_stmt() {",
          "1405:         let conn = Connection::open_in_memory().unwrap();",
          "1406:         let stmt = conn.prepare(\"/*...*/ SELECT 1;\").unwrap();",
          "1411:     fn test_semi_colon_stmt() {",
          "1412:         let conn = Connection::open_in_memory().unwrap();",
          "1413:         let stmt = conn.prepare(\";\").unwrap();",
          "1418:     fn test_utf16_conversion() {",
          "1419:         let db = Connection::open_in_memory().unwrap();",
          "1420:         db.pragma_update(None, \"encoding\", &\"UTF-16le\").unwrap();",
          "1421:         let encoding: String = db",
          "1422:             .pragma_query_value(None, \"encoding\", |row| row.get(0))",
          "1423:             .unwrap();",
          "1425:         db.execute_batch(\"CREATE TABLE foo(x TEXT)\").unwrap();",
          "1427:         db.execute(\"INSERT INTO foo(x) VALUES (?)\", &[&expected])",
          "1428:             .unwrap();",
          "1429:         let actual: String = db",
          "1430:             .query_row(\"SELECT x FROM foo\", [], |row| row.get(0))",
          "1431:             .unwrap();",
          "1436:     fn test_nul_byte() {",
          "1437:         let db = Connection::open_in_memory().unwrap();",
          "1439:         let actual: String = db",
          "1440:             .query_row(\"SELECT ?\", [expected], |row| row.get(0))",
          "1441:             .unwrap();",
          "",
          "[Added Lines]",
          "1332:         })?;",
          "1337:         })?;",
          "1340:         })?;",
          "1341:         Ok(())",
          "1345:     fn test_empty_stmt() -> Result<()> {",
          "1346:         let conn = Connection::open_in_memory()?;",
          "1347:         let mut stmt = conn.prepare(\"\")?;",
          "1353:         Ok(())",
          "1357:     fn test_comment_stmt() -> Result<()> {",
          "1358:         let conn = Connection::open_in_memory()?;",
          "1359:         conn.prepare(\"/*SELECT 1;*/\")?;",
          "1360:         Ok(())",
          "1364:     fn test_comment_and_sql_stmt() -> Result<()> {",
          "1365:         let conn = Connection::open_in_memory()?;",
          "1366:         let stmt = conn.prepare(\"/*...*/ SELECT 1;\")?;",
          "1368:         Ok(())",
          "1372:     fn test_semi_colon_stmt() -> Result<()> {",
          "1373:         let conn = Connection::open_in_memory()?;",
          "1374:         let stmt = conn.prepare(\";\")?;",
          "1376:         Ok(())",
          "1380:     fn test_utf16_conversion() -> Result<()> {",
          "1381:         let db = Connection::open_in_memory()?;",
          "1382:         db.pragma_update(None, \"encoding\", &\"UTF-16le\")?;",
          "1383:         let encoding: String = db.pragma_query_value(None, \"encoding\", |row| row.get(0))?;",
          "1385:         db.execute_batch(\"CREATE TABLE foo(x TEXT)\")?;",
          "1387:         db.execute(\"INSERT INTO foo(x) VALUES (?)\", &[&expected])?;",
          "1388:         let actual: String = db.query_row(\"SELECT x FROM foo\", [], |row| row.get(0))?;",
          "1390:         Ok(())",
          "1394:     fn test_nul_byte() -> Result<()> {",
          "1395:         let db = Connection::open_in_memory()?;",
          "1397:         let actual: String = db.query_row(\"SELECT ?\", [expected], |row| row.get(0))?;",
          "1399:         Ok(())",
          "",
          "---------------"
        ],
        "src/trace.rs||src/trace.rs": [
          "File: src/trace.rs -> src/trace.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:     use std::sync::Mutex;",
          "129:     use std::time::Duration;",
          "133:     #[test]",
          "135:         lazy_static! {",
          "136:             static ref TRACED_STMTS: Mutex<Vec<String>> = Mutex::new(Vec::new());",
          "137:         }",
          "",
          "[Removed Lines]",
          "131:     use crate::Connection;",
          "134:     fn test_trace() {",
          "",
          "[Added Lines]",
          "131:     use crate::{Connection, Result};",
          "134:     fn test_trace() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:             traced_stmts.push(s.to_owned());",
          "141:         }",
          "144:         db.trace(Some(tracer));",
          "145:         {",
          "146:             let _ = db.query_row(\"SELECT ?\", &[&1i32], |_| Ok(()));",
          "",
          "[Removed Lines]",
          "143:         let mut db = Connection::open_in_memory().unwrap();",
          "",
          "[Added Lines]",
          "143:         let mut db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156:         assert_eq!(traced_stmts.len(), 2);",
          "157:         assert_eq!(traced_stmts[0], \"SELECT 1\");",
          "158:         assert_eq!(traced_stmts[1], \"SELECT 'hello'\");",
          "159:     }",
          "161:     #[test]",
          "163:         lazy_static! {",
          "164:             static ref PROFILED: Mutex<Vec<(String, Duration)>> = Mutex::new(Vec::new());",
          "165:         }",
          "",
          "[Removed Lines]",
          "162:     fn test_profile() {",
          "",
          "[Added Lines]",
          "159:         Ok(())",
          "163:     fn test_profile() -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:             profiled.push((s.to_owned(), d));",
          "169:         }",
          "172:         db.profile(Some(profiler));",
          "174:         db.profile(None);",
          "177:         let profiled = PROFILED.lock().unwrap();",
          "178:         assert_eq!(profiled.len(), 1);",
          "179:         assert_eq!(profiled[0].0, \"PRAGMA application_id = 1\");",
          "180:     }",
          "181: }",
          "",
          "[Removed Lines]",
          "171:         let mut db = Connection::open_in_memory().unwrap();",
          "173:         db.execute_batch(\"PRAGMA application_id = 1\").unwrap();",
          "175:         db.execute_batch(\"PRAGMA application_id = 2\").unwrap();",
          "",
          "[Added Lines]",
          "172:         let mut db = Connection::open_in_memory()?;",
          "174:         db.execute_batch(\"PRAGMA application_id = 1\")?;",
          "176:         db.execute_batch(\"PRAGMA application_id = 2\")?;",
          "181:         Ok(())",
          "",
          "---------------"
        ],
        "src/transaction.rs||src/transaction.rs": [
          "File: src/transaction.rs -> src/transaction.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "500: #[cfg(test)]",
          "501: mod test {",
          "502:     use super::DropBehavior;",
          "509:     }",
          "511:     #[test]",
          "514:         {",
          "518:         }",
          "519:         {",
          "522:             tx.set_drop_behavior(DropBehavior::Commit)",
          "523:         }",
          "524:         {",
          "526:             assert_eq!(",
          "527:                 2i32,",
          "530:             );",
          "531:         }",
          "532:     }",
          "533:     fn assert_nested_tx_error(e: crate::Error) {",
          "534:         if let Error::SqliteFailure(e, Some(m)) = &e {",
          "",
          "[Removed Lines]",
          "503:     use crate::{Connection, Error};",
          "505:     fn checked_memory_handle() -> Connection {",
          "506:         let db = Connection::open_in_memory().unwrap();",
          "507:         db.execute_batch(\"CREATE TABLE foo (x INTEGER)\").unwrap();",
          "508:         db",
          "512:     fn test_drop() {",
          "513:         let mut db = checked_memory_handle();",
          "515:             let tx = db.transaction().unwrap();",
          "516:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\").unwrap();",
          "520:             let mut tx = db.transaction().unwrap();",
          "521:             tx.execute_batch(\"INSERT INTO foo VALUES(2)\").unwrap();",
          "525:             let tx = db.transaction().unwrap();",
          "528:                 tx.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "529:                     .unwrap()",
          "",
          "[Added Lines]",
          "503:     use crate::{Connection, Error, Result};",
          "505:     fn checked_memory_handle() -> Result<Connection> {",
          "506:         let db = Connection::open_in_memory()?;",
          "507:         db.execute_batch(\"CREATE TABLE foo (x INTEGER)\")?;",
          "508:         Ok(db)",
          "512:     fn test_drop() -> Result<()> {",
          "513:         let mut db = checked_memory_handle()?;",
          "515:             let tx = db.transaction()?;",
          "516:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\")?;",
          "520:             let mut tx = db.transaction()?;",
          "521:             tx.execute_batch(\"INSERT INTO foo VALUES(2)\")?;",
          "525:             let tx = db.transaction()?;",
          "528:                 tx.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?",
          "531:         Ok(())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "542:     }",
          "544:     #[test]",
          "548:         {",
          "550:             let e = tx.unchecked_transaction().unwrap_err();",
          "551:             assert_nested_tx_error(e);",
          "553:         }",
          "554:         {",
          "558:             let e = tx.unchecked_transaction().unwrap_err();",
          "559:             assert_nested_tx_error(e);",
          "563:         }",
          "565:         assert_eq!(",
          "566:             2i32,",
          "569:         );",
          "570:     }",
          "572:     #[test]",
          "575:         {",
          "577:             {",
          "583:             }",
          "585:         }",
          "586:         {",
          "590:         }",
          "591:         {",
          "593:             assert_eq!(",
          "594:                 6i32,",
          "597:             );",
          "598:         }",
          "599:     }",
          "601:     #[test]",
          "604:         {",
          "608:             tx.set_drop_behavior(DropBehavior::Commit);",
          "609:             {",
          "614:                 {",
          "619:                     {",
          "625:                     }",
          "627:                 }",
          "629:             }",
          "631:         }",
          "633:     }",
          "635:     #[test]",
          "640:         {",
          "645:             {",
          "647:                 sp2.set_drop_behavior(DropBehavior::Ignore);",
          "649:             }",
          "652:         }",
          "654:     }",
          "656:     #[test]",
          "660:         {",
          "664:             {",
          "666:                 sp2.set_drop_behavior(DropBehavior::Commit);",
          "672:             }",
          "675:             {",
          "677:                 sp2.set_drop_behavior(DropBehavior::Ignore);",
          "679:             }",
          "682:         }",
          "684:     }",
          "686:     #[test]",
          "688:         use std::rc::Rc;",
          "693:         Rc::try_unwrap(rc_txn).unwrap();",
          "694:     }",
          "698:     }",
          "704:         assert_eq!(x, i);",
          "705:     }",
          "706: }",
          "",
          "[Removed Lines]",
          "545:     fn test_unchecked_nesting() {",
          "546:         let db = checked_memory_handle();",
          "549:             let tx = db.unchecked_transaction().unwrap();",
          "555:             let tx = db.unchecked_transaction().unwrap();",
          "556:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\").unwrap();",
          "561:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\").unwrap();",
          "562:             tx.commit().unwrap();",
          "567:             db.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "568:                 .unwrap()",
          "573:     fn test_explicit_rollback_commit() {",
          "574:         let mut db = checked_memory_handle();",
          "576:             let mut tx = db.transaction().unwrap();",
          "578:                 let mut sp = tx.savepoint().unwrap();",
          "579:                 sp.execute_batch(\"INSERT INTO foo VALUES(1)\").unwrap();",
          "580:                 sp.rollback().unwrap();",
          "581:                 sp.execute_batch(\"INSERT INTO foo VALUES(2)\").unwrap();",
          "582:                 sp.commit().unwrap();",
          "584:             tx.commit().unwrap();",
          "587:             let tx = db.transaction().unwrap();",
          "588:             tx.execute_batch(\"INSERT INTO foo VALUES(4)\").unwrap();",
          "589:             tx.commit().unwrap();",
          "592:             let tx = db.transaction().unwrap();",
          "595:                 tx.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "596:                     .unwrap()",
          "602:     fn test_savepoint() {",
          "603:         let mut db = checked_memory_handle();",
          "605:             let mut tx = db.transaction().unwrap();",
          "606:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\").unwrap();",
          "607:             assert_current_sum(1, &tx);",
          "610:                 let mut sp1 = tx.savepoint().unwrap();",
          "611:                 sp1.execute_batch(\"INSERT INTO foo VALUES(2)\").unwrap();",
          "612:                 assert_current_sum(3, &sp1);",
          "615:                     let mut sp2 = sp1.savepoint().unwrap();",
          "616:                     sp2.execute_batch(\"INSERT INTO foo VALUES(4)\").unwrap();",
          "617:                     assert_current_sum(7, &sp2);",
          "620:                         let sp3 = sp2.savepoint().unwrap();",
          "621:                         sp3.execute_batch(\"INSERT INTO foo VALUES(8)\").unwrap();",
          "622:                         assert_current_sum(15, &sp3);",
          "623:                         sp3.commit().unwrap();",
          "626:                     assert_current_sum(15, &sp2);",
          "628:                 assert_current_sum(3, &sp1);",
          "630:             assert_current_sum(1, &tx);",
          "632:         assert_current_sum(1, &db);",
          "636:     fn test_ignore_drop_behavior() {",
          "637:         let mut db = checked_memory_handle();",
          "639:         let mut tx = db.transaction().unwrap();",
          "641:             let mut sp1 = tx.savepoint().unwrap();",
          "642:             insert(1, &sp1);",
          "643:             sp1.rollback().unwrap();",
          "644:             insert(2, &sp1);",
          "646:                 let mut sp2 = sp1.savepoint().unwrap();",
          "648:                 insert(4, &sp2);",
          "650:             assert_current_sum(6, &sp1);",
          "651:             sp1.commit().unwrap();",
          "653:         assert_current_sum(6, &tx);",
          "657:     fn test_savepoint_names() {",
          "658:         let mut db = checked_memory_handle();",
          "661:             let mut sp1 = db.savepoint_with_name(\"my_sp\").unwrap();",
          "662:             insert(1, &sp1);",
          "663:             assert_current_sum(1, &sp1);",
          "665:                 let mut sp2 = sp1.savepoint_with_name(\"my_sp\").unwrap();",
          "667:                 insert(2, &sp2);",
          "668:                 assert_current_sum(3, &sp2);",
          "669:                 sp2.rollback().unwrap();",
          "670:                 assert_current_sum(1, &sp2);",
          "671:                 insert(4, &sp2);",
          "673:             assert_current_sum(5, &sp1);",
          "674:             sp1.rollback().unwrap();",
          "676:                 let mut sp2 = sp1.savepoint_with_name(\"my_sp\").unwrap();",
          "678:                 insert(8, &sp2);",
          "680:             assert_current_sum(8, &sp1);",
          "681:             sp1.commit().unwrap();",
          "683:         assert_current_sum(8, &db);",
          "687:     fn test_rc() {",
          "689:         let mut conn = Connection::open_in_memory().unwrap();",
          "690:         let rc_txn = Rc::new(conn.transaction().unwrap());",
          "696:     fn insert(x: i32, conn: &Connection) {",
          "697:         conn.execute(\"INSERT INTO foo VALUES(?)\", [x]).unwrap();",
          "700:     fn assert_current_sum(x: i32, conn: &Connection) {",
          "701:         let i = conn",
          "702:             .query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))",
          "703:             .unwrap();",
          "",
          "[Added Lines]",
          "545:     fn test_unchecked_nesting() -> Result<()> {",
          "546:         let db = checked_memory_handle()?;",
          "549:             let tx = db.unchecked_transaction()?;",
          "555:             let tx = db.unchecked_transaction()?;",
          "556:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\")?;",
          "561:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\")?;",
          "562:             tx.commit()?;",
          "567:             db.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?",
          "569:         Ok(())",
          "573:     fn test_explicit_rollback_commit() -> Result<()> {",
          "574:         let mut db = checked_memory_handle()?;",
          "576:             let mut tx = db.transaction()?;",
          "578:                 let mut sp = tx.savepoint()?;",
          "579:                 sp.execute_batch(\"INSERT INTO foo VALUES(1)\")?;",
          "580:                 sp.rollback()?;",
          "581:                 sp.execute_batch(\"INSERT INTO foo VALUES(2)\")?;",
          "582:                 sp.commit()?;",
          "584:             tx.commit()?;",
          "587:             let tx = db.transaction()?;",
          "588:             tx.execute_batch(\"INSERT INTO foo VALUES(4)\")?;",
          "589:             tx.commit()?;",
          "592:             let tx = db.transaction()?;",
          "595:                 tx.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?",
          "598:         Ok(())",
          "602:     fn test_savepoint() -> Result<()> {",
          "603:         let mut db = checked_memory_handle()?;",
          "605:             let mut tx = db.transaction()?;",
          "606:             tx.execute_batch(\"INSERT INTO foo VALUES(1)\")?;",
          "607:             assert_current_sum(1, &tx)?;",
          "610:                 let mut sp1 = tx.savepoint()?;",
          "611:                 sp1.execute_batch(\"INSERT INTO foo VALUES(2)\")?;",
          "612:                 assert_current_sum(3, &sp1)?;",
          "615:                     let mut sp2 = sp1.savepoint()?;",
          "616:                     sp2.execute_batch(\"INSERT INTO foo VALUES(4)\")?;",
          "617:                     assert_current_sum(7, &sp2)?;",
          "620:                         let sp3 = sp2.savepoint()?;",
          "621:                         sp3.execute_batch(\"INSERT INTO foo VALUES(8)\")?;",
          "622:                         assert_current_sum(15, &sp3)?;",
          "623:                         sp3.commit()?;",
          "626:                     assert_current_sum(15, &sp2)?;",
          "628:                 assert_current_sum(3, &sp1)?;",
          "630:             assert_current_sum(1, &tx)?;",
          "632:         assert_current_sum(1, &db)?;",
          "633:         Ok(())",
          "637:     fn test_ignore_drop_behavior() -> Result<()> {",
          "638:         let mut db = checked_memory_handle()?;",
          "640:         let mut tx = db.transaction()?;",
          "642:             let mut sp1 = tx.savepoint()?;",
          "643:             insert(1, &sp1)?;",
          "644:             sp1.rollback()?;",
          "645:             insert(2, &sp1)?;",
          "647:                 let mut sp2 = sp1.savepoint()?;",
          "649:                 insert(4, &sp2)?;",
          "651:             assert_current_sum(6, &sp1)?;",
          "652:             sp1.commit()?;",
          "654:         assert_current_sum(6, &tx)?;",
          "655:         Ok(())",
          "659:     fn test_savepoint_names() -> Result<()> {",
          "660:         let mut db = checked_memory_handle()?;",
          "663:             let mut sp1 = db.savepoint_with_name(\"my_sp\")?;",
          "664:             insert(1, &sp1)?;",
          "665:             assert_current_sum(1, &sp1)?;",
          "667:                 let mut sp2 = sp1.savepoint_with_name(\"my_sp\")?;",
          "669:                 insert(2, &sp2)?;",
          "670:                 assert_current_sum(3, &sp2)?;",
          "671:                 sp2.rollback()?;",
          "672:                 assert_current_sum(1, &sp2)?;",
          "673:                 insert(4, &sp2)?;",
          "675:             assert_current_sum(5, &sp1)?;",
          "676:             sp1.rollback()?;",
          "678:                 let mut sp2 = sp1.savepoint_with_name(\"my_sp\")?;",
          "680:                 insert(8, &sp2)?;",
          "682:             assert_current_sum(8, &sp1)?;",
          "683:             sp1.commit()?;",
          "685:         assert_current_sum(8, &db)?;",
          "686:         Ok(())",
          "690:     fn test_rc() -> Result<()> {",
          "692:         let mut conn = Connection::open_in_memory()?;",
          "693:         let rc_txn = Rc::new(conn.transaction()?);",
          "697:         Ok(())",
          "700:     fn insert(x: i32, conn: &Connection) -> Result<usize> {",
          "701:         conn.execute(\"INSERT INTO foo VALUES(?)\", [x])",
          "704:     fn assert_current_sum(x: i32, conn: &Connection) -> Result<()> {",
          "705:         let i = conn.query_row::<i32, _, _>(\"SELECT SUM(x) FROM foo\", [], |r| r.get(0))?;",
          "707:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/chrono.rs||src/types/chrono.rs": [
          "File: src/types/chrono.rs -> src/types/chrono.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "137:     use crate::{Connection, Result};",
          "138:     use chrono::{DateTime, Duration, Local, NaiveDate, NaiveDateTime, NaiveTime, TimeZone, Utc};",
          "145:     }",
          "147:     #[test]",
          "150:         let date = NaiveDate::from_ymd(2016, 2, 23);",
          "155:         assert_eq!(\"2016-02-23\", s);",
          "157:         assert_eq!(date, t);",
          "158:     }",
          "160:     #[test]",
          "163:         let time = NaiveTime::from_hms(23, 56, 4);",
          "168:         assert_eq!(\"23:56:04\", s);",
          "170:         assert_eq!(time, v);",
          "171:     }",
          "173:     #[test]",
          "176:         let date = NaiveDate::from_ymd(2016, 2, 23);",
          "177:         let time = NaiveTime::from_hms(23, 56, 4);",
          "178:         let dt = NaiveDateTime::new(date, time);",
          "184:         assert_eq!(\"2016-02-23T23:56:04\", s);",
          "186:         assert_eq!(dt, v);",
          "190:         assert_eq!(dt, hms);",
          "191:     }",
          "193:     #[test]",
          "196:         let date = NaiveDate::from_ymd(2016, 2, 23);",
          "197:         let time = NaiveTime::from_hms_milli(23, 56, 4, 789);",
          "198:         let dt = NaiveDateTime::new(date, time);",
          "199:         let utc = Utc.from_utc_datetime(&dt);",
          "205:         assert_eq!(\"2016-02-23T23:56:04.789+00:00\", s);",
          "208:         assert_eq!(utc, v1);",
          "213:         assert_eq!(utc, v2);",
          "218:         assert_eq!(utc - Duration::milliseconds(789), v3);",
          "223:         assert_eq!(utc, v4);",
          "224:     }",
          "226:     #[test]",
          "229:         let date = NaiveDate::from_ymd(2016, 2, 23);",
          "230:         let time = NaiveTime::from_hms_milli(23, 56, 4, 789);",
          "231:         let dt = NaiveDateTime::new(date, time);",
          "232:         let local = Local.from_local_datetime(&dt).single().unwrap();",
          "239:         assert!(s.ends_with(\"+00:00\"));",
          "242:         assert_eq!(local, v);",
          "243:     }",
          "245:     #[test]",
          "248:         let result: Result<NaiveTime> = db.query_row(\"SELECT CURRENT_TIME\", [], |r| r.get(0));",
          "249:         assert!(result.is_ok());",
          "250:         let result: Result<NaiveDate> = db.query_row(\"SELECT CURRENT_DATE\", [], |r| r.get(0));",
          "",
          "[Removed Lines]",
          "140:     fn checked_memory_handle() -> Connection {",
          "141:         let db = Connection::open_in_memory().unwrap();",
          "142:         db.execute_batch(\"CREATE TABLE foo (t TEXT, i INTEGER, f FLOAT, b BLOB)\")",
          "143:             .unwrap();",
          "144:         db",
          "148:     fn test_naive_date() {",
          "149:         let db = checked_memory_handle();",
          "151:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&date])",
          "152:             .unwrap();",
          "154:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "156:         let t: NaiveDate = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "161:     fn test_naive_time() {",
          "162:         let db = checked_memory_handle();",
          "164:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&time])",
          "165:             .unwrap();",
          "167:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "169:         let v: NaiveTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "174:     fn test_naive_date_time() {",
          "175:         let db = checked_memory_handle();",
          "180:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&dt])",
          "181:             .unwrap();",
          "183:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "185:         let v: NaiveDateTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "188:         db.execute(\"UPDATE foo set b = datetime(t)\", []).unwrap(); // \"YYYY-MM-DD HH:MM:SS\"",
          "189:         let hms: NaiveDateTime = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0)).unwrap();",
          "194:     fn test_date_time_utc() {",
          "195:         let db = checked_memory_handle();",
          "201:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&utc])",
          "202:             .unwrap();",
          "204:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "207:         let v1: DateTime<Utc> = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "210:         let v2: DateTime<Utc> = db",
          "211:             .query_row(\"SELECT '2016-02-23 23:56:04.789'\", [], |r| r.get(0))",
          "212:             .unwrap();",
          "215:         let v3: DateTime<Utc> = db",
          "216:             .query_row(\"SELECT '2016-02-23 23:56:04'\", [], |r| r.get(0))",
          "217:             .unwrap();",
          "220:         let v4: DateTime<Utc> = db",
          "221:             .query_row(\"SELECT '2016-02-23 23:56:04.789+00:00'\", [], |r| r.get(0))",
          "222:             .unwrap();",
          "227:     fn test_date_time_local() {",
          "228:         let db = checked_memory_handle();",
          "234:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&local])",
          "235:             .unwrap();",
          "238:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "241:         let v: DateTime<Local> = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "246:     fn test_sqlite_functions() {",
          "247:         let db = checked_memory_handle();",
          "",
          "[Added Lines]",
          "140:     fn checked_memory_handle() -> Result<Connection> {",
          "141:         let db = Connection::open_in_memory()?;",
          "142:         db.execute_batch(\"CREATE TABLE foo (t TEXT, i INTEGER, f FLOAT, b BLOB)\")?;",
          "143:         Ok(db)",
          "147:     fn test_naive_date() -> Result<()> {",
          "148:         let db = checked_memory_handle()?;",
          "150:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&date])?;",
          "152:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "154:         let t: NaiveDate = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "156:         Ok(())",
          "160:     fn test_naive_time() -> Result<()> {",
          "161:         let db = checked_memory_handle()?;",
          "163:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&time])?;",
          "165:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "167:         let v: NaiveTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "169:         Ok(())",
          "173:     fn test_naive_date_time() -> Result<()> {",
          "174:         let db = checked_memory_handle()?;",
          "179:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&dt])?;",
          "181:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "183:         let v: NaiveDateTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "186:         db.execute(\"UPDATE foo set b = datetime(t)\", [])?; // \"YYYY-MM-DD HH:MM:SS\"",
          "187:         let hms: NaiveDateTime = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0))?;",
          "189:         Ok(())",
          "193:     fn test_date_time_utc() -> Result<()> {",
          "194:         let db = checked_memory_handle()?;",
          "200:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&utc])?;",
          "202:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "205:         let v1: DateTime<Utc> = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "208:         let v2: DateTime<Utc> =",
          "209:             db.query_row(\"SELECT '2016-02-23 23:56:04.789'\", [], |r| r.get(0))?;",
          "212:         let v3: DateTime<Utc> = db.query_row(\"SELECT '2016-02-23 23:56:04'\", [], |r| r.get(0))?;",
          "215:         let v4: DateTime<Utc> =",
          "216:             db.query_row(\"SELECT '2016-02-23 23:56:04.789+00:00'\", [], |r| r.get(0))?;",
          "218:         Ok(())",
          "222:     fn test_date_time_local() -> Result<()> {",
          "223:         let db = checked_memory_handle()?;",
          "229:         db.execute(\"INSERT INTO foo (t) VALUES (?)\", &[&local])?;",
          "232:         let s: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "235:         let v: DateTime<Local> = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "237:         Ok(())",
          "241:     fn test_sqlite_functions() -> Result<()> {",
          "242:         let db = checked_memory_handle()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255:         let result: Result<DateTime<Utc>> =",
          "256:             db.query_row(\"SELECT CURRENT_TIMESTAMP\", [], |r| r.get(0));",
          "257:         assert!(result.is_ok());",
          "258:     }",
          "259: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "253:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/from_sql.rs||src/types/from_sql.rs": [
          "File: src/types/from_sql.rs -> src/types/from_sql.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "235: #[cfg(test)]",
          "236: mod test {",
          "237:     use super::FromSql;",
          "244:     #[test]",
          "248:         fn check_ranges<T>(db: &Connection, out_of_range: &[i64], in_range: &[i64])",
          "249:         where",
          "",
          "[Removed Lines]",
          "238:     use crate::{Connection, Error};",
          "240:     fn checked_memory_handle() -> Connection {",
          "241:         Connection::open_in_memory().unwrap()",
          "242:     }",
          "245:     fn test_integral_ranges() {",
          "246:         let db = checked_memory_handle();",
          "",
          "[Added Lines]",
          "238:     use crate::{Connection, Error, Result};",
          "241:     fn test_integral_ranges() -> Result<()> {",
          "242:         let db = Connection::open_in_memory()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "278:         check_ranges::<u8>(&db, &[-2, -1, 256], &[0, 1, 255]);",
          "279:         check_ranges::<u16>(&db, &[-2, -1, 65536], &[0, 1, 65535]);",
          "280:         check_ranges::<u32>(&db, &[-2, -1, 4_294_967_296], &[0, 1, 4_294_967_295]);",
          "281:     }",
          "282: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/mod.rs||src/types/mod.rs": [
          "File: src/types/mod.rs -> src/types/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: #[cfg(test)]",
          "132: mod test {",
          "133:     use super::Value;",
          "135:     use std::f64::EPSILON;",
          "136:     use std::os::raw::{c_double, c_int};",
          "143:     }",
          "145:     #[test]",
          "149:         let v1234 = vec![1u8, 2, 3, 4];",
          "154:         assert_eq!(v, v1234);",
          "155:     }",
          "157:     #[test]",
          "161:         let empty = vec![];",
          "166:         assert_eq!(v, empty);",
          "167:     }",
          "169:     #[test]",
          "173:         let s = \"hello, world!\";",
          "177:         assert_eq!(from, s);",
          "178:     }",
          "180:     #[test]",
          "184:         let s = \"hello, world!\";",
          "189:         assert_eq!(from, s);",
          "190:     }",
          "192:     #[test]",
          "199:         assert_eq!(",
          "200:             10i64,",
          "203:         );",
          "204:     }",
          "206:     #[test]",
          "210:         let s = Some(\"hello, world!\");",
          "211:         let b = Some(vec![1u8, 2, 3, 4]);",
          "221:         {",
          "223:             let s1: Option<String> = row1.get_unwrap(0);",
          "224:             let b1: Option<Vec<u8>> = row1.get_unwrap(1);",
          "225:             assert_eq!(s.unwrap(), s1.unwrap());",
          "",
          "[Removed Lines]",
          "134:     use crate::{params, Connection, Error, Statement};",
          "138:     fn checked_memory_handle() -> Connection {",
          "139:         let db = Connection::open_in_memory().unwrap();",
          "140:         db.execute_batch(\"CREATE TABLE foo (b BLOB, t TEXT, i INTEGER, f FLOAT, n)\")",
          "141:             .unwrap();",
          "142:         db",
          "146:     fn test_blob() {",
          "147:         let db = checked_memory_handle();",
          "150:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&v1234])",
          "151:             .unwrap();",
          "153:         let v: Vec<u8> = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0)).unwrap();",
          "158:     fn test_empty_blob() {",
          "159:         let db = checked_memory_handle();",
          "162:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&empty])",
          "163:             .unwrap();",
          "165:         let v: Vec<u8> = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0)).unwrap();",
          "170:     fn test_str() {",
          "171:         let db = checked_memory_handle();",
          "174:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&s]).unwrap();",
          "176:         let from: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "181:     fn test_string() {",
          "182:         let db = checked_memory_handle();",
          "185:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", [s.to_owned()])",
          "186:             .unwrap();",
          "188:         let from: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "193:     fn test_value() {",
          "194:         let db = checked_memory_handle();",
          "196:         db.execute(\"INSERT INTO foo(i) VALUES (?)\", [Value::Integer(10)])",
          "197:             .unwrap();",
          "201:             db.query_row::<i64, _, _>(\"SELECT i FROM foo\", [], |r| r.get(0))",
          "202:                 .unwrap()",
          "207:     fn test_option() {",
          "208:         let db = checked_memory_handle();",
          "213:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&s]).unwrap();",
          "214:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&b]).unwrap();",
          "216:         let mut stmt = db",
          "217:             .prepare(\"SELECT t, b FROM foo ORDER BY ROWID ASC\")",
          "218:             .unwrap();",
          "219:         let mut rows = stmt.query([]).unwrap();",
          "222:             let row1 = rows.next().unwrap().unwrap();",
          "",
          "[Added Lines]",
          "134:     use crate::{params, Connection, Error, Result, Statement};",
          "138:     fn checked_memory_handle() -> Result<Connection> {",
          "139:         let db = Connection::open_in_memory()?;",
          "140:         db.execute_batch(\"CREATE TABLE foo (b BLOB, t TEXT, i INTEGER, f FLOAT, n)\")?;",
          "141:         Ok(db)",
          "145:     fn test_blob() -> Result<()> {",
          "146:         let db = checked_memory_handle()?;",
          "149:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&v1234])?;",
          "151:         let v: Vec<u8> = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0))?;",
          "153:         Ok(())",
          "157:     fn test_empty_blob() -> Result<()> {",
          "158:         let db = checked_memory_handle()?;",
          "161:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&empty])?;",
          "163:         let v: Vec<u8> = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0))?;",
          "165:         Ok(())",
          "169:     fn test_str() -> Result<()> {",
          "170:         let db = checked_memory_handle()?;",
          "173:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&s])?;",
          "175:         let from: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "177:         Ok(())",
          "181:     fn test_string() -> Result<()> {",
          "182:         let db = checked_memory_handle()?;",
          "185:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", [s.to_owned()])?;",
          "187:         let from: String = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "189:         Ok(())",
          "193:     fn test_value() -> Result<()> {",
          "194:         let db = checked_memory_handle()?;",
          "196:         db.execute(\"INSERT INTO foo(i) VALUES (?)\", [Value::Integer(10)])?;",
          "200:             db.query_row::<i64, _, _>(\"SELECT i FROM foo\", [], |r| r.get(0))?",
          "202:         Ok(())",
          "206:     fn test_option() -> Result<()> {",
          "207:         let db = checked_memory_handle()?;",
          "212:         db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&s])?;",
          "213:         db.execute(\"INSERT INTO foo(b) VALUES (?)\", &[&b])?;",
          "215:         let mut stmt = db.prepare(\"SELECT t, b FROM foo ORDER BY ROWID ASC\")?;",
          "216:         let mut rows = stmt.query([])?;",
          "219:             let row1 = rows.next()?.unwrap();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "227:         }",
          "229:         {",
          "231:             let s2: Option<String> = row2.get_unwrap(0);",
          "232:             let b2: Option<Vec<u8>> = row2.get_unwrap(1);",
          "233:             assert!(s2.is_none());",
          "234:             assert_eq!(b, b2);",
          "235:         }",
          "236:     }",
          "238:     #[test]",
          "239:     #[allow(clippy::cognitive_complexity)]",
          "241:         fn is_invalid_column_type(err: Error) -> bool {",
          "242:             matches!(err, Error::InvalidColumnType(..))",
          "243:         }",
          "247:         db.execute(",
          "248:             \"INSERT INTO foo(b, t, i, f) VALUES (X'0102', 'text', 1, 1.5)\",",
          "249:             [],",
          "",
          "[Removed Lines]",
          "230:             let row2 = rows.next().unwrap().unwrap();",
          "240:     fn test_mismatched_types() {",
          "245:         let db = checked_memory_handle();",
          "250:         )",
          "251:         .unwrap();",
          "253:         let mut stmt = db.prepare(\"SELECT b, t, i, f, n FROM foo\").unwrap();",
          "254:         let mut rows = stmt.query([]).unwrap();",
          "256:         let row = rows.next().unwrap().unwrap();",
          "259:         assert_eq!(vec![1, 2], row.get::<_, Vec<u8>>(0).unwrap());",
          "260:         assert_eq!(\"text\", row.get::<_, String>(1).unwrap());",
          "261:         assert_eq!(1, row.get::<_, c_int>(2).unwrap());",
          "262:         assert!((1.5 - row.get::<_, c_double>(3).unwrap()).abs() < EPSILON);",
          "263:         assert_eq!(row.get::<_, Option<c_int>>(4).unwrap(), None);",
          "264:         assert_eq!(row.get::<_, Option<c_double>>(4).unwrap(), None);",
          "265:         assert_eq!(row.get::<_, Option<String>>(4).unwrap(), None);",
          "",
          "[Added Lines]",
          "227:             let row2 = rows.next()?.unwrap();",
          "233:         Ok(())",
          "238:     fn test_mismatched_types() -> Result<()> {",
          "243:         let db = checked_memory_handle()?;",
          "248:         )?;",
          "250:         let mut stmt = db.prepare(\"SELECT b, t, i, f, n FROM foo\")?;",
          "251:         let mut rows = stmt.query([])?;",
          "253:         let row = rows.next()?.unwrap();",
          "256:         assert_eq!(vec![1, 2], row.get::<_, Vec<u8>>(0)?);",
          "257:         assert_eq!(\"text\", row.get::<_, String>(1)?);",
          "258:         assert_eq!(1, row.get::<_, c_int>(2)?);",
          "259:         assert!((1.5 - row.get::<_, c_double>(3)?).abs() < EPSILON);",
          "260:         assert_eq!(row.get::<_, Option<c_int>>(4)?, None);",
          "261:         assert_eq!(row.get::<_, Option<c_double>>(4)?, None);",
          "262:         assert_eq!(row.get::<_, Option<String>>(4)?, None);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "347:         assert!(is_invalid_column_type(",
          "348:             row.get::<_, time::OffsetDateTime>(4).err().unwrap()",
          "349:         ));",
          "350:     }",
          "352:     #[test]",
          "354:         use super::Value;",
          "357:         db.execute(",
          "358:             \"INSERT INTO foo(b, t, i, f) VALUES (X'0102', 'text', 1, 1.5)\",",
          "359:             [],",
          "374:             Value::Real(val) => assert!((1.5 - val).abs() < EPSILON),",
          "375:             x => panic!(\"Invalid Value {:?}\", x),",
          "376:         }",
          "378:     }",
          "380:     macro_rules! test_conversion {",
          "381:         ($db_etc:ident, $insert_value:expr, $get_type:ty,expect $expected_value:expr) => {",
          "386:             let res = $db_etc",
          "387:                 .query_statement",
          "388:                 .query_row([], |row| row.get::<_, $get_type>(0));",
          "391:         };",
          "392:         ($db_etc:ident, $insert_value:expr, $get_type:ty,expect_from_sql_error) => {",
          "397:             let res = $db_etc",
          "398:                 .query_statement",
          "399:                 .query_row([], |row| row.get::<_, $get_type>(0));",
          "400:             res.unwrap_err();",
          "402:         };",
          "403:         ($db_etc:ident, $insert_value:expr, $get_type:ty,expect_to_sql_error) => {",
          "404:             $db_etc",
          "",
          "[Removed Lines]",
          "353:     fn test_dynamic_type() {",
          "355:         let db = checked_memory_handle();",
          "360:         )",
          "361:         .unwrap();",
          "363:         let mut stmt = db.prepare(\"SELECT b, t, i, f, n FROM foo\").unwrap();",
          "364:         let mut rows = stmt.query([]).unwrap();",
          "366:         let row = rows.next().unwrap().unwrap();",
          "367:         assert_eq!(Value::Blob(vec![1, 2]), row.get::<_, Value>(0).unwrap());",
          "368:         assert_eq!(",
          "369:             Value::Text(String::from(\"text\")),",
          "370:             row.get::<_, Value>(1).unwrap()",
          "371:         );",
          "372:         assert_eq!(Value::Integer(1), row.get::<_, Value>(2).unwrap());",
          "373:         match row.get::<_, Value>(3).unwrap() {",
          "377:         assert_eq!(Value::Null, row.get::<_, Value>(4).unwrap());",
          "382:             $db_etc",
          "383:                 .insert_statement",
          "384:                 .execute(params![$insert_value])",
          "385:                 .unwrap();",
          "389:             assert_eq!(res.unwrap(), $expected_value);",
          "390:             $db_etc.delete_statement.execute([]).unwrap();",
          "393:             $db_etc",
          "394:                 .insert_statement",
          "395:                 .execute(params![$insert_value])",
          "396:                 .unwrap();",
          "401:             $db_etc.delete_statement.execute([]).unwrap();",
          "",
          "[Added Lines]",
          "347:         Ok(())",
          "351:     fn test_dynamic_type() -> Result<()> {",
          "353:         let db = checked_memory_handle()?;",
          "358:         )?;",
          "360:         let mut stmt = db.prepare(\"SELECT b, t, i, f, n FROM foo\")?;",
          "361:         let mut rows = stmt.query([])?;",
          "363:         let row = rows.next()?.unwrap();",
          "364:         assert_eq!(Value::Blob(vec![1, 2]), row.get::<_, Value>(0)?);",
          "365:         assert_eq!(Value::Text(String::from(\"text\")), row.get::<_, Value>(1)?);",
          "366:         assert_eq!(Value::Integer(1), row.get::<_, Value>(2)?);",
          "367:         match row.get::<_, Value>(3)? {",
          "371:         assert_eq!(Value::Null, row.get::<_, Value>(4)?);",
          "372:         Ok(())",
          "377:             $db_etc.insert_statement.execute(params![$insert_value])?;",
          "381:             assert_eq!(res?, $expected_value);",
          "382:             $db_etc.delete_statement.execute([])?;",
          "385:             $db_etc.insert_statement.execute(params![$insert_value])?;",
          "390:             $db_etc.delete_statement.execute([])?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "409:     }",
          "411:     #[test]",
          "413:         #![allow(clippy::float_cmp)]",
          "",
          "[Removed Lines]",
          "412:     fn test_numeric_conversions() {",
          "416:         let db = Connection::open_in_memory().unwrap();",
          "417:         db.execute_batch(\"CREATE TABLE foo (x)\").unwrap();",
          "",
          "[Added Lines]",
          "401:     fn test_numeric_conversions() -> Result<()> {",
          "405:         let db = Connection::open_in_memory()?;",
          "406:         db.execute_batch(\"CREATE TABLE foo (x)\")?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "426:         }",
          "428:         let mut db_etc = DbEtc {",
          "432:         };",
          "",
          "[Removed Lines]",
          "429:             insert_statement: db.prepare(\"INSERT INTO foo VALUES (?1)\").unwrap(),",
          "430:             query_statement: db.prepare(\"SELECT x FROM foo\").unwrap(),",
          "431:             delete_statement: db.prepare(\"DELETE FROM foo\").unwrap(),",
          "",
          "[Added Lines]",
          "418:             insert_statement: db.prepare(\"INSERT INTO foo VALUES (?1)\")?,",
          "419:             query_statement: db.prepare(\"SELECT x FROM foo\")?,",
          "420:             delete_statement: db.prepare(\"DELETE FROM foo\")?,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "468:         test_conversion!(db_etc, 0f64, i64, expect_from_sql_error);",
          "469:     }",
          "470: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "458:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/serde_json.rs||src/types/serde_json.rs": [
          "File: src/types/serde_json.rs -> src/types/serde_json.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #[cfg(test)]",
          "30: mod test {",
          "31:     use crate::types::ToSql;",
          "39:     }",
          "41:     #[test]",
          "45:         let json = r#\"{\"foo\": 13, \"bar\": \"baz\"}\"#;",
          "46:         let data: serde_json::Value = serde_json::from_str(json).unwrap();",
          "47:         db.execute(",
          "48:             \"INSERT INTO foo (t, b) VALUES (?, ?)\",",
          "49:             &[&data as &dyn ToSql, &json.as_bytes()],",
          "54:         assert_eq!(data, t);",
          "56:         assert_eq!(data, b);",
          "57:     }",
          "58: }",
          "",
          "[Removed Lines]",
          "32:     use crate::Connection;",
          "34:     fn checked_memory_handle() -> Connection {",
          "35:         let db = Connection::open_in_memory().unwrap();",
          "36:         db.execute_batch(\"CREATE TABLE foo (t TEXT, b BLOB)\")",
          "37:             .unwrap();",
          "38:         db",
          "42:     fn test_json_value() {",
          "43:         let db = checked_memory_handle();",
          "50:         )",
          "51:         .unwrap();",
          "53:         let t: serde_json::Value = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "55:         let b: serde_json::Value = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0)).unwrap();",
          "",
          "[Added Lines]",
          "32:     use crate::{Connection, Result};",
          "34:     fn checked_memory_handle() -> Result<Connection> {",
          "35:         let db = Connection::open_in_memory()?;",
          "36:         db.execute_batch(\"CREATE TABLE foo (t TEXT, b BLOB)\")?;",
          "37:         Ok(db)",
          "41:     fn test_json_value() -> Result<()> {",
          "42:         let db = checked_memory_handle()?;",
          "49:         )?;",
          "51:         let t: serde_json::Value = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "53:         let b: serde_json::Value = db.query_row(\"SELECT b FROM foo\", [], |r| r.get(0))?;",
          "55:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/time.rs||src/types/time.rs": [
          "File: src/types/time.rs -> src/types/time.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:     use std::time::Duration;",
          "38:     use time::OffsetDateTime;",
          "45:     }",
          "47:     #[test]",
          "51:         let mut ts_vec = vec![];",
          "",
          "[Removed Lines]",
          "40:     fn checked_memory_handle() -> Connection {",
          "41:         let db = Connection::open_in_memory().unwrap();",
          "42:         db.execute_batch(\"CREATE TABLE foo (t TEXT, i INTEGER, f FLOAT)\")",
          "43:             .unwrap();",
          "44:         db",
          "48:     fn test_offset_date_time() {",
          "49:         let db = checked_memory_handle();",
          "",
          "[Added Lines]",
          "40:     fn checked_memory_handle() -> Result<Connection> {",
          "41:         let db = Connection::open_in_memory()?;",
          "42:         db.execute_batch(\"CREATE TABLE foo (t TEXT, i INTEGER, f FLOAT)\")?;",
          "43:         Ok(db)",
          "47:     fn test_offset_date_time() -> Result<()> {",
          "48:         let db = checked_memory_handle()?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:         ts_vec.push(make_datetime(10_000_000_000, 0)); //November 20, 2286",
          "63:         for ts in ts_vec {",
          "70:             assert_eq!(from, ts);",
          "71:         }",
          "72:     }",
          "74:     #[test]",
          "77:         let result: Result<OffsetDateTime> =",
          "78:             db.query_row(\"SELECT CURRENT_TIMESTAMP\", [], |r| r.get(0));",
          "79:         assert!(result.is_ok());",
          "80:     }",
          "81: }",
          "",
          "[Removed Lines]",
          "64:             db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&ts]).unwrap();",
          "66:             let from: OffsetDateTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0)).unwrap();",
          "68:             db.execute(\"DELETE FROM foo\", []).unwrap();",
          "75:     fn test_sqlite_functions() {",
          "76:         let db = checked_memory_handle();",
          "",
          "[Added Lines]",
          "63:             db.execute(\"INSERT INTO foo(t) VALUES (?)\", &[&ts])?;",
          "65:             let from: OffsetDateTime = db.query_row(\"SELECT t FROM foo\", [], |r| r.get(0))?;",
          "67:             db.execute(\"DELETE FROM foo\", [])?;",
          "71:         Ok(())",
          "75:     fn test_sqlite_functions() -> Result<()> {",
          "76:         let db = checked_memory_handle()?;",
          "80:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/to_sql.rs||src/types/to_sql.rs": [
          "File: src/types/to_sql.rs -> src/types/to_sql.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "245: #[cfg(test)]",
          "246: mod test {",
          "247:     use super::ToSql;",
          "249:     fn is_to_sql<T: ToSql>() {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:     use crate::Result;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:     #[cfg(feature = \"i128_blob\")]",
          "341:     #[test]",
          "343:         use crate::Connection;",
          "344:         use std::i128;",
          "348:         db.execute(",
          "349:             \"",
          "350:             INSERT INTO foo(i128, desc) VALUES",
          "",
          "[Removed Lines]",
          "342:     fn test_i128() {",
          "345:         let db = Connection::open_in_memory().unwrap();",
          "346:         db.execute_batch(\"CREATE TABLE foo (i128 BLOB, desc TEXT)\")",
          "347:             .unwrap();",
          "",
          "[Added Lines]",
          "343:     fn test_i128() -> Result<()> {",
          "346:         let db = Connection::open_in_memory()?;",
          "347:         db.execute_batch(\"CREATE TABLE foo (i128 BLOB, desc TEXT)\")?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "353:                 (?, 'pos one'), (?, 'pos two'),",
          "354:                 (?, 'min'), (?, 'max')\",",
          "355:             [0i128, -1i128, -2i128, 1i128, 2i128, i128::MIN, i128::MAX],",
          "363:         let res = stmt",
          "364:             .query_map([], |row| {",
          "365:                 Ok((row.get::<_, i128>(0)?, row.get::<_, String>(1)?))",
          "371:         assert_eq!(",
          "372:             res,",
          "",
          "[Removed Lines]",
          "356:         )",
          "357:         .unwrap();",
          "359:         let mut stmt = db",
          "360:             .prepare(\"SELECT i128, desc FROM foo ORDER BY i128 ASC\")",
          "361:             .unwrap();",
          "366:             })",
          "367:             .unwrap()",
          "368:             .collect::<Result<Vec<_>, _>>()",
          "369:             .unwrap();",
          "",
          "[Added Lines]",
          "356:         )?;",
          "358:         let mut stmt = db.prepare(\"SELECT i128, desc FROM foo ORDER BY i128 ASC\")?;",
          "363:             })?",
          "364:             .collect::<Result<Vec<_>, _>>()?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "380:                 (i128::MAX, \"max\".to_owned()),",
          "381:             ]",
          "382:         );",
          "383:     }",
          "385:     #[cfg(feature = \"uuid\")]",
          "386:     #[test]",
          "388:         use crate::{params, Connection};",
          "389:         use uuid::Uuid;",
          "395:         let id = Uuid::new_v4();",
          "397:         db.execute(",
          "398:             \"INSERT INTO foo (id, label) VALUES (?, ?)\",",
          "399:             params![id, \"target\"],",
          "410:         let found_id: Uuid = row.get_unwrap(0);",
          "411:         let found_label: String = row.get_unwrap(1);",
          "413:         assert_eq!(found_id, id);",
          "414:         assert_eq!(found_label, \"target\");",
          "415:     }",
          "416: }",
          "",
          "[Removed Lines]",
          "387:     fn test_uuid() {",
          "391:         let db = Connection::open_in_memory().unwrap();",
          "392:         db.execute_batch(\"CREATE TABLE foo (id BLOB CHECK(length(id) = 16), label TEXT);\")",
          "393:             .unwrap();",
          "400:         )",
          "401:         .unwrap();",
          "403:         let mut stmt = db",
          "404:             .prepare(\"SELECT id, label FROM foo WHERE id = ?\")",
          "405:             .unwrap();",
          "407:         let mut rows = stmt.query(params![id]).unwrap();",
          "408:         let row = rows.next().unwrap().unwrap();",
          "",
          "[Added Lines]",
          "378:         Ok(())",
          "383:     fn test_uuid() -> Result<()> {",
          "387:         let db = Connection::open_in_memory()?;",
          "388:         db.execute_batch(\"CREATE TABLE foo (id BLOB CHECK(length(id) = 16), label TEXT);\")?;",
          "395:         )?;",
          "397:         let mut stmt = db.prepare(\"SELECT id, label FROM foo WHERE id = ?\")?;",
          "399:         let mut rows = stmt.query(params![id])?;",
          "400:         let row = rows.next()?.unwrap();",
          "407:         Ok(())",
          "",
          "---------------"
        ],
        "src/types/url.rs||src/types/url.rs": [
          "File: src/types/url.rs -> src/types/url.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     use crate::{params, Connection, Error, Result};",
          "31:     use url::{ParseError, Url};",
          "38:     }",
          "40:     fn get_url(db: &Connection, id: i64) -> Result<Url> {",
          "",
          "[Removed Lines]",
          "33:     fn checked_memory_handle() -> Connection {",
          "34:         let db = Connection::open_in_memory().unwrap();",
          "35:         db.execute_batch(\"CREATE TABLE urls (i INTEGER, v TEXT)\")",
          "36:             .unwrap();",
          "37:         db",
          "",
          "[Added Lines]",
          "33:     fn checked_memory_handle() -> Result<Connection> {",
          "34:         let db = Connection::open_in_memory()?;",
          "35:         db.execute_batch(\"CREATE TABLE urls (i INTEGER, v TEXT)\")?;",
          "36:         Ok(db)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:     }",
          "44:     #[test]",
          "48:         let url0 = Url::parse(\"http://www.example1.com\").unwrap();",
          "49:         let url1 = Url::parse(\"http://www.example1.com/\ud83d\udc4c\").unwrap();",
          "",
          "[Removed Lines]",
          "45:     fn test_sql_url() {",
          "46:         let db = &checked_memory_handle();",
          "",
          "[Added Lines]",
          "44:     fn test_sql_url() -> Result<()> {",
          "45:         let db = &checked_memory_handle()?;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56:             params![url0, url1, url2, \"illegal\"],",
          "67:         assert_eq!(out_url2, Url::parse(url2).unwrap());",
          "",
          "[Removed Lines]",
          "57:         )",
          "58:         .unwrap();",
          "60:         assert_eq!(get_url(db, 0).unwrap(), url0);",
          "62:         assert_eq!(get_url(db, 1).unwrap(), url1);",
          "66:         let out_url2: Url = get_url(db, 2).unwrap();",
          "",
          "[Added Lines]",
          "56:         )?;",
          "58:         assert_eq!(get_url(db, 0)?, url0);",
          "60:         assert_eq!(get_url(db, 1)?, url1);",
          "64:         let out_url2: Url = get_url(db, 2)?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "79:                 panic!(\"Expected conversion failure, got {}\", e);",
          "80:             }",
          "81:         }",
          "82:     }",
          "83: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:         Ok(())",
          "",
          "---------------"
        ],
        "src/unlock_notify.rs||src/unlock_notify.rs": [
          "File: src/unlock_notify.rs -> src/unlock_notify.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:     use std::time;",
          "108:     #[test]",
          "110:         let url = \"file::memory:?cache=shared\";",
          "111:         let flags = OpenFlags::SQLITE_OPEN_READ_WRITE | OpenFlags::SQLITE_OPEN_URI;",
          "114:         let (rx, tx) = sync_channel(0);",
          "115:         let child = thread::spawn(move || {",
          "116:             let mut db2 = Connection::open_with_flags(url, flags).unwrap();",
          "",
          "[Removed Lines]",
          "109:     fn test_unlock_notify() {",
          "112:         let db1 = Connection::open_with_flags(url, flags).unwrap();",
          "113:         db1.execute_batch(\"CREATE TABLE foo (x)\").unwrap();",
          "",
          "[Added Lines]",
          "109:     fn test_unlock_notify() -> Result<()> {",
          "112:         let db1 = Connection::open_with_flags(url, flags)?;",
          "113:         db1.execute_batch(\"CREATE TABLE foo (x)\")?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:         });",
          "124:         assert_eq!(tx.recv().unwrap(), 1);",
          "125:         let the_answer: Result<i64> = db1.query_row(\"SELECT x FROM foo\", [], |r| r.get(0));",
          "127:         child.join().unwrap();",
          "128:     }",
          "129: }",
          "",
          "[Removed Lines]",
          "126:         assert_eq!(42i64, the_answer.unwrap());",
          "",
          "[Added Lines]",
          "126:         assert_eq!(42i64, the_answer?);",
          "128:         Ok(())",
          "",
          "---------------"
        ],
        "src/vtab/array.rs||src/vtab/array.rs": [
          "File: src/vtab/array.rs -> src/vtab/array.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "197: mod test {",
          "198:     use crate::types::Value;",
          "199:     use crate::vtab::array;",
          "201:     use std::rc::Rc;",
          "203:     #[test]",
          "208:         let v = vec![1i64, 2, 3, 4];",
          "209:         let values: Vec<Value> = v.into_iter().map(Value::from).collect();",
          "210:         let ptr = Rc::new(values);",
          "211:         {",
          "215:             assert_eq!(2, Rc::strong_count(&ptr));",
          "216:             let mut count = 0;",
          "217:             for (i, value) in rows.enumerate() {",
          "219:                 count += 1;",
          "220:             }",
          "221:             assert_eq!(4, count);",
          "222:         }",
          "223:         assert_eq!(1, Rc::strong_count(&ptr));",
          "224:     }",
          "225: }",
          "",
          "[Removed Lines]",
          "200:     use crate::Connection;",
          "204:     fn test_array_module() {",
          "205:         let db = Connection::open_in_memory().unwrap();",
          "206:         array::load_module(&db).unwrap();",
          "212:             let mut stmt = db.prepare(\"SELECT value from rarray(?);\").unwrap();",
          "214:             let rows = stmt.query_map(&[&ptr], |row| row.get::<_, i64>(0)).unwrap();",
          "218:                 assert_eq!(i as i64, value.unwrap() - 1);",
          "",
          "[Added Lines]",
          "200:     use crate::{Connection, Result};",
          "204:     fn test_array_module() -> Result<()> {",
          "205:         let db = Connection::open_in_memory()?;",
          "206:         array::load_module(&db)?;",
          "212:             let mut stmt = db.prepare(\"SELECT value from rarray(?);\")?;",
          "214:             let rows = stmt.query_map(&[&ptr], |row| row.get::<_, i64>(0))?;",
          "218:                 assert_eq!(i as i64, value? - 1);",
          "224:         Ok(())",
          "",
          "---------------"
        ],
        "src/vtab/csvtab.rs||src/vtab/csvtab.rs": [
          "File: src/vtab/csvtab.rs -> src/vtab/csvtab.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "367:     use fallible_iterator::FallibleIterator;",
          "369:     #[test]",
          "376:         {",
          "378:             {",
          "379:                 let headers = s.column_names();",
          "380:                 assert_eq!(vec![\"rowid\", \"colA\", \"colB\", \"colC\"], headers);",
          "381:             }",
          "389:             assert_eq!(sum, 15);",
          "390:         }",
          "392:     }",
          "394:     #[test]",
          "401:         {",
          "405:                      v1.rowid < v2.rowid\",",
          "411:             assert_eq!(row.get_unwrap::<_, i32>(0), 2);",
          "412:         }",
          "414:     }",
          "415: }",
          "",
          "[Removed Lines]",
          "370:     fn test_csv_module() {",
          "371:         let db = Connection::open_in_memory().unwrap();",
          "372:         csvtab::load_module(&db).unwrap();",
          "373:         db.execute_batch(\"CREATE VIRTUAL TABLE vtab USING csv(filename='test.csv', header=yes)\")",
          "374:             .unwrap();",
          "377:             let mut s = db.prepare(\"SELECT rowid, * FROM vtab\").unwrap();",
          "383:             let ids: Result<Vec<i32>> = s",
          "384:                 .query([])",
          "385:                 .unwrap()",
          "386:                 .map(|row| row.get::<_, i32>(0))",
          "387:                 .collect();",
          "388:             let sum = ids.unwrap().iter().sum::<i32>();",
          "391:         db.execute_batch(\"DROP TABLE vtab\").unwrap();",
          "395:     fn test_csv_cursor() {",
          "396:         let db = Connection::open_in_memory().unwrap();",
          "397:         csvtab::load_module(&db).unwrap();",
          "398:         db.execute_batch(\"CREATE VIRTUAL TABLE vtab USING csv(filename='test.csv', header=yes)\")",
          "399:             .unwrap();",
          "402:             let mut s = db",
          "403:                 .prepare(",
          "404:                     \"SELECT v1.rowid, v1.* FROM vtab v1 NATURAL JOIN vtab v2 WHERE \\",
          "406:                 )",
          "407:                 .unwrap();",
          "409:             let mut rows = s.query([]).unwrap();",
          "410:             let row = rows.next().unwrap().unwrap();",
          "413:         db.execute_batch(\"DROP TABLE vtab\").unwrap();",
          "",
          "[Added Lines]",
          "370:     fn test_csv_module() -> Result<()> {",
          "371:         let db = Connection::open_in_memory()?;",
          "372:         csvtab::load_module(&db)?;",
          "373:         db.execute_batch(\"CREATE VIRTUAL TABLE vtab USING csv(filename='test.csv', header=yes)\")?;",
          "376:             let mut s = db.prepare(\"SELECT rowid, * FROM vtab\")?;",
          "382:             let ids: Result<Vec<i32>> = s.query([])?.map(|row| row.get::<_, i32>(0)).collect();",
          "383:             let sum = ids?.iter().sum::<i32>();",
          "386:         db.execute_batch(\"DROP TABLE vtab\")",
          "390:     fn test_csv_cursor() -> Result<()> {",
          "391:         let db = Connection::open_in_memory()?;",
          "392:         csvtab::load_module(&db)?;",
          "393:         db.execute_batch(\"CREATE VIRTUAL TABLE vtab USING csv(filename='test.csv', header=yes)\")?;",
          "396:             let mut s = db.prepare(",
          "397:                 \"SELECT v1.rowid, v1.* FROM vtab v1 NATURAL JOIN vtab v2 WHERE \\",
          "399:             )?;",
          "401:             let mut rows = s.query([])?;",
          "402:             let row = rows.next()?.unwrap();",
          "405:         db.execute_batch(\"DROP TABLE vtab\")",
          "",
          "---------------"
        ],
        "src/vtab/series.rs||src/vtab/series.rs": [
          "File: src/vtab/series.rs -> src/vtab/series.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "273: mod test {",
          "274:     use crate::ffi;",
          "275:     use crate::vtab::series;",
          "278:     #[test]",
          "280:         let version = unsafe { ffi::sqlite3_libversion_number() };",
          "281:         if version < 3_008_012 {",
          "283:         }",
          "292:         let mut expected = 0;",
          "293:         for value in series {",
          "295:             expected += 5;",
          "296:         }",
          "297:     }",
          "298: }",
          "",
          "[Removed Lines]",
          "276:     use crate::Connection;",
          "279:     fn test_series_module() {",
          "282:             return;",
          "285:         let db = Connection::open_in_memory().unwrap();",
          "286:         series::load_module(&db).unwrap();",
          "288:         let mut s = db.prepare(\"SELECT * FROM generate_series(0,20,5)\").unwrap();",
          "290:         let series = s.query_map([], |row| row.get::<_, i32>(0)).unwrap();",
          "294:             assert_eq!(expected, value.unwrap());",
          "",
          "[Added Lines]",
          "276:     use crate::{Connection, Result};",
          "279:     fn test_series_module() -> Result<()> {",
          "282:             return Ok(());",
          "285:         let db = Connection::open_in_memory()?;",
          "286:         series::load_module(&db)?;",
          "288:         let mut s = db.prepare(\"SELECT * FROM generate_series(0,20,5)\")?;",
          "290:         let series = s.query_map([], |row| row.get::<_, i32>(0))?;",
          "294:             assert_eq!(expected, value?);",
          "297:         Ok(())",
          "",
          "---------------"
        ],
        "tests/vtab.rs||tests/vtab.rs": [
          "File: tests/vtab.rs -> tests/vtab.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #[cfg(feature = \"vtab\")]",
          "4: #[test]",
          "6:     use rusqlite::types::ToSql;",
          "7:     use rusqlite::vtab::{",
          "8:         eponymous_only_module, sqlite3_vtab, sqlite3_vtab_cursor, Context, IndexInfo, VTab,",
          "",
          "[Removed Lines]",
          "5: fn test_dummy_module() {",
          "",
          "[Added Lines]",
          "5: fn test_dummy_module() -> rusqlite::Result<()> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:         }",
          "85:     }",
          "92:     let version = version_number();",
          "93:     if version < 3_008_012 {",
          "95:     }",
          "102:     assert_eq!(1, dummy);",
          "103: }",
          "",
          "[Removed Lines]",
          "87:     let db = Connection::open_in_memory().unwrap();",
          "89:     db.create_module::<DummyTab>(\"dummy\", &module, None)",
          "90:         .unwrap();",
          "94:         return;",
          "97:     let mut s = db.prepare(\"SELECT * FROM dummy()\").unwrap();",
          "99:     let dummy = s",
          "100:         .query_row(&[] as &[&dyn ToSql], |row| row.get::<_, i32>(0))",
          "101:         .unwrap();",
          "",
          "[Added Lines]",
          "87:     let db = Connection::open_in_memory()?;",
          "89:     db.create_module::<DummyTab>(\"dummy\", &module, None)?;",
          "93:         return Ok(());",
          "96:     let mut s = db.prepare(\"SELECT * FROM dummy()\")?;",
          "98:     let dummy = s.query_row(&[] as &[&dyn ToSql], |row| row.get::<_, i32>(0))?;",
          "100:     Ok(())",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
      "candidate_info": {
        "commit_hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
        "repo": "rusqlite/rusqlite",
        "commit_url": "https://github.com/rusqlite/rusqlite/commit/71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
        "files": [
          "src/functions.rs"
        ],
        "message": "Ensure type use for auxdata is repr(C)",
        "before_after_code_files": [
          "src/functions.rs||src/functions.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/functions.rs||src/functions.rs"
          ],
          "candidate": [
            "src/functions.rs||src/functions.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/functions.rs||src/functions.rs": [
          "File: src/functions.rs -> src/functions.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "70: use std::os::raw::{c_int, c_void};",
          "71: use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};",
          "72: use std::ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: use std::any::TypeId;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {",
          "181:         unsafe {",
          "182:             ffi::sqlite3_set_auxdata(",
          "183:                 self.ctx,",
          "184:                 arg,",
          "185:                 boxed as *mut c_void,",
          "187:             )",
          "188:         };",
          "189:     }",
          "",
          "[Removed Lines]",
          "180:         let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));",
          "186:                 Some(free_boxed_value::<(std::any::TypeId, T)>),",
          "",
          "[Added Lines]",
          "181:         let boxed = Box::into_raw(Box::new(AuxData {",
          "182:             id: TypeId::of::<T>(),",
          "183:             value,",
          "184:         }));",
          "190:                 Some(free_boxed_value::<AuxData<T>>),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {",
          "196:         if p.is_null() {",
          "197:             Ok(None)",
          "198:         } else {",
          "201:                 Err(Error::GetAuxWrongType)",
          "202:             } else {",
          "204:             }",
          "205:         }",
          "206:     }",
          "207: }",
          "",
          "[Removed Lines]",
          "195:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };",
          "199:             let id_val = unsafe { &*p };",
          "200:             if std::any::TypeId::of::<T>() != id_val.0 {",
          "203:                 Ok(Some(&id_val.1))",
          "",
          "[Added Lines]",
          "199:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };",
          "203:             let id = unsafe { (*p).id };",
          "204:             if TypeId::of::<T>() != id {",
          "207:                 Ok(Some(unsafe { &(*p).value }))",
          "213: #[repr(C)]",
          "214: struct AuxData<T: 'static> {",
          "215:     id: TypeId,",
          "216:     value: T,",
          "217: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
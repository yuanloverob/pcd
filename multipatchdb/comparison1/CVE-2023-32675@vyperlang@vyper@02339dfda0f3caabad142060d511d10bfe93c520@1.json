{
  "cve_id": "CVE-2023-32675",
  "cve_desc": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In contracts with more than one regular nonpayable function, it is possible to send funds to the default function, even if the default function is marked `nonpayable`. This applies to contracts compiled with vyper versions prior to 0.3.8. This issue was fixed by the removal of the global `calldatasize` check in commit `02339dfda`. Users are advised to upgrade to version 0.3.8. Users unable to upgrade should avoid use of nonpayable default functions.",
  "repo": "vyperlang/vyper",
  "patch_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
  "patch_info": {
    "commit_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
    "repo": "vyperlang/vyper",
    "commit_url": "https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520",
    "files": [
      "tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py"
    ],
    "message": "refactor: optimize calldatasize check (#3104)\n\nthis changes the calldatasize check from a global/contract-entry check\nto a function-local check - the calldatasize check only needs to be\npresent if a selector is 0. this maintains the invariant protecting\nagainst the bug in #1603 while being more efficient.\n\nCo-authored-by: Charles Cooper <cooper.charles.m@gmail.com>",
    "before_after_code_files": [
      "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py||vyper/codegen/module.py"
    ]
  },
  "patch_diff": {
    "tests/parser/features/test_init.py||tests/parser/features/test_init.py": [
      "File: tests/parser/features/test_init.py -> tests/parser/features/test_init.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:     assert c.val() == 123",
      "17:     # Make sure the init code does not access calldata",
      "26: def test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):",
      "",
      "[Removed Lines]",
      "18:     opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")",
      "19:     ir_return_idx = opcodes.index(\"JUMP\")",
      "21:     assert \"CALLDATALOAD\" in opcodes",
      "22:     assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]",
      "23:     assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]",
      "",
      "[Added Lines]",
      "18:     assembly = vyper.compile_code(code, [\"asm\"])[\"asm\"].split(\" \")",
      "19:     ir_return_idx_start = assembly.index(\"{\")",
      "20:     ir_return_idx_end = assembly.index(\"}\")",
      "22:     assert \"CALLDATALOAD\" in assembly",
      "23:     assert \"CALLDATACOPY\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "24:     assert \"CALLDATALOAD\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "",
      "---------------"
    ],
    "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
      "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "124:         ret.append([\"goto\", sig.external_function_base_entry_label])",
      "127:         return ret",
      "129:     ret = [\"seq\"]",
      "",
      "[Removed Lines]",
      "126:         ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]",
      "",
      "[Added Lines]",
      "126:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
      "128:         # if there is a function whose selector is 0, it won't be distinguished",
      "129:         # from the case where nil calldata is supplied, b/c calldataload loads",
      "130:         # 0s past the end of physical calldata (cf. yellow paper).",
      "131:         # since supplying 0 calldata is expected to trigger the fallback fn,",
      "132:         # we check that calldatasize > 0, which distinguishes the 0 selector",
      "133:         # from the fallback function \"selector\"",
      "134:         # (equiv. to \"all selectors not in the selector table\").",
      "136:         # note: cases where not enough calldata is supplied (besides",
      "137:         # calldatasize==0) are not addressed here b/c a calldatasize",
      "138:         # well-formedness check is already present in the function body",
      "139:         # as part of abi validation",
      "140:         if method_id.value == 0:",
      "141:             method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
      "143:         ret = [\"if\", method_id_check, ret]",
      "",
      "---------------"
    ],
    "vyper/codegen/module.py||vyper/codegen/module.py": [
      "File: vyper/codegen/module.py -> vyper/codegen/module.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:     runtime = [",
      "122:         \"seq\",",
      "126:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
      "127:         close_selector_section,",
      "128:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
      "",
      "[Removed Lines]",
      "123:         # check that calldatasize is at least 4, otherwise",
      "124:         # calldataload will load zeros (cf. yellow paper).",
      "125:         [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aa8affbc4ada843ea53d6e8f5a1c2d0726d0137b",
      "candidate_info": {
        "commit_hash": "aa8affbc4ada843ea53d6e8f5a1c2d0726d0137b",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/aa8affbc4ada843ea53d6e8f5a1c2d0726d0137b",
        "files": [
          "vyper/codegen/module.py"
        ],
        "message": "feat: close external section with goto fallback (#2692)\n\nensure basic block hygiene by closing with a terminating instruction",
        "before_after_code_files": [
          "vyper/codegen/module.py||vyper/codegen/module.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:             external_seq.append([\"assert\", [\"iszero\", \"callvalue\"]])",
          "169:             external_seq += nonpayable_funcs",
          "171:     # bytecode is organized by: external functions, fallback fn, internal functions",
          "172:     # this way we save gas and reduce bytecode by not jumping over internal functions",
          "173:     runtime = [",
          "174:         \"seq\",",
          "175:         func_init_lll(),",
          "176:         [\"with\", \"_calldata_method_id\", [\"mload\", 0], external_seq],",
          "177:         [\"label\", \"fallback\", [\"var_list\"], fallback_lll],",
          "178:     ]",
          "179:     runtime.extend(internal_funcs)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171:     # ensure the external jumptable section gets closed out",
          "172:     # (for basic block hygiene and also for zksync interpreter)",
          "173:     # NOTE: this jump gets optimized out in assembly since the",
          "174:     # fallback label is the immediate next instruction,",
          "175:     close_selector_section = [\"goto\", \"fallback\"]",
          "183:         close_selector_section,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d7987323fdd248eaf58ade85e8308481f747b64",
      "candidate_info": {
        "commit_hash": "1d7987323fdd248eaf58ade85e8308481f747b64",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/1d7987323fdd248eaf58ade85e8308481f747b64",
        "files": [
          "tests/ast/test_folding.py",
          "tests/compiler/test_sha3_32.py",
          "tests/parser/features/external_contracts/test_external_contract_calls.py",
          "tests/parser/features/test_clampers.py",
          "tests/parser/features/test_init.py",
          "tests/parser/functions/test_convert_to_decimal.py",
          "tests/parser/types/numbers/test_constants.py",
          "tests/parser/types/test_identifier_naming.py",
          "vyper/ast/folding.py",
          "vyper/ast/nodes.py",
          "vyper/builtin_functions/convert.py",
          "vyper/codegen/core.py",
          "vyper/codegen/expr.py",
          "vyper/codegen/module.py",
          "vyper/codegen/types/types.py",
          "vyper/ir/optimizer.py",
          "vyper/semantics/types/value/numeric.py",
          "vyper/utils.py"
        ],
        "message": "feat(lang): change decimal bounds (#2730)\n\nchange from (-2**127 * 10**10, 2**127-1 * 10**10) to (-2**168, 2**168).\nthis way we use the entire space, and clamps are more efficient and\neasier to reason about since we can use the same clamps as integers.\n\nthis commit also removes the LOADED_LIMITS from memory so we have more\nunreserved memory and smaller code now.",
        "before_after_code_files": [
          "tests/ast/test_folding.py||tests/ast/test_folding.py",
          "tests/compiler/test_sha3_32.py||tests/compiler/test_sha3_32.py",
          "tests/parser/features/external_contracts/test_external_contract_calls.py||tests/parser/features/external_contracts/test_external_contract_calls.py",
          "tests/parser/features/test_clampers.py||tests/parser/features/test_clampers.py",
          "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
          "tests/parser/functions/test_convert_to_decimal.py||tests/parser/functions/test_convert_to_decimal.py",
          "tests/parser/types/numbers/test_constants.py||tests/parser/types/numbers/test_constants.py",
          "tests/parser/types/test_identifier_naming.py||tests/parser/types/test_identifier_naming.py",
          "vyper/ast/folding.py||vyper/ast/folding.py",
          "vyper/ast/nodes.py||vyper/ast/nodes.py",
          "vyper/builtin_functions/convert.py||vyper/builtin_functions/convert.py",
          "vyper/codegen/core.py||vyper/codegen/core.py",
          "vyper/codegen/expr.py||vyper/codegen/expr.py",
          "vyper/codegen/module.py||vyper/codegen/module.py",
          "vyper/codegen/types/types.py||vyper/codegen/types/types.py",
          "vyper/ir/optimizer.py||vyper/ir/optimizer.py",
          "vyper/semantics/types/value/numeric.py||vyper/semantics/types/value/numeric.py",
          "vyper/utils.py||vyper/utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/ast/test_folding.py||tests/ast/test_folding.py": [
          "File: tests/ast/test_folding.py -> tests/ast/test_folding.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: def test_replace_decimal_nested_intermediate_overflow():",
          "49:     with pytest.raises(OverflowException):",
          "50:         folding.fold(test_ast)",
          "53: def test_replace_decimal_nested_intermediate_underflow():",
          "55:     with pytest.raises(OverflowException):",
          "56:         folding.fold(test_ast)",
          "",
          "[Removed Lines]",
          "48:     test_ast = vy_ast.parse_to_ast(\"170141183460469231731687303715884105726.0 + 1.1 - 10.0\")",
          "54:     test_ast = vy_ast.parse_to_ast(\"-170141183460469231731687303715884105726.0 - 2.1 + 10.0\")",
          "",
          "[Added Lines]",
          "48:     test_ast = vy_ast.parse_to_ast(",
          "49:         \"18707220957835557353007165858768422651595.9365500927 + 1e-10 - 1e-10\"",
          "50:     )",
          "56:     test_ast = vy_ast.parse_to_ast(",
          "57:         \"-18707220957835557353007165858768422651595.9365500928 - 1e-10 + 1e-10\"",
          "58:     )",
          "",
          "---------------"
        ],
        "tests/compiler/test_sha3_32.py||tests/compiler/test_sha3_32.py": [
          "File: tests/compiler/test_sha3_32.py -> tests/compiler/test_sha3_32.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: def test_sha3_32():",
          "6:     ir = [\"sha3_32\", 0]",
          "8:     assert compile_ir.compile_to_assembly(IRnode.from_list(ir)) == evm",
          "9:     assert compile_ir.compile_to_assembly(optimizer.optimize(IRnode.from_list(ir))) == evm",
          "",
          "[Removed Lines]",
          "7:     evm = [\"PUSH1\", 0, \"PUSH1\", 128, \"MSTORE\", \"PUSH1\", 32, \"PUSH1\", 128, \"SHA3\"]",
          "",
          "[Added Lines]",
          "7:     evm = [\"PUSH1\", 0, \"PUSH1\", 0, \"MSTORE\", \"PUSH1\", 32, \"PUSH1\", 0, \"SHA3\"]",
          "",
          "---------------"
        ],
        "tests/parser/features/external_contracts/test_external_contract_calls.py||tests/parser/features/external_contracts/test_external_contract_calls.py": [
          "File: tests/parser/features/external_contracts/test_external_contract_calls.py -> tests/parser/features/external_contracts/test_external_contract_calls.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1405:     c2.set_contract(c1.address, transact={})",
          "1407:     assert c2.get_lucky(1000) == 656598",
          "1411: def test_skip_contract_check(get_contract_with_gas_estimation):",
          "",
          "[Removed Lines]",
          "1408:     assert_tx_failed(lambda: c2.get_lucky(100))  # too little gas.",
          "",
          "[Added Lines]",
          "1408:     assert_tx_failed(lambda: c2.get_lucky(50))  # too little gas.",
          "",
          "---------------"
        ],
        "tests/parser/features/test_clampers.py||tests/parser/features/test_clampers.py": [
          "File: tests/parser/features/test_clampers.py -> tests/parser/features/test_clampers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:         0,",
          "171:         1,",
          "172:         -1,",
          "175:         \"0.0\",",
          "176:         \"1.0\",",
          "177:         \"-1.0\",",
          "",
          "[Removed Lines]",
          "173:         2 ** 127 - 1,",
          "174:         -(2 ** 127),",
          "",
          "[Added Lines]",
          "173:         Decimal(2 ** 167 - 1) / 10 ** 10,",
          "174:         -Decimal(2 ** 167) / 10 ** 10,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:         \"0.9999999999\",",
          "180:         \"-0.0000000001\",",
          "181:         \"-0.9999999999\",",
          "184:     ],",
          "185: )",
          "186: def test_decimal_clamper_passing(get_contract, value, evm_version):",
          "",
          "[Removed Lines]",
          "182:         \"170141183460469231731687303715884105726.9999999999\",  # 2 ** 127 - 1.0000000001",
          "183:         \"-170141183460469231731687303715884105727.9999999999\",  # - (2 ** 127 - 0.0000000001)",
          "",
          "[Added Lines]",
          "182:         \"18707220957835557353007165858768422651595.9365500927\",  # 2**167 - 1e-10",
          "183:         \"-18707220957835557353007165858768422651595.9365500928\",  # -2**167",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "199: @pytest.mark.parametrize(",
          "200:     \"value\",",
          "201:     [",
          "206:     ],",
          "207: )",
          "209:     code = \"\"\"",
          "210: @external",
          "211: def foo(s: decimal) -> decimal:",
          "",
          "[Removed Lines]",
          "202:         2 ** 127,",
          "203:         -(2 ** 127 + 1),",
          "204:         \"170141183460469231731687303715884105727.0000000001\",  # 2 ** 127 - 0.999999999",
          "205:         \"-170141183460469231731687303715884105728.0000000001\",  # - (2 ** 127 + 0.0000000001)",
          "208: def test_decimal_clamper_failing(assert_tx_failed, get_contract, value, evm_version):",
          "",
          "[Added Lines]",
          "202:         2 ** 167,",
          "203:         -(2 ** 167 + 1),",
          "204:         187072209578355573530071658587684226515959365500928,  # 2 ** 167",
          "205:         -187072209578355573530071658587684226515959365500929,  # - (2 ** 127 - 1e-10)",
          "208: def test_decimal_clamper_failing(w3, assert_tx_failed, get_contract, value, evm_version):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "215:     c = get_contract(code, evm_version=evm_version)",
          "220: @pytest.mark.parametrize(\"value\", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])",
          "",
          "[Removed Lines]",
          "217:     assert_tx_failed(lambda: c.foo(Decimal(value)))",
          "",
          "[Added Lines]",
          "217:     assert_tx_failed(lambda: _make_tx(w3, c.address, \"foo(fixed168x10)\", [value]))",
          "",
          "---------------"
        ],
        "tests/parser/features/test_init.py||tests/parser/features/test_init.py": [
          "File: tests/parser/features/test_init.py -> tests/parser/features/test_init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:     opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")",
          "19:     ir_return_idx = opcodes.index(\"JUMP\")",
          "22:     assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]",
          "23:     assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]",
          "",
          "[Removed Lines]",
          "21:     assert \"CALLDATACOPY\" in opcodes",
          "",
          "[Added Lines]",
          "21:     assert \"CALLDATALOAD\" in opcodes",
          "",
          "---------------"
        ],
        "tests/parser/functions/test_convert_to_decimal.py||tests/parser/functions/test_convert_to_decimal.py": [
          "File: tests/parser/functions/test_convert_to_decimal.py -> tests/parser/functions/test_convert_to_decimal.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: from decimal import Decimal",
          "3: from vyper.exceptions import InvalidLiteral, TypeMismatch",
          "8: a: int128",
          "9: b: decimal",
          "",
          "[Removed Lines]",
          "6: def test_convert_from_int128(get_contract_with_gas_estimation):",
          "7:     code = \"\"\"",
          "",
          "[Added Lines]",
          "1: import math",
          "4: import pytest",
          "9: @pytest.mark.parametrize(\"inp\", [1, -1, 2 ** 127 - 1, -(2 ** 127)])",
          "10: def test_convert_from_int128(get_contract_with_gas_estimation, inp):",
          "11:     code = f\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13:     self.a = inp",
          "14:     memory: decimal = convert(inp, decimal)",
          "15:     storage: decimal = convert(self.a, decimal)",
          "17:     return  memory, storage, literal",
          "18: \"\"\"",
          "19:     c = get_contract_with_gas_estimation(code)",
          "23: def test_convert_from_uint256(assert_tx_failed, get_contract_with_gas_estimation):",
          "",
          "[Removed Lines]",
          "16:     literal: decimal = convert(1, decimal)",
          "20:     assert c.int128_to_decimal(1) == [1.0, 1.0, 1.0]",
          "",
          "[Added Lines]",
          "20:     literal: decimal = convert({inp}, decimal)",
          "24:     assert c.int128_to_decimal(inp) == [Decimal(inp)] * 3",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "37:     assert c.test_variable() is True",
          "38:     assert c.test_passed_variable(256) == 256",
          "40:     assert c.test_passed_variable(max_decimal) == Decimal(max_decimal)",
          "44: def test_convert_from_uint256_overflow(get_contract_with_gas_estimation, assert_compile_failed):",
          "45:     code = \"\"\"",
          "46: @external",
          "47: def foo() -> decimal:",
          "49:     \"\"\"",
          "51:     assert_compile_failed(lambda: get_contract_with_gas_estimation(code), InvalidLiteral)",
          "",
          "[Removed Lines]",
          "39:     max_decimal = 2 ** 127 - 1",
          "41:     assert_tx_failed(lambda: c.test_passed_variable(max_decimal + 1))",
          "48:     return convert(2**127, decimal)",
          "",
          "[Added Lines]",
          "44:     max_decimal = math.floor(Decimal(2 ** 167 - 1) / 10 ** 10)",
          "47:     failing_decimal = max_decimal + 1",
          "48:     assert_tx_failed(lambda: c.test_passed_variable(failing_decimal))",
          "55:     return convert(2**167, decimal)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "80: def test_convert_from_bytes32_overflow(get_contract_with_gas_estimation, assert_compile_failed):",
          "82: @external",
          "83: def foo() -> decimal:",
          "85:     \"\"\"",
          "87:     assert_compile_failed(lambda: get_contract_with_gas_estimation(code), InvalidLiteral)",
          "",
          "[Removed Lines]",
          "81:     code = \"\"\"",
          "84:     return convert(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, decimal)",
          "",
          "[Added Lines]",
          "88:     # bytes for 2**167",
          "89:     failing_decimal_bytes = \"0x\" + (2 ** 167).to_bytes(32, byteorder=\"big\").hex()",
          "90:     code = f\"\"\"",
          "93:     return convert({failing_decimal_bytes}, decimal)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "176:     c = get_contract_with_gas_estimation(code)",
          "177:     assert c.test(0) == 0",
          "178:     assert c.test(-1) == -1",
          "182:     assert_tx_failed(lambda: c.test(2 ** 255 - 1))",
          "184:     assert_tx_failed(lambda: c.test(-(2 ** 255)))",
          "",
          "[Removed Lines]",
          "179:     assert c.test(2 ** 127 - 1) == 2 ** 127 - 1",
          "180:     assert c.test(-(2 ** 127)) == -(2 ** 127)",
          "181:     assert_tx_failed(lambda: c.test(2 ** 127))",
          "183:     assert_tx_failed(lambda: c.test(-(2 ** 127) - 1))",
          "",
          "[Added Lines]",
          "191:     max_decimal = math.floor(Decimal(2 ** 167 - 1) / 10 ** 10)",
          "192:     assert c.test(max_decimal) == Decimal(max_decimal)",
          "194:     min_decimal = math.ceil(-Decimal(2 ** 167) / 10 ** 10)",
          "195:     assert c.test(min_decimal) == Decimal(min_decimal)",
          "197:     assert_tx_failed(lambda: c.test(max_decimal + 1))",
          "198:     assert_tx_failed(lambda: c.test(min_decimal - 1))",
          "",
          "---------------"
        ],
        "tests/parser/types/numbers/test_constants.py||tests/parser/types/numbers/test_constants.py": [
          "File: tests/parser/types/numbers/test_constants.py -> tests/parser/types/numbers/test_constants.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     assert c.test_int128(-(2 ** 127)) == [False, True]",
          "53:     assert c.test_int128(0) == [False, False]",
          "57:     assert c.test_decimal(Decimal(\"0.1\")) == [False, False]",
          "59:     assert c.test_uint256(2 ** 256 - 1) is True",
          "",
          "[Removed Lines]",
          "55:     assert c.test_decimal(Decimal(2 ** 127 - 1)) == [True, False]",
          "56:     assert c.test_decimal(Decimal(\"-170141183460469231731687303715884105728\")) == [False, True]",
          "",
          "[Added Lines]",
          "55:     assert c.test_decimal(Decimal(\"18707220957835557353007165858768422651595.9365500927\")) == [",
          "56:         True,",
          "57:         False,",
          "58:     ]",
          "59:     assert c.test_decimal(Decimal(\"-18707220957835557353007165858768422651595.9365500928\")) == [",
          "60:         False,",
          "61:         True,",
          "62:     ]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "109:     assert c.joo() is None",
          "114:     assert c.zoo() == 2 ** 256 - 1",
          "",
          "[Removed Lines]",
          "111:     assert c.koo() == Decimal(2 ** 127 - 1)",
          "112:     assert c.loo() == Decimal(-(2 ** 127))",
          "",
          "[Added Lines]",
          "117:     assert c.koo() == Decimal(2 ** 167 - 1) / 10 ** 10",
          "118:     assert c.loo() == Decimal(-(2 ** 167)) / 10 ** 10",
          "",
          "---------------"
        ],
        "tests/parser/types/test_identifier_naming.py||tests/parser/types/test_identifier_naming.py": [
          "File: tests/parser/types/test_identifier_naming.py -> tests/parser/types/test_identifier_naming.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import pytest",
          "3: from vyper.builtin_functions import BUILTIN_FUNCTIONS",
          "5: from vyper.exceptions import NamespaceCollision, StructureException, SyntaxException",
          "6: from vyper.semantics.namespace import RESERVED_KEYWORDS",
          "7: from vyper.utils import FUNCTION_WHITELIST",
          "",
          "[Removed Lines]",
          "4: from vyper.codegen.expr import BUILTIN_CONSTANTS, ENVIRONMENT_VARIABLES",
          "",
          "[Added Lines]",
          "3: from vyper.ast.folding import BUILTIN_CONSTANTS",
          "5: from vyper.codegen.expr import ENVIRONMENT_VARIABLES",
          "",
          "---------------"
        ],
        "vyper/ast/folding.py||vyper/ast/folding.py": [
          "File: vyper/ast/folding.py -> vyper/ast/folding.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import copy",
          "3: from typing import Union",
          "5: from vyper.ast import nodes as vy_ast",
          "",
          "[Removed Lines]",
          "2: from decimal import Decimal",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7: from vyper.exceptions import UnfoldableNode, UnknownType",
          "8: from vyper.semantics.types.bases import BaseTypeDefinition, DataLocation",
          "9: from vyper.semantics.types.utils import get_type_from_annotation",
          "11: BUILTIN_CONSTANTS = {",
          "12:     \"EMPTY_BYTES32\": (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: from vyper.utils import SizeLimits",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "16:     \"ZERO_ADDRESS\": (vy_ast.Hex, \"0x0000000000000000000000000000000000000000\"),",
          "17:     \"MAX_INT128\": (vy_ast.Int, 2 ** 127 - 1),",
          "18:     \"MIN_INT128\": (vy_ast.Int, -(2 ** 127)),",
          "21:     \"MAX_UINT256\": (vy_ast.Int, 2 ** 256 - 1),",
          "22: }",
          "",
          "[Removed Lines]",
          "19:     \"MAX_DECIMAL\": (vy_ast.Decimal, Decimal(2 ** 127 - 1)),",
          "20:     \"MIN_DECIMAL\": (vy_ast.Decimal, Decimal(-(2 ** 127))),",
          "",
          "[Added Lines]",
          "19:     \"MAX_DECIMAL\": (vy_ast.Decimal, SizeLimits.MAX_AST_DECIMAL),",
          "20:     \"MIN_DECIMAL\": (vy_ast.Decimal, SizeLimits.MIN_AST_DECIMAL),",
          "",
          "---------------"
        ],
        "vyper/ast/nodes.py||vyper/ast/nodes.py": [
          "File: vyper/ast/nodes.py -> vyper/ast/nodes.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:     node: Union[\"BinOp\", \"UnaryOp\"], value: Union[decimal.Decimal, int]",
          "184: ) -> None:",
          "185:     if isinstance(value, decimal.Decimal):",
          "187:     elif isinstance(value, int):",
          "188:         lower, upper = SizeLimits.MIN_INT256, SizeLimits.MAX_UINT256",
          "189:     else:",
          "",
          "[Removed Lines]",
          "186:         lower, upper = SizeLimits.MIN_INT128, SizeLimits.MAX_INT128",
          "",
          "[Added Lines]",
          "186:         # this will change if/when we add more decimal types",
          "187:         lower, upper = SizeLimits.MIN_AST_DECIMAL, SizeLimits.MAX_AST_DECIMAL",
          "",
          "---------------"
        ],
        "vyper/builtin_functions/convert.py||vyper/builtin_functions/convert.py": [
          "File: vyper/builtin_functions/convert.py -> vyper/builtin_functions/convert.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:     is_integer_type,",
          "29: )",
          "30: from vyper.exceptions import CompilerPanic, InvalidLiteral, StructureException, TypeMismatch",
          "34: def _FAIL(ityp, otyp, source_expr=None):",
          "",
          "[Removed Lines]",
          "31: from vyper.utils import DECIMAL_DIVISOR, SizeLimits, int_bounds",
          "",
          "[Added Lines]",
          "31: from vyper.utils import DECIMAL_DIVISOR, SizeLimits",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102: # truncate from fixed point decimal to int",
          "104:     return IRnode.from_list([\"sdiv\", x, 10 ** decimals], typ=out_typ)",
          "107: # promote from int to fixed point decimal",
          "112: def _check_bytes(expr, arg, output_type, max_bytes_allowed):",
          "",
          "[Removed Lines]",
          "103: def _fixed_to_int(x, out_typ, decimals=10):",
          "108: def _int_to_fixed(x, out_typ, decimals=10):",
          "109:     return IRnode.from_list([\"mul\", x, 10 ** decimals], typ=out_typ)",
          "",
          "[Added Lines]",
          "103: def _fixed_to_int(x, out_typ):",
          "104:     decimals = x.typ._decimal_info.decimals",
          "109: def _int_to_fixed(x, out_typ):",
          "110:     info = out_typ._decimal_info",
          "112:     lo, hi = info.bounds",
          "113:     decimals = info.decimals",
          "115:     clamp_op = \"clamp\" if info.is_signed else \"uclamp\"",
          "117:     # TODO is this clamp redundant with later num clamps?",
          "118:     return IRnode.from_list([\"mul\", [clamp_op, lo, x, hi], 10 ** decimals], typ=out_typ)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:     else:",
          "129:         # Int, Decimal",
          "130:         val = int(expr.value)",
          "132:     if not (lo <= val <= hi):",
          "133:         raise InvalidLiteral(\"Number out of range\", expr)",
          "134:     return IRnode.from_list(val, typ=out_typ)",
          "",
          "[Removed Lines]",
          "131:     (lo, hi) = int_bounds(int_info.is_signed, int_info.bits)",
          "",
          "[Added Lines]",
          "140:     (lo, hi) = int_info.bounds",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "144:     val = val * DECIMAL_DIVISOR",
          "148:         raise InvalidLiteral(\"Number out of range\", expr)",
          "150:     # sanity check type checker did its job",
          "",
          "[Removed Lines]",
          "146:     (lo, hi) = (SizeLimits.MINDECIMAL, SizeLimits.MAXDECIMAL)",
          "147:     if not (lo <= val <= hi):",
          "",
          "[Added Lines]",
          "155:     if not SizeLimits.in_bounds(\"decimal\", val):",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "216:     elif is_decimal_type(arg.typ):",
          "217:         arg_info = arg.typ._decimal_info",
          "219:         arg = _num_clamp(arg, int_info, arg_info)",
          "221:     elif is_integer_type(arg.typ):",
          "",
          "[Removed Lines]",
          "218:         arg = _fixed_to_int(arg, out_typ, decimals=arg_info.decimals)",
          "",
          "[Added Lines]",
          "226:         arg = _fixed_to_int(arg, out_typ)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "264:         return IRnode.from_list(arg, typ=out_typ)",
          "268:     elif is_integer_type(arg.typ):",
          "269:         int_info = arg.typ._int_info",
          "278:     elif is_base_type(arg.typ, \"bool\"):",
          "280:     else:",
          "281:         raise CompilerPanic(\"unreachable\")  # pragma: notest",
          "286: @_input_types(\"int\", \"decimal\", \"bytes_m\", \"address\", \"bytes\", \"bool\")",
          "287: def to_bytes_m(expr, arg, out_typ):",
          "",
          "[Removed Lines]",
          "266:     # for the clamp, pretend it's int128 because int128 clamps are cheaper",
          "267:     # (and then multiply into the decimal base afterwards)",
          "270:         # TODO revisit this condition once we have more decimal types",
          "271:         # and decimal bounds expand. (note that right now decimal bounds",
          "272:         # are -2**127 and 2**127 - 1).",
          "273:         # will be something like: if info.m_bits > 168",
          "274:         # TODO this should probably use _num_clamp instead",
          "275:         if int_info.bits > 128:",
          "276:             arg = int_clamp(arg, 128, signed=True)",
          "279:         pass",
          "283:     return _int_to_fixed(arg, out_typ)",
          "",
          "[Added Lines]",
          "277:         arg = _int_to_fixed(arg, out_typ)",
          "278:         out_info = out_typ._decimal_info",
          "279:         if int_info.bits > out_info.bits:",
          "280:             # TODO: _num_clamp probably not necessary bc already",
          "281:             # clamped in _int_to_fixed",
          "282:             arg = _num_clamp(arg, out_info, int_info)",
          "283:         return IRnode.from_list(arg, typ=out_typ)",
          "286:         arg = _int_to_fixed(arg, out_typ)",
          "287:         return IRnode.from_list(arg, typ=out_typ)",
          "",
          "---------------"
        ],
        "vyper/codegen/core.py||vyper/codegen/core.py": [
          "File: vyper/codegen/core.py -> vyper/codegen/core.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: from vyper import ast as vy_ast",
          "4: from vyper.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE",
          "5: from vyper.codegen.ir_node import Encoding, IRnode",
          "",
          "[Removed Lines]",
          "1: from decimal import Context, setcontext",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16:     TupleType,",
          "17:     ceil32,",
          "18:     is_bytes_m_type,",
          "19:     is_integer_type,",
          "20: )",
          "21: from vyper.evm.opcodes import version_check",
          "48: # propagate revert message when calls to external contracts fail",
          "",
          "[Removed Lines]",
          "22: from vyper.exceptions import (",
          "23:     CompilerPanic,",
          "24:     DecimalOverrideException,",
          "25:     StructureException,",
          "26:     TypeCheckFailure,",
          "27:     TypeMismatch,",
          "28: )",
          "29: from vyper.utils import (",
          "30:     GAS_CALLDATACOPY_WORD,",
          "31:     GAS_CODECOPY_WORD,",
          "32:     GAS_IDENTITY,",
          "33:     GAS_IDENTITYWORD,",
          "34:     MemoryPositions,",
          "35: )",
          "38: class DecimalContextOverride(Context):",
          "39:     def __setattr__(self, name, value):",
          "40:         if name == \"prec\":",
          "41:             raise DecimalOverrideException(\"Overriding decimal precision disabled\")",
          "42:         super().__setattr__(name, value)",
          "45: setcontext(DecimalContextOverride(prec=78))",
          "",
          "[Added Lines]",
          "17:     is_decimal_type,",
          "21: from vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch",
          "22: from vyper.utils import GAS_CALLDATACOPY_WORD, GAS_CODECOPY_WORD, GAS_IDENTITY, GAS_IDENTITYWORD",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "952:     # copy of the input",
          "953:     ir_node = unwrap_location(ir_node)",
          "957:             return ir_node",
          "958:         else:",
          "969:     if t.typ in (\"address\",):",
          "970:         return int_clamp(ir_node, 160)",
          "971:     if t.typ in (\"bool\",):",
          "972:         return int_clamp(ir_node, 1)",
          "978:     raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest",
          "",
          "[Removed Lines]",
          "955:     if is_integer_type(t):",
          "956:         if t._int_info.bits == 256:",
          "959:             return int_clamp(ir_node, t._int_info.bits, signed=t._int_info.is_signed)",
          "961:     if t.typ in (\"decimal\"):",
          "962:         return [",
          "963:             \"clamp\",",
          "964:             [\"mload\", MemoryPositions.MINDECIMAL],",
          "965:             ir_node,",
          "966:             [\"mload\", MemoryPositions.MAXDECIMAL],",
          "967:         ]",
          "973:     if t.typ in (\"bytes32\",):",
          "974:         return ir_node  # special case, no clamp.",
          "975:     if is_bytes_m_type(t):",
          "976:         return bytes_clamp(ir_node, t._bytes_info.m)",
          "",
          "[Added Lines]",
          "932:     if is_integer_type(t) or is_decimal_type(t):",
          "933:         if t._num_info.bits == 256:",
          "936:             return int_clamp(ir_node, t._num_info.bits, signed=t._num_info.is_signed)",
          "938:     if is_bytes_m_type(t):",
          "939:         if t._bytes_info.m == 32:",
          "940:             return ir_node  # special case, no clamp.",
          "941:         else:",
          "942:             return bytes_clamp(ir_node, t._bytes_info.m)",
          "",
          "---------------"
        ],
        "vyper/codegen/expr.py||vyper/codegen/expr.py": [
          "File: vyper/codegen/expr.py -> vyper/codegen/expr.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: )",
          "45: from vyper.utils import DECIMAL_DIVISOR, SizeLimits, bytes_to_int, checksum_encode, string_to_bytes",
          "60: ENVIRONMENT_VARIABLES = {",
          "61:     \"block\",",
          "62:     \"msg\",",
          "",
          "[Removed Lines]",
          "47: # var name: (irnode, type)",
          "48: BUILTIN_CONSTANTS = {",
          "49:     \"EMPTY_BYTES32\": (0, \"bytes32\"),",
          "50:     \"ZERO_ADDRESS\": (0, \"address\"),",
          "51:     \"MAX_INT128\": (SizeLimits.MAX_INT128, \"int128\"),",
          "52:     \"MIN_INT128\": (SizeLimits.MIN_INT128, \"int128\"),",
          "53:     \"MAX_INT256\": (SizeLimits.MAX_INT256, \"int256\"),",
          "54:     \"MIN_INT256\": (SizeLimits.MIN_INT256, \"int256\"),",
          "55:     \"MAX_DECIMAL\": (SizeLimits.MAXDECIMAL, \"decimal\"),",
          "56:     \"MIN_DECIMAL\": (SizeLimits.MINDECIMAL, \"decimal\"),",
          "57:     \"MAX_UINT256\": (SizeLimits.MAX_UINT256, \"uint256\"),",
          "58: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:     return a",
          "184: class Expr:",
          "185:     # TODO: Once other refactors are made reevaluate all inline imports",
          "",
          "[Removed Lines]",
          "175: def get_min_val_for_type(typ: str) -> int:",
          "176:     key = \"MIN_\" + typ.upper()",
          "177:     try:",
          "178:         min_val, _ = BUILTIN_CONSTANTS[key]",
          "179:     except KeyError as e:",
          "180:         raise TypeMismatch(f\"Not a signed type: {typ}\") from e",
          "181:     return min_val",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "213:             return IRnode.from_list(self.expr.n, typ=BaseType(\"uint256\", is_literal=True))",
          "215:     def parse_Decimal(self):",
          "217:         # sanity check that type checker did its job",
          "218:         assert isinstance(val, decimal.Decimal)",
          "225:     def parse_Hex(self):",
          "226:         hexstr = self.expr.value",
          "",
          "[Removed Lines]",
          "216:         val = self.expr.value",
          "219:         assert SizeLimits.MINDECIMAL <= val <= SizeLimits.MAXDECIMAL",
          "221:         return IRnode.from_list(",
          "222:             int(val * DECIMAL_DIVISOR), typ=BaseType(\"decimal\", is_literal=True)",
          "223:         )",
          "",
          "[Added Lines]",
          "194:         val = self.expr.value * DECIMAL_DIVISOR",
          "198:         assert SizeLimits.in_bounds(\"decimal\", val)",
          "199:         assert math.ceil(val) == math.floor(val)",
          "201:         val = int(val)",
          "203:         return IRnode.from_list(val, typ=BaseType(\"decimal\", is_literal=True))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:                 mutable=var.mutable,",
          "300:             )",
          "306:         elif self.expr._metadata[\"type\"].is_immutable:",
          "307:             var = self.context.globals[self.expr.id]",
          "308:             ofst = self.expr._metadata[\"type\"].position.offset",
          "",
          "[Removed Lines]",
          "302:         elif self.expr.id in BUILTIN_CONSTANTS:",
          "303:             obj, typ = BUILTIN_CONSTANTS[self.expr.id]",
          "304:             return IRnode.from_list(obj, typ=BaseType(typ, is_literal=True))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "864:             # kludge to block behavior in #2638",
          "865:             # TODO actually implement equality for complex types",
          "866:             raise TypeMismatch(",
          "868:             )",
          "870:         return IRnode.from_list([op, left, right], typ=\"bool\")",
          "",
          "[Removed Lines]",
          "867:                 \"equality not yet supported for complex types, see issue #2638\", self.expr",
          "",
          "[Added Lines]",
          "843:                 f\"operation not yet supported for {left.typ}, {right.typ}, see issue #2638\",",
          "844:                 self.expr.op,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "915:             if isinstance(operand.typ, BaseType) and operand.typ.typ == \"bool\":",
          "916:                 return IRnode.from_list([\"iszero\", operand], typ=\"bool\")",
          "917:         elif isinstance(self.expr.op, vy_ast.USub) and is_numeric_type(operand.typ):",
          "918:             # Clamp on minimum integer value as we cannot negate that value",
          "919:             # (all other integer values are fine)",
          "921:             return IRnode.from_list(",
          "922:                 [\"sub\", 0, [\"clampgt\", operand, min_int_val]],",
          "923:                 typ=operand.typ,",
          "",
          "[Removed Lines]",
          "920:             min_int_val = get_min_val_for_type(operand.typ.typ)",
          "",
          "[Added Lines]",
          "895:             assert operand.typ._num_info.is_signed",
          "898:             min_int_val, _ = operand.typ._num_info.bounds",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # a contract.vy -- all functions and constructor",
          "5: from vyper import ast as vy_ast",
          "6: from vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures",
          "7: from vyper.codegen.function_definitions import (",
          "8:     generate_ir_for_function,",
          "9:     is_default_func,",
          "",
          "[Removed Lines]",
          "3: from typing import Any, List, Tuple, Union",
          "",
          "[Added Lines]",
          "3: from typing import List, Tuple, Union",
          "7: from vyper.codegen.core import shr",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17:     StructureException,",
          "18: )",
          "19: from vyper.semantics.types.function import FunctionVisibility, StateMutability",
          "22: # TODO remove this check",
          "23: if not hasattr(vy_ast, \"AnnAssign\"):",
          "24:     raise Exception(\"Requires python 3.6 or higher for annotation support\")",
          "48: def parse_external_interfaces(external_interfaces, global_ctx):",
          "49:     for _interfacename in global_ctx._contracts:",
          "",
          "[Removed Lines]",
          "20: from vyper.utils import LOADED_LIMITS",
          "26: # Header code",
          "27: STORE_CALLDATA: List[Any] = [",
          "28:     \"seq\",",
          "29:     # check that calldatasize is at least 4, otherwise",
          "30:     # calldataload will load zeros (cf. yellow paper).",
          "31:     [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
          "32:     [\"calldatacopy\", 28, 0, 4],",
          "33: ]",
          "34: # Store limit constants at fixed addresses in memory.",
          "35: LIMIT_MEMORY_SET: List[Any] = [",
          "36:     [\"mstore\", pos, limit_size] for pos, limit_size in LOADED_LIMITS.items()",
          "37: ]",
          "40: def func_init_ir():",
          "41:     return IRnode.from_list(STORE_CALLDATA + LIMIT_MEMORY_SET, typ=None)",
          "44: def init_func_init_ir():",
          "45:     return IRnode.from_list([\"seq\"] + LIMIT_MEMORY_SET, typ=None)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113:     payable_funcs = []",
          "114:     nonpayable_funcs = []",
          "115:     internal_funcs = []",
          "118:     for func_node in regular_functions:",
          "119:         func_type = func_node._metadata[\"type\"]",
          "",
          "[Removed Lines]",
          "116:     add_gas = func_init_ir().gas",
          "",
          "[Added Lines]",
          "95:     add_gas = 0",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "179:     # this way we save gas and reduce bytecode by not jumping over internal functions",
          "180:     runtime = [",
          "181:         \"seq\",",
          "184:         close_selector_section,",
          "185:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "186:     ]",
          "",
          "[Removed Lines]",
          "182:         func_init_ir(),",
          "183:         [\"with\", \"_calldata_method_id\", [\"mload\", 0], external_seq],",
          "",
          "[Added Lines]",
          "161:         # check that calldatasize is at least 4, otherwise",
          "162:         # calldataload will load zeros (cf. yellow paper).",
          "163:         [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
          "164:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), external_seq],",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "224:     init_func_ir = None",
          "225:     if init_function:",
          "227:         init_func_ir, _frame_start, init_frame_size = generate_ir_for_function(",
          "228:             init_function,",
          "229:             {**{\"self\": sigs}, **external_interfaces},",
          "",
          "[Removed Lines]",
          "226:         o.append(init_func_init_ir())",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/codegen/types/types.py||vyper/codegen/types/types.py": [
          "File: vyper/codegen/types/types.py -> vyper/codegen/types/types.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import re",
          "4: from collections import OrderedDict",
          "5: from dataclasses import dataclass",
          "8: from vyper import ast as vy_ast",
          "9: from vyper.abi_types import (",
          "",
          "[Removed Lines]",
          "6: from typing import Any",
          "",
          "[Added Lines]",
          "6: from typing import Any, Tuple",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:     ABIType,",
          "21: )",
          "22: from vyper.exceptions import ArgumentException, CompilerPanic, InvalidType",
          "25: # Available base types",
          "26: UNSIGNED_INTEGER_TYPES = {f\"uint{8*(i+1)}\" for i in range(32)}",
          "",
          "[Removed Lines]",
          "23: from vyper.utils import ceil32",
          "",
          "[Added Lines]",
          "23: from vyper.utils import ceil32, int_bounds",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83: @dataclass",
          "86:     bits: int",
          "89: @dataclass",
          "92:     decimals: int",
          "96: @dataclass",
          "",
          "[Removed Lines]",
          "84: class IntegerTypeInfo:",
          "85:     is_signed: bool",
          "90: class DecimalTypeInfo:",
          "91:     bits: int",
          "93:     is_signed: bool  # always true for now but may change",
          "",
          "[Added Lines]",
          "84: class NumericTypeInfo:",
          "86:     is_signed: bool",
          "88:     @property",
          "89:     def bounds(self) -> Tuple[int, int]:",
          "90:         return int_bounds(signed=self.is_signed, bits=self.bits)",
          "94: class IntegerTypeInfo(NumericTypeInfo):",
          "95:     pass",
          "98: @dataclass",
          "99: class DecimalTypeInfo(NumericTypeInfo):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:         if is_integer_type(self):",
          "165:             self._int_info = parse_integer_typeinfo(typename)",
          "166:         if is_base_type(self, \"address\"):",
          "167:             self._int_info = IntegerTypeInfo(bits=160, is_signed=False)",
          "168:         # don't generate _int_info for bool,",
          "169:         # it doesn't really behave like an int in conversions",
          "170:         # and should have special handling in the codebase",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:             self._num_info = self._int_info",
          "176:             self._num_info = self._int_info",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:             self._bytes_info = parse_bytes_m_info(typename)",
          "173:         if is_decimal_type(self):",
          "174:             self._decimal_info = parse_decimal_info(typename)",
          "176:     def eq(self, other):",
          "177:         return self.typ == other.typ",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184:             self._num_info = self._decimal_info",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "503: # Is a type representing a number?",
          "504: def is_numeric_type(typ):",
          "520: # Is a type representing some particular base type?",
          "",
          "[Removed Lines]",
          "505:     return isinstance(typ, BaseType) and typ.typ in (",
          "506:         \"int128\",",
          "507:         \"int256\",",
          "508:         \"uint8\",",
          "509:         \"uint256\",",
          "510:         \"decimal\",",
          "511:     )",
          "514: def is_signed_num(typ):",
          "515:     if not is_numeric_type(typ):",
          "516:         return None",
          "517:     return typ.typ.startswith(\"u\")",
          "",
          "[Added Lines]",
          "515:     # NOTE: not quite the same as hasattr(typ, \"_num_info\") (address has _num_info)",
          "516:     return is_integer_type(typ) or is_decimal_type(typ)",
          "",
          "---------------"
        ],
        "vyper/ir/optimizer.py||vyper/ir/optimizer.py": [
          "File: vyper/ir/optimizer.py -> vyper/ir/optimizer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: from typing import List, Optional",
          "4: from vyper.codegen.ir_node import IRnode",
          "8: def get_int_at(args: List[IRnode], pos: int, signed: bool = False) -> Optional[int]:",
          "",
          "[Removed Lines]",
          "5: from vyper.utils import LOADED_LIMITS, ceil32, evm_div, evm_mod",
          "",
          "[Added Lines]",
          "5: from vyper.utils import ceil32, evm_div, evm_mod",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:     if isinstance(value, int):",
          "12:         o = value",
          "20:     else:",
          "21:         return None",
          "",
          "[Removed Lines]",
          "13:     elif (",
          "14:         value == \"mload\"",
          "15:         and args[pos].args[0].value in LOADED_LIMITS.keys()",
          "16:         and isinstance(args[pos].args[0].value, int)",
          "17:     ):",
          "18:         idx = int(args[pos].args[0].value)  # isinstance in if confirms type is int.",
          "19:         o = LOADED_LIMITS[idx]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "47:     )",
          "58:     # TODO add rules for modulus powers of 2",
          "59:     # TODO refactor this into several functions",
          "63:     value = node.value",
          "64:     typ = node.typ",
          "",
          "[Removed Lines]",
          "50: def optimize(ir_node: IRnode) -> IRnode:",
          "51:     ir_node = apply_general_optimizations(ir_node)",
          "52:     ir_node = filter_unused_sizelimits(ir_node)",
          "54:     return ir_node",
          "57: def apply_general_optimizations(node: IRnode) -> IRnode:",
          "61:     argz = [apply_general_optimizations(arg) for arg in node.args]",
          "",
          "[Added Lines]",
          "43: def optimize(node: IRnode) -> IRnode:",
          "47:     argz = [optimize(arg) for arg in node.args]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "304:         mstore_nodes.clear()",
          "321: def _find_mload_offsets(ir_node: IRnode, expected_offsets: set, seen_offsets: set) -> set:",
          "322:     for node in ir_node.args:",
          "323:         if node.value == \"mload\" and node.args[0].value in expected_offsets:",
          "",
          "[Removed Lines]",
          "307: def filter_unused_sizelimits(ir_node: IRnode) -> IRnode:",
          "308:     # recursively search the IR for mloads of the size limits, and then remove",
          "309:     # the initial mstore operations for size limits that are never referenced",
          "310:     expected_offsets = set(LOADED_LIMITS)",
          "311:     seen_offsets = _find_mload_offsets(ir_node, expected_offsets, set())",
          "312:     if expected_offsets == seen_offsets:",
          "313:         return ir_node",
          "315:     unseen_offsets = expected_offsets.difference(seen_offsets)",
          "316:     _remove_mstore(ir_node, unseen_offsets)",
          "318:     return ir_node",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/semantics/types/value/numeric.py||vyper/semantics/types/value/numeric.py": [
          "File: vyper/semantics/types/value/numeric.py -> vyper/semantics/types/value/numeric.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:     UnsignedIntegerAbstractType,",
          "10: )",
          "11: from vyper.semantics.types.bases import BasePrimitive, BaseTypeDefinition, ValueTypeDefinition",
          "15: class AbstractNumericDefinition(ValueTypeDefinition):",
          "",
          "[Removed Lines]",
          "12: from vyper.utils import int_bounds",
          "",
          "[Added Lines]",
          "12: from vyper.utils import SizeLimits, int_bounds",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185: class DecimalPrimitive(_NumericPrimitive):",
          "187:     _id = \"decimal\"",
          "188:     _type = DecimalDefinition",
          "189:     _valid_literal = (vy_ast.Decimal,)",
          "",
          "[Removed Lines]",
          "186:     _bounds = (-(2 ** 127), 2 ** 127 - 1)",
          "",
          "[Added Lines]",
          "186:     _bounds = (SizeLimits.MIN_AST_DECIMAL, SizeLimits.MAX_AST_DECIMAL)",
          "",
          "---------------"
        ],
        "vyper/utils.py||vyper/utils.py": [
          "File: vyper/utils.py -> vyper/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import decimal",
          "3: import sys",
          "4: import traceback",
          "9: try:",
          "10:     from Crypto.Hash import keccak  # type: ignore",
          "",
          "[Removed Lines]",
          "5: from typing import Dict, List, Union",
          "7: from vyper.exceptions import InvalidLiteral",
          "",
          "[Added Lines]",
          "5: from typing import List, Union",
          "7: from vyper.exceptions import DecimalOverrideException, InvalidLiteral",
          "10: class DecimalContextOverride(decimal.Context):",
          "11:     def __setattr__(self, name, value):",
          "12:         if name == \"prec\":",
          "13:             # CMC 2022-03-27: should we raise a warning instead of an exception?",
          "14:             raise DecimalOverrideException(\"Overriding decimal precision disabled\")",
          "15:         super().__setattr__(name, value)",
          "18: decimal.setcontext(DecimalContextOverride(prec=78))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141: # memory used for system purposes, not for variables",
          "142: class MemoryPositions:",
          "150: # Sizes of different data types. Used to clamp types.",
          "",
          "[Removed Lines]",
          "143:     MAXDECIMAL = 32",
          "144:     MINDECIMAL = 64",
          "145:     FREE_VAR_SPACE = 128",
          "146:     FREE_VAR_SPACE2 = 160",
          "147:     RESERVED_MEMORY = 192",
          "",
          "[Added Lines]",
          "155:     FREE_VAR_SPACE = 0",
          "156:     FREE_VAR_SPACE2 = 32",
          "157:     RESERVED_MEMORY = 64",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153:     MIN_INT128 = -(2 ** 127)",
          "154:     MAX_INT256 = 2 ** 255 - 1",
          "155:     MIN_INT256 = -(2 ** 255)",
          "158:     MAX_UINT8 = 2 ** 8 - 1",
          "159:     MAX_UINT256 = 2 ** 256 - 1",
          "161:     @classmethod",
          "162:     def in_bounds(cls, type_str, value):",
          "163:         # TODO: fix this circular import",
          "166:         assert isinstance(type_str, str)",
          "167:         if type_str == \"decimal\":",
          "172:         return lo <= value <= hi",
          "183: # Otherwise reserved words that are whitelisted for function declarations",
          "184: FUNCTION_WHITELIST = {",
          "185:     \"send\",",
          "",
          "[Removed Lines]",
          "156:     MAXDECIMAL = (2 ** 127 - 1) * DECIMAL_DIVISOR",
          "157:     MINDECIMAL = (-(2 ** 127)) * DECIMAL_DIVISOR",
          "164:         from vyper.codegen.types import parse_integer_typeinfo",
          "168:             return decimal.Decimal(cls.MINDECIMAL) <= value <= decimal.Decimal(cls.MAXDECIMAL)",
          "170:         int_info = parse_integer_typeinfo(type_str)",
          "171:         (lo, hi) = int_bounds(int_info.is_signed, int_info.bits)",
          "175: # Map representing all limits loaded into a contract as part of the initializer",
          "176: # code.",
          "177: LOADED_LIMITS: Dict[int, int] = {",
          "178:     MemoryPositions.MAXDECIMAL: SizeLimits.MAXDECIMAL,",
          "179:     MemoryPositions.MINDECIMAL: SizeLimits.MINDECIMAL,",
          "180: }",
          "",
          "[Added Lines]",
          "166:     MAXDECIMAL = 2 ** 167 - 1  # maxdecimal as EVM value",
          "167:     MINDECIMAL = -(2 ** 167)  # mindecimal as EVM value",
          "168:     # min decimal allowed as Python value",
          "169:     MIN_AST_DECIMAL = -decimal.Decimal(2 ** 167) / DECIMAL_DIVISOR",
          "170:     # max decimal allowed as Python value",
          "171:     MAX_AST_DECIMAL = decimal.Decimal(2 ** 167 - 1) / DECIMAL_DIVISOR",
          "178:         from vyper.codegen.types import parse_decimal_info, parse_integer_typeinfo",
          "182:             info = parse_decimal_info(type_str)",
          "183:         else:",
          "184:             info = parse_integer_typeinfo(type_str)",
          "186:         (lo, hi) = int_bounds(info.is_signed, info.bits)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
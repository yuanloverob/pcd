{
  "cve_id": "CVE-2024-43044",
  "cve_desc": "Jenkins 2.470 and earlier, LTS 2.452.3 and earlier allows agent processes to read arbitrary files from the Jenkins controller file system by using the `ClassLoaderProxy#fetchJar` method in the Remoting library.",
  "repo": "jenkinsci/remoting",
  "patch_hash": "858f3c9af69d4d216b26551ea51dde6e67479bb3",
  "patch_info": {
    "commit_hash": "858f3c9af69d4d216b26551ea51dde6e67479bb3",
    "repo": "jenkinsci/remoting",
    "commit_url": "https://github.com/jenkinsci/remoting/commit/858f3c9af69d4d216b26551ea51dde6e67479bb3",
    "files": [
      "src/main/java/hudson/remoting/Channel.java",
      "src/main/java/hudson/remoting/JarURLValidator.java",
      "src/main/java/hudson/remoting/PreloadJarTask.java",
      "src/main/java/hudson/remoting/PreloadJarTask2.java",
      "src/main/java/hudson/remoting/RemoteClassLoader.java"
    ],
    "message": "[SECURITY-3430]",
    "before_after_code_files": [
      "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
      "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java",
      "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
      "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java",
      "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
    ]
  },
  "patch_diff": {
    "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java": [
      "File: src/main/java/hudson/remoting/Channel.java -> src/main/java/hudson/remoting/Channel.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: import java.net.URL;",
      "44: import java.nio.channels.ClosedChannelException;",
      "45: import java.nio.charset.StandardCharsets;",
      "46: import java.util.Collections;",
      "47: import java.util.Date;",
      "48: import java.util.List;",
      "49: import java.util.Locale;",
      "50: import java.util.Map;",
      "51: import java.util.WeakHashMap;",
      "52: import java.util.concurrent.ConcurrentHashMap;",
      "53: import java.util.concurrent.CopyOnWriteArrayList;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "46: import java.util.Arrays;",
      "49: import java.util.HashSet;",
      "53: import java.util.Set;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "993:         return preloadJar(UserRequest.getClassLoader(classLoaderRef), classesInJar);",
      "994:     }",
      "996:     public boolean preloadJar(ClassLoader local, Class<?>... classesInJar) throws IOException, InterruptedException {",
      "1000:         }",
      "1002:     }",
      "1004:     public boolean preloadJar(ClassLoader local, URL... jars) throws IOException, InterruptedException {",
      "1006:     }",
      "",
      "[Removed Lines]",
      "997:         URL[] jars = new URL[classesInJar.length];",
      "998:         for (int i = 0; i < classesInJar.length; i++) {",
      "999:             jars[i] = Which.jarFile(classesInJar[i]).toURI().toURL();",
      "1001:         return call(new PreloadJarTask(jars, local));",
      "1005:         return call(new PreloadJarTask(jars, local));",
      "",
      "[Added Lines]",
      "999:     @SuppressFBWarnings(",
      "1000:             value = \"DMI_COLLECTION_OF_URLS\",",
      "1001:             justification = \"All URLs point to local files, so no DNS lookup.\")",
      "1003:         Set<URL> jarSet = new HashSet<>();",
      "1004:         for (Class<?> clazz : classesInJar) {",
      "1005:             jarSet.add(Which.jarFile(clazz).toURI().toURL());",
      "1007:         URL[] jars = jarSet.toArray(new URL[0]);",
      "1008:         return preloadJar(local, jars);",
      "1011:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Callers are privileged controller-side code.\")",
      "1013:         byte[][] contents = new byte[jars.length][0];",
      "1015:         List<URL> jarList = Arrays.asList(jars);",
      "1016:         for (int i = 0; i < jarList.size(); i++) {",
      "1017:             final URL url = jarList.get(i);",
      "1018:             jars[i] = url;",
      "1019:             contents[i] = Util.readFully(url.openStream());",
      "1020:         }",
      "1021:         try {",
      "1022:             return call(new PreloadJarTask2(jars, contents, local));",
      "1023:         } catch (IOException ex) {",
      "1024:             if (ex.getCause() instanceof IllegalAccessError) {",
      "1025:                 logger.log(",
      "1026:                         Level.FINE,",
      "1027:                         ex,",
      "1028:                         () -> \"Failed to call PreloadJarTask2 on \" + this + \", retrying with PreloadJarTask\");",
      "1040:                 return call(new PreloadJarTask(jars, local));",
      "1041:             }",
      "1042:             throw ex;",
      "1043:         }",
      "",
      "---------------"
    ],
    "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java": [
      "File: src/main/java/hudson/remoting/JarURLValidator.java -> src/main/java/hudson/remoting/JarURLValidator.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: package hudson.remoting;",
      "3: import java.io.IOException;",
      "4: import java.net.URL;",
      "12: @Deprecated",
      "13: public interface JarURLValidator {",
      "14:     void validate(URL url) throws IOException;",
      "15: }",
      "",
      "---------------"
    ],
    "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java": [
      "File: src/main/java/hudson/remoting/PreloadJarTask.java -> src/main/java/hudson/remoting/PreloadJarTask.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "37: final class PreloadJarTask implements DelegatingCallable<Boolean, IOException> {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "38: @Deprecated",
      "",
      "---------------"
    ],
    "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java": [
      "File: src/main/java/hudson/remoting/PreloadJarTask2.java -> src/main/java/hudson/remoting/PreloadJarTask2.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "24: package hudson.remoting;",
      "26: import edu.umd.cs.findbugs.annotations.CheckForNull;",
      "27: import java.io.IOException;",
      "28: import java.net.URL;",
      "29: import org.jenkinsci.remoting.Role;",
      "30: import org.jenkinsci.remoting.RoleChecker;",
      "40: final class PreloadJarTask2 implements DelegatingCallable<Boolean, IOException> {",
      "44:     private final URL[] jars;",
      "46:     private final byte[][] contents;",
      "52:     @CheckForNull",
      "53:     private transient ClassLoader target = null;",
      "55:     PreloadJarTask2(URL[] jars, byte[][] contents, @CheckForNull ClassLoader target) {",
      "56:         if (jars.length != contents.length) {",
      "57:             throw new IllegalArgumentException(\"Got \" + jars.length + \" jars and \" + contents.length + \" contents\");",
      "58:         }",
      "59:         this.jars = jars;",
      "60:         this.contents = contents;",
      "61:         this.target = target;",
      "62:     }",
      "64:     @Override",
      "65:     public ClassLoader getClassLoader() {",
      "66:         return target;",
      "67:     }",
      "69:     @Override",
      "70:     public Boolean call() throws IOException {",
      "71:         ClassLoader cl = Thread.currentThread().getContextClassLoader();",
      "73:         try {",
      "74:             if (!(cl instanceof RemoteClassLoader)) {",
      "75:                 return false;",
      "76:             }",
      "77:             final RemoteClassLoader rcl = (RemoteClassLoader) cl;",
      "79:             boolean r = false;",
      "80:             for (int i = 0; i < jars.length; i++) {",
      "81:                 r |= rcl.prefetch(jars[i], contents[i]);",
      "82:             }",
      "83:             return r;",
      "84:         } catch (IllegalAccessError iae) {",
      "86:             throw new IOException(iae);",
      "87:         }",
      "88:     }",
      "94:     @Override",
      "95:     public void checkRoles(RoleChecker checker) throws SecurityException {",
      "96:         checker.check(this, Role.UNKNOWN);",
      "97:     }",
      "99:     private static final long serialVersionUID = -773448303394727271L;",
      "100: }",
      "",
      "---------------"
    ],
    "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java": [
      "File: src/main/java/hudson/remoting/RemoteClassLoader.java -> src/main/java/hudson/remoting/RemoteClassLoader.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "687:         synchronized (prefetchedJars) {",
      "688:             if (prefetchedJars.contains(jar)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "689:     @Deprecated",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "698:         }",
      "699:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "716:         synchronized (prefetchedJars) {",
      "717:             if (prefetchedJars.contains(jar)) {",
      "718:                 return false;",
      "719:             }",
      "721:             String p = jar.getPath().replace('\\\\', '/');",
      "722:             p = Util.getBaseName(p);",
      "723:             File localJar = Util.makeResource(p, content);",
      "724:             addURL(localJar.toURI().toURL());",
      "725:             prefetchedJars.add(jar);",
      "726:             return true;",
      "727:         }",
      "728:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "846:     public interface IClassLoader {",
      "847:         byte[] fetchJar(URL url) throws IOException;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "876:         @Deprecated",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "971:         @Override",
      "972:         @SuppressFBWarnings(",
      "973:                 value = \"URLCONNECTION_SSRF_FD\",",
      "975:         public byte[] fetchJar(URL url) throws IOException {",
      "976:             return Util.readFully(url.openStream());",
      "977:         }",
      "",
      "[Removed Lines]",
      "974:                 justification = \"This is only used for managing the jar cache as files.\")",
      "",
      "[Added Lines]",
      "1004:                 justification = \"URL validation is being done through JarURLValidator\")",
      "1006:             final Object o = channel.getProperty(JarURLValidator.class);",
      "1007:             if (o == null) {",
      "1008:                 final boolean disabled = Boolean.getBoolean(Channel.class.getName() + \".DISABLE_JAR_URL_VALIDATOR\");",
      "1009:                 LOGGER.log(Level.FINE, \"Default behavior for URL: \" + url + \" with disabled flag: \" + disabled);",
      "1010:                 if (!disabled) {",
      "1011:                     throw new IOException(",
      "1012:                             \"No hudson.remoting.JarURLValidator has been set for this channel, so all #fetchJar calls are rejected.\"",
      "1013:                                     + \" This is likely a bug in Jenkins.\"",
      "1014:                                     + \" As a workaround, try updating the agent.jar file.\");",
      "1015:                 }",
      "1016:             } else {",
      "1017:                 if (o instanceof JarURLValidator) {",
      "1018:                     ((JarURLValidator) o).validate(url);",
      "1019:                 } else {",
      "1020:                     throw new IOException(\"Unexpected channel property hudson.remoting.JarURLValidator value: \" + o);",
      "1021:                 }",
      "1022:             }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3ea58fc6d3356698eb8b14210135149b8f1e6018",
      "candidate_info": {
        "commit_hash": "3ea58fc6d3356698eb8b14210135149b8f1e6018",
        "repo": "jenkinsci/remoting",
        "commit_url": "https://github.com/jenkinsci/remoting/commit/3ea58fc6d3356698eb8b14210135149b8f1e6018",
        "files": [
          "pom.xml",
          "src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java",
          "src/main/java/hudson/remoting/AsyncFutureImpl.java",
          "src/main/java/hudson/remoting/Asynchronous.java",
          "src/main/java/hudson/remoting/AtmostOneThreadExecutor.java",
          "src/main/java/hudson/remoting/Base64.java",
          "src/main/java/hudson/remoting/BinarySafeStream.java",
          "src/main/java/hudson/remoting/Callable.java",
          "src/main/java/hudson/remoting/CallableDecoratorAdapter.java",
          "src/main/java/hudson/remoting/CallableDecoratorList.java",
          "src/main/java/hudson/remoting/Capability.java",
          "src/main/java/hudson/remoting/Channel.java",
          "src/main/java/hudson/remoting/ChannelBuilder.java",
          "src/main/java/hudson/remoting/ChannelClosedException.java",
          "src/main/java/hudson/remoting/Checksum.java",
          "src/main/java/hudson/remoting/ChunkHeader.java",
          "src/main/java/hudson/remoting/ChunkedCommandTransport.java",
          "src/main/java/hudson/remoting/ChunkedInputStream.java",
          "src/main/java/hudson/remoting/ChunkedOutputStream.java",
          "src/main/java/hudson/remoting/ClassFilter.java",
          "src/main/java/hudson/remoting/ClassLoaderHolder.java",
          "src/main/java/hudson/remoting/ClassicCommandTransport.java",
          "src/main/java/hudson/remoting/Command.java",
          "src/main/java/hudson/remoting/CommandTransport.java",
          "src/main/java/hudson/remoting/DaemonThreadFactory.java",
          "src/main/java/hudson/remoting/DelegatingCallable.java",
          "src/main/java/hudson/remoting/DelegatingExecutorService.java",
          "src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java",
          "src/main/java/hudson/remoting/DumbClassLoaderBridge.java",
          "src/main/java/hudson/remoting/Engine.java",
          "src/main/java/hudson/remoting/EngineListener.java",
          "src/main/java/hudson/remoting/EngineListenerAdapter.java",
          "src/main/java/hudson/remoting/EngineListenerSplitter.java",
          "src/main/java/hudson/remoting/ExportTable.java",
          "src/main/java/hudson/remoting/FastPipedInputStream.java",
          "src/main/java/hudson/remoting/FastPipedOutputStream.java",
          "src/main/java/hudson/remoting/FileSystemJarCache.java",
          "src/main/java/hudson/remoting/FlightRecorderInputStream.java",
          "src/main/java/hudson/remoting/Future.java",
          "src/main/java/hudson/remoting/FutureAdapter.java",
          "src/main/java/hudson/remoting/HexDump.java",
          "src/main/java/hudson/remoting/IChannel.java",
          "src/main/java/hudson/remoting/IReadResolve.java",
          "src/main/java/hudson/remoting/ImportedClassLoaderTable.java",
          "src/main/java/hudson/remoting/InitializeJarCacheMain.java",
          "src/main/java/hudson/remoting/InterceptingExecutorService.java",
          "src/main/java/hudson/remoting/JarCache.java",
          "src/main/java/hudson/remoting/JarCacheSupport.java",
          "src/main/java/hudson/remoting/JarLoader.java",
          "src/main/java/hudson/remoting/JarLoaderImpl.java",
          "src/main/java/hudson/remoting/Launcher.java",
          "src/main/java/hudson/remoting/LocalChannel.java",
          "src/main/java/hudson/remoting/MimicException.java",
          "src/main/java/hudson/remoting/MultiClassLoaderSerializer.java",
          "src/main/java/hudson/remoting/NoProxyEvaluator.java",
          "src/main/java/hudson/remoting/ObjectInputStreamEx.java",
          "src/main/java/hudson/remoting/PingThread.java",
          "src/main/java/hudson/remoting/Pipe.java",
          "src/main/java/hudson/remoting/PipeWindow.java",
          "src/main/java/hudson/remoting/PipeWriter.java",
          "src/main/java/hudson/remoting/PreloadJarTask.java",
          "src/main/java/hudson/remoting/ProxyException.java",
          "src/main/java/hudson/remoting/ProxyInputStream.java",
          "src/main/java/hudson/remoting/ProxyOutputStream.java",
          "src/main/java/hudson/remoting/ProxyWriter.java",
          "src/main/java/hudson/remoting/RemoteClassLoader.java",
          "src/main/java/hudson/remoting/RemoteInputStream.java",
          "src/main/java/hudson/remoting/RemoteInvocationHandler.java",
          "src/main/java/hudson/remoting/RemoteOutputStream.java",
          "src/main/java/hudson/remoting/RemoteWriter.java",
          "src/main/java/hudson/remoting/Request.java",
          "src/main/java/hudson/remoting/RequestAbortedException.java",
          "src/main/java/hudson/remoting/ResourceImageBoth.java",
          "src/main/java/hudson/remoting/ResourceImageDirect.java",
          "src/main/java/hudson/remoting/ResourceImageInJar.java",
          "src/main/java/hudson/remoting/ResourceImageRef.java",
          "src/main/java/hudson/remoting/Response.java",
          "src/main/java/hudson/remoting/SingleLaneExecutorService.java",
          "src/main/java/hudson/remoting/SocketChannelStream.java",
          "src/main/java/hudson/remoting/SocketInputStream.java",
          "src/main/java/hudson/remoting/SocketOutputStream.java",
          "src/main/java/hudson/remoting/StandardOutputStream.java",
          "src/main/java/hudson/remoting/SynchronousCommandTransport.java",
          "src/main/java/hudson/remoting/SynchronousExecutorService.java",
          "src/main/java/hudson/remoting/TeeOutputStream.java",
          "src/main/java/hudson/remoting/URLDeserializationHelper.java",
          "src/main/java/hudson/remoting/URLish.java",
          "src/main/java/hudson/remoting/UnexportCommand.java",
          "src/main/java/hudson/remoting/UserRequest.java",
          "src/main/java/hudson/remoting/Util.java",
          "src/main/java/hudson/remoting/VirtualChannel.java",
          "src/main/java/hudson/remoting/Which.java",
          "src/main/java/hudson/remoting/forward/CopyThread.java",
          "src/main/java/hudson/remoting/forward/Forwarder.java",
          "src/main/java/hudson/remoting/forward/ForwarderFactory.java",
          "src/main/java/hudson/remoting/forward/PortForwarder.java",
          "src/main/java/hudson/remoting/jnlp/package-info.java",
          "src/main/java/hudson/remoting/package-info.java",
          "src/main/java/org/jenkinsci/remoting/CallableDecorator.java",
          "src/main/java/org/jenkinsci/remoting/ChannelStateException.java",
          "src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java",
          "src/main/java/org/jenkinsci/remoting/Role.java",
          "src/main/java/org/jenkinsci/remoting/RoleChecker.java",
          "src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java",
          "src/main/java/org/jenkinsci/remoting/engine/HostPort.java",
          "src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java",
          "src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java",
          "src/main/java/org/jenkinsci/remoting/nio/Closeables.java",
          "src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java",
          "src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java",
          "src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java",
          "src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java",
          "src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java",
          "src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/IOHub.java",
          "src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java",
          "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java",
          "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java",
          "src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java",
          "src/main/java/org/jenkinsci/remoting/util/DurationStyle.java",
          "src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java",
          "src/main/java/org/jenkinsci/remoting/util/IOUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/SettableFuture.java",
          "src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/VersionNumber.java",
          "src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java",
          "src/test/java/JarCertDump.java",
          "src/test/java/OISInterception.java",
          "src/test/java/hudson/remoting/AbstractNioChannelRunner.java",
          "src/test/java/hudson/remoting/BinarySafeStreamTest.java",
          "src/test/java/hudson/remoting/CallableBase.java",
          "src/test/java/hudson/remoting/ChannelFilterTest.java",
          "src/test/java/hudson/remoting/ChannelRunner.java",
          "src/test/java/hudson/remoting/ChannelRunners.java",
          "src/test/java/hudson/remoting/ChannelTest.java",
          "src/test/java/hudson/remoting/ChecksumTest.java",
          "src/test/java/hudson/remoting/ChunkedInputStreamTest.java",
          "src/test/java/hudson/remoting/ClassFilterTest.java",
          "src/test/java/hudson/remoting/ClassRemoting2Test.java",
          "src/test/java/hudson/remoting/ClassRemotingTest.java",
          "src/test/java/hudson/remoting/Copier.java",
          "src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java",
          "src/test/java/hudson/remoting/DefaultClassFilterTest.java",
          "src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java",
          "src/test/java/hudson/remoting/DummyClassLoader.java",
          "src/test/java/hudson/remoting/DummyClassLoaderTest.java",
          "src/test/java/hudson/remoting/EngineTest.java",
          "src/test/java/hudson/remoting/FileSystemJarCacheTest.java",
          "src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java",
          "src/test/java/hudson/remoting/ForkEBCDICRunner.java",
          "src/test/java/hudson/remoting/ForkRunner.java",
          "src/test/java/hudson/remoting/HexDumpTest.java",
          "src/test/java/hudson/remoting/InProcessCompatibilityRunner.java",
          "src/test/java/hudson/remoting/InProcessRunner.java",
          "src/test/java/hudson/remoting/LauncherTest.java",
          "src/test/java/hudson/remoting/NioPipeRunner.java",
          "src/test/java/hudson/remoting/NioSocketRunner.java",
          "src/test/java/hudson/remoting/NoProxyEvaluatorTest.java",
          "src/test/java/hudson/remoting/NonSerializableExceptionTest.java",
          "src/test/java/hudson/remoting/PipeTest.java",
          "src/test/java/hudson/remoting/PipeWriterTest.java",
          "src/test/java/hudson/remoting/PipeWriterTestChecker.java",
          "src/test/java/hudson/remoting/PrefetchTest.java",
          "src/test/java/hudson/remoting/PrefetchingTest.java",
          "src/test/java/hudson/remoting/ProxyExceptionTest.java",
          "src/test/java/hudson/remoting/ProxyWriterTest.java",
          "src/test/java/hudson/remoting/RegExpBenchmark.java",
          "src/test/java/hudson/remoting/RemoteInputStreamTest.java",
          "src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java",
          "src/test/java/hudson/remoting/SimpleTest.java",
          "src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java",
          "src/test/java/hudson/remoting/TestCallable.java",
          "src/test/java/hudson/remoting/TestLinkage.java",
          "src/test/java/hudson/remoting/TestStaticGetResources.java",
          "src/test/java/hudson/remoting/TestStaticResourceReference.java",
          "src/test/java/hudson/remoting/TrafficAnalyzer.java",
          "src/test/java/hudson/remoting/URLDeserializatinHelperTest.java",
          "src/test/java/hudson/remoting/pipe/RandomWorkload.java",
          "src/test/java/hudson/remoting/pipe/Workload.java",
          "src/test/java/hudson/remoting/throughput/DumbReceiver.java",
          "src/test/java/hudson/remoting/throughput/DumbSender.java",
          "src/test/java/hudson/remoting/throughput/Receiver.java",
          "src/test/java/hudson/remoting/throughput/Sender.java",
          "src/test/java/hudson/remoting/util/GCTask.java",
          "src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java",
          "src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java",
          "src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java",
          "src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java",
          "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java",
          "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java",
          "src/test/java/org/jenkinsci/remoting/nio/Main.java",
          "src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java",
          "src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/Repeat.java",
          "src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java",
          "src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java",
          "src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java",
          "src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java"
        ],
        "message": "Format repository with Spotless (#751)",
        "before_after_code_files": [
          "src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java||src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java",
          "src/main/java/hudson/remoting/AsyncFutureImpl.java||src/main/java/hudson/remoting/AsyncFutureImpl.java",
          "src/main/java/hudson/remoting/Asynchronous.java||src/main/java/hudson/remoting/Asynchronous.java",
          "src/main/java/hudson/remoting/AtmostOneThreadExecutor.java||src/main/java/hudson/remoting/AtmostOneThreadExecutor.java",
          "src/main/java/hudson/remoting/Base64.java||src/main/java/hudson/remoting/Base64.java",
          "src/main/java/hudson/remoting/BinarySafeStream.java||src/main/java/hudson/remoting/BinarySafeStream.java",
          "src/main/java/hudson/remoting/Callable.java||src/main/java/hudson/remoting/Callable.java",
          "src/main/java/hudson/remoting/CallableDecoratorAdapter.java||src/main/java/hudson/remoting/CallableDecoratorAdapter.java",
          "src/main/java/hudson/remoting/CallableDecoratorList.java||src/main/java/hudson/remoting/CallableDecoratorList.java",
          "src/main/java/hudson/remoting/Capability.java||src/main/java/hudson/remoting/Capability.java",
          "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
          "src/main/java/hudson/remoting/ChannelBuilder.java||src/main/java/hudson/remoting/ChannelBuilder.java",
          "src/main/java/hudson/remoting/ChannelClosedException.java||src/main/java/hudson/remoting/ChannelClosedException.java",
          "src/main/java/hudson/remoting/Checksum.java||src/main/java/hudson/remoting/Checksum.java",
          "src/main/java/hudson/remoting/ChunkHeader.java||src/main/java/hudson/remoting/ChunkHeader.java",
          "src/main/java/hudson/remoting/ChunkedCommandTransport.java||src/main/java/hudson/remoting/ChunkedCommandTransport.java",
          "src/main/java/hudson/remoting/ChunkedInputStream.java||src/main/java/hudson/remoting/ChunkedInputStream.java",
          "src/main/java/hudson/remoting/ChunkedOutputStream.java||src/main/java/hudson/remoting/ChunkedOutputStream.java",
          "src/main/java/hudson/remoting/ClassFilter.java||src/main/java/hudson/remoting/ClassFilter.java",
          "src/main/java/hudson/remoting/ClassLoaderHolder.java||src/main/java/hudson/remoting/ClassLoaderHolder.java",
          "src/main/java/hudson/remoting/ClassicCommandTransport.java||src/main/java/hudson/remoting/ClassicCommandTransport.java",
          "src/main/java/hudson/remoting/Command.java||src/main/java/hudson/remoting/Command.java",
          "src/main/java/hudson/remoting/CommandTransport.java||src/main/java/hudson/remoting/CommandTransport.java",
          "src/main/java/hudson/remoting/DaemonThreadFactory.java||src/main/java/hudson/remoting/DaemonThreadFactory.java",
          "src/main/java/hudson/remoting/DelegatingCallable.java||src/main/java/hudson/remoting/DelegatingCallable.java",
          "src/main/java/hudson/remoting/DelegatingExecutorService.java||src/main/java/hudson/remoting/DelegatingExecutorService.java",
          "src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java||src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java",
          "src/main/java/hudson/remoting/DumbClassLoaderBridge.java||src/main/java/hudson/remoting/DumbClassLoaderBridge.java",
          "src/main/java/hudson/remoting/Engine.java||src/main/java/hudson/remoting/Engine.java",
          "src/main/java/hudson/remoting/EngineListener.java||src/main/java/hudson/remoting/EngineListener.java",
          "src/main/java/hudson/remoting/EngineListenerAdapter.java||src/main/java/hudson/remoting/EngineListenerAdapter.java",
          "src/main/java/hudson/remoting/EngineListenerSplitter.java||src/main/java/hudson/remoting/EngineListenerSplitter.java",
          "src/main/java/hudson/remoting/ExportTable.java||src/main/java/hudson/remoting/ExportTable.java",
          "src/main/java/hudson/remoting/FastPipedInputStream.java||src/main/java/hudson/remoting/FastPipedInputStream.java",
          "src/main/java/hudson/remoting/FastPipedOutputStream.java||src/main/java/hudson/remoting/FastPipedOutputStream.java",
          "src/main/java/hudson/remoting/FileSystemJarCache.java||src/main/java/hudson/remoting/FileSystemJarCache.java",
          "src/main/java/hudson/remoting/FlightRecorderInputStream.java||src/main/java/hudson/remoting/FlightRecorderInputStream.java",
          "src/main/java/hudson/remoting/Future.java||src/main/java/hudson/remoting/Future.java",
          "src/main/java/hudson/remoting/FutureAdapter.java||src/main/java/hudson/remoting/FutureAdapter.java",
          "src/main/java/hudson/remoting/HexDump.java||src/main/java/hudson/remoting/HexDump.java",
          "src/main/java/hudson/remoting/IChannel.java||src/main/java/hudson/remoting/IChannel.java",
          "src/main/java/hudson/remoting/IReadResolve.java||src/main/java/hudson/remoting/IReadResolve.java",
          "src/main/java/hudson/remoting/ImportedClassLoaderTable.java||src/main/java/hudson/remoting/ImportedClassLoaderTable.java",
          "src/main/java/hudson/remoting/InitializeJarCacheMain.java||src/main/java/hudson/remoting/InitializeJarCacheMain.java",
          "src/main/java/hudson/remoting/InterceptingExecutorService.java||src/main/java/hudson/remoting/InterceptingExecutorService.java",
          "src/main/java/hudson/remoting/JarCache.java||src/main/java/hudson/remoting/JarCache.java",
          "src/main/java/hudson/remoting/JarCacheSupport.java||src/main/java/hudson/remoting/JarCacheSupport.java",
          "src/main/java/hudson/remoting/JarLoader.java||src/main/java/hudson/remoting/JarLoader.java",
          "src/main/java/hudson/remoting/JarLoaderImpl.java||src/main/java/hudson/remoting/JarLoaderImpl.java",
          "src/main/java/hudson/remoting/Launcher.java||src/main/java/hudson/remoting/Launcher.java",
          "src/main/java/hudson/remoting/LocalChannel.java||src/main/java/hudson/remoting/LocalChannel.java",
          "src/main/java/hudson/remoting/MimicException.java||src/main/java/hudson/remoting/MimicException.java",
          "src/main/java/hudson/remoting/MultiClassLoaderSerializer.java||src/main/java/hudson/remoting/MultiClassLoaderSerializer.java",
          "src/main/java/hudson/remoting/NoProxyEvaluator.java||src/main/java/hudson/remoting/NoProxyEvaluator.java",
          "src/main/java/hudson/remoting/ObjectInputStreamEx.java||src/main/java/hudson/remoting/ObjectInputStreamEx.java",
          "src/main/java/hudson/remoting/PingThread.java||src/main/java/hudson/remoting/PingThread.java",
          "src/main/java/hudson/remoting/Pipe.java||src/main/java/hudson/remoting/Pipe.java",
          "src/main/java/hudson/remoting/PipeWindow.java||src/main/java/hudson/remoting/PipeWindow.java",
          "src/main/java/hudson/remoting/PipeWriter.java||src/main/java/hudson/remoting/PipeWriter.java",
          "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
          "src/main/java/hudson/remoting/ProxyException.java||src/main/java/hudson/remoting/ProxyException.java",
          "src/main/java/hudson/remoting/ProxyInputStream.java||src/main/java/hudson/remoting/ProxyInputStream.java",
          "src/main/java/hudson/remoting/ProxyOutputStream.java||src/main/java/hudson/remoting/ProxyOutputStream.java",
          "src/main/java/hudson/remoting/ProxyWriter.java||src/main/java/hudson/remoting/ProxyWriter.java",
          "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java",
          "src/main/java/hudson/remoting/RemoteInputStream.java||src/main/java/hudson/remoting/RemoteInputStream.java",
          "src/main/java/hudson/remoting/RemoteInvocationHandler.java||src/main/java/hudson/remoting/RemoteInvocationHandler.java",
          "src/main/java/hudson/remoting/RemoteOutputStream.java||src/main/java/hudson/remoting/RemoteOutputStream.java",
          "src/main/java/hudson/remoting/RemoteWriter.java||src/main/java/hudson/remoting/RemoteWriter.java",
          "src/main/java/hudson/remoting/Request.java||src/main/java/hudson/remoting/Request.java",
          "src/main/java/hudson/remoting/RequestAbortedException.java||src/main/java/hudson/remoting/RequestAbortedException.java",
          "src/main/java/hudson/remoting/ResourceImageBoth.java||src/main/java/hudson/remoting/ResourceImageBoth.java",
          "src/main/java/hudson/remoting/ResourceImageDirect.java||src/main/java/hudson/remoting/ResourceImageDirect.java",
          "src/main/java/hudson/remoting/ResourceImageInJar.java||src/main/java/hudson/remoting/ResourceImageInJar.java",
          "src/main/java/hudson/remoting/ResourceImageRef.java||src/main/java/hudson/remoting/ResourceImageRef.java",
          "src/main/java/hudson/remoting/Response.java||src/main/java/hudson/remoting/Response.java",
          "src/main/java/hudson/remoting/SingleLaneExecutorService.java||src/main/java/hudson/remoting/SingleLaneExecutorService.java",
          "src/main/java/hudson/remoting/SocketChannelStream.java||src/main/java/hudson/remoting/SocketChannelStream.java",
          "src/main/java/hudson/remoting/SocketInputStream.java||src/main/java/hudson/remoting/SocketInputStream.java",
          "src/main/java/hudson/remoting/SocketOutputStream.java||src/main/java/hudson/remoting/SocketOutputStream.java",
          "src/main/java/hudson/remoting/StandardOutputStream.java||src/main/java/hudson/remoting/StandardOutputStream.java",
          "src/main/java/hudson/remoting/SynchronousCommandTransport.java||src/main/java/hudson/remoting/SynchronousCommandTransport.java",
          "src/main/java/hudson/remoting/SynchronousExecutorService.java||src/main/java/hudson/remoting/SynchronousExecutorService.java",
          "src/main/java/hudson/remoting/TeeOutputStream.java||src/main/java/hudson/remoting/TeeOutputStream.java",
          "src/main/java/hudson/remoting/URLDeserializationHelper.java||src/main/java/hudson/remoting/URLDeserializationHelper.java",
          "src/main/java/hudson/remoting/URLish.java||src/main/java/hudson/remoting/URLish.java",
          "src/main/java/hudson/remoting/UnexportCommand.java||src/main/java/hudson/remoting/UnexportCommand.java",
          "src/main/java/hudson/remoting/UserRequest.java||src/main/java/hudson/remoting/UserRequest.java",
          "src/main/java/hudson/remoting/Util.java||src/main/java/hudson/remoting/Util.java",
          "src/main/java/hudson/remoting/VirtualChannel.java||src/main/java/hudson/remoting/VirtualChannel.java",
          "src/main/java/hudson/remoting/Which.java||src/main/java/hudson/remoting/Which.java",
          "src/main/java/hudson/remoting/forward/CopyThread.java||src/main/java/hudson/remoting/forward/CopyThread.java",
          "src/main/java/hudson/remoting/forward/Forwarder.java||src/main/java/hudson/remoting/forward/Forwarder.java",
          "src/main/java/hudson/remoting/forward/ForwarderFactory.java||src/main/java/hudson/remoting/forward/ForwarderFactory.java",
          "src/main/java/hudson/remoting/forward/PortForwarder.java||src/main/java/hudson/remoting/forward/PortForwarder.java",
          "src/main/java/hudson/remoting/jnlp/package-info.java||src/main/java/hudson/remoting/jnlp/package-info.java",
          "src/main/java/hudson/remoting/package-info.java||src/main/java/hudson/remoting/package-info.java",
          "src/main/java/org/jenkinsci/remoting/CallableDecorator.java||src/main/java/org/jenkinsci/remoting/CallableDecorator.java",
          "src/main/java/org/jenkinsci/remoting/ChannelStateException.java||src/main/java/org/jenkinsci/remoting/ChannelStateException.java",
          "src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java||src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java",
          "src/main/java/org/jenkinsci/remoting/Role.java||src/main/java/org/jenkinsci/remoting/Role.java",
          "src/main/java/org/jenkinsci/remoting/RoleChecker.java||src/main/java/org/jenkinsci/remoting/RoleChecker.java",
          "src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java||src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java",
          "src/main/java/org/jenkinsci/remoting/engine/HostPort.java||src/main/java/org/jenkinsci/remoting/engine/HostPort.java",
          "src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java||src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java||src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java||src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java||src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java",
          "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java",
          "src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java||src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java",
          "src/main/java/org/jenkinsci/remoting/nio/Closeables.java||src/main/java/org/jenkinsci/remoting/nio/Closeables.java",
          "src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java||src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java",
          "src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java||src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java",
          "src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java||src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java",
          "src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java||src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java",
          "src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java||src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java",
          "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java",
          "src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java||src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/IOHub.java||src/main/java/org/jenkinsci/remoting/protocol/IOHub.java",
          "src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java||src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java",
          "src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java",
          "src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java||src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java",
          "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java||src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java",
          "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java||src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java",
          "src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java||src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java",
          "src/main/java/org/jenkinsci/remoting/util/DurationStyle.java||src/main/java/org/jenkinsci/remoting/util/DurationStyle.java",
          "src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java||src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java||src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java",
          "src/main/java/org/jenkinsci/remoting/util/IOUtils.java||src/main/java/org/jenkinsci/remoting/util/IOUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/SettableFuture.java||src/main/java/org/jenkinsci/remoting/util/SettableFuture.java",
          "src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java||src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java",
          "src/main/java/org/jenkinsci/remoting/util/VersionNumber.java||src/main/java/org/jenkinsci/remoting/util/VersionNumber.java",
          "src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java||src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java",
          "src/test/java/JarCertDump.java||src/test/java/JarCertDump.java",
          "src/test/java/OISInterception.java||src/test/java/OISInterception.java",
          "src/test/java/hudson/remoting/AbstractNioChannelRunner.java||src/test/java/hudson/remoting/AbstractNioChannelRunner.java",
          "src/test/java/hudson/remoting/BinarySafeStreamTest.java||src/test/java/hudson/remoting/BinarySafeStreamTest.java",
          "src/test/java/hudson/remoting/CallableBase.java||src/test/java/hudson/remoting/CallableBase.java",
          "src/test/java/hudson/remoting/ChannelFilterTest.java||src/test/java/hudson/remoting/ChannelFilterTest.java",
          "src/test/java/hudson/remoting/ChannelRunner.java||src/test/java/hudson/remoting/ChannelRunner.java",
          "src/test/java/hudson/remoting/ChannelRunners.java||src/test/java/hudson/remoting/ChannelRunners.java",
          "src/test/java/hudson/remoting/ChannelTest.java||src/test/java/hudson/remoting/ChannelTest.java",
          "src/test/java/hudson/remoting/ChecksumTest.java||src/test/java/hudson/remoting/ChecksumTest.java",
          "src/test/java/hudson/remoting/ChunkedInputStreamTest.java||src/test/java/hudson/remoting/ChunkedInputStreamTest.java",
          "src/test/java/hudson/remoting/ClassFilterTest.java||src/test/java/hudson/remoting/ClassFilterTest.java",
          "src/test/java/hudson/remoting/ClassRemoting2Test.java||src/test/java/hudson/remoting/ClassRemoting2Test.java",
          "src/test/java/hudson/remoting/ClassRemotingTest.java||src/test/java/hudson/remoting/ClassRemotingTest.java",
          "src/test/java/hudson/remoting/Copier.java||src/test/java/hudson/remoting/Copier.java",
          "src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java||src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java",
          "src/test/java/hudson/remoting/DefaultClassFilterTest.java||src/test/java/hudson/remoting/DefaultClassFilterTest.java",
          "src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java||src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java",
          "src/test/java/hudson/remoting/DummyClassLoader.java||src/test/java/hudson/remoting/DummyClassLoader.java",
          "src/test/java/hudson/remoting/DummyClassLoaderTest.java||src/test/java/hudson/remoting/DummyClassLoaderTest.java",
          "src/test/java/hudson/remoting/EngineTest.java||src/test/java/hudson/remoting/EngineTest.java",
          "src/test/java/hudson/remoting/FileSystemJarCacheTest.java||src/test/java/hudson/remoting/FileSystemJarCacheTest.java",
          "src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java||src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java",
          "src/test/java/hudson/remoting/ForkEBCDICRunner.java||src/test/java/hudson/remoting/ForkEBCDICRunner.java",
          "src/test/java/hudson/remoting/ForkRunner.java||src/test/java/hudson/remoting/ForkRunner.java",
          "src/test/java/hudson/remoting/HexDumpTest.java||src/test/java/hudson/remoting/HexDumpTest.java",
          "src/test/java/hudson/remoting/InProcessCompatibilityRunner.java||src/test/java/hudson/remoting/InProcessCompatibilityRunner.java",
          "src/test/java/hudson/remoting/InProcessRunner.java||src/test/java/hudson/remoting/InProcessRunner.java",
          "src/test/java/hudson/remoting/LauncherTest.java||src/test/java/hudson/remoting/LauncherTest.java",
          "src/test/java/hudson/remoting/NioPipeRunner.java||src/test/java/hudson/remoting/NioPipeRunner.java",
          "src/test/java/hudson/remoting/NioSocketRunner.java||src/test/java/hudson/remoting/NioSocketRunner.java",
          "src/test/java/hudson/remoting/NoProxyEvaluatorTest.java||src/test/java/hudson/remoting/NoProxyEvaluatorTest.java",
          "src/test/java/hudson/remoting/NonSerializableExceptionTest.java||src/test/java/hudson/remoting/NonSerializableExceptionTest.java",
          "src/test/java/hudson/remoting/PipeTest.java||src/test/java/hudson/remoting/PipeTest.java",
          "src/test/java/hudson/remoting/PipeWriterTest.java||src/test/java/hudson/remoting/PipeWriterTest.java",
          "src/test/java/hudson/remoting/PipeWriterTestChecker.java||src/test/java/hudson/remoting/PipeWriterTestChecker.java",
          "src/test/java/hudson/remoting/PrefetchTest.java||src/test/java/hudson/remoting/PrefetchTest.java",
          "src/test/java/hudson/remoting/PrefetchingTest.java||src/test/java/hudson/remoting/PrefetchingTest.java",
          "src/test/java/hudson/remoting/ProxyExceptionTest.java||src/test/java/hudson/remoting/ProxyExceptionTest.java",
          "src/test/java/hudson/remoting/ProxyWriterTest.java||src/test/java/hudson/remoting/ProxyWriterTest.java",
          "src/test/java/hudson/remoting/RegExpBenchmark.java||src/test/java/hudson/remoting/RegExpBenchmark.java",
          "src/test/java/hudson/remoting/RemoteInputStreamTest.java||src/test/java/hudson/remoting/RemoteInputStreamTest.java",
          "src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java||src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java",
          "src/test/java/hudson/remoting/SimpleTest.java||src/test/java/hudson/remoting/SimpleTest.java",
          "src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java||src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java",
          "src/test/java/hudson/remoting/TestCallable.java||src/test/java/hudson/remoting/TestCallable.java",
          "src/test/java/hudson/remoting/TestLinkage.java||src/test/java/hudson/remoting/TestLinkage.java",
          "src/test/java/hudson/remoting/TestStaticGetResources.java||src/test/java/hudson/remoting/TestStaticGetResources.java",
          "src/test/java/hudson/remoting/TestStaticResourceReference.java||src/test/java/hudson/remoting/TestStaticResourceReference.java",
          "src/test/java/hudson/remoting/TrafficAnalyzer.java||src/test/java/hudson/remoting/TrafficAnalyzer.java",
          "src/test/java/hudson/remoting/URLDeserializatinHelperTest.java||src/test/java/hudson/remoting/URLDeserializatinHelperTest.java",
          "src/test/java/hudson/remoting/pipe/RandomWorkload.java||src/test/java/hudson/remoting/pipe/RandomWorkload.java",
          "src/test/java/hudson/remoting/pipe/Workload.java||src/test/java/hudson/remoting/pipe/Workload.java",
          "src/test/java/hudson/remoting/throughput/DumbReceiver.java||src/test/java/hudson/remoting/throughput/DumbReceiver.java",
          "src/test/java/hudson/remoting/throughput/DumbSender.java||src/test/java/hudson/remoting/throughput/DumbSender.java",
          "src/test/java/hudson/remoting/throughput/Receiver.java||src/test/java/hudson/remoting/throughput/Receiver.java",
          "src/test/java/hudson/remoting/throughput/Sender.java||src/test/java/hudson/remoting/throughput/Sender.java",
          "src/test/java/hudson/remoting/util/GCTask.java||src/test/java/hudson/remoting/util/GCTask.java",
          "src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java||src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java",
          "src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java||src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java",
          "src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java||src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java",
          "src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java||src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java",
          "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java||src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java",
          "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java||src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java||src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java",
          "src/test/java/org/jenkinsci/remoting/nio/Main.java||src/test/java/org/jenkinsci/remoting/nio/Main.java",
          "src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java||src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java",
          "src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java||src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java",
          "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java||src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java||src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java||src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java||src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java||src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java",
          "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/Repeat.java||src/test/java/org/jenkinsci/remoting/protocol/Repeat.java",
          "src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java||src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java||src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java||src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java",
          "src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java||src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java",
          "src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java||src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java",
          "src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java",
          "src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java||src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java",
          "src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java||src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
            "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
            "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
          ],
          "candidate": [
            "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
            "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
            "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java||src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java": [
          "File: src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java -> src/main/java/hudson/remoting/AbstractByteBufferCommandTransport.java"
        ],
        "src/main/java/hudson/remoting/AsyncFutureImpl.java||src/main/java/hudson/remoting/AsyncFutureImpl.java": [
          "File: src/main/java/hudson/remoting/AsyncFutureImpl.java -> src/main/java/hudson/remoting/AsyncFutureImpl.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:     @Override",
          "76:     public synchronized V get() throws InterruptedException, ExecutionException {",
          "78:             wait();",
          "80:             throw new ExecutionException(problem);",
          "82:             throw new CancellationException();",
          "83:         return value;",
          "84:     }",
          "86:     @Override",
          "87:     @CheckForNull",
          "90:         long endWaitTime = System.nanoTime() + unit.toNanos(timeout);",
          "91:         while (!completed) {",
          "",
          "[Removed Lines]",
          "77:         while(!completed)",
          "79:         if(problem!=null)",
          "81:         if(cancelled)",
          "88:     public synchronized V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "79:         while (!completed) {",
          "81:         }",
          "82:         if (problem != null) {",
          "84:         }",
          "85:         if (cancelled) {",
          "87:         }",
          "93:     public synchronized V get(long timeout, TimeUnit unit)",
          "94:             throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:                 break;",
          "95:             }",
          "98:         }",
          "101:             throw new TimeoutException();",
          "103:             throw new CancellationException();",
          "108:         return get();",
          "",
          "[Removed Lines]",
          "97:             wait(timeToWait / 1000000, (int)(timeToWait % 1000000));",
          "100:         if(!completed)",
          "102:         if(cancelled)",
          "",
          "[Added Lines]",
          "103:             wait(timeToWait / 1000000, (int) (timeToWait % 1000000));",
          "106:         if (!completed) {",
          "108:         }",
          "109:         if (cancelled) {",
          "111:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Asynchronous.java||src/main/java/hudson/remoting/Asynchronous.java": [
          "File: src/main/java/hudson/remoting/Asynchronous.java -> src/main/java/hudson/remoting/Asynchronous.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: @Documented",
          "40: @Target(ElementType.METHOD)",
          "41: @Retention(RetentionPolicy.RUNTIME)",
          "",
          "[Removed Lines]",
          "42: public @interface Asynchronous {",
          "43: }",
          "",
          "[Added Lines]",
          "42: public @interface Asynchronous {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/AtmostOneThreadExecutor.java||src/main/java/hudson/remoting/AtmostOneThreadExecutor.java": [
          "File: src/main/java/hudson/remoting/AtmostOneThreadExecutor.java -> src/main/java/hudson/remoting/AtmostOneThreadExecutor.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:     public void shutdown() {",
          "45:         synchronized (q) {",
          "46:             shutdown = true;",
          "48:                 worker.interrupt();",
          "49:         }",
          "50:     }",
          "",
          "[Removed Lines]",
          "47:             if (isAlive())",
          "",
          "[Added Lines]",
          "47:             if (isAlive()) {",
          "49:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:     private boolean isAlive() {",
          "57:     }",
          "59:     @NonNull",
          "",
          "[Removed Lines]",
          "56:         return worker!=null && worker.isAlive();",
          "",
          "[Added Lines]",
          "57:         return worker != null && worker.isAlive();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:             while (true) {",
          "112:                 Runnable task;",
          "113:                 synchronized (q) {",
          "115:                         worker = null;",
          "116:                         return;",
          "117:                     }",
          "",
          "[Removed Lines]",
          "114:                     if (q.isEmpty()) {// no more work",
          "",
          "[Added Lines]",
          "115:                     if (q.isEmpty()) { // no more work",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Base64.java||src/main/java/hudson/remoting/Base64.java": [
          "File: src/main/java/hudson/remoting/Base64.java -> src/main/java/hudson/remoting/Base64.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: @Deprecated",
          "",
          "[Removed Lines]",
          "40: public final class  Base64 {",
          "",
          "[Added Lines]",
          "40: public final class Base64 {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:     @Nullable",
          "49:     public static String encode(byte[] binaryData) {",
          "52:             return null;",
          "54:         return java.util.Base64.getEncoder().encodeToString(binaryData);",
          "55:     }",
          "",
          "[Removed Lines]",
          "51:         if (binaryData == null)",
          "",
          "[Added Lines]",
          "51:         if (binaryData == null) {",
          "53:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:     @CheckForNull",
          "65:             justification = \"Null arrays are the part of the library API\")",
          "66:     public static byte[] decode(String encoded) {",
          "69:             return null;",
          "71:         return java.util.Base64.getDecoder().decode(encoded);",
          "72:     }",
          "",
          "[Removed Lines]",
          "64:     @SuppressFBWarnings(value = \"PZLA_PREFER_ZERO_LENGTH_ARRAYS\",",
          "68:         if (encoded == null)",
          "",
          "[Added Lines]",
          "65:     @SuppressFBWarnings(",
          "66:             value = \"PZLA_PREFER_ZERO_LENGTH_ARRAYS\",",
          "70:         if (encoded == null) {",
          "72:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/BinarySafeStream.java||src/main/java/hudson/remoting/BinarySafeStream.java": [
          "File: src/main/java/hudson/remoting/BinarySafeStream.java -> src/main/java/hudson/remoting/BinarySafeStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:             final byte[] qualtet = new byte[4];",
          "77:             int input = 0;",
          "79:             @Override",
          "80:             public int read() throws IOException {",
          "85:                 }",
          "87:                     return -1; // EOF",
          "89:                 return ((int) triplet[3 - remaining--]) & 0xFF;",
          "90:             }",
          "92:             @Override",
          "93:             public int read(@NonNull byte[] b, int off, int len) throws IOException {",
          "98:                     int read = 0;",
          "99:                     int ch;",
          "102:                         read++;",
          "103:                         len--;",
          "104:                     }",
          "",
          "[Removed Lines]",
          "74:             int remaining=0;",
          "81:                 if(remaining==0) {",
          "82:                     remaining = _read(triplet,0,3);",
          "83:                     if(0<remaining && remaining<3) // adjust to right",
          "84:                         System.arraycopy(triplet,0,triplet,3-remaining,remaining);",
          "86:                 if(remaining==-1)",
          "88:                 assert remaining>0;",
          "94:                 if(remaining==-1)   return -1; // EOF",
          "96:                 if(len<4) {",
          "100:                     while(len>0 && (ch=read())!=-1) {",
          "101:                         b[off++] = (byte)ch;",
          "",
          "[Added Lines]",
          "74:             int remaining = 0;",
          "81:                 if (remaining == 0) {",
          "82:                     remaining = _read(triplet, 0, 3);",
          "83:                     if (0 < remaining && remaining < 3) { // adjust to right",
          "84:                         System.arraycopy(triplet, 0, triplet, 3 - remaining, remaining);",
          "85:                     }",
          "87:                 if (remaining == -1) {",
          "89:                 }",
          "90:                 assert remaining > 0;",
          "96:                 if (remaining == -1) {",
          "97:                     return -1; // EOF",
          "98:                 }",
          "100:                 if (len < 4) {",
          "104:                     while (len > 0 && (ch = read()) != -1) {",
          "105:                         b[off++] = (byte) ch;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:                 }",
          "117:                         return l;",
          "120:                         return l;",
          "126:                 }",
          "129:             }",
          "",
          "[Removed Lines]",
          "109:                 int l = Math.min(len,remaining);",
          "110:                 if(l>0) {",
          "111:                     System.arraycopy(triplet,3-remaining,b,off,l);",
          "112:                     off+=l;",
          "113:                     len-=l;",
          "114:                     remaining=0;",
          "115:                     if(super.available()==0)",
          "118:                     if(len<4)",
          "123:                     int r = _read(b,off,len);",
          "124:                     if(r==-1)   return l;",
          "125:                     else        return l+r;",
          "128:                 return _read(b,off,len);",
          "",
          "[Added Lines]",
          "113:                 int l = Math.min(len, remaining);",
          "114:                 if (l > 0) {",
          "115:                     System.arraycopy(triplet, 3 - remaining, b, off, l);",
          "116:                     off += l;",
          "117:                     len -= l;",
          "118:                     remaining = 0;",
          "119:                     if (super.available() == 0) {",
          "122:                     }",
          "123:                     if (len < 4) {",
          "126:                     }",
          "129:                     int r = _read(b, off, len);",
          "130:                     if (r == -1) {",
          "131:                         return l;",
          "132:                     } else {",
          "133:                         return l + r;",
          "134:                     }",
          "137:                 return _read(b, off, len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:             private int _read(byte[] b, int off, int len) throws IOException {",
          "139:                 int totalRead = 0;",
          "155:                                 throw new IOException(\"Unexpected stream termination\");",
          "157:                                 return -1; // EOF, and no data to process",
          "158:                         }",
          "159:                         l += r;",
          "160:                     }",
          "168:                     }",
          "",
          "[Removed Lines]",
          "136:                 assert remaining==0;",
          "137:                 assert b.length>=off+4;",
          "142:                 if(len>0) {",
          "144:                     if(input>0)",
          "145:                         System.arraycopy(qualtet,0, b, off,input);",
          "150:                     int l=input; // l = # of total encoded bytes to be processed in this round",
          "151:                     while(l<4) {",
          "152:                         int r = super.read(b, off + l, Math.max(len,4) - l);",
          "153:                         if(r==-1) {",
          "154:                             if(l%4!=0)",
          "156:                             if(l==0)",
          "164:                     input = l%4;",
          "165:                     if(input>0) {",
          "166:                         System.arraycopy(b, off +l-input,qualtet,0,input);",
          "167:                         l-=input;",
          "171:                     assert l%4==0;",
          "172:                     for( int base= off; l>0; l-=4 ) {",
          "",
          "[Added Lines]",
          "145:                 assert remaining == 0;",
          "146:                 assert b.length >= off + 4;",
          "151:                 if (len > 0) {",
          "153:                     if (input > 0) {",
          "154:                         System.arraycopy(qualtet, 0, b, off, input);",
          "155:                     }",
          "160:                     int l = input; // l = # of total encoded bytes to be processed in this round",
          "161:                     while (l < 4) {",
          "162:                         int r = super.read(b, off + l, Math.max(len, 4) - l);",
          "163:                         if (r == -1) {",
          "164:                             if (l % 4 != 0) {",
          "166:                             }",
          "167:                             if (l == 0) {",
          "169:                             }",
          "176:                     input = l % 4;",
          "177:                     if (input > 0) {",
          "178:                         System.arraycopy(b, off + l - input, qualtet, 0, input);",
          "179:                         l -= input;",
          "183:                     assert l % 4 == 0;",
          "184:                     for (int base = off; l > 0; l -= 4) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "177:                         int c1 = DECODING_TABLE[b[base++]];",
          "178:                         int c2 = DECODING_TABLE[b[base++]];",
          "179:                         int c3 = DECODING_TABLE[b[base++]];",
          "186:                             ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "189:                             int avail = super.available();",
          "191:                                 byte[] buf = new byte[avail];",
          "193:                             }",
          "194:                             StringBuilder buf = new StringBuilder(\"Invalid encoded sequence encountered:\");",
          "197:                             throw new IOException(buf.toString());",
          "198:                         }",
          "200:                         totalRead++;",
          "203:                             totalRead++;",
          "206:                                 totalRead++;",
          "207:                             }",
          "208:                         }",
          "",
          "[Removed Lines]",
          "180:                         if(c0<0 || c1<0 || c2<-1 || c3<-1) {",
          "187:                             baos.write(b,base-4,l);",
          "190:                             if(avail >0) {",
          "192:                                 baos.write(buf,0,super.read(buf));",
          "195:                             for (byte ch : baos.toByteArray())",
          "196:                                 buf.append(String.format(\" %02X\",ch));",
          "199:                         b[off++] = (byte) ((c0<<2) | (c1>>4));",
          "201:                         if(c2!=-1) {",
          "202:                             b[off++] = (byte) ((c1<<4) | (c2>>2));",
          "204:                             if(c3!=-1) {",
          "205:                                 b[off++] = (byte) ((c2<<6) | c3);",
          "",
          "[Added Lines]",
          "192:                         if (c0 < 0 || c1 < 0 || c2 < -1 || c3 < -1) {",
          "199:                             baos.write(b, base - 4, l);",
          "202:                             if (avail > 0) {",
          "204:                                 baos.write(buf, 0, super.read(buf));",
          "207:                             for (byte ch : baos.toByteArray()) {",
          "208:                                 buf.append(String.format(\" %02X\", ch));",
          "209:                             }",
          "212:                         b[off++] = (byte) ((c0 << 2) | (c1 >> 4));",
          "214:                         if (c2 != -1) {",
          "215:                             b[off++] = (byte) ((c1 << 4) | (c2 >> 2));",
          "217:                             if (c3 != -1) {",
          "218:                                 b[off++] = (byte) ((c2 << 6) | c3);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "215:             @Override",
          "216:             public int available() throws IOException {",
          "219:             }",
          "220:         };",
          "221:     }",
          "",
          "[Removed Lines]",
          "218:                 return super.available()*3/4;",
          "",
          "[Added Lines]",
          "231:                 return super.available() * 3 / 4;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "229:     public static OutputStream wrap(OutputStream out) {",
          "230:         return new FilterOutputStream(out) {",
          "231:             private final byte[] triplet = new byte[3];",
          "233:             private final byte[] out = new byte[4];",
          "235:             @Override",
          "236:             public void write(int b) throws IOException {",
          "240:                 } else {",
          "242:                 }",
          "243:             }",
          "245:             @Override",
          "246:             public void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "250:                         triplet[remaining++] = b[off++];",
          "251:                         len--;",
          "252:                     }",
          "255:                         remaining = 0;",
          "256:                     }",
          "257:                 }",
          "263:                 }",
          "267:                     triplet[remaining++] = b[off++];",
          "268:                     len--;",
          "269:                 }",
          "270:             }",
          "272:             private void _write(byte a, byte b, byte c) throws IOException {",
          "278:             }",
          "280:             @Override",
          "",
          "[Removed Lines]",
          "232:             private int remaining=0;",
          "237:                 if(remaining==2) {",
          "238:                     _write(triplet[0],triplet[1],(byte)b);",
          "239:                     remaining=0;",
          "241:                     triplet[remaining++]=(byte)b;",
          "248:                 if(remaining>0) {",
          "249:                     while(len>0 && remaining<3) {",
          "253:                     if(remaining==3) {",
          "254:                         _write(triplet[0],triplet[1],triplet[2]);",
          "260:                 while(len>=3) {",
          "261:                     _write(b[off++],b[off++],b[off++]);",
          "262:                     len-=3;",
          "266:                 while(len>0) {",
          "273:                 out[0] = ENCODING_TABLE[(a>>2)&0x3F];",
          "274:                 out[1] = ENCODING_TABLE[((a<<4)&0x3F|(b>>4)&0x0F)];",
          "275:                 out[2] = ENCODING_TABLE[((b<<2)&0x3F|(c>>6)&0x03)];",
          "276:                 out[3] = ENCODING_TABLE[c&0x3F];",
          "277:                 super.out.write(out,0,4);",
          "",
          "[Added Lines]",
          "245:             private int remaining = 0;",
          "250:                 if (remaining == 2) {",
          "251:                     _write(triplet[0], triplet[1], (byte) b);",
          "252:                     remaining = 0;",
          "254:                     triplet[remaining++] = (byte) b;",
          "261:                 if (remaining > 0) {",
          "262:                     while (len > 0 && remaining < 3) {",
          "266:                     if (remaining == 3) {",
          "267:                         _write(triplet[0], triplet[1], triplet[2]);",
          "273:                 while (len >= 3) {",
          "274:                     _write(b[off++], b[off++], b[off++]);",
          "275:                     len -= 3;",
          "279:                 while (len > 0) {",
          "286:                 out[0] = ENCODING_TABLE[(a >> 2) & 0x3F];",
          "287:                 out[1] = ENCODING_TABLE[((a << 4) & 0x3F | (b >> 4) & 0x0F)];",
          "288:                 out[2] = ENCODING_TABLE[((b << 2) & 0x3F | (c >> 6) & 0x03)];",
          "289:                 out[3] = ENCODING_TABLE[c & 0x3F];",
          "290:                 super.out.write(out, 0, 4);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "282:                 int a = triplet[0];",
          "283:                 int b = triplet[1];",
          "310:                 }",
          "311:                 super.flush();",
          "312:             }",
          "",
          "[Removed Lines]",
          "285:                 a&=0xFF;",
          "286:                 b&=0xFF;",
          "288:                 switch(remaining) {",
          "289:                 case 0:",
          "291:                     break;",
          "292:                 case 1:",
          "293:                     out[0] = ENCODING_TABLE[(a>>2)&0x3F];",
          "294:                     out[1] = ENCODING_TABLE[(a<<4)&0x3F];",
          "295:                     out[2] = '=';",
          "296:                     out[3] = '=';",
          "297:                     super.out.write(out,0,4);",
          "298:                     remaining = 0;",
          "299:                     break;",
          "300:                 case 2:",
          "301:                     out[0] = ENCODING_TABLE[(a>>2)&0x3F];",
          "302:                     out[1] = ENCODING_TABLE[((a<<4)|(b>>4))&0x3F];",
          "303:                     out[2] = ENCODING_TABLE[(b<<2)&0x3F];",
          "304:                     out[3] = '=';",
          "305:                     super.out.write(out,0,4);",
          "306:                     remaining = 0;",
          "307:                     break;",
          "308:                 default:",
          "309:                     throw new AssertionError();",
          "",
          "[Added Lines]",
          "298:                 a &= 0xFF;",
          "299:                 b &= 0xFF;",
          "301:                 switch (remaining) {",
          "302:                     case 0:",
          "304:                         break;",
          "305:                     case 1:",
          "306:                         out[0] = ENCODING_TABLE[(a >> 2) & 0x3F];",
          "307:                         out[1] = ENCODING_TABLE[(a << 4) & 0x3F];",
          "308:                         out[2] = '=';",
          "309:                         out[3] = '=';",
          "310:                         super.out.write(out, 0, 4);",
          "311:                         remaining = 0;",
          "312:                         break;",
          "313:                     case 2:",
          "314:                         out[0] = ENCODING_TABLE[(a >> 2) & 0x3F];",
          "315:                         out[1] = ENCODING_TABLE[((a << 4) | (b >> 4)) & 0x3F];",
          "316:                         out[2] = ENCODING_TABLE[(b << 2) & 0x3F];",
          "317:                         out[3] = '=';",
          "318:                         super.out.write(out, 0, 4);",
          "319:                         remaining = 0;",
          "320:                         break;",
          "321:                     default:",
          "322:                         throw new AssertionError();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "321:     private static final int[] DECODING_TABLE = new int[128];",
          "323:     static {",
          "328:             DECODING_TABLE[ENCODING_TABLE[i]] = i;",
          "329:         DECODING_TABLE['='] = -1;",
          "330:     }",
          "331: }",
          "",
          "[Removed Lines]",
          "324:         ENCODING_TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".getBytes(StandardCharsets.US_ASCII);",
          "326:         Arrays.fill(DECODING_TABLE,-2);",
          "327:         for (int i = 0; i < ENCODING_TABLE.length; i++)",
          "",
          "[Added Lines]",
          "337:         ENCODING_TABLE =",
          "338:                 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".getBytes(StandardCharsets.US_ASCII);",
          "340:         Arrays.fill(DECODING_TABLE, -2);",
          "341:         for (int i = 0; i < ENCODING_TABLE.length; i++) {",
          "343:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Callable.java||src/main/java/hudson/remoting/Callable.java": [
          "File: src/main/java/hudson/remoting/Callable.java -> src/main/java/hudson/remoting/Callable.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "44: public interface Callable<V,T extends Throwable> extends Serializable, RoleSensitive {",
          "",
          "[Added Lines]",
          "45: public interface Callable<V, T extends Throwable> extends Serializable, RoleSensitive {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:             final Thread t = Thread.currentThread();",
          "69:         }",
          "70:         return ch;",
          "71:     }",
          "",
          "[Removed Lines]",
          "66:             throw new ChannelStateException(null, \"The calling thread \" + t + \" has no associated channel. \"",
          "67:                     + \"The current object \" + this + \" is \" + SerializableOnlyOverRemoting.class +",
          "68:                     \", but it is likely being serialized/deserialized without the channel\");",
          "",
          "[Added Lines]",
          "67:             throw new ChannelStateException(",
          "68:                     null,",
          "69:                     \"The calling thread \" + t + \" has no associated channel. \"",
          "70:                             + \"The current object \" + this + \" is \" + SerializableOnlyOverRemoting.class",
          "71:                             + \", but it is likely being serialized/deserialized without the channel\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:     default Channel getOpenChannelOrFail() throws ChannelStateException {",
          "86:         final Channel ch = getChannelOrFail();",
          "87:         if (ch.isClosingOrClosed()) {",
          "89:         }",
          "90:         return ch;",
          "91:     }",
          "",
          "[Removed Lines]",
          "88:             throw new ChannelClosedException(ch, \"The associated channel \" + ch + \" is closing down or has closed down\", ch.getCloseRequestCause());",
          "",
          "[Added Lines]",
          "91:             throw new ChannelClosedException(",
          "92:                     ch,",
          "93:                     \"The associated channel \" + ch + \" is closing down or has closed down\",",
          "94:                     ch.getCloseRequestCause());",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/CallableDecoratorAdapter.java||src/main/java/hudson/remoting/CallableDecoratorAdapter.java": [
          "File: src/main/java/hudson/remoting/CallableDecoratorAdapter.java -> src/main/java/hudson/remoting/CallableDecoratorAdapter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:     @Override",
          "27:     public boolean equals(Object obj) {",
          "28:         if (obj != null && obj.getClass() == this.getClass()) {",
          "30:         }",
          "31:         return false;",
          "32:     }",
          "",
          "[Removed Lines]",
          "29:             return ((CallableDecoratorAdapter)obj).filter.equals(filter);",
          "",
          "[Added Lines]",
          "29:             return ((CallableDecoratorAdapter) obj).filter.equals(filter);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/CallableDecoratorList.java||src/main/java/hudson/remoting/CallableDecoratorList.java": [
          "File: src/main/java/hudson/remoting/CallableDecoratorList.java -> src/main/java/hudson/remoting/CallableDecoratorList.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: class CallableDecoratorList extends CopyOnWriteArrayList<CallableDecorator> {",
          "12:     <V> java.util.concurrent.Callable<V> wrapCallable(java.util.concurrent.Callable<V> r) {",
          "14:             r = applyDecorator(r, d);",
          "15:         return r;",
          "16:     }",
          "19:         return () -> filter.call(inner);",
          "20:     }",
          "28:         return decorated;",
          "29:     }",
          "",
          "[Removed Lines]",
          "13:         for (CallableDecorator d : this)",
          "18:     private <V> java.util.concurrent.Callable<V> applyDecorator(final java.util.concurrent.Callable<V> inner, final CallableDecorator filter) {",
          "22:     <V,T extends Throwable> Callable<V,T> wrapUserRequest(final Callable<V,T> c) {",
          "23:         Callable<V,T> decorated = c;",
          "25:         for (CallableDecorator d : this)",
          "26:             decorated = d.userRequest(c,decorated);",
          "",
          "[Added Lines]",
          "13:         for (CallableDecorator d : this) {",
          "15:         }",
          "19:     private <V> java.util.concurrent.Callable<V> applyDecorator(",
          "20:             final java.util.concurrent.Callable<V> inner, final CallableDecorator filter) {",
          "24:     <V, T extends Throwable> Callable<V, T> wrapUserRequest(final Callable<V, T> c) {",
          "25:         Callable<V, T> decorated = c;",
          "27:         for (CallableDecorator d : this) {",
          "28:             decorated = d.userRequest(c, decorated);",
          "29:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Capability.java||src/main/java/hudson/remoting/Capability.java": [
          "File: src/main/java/hudson/remoting/Capability.java -> src/main/java/hudson/remoting/Capability.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     }",
          "44:     public Capability() {",
          "46:     }",
          "",
          "[Removed Lines]",
          "45:         this(MASK_MULTI_CLASSLOADER | MASK_PIPE_THROTTLING | MASK_MIMIC_EXCEPTION | MASK_PREFETCH | GREEDY_REMOTE_INPUTSTREAM | MASK_PROXY_WRITER_2_35 | MASK_CHUNKED_ENCODING | PROXY_EXCEPTION_FALLBACK);",
          "",
          "[Added Lines]",
          "45:         this(MASK_MULTI_CLASSLOADER",
          "46:                 | MASK_PIPE_THROTTLING",
          "47:                 | MASK_MIMIC_EXCEPTION",
          "48:                 | MASK_PREFETCH",
          "49:                 | GREEDY_REMOTE_INPUTSTREAM",
          "50:                 | MASK_PROXY_WRITER_2_35",
          "51:                 | MASK_CHUNKED_ENCODING",
          "52:                 | PROXY_EXCEPTION_FALLBACK);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:     public boolean supportsMultiClassLoaderRPC() {",
          "56:     }",
          "",
          "[Removed Lines]",
          "55:         return (mask&MASK_MULTI_CLASSLOADER)!=0;",
          "",
          "[Added Lines]",
          "62:         return (mask & MASK_MULTI_CLASSLOADER) != 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:     public boolean supportsPipeThrottling() {",
          "65:     }",
          "68:     @Deprecated",
          "69:     public boolean hasMimicException() {",
          "71:     }",
          "",
          "[Removed Lines]",
          "64:         return (mask& MASK_PIPE_THROTTLING)!=0;",
          "70:         return (mask&MASK_MIMIC_EXCEPTION)!=0;",
          "",
          "[Added Lines]",
          "71:         return (mask & MASK_PIPE_THROTTLING) != 0;",
          "77:         return (mask & MASK_MIMIC_EXCEPTION) != 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:     public static Capability read(InputStream is) throws IOException {",
          "165:         try (ObjectInputStream ois = new ObjectInputStream(Channel.Mode.TEXT.wrap(is)) {",
          "177:                 }",
          "185:         } catch (ClassNotFoundException e) {",
          "187:         }",
          "188:     }",
          "",
          "[Removed Lines]",
          "163:     @SuppressFBWarnings(value = \"OBJECT_DESERIALIZATION\", justification = \"Capability is used for negotiating channel between authorized agent and server. Whitelisting and proper deserialization hygiene are used.\")",
          "171:                 @Override",
          "172:                 protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {",
          "173:                     String n = desc.getName();",
          "174:                     if (n.equals(\"java.lang.String\") || n.equals(\"[Ljava.lang.String;\") || n.equals(Capability.class.getName()))",
          "175:                         return super.resolveClass(desc);",
          "176:                     throw new SecurityException(\"Rejected: \"+n);",
          "179:                 @Override",
          "180:                 public void close() throws IOException {",
          "182:                 }",
          "183:             }) {",
          "184:             return (Capability)ois.readObject();",
          "186:             throw (Error)new NoClassDefFoundError(e.getMessage()).initCause(e);",
          "",
          "[Added Lines]",
          "172:     @SuppressFBWarnings(",
          "173:             value = \"OBJECT_DESERIALIZATION\",",
          "174:             justification =",
          "175:                     \"Capability is used for negotiating channel between authorized agent and server. Whitelisting and proper deserialization hygiene are used.\")",
          "183:             @Override",
          "184:             protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {",
          "185:                 String n = desc.getName();",
          "186:                 if (n.equals(\"java.lang.String\")",
          "187:                         || n.equals(\"[Ljava.lang.String;\")",
          "188:                         || n.equals(Capability.class.getName())) {",
          "189:                     return super.resolveClass(desc);",
          "191:                 throw new SecurityException(\"Rejected: \" + n);",
          "192:             }",
          "194:             @Override",
          "195:             public void close() throws IOException {",
          "197:             }",
          "198:         }) {",
          "199:             return (Capability) ois.readObject();",
          "201:             throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java": [
          "File: src/main/java/hudson/remoting/Channel.java -> src/main/java/hudson/remoting/Channel.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:             new ConcurrentHashMap<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "299:     private final ConcurrentHashMap<Object,Object> properties = new ConcurrentHashMap<>();",
          "",
          "[Added Lines]",
          "304:     private final ConcurrentHashMap<Object, Object> properties = new ConcurrentHashMap<>();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "369:         TEXT(\"<===[HUDSON TRANSMISSION BEGINS]===>\") {",
          "371:                 return BinarySafeStream.wrap(os);",
          "372:             }",
          "374:                 return BinarySafeStream.wrap(is);",
          "375:             }",
          "376:         },",
          "",
          "[Removed Lines]",
          "364:         BINARY(new byte[]{0,0,0,0}),",
          "370:             @Override protected OutputStream wrap(OutputStream os) {",
          "373:             @Override protected InputStream wrap(InputStream is) {",
          "",
          "[Added Lines]",
          "369:         BINARY(new byte[] {0, 0, 0, 0}),",
          "375:             @Override",
          "376:             protected OutputStream wrap(OutputStream os) {",
          "380:             @Override",
          "381:             protected InputStream wrap(InputStream is) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "397:             this.preamble = preamble;",
          "398:         }",
          "402:     }",
          "",
          "[Removed Lines]",
          "400:         protected OutputStream wrap(OutputStream os) { return os; }",
          "401:         protected InputStream wrap(InputStream is) { return is; }",
          "",
          "[Added Lines]",
          "408:         protected OutputStream wrap(OutputStream os) {",
          "409:             return os;",
          "410:         }",
          "412:         protected InputStream wrap(InputStream is) {",
          "413:             return is;",
          "414:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "411:     @Deprecated",
          "412:     public Channel(String name, ExecutorService exec, InputStream is, OutputStream os) throws IOException {",
          "414:     }",
          "",
          "[Removed Lines]",
          "413:         this(name,exec,Mode.BINARY,is,os,null);",
          "",
          "[Added Lines]",
          "426:         this(name, exec, Mode.BINARY, is, os, null);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "423:     @Deprecated",
          "424:     public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os) throws IOException {",
          "426:     }",
          "",
          "[Removed Lines]",
          "425:         this(name,exec,mode,is,os,null);",
          "",
          "[Added Lines]",
          "438:         this(name, exec, mode, is, os, null);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "436:     @Deprecated",
          "439:     }",
          "",
          "[Removed Lines]",
          "437:     public Channel(String name, ExecutorService exec, InputStream is, OutputStream os, OutputStream header) throws IOException {",
          "438:         this(name,exec,Mode.BINARY,is,os,header);",
          "",
          "[Added Lines]",
          "450:     public Channel(String name, ExecutorService exec, InputStream is, OutputStream os, OutputStream header)",
          "451:             throws IOException {",
          "452:         this(name, exec, Mode.BINARY, is, os, header);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "451:     @Deprecated",
          "454:     }",
          "",
          "[Removed Lines]",
          "452:     public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os, OutputStream header) throws IOException {",
          "453:         this(name,exec,mode,is,os,header,false);",
          "",
          "[Added Lines]",
          "466:     public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os, OutputStream header)",
          "467:             throws IOException {",
          "468:         this(name, exec, mode, is, os, header, false);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "467:     @Deprecated",
          "470:     }",
          "",
          "[Removed Lines]",
          "468:     public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os, OutputStream header, boolean restricted) throws IOException {",
          "469:         this(name,exec,mode,is,os,header,restricted,null);",
          "",
          "[Added Lines]",
          "483:     public Channel(",
          "484:             String name,",
          "485:             ExecutorService exec,",
          "486:             Mode mode,",
          "487:             InputStream is,",
          "488:             OutputStream os,",
          "489:             OutputStream header,",
          "490:             boolean restricted)",
          "491:             throws IOException {",
          "492:         this(name, exec, mode, is, os, header, restricted, null);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "487:     @Deprecated",
          "501:     }",
          "",
          "[Removed Lines]",
          "488:     public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os, OutputStream header, boolean restricted, ClassLoader base) throws IOException {",
          "489:         this(name,exec,mode,is,os,header,restricted,base,new Capability());",
          "490:     }",
          "493:         this(new ChannelBuilder(name,exec)",
          "494:                 .withMode(mode)",
          "495:                 .withBaseLoader(base)",
          "496:                 .withCapability(capability)",
          "497:                 .withHeaderStream(header)",
          "498:                 .withArbitraryCallableAllowed(!restricted)",
          "499:                 .withRemoteClassLoadingAllowed(!restricted)",
          "500:                 , is, os);",
          "",
          "[Added Lines]",
          "511:     public Channel(",
          "512:             String name,",
          "513:             ExecutorService exec,",
          "514:             Mode mode,",
          "515:             InputStream is,",
          "516:             OutputStream os,",
          "517:             OutputStream header,",
          "518:             boolean restricted,",
          "519:             ClassLoader base)",
          "520:             throws IOException {",
          "521:         this(name, exec, mode, is, os, header, restricted, base, new Capability());",
          "522:     }",
          "525:             String name,",
          "526:             ExecutorService exec,",
          "527:             Mode mode,",
          "528:             InputStream is,",
          "529:             OutputStream os,",
          "530:             OutputStream header,",
          "531:             boolean restricted,",
          "532:             ClassLoader base,",
          "533:             Capability capability)",
          "534:             throws IOException {",
          "535:         this(",
          "536:                 new ChannelBuilder(name, exec)",
          "537:                         .withMode(mode)",
          "538:                         .withBaseLoader(base)",
          "539:                         .withCapability(capability)",
          "540:                         .withHeaderStream(header)",
          "541:                         .withArbitraryCallableAllowed(!restricted)",
          "542:                         .withRemoteClassLoadingAllowed(!restricted),",
          "543:                 is,",
          "544:                 os);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "513:     @Deprecated",
          "521:     }",
          "525:     }",
          "",
          "[Removed Lines]",
          "514:     public Channel(String name, ExecutorService exec, CommandTransport transport, boolean restricted, ClassLoader base) throws IOException {",
          "515:         this(new ChannelBuilder(name,exec)",
          "516:                 .withBaseLoader(base)",
          "517:                 .withArbitraryCallableAllowed(!restricted)",
          "518:                 .withRemoteClassLoadingAllowed(!restricted)",
          "519:                 , transport);",
          "524:         this(settings, settings.negotiate(is,os));",
          "",
          "[Added Lines]",
          "558:     public Channel(String name, ExecutorService exec, CommandTransport transport, boolean restricted, ClassLoader base)",
          "559:             throws IOException {",
          "560:         this(",
          "561:                 new ChannelBuilder(name, exec)",
          "562:                         .withBaseLoader(base)",
          "563:                         .withArbitraryCallableAllowed(!restricted)",
          "564:                         .withRemoteClassLoadingAllowed(!restricted),",
          "565:                 transport);",
          "569:         this(settings, settings.negotiate(is, os));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "551:     @Deprecated",
          "558:     }",
          "",
          "[Removed Lines]",
          "552:     public Channel(String name, ExecutorService exec, CommandTransport transport, boolean restricted, ClassLoader base, JarCache jarCache) throws IOException {",
          "553:         this(new ChannelBuilder(name,exec)",
          "554:             .withBaseLoader(base)",
          "555:             .withRestricted(restricted)",
          "556:             .withJarCache(jarCache)",
          "557:             , transport);",
          "",
          "[Added Lines]",
          "597:     public Channel(",
          "598:             String name,",
          "599:             ExecutorService exec,",
          "600:             CommandTransport transport,",
          "601:             boolean restricted,",
          "602:             ClassLoader base,",
          "603:             JarCache jarCache)",
          "604:             throws IOException {",
          "605:         this(",
          "606:                 new ChannelBuilder(name, exec)",
          "607:                         .withBaseLoader(base)",
          "608:                         .withRestricted(restricted)",
          "609:                         .withJarCache(jarCache),",
          "610:                 transport);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "563:     protected Channel(@NonNull ChannelBuilder settings, @NonNull CommandTransport transport) throws IOException {",
          "564:         this.name = settings.getName();",
          "565:         this.reference = new Ref(this);",
          "567:         this.arbitraryCallableAllowed = settings.isArbitraryCallableAllowed();",
          "568:         this.remoteClassLoadingAllowed = settings.isRemoteClassLoadingAllowed();",
          "569:         this.underlyingOutput = transport.getUnderlyingStream();",
          "",
          "[Removed Lines]",
          "566:         this.executor = new InterceptingExecutorService(settings.getExecutors(),decorators);",
          "",
          "[Added Lines]",
          "619:         this.executor = new InterceptingExecutorService(settings.getExecutors(), decorators);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "577:         this.baseClassLoader = settings.getBaseLoader();",
          "578:         this.classFilter = settings.getClassFilter();",
          "581:             throw new AssertionError(); // export number 1 is reserved for the channel itself",
          "582:         remoteChannel = RemoteInvocationHandler.wrap(this, 1, IChannel.class, true, false, false, true);",
          "584:         this.remoteCapability = transport.getRemoteCapability();",
          "",
          "[Removed Lines]",
          "580:         if(internalExport(IChannel.class, this, false)!=1)",
          "",
          "[Added Lines]",
          "633:         if (internalExport(IChannel.class, this, false) != 1) {",
          "635:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "606:                 try {",
          "607:                     cmd.execute(Channel.this);",
          "608:                     if (logger.isLoggable(Level.FINE)) {",
          "610:                     }",
          "611:                 } catch (Throwable t) {",
          "613:                     if (cmd.createdAt != null) {",
          "614:                         logger.log(Level.SEVERE, \"This command is created here\", cmd.createdAt);",
          "615:                     }",
          "",
          "[Removed Lines]",
          "609:                         logger.log(Level.FINE, \"Completed command {0}. It took {1}ms\", new Object[] {cmd, System.currentTimeMillis() - receivedAt});",
          "612:                     logger.log(Level.SEVERE, \"Failed to execute command \" + cmd + \" (channel \" + Channel.this.name + \")\", t);",
          "",
          "[Added Lines]",
          "663:                         logger.log(Level.FINE, \"Completed command {0}. It took {1}ms\", new Object[] {",
          "664:                             cmd, System.currentTimeMillis() - receivedAt",
          "665:                         });",
          "668:                     logger.log(",
          "669:                             Level.SEVERE,",
          "670:                             \"Failed to execute command \" + cmd + \" (channel \" + Channel.this.name + \")\",",
          "671:                             t);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "621:                 Channel.this.terminate(e);",
          "622:             }",
          "623:         });",
          "625:     }",
          "",
          "[Removed Lines]",
          "624:         ACTIVE_CHANNELS.put(this,ref());",
          "",
          "[Added Lines]",
          "683:         ACTIVE_CHANNELS.put(this, ref());",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "643:     public static abstract class Listener {",
          "",
          "[Added Lines]",
          "702:     public abstract static class Listener {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "690:         public void onJar(Channel channel, File jar) {}",
          "692:     }",
          "697:     public boolean isOutClosed() {",
          "699:     }",
          "",
          "[Removed Lines]",
          "698:         return outClosed!=null;",
          "",
          "[Added Lines]",
          "756:         return outClosed != null;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "746:     private ExecutorService createPipeWriterExecutor() {",
          "748:             return new SingleLaneExecutorService(executor);",
          "749:         return new SynchronousExecutorService();",
          "750:     }",
          "",
          "[Removed Lines]",
          "747:         if (remoteCapability.supportsPipeThrottling())",
          "",
          "[Added Lines]",
          "805:         if (remoteCapability.supportsPipeThrottling()) {",
          "807:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "762:             throw new ChannelClosedException(this, outClosed);",
          "766:         transport.write(cmd, cmd instanceof CloseCommand);",
          "767:         commandsSent.incrementAndGet();",
          "",
          "[Removed Lines]",
          "759:     @SuppressFBWarnings(value = \"VO_VOLATILE_INCREMENT\", justification = \"The method is synchronized, no other usages. See https://sourceforge.net/p/findbugs/bugs/1032/\")",
          "761:         if(outClosed!=null)",
          "763:         if(logger.isLoggable(Level.FINE))",
          "764:             logger.fine(\"Send \"+cmd);",
          "",
          "[Added Lines]",
          "818:     @SuppressFBWarnings(",
          "819:             value = \"VO_VOLATILE_INCREMENT\",",
          "820:             justification =",
          "821:                     \"The method is synchronized, no other usages. See https://sourceforge.net/p/findbugs/bugs/1032/\")",
          "823:         if (outClosed != null) {",
          "825:         }",
          "826:         if (logger.isLoggable(Level.FINE)) {",
          "827:             logger.fine(\"Send \" + cmd);",
          "828:         }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "793:     @Nullable",
          "796:             return null;",
          "797:         }",
          "803:             try {",
          "804:                 send(new GCCommand());",
          "805:             } catch (IOException e) {",
          "808:             }",
          "811:         boolean autoUnexportByCaller = exportedObjects.isRecording();",
          "812:         final int id = internalExport(type, instance, autoUnexportByCaller);",
          "814:     }",
          "",
          "[Removed Lines]",
          "795:         if(instance==null) {",
          "802:         if((++gcCounter)%10000==0)",
          "807:                 logger.log(Level.WARNING, \"Unable to send GC command\",e);",
          "813:         return RemoteInvocationHandler.wrap(null, id, type, userProxy, autoUnexportByCaller, userScope, recordCreatedAt);",
          "",
          "[Added Lines]",
          "859:             Class<T> type, @CheckForNull T instance, boolean userProxy, boolean userScope, boolean recordCreatedAt) {",
          "860:         if (instance == null) {",
          "867:         if ((++gcCounter) % 10000 == 0) {",
          "872:                 logger.log(Level.WARNING, \"Unable to send GC command\", e);",
          "874:         }",
          "879:         return RemoteInvocationHandler.wrap(",
          "880:                 null, id, type, userProxy, autoUnexportByCaller, userScope, recordCreatedAt);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "821:         return exportedObjects.export(clazz, instance, automaticUnexport);",
          "822:     }",
          "825:         return exportedObjects.get(oid);",
          "826:     }",
          "828:     @CheckForNull",
          "830:         return exportedObjects.getOrNull(oid);",
          "831:     }",
          "834:         return exportedObjects.type(oid);",
          "835:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "892:     Object getExportedObject(int oid) throws ExecutionException {",
          "902:     Class<?>[] getExportedTypes(int oid) throws ExecutionException {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "862:     public void pinClassLoader(ClassLoader cl) {",
          "864:     }",
          "",
          "[Removed Lines]",
          "863:         RemoteClassLoader.pin(cl,this);",
          "",
          "[Added Lines]",
          "932:         RemoteClassLoader.pin(cl, this);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "923:         return preloadJar(UserRequest.getClassLoader(classLoaderRef), classesInJar);",
          "924:     }",
          "926:     public boolean preloadJar(ClassLoader local, Class<?>... classesInJar) throws IOException, InterruptedException {",
          "927:         URL[] jars = new URL[classesInJar.length];",
          "929:             jars[i] = Which.jarFile(classesInJar[i]).toURI().toURL();",
          "930:         return call(new PreloadJarTask(jars, local));",
          "931:     }",
          "933:     public boolean preloadJar(ClassLoader local, URL... jars) throws IOException, InterruptedException {",
          "935:     }",
          "",
          "[Removed Lines]",
          "922:     public boolean preloadJar(Callable<?,?> classLoaderRef, Class<?>... classesInJar) throws IOException, InterruptedException {",
          "928:         for (int i = 0; i < classesInJar.length; i++)",
          "934:         return call(new PreloadJarTask(jars,local));",
          "",
          "[Added Lines]",
          "991:     public boolean preloadJar(Callable<?, ?> classLoaderRef, Class<?>... classesInJar)",
          "992:             throws IOException, InterruptedException {",
          "998:         for (int i = 0; i < classesInJar.length; i++) {",
          "1000:         }",
          "1005:         return call(new PreloadJarTask(jars, local));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "965:         synchronized (pipeWindows) {",
          "966:             PipeWindow.Key k = new PipeWindow.Key(oid);",
          "967:             WeakReference<PipeWindow> v = pipeWindows.get(k);",
          "969:                 PipeWindow w = v.get();",
          "971:                     return w;",
          "972:             }",
          "974:             PipeWindow w;",
          "976:                 w = new PipeWindow.Real(k, PIPE_WINDOW_SIZE);",
          "978:                 w = new PipeWindow.Fake();",
          "979:             pipeWindows.put(k, new WeakReference<>(w));",
          "980:             return w;",
          "981:         }",
          "982:     }",
          "988:     @Override",
          "991:         if (isClosingOrClosed()) {",
          "995:         }",
          "998:         try {",
          "999:             request = new UserRequest<>(this, callable);",
          "1000:             UserRequest.ResponseToUserRequest<V, T> r = request.call(this);",
          "1001:             return r.retrieve(this, UserRequest.getClassLoader(callable));",
          "1004:         } catch (ClassNotFoundException | Error e) {",
          "1005:             throw new IOException(\"Remote call on \" + name + \" failed\", e);",
          "1006:         } catch (SecurityException e) {",
          "",
          "[Removed Lines]",
          "968:             if (v!=null) {",
          "970:                 if (w!=null)",
          "975:             if (remoteCapability.supportsPipeThrottling())",
          "977:             else",
          "989:     public <V,T extends Throwable>",
          "990:     V call(Callable<V,T> callable) throws IOException, T, InterruptedException {",
          "993:             throw new ChannelClosedException(this, \"Remote call on \" + name + \" failed. \"",
          "994:                     + \"The channel is closing down or has closed down\", getCloseRequestCause());",
          "997:         UserRequest<V,T> request=null;",
          "",
          "[Added Lines]",
          "1039:             if (v != null) {",
          "1041:                 if (w != null) {",
          "1043:                 }",
          "1047:             if (remoteCapability.supportsPipeThrottling()) {",
          "1049:             } else {",
          "1051:             }",
          "1061:     public <V, T extends Throwable> V call(Callable<V, T> callable) throws IOException, T, InterruptedException {",
          "1064:             throw new ChannelClosedException(",
          "1065:                     this,",
          "1066:                     \"Remote call on \" + name + \" failed. \" + \"The channel is closing down or has closed down\",",
          "1067:                     getCloseRequestCause());",
          "1070:         UserRequest<V, T> request = null;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1014:                 request.releaseExports();",
          "1015:         }",
          "1016:     }",
          "",
          "[Removed Lines]",
          "1013:             if(request!=null)",
          "",
          "[Added Lines]",
          "1086:             if (request != null) {",
          "1088:             }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1021:     @Override",
          "1024:         if (isClosingOrClosed()) {",
          "1028:         }",
          "1030:         final Future<UserRequest.ResponseToUserRequest<V, T>> f = new UserRequest<V, T>(this, callable).callAsync(this);",
          "",
          "[Removed Lines]",
          "1022:     public <V,T extends Throwable>",
          "1023:     Future<V> callAsync(final Callable<V,T> callable) throws IOException {",
          "1026:             throw new ChannelClosedException(this, \"Remote call on \" + name + \" failed. \"",
          "1027:                     + \"The channel is closing down or has closed down\", getCloseRequestCause());",
          "",
          "[Added Lines]",
          "1096:     public <V, T extends Throwable> Future<V> callAsync(final Callable<V, T> callable) throws IOException {",
          "1099:             throw new ChannelClosedException(",
          "1100:                     this,",
          "1101:                     \"Remote call on \" + name + \" failed. \" + \"The channel is closing down or has closed down\",",
          "1102:                     getCloseRequestCause());",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1033:             protected V adapt(UserRequest.ResponseToUserRequest<V, T> r) throws ExecutionException {",
          "1034:                 try {",
          "1035:                     return r.retrieve(Channel.this, UserRequest.getClassLoader(callable));",
          "1037:                     throw new ExecutionException(t);",
          "1038:                 }",
          "1039:             }",
          "",
          "[Removed Lines]",
          "1036:                 } catch (Throwable t) {// really means catch(T t)",
          "",
          "[Added Lines]",
          "1111:                 } catch (Throwable t) { // really means catch(T t)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1056:     public void terminate(@NonNull IOException e) {",
          "1058:         if (e == null) {",
          "",
          "[Removed Lines]",
          "1055:     @SuppressFBWarnings(value = \"ITA_INEFFICIENT_TO_ARRAY\", justification = \"intentionally; race condition on listeners otherwise\")",
          "",
          "[Added Lines]",
          "1130:     @SuppressFBWarnings(",
          "1131:             value = \"ITA_INEFFICIENT_TO_ARRAY\",",
          "1132:             justification = \"intentionally; race condition on listeners otherwise\")",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1096:                 }",
          "1097:             } // JENKINS-14909: leave synch block",
          "1098:         } finally {",
          "1100:             for (Listener l : listeners) {",
          "1101:                 try {",
          "1102:                     l.onClosed(this, e);",
          "1103:                 } catch (Throwable t) {",
          "1105:                     lr.setThrown(t);",
          "1107:                     logger.log(lr);",
          "1108:                 }",
          "1109:             }",
          "",
          "[Removed Lines]",
          "1099:             if (e instanceof OrderlyShutdown) e = null;",
          "1104:                     LogRecord lr = new LogRecord(Level.SEVERE, \"Listener {0} propagated an exception for channel {1}'s close: {2}\");",
          "1106:                     lr.setParameters(new Object[]{l, this, t.getMessage()});",
          "",
          "[Added Lines]",
          "1176:             if (e instanceof OrderlyShutdown) {",
          "1177:                 e = null;",
          "1178:             }",
          "1183:                     LogRecord lr = new LogRecord(",
          "1184:                             Level.SEVERE, \"Listener {0} propagated an exception for channel {1}'s close: {2}\");",
          "1186:                     lr.setParameters(new Object[] {l, this, t.getMessage()});",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1176:     @Override",
          "1177:     public synchronized void join() throws InterruptedException {",
          "1183:             wait(TimeUnit.SECONDS.toMillis(30));",
          "1184:     }",
          "",
          "[Removed Lines]",
          "1178:         while(inClosed==null || outClosed==null)",
          "",
          "[Added Lines]",
          "1258:         while (inClosed == null || outClosed == null) {",
          "1264:         }",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1190:     public boolean isInClosed() {",
          "1192:     }",
          "",
          "[Removed Lines]",
          "1191:         return inClosed!=null;",
          "",
          "[Added Lines]",
          "1272:         return inClosed != null;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1259:     public void setMaximumBytecodeLevel(short level) throws IOException, InterruptedException {",
          "1260:         if (level < 5) {",
          "1262:         }",
          "1263:         call(new SetMaximumBytecodeLevel(level));",
          "1264:     }",
          "1266:         private static final long serialVersionUID = 1;",
          "1267:         private final short level;",
          "1268:         SetMaximumBytecodeLevel(short level) {",
          "1269:             this.level = level;",
          "1270:         }",
          "1271:         @Override",
          "1272:         public Void call() throws RuntimeException {",
          "1273:             Channel.currentOrFail().maximumBytecodeLevel = level;",
          "1274:             return null;",
          "1275:         }",
          "1279:     }",
          "",
          "[Removed Lines]",
          "1261:             throw new IllegalArgumentException(\"Does not make sense to specify JDK 1.4 or below since remoting itself requires JDK 5+\");",
          "1265:     private static final class SetMaximumBytecodeLevel implements InternalCallable<Void,RuntimeException> {",
          "",
          "[Added Lines]",
          "1342:             throw new IllegalArgumentException(",
          "1343:                     \"Does not make sense to specify JDK 1.4 or below since remoting itself requires JDK 5+\");",
          "1348:     private static final class SetMaximumBytecodeLevel implements InternalCallable<Void, RuntimeException> {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1313:                 channel.close();",
          "1314:                 channel.terminate(new OrderlyShutdown(createdAt));",
          "1315:             } catch (IOException e) {",
          "1318:             }",
          "1319:         }",
          "",
          "[Removed Lines]",
          "1316:                 logger.log(Level.SEVERE,\"close command failed on \"+channel.name,e);",
          "1317:                 logger.log(Level.INFO,\"close command created at\",createdAt);",
          "",
          "[Added Lines]",
          "1402:                 logger.log(Level.SEVERE, \"close command failed on \" + channel.name, e);",
          "1403:                 logger.log(Level.INFO, \"close command created at\", createdAt);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1334:     private static final class OrderlyShutdown extends IOException {",
          "1336:             super(cause);",
          "1337:         }",
          "1338:         private static final long serialVersionUID = 1L;",
          "1339:     }",
          "",
          "[Removed Lines]",
          "1335:         private OrderlyShutdown(@CheckForNull  Throwable cause) {",
          "",
          "[Added Lines]",
          "1422:         private OrderlyShutdown(@CheckForNull Throwable cause) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1359:         int l = classLoadingCount.get();",
          "1360:         int p = classLoadingPrefetchCacheCount.get();",
          "1361:         w.printf(Locale.ENGLISH, \"Class loading count=%d%n\", l);",
          "1363:         w.printf(Locale.ENGLISH, \"Class loading time=%,dms%n\", classLoadingTime.get() / (1000 * 1000));",
          "1364:         w.printf(Locale.ENGLISH, \"Resource loading count=%d%n\", resourceLoadingCount.get());",
          "1365:         w.printf(Locale.ENGLISH, \"Resource loading time=%,dms%n\", resourceLoadingTime.get() / (1000 * 1000));",
          "1366:     }",
          "",
          "[Removed Lines]",
          "1362:         w.printf(Locale.ENGLISH, \"Class loading prefetch hit=%s (%d%%)%n\", p, p*100/l);",
          "",
          "[Added Lines]",
          "1450:         w.printf(Locale.ENGLISH, \"Class loading prefetch hit=%s (%d%%)%n\", p, p * 100 / l);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1429:     @Restricted(NoExternalUse.class)",
          "1430:     public void dumpDiagnostics(@NonNull PrintWriter w) throws IOException {",
          "1432:         w.printf(\"  Created=%s%n\", new Date(createdAt));",
          "1433:         w.printf(\"  Commands sent=%d%n\", commandsSent.get());",
          "1434:         w.printf(\"  Commands received=%d%n\", commandsReceived.get());",
          "",
          "[Removed Lines]",
          "1431:         w.printf(\"Channel %s%n\",name);",
          "",
          "[Added Lines]",
          "1519:         w.printf(\"Channel %s%n\", name);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1465:     public void close(@CheckForNull Throwable diagnosis) throws IOException {",
          "1467:         closeRequested = true;",
          "1468:         if (closeRequestCause == null) {",
          "1471:             closeRequestCause = new IOException(diagnosis);",
          "1472:         }",
          "1477:                 return;",
          "1478:             }",
          "",
          "[Removed Lines]",
          "1466:         if(outClosed!=null)  return;  // already closed",
          "1474:         synchronized(this) {",
          "1475:             if(outClosed!=null) {",
          "",
          "[Added Lines]",
          "1554:         if (outClosed != null) {",
          "1555:             return; // already closed",
          "1556:         }",
          "1565:         synchronized (this) {",
          "1566:             if (outClosed != null) {",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1489:                 terminate(e);",
          "1490:                 return;",
          "1491:             }",
          "1493:             notifyAll();",
          "1494:             try {",
          "1495:                 transport.closeWrite();",
          "",
          "[Removed Lines]",
          "1492:             outClosed = new IOException(diagnosis);   // last command sent. no further command allowed. lock guarantees that no command will slip inbetween",
          "",
          "[Added Lines]",
          "1583:             outClosed = new IOException(",
          "1584:                     diagnosis); // last command sent. no further command allowed. lock guarantees that no command will",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1545:         Object prop = properties.get(key);",
          "1547:             return prop;",
          "1548:         }",
          "1552:             throw new IllegalStateException(\"Channel was already closed\", inClosed);",
          "1554:             throw new IllegalStateException(\"Channel was already closed\", outClosed);",
          "1556:         while (true) {",
          "1559:                 if (isInClosed()) {",
          "1560:                     throw new IllegalStateException(\"Channel was already closed\", inClosed);",
          "1561:                 } else if (isOutClosed()) {",
          "",
          "[Removed Lines]",
          "1546:         if(prop!=null) {",
          "1551:         if (isInClosed())",
          "1553:         if (isOutClosed())",
          "1558:             synchronized(this) {",
          "",
          "[Added Lines]",
          "1639:         if (prop != null) {",
          "1644:         if (isInClosed()) {",
          "1646:         }",
          "1647:         if (isOutClosed()) {",
          "1649:         }",
          "1653:             synchronized (this) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1565:                 }",
          "1566:             }",
          "1567:             Object v = properties.get(key);",
          "1569:         }",
          "1570:     }",
          "",
          "[Removed Lines]",
          "1568:             if (v != null) return v;",
          "",
          "[Added Lines]",
          "1663:             if (v != null) {",
          "1664:                 return v;",
          "1665:             }",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1673:     @Deprecated",
          "1677:         portForwarder.start();",
          "1678:         return portForwarder;",
          "1679:     }",
          "",
          "[Removed Lines]",
          "1674:     public ListeningPort createLocalToRemotePortForwarding(int recvPort, String forwardHost, int forwardPort) throws IOException, InterruptedException {",
          "1675:         PortForwarder portForwarder = new PortForwarder(recvPort,",
          "1676:                 ForwarderFactory.create(this, forwardHost, forwardPort));",
          "",
          "[Added Lines]",
          "1770:     public ListeningPort createLocalToRemotePortForwarding(int recvPort, String forwardHost, int forwardPort)",
          "1771:             throws IOException, InterruptedException {",
          "1772:         PortForwarder portForwarder =",
          "1773:                 new PortForwarder(recvPort, ForwarderFactory.create(this, forwardHost, forwardPort));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1698:     @Deprecated",
          "1702:     }",
          "",
          "[Removed Lines]",
          "1699:     public ListeningPort createRemoteToLocalPortForwarding(int recvPort, String forwardHost, int forwardPort) throws IOException, InterruptedException {",
          "1700:         return PortForwarder.create(this,recvPort,",
          "1701:                 ForwarderFactory.create(forwardHost, forwardPort));",
          "",
          "[Added Lines]",
          "1796:     public ListeningPort createRemoteToLocalPortForwarding(int recvPort, String forwardHost, int forwardPort)",
          "1797:             throws IOException, InterruptedException {",
          "1798:         return PortForwarder.create(this, recvPort, ForwarderFactory.create(forwardHost, forwardPort));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1733:         call(new IOSyncer());",
          "1734:     }",
          "1749:     @Override",
          "1750:     public void syncLocalIO() throws InterruptedException {",
          "1751:         Thread t = Thread.currentThread();",
          "1752:         String old = t.getName();",
          "1754:         try {",
          "1759:         } catch (ExecutionException e) {",
          "1760:             throw new AssertionError(e); // impossible",
          "1761:         } finally {",
          "",
          "[Removed Lines]",
          "1753:         t.setName(\"I/O sync: \"+old);",
          "1756:             pipeWriter.submit(0, () -> {",
          "1758:             }).get();",
          "",
          "[Added Lines]",
          "1851:         t.setName(\"I/O sync: \" + old);",
          "1854:             pipeWriter",
          "1855:                     .submit(0, () -> {",
          "1857:                     })",
          "1858:                     .get();",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1801:     @Override",
          "1802:     public String toString() {",
          "1804:     }",
          "",
          "[Removed Lines]",
          "1803:         return super.toString()+\":\"+name;",
          "",
          "[Added Lines]",
          "1903:         return super.toString() + \":\" + name;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1882:         for (Ref ref : channels) {",
          "1884:             if (w.checkError()) {",
          "1890:                 break;",
          "1891:             }",
          "",
          "[Removed Lines]",
          "1885:                 logger.log(Level.WARNING,",
          "1886:                         String.format(\"Cannot dump diagnostics for all channels, because output stream encountered an error. \"",
          "1887:                                 + \"Processed %d of %d channels, first unprocessed channel reference is %s.\",",
          "1888:                                 processedCount, channels.length, ref",
          "1889:                         ));",
          "",
          "[Added Lines]",
          "1985:                 logger.log(",
          "1986:                         Level.WARNING,",
          "1987:                         String.format(",
          "1988:                                 \"Cannot dump diagnostics for all channels, because output stream encountered an error. \"",
          "1989:                                         + \"Processed %d of %d channels, first unprocessed channel reference is %s.\",",
          "1990:                                 processedCount, channels.length, ref));",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1897:                     ch.dumpDiagnostics(w);",
          "1898:                 } catch (Throwable ex) {",
          "1899:                     if (ex instanceof Error) {",
          "1901:                     }",
          "1903:                             ch.getName(), ex.getMessage());",
          "1906:                 }",
          "1907:             }",
          "1908:             processedCount++;",
          "",
          "[Removed Lines]",
          "1900:                         throw (Error)ex;",
          "1902:                     w.printf(\"Cannot dump diagnostics for the channel %s. %s. See Error stacktrace in system logs\",",
          "1904:                     logger.log(Level.WARNING,",
          "1905:                             String.format(\"Cannot dump diagnostics for the channel %s\", ch.getName()), ex);",
          "",
          "[Added Lines]",
          "2001:                         throw (Error) ex;",
          "2003:                     w.printf(",
          "2004:                             \"Cannot dump diagnostics for the channel %s. %s. See Error stacktrace in system logs\",",
          "2006:                     logger.log(",
          "2007:                             Level.WARNING,",
          "2008:                             String.format(\"Cannot dump diagnostics for the channel %s\", ch.getName()),",
          "2009:                             ex);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1924:         } else if (t == null) {",
          "1925:             return false;",
          "1926:         } else {",
          "1928:         }",
          "1929:     }",
          "",
          "[Removed Lines]",
          "1927:             return isClosedChannelException(t.getCause()) || Stream.of(t.getSuppressed()).anyMatch(Channel::isClosedChannelException);",
          "",
          "[Added Lines]",
          "2031:             return isClosedChannelException(t.getCause())",
          "2032:                     || Stream.of(t.getSuppressed()).anyMatch(Channel::isClosedChannelException);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2025:     static final Class<?> jarLoaderProxy;",
          "",
          "[Removed Lines]",
          "2018:     public static final int PIPE_WINDOW_SIZE = Integer.getInteger(Channel.class.getName()+\".pipeWindowSize\",1024*1024);",
          "2023:     private static final Map<Channel,Ref> ACTIVE_CHANNELS = Collections.synchronizedMap(new WeakHashMap<>());",
          "",
          "[Added Lines]",
          "2122:     public static final int PIPE_WINDOW_SIZE =",
          "2123:             Integer.getInteger(Channel.class.getName() + \".pipeWindowSize\", 1024 * 1024);",
          "2128:     private static final Map<Channel, Ref> ACTIVE_CHANNELS = Collections.synchronizedMap(new WeakHashMap<>());",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2038:     }",
          "",
          "[Removed Lines]",
          "2037:         jarLoaderProxy=RemoteInvocationHandler.getProxyClass(JarLoader.class);",
          "",
          "[Added Lines]",
          "2142:         jarLoaderProxy = RemoteInvocationHandler.getProxyClass(JarLoader.class);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2100:         @CheckForNull",
          "2101:         public Exception cause() {",
          "2103:         }",
          "",
          "[Removed Lines]",
          "2102:             return  cause;",
          "",
          "[Added Lines]",
          "2207:             return cause;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChannelBuilder.java||src/main/java/hudson/remoting/ChannelBuilder.java": [
          "File: src/main/java/hudson/remoting/ChannelBuilder.java -> src/main/java/hudson/remoting/ChannelBuilder.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:     private static final Logger LOGGER = Logger.getLogger(ChannelBuilder.class.getName());",
          "48:     private static final Set<String> SPECIFIC_CALLABLES_CAN_IGNORE_ROLECHECKER = new HashSet<>();",
          "",
          "[Removed Lines]",
          "46:     private static /* non-final for Groovy */ boolean CALLABLES_CAN_IGNORE_ROLECHECKER = Boolean.getBoolean(ChannelBuilder.class.getName() + \".allCallablesCanIgnoreRoleChecker\");",
          "",
          "[Added Lines]",
          "47:     private static /* non-final for Groovy */ boolean CALLABLES_CAN_IGNORE_ROLECHECKER =",
          "48:             Boolean.getBoolean(ChannelBuilder.class.getName() + \".allCallablesCanIgnoreRoleChecker\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:         final String propertyName = ChannelBuilder.class.getName() + \".specificCallablesCanIgnoreRoleChecker\";",
          "52:         final String property = System.getProperty(propertyName);",
          "53:         if (property != null) {",
          "56:             SPECIFIC_CALLABLES_CAN_IGNORE_ROLECHECKER.addAll(names);",
          "57:         }",
          "58:     }",
          "61:     private final String name;",
          "62:     private final ExecutorService executors;",
          "63:     private ClassLoader base = this.getClass().getClassLoader();",
          "64:     private Channel.Mode mode = Channel.Mode.NEGOTIATE;",
          "65:     private Capability capability = new Capability();",
          "66:     @CheckForNull",
          "67:     private OutputStream header;",
          "68:     @CheckForNull",
          "69:     private JarCache jarCache;",
          "70:     private final List<CallableDecorator> decorators = new ArrayList<>();",
          "71:     private boolean arbitraryCallableAllowed = true;",
          "72:     private boolean remoteClassLoadingAllowed = true;",
          "74:     private ClassFilter filter = ClassFilter.DEFAULT;",
          "",
          "[Removed Lines]",
          "54:             final Set<String> names = Arrays.stream(property.split(\",\")).map(String::trim).collect(Collectors.toSet());",
          "55:             LOGGER.log(Level.INFO, () -> \"Allowing the following callables to bypass role checker requirement: \" + String.join(\", \", names));",
          "73:     private final Map<Object,Object> properties = new HashMap<>();",
          "",
          "[Added Lines]",
          "56:             final Set<String> names =",
          "57:                     Arrays.stream(property.split(\",\")).map(String::trim).collect(Collectors.toSet());",
          "58:             LOGGER.log(",
          "59:                     Level.INFO,",
          "60:                     () -> \"Allowing the following callables to bypass role checker requirement: \"",
          "61:                             + String.join(\", \", names));",
          "81:     private final Map<Object, Object> properties = new HashMap<>();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104:     public ChannelBuilder withBaseLoader(ClassLoader base) {",
          "106:         this.base = base;",
          "107:         return this;",
          "108:     }",
          "",
          "[Removed Lines]",
          "105:         if (base==null)     base = this.getClass().getClassLoader();",
          "",
          "[Added Lines]",
          "113:         if (base == null) {",
          "114:             base = this.getClass().getClassLoader();",
          "115:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "160:     @Deprecated",
          "162:         withArbitraryCallableAllowed(!restricted);",
          "163:         withRemoteClassLoadingAllowed(!restricted);",
          "164:         return this;",
          "",
          "[Removed Lines]",
          "161:     public ChannelBuilder withRestricted(boolean  restricted) {",
          "",
          "[Added Lines]",
          "171:     public ChannelBuilder withRestricted(boolean restricted) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "303:         }",
          "305:         if (callable instanceof InternalCallable) {",
          "307:             return false;",
          "308:         }",
          "311:             LOGGER.fine(() -> \"Callable \" + callable.getClass().getName() + \" is allowed through override\");",
          "312:             return false;",
          "313:         }",
          "",
          "[Removed Lines]",
          "306:             LOGGER.fine(() -> \"Callable \" + callable.getClass().getName() + \" is a remoting built-in callable allowed to bypass the role check\");",
          "310:         if (SPECIFIC_CALLABLES_CAN_IGNORE_ROLECHECKER.contains(callable.getClass().getName())) {",
          "",
          "[Added Lines]",
          "316:             LOGGER.fine(() -> \"Callable \" + callable.getClass().getName()",
          "317:                     + \" is a remoting built-in callable allowed to bypass the role check\");",
          "321:         if (SPECIFIC_CALLABLES_CAN_IGNORE_ROLECHECKER.contains(",
          "322:                 callable.getClass().getName())) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:                     RequiredRoleCheckerWrapper wrapped = new RequiredRoleCheckerWrapper(checker);",
          "328:                     stem.checkRoles(wrapped);",
          "329:                     if (wrapped.isChecked()) {",
          "331:                     } else if (isCallableProhibitedByRequiredRoleCheck(stem)) {",
          "334:                     }",
          "335:                 } catch (AbstractMethodError e) {",
          "337:                 }",
          "339:                 return stem;",
          "",
          "[Removed Lines]",
          "330:                         LOGGER.log(Level.FINER, () -> \"Callable \" + stem.getClass().getName() + \" checked roles\");",
          "332:                         LOGGER.log(Level.INFO, () -> \"Rejecting callable \" + stem.getClass().getName() + \" for ignoring RoleChecker in #checkRoles, see https://www.jenkins.io/redirect/required-role-check\");",
          "333:                         throw new SecurityException(\"Security hardening prohibits the Callable implementation \" + stem.getClass().getName() + \" from ignoring RoleChecker, see https://www.jenkins.io/redirect/required-role-check\");",
          "336:                     checker.check(stem, Role.UNKNOWN);// not implemented, assume 'unknown'",
          "",
          "[Added Lines]",
          "342:                         LOGGER.log(",
          "343:                                 Level.FINER, () -> \"Callable \" + stem.getClass().getName() + \" checked roles\");",
          "345:                         LOGGER.log(",
          "346:                                 Level.INFO,",
          "347:                                 () -> \"Rejecting callable \" + stem.getClass().getName()",
          "348:                                         + \" for ignoring RoleChecker in #checkRoles, see https://www.jenkins.io/redirect/required-role-check\");",
          "349:                         throw new SecurityException(",
          "350:                                 \"Security hardening prohibits the Callable implementation \"",
          "351:                                         + stem.getClass().getName()",
          "352:                                         + \" from ignoring RoleChecker, see https://www.jenkins.io/redirect/required-role-check\");",
          "355:                     checker.check(stem, Role.UNKNOWN); // not implemented, assume 'unknown'",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "352:     public ChannelBuilder withProperty(Object key, Object value) {",
          "354:         return this;",
          "355:     }",
          "",
          "[Removed Lines]",
          "353:         properties.put(key,value);",
          "",
          "[Added Lines]",
          "372:         properties.put(key, value);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "368:         return Collections.unmodifiableMap(properties);",
          "369:     }",
          "",
          "[Removed Lines]",
          "367:     public Map<Object,Object> getProperties() {",
          "",
          "[Added Lines]",
          "386:     public Map<Object, Object> getProperties() {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "377:     public ChannelBuilder withClassFilter(ClassFilter filter) {",
          "379:         this.filter = filter;",
          "380:         return this;",
          "381:     }",
          "",
          "[Removed Lines]",
          "378:         if (filter==null)   throw new IllegalArgumentException();",
          "",
          "[Added Lines]",
          "397:         if (filter == null) {",
          "398:             throw new IllegalArgumentException();",
          "399:         }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "400:     public Channel build(InputStream is, OutputStream os) throws IOException {",
          "402:     }",
          "404:     public Channel build(Socket s) throws IOException {",
          "408:     }",
          "410:     public Channel build(SocketChannel s) throws IOException {",
          "414:     }",
          "416:     public Channel build(CommandTransport transport) throws IOException {",
          "418:     }",
          "",
          "[Removed Lines]",
          "401:         return new Channel(this,negotiate(is,os));",
          "406:         return build(new BufferedInputStream(SocketChannelStream.in(s)),",
          "407:                     new BufferedOutputStream(SocketChannelStream.out(s)));",
          "411:         return build(",
          "412:                 SocketChannelStream.in(s),",
          "413:                 SocketChannelStream.out(s));",
          "417:         return new Channel(this,transport);",
          "",
          "[Added Lines]",
          "422:         return new Channel(this, negotiate(is, os));",
          "427:         return build(",
          "428:                 new BufferedInputStream(SocketChannelStream.in(s)),",
          "429:                 new BufferedOutputStream(SocketChannelStream.out(s)));",
          "433:         return build(SocketChannelStream.in(s), SocketChannelStream.out(s));",
          "437:         return new Channel(this, transport);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "439:         if (mode != Channel.Mode.NEGOTIATE) {",
          "440:             LOGGER.log(Level.FINER, \"Sending mode preamble: {0}\", mode);",
          "441:             os.write(mode.preamble);",
          "443:         } else {",
          "444:             LOGGER.log(Level.FINER, \"Awaiting mode preamble...\");",
          "445:         }",
          "448:             Channel.Mode[] modes = {Channel.Mode.BINARY, Channel.Mode.TEXT};",
          "454:                 int ch = is.read();",
          "456:                     throw new EOFException(\"unexpected stream termination\");",
          "459:                     byte[] preamble = preambles[i];",
          "462:                             switch (i) {",
          "488:                             }",
          "490:                         }",
          "491:                     } else {",
          "494:                     }",
          "495:                 }",
          "498:                     header.write(ch);",
          "499:             }",
          "500:         }",
          "501:     }",
          "",
          "[Removed Lines]",
          "442:             os.flush();    // make sure that stream preamble is sent to the other end. avoids dead-lock",
          "447:         {// read the input until we hit preamble",
          "449:             byte[][] preambles = new byte[][]{Channel.Mode.BINARY.preamble, Channel.Mode.TEXT.preamble, Capability.PREAMBLE};",
          "450:             int[] ptr=new int[3];",
          "451:             Capability cap = new Capability(0); // remote capacity that we obtained. If we don't hear from remote, assume no capability",
          "453:             while(true) {",
          "455:                 if(ch==-1)",
          "458:                 for(int i=0;i<preambles.length;i++) {",
          "460:                     if(preamble[ptr[i]]==ch) {",
          "461:                         if(++ptr[i]==preamble.length) {",
          "463:                             case 0:",
          "464:                             case 1:",
          "465:                                 LOGGER.log(Level.FINER, \"Received mode preamble: {0}\", modes[i]);",
          "467:                                 if (mode == Channel.Mode.NEGOTIATE) {",
          "469:                                     mode = modes[i];",
          "470:                                     LOGGER.log(Level.FINER, \"Sending agreed mode preamble: {0}\", mode);",
          "471:                                     os.write(mode.preamble);",
          "472:                                     os.flush();    // make sure that stream preamble is sent to the other end. avoids dead-lock",
          "473:                                 } else {",
          "474:                                     if(modes[i]!=mode)",
          "475:                                         throw new IOException(\"Protocol negotiation failure\");",
          "476:                                 }",
          "477:                                 LOGGER.log(Level.FINE, \"Channel name {0} negotiated mode {1} with capability {2}\",",
          "478:                                         new Object[]{name, mode, cap});",
          "480:                                 return makeTransport(is, os, mode, cap);",
          "481:                             case 2:",
          "482:                                 cap = Capability.read(is);",
          "483:                                 LOGGER.log(Level.FINER, \"Received capability preamble: {0}\", cap);",
          "484:                                 break;",
          "485:                             default:",
          "486:                                 throw new IllegalStateException(\"Unexpected preamble byte #\" + i +",
          "487:                                         \". Only \" + preambles.length + \" bytes are supported\");",
          "489:                             ptr[i]=0; // reset",
          "493:                         ptr[i]=0;",
          "497:                 if(header!=null)",
          "",
          "[Added Lines]",
          "462:             os.flush(); // make sure that stream preamble is sent to the other end. avoids dead-lock",
          "467:         { // read the input until we hit preamble",
          "469:             byte[][] preambles =",
          "470:                     new byte[][] {Channel.Mode.BINARY.preamble, Channel.Mode.TEXT.preamble, Capability.PREAMBLE};",
          "471:             int[] ptr = new int[3];",
          "472:             Capability cap = new Capability(",
          "473:                     0); // remote capacity that we obtained. If we don't hear from remote, assume no capability",
          "475:             while (true) {",
          "477:                 if (ch == -1) {",
          "479:                 }",
          "481:                 for (int i = 0; i < preambles.length; i++) {",
          "483:                     if (preamble[ptr[i]] == ch) {",
          "484:                         if (++ptr[i] == preamble.length) {",
          "486:                                 case 0:",
          "487:                                 case 1:",
          "488:                                     LOGGER.log(Level.FINER, \"Received mode preamble: {0}\", modes[i]);",
          "490:                                     if (mode == Channel.Mode.NEGOTIATE) {",
          "492:                                         mode = modes[i];",
          "493:                                         LOGGER.log(Level.FINER, \"Sending agreed mode preamble: {0}\", mode);",
          "494:                                         os.write(mode.preamble);",
          "495:                                         os.flush(); // make sure that stream preamble is sent to the other end.",
          "497:                                     } else {",
          "498:                                         if (modes[i] != mode) {",
          "499:                                             throw new IOException(\"Protocol negotiation failure\");",
          "500:                                         }",
          "501:                                     }",
          "502:                                     LOGGER.log(",
          "503:                                             Level.FINE,",
          "504:                                             \"Channel name {0} negotiated mode {1} with capability {2}\",",
          "505:                                             new Object[] {name, mode, cap});",
          "507:                                     return makeTransport(is, os, mode, cap);",
          "508:                                 case 2:",
          "509:                                     cap = Capability.read(is);",
          "510:                                     LOGGER.log(Level.FINER, \"Received capability preamble: {0}\", cap);",
          "511:                                     break;",
          "512:                                 default:",
          "513:                                     throw new IllegalStateException(\"Unexpected preamble byte #\" + i + \". Only \"",
          "514:                                             + preambles.length + \" bytes are supported\");",
          "516:                             ptr[i] = 0; // reset",
          "520:                         ptr[i] = 0;",
          "524:                 if (header != null) {",
          "526:                 }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "516:         FlightRecorderInputStream fis = new FlightRecorderInputStream(is);",
          "519:             return new ChunkedCommandTransport(cap, mode.wrap(fis), mode.wrap(os), os);",
          "521:             ObjectOutputStream oos = AnonymousClassWarnings.checkingObjectOutputStream(mode.wrap(os));",
          "524:             return new ClassicCommandTransport(",
          "527:         }",
          "528:     }",
          "529: }",
          "",
          "[Removed Lines]",
          "515:     protected CommandTransport makeTransport(InputStream is, OutputStream os, Channel.Mode mode, Capability cap) throws IOException {",
          "518:         if (cap.supportsChunking())",
          "520:         else {",
          "522:             oos.flush();    // make sure that stream preamble is sent to the other end. avoids dead-lock",
          "525:                     new ObjectInputStreamEx(mode.wrap(fis),getBaseLoader(),getClassFilter()),",
          "526:                     oos,fis,os,cap);",
          "",
          "[Added Lines]",
          "543:     protected CommandTransport makeTransport(InputStream is, OutputStream os, Channel.Mode mode, Capability cap)",
          "544:             throws IOException {",
          "547:         if (cap.supportsChunking()) {",
          "549:         } else {",
          "551:             oos.flush(); // make sure that stream preamble is sent to the other end. avoids dead-lock",
          "554:                     new ObjectInputStreamEx(mode.wrap(fis), getBaseLoader(), getClassFilter()), oos, fis, os, cap);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChannelClosedException.java||src/main/java/hudson/remoting/ChannelClosedException.java": [
          "File: src/main/java/hudson/remoting/ChannelClosedException.java -> src/main/java/hudson/remoting/ChannelClosedException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:         super(channel, message, cause);",
          "66:     }",
          "67: }",
          "",
          "[Removed Lines]",
          "64:     public ChannelClosedException(@CheckForNull Channel channel, @NonNull String message, @CheckForNull Throwable cause) {",
          "",
          "[Added Lines]",
          "64:     public ChannelClosedException(",
          "65:             @CheckForNull Channel channel, @NonNull String message, @CheckForNull Throwable cause) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Checksum.java||src/main/java/hudson/remoting/Checksum.java": [
          "File: src/main/java/hudson/remoting/Checksum.java -> src/main/java/hudson/remoting/Checksum.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:     private Checksum(byte[] arrayOf16bytes, int numOfLong) {",
          "29:         try {",
          "30:             DataInputStream in = new DataInputStream(new ByteArrayInputStream(arrayOf16bytes));",
          "33:                 long l = in.readLong();",
          "35:                     l1 ^= l;",
          "37:                     l2 ^= l;",
          "38:             }",
          "39:             sum1 = l1;",
          "40:             sum2 = l2;",
          "",
          "[Removed Lines]",
          "31:             long l1=0,l2=0;",
          "32:             for (int i=0; i<numOfLong; i++) {",
          "34:                 if (i%2==0)",
          "36:                 else",
          "",
          "[Added Lines]",
          "31:             long l1 = 0, l2 = 0;",
          "32:             for (int i = 0; i < numOfLong; i++) {",
          "34:                 if (i % 2 == 0) {",
          "36:                 } else {",
          "38:                 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:         if (o instanceof Checksum) {",
          "49:             Checksum that = (Checksum) o;",
          "50:             return sum1 == that.sum1 && sum2 == that.sum2;",
          "52:             return false;",
          "53:     }",
          "55:     @Override",
          "",
          "[Removed Lines]",
          "51:         } else",
          "",
          "[Added Lines]",
          "52:         } else {",
          "54:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:     @Override",
          "62:     public String toString() {",
          "64:     }",
          "",
          "[Removed Lines]",
          "63:         return String.format(\"%016X%016X\",sum1,sum2);",
          "",
          "[Added Lines]",
          "65:         return String.format(\"%016X%016X\", sum1, sum2);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:     static Checksum forURL(URL url) throws IOException {",
          "78:         try {",
          "79:             MessageDigest md = MessageDigest.getInstance(JarLoaderImpl.DIGEST_ALGORITHM);",
          "81:                 Util.copy(istream, ostream);",
          "82:                 return new Checksum(md.digest(), md.getDigestLength() / 8);",
          "83:             }",
          "",
          "[Removed Lines]",
          "76:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"This is only used for managing the jar cache as files, not URLs.\")",
          "80:             try(InputStream istream = url.openStream(); OutputStream ostream = new DigestOutputStream(OutputStream.nullOutputStream(), md)) {",
          "",
          "[Added Lines]",
          "78:     @SuppressFBWarnings(",
          "79:             value = \"URLCONNECTION_SSRF_FD\",",
          "80:             justification = \"This is only used for managing the jar cache as files, not URLs.\")",
          "84:             try (InputStream istream = url.openStream();",
          "85:                     OutputStream ostream = new DigestOutputStream(OutputStream.nullOutputStream(), md)) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChunkHeader.java||src/main/java/hudson/remoting/ChunkHeader.java": [
          "File: src/main/java/hudson/remoting/ChunkHeader.java -> src/main/java/hudson/remoting/ChunkHeader.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     }",
          "40:     public static int parse(int b1, int b2) {",
          "42:     }",
          "44:     public static boolean isLast(int header) {",
          "46:     }",
          "48:     public static int length(int header) {",
          "50:     }",
          "52:     public static void write(ByteBuffer buf, int length, boolean hasMore) {",
          "",
          "[Removed Lines]",
          "41:         return ((b1&0xFF)<<8) | (b2&0xFF);",
          "45:         return (header&0x8000)==0;",
          "49:         return header&0x7FFF;",
          "",
          "[Added Lines]",
          "41:         return ((b1 & 0xFF) << 8) | (b2 & 0xFF);",
          "45:         return (header & 0x8000) == 0;",
          "49:         return header & 0x7FFF;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     public static byte[] pack(int length, boolean hasMore) {",
          "63:         byte[] header = new byte[SIZE];",
          "66:         return header;",
          "67:     }",
          "68: }",
          "",
          "[Removed Lines]",
          "64:         header[0] = (byte)((hasMore?0x80:0)|(length>>8));",
          "65:         header[1] = (byte)(length);",
          "",
          "[Added Lines]",
          "64:         header[0] = (byte) ((hasMore ? 0x80 : 0) | (length >> 8));",
          "65:         header[1] = (byte) (length);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChunkedCommandTransport.java||src/main/java/hudson/remoting/ChunkedCommandTransport.java": [
          "File: src/main/java/hudson/remoting/ChunkedCommandTransport.java -> src/main/java/hudson/remoting/ChunkedCommandTransport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:     private final OutputStream rawOut;",
          "25:         this.remoteCapability = remoteCapability;",
          "26:         this.in = new ChunkedInputStream(in);",
          "28:         this.rawOut = rawOut;",
          "29:     }",
          "",
          "[Removed Lines]",
          "27:         this.out = new ChunkedOutputStream(8192,out);",
          "",
          "[Added Lines]",
          "25:             Capability remoteCapability, InputStream in, OutputStream out, OutputStream rawOut) {",
          "28:         this.out = new ChunkedOutputStream(8192, out);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChunkedInputStream.java||src/main/java/hudson/remoting/ChunkedInputStream.java": [
          "File: src/main/java/hudson/remoting/ChunkedInputStream.java -> src/main/java/hudson/remoting/ChunkedInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     @Override",
          "34:     public int read() throws IOException {",
          "36:         int x = base.read();",
          "37:         remaining--;",
          "38:         return x;",
          "",
          "[Removed Lines]",
          "35:         if (nextPayload())   return -1;",
          "",
          "[Added Lines]",
          "35:         if (nextPayload()) {",
          "36:             return -1;",
          "37:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41:     @Override",
          "42:     public int read(@NonNull byte[] b, int off, int len) throws IOException {",
          "50:         remaining -= x;",
          "51:         return x;",
          "",
          "[Removed Lines]",
          "43:         if (nextPayload())   return -1;",
          "45:         len = Math.min(remaining,len);",
          "47:         int x = base.read(b,off,len);",
          "48:         if (x<0)    return x;",
          "",
          "[Added Lines]",
          "45:         if (nextPayload()) {",
          "46:             return -1;",
          "47:         }",
          "49:         len = Math.min(remaining, len);",
          "51:         int x = base.read(b, off, len);",
          "52:         if (x < 0) {",
          "53:             return x;",
          "54:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57:     private boolean nextPayload() throws IOException {",
          "60:                 return true;",
          "61:         }",
          "62:         return false;",
          "63:     }",
          "",
          "[Removed Lines]",
          "58:         while (remaining==0) {",
          "59:             if (readHeader())",
          "",
          "[Added Lines]",
          "64:         while (remaining == 0) {",
          "65:             if (readHeader()) {",
          "67:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:     private boolean readHeader() throws IOException {",
          "73:         int b1 = base.read();",
          "74:         int b2 = base.read();",
          "77:         int header = ChunkHeader.parse(b1, b2);",
          "79:             onBreak();",
          "80:         remaining = ChunkHeader.length(header);",
          "81:         return false;",
          "82:     }",
          "",
          "[Removed Lines]",
          "71:         if (remaining>0)    return false;",
          "75:         if (b1<0 || b2<0) return true; // EOF",
          "78:         if (isLast=ChunkHeader.isLast(header))",
          "",
          "[Added Lines]",
          "78:         if (remaining > 0) {",
          "79:             return false;",
          "80:         }",
          "84:         if (b1 < 0 || b2 < 0) {",
          "85:             return true; // EOF",
          "86:         }",
          "89:         if (isLast = ChunkHeader.isLast(header)) {",
          "91:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "87:     protected void onBreak() {",
          "88:     }",
          "",
          "[Added Lines]",
          "99:     protected void onBreak() {}",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "93:     public void readUntilBreak(OutputStream sink) throws IOException {",
          "94:         byte[] buf = new byte[4096];",
          "95:         while (true) {",
          "100:                     throw new IOException(\"Unexpected EOF\");",
          "102:             } else {",
          "106:             }",
          "108:                 return; // we've read the all payload of the last chunk",
          "109:         }",
          "110:     }",
          "",
          "[Removed Lines]",
          "96:             if (remaining>0) {",
          "98:                 int read = read(buf, 0, Math.min(remaining,buf.length));",
          "99:                 if (read==-1)",
          "101:                 sink.write(buf,0,read);",
          "104:                 if (readHeader())",
          "105:                     return;     // stream has EOFed. No more bytes to read.",
          "107:             if (isLast && remaining==0)",
          "",
          "[Added Lines]",
          "107:             if (remaining > 0) {",
          "109:                 int read = read(buf, 0, Math.min(remaining, buf.length));",
          "110:                 if (read == -1) {",
          "112:                 }",
          "113:                 sink.write(buf, 0, read);",
          "116:                 if (readHeader()) {",
          "117:                     return; // stream has EOFed. No more bytes to read.",
          "118:                 }",
          "120:             if (isLast && remaining == 0) {",
          "122:             }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ChunkedOutputStream.java||src/main/java/hudson/remoting/ChunkedOutputStream.java": [
          "File: src/main/java/hudson/remoting/ChunkedOutputStream.java -> src/main/java/hudson/remoting/ChunkedOutputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     private int capacity() {",
          "41:     }",
          "43:     @Override",
          "44:     public void write(int b) throws IOException {",
          "46:         drain();",
          "47:     }",
          "49:     @Override",
          "50:     public void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "57:             drain();",
          "58:         }",
          "59:     }",
          "",
          "[Removed Lines]",
          "40:         return buf.length-size;",
          "45:         buf[size++] = (byte)b;",
          "51:         while (len>0) {",
          "52:             int s = Math.min(capacity(),len);",
          "53:             System.arraycopy(b,off,buf,size,s);",
          "54:             off+=s;",
          "55:             len-=s;",
          "56:             size+=s;",
          "",
          "[Added Lines]",
          "40:         return buf.length - size;",
          "45:         buf[size++] = (byte) b;",
          "51:         while (len > 0) {",
          "52:             int s = Math.min(capacity(), len);",
          "53:             System.arraycopy(b, off, buf, size, s);",
          "54:             off += s;",
          "55:             len -= s;",
          "56:             size += s;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     @Override",
          "70:     public void flush() throws IOException {",
          "72:             sendFrame(true);",
          "73:             base.flush();",
          "74:         }",
          "",
          "[Removed Lines]",
          "71:         if (size>0) {",
          "",
          "[Added Lines]",
          "71:         if (size > 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "86:     private void drain() throws IOException {",
          "88:             sendFrame(true);",
          "89:     }",
          "91:     private void sendFrame(boolean hasMore) throws IOException {",
          "94:         size = 0;",
          "95:     }",
          "96: }",
          "",
          "[Removed Lines]",
          "87:         if (capacity()==0)",
          "92:         base.write(ChunkHeader.pack(size,hasMore));",
          "93:         base.write(buf,0,size);",
          "",
          "[Added Lines]",
          "87:         if (capacity() == 0) {",
          "89:         }",
          "93:         base.write(ChunkHeader.pack(size, hasMore));",
          "94:         base.write(buf, 0, size);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ClassFilter.java||src/main/java/hudson/remoting/ClassFilter.java": [
          "File: src/main/java/hudson/remoting/ClassFilter.java -> src/main/java/hudson/remoting/ClassFilter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:     @Deprecated",
          "38:     private static final Logger LOGGER = Logger.getLogger(ClassFilter.class.getName());",
          "",
          "[Removed Lines]",
          "36:     public static final String FILE_OVERRIDE_LOCATION_PROPERTY = \"hudson.remoting.ClassFilter.DEFAULTS_OVERRIDE_LOCATION\";",
          "",
          "[Added Lines]",
          "36:     public static final String FILE_OVERRIDE_LOCATION_PROPERTY =",
          "37:             \"hudson.remoting.ClassFilter.DEFAULTS_OVERRIDE_LOCATION\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "176:     public static final ClassFilter NONE = new ClassFilter() {",
          "177:     };",
          "",
          "[Added Lines]",
          "178:     public static final ClassFilter NONE = new ClassFilter() {};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "190:                 LOGGER.log(Level.FINE, \"Using default in built class blacklisting\");",
          "191:                 return new RegExpClassFilter(DEFAULT_PATTERNS);",
          "192:             }",
          "196:             LOGGER.log(Level.SEVERE, \"Failed to initialize the default class filter\", e);",
          "197:             throw e;",
          "",
          "[Removed Lines]",
          "193:         }",
          "194:         catch (Error e) {",
          "",
          "[Added Lines]",
          "194:         } catch (Error e) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "201:     @CheckForNull",
          "202:     private static List<String> loadPatternOverride() {",
          "203:         String prop = System.getProperty(FILE_OVERRIDE_LOCATION_PROPERTY);",
          "205:             return null;",
          "206:         }",
          "208:         LOGGER.log(Level.FINE, \"Attempting to load user provided overrides for ClassFiltering from ''{0}''.\", prop);",
          "209:         File f = new File(prop);",
          "210:         if (!f.exists() || !f.canRead()) {",
          "212:         }",
          "214:         BufferedReader br = null;",
          "",
          "[Removed Lines]",
          "204:         if (prop==null) {",
          "211:             throw new Error(\"Could not load user provided overrides for ClassFiltering from as \" + prop + \" does not exist or is not readable.\");",
          "",
          "[Added Lines]",
          "204:         if (prop == null) {",
          "211:             throw new Error(\"Could not load user provided overrides for ClassFiltering from as \" + prop",
          "212:                     + \" does not exist or is not readable.\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "220:                     Pattern.compile(line);",
          "221:                     patterns.add(line);",
          "222:                 } catch (PatternSyntaxException pex) {",
          "224:                 }",
          "225:             }",
          "226:             return patterns;",
          "227:         } catch (IOException ex) {",
          "229:         } finally {",
          "230:             if (br != null) {",
          "231:                 try {",
          "",
          "[Removed Lines]",
          "223:                     throw new Error(\"Error compiling blacklist expressions - '\" + line + \"' is not a valid regular expression.\", pex);",
          "228:             throw new Error(\"Could not load user provided overrides for ClassFiltering from as \"+prop+\" does not exist or is not readable.\",ex);",
          "",
          "[Added Lines]",
          "224:                     throw new Error(",
          "225:                             \"Error compiling blacklist expressions - '\" + line + \"' is not a valid regular expression.\",",
          "226:                             pex);",
          "231:             throw new Error(",
          "232:                     \"Could not load user provided overrides for ClassFiltering from as \" + prop",
          "233:                             + \" does not exist or is not readable.\",",
          "234:                     ex);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "244:     private static final class RegExpClassFilter extends ClassFilter {",
          "",
          "[Removed Lines]",
          "243:     @SuppressFBWarnings(value = \"REDOS\", justification = \"In an odd usage, this pattern is used to determine if another pattern matches it and not to match a string to it. REDOS doesn't apply.\")",
          "",
          "[Added Lines]",
          "249:     @SuppressFBWarnings(",
          "250:             value = \"REDOS\",",
          "251:             justification =",
          "252:                     \"In an odd usage, this pattern is used to determine if another pattern matches it and not to match a string to it. REDOS doesn't apply.\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "251:         private static final Pattern OPTIMIZE1 = Pattern.compile(",
          "252:                 \"^\\\\^(([\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*(\\\\.|\\\\[\\\\.\\\\])?)+)\\\\.\\\\*$\");",
          "",
          "[Added Lines]",
          "260:         private static final Pattern OPTIMIZE1 =",
          "261:                 Pattern.compile(\"^\\\\^(([\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*(\\\\.|\\\\[\\\\.\\\\])?)+)\\\\.\\\\*$\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "288:         @Override",
          "289:         public boolean isBlacklisted(@NonNull String name) {",
          "290:             for (Object p : blacklistPatterns) {",
          "292:                     return true;",
          "294:                     return true;",
          "295:                 }",
          "296:             }",
          "",
          "[Removed Lines]",
          "291:                 if (p instanceof Pattern && ((Pattern)p).matcher(name).matches()) {",
          "293:                 } else if (p instanceof String && name.startsWith((String)p)) {",
          "",
          "[Added Lines]",
          "300:                 if (p instanceof Pattern && ((Pattern) p).matcher(name).matches()) {",
          "302:                 } else if (p instanceof String && name.startsWith((String) p)) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ClassLoaderHolder.java||src/main/java/hudson/remoting/ClassLoaderHolder.java": [
          "File: src/main/java/hudson/remoting/ClassLoaderHolder.java -> src/main/java/hudson/remoting/ClassLoaderHolder.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:         this.classLoader = classLoader;",
          "23:     }",
          "28:     @CheckForNull",
          "29:     public ClassLoader get() {",
          "",
          "[Removed Lines]",
          "25:     public ClassLoaderHolder() {",
          "26:     }",
          "",
          "[Added Lines]",
          "25:     public ClassLoaderHolder() {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {",
          "38:         RemoteClassLoader.IClassLoader proxy = (RemoteClassLoader.IClassLoader) ois.readObject();",
          "40:     }",
          "43:             justification = \"RemoteClassLoader.export() produces a serializable wrapper class\")",
          "44:     private void writeObject(ObjectOutputStream oos) throws IOException {",
          "46:             oos.writeObject(null);",
          "48:             RemoteClassLoader.IClassLoader proxy = RemoteClassLoader.export(classLoader, getChannelForSerialization());",
          "49:             oos.writeObject(proxy);",
          "50:         }",
          "",
          "[Removed Lines]",
          "39:         classLoader = proxy==null ? null : getChannelForSerialization().importedClassLoaders.get(proxy);",
          "42:     @SuppressFBWarnings(value = \"DMI_NONSERIALIZABLE_OBJECT_WRITTEN\",",
          "45:         if (classLoader==null)",
          "47:         else {",
          "",
          "[Added Lines]",
          "38:         classLoader = proxy == null",
          "39:                 ? null",
          "40:                 : getChannelForSerialization().importedClassLoaders.get(proxy);",
          "43:     @SuppressFBWarnings(",
          "44:             value = \"DMI_NONSERIALIZABLE_OBJECT_WRITTEN\",",
          "47:         if (classLoader == null) {",
          "49:         } else {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ClassicCommandTransport.java||src/main/java/hudson/remoting/ClassicCommandTransport.java": [
          "File: src/main/java/hudson/remoting/ClassicCommandTransport.java -> src/main/java/hudson/remoting/ClassicCommandTransport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:     private final OutputStream rawOut;",
          "38:         this.ois = ois;",
          "39:         this.oos = oos;",
          "41:         this.rawOut = rawOut;",
          "42:         this.remoteCapability = remoteCapability;",
          "43:     }",
          "",
          "[Removed Lines]",
          "30:     private final @Nullable",
          "31:     FlightRecorderInputStream rawIn;",
          "40:         this.rawIn= rawIn;",
          "",
          "[Added Lines]",
          "30:     private final @Nullable FlightRecorderInputStream rawIn;",
          "37:             ObjectInputStream ois,",
          "38:             ObjectOutputStream oos,",
          "39:             @CheckForNull FlightRecorderInputStream rawIn,",
          "40:             OutputStream rawOut,",
          "41:             Capability remoteCapability) {",
          "44:         this.rawIn = rawIn;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     @Override",
          "51:     public final void write(Command cmd, boolean last) throws IOException {",
          "",
          "[Removed Lines]",
          "52:         cmd.writeTo(channel,oos);",
          "54:         oos.flush();        // make sure the command reaches the other end.",
          "",
          "[Added Lines]",
          "56:         cmd.writeTo(channel, oos);",
          "58:         oos.flush(); // make sure the command reaches the other end.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:             oos.reset();",
          "64:     }",
          "66:     @Override",
          "",
          "[Removed Lines]",
          "62:         if(!last)",
          "",
          "[Added Lines]",
          "66:         if (!last) {",
          "68:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:         try {",
          "74:             Command cmd = Command.readFromObjectStream(channel, ois);",
          "77:                 rawIn.clear();",
          "78:             return cmd;",
          "80:             throw diagnoseStreamCorruption(e);",
          "81:         }",
          "82:     }",
          "",
          "[Removed Lines]",
          "76:             if (rawIn!=null)",
          "79:         } catch (RuntimeException | StreamCorruptedException e) {// see JENKINS-19046",
          "",
          "[Added Lines]",
          "81:             if (rawIn != null) {",
          "83:             }",
          "85:         } catch (RuntimeException | StreamCorruptedException e) { // see JENKINS-19046",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "88:     private StreamCorruptedException diagnoseStreamCorruption(Exception e) {",
          "94:         }",
          "97:     }",
          "99:     @Override",
          "",
          "[Removed Lines]",
          "89:         if (rawIn==null) {// no source of diagnostics information. can't diagnose.",
          "90:             if (e instanceof StreamCorruptedException)",
          "91:                 return (StreamCorruptedException)e;",
          "92:             else",
          "93:                 return (StreamCorruptedException)new StreamCorruptedException().initCause(e);",
          "96:         return rawIn.analyzeCrash(e,(channel!=null ? channel : this).toString());",
          "",
          "[Added Lines]",
          "95:         if (rawIn == null) { // no source of diagnostics information. can't diagnose.",
          "96:             if (e instanceof StreamCorruptedException) {",
          "97:                 return (StreamCorruptedException) e;",
          "98:             } else {",
          "99:                 return (StreamCorruptedException) new StreamCorruptedException().initCause(e);",
          "100:             }",
          "103:         return rawIn.analyzeCrash(e, (channel != null ? channel : this).toString());",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Command.java||src/main/java/hudson/remoting/Command.java": [
          "File: src/main/java/hudson/remoting/Command.java -> src/main/java/hudson/remoting/Command.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:     Command(boolean recordCreatedAt) {",
          "80:             this.createdAt = new Source();",
          "82:             this.createdAt = null;",
          "83:     }",
          "",
          "[Removed Lines]",
          "79:         if(recordCreatedAt)",
          "81:         else",
          "",
          "[Added Lines]",
          "79:         if (recordCreatedAt) {",
          "81:         } else {",
          "83:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:             throws IOException, ClassNotFoundException {",
          "144:         channel.notifyRead(cmd, payloadSize);",
          "145:         return cmd;",
          "146:     }",
          "152:         Channel old = Channel.setCurrent(channel);",
          "153:         try {",
          "155:         } finally {",
          "156:             Channel.setCurrent(old);",
          "157:         }",
          "",
          "[Removed Lines]",
          "141:         Command cmd = Command.readFromObjectStream(channel, new ObjectInputStreamEx(",
          "142:                 istream,",
          "143:                 channel.baseClassLoader,channel.classFilter));",
          "150:     @SuppressFBWarnings(value = \"OBJECT_DESERIALIZATION\", justification = \"Used for sending commands between authorized agent and server. Class filtering is done through JEP-200.\")",
          "151:     static Command readFromObjectStream(Channel channel, ObjectInputStream ois) throws IOException, ClassNotFoundException {",
          "154:             return (Command)ois.readObject();",
          "",
          "[Added Lines]",
          "141:         Command cmd = Command.readFromObjectStream(",
          "142:                 channel, new ObjectInputStreamEx(istream, channel.baseClassLoader, channel.classFilter));",
          "148:     @SuppressFBWarnings(",
          "149:             value = \"OBJECT_DESERIALIZATION\",",
          "150:             justification =",
          "151:                     \"Used for sending commands between authorized agent and server. Class filtering is done through JEP-200.\")",
          "152:     static Command readFromObjectStream(Channel channel, ObjectInputStream ois)",
          "153:             throws IOException, ClassNotFoundException {",
          "156:             return (Command) ois.readObject();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "177:     private static final long serialVersionUID = 1L;",
          "179:     private final class Source extends Exception {",
          "183:         private Source(@CheckForNull Throwable cause) {",
          "184:             super(cause);",
          "",
          "[Removed Lines]",
          "180:         public Source() {",
          "181:         }",
          "",
          "[Added Lines]",
          "182:         public Source() {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/CommandTransport.java||src/main/java/hudson/remoting/CommandTransport.java": [
          "File: src/main/java/hudson/remoting/CommandTransport.java -> src/main/java/hudson/remoting/CommandTransport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: public abstract class CommandTransport {",
          "",
          "[Removed Lines]",
          "54:     protected CommandTransport() {",
          "55:     }",
          "",
          "[Added Lines]",
          "54:     protected CommandTransport() {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/DaemonThreadFactory.java||src/main/java/hudson/remoting/DaemonThreadFactory.java": [
          "File: src/main/java/hudson/remoting/DaemonThreadFactory.java -> src/main/java/hudson/remoting/DaemonThreadFactory.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:     public Thread newThread(@NonNull Runnable r) {",
          "16:         Thread thread = new Thread(r);",
          "17:         thread.setDaemon(true);",
          "19:         return thread;",
          "20:     }",
          "21: }",
          "",
          "[Removed Lines]",
          "18:         thread.setUncaughtExceptionHandler((t, e) -> LOGGER.log(Level.SEVERE, e, () -> \"Unhandled exception in thread \" + t));",
          "",
          "[Added Lines]",
          "18:         thread.setUncaughtExceptionHandler(",
          "19:                 (t, e) -> LOGGER.log(Level.SEVERE, e, () -> \"Unhandled exception in thread \" + t));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/DelegatingCallable.java||src/main/java/hudson/remoting/DelegatingCallable.java": [
          "File: src/main/java/hudson/remoting/DelegatingCallable.java -> src/main/java/hudson/remoting/DelegatingCallable.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:     @CheckForNull",
          "",
          "[Removed Lines]",
          "46: public interface DelegatingCallable<V,T extends Throwable> extends Callable<V,T> {",
          "",
          "[Added Lines]",
          "46: public interface DelegatingCallable<V, T extends Throwable> extends Callable<V, T> {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/DelegatingExecutorService.java||src/main/java/hudson/remoting/DelegatingExecutorService.java": [
          "File: src/main/java/hudson/remoting/DelegatingExecutorService.java -> src/main/java/hudson/remoting/DelegatingExecutorService.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:     @Override",
          "76:     @NonNull",
          "78:         return base.invokeAll(tasks, timeout, unit);",
          "79:     }",
          "81:     @Override",
          "82:     @NonNull",
          "84:         return base.invokeAny(tasks);",
          "85:     }",
          "87:     @Override",
          "89:         return base.invokeAny(tasks, timeout, unit);",
          "90:     }",
          "",
          "[Removed Lines]",
          "77:     public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit) throws InterruptedException {",
          "83:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {",
          "88:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "77:     public <T> List<Future<T>> invokeAll(",
          "78:             @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)",
          "79:             throws InterruptedException {",
          "85:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)",
          "86:             throws InterruptedException, ExecutionException {",
          "91:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)",
          "92:             throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java||src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java": [
          "File: src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java -> src/main/java/hudson/remoting/DiagnosedStreamCorruptionException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:     @NonNull",
          "21:     private final byte[] readAhead;",
          "25:         initCause(cause);",
          "26:         this.diagnoseFailure = diagnoseFailure;",
          "27:         this.readBack = readBack;",
          "",
          "[Removed Lines]",
          "23:     DiagnosedStreamCorruptionException(Exception cause, Exception diagnoseFailure,",
          "24:             @NonNull byte[] readBack, @NonNull byte[] readAhead) {",
          "",
          "[Added Lines]",
          "23:     DiagnosedStreamCorruptionException(",
          "24:             Exception cause, Exception diagnoseFailure, @NonNull byte[] readBack, @NonNull byte[] readAhead) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:     }",
          "45:     @Override",
          "47:     public String toString() {",
          "48:         StringBuilder buf = new StringBuilder();",
          "49:         buf.append(super.toString()).append(\"\\n\");",
          "50:         buf.append(\"Read back: \").append(HexDump.toHex(readBack)).append('\\n');",
          "51:         buf.append(\"Read ahead: \").append(HexDump.toHex(readAhead));",
          "53:             StringWriter w = new StringWriter();",
          "54:             PrintWriter p = new PrintWriter(w);",
          "55:             diagnoseFailure.printStackTrace(p);",
          "56:             p.flush();",
          "58:             buf.append(\"\\nDiagnosis problem:\\n    \");",
          "60:         }",
          "61:         return buf.toString();",
          "62:     }",
          "",
          "[Removed Lines]",
          "46:     @SuppressFBWarnings(value = \"INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE\", justification = \"Used for diagnosing stream corruption between agent and server.\")",
          "52:         if (diagnoseFailure!=null) {",
          "59:             buf.append(w.toString().trim().replace(\"\\n\",\"\\n    \"));",
          "",
          "[Added Lines]",
          "46:     @SuppressFBWarnings(",
          "47:             value = \"INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE\",",
          "48:             justification = \"Used for diagnosing stream corruption between agent and server.\")",
          "54:         if (diagnoseFailure != null) {",
          "61:             buf.append(w.toString().trim().replace(\"\\n\", \"\\n    \"));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/DumbClassLoaderBridge.java||src/main/java/hudson/remoting/DumbClassLoaderBridge.java": [
          "File: src/main/java/hudson/remoting/DumbClassLoaderBridge.java -> src/main/java/hudson/remoting/DumbClassLoaderBridge.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     @Override",
          "54:     public Map<String, RemoteClassLoader.ClassFile2> fetch3(String className) throws ClassNotFoundException {",
          "55:         RemoteClassLoader.ClassFile cf = fetch2(className);",
          "58:     }",
          "60:     @Override",
          "61:     public RemoteClassLoader.ResourceFile getResource2(String name) throws IOException {",
          "62:         byte[] img = base.getResource(name);",
          "65:     }",
          "67:     @Override",
          "",
          "[Removed Lines]",
          "56:         return Map.of(className,",
          "57:                 new RemoteClassLoader.ClassFile2(cf.classLoader, new ResourceImageDirect(cf.classImage), null, null, null));",
          "63:         if (img==null)  return null;",
          "64:         return new RemoteClassLoader.ResourceFile(new ResourceImageDirect(img), null); // we are on the receiving side, so null is ok",
          "",
          "[Added Lines]",
          "56:         return Map.of(",
          "57:                 className,",
          "58:                 new RemoteClassLoader.ClassFile2(",
          "59:                         cf.classLoader, new ResourceImageDirect(cf.classImage), null, null, null));",
          "65:         if (img == null) {",
          "66:             return null;",
          "67:         }",
          "68:         return new RemoteClassLoader.ResourceFile(",
          "69:                 new ResourceImageDirect(img), null); // we are on the receiving side, so null is ok",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:         byte[][] r = base.getResources(name);",
          "71:         RemoteClassLoader.ResourceFile[] res = new RemoteClassLoader.ResourceFile[r.length];",
          "72:         for (int i = 0; i < res.length; i++) {",
          "74:         }",
          "75:         return res;",
          "76:     }",
          "",
          "[Removed Lines]",
          "73:             res[i] = new RemoteClassLoader.ResourceFile(new ResourceImageDirect(r[i]), null); // we are on the receiving side, so null is ok",
          "",
          "[Added Lines]",
          "78:             res[i] = new RemoteClassLoader.ResourceFile(",
          "79:                     new ResourceImageDirect(r[i]), null); // we are on the receiving side, so null is ok",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Engine.java||src/main/java/hudson/remoting/Engine.java": [
          "File: src/main/java/hudson/remoting/Engine.java -> src/main/java/hudson/remoting/Engine.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:                 r.run();",
          "140:             });",
          "141:             thread.setDaemon(true);",
          "143:             return thread;",
          "144:         }",
          "145:     });",
          "",
          "[Removed Lines]",
          "142:             thread.setUncaughtExceptionHandler((t, e) -> LOGGER.log(Level.SEVERE, e, () -> \"Uncaught exception in thread \" + t));",
          "",
          "[Added Lines]",
          "143:             thread.setUncaughtExceptionHandler(",
          "144:                     (t, e) -> LOGGER.log(Level.SEVERE, e, () -> \"Uncaught exception in thread \" + t));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:     public boolean failIfWorkDirIsMissing = WorkDirManager.DEFAULT_FAIL_IF_WORKDIR_IS_MISSING;",
          "260:     private final String directConnection;",
          "261:     private final String instanceIdentity;",
          "",
          "[Removed Lines]",
          "258:     private final DelegatingX509ExtendedTrustManager agentTrustManager = new DelegatingX509ExtendedTrustManager(new BlindTrustX509ExtendedTrustManager());",
          "",
          "[Added Lines]",
          "261:     private final DelegatingX509ExtendedTrustManager agentTrustManager =",
          "262:             new DelegatingX509ExtendedTrustManager(new BlindTrustX509ExtendedTrustManager());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "265:         this(listener, hudsonUrls, secretKey, agentName, null, null, null);",
          "266:     }",
          "270:         this.listener = listener;",
          "271:         this.directConnection = directConnection;",
          "272:         this.events.add(listener);",
          "274:         this.secretKey = secretKey;",
          "275:         this.agentName = agentName;",
          "276:         this.instanceIdentity = instanceIdentity;",
          "277:         this.protocols = protocols;",
          "279:             throw new IllegalArgumentException(\"No URLs given\");",
          "280:         }",
          "281:         setUncaughtExceptionHandler((t, e) -> {",
          "",
          "[Removed Lines]",
          "268:     public Engine(EngineListener listener, List<URL> hudsonUrls, String secretKey, String agentName, String directConnection, String instanceIdentity,",
          "269:                   Set<String> protocols) {",
          "273:         this.candidateUrls = hudsonUrls.stream().map(Engine::ensureTrailingSlash).collect(Collectors.toList());",
          "278:         if(candidateUrls.isEmpty() && instanceIdentity == null) {",
          "",
          "[Added Lines]",
          "272:     public Engine(",
          "273:             EngineListener listener,",
          "274:             List<URL> hudsonUrls,",
          "275:             String secretKey,",
          "276:             String agentName,",
          "277:             String directConnection,",
          "278:             String instanceIdentity,",
          "279:             Set<String> protocols) {",
          "283:         this.candidateUrls =",
          "284:                 hudsonUrls.stream().map(Engine::ensureTrailingSlash).collect(Collectors.toList());",
          "289:         if (candidateUrls.isEmpty() && instanceIdentity == null) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "323:                 workDirManager.disable(WorkDirManager.DirType.JAR_CACHE_DIR);",
          "324:             }",
          "326:             if (loggingConfigFilePath != null) {",
          "327:                 workDirManager.setLoggingConfig(loggingConfigFilePath.toFile());",
          "328:             }",
          "330:             final Path path = workDirManager.initializeWorkDir(workDir.toFile(), internalDir, failIfWorkDirIsMissing);",
          "331:             jarCacheDirectory = workDirManager.getLocation(WorkDirManager.DirType.JAR_CACHE_DIR);",
          "332:             workDirManager.setupLogging(path, agentLog);",
          "333:         } else if (jarCache == null) {",
          "335:             jarCacheDirectory = JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION;",
          "336:         }",
          "339:             if (jarCacheDirectory == null) {",
          "341:                 throw new IOException(\"Cannot find the JAR Cache location\");",
          "",
          "[Removed Lines]",
          "334:             LOGGER.log(Level.WARNING, \"No Working Directory. Using the legacy JAR Cache location: {0}\", JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION);",
          "338:         if (jarCache == null){",
          "",
          "[Added Lines]",
          "345:             LOGGER.log(",
          "346:                     Level.WARNING,",
          "347:                     \"No Working Directory. Using the legacy JAR Cache location: {0}\",",
          "348:                     JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION);",
          "352:         if (jarCache == null) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "484:     public void setFailIfWorkDirIsMissing(boolean failIfWorkDirIsMissing) { this.failIfWorkDirIsMissing = failIfWorkDirIsMissing; }",
          "",
          "[Added Lines]",
          "498:     public void setFailIfWorkDirIsMissing(boolean failIfWorkDirIsMissing) {",
          "499:         this.failIfWorkDirIsMissing = failIfWorkDirIsMissing;",
          "500:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "502:     }",
          "504:     public void setCandidateCertificates(List<X509Certificate> candidateCertificates) {",
          "508:     }",
          "510:     public void addCandidateCertificate(X509Certificate certificate) {",
          "",
          "[Removed Lines]",
          "505:         this.candidateCertificates = candidateCertificates == null",
          "506:                 ? null",
          "507:                 : new ArrayList<>(candidateCertificates);",
          "",
          "[Added Lines]",
          "521:         this.candidateCertificates = candidateCertificates == null ? null : new ArrayList<>(candidateCertificates);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "557:                 try {",
          "558:                     kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",
          "559:                 } catch (NoSuchAlgorithmException e) {",
          "561:                 }",
          "562:                 try {",
          "563:                     kmf.init(store, password);",
          "",
          "[Removed Lines]",
          "560:                     throw new IllegalStateException(\"Java runtime specification requires support for default key manager\", e);",
          "",
          "[Added Lines]",
          "574:                     throw new IllegalStateException(",
          "575:                             \"Java runtime specification requires support for default key manager\", e);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "565:                     throw new IllegalStateException(e);",
          "566:                 }",
          "567:                 try {",
          "569:                 } catch (KeyManagementException e) {",
          "570:                     events.error(e);",
          "571:                     return;",
          "",
          "[Removed Lines]",
          "568:                     context.init(kmf.getKeyManagers(), new TrustManager[]{agentTrustManager}, null);",
          "",
          "[Added Lines]",
          "583:                     context.init(kmf.getKeyManagers(), new TrustManager[] {agentTrustManager}, null);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "577:         }",
          "578:     }",
          "581:     private void runWebSocket() {",
          "582:         try {",
          "583:             String localCap = new Capability().toASCII();",
          "",
          "[Removed Lines]",
          "580:     @SuppressFBWarnings(value = {\"REC_CATCH_EXCEPTION\", \"URLCONNECTION_SSRF_FD\"}, justification = \"checked exceptions were a mistake to begin with; connecting to Jenkins from agent\")",
          "",
          "[Added Lines]",
          "595:     @SuppressFBWarnings(",
          "596:             value = {\"REC_CATCH_EXCEPTION\", \"URLCONNECTION_SSRF_FD\"},",
          "597:             justification = \"checked exceptions were a mistake to begin with; connecting to Jenkins from agent\")",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "607:                             VersionNumber minimumSupportedVersion = new VersionNumber(remotingMinimumVersion.get(0));",
          "608:                             VersionNumber currentVersion = new VersionNumber(Launcher.VERSION);",
          "609:                             if (currentVersion.isOlderThan(minimumSupportedVersion)) {",
          "611:                             }",
          "612:                         }",
          "613:                         try {",
          "",
          "[Removed Lines]",
          "610:                                 events.error(new IOException(\"Agent version \" + minimumSupportedVersion + \" or newer is required.\"));",
          "",
          "[Added Lines]",
          "629:                                 events.error(new IOException(",
          "630:                                         \"Agent version \" + minimumSupportedVersion + \" or newer is required.\"));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "631:                 }",
          "632:                 HeaderHandler headerHandler = new HeaderHandler();",
          "633:                 class AgentEndpoint extends Endpoint {",
          "635:                     AgentEndpoint.Transport transport;",
          "637:                     @Override",
          "",
          "[Removed Lines]",
          "634:                     @SuppressFBWarnings(value = \"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\", justification = \"just trust me here\")",
          "",
          "[Added Lines]",
          "654:                     @SuppressFBWarnings(",
          "655:                             value = \"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",",
          "656:                             justification = \"just trust me here\")",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "640:                         session.addMessageHandler(ByteBuffer.class, this::onMessage);",
          "641:                         try {",
          "642:                             transport = new Transport(session);",
          "646:                         } catch (IOException x) {",
          "647:                             events.error(x);",
          "648:                         }",
          "649:                     }",
          "650:                     private void onMessage(ByteBuffer message) {",
          "651:                         try {",
          "652:                             transport.receive(message);",
          "",
          "[Removed Lines]",
          "643:                             ch.set(new ChannelBuilder(agentName, executor).",
          "644:                                 withJarCacheOrDefault(jarCache). // unless EngineJnlpConnectionStateListener can be used for this purpose",
          "645:                                 build(transport));",
          "",
          "[Added Lines]",
          "665:                             ch.set(new ChannelBuilder(agentName, executor)",
          "666:                                     .withJarCacheOrDefault(jarCache)",
          "667:                                     . // unless EngineJnlpConnectionStateListener can be used for this purpose",
          "668:                                     build(transport));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "657:                             Thread.currentThread().interrupt();",
          "658:                         }",
          "659:                     }",
          "660:                     @Override",
          "663:                     public void onClose(Session session, CloseReason closeReason) {",
          "664:                         LOGGER.fine(() -> \"onClose: \" + closeReason);",
          "667:                         ch.get().executor.submit(() -> transport.terminate(new ChannelClosedException(ch.get(), null)));",
          "668:                     }",
          "669:                     @Override",
          "672:                     public void onError(Session session, Throwable x) {",
          "674:                         LOGGER.log(Level.FINE, null, x);",
          "",
          "[Removed Lines]",
          "661:                     @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "662:                             justification = \"We want the transport.terminate method to run asynchronously and don't want to wait for its status.\")",
          "670:                     @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "671:                             justification = \"We want the transport.terminate method to run asynchronously and don't want to wait for its status.\")",
          "",
          "[Added Lines]",
          "686:                     @SuppressFBWarnings(",
          "687:                             value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "688:                             justification =",
          "689:                                     \"We want the transport.terminate method to run asynchronously and don't want to wait for its status.\")",
          "698:                     @SuppressFBWarnings(",
          "699:                             value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "700:                             justification =",
          "701:                                     \"We want the transport.terminate method to run asynchronously and don't want to wait for its status.\")",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "679:                     class Transport extends AbstractByteBufferCommandTransport {",
          "680:                         final Session session;",
          "681:                         Transport(Session session) {",
          "682:                             super(true);",
          "683:                             this.session = session;",
          "684:                         }",
          "685:                         @Override",
          "686:                         protected void write(ByteBuffer headerAndData) throws IOException {",
          "688:                             try {",
          "690:                             } catch (Exception x) {",
          "691:                                 throw new IOException(x);",
          "692:                             }",
          "",
          "[Removed Lines]",
          "687:                             LOGGER.finest(() -> \"sending message of length \" + (headerAndData.remaining() - ChunkHeader.SIZE));",
          "689:                                 session.getAsyncRemote().sendBinary(headerAndData).get(5, TimeUnit.MINUTES);",
          "",
          "[Added Lines]",
          "719:                             LOGGER.finest(() ->",
          "720:                                     \"sending message of length \" + (headerAndData.remaining() - ChunkHeader.SIZE));",
          "722:                                 session.getAsyncRemote()",
          "723:                                         .sendBinary(headerAndData)",
          "724:                                         .get(5, TimeUnit.MINUTES);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "717:                     String proxyHost = System.getProperty(\"http.proxyHost\", System.getenv(\"proxy_host\"));",
          "718:                     String proxyPort = System.getProperty(\"http.proxyPort\");",
          "720:                         URI proxyUri;",
          "721:                         if (proxyPort != null) {",
          "722:                             proxyUri = URI.create(String.format(\"http://%s:%s\", proxyHost, proxyPort));",
          "",
          "[Removed Lines]",
          "719:                     if (proxyHost != null && \"http\".equals(hudsonUrl.getProtocol()) && NoProxyEvaluator.shouldProxy(hudsonUrl.getHost())) {",
          "",
          "[Added Lines]",
          "756:                     if (proxyHost != null",
          "757:                             && \"http\".equals(hudsonUrl.getProtocol())",
          "758:                             && NoProxyEvaluator.shouldProxy(hudsonUrl.getHost())) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "725:                         }",
          "726:                         client.getProperties().put(ClientProperties.PROXY_URI, proxyUri);",
          "727:                         if (proxyCredentials != null) {",
          "729:                         }",
          "730:                     }",
          "",
          "[Removed Lines]",
          "728:                             client.getProperties().put(ClientProperties.PROXY_HEADERS, Map.of(\"Proxy-Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(proxyCredentials.getBytes(StandardCharsets.UTF_8))));",
          "",
          "[Added Lines]",
          "767:                             client.getProperties()",
          "768:                                     .put(",
          "769:                                             ClientProperties.PROXY_HEADERS,",
          "770:                                             Map.of(",
          "771:                                                     \"Proxy-Authorization\",",
          "772:                                                     \"Basic \"",
          "773:                                                             + Base64.getEncoder()",
          "774:                                                                     .encodeToString(proxyCredentials.getBytes(",
          "775:                                                                             StandardCharsets.UTF_8))));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "738:                         client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);",
          "739:                     }",
          "740:                 }",
          "743:                 while (ch.get() == null) {",
          "744:                     Thread.sleep(100);",
          "745:                 }",
          "",
          "[Removed Lines]",
          "741:                 container.connectToServer(new AgentEndpoint(),",
          "742:                     ClientEndpointConfig.Builder.create().configurator(headerHandler).build(), URI.create(wsUrl + \"wsagents/\"));",
          "",
          "[Added Lines]",
          "788:                 container.connectToServer(",
          "789:                         new AgentEndpoint(),",
          "790:                         ClientEndpointConfig.Builder.create()",
          "791:                                 .configurator(headerHandler)",
          "792:                                 .build(),",
          "793:                         URI.create(wsUrl + \"wsagents/\"));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "799:                 .withSSLContext(context)",
          "800:                 .withPreferNonBlockingIO(false) // we only have one connection, prefer blocking I/O",
          "801:                 .handlers();",
          "803:         headers.put(JnlpConnectionState.CLIENT_NAME_KEY, agentName);",
          "804:         headers.put(JnlpConnectionState.SECRET_KEY, secretKey);",
          "805:         List<String> jenkinsUrls = new ArrayList<>();",
          "807:             jenkinsUrls.add(url.toExternalForm());",
          "808:         }",
          "809:         JnlpEndpointResolver resolver = createEndpointResolver(jenkinsUrls, agentName);",
          "",
          "[Removed Lines]",
          "802:         final Map<String,String> headers = new HashMap<>();",
          "806:         for (URL url: candidateUrls) {",
          "",
          "[Added Lines]",
          "854:         final Map<String, String> headers = new HashMap<>();",
          "858:         for (URL url : candidateUrls) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "811:         try {",
          "812:             boolean first = true;",
          "813:             firstAttempt = Instant.now();",
          "816:                     first = false;",
          "817:                 } else {",
          "819:                         return; // exit",
          "820:                 }",
          "821:                 if (Util.shouldBailOut(firstAttempt, noReconnectAfter)) {",
          "822:                     events.status(\"Bailing out after \" + DurationFormatter.format(noReconnectAfter));",
          "",
          "[Removed Lines]",
          "814:             while(true) {",
          "815:                 if(first) {",
          "818:                     if(noReconnect)",
          "",
          "[Added Lines]",
          "866:             while (true) {",
          "867:                 if (first) {",
          "870:                     if (noReconnect) {",
          "872:                     }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "828:                     endpoint = resolver.resolve();",
          "829:                 } catch (IOException e) {",
          "830:                     if (!noReconnect) {",
          "833:                         TimeUnit.SECONDS.sleep(10);",
          "834:                         continue;",
          "835:                     } else {",
          "837:                             events.status(\"Could not resolve JNLP agent endpoint\", e);",
          "838:                         } else {",
          "839:                             events.error(e);",
          "",
          "[Removed Lines]",
          "831:                         events.status(\"Could not locate server among \" + candidateUrls + \"; waiting 10 seconds before retry\", e);",
          "836:                         if (Boolean.getBoolean(Engine.class.getName() + \".nonFatalJnlpAgentEndpointResolutionExceptions\")) {",
          "",
          "[Added Lines]",
          "884:                         events.status(",
          "885:                                 \"Could not locate server among \" + candidateUrls + \"; waiting 10 seconds before retry\",",
          "886:                                 e);",
          "891:                         if (Boolean.getBoolean(",
          "892:                                 Engine.class.getName() + \".nonFatalJnlpAgentEndpointResolutionExceptions\")) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "847:                 }",
          "848:                 hudsonUrl = endpoint.getServiceUrl();",
          "858:                 PublicKeyMatchingX509ExtendedTrustManager delegate = new PublicKeyMatchingX509ExtendedTrustManager();",
          "859:                 RSAPublicKey publicKey = endpoint.getPublicKey();",
          "860:                 if (publicKey != null) {",
          "",
          "[Removed Lines]",
          "850:                 events.status(String.format(\"Agent discovery successful%n\"",
          "851:                         + \"  Agent address: %s%n\"",
          "852:                         + \"  Agent port:    %d%n\"",
          "853:                         + \"  Identity:      %s\",",
          "854:                         endpoint.getHost(),",
          "855:                         endpoint.getPort(),",
          "856:                         KeyUtils.fingerprint(endpoint.getPublicKey()))",
          "857:                 );",
          "",
          "[Added Lines]",
          "906:                 events.status(String.format(",
          "907:                         \"Agent discovery successful%n\"",
          "908:                                 + \"  Agent address: %s%n\"",
          "909:                                 + \"  Agent port:    %d%n\"",
          "910:                                 + \"  Identity:      %s\",",
          "911:                         endpoint.getHost(), endpoint.getPort(), KeyUtils.fingerprint(endpoint.getPublicKey())));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "886:                         triedAtLeastOneProtocol = true;",
          "887:                         events.status(\"Trying protocol: \" + protocol.getName());",
          "888:                         try {",
          "890:                         } catch (IOException ioe) {",
          "891:                             events.status(\"Protocol \" + protocol.getName() + \" failed to establish channel\", ioe);",
          "892:                         } catch (RuntimeException e) {",
          "893:                             events.status(\"Protocol \" + protocol.getName() + \" encountered a runtime error\", e);",
          "894:                         } catch (Error e) {",
          "897:                         } catch (Throwable e) {",
          "898:                             events.status(\"Protocol \" + protocol.getName() + \" encountered an unexpected exception\", e);",
          "899:                         }",
          "",
          "[Removed Lines]",
          "889:                             channel = protocol.connect(jnlpSocket, headers, new EngineJnlpConnectionStateListener(endpoint.getPublicKey(), headers)).get();",
          "895:                             events.status(\"Protocol \" + protocol.getName() + \" could not be completed due to an error\",",
          "896:                                     e);",
          "",
          "[Added Lines]",
          "943:                             channel = protocol.connect(",
          "944:                                             jnlpSocket,",
          "945:                                             headers,",
          "946:                                             new EngineJnlpConnectionStateListener(endpoint.getPublicKey(), headers))",
          "947:                                     .get();",
          "953:                             events.status(",
          "954:                                     \"Protocol \" + protocol.getName() + \" could not be completed due to an error\", e);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "932:                         }",
          "933:                     }",
          "934:                 }",
          "936:                     return; // exit",
          "937:                 firstAttempt = Instant.now();",
          "938:                 events.onDisconnect();",
          "",
          "[Removed Lines]",
          "935:                 if(noReconnect)",
          "",
          "[Added Lines]",
          "993:                 if (noReconnect) {",
          "995:                 }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "956:             } catch (Exception e) {",
          "957:                 events.error(e);",
          "958:             }",
          "961:         } else {",
          "963:         }",
          "964:         return resolver;",
          "965:     }",
          "967:     private void onConnectionRejected(String greeting) throws InterruptedException {",
          "970:         TimeUnit.SECONDS.sleep(10);",
          "971:     }",
          "",
          "[Removed Lines]",
          "959:             resolver = new JnlpAgentEndpointResolver(jenkinsUrls, agentName, credentials, proxyCredentials, tunnel,",
          "960:                     sslSocketFactory, disableHttpsCertValidation, noReconnectAfter);",
          "962:             resolver = new JnlpAgentEndpointConfigurator(directConnection, instanceIdentity, protocols, proxyCredentials);",
          "968:         events.status(\"reconnect rejected, sleeping 10s: \", new Exception(\"The server rejected the connection: \" + greeting));",
          "",
          "[Added Lines]",
          "1018:             resolver = new JnlpAgentEndpointResolver(",
          "1019:                     jenkinsUrls,",
          "1020:                     agentName,",
          "1021:                     credentials,",
          "1022:                     proxyCredentials,",
          "1023:                     tunnel,",
          "1024:                     sslSocketFactory,",
          "1025:                     disableHttpsCertValidation,",
          "1026:                     noReconnectAfter);",
          "1028:             resolver =",
          "1029:                     new JnlpAgentEndpointConfigurator(directConnection, instanceIdentity, protocols, proxyCredentials);",
          "1035:         events.status(",
          "1036:                 \"reconnect rejected, sleeping 10s: \", new Exception(\"The server rejected the connection: \" + greeting));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "980:         String msg = \"Connecting to \" + endpoint.getHost() + ':' + endpoint.getPort();",
          "981:         events.status(msg);",
          "982:         int retry = 1;",
          "984:             try {",
          "986:                 s.setKeepAlive(keepAlive);",
          "987:                 return s;",
          "988:             } catch (IOException e) {",
          "990:                     throw e;",
          "991:                 }",
          "993:                 TimeUnit.SECONDS.sleep(10);",
          "995:             }",
          "996:         }",
          "997:     }",
          "",
          "[Removed Lines]",
          "983:         while(true) {",
          "985:                 final Socket s = endpoint.open(SOCKET_TIMEOUT); // default is 30 mins. See PingThread for the ping interval",
          "989:                 if(retry++>10) {",
          "994:                 events.status(msg+\" (retrying:\"+retry+\")\",e);",
          "",
          "[Added Lines]",
          "1051:         while (true) {",
          "1053:                 final Socket s =",
          "1054:                         endpoint.open(SOCKET_TIMEOUT); // default is 30 mins. See PingThread for the ping interval",
          "1058:                 if (retry++ > 10) {",
          "1063:                 events.status(msg + \" (retrying:\" + retry + \")\", e);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1013:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"File path is loaded from system properties.\")",
          "1014:     static KeyStore getCacertsKeyStore()",
          "1015:             throws PrivilegedActionException, KeyStoreException, NoSuchProviderException, CertificateException,",
          "1019:                     Map<String, String> result = new HashMap<>();",
          "1020:                     result.put(\"trustStore\", System.getProperty(\"javax.net.ssl.trustStore\"));",
          "1021:                     result.put(\"javaHome\", System.getProperty(\"java.home\"));",
          "1023:                             System.getProperty(\"javax.net.ssl.trustStoreType\", KeyStore.getDefaultType()));",
          "1024:                     result.put(\"trustStoreProvider\", System.getProperty(\"javax.net.ssl.trustStoreProvider\", \"\"));",
          "1025:                     result.put(\"trustStorePasswd\", System.getProperty(\"javax.net.ssl.trustStorePassword\", \"\"));",
          "",
          "[Removed Lines]",
          "1016:             NoSuchAlgorithmException, IOException {",
          "1017:         Map<String, String> properties = AccessController.doPrivileged(",
          "1018:                 (PrivilegedExceptionAction<Map<String, String>>) () -> {",
          "1022:                     result.put(\"trustStoreType\",",
          "",
          "[Added Lines]",
          "1085:                     NoSuchAlgorithmException, IOException {",
          "1086:         Map<String, String> properties =",
          "1087:                 AccessController.doPrivileged((PrivilegedExceptionAction<Map<String, String>>) () -> {",
          "1091:                     result.put(",
          "1092:                             \"trustStoreType\",",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1037:                     trustStoreStream = getFileInputStream(trustStoreFile);",
          "1038:                 } else {",
          "1039:                     String javaHome = properties.get(\"javaHome\");",
          "1043:                     if ((trustStoreStream = getFileInputStream(trustStoreFile)) == null) {",
          "1047:                         trustStoreStream = getFileInputStream(trustStoreFile);",
          "1048:                     }",
          "1049:                 }",
          "",
          "[Removed Lines]",
          "1040:                     trustStoreFile = new File(",
          "1041:                             javaHome + File.separator + \"lib\" + File.separator + \"security\" + File.separator",
          "1042:                                     + \"jssecacerts\");",
          "1044:                         trustStoreFile = new File(",
          "1045:                                 javaHome + File.separator + \"lib\" + File.separator + \"security\" + File.separator",
          "1046:                                         + \"cacerts\");",
          "",
          "[Added Lines]",
          "1110:                     trustStoreFile = new File(javaHome + File.separator + \"lib\" + File.separator + \"security\"",
          "1111:                             + File.separator + \"jssecacerts\");",
          "1113:                         trustStoreFile = new File(javaHome + File.separator + \"lib\" + File.separator + \"security\"",
          "1114:                                 + File.separator + \"cacerts\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1104:     @CheckForNull",
          "1105:     private static SSLContext getSSLContext(List<X509Certificate> x509Certificates, boolean noCertificateCheck)",
          "1106:             throws PrivilegedActionException, KeyStoreException, NoSuchProviderException, CertificateException,",
          "1108:         SSLContext sslContext = null;",
          "1109:         if (noCertificateCheck) {",
          "1110:             sslContext = SSLContext.getInstance(\"TLS\");",
          "1112:         } else if (x509Certificates != null && !x509Certificates.isEmpty()) {",
          "1113:             KeyStore keyStore = getCacertsKeyStore();",
          "",
          "[Removed Lines]",
          "1107:             NoSuchAlgorithmException, IOException, KeyManagementException {",
          "1111:             sslContext.init(null, new TrustManager[]{new NoCheckTrustManager()}, new SecureRandom());",
          "",
          "[Added Lines]",
          "1175:                     NoSuchAlgorithmException, IOException, KeyManagementException {",
          "1179:             sslContext.init(null, new TrustManager[] {new NoCheckTrustManager()}, new SecureRandom());",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1128:         }",
          "1129:         return sslContext;",
          "1130:     }",
          "1132:     @CheckForNull",
          "1133:     @Restricted(NoExternalUse.class)",
          "1134:     static SSLSocketFactory getSSLSocketFactory(List<X509Certificate> x509Certificates, boolean noCertificateCheck)",
          "1135:             throws PrivilegedActionException, KeyStoreException, NoSuchProviderException, CertificateException,",
          "1137:         SSLContext sslContext = getSSLContext(x509Certificates, noCertificateCheck);",
          "1138:         return sslContext != null ? sslContext.getSocketFactory() : null;",
          "1139:     }",
          "",
          "[Removed Lines]",
          "1136:             NoSuchAlgorithmException, IOException, KeyManagementException {",
          "",
          "[Added Lines]",
          "1204:                     NoSuchAlgorithmException, IOException, KeyManagementException {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1146:     static final int SOCKET_TIMEOUT = Integer.getInteger(Engine.class.getName()+\".socketTimeout\",30*60*1000);",
          "",
          "[Added Lines]",
          "1214:     static final int SOCKET_TIMEOUT = Integer.getInteger(Engine.class.getName() + \".socketTimeout\", 30 * 60 * 1000);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1183:             if (event instanceof Jnlp4ConnectionState) {",
          "1184:                 X509Certificate certificate = ((Jnlp4ConnectionState) event).getCertificate();",
          "1185:                 if (certificate != null) {",
          "1188:                     if (!KeyUtils.equals(publicKey, certificate.getPublicKey())) {",
          "1191:                     }",
          "1192:                     events.status(\"Remote identity confirmed: \" + fingerprint);",
          "1193:                 }",
          "",
          "[Removed Lines]",
          "1186:                     String fingerprint = KeyUtils",
          "1187:                             .fingerprint(certificate.getPublicKey());",
          "1189:                         event.reject(new ConnectionRefusalException(",
          "1190:                                 \"Expecting identity \" + fingerprint));",
          "",
          "[Added Lines]",
          "1254:                     String fingerprint = KeyUtils.fingerprint(certificate.getPublicKey());",
          "1256:                         event.reject(new ConnectionRefusalException(\"Expecting identity \" + fingerprint));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/EngineListener.java||src/main/java/hudson/remoting/EngineListener.java": [
          "File: src/main/java/hudson/remoting/EngineListener.java -> src/main/java/hudson/remoting/EngineListener.java"
        ],
        "src/main/java/hudson/remoting/EngineListenerAdapter.java||src/main/java/hudson/remoting/EngineListenerAdapter.java": [
          "File: src/main/java/hudson/remoting/EngineListenerAdapter.java -> src/main/java/hudson/remoting/EngineListenerAdapter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: public abstract class EngineListenerAdapter implements EngineListener {",
          "10:     @Override",
          "14:     @Override",
          "18:     @Override",
          "22:     @Override",
          "26:     @Override",
          "29: }",
          "",
          "[Removed Lines]",
          "11:     public void status(String msg) {",
          "12:     }",
          "15:     public void status(String msg, Throwable t) {",
          "16:     }",
          "19:     public void error(Throwable t) {",
          "20:     }",
          "23:     public void onDisconnect() {",
          "24:     }",
          "27:     public void onReconnect() {",
          "28:     }",
          "",
          "[Added Lines]",
          "11:     public void status(String msg) {}",
          "14:     public void status(String msg, Throwable t) {}",
          "17:     public void error(Throwable t) {}",
          "20:     public void onDisconnect() {}",
          "23:     public void onReconnect() {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/EngineListenerSplitter.java||src/main/java/hudson/remoting/EngineListenerSplitter.java": [
          "File: src/main/java/hudson/remoting/EngineListenerSplitter.java -> src/main/java/hudson/remoting/EngineListenerSplitter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     @Override",
          "31:     public void status(String msg, Throwable t) {",
          "32:         for (EngineListener l : listeners) {",
          "34:         }",
          "35:     }",
          "",
          "[Removed Lines]",
          "33:             l.status(msg,t);",
          "",
          "[Added Lines]",
          "33:             l.status(msg, t);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ExportTable.java||src/main/java/hudson/remoting/ExportTable.java": [
          "File: src/main/java/hudson/remoting/ExportTable.java -> src/main/java/hudson/remoting/ExportTable.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: final class ExportTable {",
          "",
          "[Removed Lines]",
          "50:     private final Map<Integer,Entry<?>> table = new HashMap<>();",
          "51:     private final Map<Object,Entry<?>> reverse = new HashMap<>();",
          "",
          "[Added Lines]",
          "50:     private final Map<Integer, Entry<?>> table = new HashMap<>();",
          "51:     private final Map<Object, Entry<?>> reverse = new HashMap<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:             this.objectType = object.getClass().getName();",
          "101:             this.allocationTrace = EXPORT_TRACES ? new CreatedAt() : null;",
          "105:         }",
          "107:         void addRef() {",
          "",
          "[Removed Lines]",
          "103:             table.put(id,this);",
          "104:             reverse.put(object,this);",
          "",
          "[Added Lines]",
          "103:             table.put(id, this);",
          "104:             reverse.put(object, this);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "130:                 referenceCount += 0x40000000;",
          "131:         }",
          "",
          "[Removed Lines]",
          "129:             if (referenceCount<0x20000000)",
          "",
          "[Added Lines]",
          "129:             if (referenceCount < 0x20000000) {",
          "131:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "139:         void release(@CheckForNull Throwable callSite) {",
          "141:                 table.remove(id);",
          "142:                 reverse.remove(object);",
          "",
          "[Removed Lines]",
          "140:             if(--referenceCount==0) {",
          "",
          "[Added Lines]",
          "141:             if (--referenceCount == 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "146:                     releaseTrace = new ReleasedAt(callSite);",
          "147:                 }",
          "148:                 unexportLog.add(this);",
          "150:                     unexportLog.remove(0);",
          "151:             }",
          "152:         }",
          "154:         private String interfaceNames() {",
          "155:             StringBuilder buf = new StringBuilder(10 + getInterfaces().length * 128);",
          "156:             String sep = \"[\";",
          "158:                 buf.append(sep).append(clazz.getName());",
          "159:                 sep = \", \";",
          "160:             }",
          "",
          "[Removed Lines]",
          "149:                 while (unexportLog.size() > UNEXPORT_LOG_SIZE)",
          "157:             for (Class<? super T> clazz: getInterfaces()) {",
          "",
          "[Added Lines]",
          "150:                 while (unexportLog.size() > UNEXPORT_LOG_SIZE) {",
          "152:                 }",
          "159:             for (Class<? super T> clazz : getInterfaces()) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "168:         void dump(PrintWriter w) throws IOException {",
          "170:             if (allocationTrace != null) {",
          "171:                 allocationTrace.printStackTrace(w);",
          "172:             }",
          "",
          "[Removed Lines]",
          "169:             w.printf(\"#%d (ref.%d) : object=%s type=%s interfaces=%s%n\", id, referenceCount, object, objectType, interfaceNames());",
          "",
          "[Added Lines]",
          "171:             w.printf(",
          "172:                     \"#%d (ref.%d) : object=%s type=%s interfaces=%s%n\",",
          "173:                     id, referenceCount, object, objectType, interfaceNames());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "180:             try (PrintWriter pw = new PrintWriter(sw)) {",
          "181:                 dump(pw);",
          "182:             } catch (IOException e) {",
          "184:             }",
          "185:             return sw.toString();",
          "186:         }",
          "",
          "[Removed Lines]",
          "183:                 throw new Error(e);   // impossible",
          "",
          "[Added Lines]",
          "187:                 throw new Error(e); // impossible",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "190:         }",
          "192:         synchronized void addInterface(Class<? super T> clazz) {",
          "195:             }",
          "197:             System.arraycopy(interfaces, 0, replacement, 0, interfaces.length);",
          "198:             replacement[interfaces.length] = clazz;",
          "199:             interfaces = replacement;",
          "200:         }",
          "202:     }",
          "204:     static class Source extends Exception {",
          "",
          "[Removed Lines]",
          "193:             for (Class<? super T> c: interfaces) {",
          "194:                 if (c.equals(clazz)) return;",
          "196:             Class<? super T>[] replacement = new Class[interfaces.length+1];",
          "",
          "[Added Lines]",
          "197:             for (Class<? super T> c : interfaces) {",
          "198:                 if (c.equals(clazz)) {",
          "199:                     return;",
          "200:                 }",
          "202:             Class<? super T>[] replacement = new Class[interfaces.length + 1];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "223:         @Override",
          "224:         public String toString() {",
          "226:         }",
          "227:     }",
          "",
          "[Removed Lines]",
          "225:             return \"  Created at \"+new Date(timestamp);",
          "",
          "[Added Lines]",
          "229:             return \"  Created at \" + new Date(timestamp);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "234:         @Override",
          "235:         public String toString() {",
          "237:         }",
          "238:     }",
          "",
          "[Removed Lines]",
          "236:             return \"  Released at \"+new Date(timestamp);",
          "",
          "[Added Lines]",
          "240:             return \"  Released at \" + new Date(timestamp);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "246:     @Restricted(NoExternalUse.class)",
          "248:             justification = \"ExportList is supposed to be serializable as ArrayList, but it is not. \"",
          "250:     public final class ExportList extends ArrayList<Entry<?>> {",
          "251:         private final ExportList old;",
          "252:         private ExportList() {",
          "254:             lists.set(this);",
          "255:         }",
          "256:         void release(Throwable callSite) {",
          "259:                     e.release(callSite);",
          "260:             }",
          "261:         }",
          "262:         void stopRecording() {",
          "263:             lists.set(old);",
          "264:         }",
          "267:     }",
          "",
          "[Removed Lines]",
          "247:     @SuppressFBWarnings(value = {\"EQ_DOESNT_OVERRIDE_EQUALS\", \"SE_BAD_FIELD_INNER_CLASS\"},",
          "249:                           + \"The issue is ignored since the class does not belong to the public API\")",
          "253:             old=lists.get();",
          "257:             synchronized(ExportTable.this) {",
          "258:                 for (Entry<?> e : this)",
          "266:         private static final long serialVersionUID = 1L;    // we don't actually serialize this class but just to shutup FindBugs",
          "",
          "[Added Lines]",
          "251:     @SuppressFBWarnings(",
          "252:             value = {\"EQ_DOESNT_OVERRIDE_EQUALS\", \"SE_BAD_FIELD_INNER_CLASS\"},",
          "254:                     + \"The issue is ignored since the class does not belong to the public API\")",
          "259:             old = lists.get();",
          "264:             synchronized (ExportTable.this) {",
          "265:                 for (Entry<?> e : this) {",
          "267:                 }",
          "275:         private static final long serialVersionUID =",
          "276:                 1L; // we don't actually serialize this class but just to shutup FindBugs",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "284:     }",
          "286:     boolean isRecording() {",
          "288:     }",
          "",
          "[Removed Lines]",
          "287:         return lists.get()!=null;",
          "",
          "[Added Lines]",
          "297:         return lists.get() != null;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "304:     synchronized <T> int export(@NonNull Class<T> clazz, @CheckForNull T t) {",
          "306:     }",
          "",
          "[Removed Lines]",
          "305:         return export(clazz, t,true);",
          "",
          "[Added Lines]",
          "315:         return export(clazz, t, true);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "319:     synchronized <T> int export(@NonNull Class<T> clazz, @CheckForNull T t, boolean notifyListener) {",
          "322:         Entry<T> e = (Entry<T>) reverse.get(t);",
          "323:         if (e == null) {",
          "",
          "[Removed Lines]",
          "320:         if(t==null)    return 0;   // bootstrap classloader",
          "",
          "[Added Lines]",
          "330:         if (t == null) {",
          "331:             return 0; // bootstrap classloader",
          "332:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "327:         }",
          "328:         e.addRef();",
          "331:             ExportList l = lists.get();",
          "333:         }",
          "335:         return e.id;",
          "",
          "[Removed Lines]",
          "330:         if(notifyListener) {",
          "332:             if(l!=null) l.add(e);",
          "",
          "[Added Lines]",
          "342:         if (notifyListener) {",
          "344:             if (l != null) {",
          "345:                 l.add(e);",
          "346:             }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "339:         Entry<?> e = reverse.get(t);",
          "341:             e.pin();",
          "342:     }",
          "",
          "[Removed Lines]",
          "340:         if(e!=null)",
          "",
          "[Added Lines]",
          "354:         if (e != null) {",
          "356:         }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "351:     @NonNull",
          "352:     synchronized Object get(int id) throws ExecutionException {",
          "353:         Entry<?> e = table.get(id);",
          "356:         throw diagnoseInvalidObjectId(id);",
          "357:     }",
          "",
          "[Removed Lines]",
          "354:         if(e!=null) return e.object;",
          "",
          "[Added Lines]",
          "369:         if (e != null) {",
          "370:             return e.object;",
          "371:         }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "364:     @CheckForNull",
          "365:     synchronized Object getOrNull(int oid) {",
          "366:         Entry<?> e = table.get(oid);",
          "369:         return null;",
          "370:     }",
          "",
          "[Removed Lines]",
          "367:         if(e!=null) return e.object;",
          "",
          "[Added Lines]",
          "384:         if (e != null) {",
          "385:             return e.object;",
          "386:         }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "372:     @NonNull",
          "373:     synchronized Class<?>[] type(int id) throws ExecutionException {",
          "374:         Entry<?> e = table.get(id);",
          "377:         throw diagnoseInvalidObjectId(id);",
          "378:     }",
          "",
          "[Removed Lines]",
          "375:         if(e!=null) return e.getInterfaces();",
          "",
          "[Added Lines]",
          "394:         if (e != null) {",
          "395:             return e.getInterfaces();",
          "396:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "396:         for (Entry<?> v : values) {",
          "397:             if (v.object instanceof ErrorPropagatingOutputStream) {",
          "398:                 try {",
          "400:                 } catch (Throwable x) {",
          "402:                 }",
          "403:             }",
          "404:         }",
          "",
          "[Removed Lines]",
          "399:                     ((ErrorPropagatingOutputStream)v.object).error(e);",
          "401:                     LOGGER.log(Level.INFO, \"Failed to propagate a channel termination error\",x);",
          "",
          "[Added Lines]",
          "420:                     ((ErrorPropagatingOutputStream) v.object).error(e);",
          "422:                     LOGGER.log(Level.INFO, \"Failed to propagate a channel termination error\", x);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "420:     @NonNull",
          "421:     private synchronized ExecutionException diagnoseInvalidObjectId(int id) {",
          "424:         if (!unexportLog.isEmpty()) {",
          "425:             for (Entry<?> e : unexportLog) {",
          "427:                     cause = new Exception(\"Object was recently deallocated\\n\" + Util.indent(e.dump()), e.releaseTrace);",
          "428:                     break;",
          "429:                 }",
          "430:             }",
          "433:                 final ReleasedAt releasedAt = unexportLog.get(0).releaseTrace;",
          "434:                 final Date releasedBefore = releasedAt != null ? new Date(releasedAt.timestamp) : new Date();",
          "436:             }",
          "437:         }",
          "440:     }",
          "",
          "[Removed Lines]",
          "422:         Exception cause=null;",
          "426:                 if (e.id==id) {",
          "431:             if (cause==null) {",
          "435:                 cause = new Exception(\"Object appears to be deallocated at lease before \"+ releasedBefore);",
          "439:         return new ExecutionException(\"Invalid object ID \"+id+\" iota=\"+iota, cause);",
          "",
          "[Added Lines]",
          "443:         Exception cause = null;",
          "447:                 if (e.id == id) {",
          "452:             if (cause == null) {",
          "457:                 cause = new Exception(\"Object appears to be deallocated at lease before \" + releasedBefore);",
          "461:         return new ExecutionException(\"Invalid object ID \" + id + \" iota=\" + iota, cause);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "459:         Entry<?> e = table.get(oid);",
          "461:             Level loggingLevel = severeErrorIfMissing ? Level.SEVERE : Level.FINE;",
          "464:                 LOGGER.log(loggingLevel, \"2nd unexport attempt is here\", callSite);",
          "465:             return;",
          "466:         }",
          "467:         e.release(callSite);",
          "",
          "[Removed Lines]",
          "457:     synchronized void unexportByOid(@CheckForNull Integer oid, @CheckForNull Throwable callSite, boolean severeErrorIfMissing) {",
          "458:         if(oid==null)     return;",
          "460:         if(e==null) {",
          "462:             LOGGER.log(loggingLevel, \"Trying to unexport an object that's already unexported\", diagnoseInvalidObjectId(oid));",
          "463:             if (callSite!=null)",
          "",
          "[Added Lines]",
          "479:     synchronized void unexportByOid(",
          "480:             @CheckForNull Integer oid, @CheckForNull Throwable callSite, boolean severeErrorIfMissing) {",
          "481:         if (oid == null) {",
          "482:             return;",
          "483:         }",
          "485:         if (e == null) {",
          "487:             LOGGER.log(",
          "488:                     loggingLevel,",
          "489:                     \"Trying to unexport an object that's already unexported\",",
          "490:                     diagnoseInvalidObjectId(oid));",
          "491:             if (callSite != null) {",
          "493:             }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "490:     static boolean EXPORT_TRACES = Boolean.getBoolean(ExportTable.class.getName() + \".exportTraces\");",
          "",
          "[Removed Lines]",
          "488:     public static int UNEXPORT_LOG_SIZE = Integer.getInteger(ExportTable.class.getName()+\".unexportLogSize\",1024);",
          "",
          "[Added Lines]",
          "517:     public static int UNEXPORT_LOG_SIZE = Integer.getInteger(ExportTable.class.getName() + \".unexportLogSize\", 1024);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/FastPipedInputStream.java||src/main/java/hudson/remoting/FastPipedInputStream.java": [
          "File: src/main/java/hudson/remoting/FastPipedInputStream.java -> src/main/java/hudson/remoting/FastPipedInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:     public FastPipedInputStream(FastPipedOutputStream source, int bufferSize) throws IOException {",
          "78:             connect(source);",
          "79:         }",
          "80:         this.buffer = new byte[bufferSize];",
          "",
          "[Removed Lines]",
          "77:         if(source != null) {",
          "",
          "[Added Lines]",
          "78:         if (source != null) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     private void checkSource() throws IOException {",
          "84:         FastPipedOutputStream s = source.get();",
          "86:     }",
          "88:     @Override",
          "",
          "[Removed Lines]",
          "85:         if (s==null)    throw new IOException(\"Writer side has already been abandoned\", allocatedAt);",
          "",
          "[Added Lines]",
          "86:         if (s == null) {",
          "87:             throw new IOException(\"Writer side has already been abandoned\", allocatedAt);",
          "88:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:         synchronized (buffer) {",
          "98:                             :",
          "100:                             (writeLaps > readLaps ? buffer.length : 0));",
          "",
          "[Removed Lines]",
          "94:             return writePosition > readPosition /* The writer is in the same lap. */? writePosition",
          "95:                     - readPosition",
          "96:                     : (writePosition < readPosition /* The writer is in the next lap. */? buffer.length",
          "97:                             - readPosition + 1 + writePosition",
          "",
          "[Added Lines]",
          "98:                     ? writePosition - readPosition",
          "100:                             ? buffer.length - readPosition + 1 + writePosition",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "107:     @Override",
          "108:     public void close() throws IOException {",
          "110:             throw new IOException(\"Unconnected pipe\");",
          "111:         }",
          "113:             closed = new ClosedBy(null);",
          "115:             buffer.notifyAll();",
          "",
          "[Removed Lines]",
          "109:         if(source == null) {",
          "112:         synchronized(buffer) {",
          "",
          "[Added Lines]",
          "112:         if (source == null) {",
          "115:         synchronized (buffer) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "122:     public void connect(FastPipedOutputStream source) throws IOException {",
          "124:             throw new IOException(\"Pipe already connected\");",
          "125:         }",
          "126:         this.source = new WeakReference<>(source);",
          "",
          "[Removed Lines]",
          "123:         if(this.source != null) {",
          "",
          "[Added Lines]",
          "126:         if (this.source != null) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "134:     }",
          "136:     @Override",
          "140:     @Override",
          "141:     public boolean markSupported() {",
          "",
          "[Removed Lines]",
          "137:     public void mark(int readLimit) {",
          "138:     }",
          "",
          "[Added Lines]",
          "140:     public void mark(int readLimit) {}",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "159:     @Override",
          "160:     public int read(@NonNull byte[] b, int off, int len) throws IOException {",
          "162:             throw new IOException(\"Unconnected pipe\");",
          "163:         }",
          "165:         while (true) {",
          "169:                         Throwable c = closed.getCause();",
          "171:                         throw new IOException(c);",
          "172:                     }",
          "173:                     checkSource(); // make sure the sink is still trying to read, or else fail the write.",
          "",
          "[Removed Lines]",
          "161:         if(source == null) {",
          "166:             synchronized(buffer) {",
          "167:                 if(writePosition == readPosition && writeLaps == readLaps) {",
          "168:                     if(closed!=null) {",
          "170:                         if (c==null)        return -1;  // EOF",
          "",
          "[Added Lines]",
          "163:         if (source == null) {",
          "168:             synchronized (buffer) {",
          "169:                 if (writePosition == readPosition && writeLaps == readLaps) {",
          "170:                     if (closed != null) {",
          "172:                         if (c == null) {",
          "173:                             return -1; // EOF",
          "174:                         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "191:                 System.arraycopy(buffer, readPosition, b, off, amount);",
          "192:                 readPosition += amount;",
          "195:                     readPosition = 0;",
          "196:                     ++readLaps;",
          "197:                 }",
          "",
          "[Removed Lines]",
          "188:                 int amount = Math.min(len, (writePosition > readPosition ? writePosition",
          "189:                         : buffer.length)",
          "190:                         - readPosition);",
          "194:                 if(readPosition == buffer.length) {// A lap was completed, so go back.",
          "",
          "[Added Lines]",
          "192:                 int amount =",
          "193:                         Math.min(len, (writePosition > readPosition ? writePosition : buffer.length) - readPosition);",
          "197:                 if (readPosition == buffer.length) { // A lap was completed, so go back.",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/FastPipedOutputStream.java||src/main/java/hudson/remoting/FastPipedOutputStream.java": [
          "File: src/main/java/hudson/remoting/FastPipedOutputStream.java -> src/main/java/hudson/remoting/FastPipedOutputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:     private FastPipedInputStream sink() throws IOException {",
          "76:         FastPipedInputStream s = sink.get();",
          "78:         return s;",
          "79:     }",
          "",
          "[Removed Lines]",
          "77:         if (s==null)    throw new IOException(\"Reader side has already been abandoned\", allocatedAt);",
          "",
          "[Added Lines]",
          "77:         if (s == null) {",
          "78:             throw new IOException(\"Reader side has already been abandoned\", allocatedAt);",
          "79:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:     @Override",
          "90:     public void error(Throwable e) throws IOException {",
          "92:             throw new IOException(\"Unconnected pipe\");",
          "93:         }",
          "94:         FastPipedInputStream s = sink();",
          "97:                 s.closed = new FastPipedInputStream.ClosedBy(e);",
          "98:                 flush();",
          "99:             }",
          "",
          "[Removed Lines]",
          "91:         if(sink == null) {",
          "95:         synchronized(s.buffer) {",
          "96:             if (s.closed==null) {",
          "",
          "[Added Lines]",
          "93:         if (sink == null) {",
          "97:         synchronized (s.buffer) {",
          "98:             if (s.closed == null) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:     public void connect(FastPipedInputStream sink) throws IOException {",
          "108:             throw new IOException(\"Pipe already connected\");",
          "109:         }",
          "110:         this.sink = new WeakReference<>(sink);",
          "",
          "[Removed Lines]",
          "107:         if(this.sink != null) {",
          "",
          "[Added Lines]",
          "109:         if (this.sink != null) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "120:     @Override",
          "121:     public void flush() throws IOException {",
          "122:         FastPipedInputStream s = sink();",
          "125:             s.buffer.notifyAll();",
          "126:         }",
          "",
          "[Removed Lines]",
          "123:         synchronized(s.buffer) {",
          "",
          "[Added Lines]",
          "125:         synchronized (s.buffer) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "129:     @Override",
          "130:     public void write(int b) throws IOException {",
          "132:     }",
          "134:     @Override",
          "",
          "[Removed Lines]",
          "131:         write(new byte[] { (byte) b });",
          "",
          "[Added Lines]",
          "133:         write(new byte[] {(byte) b});",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "142:     @Override",
          "143:     public void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "145:             throw new IOException(\"Unconnected pipe\");",
          "146:         }",
          "149:             FastPipedInputStream s = sink(); // make sure the sink is still trying to read, or else fail the write.",
          "152:                 throw new IOException(\"Pipe is already closed\", s.closed);",
          "153:             }",
          "",
          "[Removed Lines]",
          "144:         if(sink == null) {",
          "148:         while (len>0) {",
          "151:             if(s.closed!=null) {",
          "155:             synchronized(s.buffer) {",
          "156:                 if(s.writePosition == s.readPosition && s.writeLaps > s.readLaps) {",
          "",
          "[Added Lines]",
          "146:         if (sink == null) {",
          "150:         while (len > 0) {",
          "153:             if (s.closed != null) {",
          "157:             synchronized (s.buffer) {",
          "158:                 if (s.writePosition == s.readPosition && s.writeLaps > s.readLaps) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "164:                     Thread t = Thread.currentThread();",
          "165:                     String oldName = t.getName();",
          "167:                     try {",
          "168:                         buf.wait(TIMEOUT);",
          "169:                     } catch (InterruptedException e) {",
          "171:                     } finally {",
          "172:                         t.setName(oldName);",
          "173:                     }",
          "",
          "[Removed Lines]",
          "166:                     t.setName(\"Blocking to write \"+HexDump.toHex(b,off,Math.min(len,256))+\": \"+oldName);",
          "170:                         throw (InterruptedIOException)new InterruptedIOException(e.getMessage()).initCause(e);",
          "",
          "[Added Lines]",
          "168:                     t.setName(\"Blocking to write \" + HexDump.toHex(b, off, Math.min(len, 256)) + \": \" + oldName);",
          "172:                         throw (InterruptedIOException) new InterruptedIOException(e.getMessage()).initCause(e);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "183:                 System.arraycopy(b, off, s.buffer, s.writePosition, amount);",
          "184:                 s.writePosition += amount;",
          "187:                     s.writePosition = 0;",
          "188:                     ++s.writeLaps;",
          "189:                 }",
          "",
          "[Removed Lines]",
          "180:                 int amount = Math.min(len, (s.writePosition < s.readPosition ? s.readPosition",
          "181:                         : s.buffer.length)",
          "182:                         - s.writePosition);",
          "186:                 if(s.writePosition == s.buffer.length) {",
          "",
          "[Added Lines]",
          "182:                 int amount = Math.min(",
          "183:                         len, (s.writePosition < s.readPosition ? s.readPosition : s.buffer.length) - s.writePosition);",
          "187:                 if (s.writePosition == s.buffer.length) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "196:         }",
          "197:     }",
          "200: }",
          "",
          "[Removed Lines]",
          "199:     static final int TIMEOUT = Integer.getInteger(FastPipedOutputStream.class.getName()+\".timeout\",10*1000);",
          "",
          "[Added Lines]",
          "200:     static final int TIMEOUT = Integer.getInteger(FastPipedOutputStream.class.getName() + \".timeout\", 10 * 1000);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/FileSystemJarCache.java||src/main/java/hudson/remoting/FileSystemJarCache.java": [
          "File: src/main/java/hudson/remoting/FileSystemJarCache.java -> src/main/java/hudson/remoting/FileSystemJarCache.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     public FileSystemJarCache(@NonNull File rootDir, boolean touch) {",
          "54:         this.rootDir = rootDir;",
          "55:         this.touch = touch;",
          "57:             throw new IllegalArgumentException(\"Root directory is null\");",
          "59:         try {",
          "60:             Files.createDirectories(rootDir.toPath());",
          "",
          "[Removed Lines]",
          "56:         if (rootDir==null)",
          "",
          "[Added Lines]",
          "56:         if (rootDir == null) {",
          "58:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:     public String toString() {",
          "68:         return String.format(\"FileSystem JAR Cache: path=%s, touch=%s\", rootDir, touch);",
          "69:     }",
          "71:     @Override",
          "72:     protected URL lookInCache(Channel channel, long sum1, long sum2) throws IOException, InterruptedException {",
          "73:         File jar = map(sum1, sum2);",
          "74:         if (jar.exists()) {",
          "77:                 Files.setLastModifiedTime(PathUtils.fileToPath(jar), FileTime.fromMillis(System.currentTimeMillis()));",
          "78:             }",
          "81:             }",
          "82:             return jar.toURI().toURL();",
          "83:         }",
          "",
          "[Removed Lines]",
          "75:             LOGGER.log(Level.FINER, () -> String.format(\"Jar file cache hit %16X%16X\",sum1,sum2));",
          "76:             if (touch)  {",
          "79:             if (notified.add(new Checksum(sum1,sum2))) {",
          "80:                 getJarLoader(channel).notifyJarPresence(sum1,sum2);",
          "",
          "[Added Lines]",
          "76:             LOGGER.log(Level.FINER, () -> String.format(\"Jar file cache hit %16X%16X\", sum1, sum2));",
          "77:             if (touch) {",
          "80:             if (notified.add(new Checksum(sum1, sum2))) {",
          "81:                 getJarLoader(channel).notifyJarPresence(sum1, sum2);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:     }",
          "87:     @Override",
          "89:     protected URL retrieve(Channel channel, long sum1, long sum2) throws IOException, InterruptedException {",
          "90:         Checksum expected = new Checksum(sum1, sum2);",
          "91:         File target = map(sum1, sum2);",
          "",
          "[Removed Lines]",
          "88:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"The file path is a generated value based on server supplied data.\")",
          "",
          "[Added Lines]",
          "89:     @SuppressFBWarnings(",
          "90:             value = \"PATH_TRAVERSAL_IN\",",
          "91:             justification = \"The file path is a generated value based on server supplied data.\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:             LOGGER.warning(String.format(",
          "101:                     \"Cached file checksum mismatch: %s%nExpected: %s%n Actual: %s\",",
          "104:             Files.delete(PathUtils.fileToPath(target));",
          "105:             synchronized (checksumsByPath) {",
          "106:                 checksumsByPath.remove(target.getCanonicalPath());",
          "",
          "[Removed Lines]",
          "102:                     target.getAbsolutePath(), expected, actual",
          "103:             ));",
          "",
          "[Added Lines]",
          "105:                     target.getAbsolutePath(), expected, actual));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "145:                 Files.deleteIfExists(PathUtils.fileToPath(tmp));",
          "146:             }",
          "147:         } catch (IOException e) {",
          "149:         }",
          "150:     }",
          "",
          "[Removed Lines]",
          "148:             throw new IOException(\"Failed to write to \"+target, e);",
          "",
          "[Added Lines]",
          "150:             throw new IOException(\"Failed to write to \" + target, e);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "161:         synchronized (checksumsByPath) {",
          "162:             Checksum checksum = checksumsByPath.get(location);",
          "165:             checksum = Checksum.forFile(file);",
          "166:             checksumsByPath.put(location, checksum);",
          "",
          "[Removed Lines]",
          "163:             if (checksum != null) return checksum;",
          "",
          "[Added Lines]",
          "165:             if (checksum != null) {",
          "166:                 return checksum;",
          "167:             }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "168:         }",
          "169:     }",
          "173:         File parent = target.getParentFile();",
          "174:         Files.createDirectories(parent.toPath());",
          "",
          "[Removed Lines]",
          "171:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"This path exists within a temp directory so the potential traversal is limited.\")",
          "",
          "[Added Lines]",
          "175:     @SuppressFBWarnings(",
          "176:             value = \"PATH_TRAVERSAL_IN\",",
          "177:             justification = \"This path exists within a temp directory so the potential traversal is limited.\")",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "181:     File map(long sum1, long sum2) {",
          "185:     }",
          "187:     private static final Logger LOGGER = Logger.getLogger(FileSystemJarCache.class.getName());",
          "",
          "[Removed Lines]",
          "182:         return new File(rootDir,String.format(\"%02X/%014X%016X.jar\",",
          "183:                 (int)(sum1>>>(64-8)),",
          "184:                 sum1&0x00FFFFFFFFFFFFFFL, sum2));",
          "",
          "[Added Lines]",
          "188:         return new File(",
          "189:                 rootDir,",
          "190:                 String.format(\"%02X/%014X%016X.jar\", (int) (sum1 >>> (64 - 8)), sum1 & 0x00FFFFFFFFFFFFFFL, sum2));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/FlightRecorderInputStream.java||src/main/java/hudson/remoting/FlightRecorderInputStream.java": [
          "File: src/main/java/hudson/remoting/FlightRecorderInputStream.java -> src/main/java/hudson/remoting/FlightRecorderInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     private final InputStream source;",
          "28:     private ByteArrayRingBuffer recorder = new ByteArrayRingBuffer(BUFFER_SIZE);",
          "",
          "[Removed Lines]",
          "25:     static final int BUFFER_SIZE = Integer.getInteger(\"hudson.remoting.FlightRecorderInputStream.BUFFER_SIZE\", 1024 * 1024);",
          "",
          "[Added Lines]",
          "25:     static final int BUFFER_SIZE =",
          "26:             Integer.getInteger(\"hudson.remoting.FlightRecorderInputStream.BUFFER_SIZE\", 1024 * 1024);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:         final ByteArrayOutputStream readAhead = new ByteArrayOutputStream();",
          "54:         final IOException[] error = new IOException[1];",
          "57:             @Override",
          "58:             public void run() {",
          "59:                 int b;",
          "60:                 try {",
          "63:                         readAhead.write(b);",
          "64:                     }",
          "65:                 } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "56:         Thread diagnosisThread = new Thread(diagnosisName+\" stream corruption diagnosis thread\") {",
          "62:                     while (!Thread.interrupted() && (b=source.read())!=-1) {",
          "",
          "[Added Lines]",
          "57:         Thread diagnosisThread = new Thread(diagnosisName + \" stream corruption diagnosis thread\") {",
          "64:                     while (!Thread.interrupted() && (b = source.read()) != -1) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:         }",
          "83:         IOException diagnosisProblem = error[0]; // capture the error, if any, before we kill the thread",
          "89:     }",
          "91:     @Override",
          "92:     public int read() throws IOException {",
          "93:         int i = source.read();",
          "95:             recorder.write(i);",
          "96:         return i;",
          "97:     }",
          "99:     @Override",
          "100:     public int read(@NonNull byte[] b, int off, int len) throws IOException {",
          "101:         len = source.read(b, off, len);",
          "104:         return len;",
          "105:     }",
          "",
          "[Removed Lines]",
          "84:         if (diagnosisThread.isAlive())",
          "85:             diagnosisThread.interrupt();    // if it's not dead, kill",
          "87:         return new DiagnosedStreamCorruptionException(problem,diagnosisProblem,getRecord(),readAhead.toByteArray());",
          "94:         if (i>=0)",
          "102:         if (len>0)",
          "103:             recorder.write(b,off,len);",
          "",
          "[Added Lines]",
          "86:         if (diagnosisThread.isAlive()) {",
          "87:             diagnosisThread.interrupt(); // if it's not dead, kill",
          "88:         }",
          "90:         return new DiagnosedStreamCorruptionException(problem, diagnosisProblem, getRecord(), readAhead.toByteArray());",
          "96:         if (i >= 0) {",
          "98:         }",
          "105:         if (len > 0) {",
          "106:             recorder.write(b, off, len);",
          "107:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:     @Override",
          "111:     public long skip(long n) throws IOException {",
          "114:     }",
          "116:     @Override",
          "",
          "[Removed Lines]",
          "112:         byte[] buf = new byte[(int)Math.min(n,64*1024)];",
          "113:         return read(buf,0,buf.length);",
          "",
          "[Added Lines]",
          "116:         byte[] buf = new byte[(int) Math.min(n, 64 * 1024)];",
          "117:         return read(buf, 0, buf.length);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "160:             System.arraycopy(data, 0, ret, capacity - pos, pos);",
          "161:             return ret;",
          "162:         }",
          "167:             if (len > capacity) {",
          "168:                 off += (len - capacity);",
          "",
          "[Removed Lines]",
          "165:         @Override public synchronized void write(@NonNull byte[] buf, int off, int len) {",
          "",
          "[Added Lines]",
          "169:         @Override",
          "170:         public synchronized void write(@NonNull byte[] buf, int off, int len) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Future.java||src/main/java/hudson/remoting/Future.java": [
          "File: src/main/java/hudson/remoting/Future.java -> src/main/java/hudson/remoting/Future.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;",
          "39:         justification = \"This class is just an alias, but this alias is a part of public API\")",
          "",
          "[Removed Lines]",
          "38: @SuppressFBWarnings(value = \"NM_SAME_SIMPLE_NAME_AS_INTERFACE\",",
          "40: public interface Future<V> extends java.util.concurrent.Future<V> {",
          "41: }",
          "",
          "[Added Lines]",
          "38: @SuppressFBWarnings(",
          "39:         value = \"NM_SAME_SIMPLE_NAME_AS_INTERFACE\",",
          "41: public interface Future<V> extends java.util.concurrent.Future<V> {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/FutureAdapter.java||src/main/java/hudson/remoting/FutureAdapter.java": [
          "File: src/main/java/hudson/remoting/FutureAdapter.java -> src/main/java/hudson/remoting/FutureAdapter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:     protected final Future<Y> core;",
          "39:     protected FutureAdapter(Future<Y> core) {",
          "",
          "[Removed Lines]",
          "36: abstract class FutureAdapter<X,Y> implements Future<X> {",
          "",
          "[Added Lines]",
          "36: abstract class FutureAdapter<X, Y> implements Future<X> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:     }",
          "63:     @Override",
          "65:         return adapt(core.get(timeout, unit));",
          "66:     }",
          "",
          "[Removed Lines]",
          "64:     public X get(long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "64:     public X get(long timeout, @NonNull TimeUnit unit)",
          "65:             throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/HexDump.java||src/main/java/hudson/remoting/HexDump.java": [
          "File: src/main/java/hudson/remoting/HexDump.java -> src/main/java/hudson/remoting/HexDump.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "7:     private static final String CODE = \"0123456789abcdef\";",
          "9:     public static String toHex(byte[] buf) {",
          "11:     }",
          "12:     public static String toHex(byte[] buf, int start, int len) {",
          "14:         boolean inText = false;",
          "17:             if (b >= 0x20 && b <= 0x7e) {",
          "18:                 if (!inText) {",
          "19:                     inText = true;",
          "",
          "[Removed Lines]",
          "10:         return toHex(buf,0,buf.length);",
          "13:         StringBuilder r = new StringBuilder(len*2);",
          "15:         for (int i=0; i<len; i++) {",
          "16:             byte b = buf[start+i];",
          "",
          "[Added Lines]",
          "10:         return toHex(buf, 0, buf.length);",
          "14:         StringBuilder r = new StringBuilder(len * 2);",
          "16:         for (int i = 0; i < len; i++) {",
          "17:             byte b = buf[start + i];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:                     inText = false;",
          "27:                 }",
          "28:                 r.append(\"0x\");",
          "31:                 if (i < len - 1) {",
          "32:                     if (b == 10) {",
          "33:                         r.append('\\n');",
          "",
          "[Removed Lines]",
          "29:                 r.append(CODE.charAt((b>>4)&15));",
          "30:                 r.append(CODE.charAt(b&15));",
          "",
          "[Added Lines]",
          "30:                 r.append(CODE.charAt((b >> 4) & 15));",
          "31:                 r.append(CODE.charAt(b & 15));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/IChannel.java||src/main/java/hudson/remoting/IChannel.java": [
          "File: src/main/java/hudson/remoting/IChannel.java -> src/main/java/hudson/remoting/IChannel.java"
        ],
        "src/main/java/hudson/remoting/IReadResolve.java||src/main/java/hudson/remoting/IReadResolve.java": [
          "File: src/main/java/hudson/remoting/IReadResolve.java -> src/main/java/hudson/remoting/IReadResolve.java"
        ],
        "src/main/java/hudson/remoting/ImportedClassLoaderTable.java||src/main/java/hudson/remoting/ImportedClassLoaderTable.java": [
          "File: src/main/java/hudson/remoting/ImportedClassLoaderTable.java -> src/main/java/hudson/remoting/ImportedClassLoaderTable.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     @NonNull",
          "51:     public ClassLoader get(int oid) {",
          "53:     }",
          "",
          "[Removed Lines]",
          "52:         return get(RemoteInvocationHandler.wrap(channel, oid, RemoteClassLoader.IClassLoader.class, false, false, false, false));",
          "",
          "[Added Lines]",
          "52:         return get(RemoteInvocationHandler.wrap(",
          "53:                 channel, oid, RemoteClassLoader.IClassLoader.class, false, false, false, false));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:     @NonNull",
          "62:     public ClassLoader get(@NonNull RemoteClassLoader.IClassLoader classLoaderProxy) {",
          "65:     }",
          "66: }",
          "",
          "[Removed Lines]",
          "64:         return classLoaders.computeIfAbsent(classLoaderProxy, proxy -> RemoteClassLoader.create(channel.baseClassLoader, proxy));",
          "",
          "[Added Lines]",
          "65:         return classLoaders.computeIfAbsent(",
          "66:                 classLoaderProxy, proxy -> RemoteClassLoader.create(channel.baseClassLoader, proxy));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/InitializeJarCacheMain.java||src/main/java/hudson/remoting/InitializeJarCacheMain.java": [
          "File: src/main/java/hudson/remoting/InitializeJarCacheMain.java -> src/main/java/hudson/remoting/InitializeJarCacheMain.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     public static void main(String[] argv) throws Exception {",
          "32:         if (argv.length != 2) {",
          "36:         }",
          "38:         File sourceJarDir = new File(argv[0]);",
          "",
          "[Removed Lines]",
          "30:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"These file values are provided by users with sufficient administrative permissions to run this utility program.\")",
          "33:             throw new IllegalArgumentException(",
          "34:                     \"Usage: java -cp agent.jar hudson.remoting.InitializeJarCacheMain \" +",
          "35:                     \"<source jar dir> <jar cache dir>\");",
          "",
          "[Added Lines]",
          "30:     @SuppressFBWarnings(",
          "31:             value = \"PATH_TRAVERSAL_IN\",",
          "32:             justification =",
          "33:                     \"These file values are provided by users with sufficient administrative permissions to run this utility program.\")",
          "36:             throw new IllegalArgumentException(\"Usage: java -cp agent.jar hudson.remoting.InitializeJarCacheMain \"",
          "37:                     + \"<source jar dir> <jar cache dir>\");",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/InterceptingExecutorService.java||src/main/java/hudson/remoting/InterceptingExecutorService.java": [
          "File: src/main/java/hudson/remoting/InterceptingExecutorService.java -> src/main/java/hudson/remoting/InterceptingExecutorService.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:     @Override",
          "47:     @NonNull",
          "48:     public <T> Future<T> submit(@NonNull Runnable task, T result) {",
          "50:     }",
          "52:     @Override",
          "",
          "[Removed Lines]",
          "49:         return super.submit(wrap(task,result));",
          "",
          "[Added Lines]",
          "49:         return super.submit(wrap(task, result));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     @Override",
          "59:     @NonNull",
          "61:         return super.invokeAll(wrap(tasks), timeout, unit);",
          "62:     }",
          "64:     @Override",
          "65:     @NonNull",
          "67:         return super.invokeAny(wrap(tasks));",
          "68:     }",
          "70:     @Override",
          "72:         return super.invokeAny(wrap(tasks), timeout, unit);",
          "73:     }",
          "",
          "[Removed Lines]",
          "60:     public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit) throws InterruptedException {",
          "66:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {",
          "71:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "60:     public <T> List<Future<T>> invokeAll(",
          "61:             @NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)",
          "62:             throws InterruptedException {",
          "68:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks)",
          "69:             throws InterruptedException, ExecutionException {",
          "74:     public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks, long timeout, @NonNull TimeUnit unit)",
          "75:             throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/JarCache.java||src/main/java/hudson/remoting/JarCache.java": [
          "File: src/main/java/hudson/remoting/JarCache.java -> src/main/java/hudson/remoting/JarCache.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     public static final File DEFAULT_NOWS_JAR_CACHE_LOCATION =",
          "",
          "[Removed Lines]",
          "28:         new File(System.getProperty(\"user.home\"),\".jenkins/cache/jars\");",
          "",
          "[Added Lines]",
          "28:             new File(System.getProperty(\"user.home\"), \".jenkins/cache/jars\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:     @NonNull",
          "59: }",
          "",
          "[Removed Lines]",
          "58:     public abstract CompletableFuture<URL> resolve(@NonNull Channel channel, long sum1, long sum2) throws IOException, InterruptedException;",
          "",
          "[Added Lines]",
          "58:     public abstract CompletableFuture<URL> resolve(@NonNull Channel channel, long sum1, long sum2)",
          "59:             throws IOException, InterruptedException;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/JarCacheSupport.java||src/main/java/hudson/remoting/JarCacheSupport.java": [
          "File: src/main/java/hudson/remoting/JarCacheSupport.java -> src/main/java/hudson/remoting/JarCacheSupport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "28:     private final ConcurrentMap<Checksum,CompletableFuture<URL>> inprogress = new ConcurrentHashMap<>();",
          "",
          "[Added Lines]",
          "28:     private final ConcurrentMap<Checksum, CompletableFuture<URL>> inprogress = new ConcurrentHashMap<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:     private final ExecutorService downloader = newCachingSingleThreadExecutor(",
          "50:     private static ExecutorService newCachingSingleThreadExecutor(ThreadFactory threadFactory) {",
          "51:         ThreadPoolExecutor threadPoolExecutor =",
          "",
          "[Removed Lines]",
          "47:             new NamingThreadFactory(new DaemonThreadFactory(), JarCacheSupport.class.getSimpleName())",
          "48:     );",
          "",
          "[Added Lines]",
          "47:             new NamingThreadFactory(new DaemonThreadFactory(), JarCacheSupport.class.getSimpleName()));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57:     @Override",
          "58:     @NonNull",
          "63:             return CompletableFuture.completedFuture(jar);",
          "64:         }",
          "",
          "[Removed Lines]",
          "59:     public CompletableFuture<URL> resolve(@NonNull final Channel channel, final long sum1, final long sum2) throws IOException, InterruptedException {",
          "60:         URL jar = lookInCache(channel,sum1, sum2);",
          "61:         if (jar!=null) {",
          "",
          "[Added Lines]",
          "58:     public CompletableFuture<URL> resolve(@NonNull final Channel channel, final long sum1, final long sum2)",
          "59:             throws IOException, InterruptedException {",
          "60:         URL jar = lookInCache(channel, sum1, sum2);",
          "61:         if (jar != null) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98:                 if (inprogress.remove(key, promise)) {",
          "99:                     promise.complete(url);",
          "100:                 } else {",
          "102:                 }",
          "103:             } catch (ChannelClosedException | RequestAbortedException e) {",
          "",
          "[Removed Lines]",
          "101:                     promise.completeExceptionally(new IllegalStateException(\"Download is (unexpectedly) no longer in progress\"));",
          "",
          "[Added Lines]",
          "101:                     promise.completeExceptionally(",
          "102:                             new IllegalStateException(\"Download is (unexpectedly) no longer in progress\"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "127:         private void bailout(Throwable e) {",
          "130:         }",
          "131:     }",
          "133:     protected JarLoader getJarLoader(Channel channel) throws InterruptedException {",
          "134:         JarLoader jl = channel.getProperty(JarLoader.THEIRS);",
          "136:             jl = (JarLoader) channel.waitForRemoteProperty(JarLoader.OURS);",
          "138:         }",
          "139:         return jl;",
          "140:     }",
          "142:     private static final Logger LOGGER = Logger.getLogger(JarCacheSupport.class.getName());",
          "143: }",
          "",
          "[Removed Lines]",
          "128:             inprogress.remove(key, promise);     // this lets another thread to retry later",
          "129:             promise.completeExceptionally(e);             // then tell those who are waiting that we aborted",
          "135:         if (jl==null) {// even if two threads run this simultaneously, it is harmless",
          "137:             channel.setProperty(JarLoader.THEIRS,jl);",
          "",
          "[Added Lines]",
          "129:             inprogress.remove(key, promise); // this lets another thread to retry later",
          "130:             promise.completeExceptionally(e); // then tell those who are waiting that we aborted",
          "136:         if (jl == null) { // even if two threads run this simultaneously, it is harmless",
          "138:             channel.setProperty(JarLoader.THEIRS, jl);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/JarLoader.java||src/main/java/hudson/remoting/JarLoader.java": [
          "File: src/main/java/hudson/remoting/JarLoader.java -> src/main/java/hudson/remoting/JarLoader.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     boolean isPresentOnRemote(Checksum sum);",
          "56:     ChannelProperty<JarLoader> THEIRS = new ChannelProperty<>(JarLoader.class, \"their JarLoader\");",
          "57: }",
          "",
          "[Removed Lines]",
          "55:     String OURS = JarLoader.class.getName()+\".ours\";",
          "",
          "[Added Lines]",
          "55:     String OURS = JarLoader.class.getName() + \".ours\";",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/JarLoaderImpl.java||src/main/java/hudson/remoting/JarLoaderImpl.java": [
          "File: src/main/java/hudson/remoting/JarLoaderImpl.java -> src/main/java/hudson/remoting/JarLoaderImpl.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:     private static final Logger LOGGER = Logger.getLogger(JarLoaderImpl.class.getName());",
          "32:     private final Set<Checksum> presentOnRemote = Collections.synchronizedSet(new HashSet<>());",
          "34:     @Override",
          "36:     public void writeJarTo(long sum1, long sum2, OutputStream sink) throws IOException, InterruptedException {",
          "37:         Checksum k = new Checksum(sum1, sum2);",
          "38:         URL url = knownJars.get(k);",
          "42:         Channel channel = Channel.current();",
          "43:         if (channel != null) {",
          "",
          "[Removed Lines]",
          "28:     private final ConcurrentMap<Checksum,URL> knownJars = new ConcurrentHashMap<>();",
          "30:     private final ConcurrentMap<URL,Checksum> checksums = new ConcurrentHashMap<>();",
          "35:     @SuppressFBWarnings(value = {\"URLCONNECTION_SSRF_FD\", \"PATH_TRAVERSAL_IN\"}, justification = \"This is only used for managing the jar cache as files, not URLs.\")",
          "39:         if (url==null)",
          "40:             throw new IOException(\"Unadvertised jar file \"+k);",
          "",
          "[Added Lines]",
          "28:     private final ConcurrentMap<Checksum, URL> knownJars = new ConcurrentHashMap<>();",
          "30:     private final ConcurrentMap<URL, Checksum> checksums = new ConcurrentHashMap<>();",
          "35:     @SuppressFBWarnings(",
          "36:             value = {\"URLCONNECTION_SSRF_FD\", \"PATH_TRAVERSAL_IN\"},",
          "37:             justification = \"This is only used for managing the jar cache as files, not URLs.\")",
          "41:         if (url == null) {",
          "42:             throw new IOException(\"Unadvertised jar file \" + k);",
          "43:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     @Override",
          "70:     public void notifyJarPresence(long sum1, long sum2) {",
          "72:     }",
          "74:     @Override",
          "75:     public void notifyJarPresence(long[] sums) {",
          "76:         synchronized (presentOnRemote) {",
          "79:         }",
          "80:     }",
          "",
          "[Removed Lines]",
          "71:         presentOnRemote.add(new Checksum(sum1,sum2));",
          "77:             for (int i=0; i<sums.length; i+=2)",
          "78:                 presentOnRemote.add(new Checksum(sums[i*2],sums[i*2+1]));",
          "",
          "[Added Lines]",
          "74:         presentOnRemote.add(new Checksum(sum1, sum2));",
          "80:             for (int i = 0; i < sums.length; i += 2) {",
          "81:                 presentOnRemote.add(new Checksum(sums[i * 2], sums[i * 2 + 1]));",
          "82:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:     public Checksum calcChecksum(URL jar) throws IOException {",
          "89:         v = Checksum.forURL(jar);",
          "93:         return v;",
          "94:     }",
          "",
          "[Removed Lines]",
          "86:         Checksum v = checksums.get(jar);    // cache hit",
          "87:         if (v!=null)    return v;",
          "91:         knownJars.put(v,jar);",
          "92:         checksums.put(jar,v);",
          "",
          "[Added Lines]",
          "90:         Checksum v = checksums.get(jar); // cache hit",
          "91:         if (v != null) {",
          "92:             return v;",
          "93:         }",
          "97:         knownJars.put(v, jar);",
          "98:         checksums.put(jar, v);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:         return getChannelForSerialization().export(JarLoader.class, this);",
          "101:     }",
          "105:     private static final long serialVersionUID = 1L;",
          "106: }",
          "",
          "[Removed Lines]",
          "103:     public static final String DIGEST_ALGORITHM = System.getProperty(JarLoaderImpl.class.getName()+\".algorithm\",\"SHA-256\");",
          "",
          "[Added Lines]",
          "109:     public static final String DIGEST_ALGORITHM =",
          "110:             System.getProperty(JarLoaderImpl.class.getName() + \".algorithm\", \"SHA-256\");",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Launcher.java||src/main/java/hudson/remoting/Launcher.java": [
          "File: src/main/java/hudson/remoting/Launcher.java -> src/main/java/hudson/remoting/Launcher.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: public class Launcher {",
          "101:     public Channel.Mode mode = Channel.Mode.BINARY;",
          "",
          "[Removed Lines]",
          "99: @SuppressFBWarnings(value = \"DM_EXIT\", justification = \"This class is runnable. It is eligible to exit in the case of wrong params\")",
          "",
          "[Added Lines]",
          "99: @SuppressFBWarnings(",
          "100:         value = \"DM_EXIT\",",
          "101:         justification = \"This class is runnable. It is eligible to exit in the case of wrong params\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:     @CheckForNull",
          "117:     public File agentLog = null;",
          "121:     public void setTextMode(boolean b) {",
          "122:         mode = b ? Channel.Mode.TEXT : Channel.Mode.BINARY;",
          "124:     }",
          "",
          "[Removed Lines]",
          "115:     @Option(name=\"-agentLog\", usage=\"Local agent error log destination (overrides workDir)\")",
          "119:     @Option(name=\"-text\",usage=\"encode communication with the controller with base64. \" +",
          "120:             \"Useful for running agent over 8-bit unsafe protocol like telnet\")",
          "123:         System.out.println(\"Running in \"+mode.name().toLowerCase(Locale.ENGLISH)+\" mode\");",
          "",
          "[Added Lines]",
          "117:     @Option(name = \"-agentLog\", usage = \"Local agent error log destination (overrides workDir)\")",
          "121:     @Option(",
          "122:             name = \"-text\",",
          "123:             usage = \"encode communication with the controller with base64. \"",
          "124:                     + \"Useful for running agent over 8-bit unsafe protocol like telnet\")",
          "127:         System.out.println(\"Running in \" + mode.name().toLowerCase(Locale.ENGLISH) + \" mode\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:     @Deprecated",
          "145:     public URL agentJnlpURL = null;",
          "148:     public String agentJnlpCredentials = null;",
          "151:     public String secret;",
          "154:     public String name;",
          "157:     public String proxyCredentials = System.getProperty(\"proxyCredentials\");",
          "",
          "[Removed Lines]",
          "141:     @Option(name=\"-jnlpUrl\",usage=\"instead of talking to the controller via stdin/stdout, \" +",
          "142:             \"emulate a JNLP client by making a TCP connection to the controller. \" +",
          "143:             \"Connection parameters are obtained by parsing the JNLP file.\", forbids = {\"-direct\", \"-name\", \"-tunnel\", \"-url\", \"-webSocket\"})",
          "147:     @Option(name=\"-credentials\",metaVar=\"USER:PASSWORD\",aliases=\"-jnlpCredentials\",usage=\"HTTP BASIC AUTH header to pass in for making HTTP requests.\")",
          "150:     @Option(name=\"-secret\", metaVar=\"HEX_SECRET\", usage=\"Agent connection secret.\")",
          "153:     @Option(name=\"-name\", usage=\"Name of the agent.\")",
          "156:     @Option(name=\"-proxyCredentials\",metaVar=\"USER:PASSWORD\",usage=\"HTTP BASIC AUTH header to pass in for making HTTP authenticated proxy requests.\")",
          "",
          "[Added Lines]",
          "145:     @Option(",
          "146:             name = \"-jnlpUrl\",",
          "147:             usage = \"instead of talking to the controller via stdin/stdout, \"",
          "148:                     + \"emulate a JNLP client by making a TCP connection to the controller. \"",
          "149:                     + \"Connection parameters are obtained by parsing the JNLP file.\",",
          "150:             forbids = {\"-direct\", \"-name\", \"-tunnel\", \"-url\", \"-webSocket\"})",
          "154:     @Option(",
          "155:             name = \"-credentials\",",
          "156:             metaVar = \"USER:PASSWORD\",",
          "157:             aliases = \"-jnlpCredentials\",",
          "158:             usage = \"HTTP BASIC AUTH header to pass in for making HTTP requests.\")",
          "161:     @Option(name = \"-secret\", metaVar = \"HEX_SECRET\", usage = \"Agent connection secret.\")",
          "164:     @Option(name = \"-name\", usage = \"Name of the agent.\")",
          "167:     @Option(",
          "168:             name = \"-proxyCredentials\",",
          "169:             metaVar = \"USER:PASSWORD\",",
          "170:             usage = \"HTTP BASIC AUTH header to pass in for making HTTP authenticated proxy requests.\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:     @Deprecated",
          "172:     public void setTcpPortFile(File tcpPortFile) {",
          "173:         this.tcpPortFile = tcpPortFile;",
          "174:         System.err.println(",
          "",
          "[Removed Lines]",
          "169:     @Option(name=\"-tcp\",usage=\"(deprecated) instead of talking to the controller via stdin/stdout, \" +",
          "170:             \"listens to a random local port, write that port number to the given file, \" +",
          "171:             \"then wait for the controller to connect to that port.\")",
          "",
          "[Added Lines]",
          "183:     @Option(",
          "184:             name = \"-tcp\",",
          "185:             usage = \"(deprecated) instead of talking to the controller via stdin/stdout, \"",
          "186:                     + \"listens to a random local port, write that port number to the given file, \"",
          "187:                     + \"then wait for the controller to connect to that port.\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "198:     @CheckForNull",
          "200:     public File jarCache = null;",
          "",
          "[Removed Lines]",
          "199:     @Option(name=\"-jar-cache\",metaVar=\"DIR\",usage=\"Cache directory that stores jar files sent from the controller\")",
          "",
          "[Added Lines]",
          "215:     @Option(",
          "216:             name = \"-jar-cache\",",
          "217:             metaVar = \"DIR\",",
          "218:             usage = \"Cache directory that stores jar files sent from the controller\")",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "206:     @CheckForNull",
          "208:     public File loggingConfigFilePath = null;",
          "214:     public List<String> candidateCertificates;",
          "216:     private List<X509Certificate> x509Certificates;",
          "",
          "[Removed Lines]",
          "207:     @Option(name=\"-loggingConfig\",usage=\"Path to the property file with java.util.logging settings\")",
          "210:     @Option(name = \"-cert\",",
          "211:             usage = \"Specify additional X.509 encoded PEM certificates to trust when connecting to Jenkins \" +",
          "212:                     \"root URLs. If starting with @ then the remainder is assumed to be the name of the \" +",
          "213:                     \"certificate file to read.\", forbids = \"-noCertificateCheck\")",
          "",
          "[Added Lines]",
          "226:     @Option(name = \"-loggingConfig\", usage = \"Path to the property file with java.util.logging settings\")",
          "229:     @Option(",
          "230:             name = \"-cert\",",
          "231:             usage = \"Specify additional X.509 encoded PEM certificates to trust when connecting to Jenkins \"",
          "232:                     + \"root URLs. If starting with @ then the remainder is assumed to be the name of the \"",
          "233:                     + \"certificate file to read.\",",
          "234:             forbids = \"-noCertificateCheck\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "225:     public boolean noCertificateCheck = false;",
          "227:     private HostnameVerifier hostnameVerifier;",
          "",
          "[Removed Lines]",
          "224:     @Option(name=\"-noCertificateCheck\", aliases = \"-disableHttpsCertValidation\", forbids = \"-cert\", usage=\"Ignore SSL validation errors - use as a last resort only.\")",
          "",
          "[Added Lines]",
          "245:     @Option(",
          "246:             name = \"-noCertificateCheck\",",
          "247:             aliases = \"-disableHttpsCertValidation\",",
          "248:             forbids = \"-cert\",",
          "249:             usage = \"Ignore SSL validation errors - use as a last resort only.\")",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "238:     @Deprecated",
          "240:     public void setConnectTo(String target) {",
          "241:         String[] tokens = target.split(\":\");",
          "244:             System.exit(1);",
          "245:         }",
          "247:         System.err.println(",
          "248:                 \"WARNING: The \\\"-connectTo\\\" argument is deprecated and will be removed without replacement in a future release.\");",
          "249:     }",
          "252:     public boolean noReconnect = false;",
          "255:     public Duration noReconnectAfter;",
          "259:     public boolean noKeepAlive = false;",
          "",
          "[Removed Lines]",
          "239:     @Option(name=\"-connectTo\",usage=\"(deprecated) make a TCP connection to the given host and port, then start communication.\",metaVar=\"HOST:PORT\")",
          "242:         if(tokens.length!=2) {",
          "243:             System.err.println(\"Illegal parameter: \"+target);",
          "246:         connectionTarget = new InetSocketAddress(tokens[0],Integer.parseInt(tokens[1]));",
          "251:     @Option(name=\"-noReconnect\",aliases=\"-noreconnect\",usage=\"Doesn't try to reconnect when a communication fail, and exit instead\")",
          "254:     @Option(name=\"-noReconnectAfter\",usage = \"Bail out after the given time after the first attempt to reconnect\", handler = DurationOptionHandler.class, forbids = \"-noReconnect\")",
          "257:     @Option(name = \"-noKeepAlive\",",
          "258:             usage = \"Disable TCP socket keep alive on connection to the controller.\")",
          "",
          "[Added Lines]",
          "264:     @Option(",
          "265:             name = \"-connectTo\",",
          "266:             usage = \"(deprecated) make a TCP connection to the given host and port, then start communication.\",",
          "267:             metaVar = \"HOST:PORT\")",
          "270:         if (tokens.length != 2) {",
          "271:             System.err.println(\"Illegal parameter: \" + target);",
          "274:         connectionTarget = new InetSocketAddress(tokens[0], Integer.parseInt(tokens[1]));",
          "279:     @Option(",
          "280:             name = \"-noReconnect\",",
          "281:             aliases = \"-noreconnect\",",
          "282:             usage = \"Doesn't try to reconnect when a communication fail, and exit instead\")",
          "285:     @Option(",
          "286:             name = \"-noReconnectAfter\",",
          "287:             usage = \"Bail out after the given time after the first attempt to reconnect\",",
          "288:             handler = DurationOptionHandler.class,",
          "289:             forbids = \"-noReconnect\")",
          "292:     @Option(name = \"-noKeepAlive\", usage = \"Disable TCP socket keep alive on connection to the controller.\")",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "271:             usage = \"Declares the working directory of the remoting instance (stores cache and logs by default)\")",
          "272:     @CheckForNull",
          "273:     public File workDir = null;",
          "",
          "[Removed Lines]",
          "270:     @Option(name = \"-workDir\",",
          "",
          "[Added Lines]",
          "304:     @Option(",
          "305:             name = \"-workDir\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "283:             usage = \"Specifies a name of the internal files within a working directory ('remoting' by default)\",",
          "284:             depends = \"-workDir\")",
          "285:     @NonNull",
          "",
          "[Removed Lines]",
          "282:     @Option(name = \"-internalDir\",",
          "",
          "[Added Lines]",
          "317:     @Option(",
          "318:             name = \"-internalDir\",",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "295:             usage = \"Fails the initialization if the requested workDir or internalDir are missing ('false' by default)\",",
          "296:             depends = \"-workDir\")",
          "297:     public boolean failIfWorkDirIsMissing = WorkDirManager.DEFAULT_FAIL_IF_WORKDIR_IS_MISSING;",
          "300:             metaVar = \"HOST:PORT\",",
          "301:             usage = \"Connect to the specified host and port, instead of connecting directly to Jenkins. \"",
          "302:                     + \"Useful when connection to Jenkins needs to be tunneled. Can be also HOST: or :PORT, \"",
          "",
          "[Removed Lines]",
          "294:     @Option(name = \"-failIfWorkDirIsMissing\",",
          "299:     @Option(name = \"-tunnel\",",
          "",
          "[Added Lines]",
          "330:     @Option(",
          "331:             name = \"-failIfWorkDirIsMissing\",",
          "336:     @Option(",
          "337:             name = \"-tunnel\",",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "323:     @Option(name = \"-url\", usage = \"Specify the Jenkins root URLs to connect to.\")",
          "324:     public List<URL> urls = new ArrayList<>();",
          "327:             usage = \"Make a WebSocket connection to Jenkins rather than using the TCP port.\",",
          "328:             depends = \"-url\",",
          "335:     public boolean webSocket;",
          "339:             metaVar = \"NAME=VALUE\",",
          "340:             depends = \"-webSocket\")",
          "341:     public Map<String, String> webSocketHeaders;",
          "",
          "[Removed Lines]",
          "326:     @Option(name = \"-webSocket\",",
          "329:             forbids = {",
          "330:                 \"-direct\",",
          "331:                 \"-tunnel\",",
          "332:                 \"-credentials\",",
          "333:                 \"-noKeepAlive\"",
          "334:             })",
          "337:     @Option(name = \"-webSocketHeader\",",
          "338:             usage = \"Additional WebSocket header to set, eg for authenticating with reverse proxies. To specify multiple headers, call this flag multiple times, one with each header\",",
          "",
          "[Added Lines]",
          "364:     @Option(",
          "365:             name = \"-webSocket\",",
          "368:             forbids = {\"-direct\", \"-tunnel\", \"-credentials\", \"-noKeepAlive\"})",
          "371:     @Option(",
          "372:             name = \"-webSocketHeader\",",
          "373:             usage =",
          "374:                     \"Additional WebSocket header to set, eg for authenticating with reverse proxies. To specify multiple headers, call this flag multiple times, one with each header\",",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "348:             metaVar = \"HOST:PORT\",",
          "349:             aliases = \"-directConnection\",",
          "350:             depends = \"-instanceIdentity\",",
          "351:             forbids = {\"-jnlpUrl\", \"-url\", \"-tunnel\"},",
          "353:     public String directConnection;",
          "",
          "[Removed Lines]",
          "347:     @Option(name = \"-direct\",",
          "352:             usage = \"Connect directly to this TCP agent port, skipping the HTTP(S) connection parameter download. For example, \\\"myjenkins:50000\\\".\")",
          "",
          "[Added Lines]",
          "383:     @Option(",
          "384:             name = \"-direct\",",
          "389:             usage =",
          "390:                     \"Connect directly to this TCP agent port, skipping the HTTP(S) connection parameter download. For example, \\\"myjenkins:50000\\\".\")",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "361:             depends = \"-direct\",",
          "363:     public String instanceIdentity;",
          "",
          "[Removed Lines]",
          "360:     @Option(name = \"-instanceIdentity\",",
          "362:             usage = \"The base64 encoded InstanceIdentity byte array of the Jenkins controller. When this is set, the agent skips connecting to an HTTP(S) port for connection info.\")",
          "",
          "[Added Lines]",
          "398:     @Option(",
          "399:             name = \"-instanceIdentity\",",
          "401:             usage =",
          "402:                     \"The base64 encoded InstanceIdentity byte array of the Jenkins controller. When this is set, the agent skips connecting to an HTTP(S) port for connection info.\")",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "372:             depends = {\"-direct\"},",
          "373:             usage = \"Specify the remoting protocols to attempt when instanceIdentity is provided.\")",
          "374:     public List<String> protocols = new ArrayList<>();",
          "",
          "[Removed Lines]",
          "371:     @Option(name = \"-protocols\",",
          "",
          "[Added Lines]",
          "411:     @Option(",
          "412:             name = \"-protocols\",",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "381:     public boolean showHelp = false;",
          "388:     public boolean showVersion = false;",
          "",
          "[Removed Lines]",
          "380:     @Option(name=\"-help\",usage=\"Show this help message\")",
          "387:     @Option(name=\"-version\",usage=\"Shows the version of the remoting jar and then exits\")",
          "",
          "[Added Lines]",
          "421:     @Option(name = \"-help\", usage = \"Show this help message\")",
          "428:     @Option(name = \"-version\", usage = \"Shows the version of the remoting jar and then exits\")",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "420:         }",
          "421:     }",
          "424:     public void run() throws CmdLineException, IOException, InterruptedException {",
          "425:         if (showVersion) {",
          "426:             String version = Util.getVersion();",
          "428:                 System.out.println(version);",
          "429:             }",
          "430:             return;",
          "",
          "[Removed Lines]",
          "423:     @SuppressFBWarnings(value = \"DM_DEFAULT_ENCODING\", justification = \"log file, just like console output, should be in platform default encoding\")",
          "427:             if(version != null) {",
          "",
          "[Added Lines]",
          "464:     @SuppressFBWarnings(",
          "465:             value = \"DM_DEFAULT_ENCODING\",",
          "466:             justification = \"log file, just like console output, should be in platform default encoding\")",
          "470:             if (version != null) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "508:                             cert = new byte[(int) length];",
          "516:                         } catch (IOException e) {",
          "517:                             LOGGER.log(Level.WARNING, e, () -> \"Could not read certificate from \" + file);",
          "518:                             continue;",
          "519:                         }",
          "520:                     } else {",
          "521:                         if (file.isFile()) {",
          "525:                                     file.getAbsolutePath());",
          "526:                         } else {",
          "528:                                     file.getAbsolutePath());",
          "529:                         }",
          "530:                         continue;",
          "",
          "[Removed Lines]",
          "509:                                 int read = fis.read(cert);",
          "510:                                 if (cert.length != read) {",
          "511:                                     LOGGER.log(Level.WARNING, \"Only read {0} bytes from {1}, expected to read {2}\",",
          "512:                                             new Object[]{read, file, cert.length});",
          "514:                                     continue;",
          "515:                                 }",
          "522:                             LOGGER.log(Level.WARNING,",
          "523:                                     \"Could not read certificate from {0}. File size is not within \" +",
          "524:                                             \"the expected range for a PEM encoded X.509 certificate\",",
          "527:                             LOGGER.log(Level.WARNING, \"Could not read certificate from {0}. File not found\",",
          "",
          "[Added Lines]",
          "554:                             int read = fis.read(cert);",
          "555:                             if (cert.length != read) {",
          "556:                                 LOGGER.log(",
          "557:                                         Level.WARNING,",
          "558:                                         \"Only read {0} bytes from {1}, expected to read {2}\",",
          "559:                                         new Object[] {read, file, cert.length});",
          "561:                                 continue;",
          "562:                             }",
          "569:                             LOGGER.log(",
          "570:                                     Level.WARNING,",
          "571:                                     \"Could not read certificate from {0}. File size is not within \"",
          "572:                                             + \"the expected range for a PEM encoded X.509 certificate\",",
          "575:                             LOGGER.log(",
          "576:                                     Level.WARNING,",
          "577:                                     \"Could not read certificate from {0}. File not found\",",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "683:         initialize();",
          "684:         if (secret != null) {",
          "685:             agentJnlpURL = new URL(agentJnlpURL + \"?encrypt=true\");",
          "",
          "[Removed Lines]",
          "681:     @SuppressFBWarnings(value = {\"CIPHER_INTEGRITY\", \"STATIC_IV\"}, justification = \"Integrity not needed here. IV used for decryption only, loaded from encryptor.\")",
          "682:     private List<String> parseJnlpArguments() throws ParserConfigurationException, SAXException, IOException, InterruptedException {",
          "",
          "[Added Lines]",
          "731:     @SuppressFBWarnings(",
          "732:             value = {\"CIPHER_INTEGRITY\", \"STATIC_IV\"},",
          "733:             justification = \"Integrity not needed here. IV used for decryption only, loaded from encryptor.\")",
          "734:     private List<String> parseJnlpArguments()",
          "735:             throws ParserConfigurationException, SAXException, IOException, InterruptedException {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "691:         while (true) {",
          "692:             URLConnection con = null;",
          "693:             try {",
          "695:                 con.connect();",
          "697:                 if (con instanceof HttpURLConnection) {",
          "698:                     HttpURLConnection http = (HttpURLConnection) con;",
          "702:                 }",
          "704:                 Document dom;",
          "707:                 String contentType = con.getHeaderField(\"Content-Type\");",
          "709:                 InputStream input = con.getInputStream();",
          "710:                 if (secret != null) {",
          "711:                     byte[] payload = input.readAllBytes();",
          "",
          "[Removed Lines]",
          "694:                 con = JnlpAgentEndpointResolver.openURLConnection(agentJnlpURL, null, agentJnlpCredentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "699:                     if(http.getResponseCode()>=400)",
          "701:                         throw new IOException(\"Failed to load \"+ agentJnlpURL +\": \"+http.getResponseCode()+\" \"+http.getResponseMessage());",
          "708:                 String expectedContentType = secret == null ? \"application/x-java-jnlp-file\" : \"application/octet-stream\";",
          "",
          "[Added Lines]",
          "747:                 con = JnlpAgentEndpointResolver.openURLConnection(",
          "748:                         agentJnlpURL, null, agentJnlpCredentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "753:                     if (http.getResponseCode() >= 400) {",
          "755:                         throw new IOException(\"Failed to load \" + agentJnlpURL + \": \" + http.getResponseCode() + \" \"",
          "756:                                 + http.getResponseMessage());",
          "757:                     }",
          "764:                 String expectedContentType =",
          "765:                         secret == null ? \"application/x-java-jnlp-file\" : \"application/octet-stream\";",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "714:                     try {",
          "715:                         Cipher cipher = Cipher.getInstance(\"AES/CFB8/NoPadding\");",
          "720:                         input = new ByteArrayInputStream(decrypted);",
          "721:                     } catch (GeneralSecurityException x) {",
          "722:                         throw new IOException(\"Failed to decrypt the JNLP file. Invalid secret key?\", x);",
          "723:                     }",
          "724:                 }",
          "727:                     try {",
          "728:                         dom = loadDom(input);",
          "729:                     } catch (SAXException | IOException e) {",
          "731:                     }",
          "732:                 } else {",
          "733:                     dom = loadDom(input);",
          "",
          "[Removed Lines]",
          "716:                         cipher.init(Cipher.DECRYPT_MODE,",
          "717:                                 new SecretKeySpec(fromHexString(secret.substring(0, Math.min(secret.length(), 32))), \"AES\"),",
          "718:                                 new IvParameterSpec(payload,0,16));",
          "719:                         byte[] decrypted = cipher.doFinal(payload,16,payload.length-16);",
          "725:                 if(contentType==null || !contentType.startsWith(expectedContentType)) {",
          "730:                         throw new IOException(agentJnlpURL +\" doesn't look like a JNLP file; content type was \"+contentType);",
          "",
          "[Added Lines]",
          "773:                         cipher.init(",
          "774:                                 Cipher.DECRYPT_MODE,",
          "775:                                 new SecretKeySpec(",
          "776:                                         fromHexString(secret.substring(0, Math.min(secret.length(), 32))), \"AES\"),",
          "777:                                 new IvParameterSpec(payload, 0, 16));",
          "778:                         byte[] decrypted = cipher.doFinal(payload, 16, payload.length - 16);",
          "784:                 if (contentType == null || !contentType.startsWith(expectedContentType)) {",
          "790:                         throw new IOException(",
          "791:                                 agentJnlpURL + \" doesn't look like a JNLP file; content type was \" + contentType);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "737:                 NodeList argElements = dom.getElementsByTagName(\"argument\");",
          "738:                 List<String> jnlpArgs = new ArrayList<>();",
          "741:                 return jnlpArgs;",
          "742:             } catch (SSLHandshakeException e) {",
          "747:                     throw e;",
          "748:             } catch (IOException e) {",
          "750:                     throw new IOException(\"Failed to obtain \" + agentJnlpURL, e);",
          "751:                 if (Util.shouldBailOut(firstAttempt, noReconnectAfter)) {",
          "753:                 }",
          "755:                 e.printStackTrace(System.err);",
          "756:                 System.err.println(\"Waiting 10 seconds before retry\");",
          "",
          "[Removed Lines]",
          "739:                 for( int i=0; i<argElements.getLength(); i++ )",
          "740:                         jnlpArgs.add(argElements.item(i).getTextContent());",
          "743:                 if(e.getMessage().contains(\"PKIX path building failed\")) {",
          "745:                     throw new IOException(\"Failed to validate a server certificate. If you are using a self-signed certificate, you can use the -noCertificateCheck option to bypass this check.\", e);",
          "746:                 } else",
          "749:                 if (this.noReconnect)",
          "752:                     throw new IOException(\"Failed to obtain \" + agentJnlpURL + \" after \" + DurationFormatter.format(noReconnectAfter), e);",
          "754:                 System.err.println(\"Failed to obtain \"+ agentJnlpURL);",
          "",
          "[Added Lines]",
          "800:                 for (int i = 0; i < argElements.getLength(); i++) {",
          "801:                     jnlpArgs.add(argElements.item(i).getTextContent());",
          "802:                 }",
          "805:                 if (e.getMessage().contains(\"PKIX path building failed\")) {",
          "807:                     throw new IOException(",
          "808:                             \"Failed to validate a server certificate. If you are using a self-signed certificate, you can use the -noCertificateCheck option to bypass this check.\",",
          "809:                             e);",
          "810:                 } else {",
          "812:                 }",
          "814:                 if (this.noReconnect) {",
          "816:                 }",
          "818:                     throw new IOException(",
          "819:                             \"Failed to obtain \" + agentJnlpURL + \" after \" + DurationFormatter.format(noReconnectAfter),",
          "820:                             e);",
          "822:                 System.err.println(\"Failed to obtain \" + agentJnlpURL);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "770:     private static byte[] fromHexString(String data) {",
          "771:         byte[] r = new byte[data.length() / 2];",
          "773:             r[i / 2] = (byte) Integer.parseInt(data.substring(i, i + 2), 16);",
          "774:         return r;",
          "775:     }",
          "",
          "[Removed Lines]",
          "772:         for (int i = 0; i < data.length(); i += 2)",
          "",
          "[Added Lines]",
          "840:         for (int i = 0; i < data.length(); i += 2) {",
          "842:         }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "788:     @Deprecated",
          "790:     private void runAsTcpServer() throws IOException, InterruptedException {",
          "793:         Socket s;",
          "800:             try (FileWriter w = new FileWriter(tcpPortFile)) {",
          "",
          "[Removed Lines]",
          "789:     @SuppressFBWarnings(value = {\"UNENCRYPTED_SERVER_SOCKET\", \"DM_DEFAULT_ENCODING\", \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"}, justification = \"This is an old, insecure mechanism that should be removed. port number file should be in platform default encoding. Laucher instance is created only once.\")",
          "794:         try (ServerSocket ss = new ServerSocket(0,1)) {",
          "797:             ss.setSoTimeout(30*1000);",
          "",
          "[Added Lines]",
          "858:     @SuppressFBWarnings(",
          "859:             value = {\"UNENCRYPTED_SERVER_SOCKET\", \"DM_DEFAULT_ENCODING\", \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"},",
          "860:             justification =",
          "861:                     \"This is an old, insecure mechanism that should be removed. port number file should be in platform default encoding. Laucher instance is created only once.\")",
          "866:         try (ServerSocket ss = new ServerSocket(0, 1)) {",
          "869:             ss.setSoTimeout(30 * 1000);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "819:         s.setKeepAlive(true);",
          "821:         s.setTcpNoDelay(true);",
          "825:     }",
          "831:     @Deprecated",
          "832:     private void runAsTcpClient() throws IOException, InterruptedException {",
          "837:         Launcher.communicationProtocolName = \"TCP (remote: client)\";",
          "838:         runOnSocket(s);",
          "839:     }",
          "842:     private void runWithStdinStdout() throws IOException, InterruptedException {",
          "844:         ttyCheck();",
          "846:         if (isWindows()) {",
          "872:             new SecureRandom().nextBoolean();",
          "873:         }",
          "",
          "[Removed Lines]",
          "822:         main(new BufferedInputStream(SocketChannelStream.in(s)),",
          "823:              new BufferedOutputStream(SocketChannelStream.out(s)), mode,ping,",
          "824:              jarCache != null ? new FileSystemJarCache(jarCache,true) : null);",
          "830:     @SuppressFBWarnings(value = {\"UNENCRYPTED_SOCKET\", \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"}, justification = \"This implements an old, insecure connection mechanism. Laucher instance is created only once.\")",
          "835:         Socket s = new Socket(connectionTarget.getAddress(),connectionTarget.getPort());",
          "841:     @SuppressFBWarnings(value = {\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\", \"DMI_RANDOM_USED_ONLY_ONCE\"}, justification = \"Laucher instance is created only once.\")",
          "848:                 To prevent the dead lock between GetFileType from _ioinit in C runtime and blocking read that ChannelReaderThread",
          "849:                 would do on stdin, load the crypto DLL first.",
          "851:                 This is a band-aid solution to the problem. Still searching for more fundamental fix.",
          "853:                 02f1e750 7c90d99a ntdll!KiFastSystemCallRet",
          "854:                 02f1e754 7c810f63 ntdll!NtQueryVolumeInformationFile+0xc",
          "855:                 02f1e784 77c2c9f9 kernel32!GetFileType+0x7e",
          "856:                 02f1e7e8 77c1f01d msvcrt!_ioinit+0x19f",
          "857:                 02f1e88c 7c90118a msvcrt!__CRTDLL_INIT+0xac",
          "858:                 02f1e8ac 7c91c4fa ntdll!LdrpCallInitRoutine+0x14",
          "859:                 02f1e9b4 7c916371 ntdll!LdrpRunInitializeRoutines+0x344",
          "860:                 02f1ec60 7c9164d3 ntdll!LdrpLoadDll+0x3e5",
          "861:                 02f1ef08 7c801bbd ntdll!LdrLoadDll+0x230",
          "862:                 02f1ef70 7c801d72 kernel32!LoadLibraryExW+0x18e",
          "863:                 02f1ef84 7c801da8 kernel32!LoadLibraryExA+0x1f",
          "864:                 02f1efa0 77de8830 kernel32!LoadLibraryA+0x94",
          "865:                 02f1f05c 6d3eb1be ADVAPI32!CryptAcquireContextA+0x512",
          "866:                 WARNING: Stack unwind information not available. Following frames may be wrong.",
          "867:                 02f1f13c 6d99c844 java_6d3e0000!Java_sun_security_provider_NativeSeedGenerator_nativeGenerateSeed+0x6e",
          "869:                 see http://weblogs.java.net/blog/kohsuke/archive/2009/09/28/reading-stdin-may-cause-your-jvm-hang",
          "870:                 for more details",
          "",
          "[Added Lines]",
          "894:         main(",
          "895:                 new BufferedInputStream(SocketChannelStream.in(s)),",
          "896:                 new BufferedOutputStream(SocketChannelStream.out(s)),",
          "897:                 mode,",
          "898:                 ping,",
          "899:                 jarCache != null ? new FileSystemJarCache(jarCache, true) : null);",
          "905:     @SuppressFBWarnings(",
          "906:             value = {\"UNENCRYPTED_SOCKET\", \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"},",
          "907:             justification =",
          "908:                     \"This implements an old, insecure connection mechanism. Laucher instance is created only once.\")",
          "913:         Socket s = new Socket(connectionTarget.getAddress(), connectionTarget.getPort());",
          "919:     @SuppressFBWarnings(",
          "920:             value = {\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\", \"DMI_RANDOM_USED_ONLY_ONCE\"},",
          "921:             justification = \"Laucher instance is created only once.\")",
          "928:                To prevent the dead lock between GetFileType from _ioinit in C runtime and blocking read that ChannelReaderThread",
          "929:                would do on stdin, load the crypto DLL first.",
          "931:                This is a band-aid solution to the problem. Still searching for more fundamental fix.",
          "933:                02f1e750 7c90d99a ntdll!KiFastSystemCallRet",
          "934:                02f1e754 7c810f63 ntdll!NtQueryVolumeInformationFile+0xc",
          "935:                02f1e784 77c2c9f9 kernel32!GetFileType+0x7e",
          "936:                02f1e7e8 77c1f01d msvcrt!_ioinit+0x19f",
          "937:                02f1e88c 7c90118a msvcrt!__CRTDLL_INIT+0xac",
          "938:                02f1e8ac 7c91c4fa ntdll!LdrpCallInitRoutine+0x14",
          "939:                02f1e9b4 7c916371 ntdll!LdrpRunInitializeRoutines+0x344",
          "940:                02f1ec60 7c9164d3 ntdll!LdrpLoadDll+0x3e5",
          "941:                02f1ef08 7c801bbd ntdll!LdrLoadDll+0x230",
          "942:                02f1ef70 7c801d72 kernel32!LoadLibraryExW+0x18e",
          "943:                02f1ef84 7c801da8 kernel32!LoadLibraryExA+0x1f",
          "944:                02f1efa0 77de8830 kernel32!LoadLibraryA+0x94",
          "945:                02f1f05c 6d3eb1be ADVAPI32!CryptAcquireContextA+0x512",
          "946:                WARNING: Stack unwind information not available. Following frames may be wrong.",
          "947:                02f1f13c 6d99c844 java_6d3e0000!Java_sun_security_provider_NativeSeedGenerator_nativeGenerateSeed+0x6e",
          "949:                see http://weblogs.java.net/blog/kohsuke/archive/2009/09/28/reading-stdin-may-cause-your-jvm-hang",
          "950:                for more details",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "880:         Launcher.communicationProtocolName = \"Standard in/out\";",
          "884:     }",
          "",
          "[Removed Lines]",
          "883:         main(System.in, os, mode, ping, jarCache != null ? new FileSystemJarCache(jarCache,true) : null);",
          "",
          "[Added Lines]",
          "963:         main(System.in, os, mode, ping, jarCache != null ? new FileSystemJarCache(jarCache, true) : null);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "890:     private static void ttyCheck() {",
          "891:         final Console console = System.console();",
          "899:         }",
          "900:     }",
          "",
          "[Removed Lines]",
          "892:         if(console != null) {",
          "895:             System.out.println(",
          "896:                     \"WARNING: Are you running agent from an interactive console?\\n\" +",
          "897:                             \"If so, you are probably using it incorrectly.\\n\" +",
          "898:                             \"See https://wiki.jenkins.io/display/JENKINS/Launching+agent+from+console\");",
          "",
          "[Added Lines]",
          "972:         if (console != null) {",
          "975:             System.out.println(\"WARNING: Are you running agent from an interactive console?\\n\"",
          "976:                     + \"If so, you are probably using it incorrectly.\\n\"",
          "977:                     + \"See https://wiki.jenkins.io/display/JENKINS/Launching+agent+from+console\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "903:         main(is, os, Channel.Mode.BINARY);",
          "904:     }",
          "908:     }",
          "",
          "[Removed Lines]",
          "906:     public static void main(InputStream is, OutputStream os, Channel.Mode mode) throws IOException, InterruptedException {",
          "907:         main(is,os,mode,false);",
          "",
          "[Added Lines]",
          "985:     public static void main(InputStream is, OutputStream os, Channel.Mode mode)",
          "986:             throws IOException, InterruptedException {",
          "987:         main(is, os, mode, false);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "914:     @Deprecated",
          "916:         main(is, os, mode, performPing, null);",
          "917:     }",
          "",
          "[Removed Lines]",
          "915:     public static void main(InputStream is, OutputStream os, Channel.Mode mode, boolean performPing) throws IOException, InterruptedException {",
          "",
          "[Added Lines]",
          "995:     public static void main(InputStream is, OutputStream os, Channel.Mode mode, boolean performPing)",
          "996:             throws IOException, InterruptedException {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "925:         ExecutorService executor = Executors.newCachedThreadPool();",
          "935:         Channel channel = cb.build(is, os);",
          "936:         System.err.println(\"channel started\");",
          "944:         if (performPing && timeout > 0 && interval > 0) {",
          "945:             new PingThread(channel, timeout, interval) {",
          "946:                 @Deprecated",
          "",
          "[Removed Lines]",
          "924:     public static void main(InputStream is, OutputStream os, Channel.Mode mode, boolean performPing, @CheckForNull JarCache cache) throws IOException, InterruptedException {",
          "926:         ChannelBuilder cb = new ChannelBuilder(\"channel\", executor)",
          "927:                 .withMode(mode)",
          "928:                 .withJarCacheOrDefault(cache);",
          "932:         if (os instanceof StandardOutputStream)",
          "933:             cb.withProperty(StandardOutputStream.class,os);",
          "939:         long timeout = 1000 * Long.parseLong(",
          "940:                 System.getProperty(\"hudson.remoting.Launcher.pingTimeoutSec\", \"240\")),",
          "941:              interval = 1000 * Long.parseLong(",
          "942:                 System.getProperty(\"hudson.remoting.Launcher.pingIntervalSec\", /* was \"600\" but this duplicates ChannelPinger */ \"0\"));",
          "943:         Logger.getLogger(PingThread.class.getName()).log(Level.FINE, \"performPing={0} timeout={1} interval={2}\", new Object[] {performPing, timeout, interval});",
          "",
          "[Added Lines]",
          "1005:     public static void main(",
          "1006:             InputStream is, OutputStream os, Channel.Mode mode, boolean performPing, @CheckForNull JarCache cache)",
          "1007:             throws IOException, InterruptedException {",
          "1009:         ChannelBuilder cb =",
          "1010:                 new ChannelBuilder(\"channel\", executor).withMode(mode).withJarCacheOrDefault(cache);",
          "1014:         if (os instanceof StandardOutputStream) {",
          "1015:             cb.withProperty(StandardOutputStream.class, os);",
          "1016:         }",
          "1022:         long timeout = 1000 * Long.parseLong(System.getProperty(\"hudson.remoting.Launcher.pingTimeoutSec\", \"240\")),",
          "1023:                 interval =",
          "1024:                         1000",
          "1027:                                         \"0\"));",
          "1028:         Logger.getLogger(PingThread.class.getName())",
          "1029:                 .log(Level.FINE, \"performPing={0} timeout={1} interval={2}\", new Object[] {",
          "1030:                     performPing, timeout, interval",
          "1031:                 });",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "949:                     System.err.println(\"Ping failed. Terminating\");",
          "950:                     System.exit(-1);",
          "951:                 }",
          "952:                 @Override",
          "954:                 protected void onDead(Throwable cause) {",
          "955:                     System.err.println(\"Ping failed. Terminating\");",
          "956:                     cause.printStackTrace();",
          "",
          "[Removed Lines]",
          "953:                 @SuppressFBWarnings(value = \"INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE\", justification = \"Prints the agent-side message to the agent log before exiting.\")",
          "",
          "[Added Lines]",
          "1042:                 @SuppressFBWarnings(",
          "1043:                         value = \"INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE\",",
          "1044:                         justification = \"Prints the agent-side message to the agent log before exiting.\")",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "964:     }",
          "966:     public static boolean isWindows() {",
          "968:     }",
          "",
          "[Removed Lines]",
          "967:         return File.pathSeparatorChar==';';",
          "",
          "[Added Lines]",
          "1058:         return File.pathSeparatorChar == ';';",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "983:         Properties props = new Properties();",
          "984:         InputStream is = Launcher.class.getResourceAsStream(JENKINS_VERSION_PROP_FILE);",
          "985:         if (is == null) {",
          "987:                     JENKINS_VERSION_PROP_FILE);",
          "988:             return UNKNOWN_JENKINS_VERSION_STR;",
          "989:         }",
          "",
          "[Removed Lines]",
          "986:             LOGGER.log(Level.FINE, \"Cannot locate the {0} resource file. Hudson/Jenkins version is unknown\",",
          "",
          "[Added Lines]",
          "1077:             LOGGER.log(",
          "1078:                     Level.FINE,",
          "1079:                     \"Cannot locate the {0} resource file. Hudson/Jenkins version is unknown\",",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1010:     private Engine createEngine() throws IOException {",
          "1011:         LOGGER.log(Level.INFO, \"Setting up agent: {0}\", name);",
          "1012:         Engine engine = new Engine(",
          "1020:         engine.setWebSocket(webSocket);",
          "1021:         if (webSocketHeaders != null) {",
          "1022:             engine.setWebSocketHeaders(webSocketHeaders);",
          "",
          "[Removed Lines]",
          "1013:                 new CuiListener(),",
          "1014:                 urls,",
          "1015:                 secret,",
          "1016:                 name,",
          "1017:                 directConnection,",
          "1018:                 instanceIdentity,",
          "1019:                 new HashSet<>(protocols));",
          "",
          "[Added Lines]",
          "1106:                 new CuiListener(), urls, secret, name, directConnection, instanceIdentity, new HashSet<>(protocols));",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/LocalChannel.java||src/main/java/hudson/remoting/LocalChannel.java": [
          "File: src/main/java/hudson/remoting/LocalChannel.java -> src/main/java/hudson/remoting/LocalChannel.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     }",
          "44:     @Override",
          "46:         return callable.call();",
          "47:     }",
          "49:     @Override",
          "51:         final java.util.concurrent.Future<V> f = executor.submit(() -> {",
          "52:             try {",
          "53:                 return callable.call();",
          "",
          "[Removed Lines]",
          "45:     public <V, T extends Throwable> V call(Callable<V,T> callable) throws T {",
          "50:     public <V, T extends Throwable> Future<V> callAsync(@NonNull final Callable<V,T> callable) {",
          "",
          "[Added Lines]",
          "45:     public <V, T extends Throwable> V call(Callable<V, T> callable) throws T {",
          "50:     public <V, T extends Throwable> Future<V> callAsync(@NonNull final Callable<V, T> callable) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:             }",
          "82:             @Override",
          "84:                 return f.get(timeout, unit);",
          "85:             }",
          "86:         };",
          "",
          "[Removed Lines]",
          "83:             public V get(long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "83:             public V get(long timeout, @NonNull TimeUnit unit)",
          "84:                     throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/MimicException.java||src/main/java/hudson/remoting/MimicException.java": [
          "File: src/main/java/hudson/remoting/MimicException.java -> src/main/java/hudson/remoting/MimicException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: @Restricted(DoNotUse.class)",
          "20: class MimicException extends Exception {",
          "21:     private final String className;",
          "22:     MimicException(Throwable cause) {",
          "23:         super(cause.getMessage());",
          "24:         className = cause.getClass().getName();",
          "25:         setStackTrace(cause.getStackTrace());",
          "28:             initCause(new MimicException(cause.getCause()));",
          "29:     }",
          "31:     @Override",
          "",
          "[Removed Lines]",
          "27:         if (cause.getCause()!=null)",
          "",
          "[Added Lines]",
          "28:         if (cause.getCause() != null) {",
          "30:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:     @Nullable",
          "39:     public static Throwable make(@NonNull Channel ch, @Nullable Throwable cause) {",
          "44:             return new MimicException(cause);",
          "46:             return cause;",
          "47:     }",
          "49:     private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "40:         if (cause == null)  return null;",
          "43:         if (ch.remoteCapability.hasMimicException())",
          "45:         else",
          "",
          "[Added Lines]",
          "42:         if (cause == null) {",
          "43:             return null;",
          "44:         }",
          "47:         if (ch.remoteCapability.hasMimicException()) {",
          "49:         } else {",
          "51:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/MultiClassLoaderSerializer.java||src/main/java/hudson/remoting/MultiClassLoaderSerializer.java": [
          "File: src/main/java/hudson/remoting/MultiClassLoaderSerializer.java -> src/main/java/hudson/remoting/MultiClassLoaderSerializer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:         Output(Channel channel, OutputStream out) throws IOException {",
          "40:             super(out);",
          "",
          "[Removed Lines]",
          "37:         private final Map<ClassLoader,Integer> classLoaders = new HashMap<>();",
          "",
          "[Added Lines]",
          "37:         private final Map<ClassLoader, Integer> classLoaders = new HashMap<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:         protected void annotateClass(Class<?> c) throws IOException {",
          "46:             AnonymousClassWarnings.check(c);",
          "47:             ClassLoader cl = c.getClassLoader();",
          "49:                 writeInt(TAG_SYSTEMCLASSLOADER);",
          "50:                 return;",
          "51:             }",
          "53:             Integer idx = classLoaders.get(cl);",
          "56:                 if (cl instanceof RemoteClassLoader) {",
          "57:                     int oid = ((RemoteClassLoader) cl).getOid(channel);",
          "60:                         writeInt(TAG_LOCAL_CLASSLOADER);",
          "61:                         writeInt(oid);",
          "",
          "[Removed Lines]",
          "48:             if (cl==null) {// bootstrap classloader. no need to export.",
          "54:             if (idx==null) {",
          "55:                 classLoaders.put(cl,classLoaders.size());",
          "58:                     if (oid>=0) {",
          "",
          "[Added Lines]",
          "48:             if (cl == null) { // bootstrap classloader. no need to export.",
          "54:             if (idx == null) {",
          "55:                 classLoaders.put(cl, classLoaders.size());",
          "58:                     if (oid >= 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:                 }",
          "68:                 writeInt(TAG_EXPORTED_CLASSLOADER);",
          "71:                 writeInt(idx);",
          "72:             }",
          "73:         }",
          "",
          "[Removed Lines]",
          "69:                 writeInt(RemoteClassLoader.exportId(cl,channel));",
          "70:             } else {// reference to a classloader that's already written",
          "",
          "[Added Lines]",
          "70:                 writeInt(RemoteClassLoader.exportId(cl, channel));",
          "71:             } else { // reference to a classloader that's already written",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "95:             ClassLoader cl;",
          "96:             int code = readInt();",
          "97:             switch (code) {",
          "120:             }",
          "121:         }",
          "",
          "[Removed Lines]",
          "98:             case TAG_SYSTEMCLASSLOADER:",
          "99:                 return null;",
          "101:             case TAG_LOCAL_CLASSLOADER:",
          "102:                 Object proxyObject;",
          "103:                 int oid = readInt();",
          "104:                 try {",
          "105:                     proxyObject = channel.getExportedObject(oid);",
          "106:                 } catch (ExecutionException ex) {",
          "107:                     throw new IOException(\"Cannot locate RemoteClassLoader.ClassLoaderProxy(\" +",
          "108:                             oid + \") in the channel exported table\", ex);",
          "109:                 }",
          "110:                 cl = ((RemoteClassLoader.ClassLoaderProxy)proxyObject).cl;",
          "111:                 classLoaders.add(cl);",
          "112:                 return cl;",
          "114:             case TAG_EXPORTED_CLASSLOADER:",
          "115:                 cl = channel.importedClassLoaders.get(readInt());",
          "116:                 classLoaders.add(cl);",
          "117:                 return cl;",
          "118:             default:",
          "119:                 return classLoaders.get(code);",
          "",
          "[Added Lines]",
          "99:                 case TAG_SYSTEMCLASSLOADER:",
          "100:                     return null;",
          "102:                 case TAG_LOCAL_CLASSLOADER:",
          "103:                     Object proxyObject;",
          "104:                     int oid = readInt();",
          "105:                     try {",
          "106:                         proxyObject = channel.getExportedObject(oid);",
          "107:                     } catch (ExecutionException ex) {",
          "108:                         throw new IOException(",
          "109:                                 \"Cannot locate RemoteClassLoader.ClassLoaderProxy(\" + oid",
          "110:                                         + \") in the channel exported table\",",
          "111:                                 ex);",
          "112:                     }",
          "113:                     cl = ((RemoteClassLoader.ClassLoaderProxy) proxyObject).cl;",
          "114:                     classLoaders.add(cl);",
          "115:                     return cl;",
          "117:                 case TAG_EXPORTED_CLASSLOADER:",
          "118:                     cl = channel.importedClassLoaders.get(readInt());",
          "119:                     classLoaders.add(cl);",
          "120:                     return cl;",
          "121:                 default:",
          "122:                     return classLoaders.get(code);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "140:             ClassLoader cl = readClassLoader();",
          "142:             Class<?>[] classes = new Class[interfaces.length];",
          "145:                 classes[i] = Class.forName(interfaces[i], false, cl);",
          "148:                  dead lock prevention.",
          "",
          "[Removed Lines]",
          "143:             for (int i = 0; i < interfaces.length; i++)",
          "",
          "[Added Lines]",
          "146:             for (int i = 0; i < interfaces.length; i++) {",
          "149:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "162:                  So this is somewhat hack-ish, but in this change we look for a specific",
          "163:                  proxy type that we use and resolve them outside Proxy.getProxyClass.",
          "166:                 return Channel.jarLoaderProxy;",
          "168:             return Proxy.getProxyClass(cl, classes);",
          "169:         }",
          "171:         @Override",
          "172:         protected Object resolveObject(Object obj) throws IOException {",
          "175:                 return URLDeserializationHelper.wrapIfRequired((URL) obj);",
          "176:             }",
          "",
          "[Removed Lines]",
          "165:             if (classes.length==2 && classes[0]==JarLoader.class && classes[1]==IReadResolve.class)",
          "173:             if(obj instanceof URL){",
          "",
          "[Added Lines]",
          "169:             if (classes.length == 2 && classes[0] == JarLoader.class && classes[1] == IReadResolve.class) {",
          "171:             }",
          "178:             if (obj instanceof URL) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/NoProxyEvaluator.java||src/main/java/hudson/remoting/NoProxyEvaluator.java": [
          "File: src/main/java/hudson/remoting/NoProxyEvaluator.java -> src/main/java/hudson/remoting/NoProxyEvaluator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:     }",
          "94:     private boolean matchesIpAddress(InetAddress hostAddress) {",
          "97:     }",
          "99:     private void processSpecificationsIntoTypes(String noProxySpecification) {",
          "100:         noProxySpecification = noProxySpecification.trim();",
          "101:         String[] noProxySpecifications = splitComponents(noProxySpecification);",
          "103:             specification = stripLeadingStarDot(stripLeadingDot(specification.trim()));",
          "105:                 continue;",
          "106:             }",
          "107:             if (isIpAddress(specification)) {",
          "",
          "[Removed Lines]",
          "95:         return noProxyIpAddresses.stream().",
          "96:                 anyMatch(inetAddress -> inetAddress.equals(hostAddress));",
          "102:         for (String specification : noProxySpecifications){",
          "104:             if (specification.isEmpty() ) {",
          "",
          "[Added Lines]",
          "95:         return noProxyIpAddresses.stream().anyMatch(inetAddress -> inetAddress.equals(hostAddress));",
          "101:         for (String specification : noProxySpecifications) {",
          "103:             if (specification.isEmpty()) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "149:     }",
          "151:     private boolean matchesDomainHost(String host) {",
          "154:     }",
          "156:     private boolean isIpAddress(String host) {",
          "157:         return InetAddressValidator.getInstance().isValid(host);",
          "158:     }",
          "160: }",
          "",
          "[Removed Lines]",
          "152:         return noProxyDomainsHosts.stream().",
          "153:                anyMatch(host::endsWith);",
          "",
          "[Added Lines]",
          "151:         return noProxyDomainsHosts.stream().anyMatch(host::endsWith);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ObjectInputStreamEx.java||src/main/java/hudson/remoting/ObjectInputStreamEx.java": [
          "File: src/main/java/hudson/remoting/ObjectInputStreamEx.java -> src/main/java/hudson/remoting/ObjectInputStreamEx.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:     @Deprecated",
          "45:     public ObjectInputStreamEx(InputStream in, ClassLoader cl) throws IOException {",
          "47:     }",
          "49:     public ObjectInputStreamEx(InputStream in, ClassLoader cl, ClassFilter filter) throws IOException {",
          "",
          "[Removed Lines]",
          "46:         this(in,cl,ClassFilter.DEFAULT);",
          "",
          "[Added Lines]",
          "46:         this(in, cl, ClassFilter.DEFAULT);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:             if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {",
          "79:                 if (hasNonPublicInterface) {",
          "80:                     if (nonPublicLoader != cl.getClassLoader()) {",
          "83:                     }",
          "84:                 } else {",
          "85:                     nonPublicLoader = cl.getClassLoader();",
          "",
          "[Removed Lines]",
          "81:                         throw new IllegalAccessError(",
          "82:                             \"conflicting non-public interface class loaders\");",
          "",
          "[Added Lines]",
          "81:                         throw new IllegalAccessError(\"conflicting non-public interface class loaders\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:             classObjs[i] = cl;",
          "90:         }",
          "91:         try {",
          "95:         } catch (IllegalArgumentException e) {",
          "96:             throw new ClassNotFoundException(null, e);",
          "97:         }",
          "",
          "[Removed Lines]",
          "92:             return Proxy.getProxyClass(",
          "93:                 hasNonPublicInterface ? nonPublicLoader : latestLoader,",
          "94:                 classObjs);",
          "",
          "[Added Lines]",
          "91:             return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader : latestLoader, classObjs);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:     @Override",
          "101:     protected Object resolveObject(Object obj) throws IOException {",
          "104:             return URLDeserializationHelper.wrapIfRequired((URL) obj);",
          "105:         }",
          "",
          "[Removed Lines]",
          "102:         if(obj instanceof URL){",
          "",
          "[Added Lines]",
          "99:         if (obj instanceof URL) {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PingThread.java||src/main/java/hudson/remoting/PingThread.java": [
          "File: src/main/java/hudson/remoting/PingThread.java -> src/main/java/hudson/remoting/PingThread.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     private final long interval;",
          "61:     public PingThread(Channel channel, long timeout, long interval) {",
          "63:         this.channel = channel;",
          "64:         this.timeout = timeout;",
          "65:         this.interval = interval;",
          "",
          "[Removed Lines]",
          "62:         super(\"Ping thread for channel \"+channel);",
          "",
          "[Added Lines]",
          "62:         super(\"Ping thread for channel \" + channel);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:     @Override",
          "82:     public void run() {",
          "83:         try {",
          "85:                 long nextCheck = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(interval);",
          "87:                 ping();",
          "90:                 long diff;",
          "92:                     TimeUnit.NANOSECONDS.sleep(diff);",
          "93:                 }",
          "94:             }",
          "95:         } catch (ChannelClosedException e) {",
          "97:         } catch (IOException e) {",
          "98:             onDead(e);",
          "99:         } catch (InterruptedException e) {",
          "102:         }",
          "103:     }",
          "",
          "[Removed Lines]",
          "84:             while(true) {",
          "91:                 while((diff = nextCheck - System.nanoTime()) > 0) {",
          "96:             LOGGER.fine(getName()+\" is closed. Terminating\");",
          "101:             LOGGER.fine(getName()+\" is interrupted. Terminating\");",
          "",
          "[Added Lines]",
          "84:             while (true) {",
          "91:                 while ((diff = nextCheck - System.nanoTime()) > 0) {",
          "96:             LOGGER.fine(getName() + \" is closed. Terminating\");",
          "101:             LOGGER.fine(getName() + \" is interrupted. Terminating\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:         long remaining = end - System.nanoTime();",
          "113:         do {",
          "115:             try {",
          "117:                 LOGGER.log(Level.FINE, \"ping succeeded on {0}\", channel.getName());",
          "118:                 return;",
          "119:             } catch (ExecutionException e) {",
          "121:                     return; // connection has shut down orderly.",
          "122:                 onDead(e);",
          "123:                 return;",
          "124:             } catch (TimeoutException e) {",
          "",
          "[Removed Lines]",
          "114:             LOGGER.log(Level.FINE, \"waiting {0}s on {1}\", new Object[] {TimeUnit.NANOSECONDS.toSeconds(remaining), channel.getName()});",
          "116:                 f.get(Math.max(1,remaining),TimeUnit.NANOSECONDS);",
          "120:                 if (e.getCause() instanceof RequestAbortedException)",
          "",
          "[Added Lines]",
          "114:             LOGGER.log(Level.FINE, \"waiting {0}s on {1}\", new Object[] {",
          "115:                 TimeUnit.NANOSECONDS.toSeconds(remaining), channel.getName()",
          "116:             });",
          "118:                 f.get(Math.max(1, remaining), TimeUnit.NANOSECONDS);",
          "122:                 if (e.getCause() instanceof RequestAbortedException) {",
          "124:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:             }",
          "128:             remaining = end - System.nanoTime();",
          "132:     }",
          "",
          "[Removed Lines]",
          "129:         } while(remaining>0);",
          "131:         onDead(new TimeoutException(\"Ping started at \"+start+\" hasn't completed by \"+System.currentTimeMillis()));//.initCause(e)",
          "",
          "[Added Lines]",
          "132:         } while (remaining > 0);",
          "134:         onDead(new TimeoutException(",
          "135:                 \"Ping started at \" + start + \" hasn't completed by \" + System.currentTimeMillis())); // .initCause(e)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "149:     protected void onDead(Throwable diagnosis) {",
          "151:     }",
          "153:     private static final class Ping implements InternalCallable<Void, IOException> {",
          "",
          "[Removed Lines]",
          "150:         onDead();   // fall back",
          "",
          "[Added Lines]",
          "154:         onDead(); // fall back",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Pipe.java||src/main/java/hudson/remoting/Pipe.java": [
          "File: src/main/java/hudson/remoting/Pipe.java -> src/main/java/hudson/remoting/Pipe.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:     public static Pipe createRemoteToLocal() {",
          "144:     }",
          "149:     public static Pipe createLocalToRemote() {",
          "151:     }",
          "153:     private void writeObject(ObjectOutputStream oos) throws IOException {",
          "",
          "[Removed Lines]",
          "143:         return new Pipe(new FastPipedInputStream(),null);",
          "150:         return new Pipe(null,new ProxyOutputStream());",
          "",
          "[Added Lines]",
          "143:         return new Pipe(new FastPipedInputStream(), null);",
          "150:         return new Pipe(null, new ProxyOutputStream());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:             oos.writeBoolean(true); // marker",
          "166:             oos.writeInt(oid);",
          "",
          "[Removed Lines]",
          "160:         if(in!=null && out==null) {",
          "162:             FastPipedOutputStream pos = new FastPipedOutputStream((FastPipedInputStream)in);",
          "163:             int oid = ch.internalExport(Object.class, pos, false);  // this export is unexported in ProxyOutputStream.finalize()",
          "",
          "[Added Lines]",
          "160:         if (in != null && out == null) {",
          "162:             FastPipedOutputStream pos = new FastPipedOutputStream((FastPipedInputStream) in);",
          "163:             int oid = ch.internalExport(",
          "164:                     Object.class, pos, false); // this export is unexported in ProxyOutputStream.finalize()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "174:         }",
          "175:     }",
          "178:     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {",
          "179:         final Channel channel = getChannelForSerialization();",
          "183:             in = null;",
          "184:             out = new ProxyOutputStream(channel, ois.readInt());",
          "",
          "[Removed Lines]",
          "177:     @SuppressFBWarnings(value = \"DESERIALIZATION_GADGET\", justification = \"Serializable only over remoting. Class filtering is done through JEP-200.\")",
          "181:         if(ois.readBoolean()) {",
          "",
          "[Added Lines]",
          "178:     @SuppressFBWarnings(",
          "179:             value = \"DESERIALIZATION_GADGET\",",
          "180:             justification = \"Serializable only over remoting. Class filtering is done through JEP-200.\")",
          "184:         if (ois.readBoolean()) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "193:             FastPipedOutputStream pos = new FastPipedOutputStream();",
          "194:             FastPipedInputStream pis = new FastPipedInputStream(pos);",
          "198:             channel.send(new ConnectCommand(oidRos, oidPos));",
          "",
          "[Removed Lines]",
          "195:             final int oidPos = channel.internalExport(Object.class, pos, false); // this gets unexported when the remote ProxyOutputStream closes.",
          "",
          "[Added Lines]",
          "198:             final int oidPos = channel.internalExport(",
          "199:                     Object.class, pos, false); // this gets unexported when the remote ProxyOutputStream closes.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "221:             channel.pipeWriter.submit(0, () -> {",
          "222:                 try {",
          "223:                     final ProxyOutputStream ros = (ProxyOutputStream) channel.getExportedObject(oidRos);",
          "226:                     ros.connect(channel, oidPos);",
          "227:                 } catch (IOException e) {",
          "229:                 } catch (ExecutionException ex) {",
          "230:                     throw new IllegalStateException(ex);",
          "231:                 }",
          "",
          "[Removed Lines]",
          "224:                     channel.unexport(oidRos,createdAt);",
          "228:                     logger.log(Level.SEVERE,\"Failed to connect to pipe\",e);",
          "",
          "[Added Lines]",
          "228:                     channel.unexport(oidRos, createdAt);",
          "232:                     logger.log(Level.SEVERE, \"Failed to connect to pipe\", e);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PipeWindow.java||src/main/java/hudson/remoting/PipeWindow.java": [
          "File: src/main/java/hudson/remoting/PipeWindow.java -> src/main/java/hudson/remoting/PipeWindow.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:     void dead(@CheckForNull Throwable cause) {",
          "109:     }",
          "",
          "[Removed Lines]",
          "108:         this.dead = cause != null ? cause : new RemotingSystemException(\"Unknown cause\", null) ;",
          "",
          "[Added Lines]",
          "108:         this.dead = cause != null ? cause : new RemotingSystemException(\"Unknown cause\", null);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:         }",
          "133:         @Override",
          "137:         @Override",
          "138:         int peek() {",
          "",
          "[Removed Lines]",
          "134:         void increase(int delta) {",
          "135:         }",
          "",
          "[Added Lines]",
          "133:         void increase(int delta) {}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:         }",
          "148:         @Override",
          "151:     }",
          "153:     static final class Key {",
          "",
          "[Removed Lines]",
          "149:         void decrease(int delta) {",
          "150:         }",
          "",
          "[Added Lines]",
          "147:         void decrease(int delta) {}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "160:         @Override",
          "161:         public boolean equals(Object o) {",
          "164:             return oid == ((Key) o).oid;",
          "165:         }",
          "",
          "[Removed Lines]",
          "162:             if (o == null || getClass() != o.getClass()) return false;",
          "",
          "[Added Lines]",
          "159:             if (o == null || getClass() != o.getClass()) {",
          "160:                 return false;",
          "161:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "205:         @Override",
          "206:         public synchronized void increase(int delta) {",
          "209:             available += delta;",
          "210:             acked += delta;",
          "211:             notifyAll();",
          "",
          "[Removed Lines]",
          "207:             if (LOGGER.isLoggable(Level.FINER))",
          "208:                 LOGGER.finer(String.format(\"increase(%d,%d)->%d\",oid,delta,delta+available));",
          "",
          "[Added Lines]",
          "207:             if (LOGGER.isLoggable(Level.FINER)) {",
          "208:                 LOGGER.finer(String.format(\"increase(%d,%d)->%d\", oid, delta, delta + available));",
          "209:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223:         public int get(int min) throws InterruptedException, IOException {",
          "224:             checkDeath();",
          "225:             synchronized (this) {",
          "227:                     return available;",
          "230:                     wait(100);",
          "231:                     checkDeath();",
          "232:                 }",
          "",
          "[Removed Lines]",
          "226:                 if (available>=min)",
          "229:                 while (available<min) {",
          "",
          "[Added Lines]",
          "227:                 if (available >= min) {",
          "229:                 }",
          "231:                 while (available < min) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "238:         @Override",
          "239:         public synchronized void decrease(int delta) {",
          "242:             available -= delta;",
          "245:             HUDSON-7745 says the following assertion fails, which AFAICT is only possible if multiple",
          "246:             threads write to OutputStream concurrently, but that doesn't happen in most of the situations, so",
          "",
          "[Removed Lines]",
          "240:             if (LOGGER.isLoggable(Level.FINER))",
          "241:                 LOGGER.finer(String.format(\"decrease(%d,%d)->%d\",oid,delta,available-delta));",
          "243:             written+= delta;",
          "",
          "[Added Lines]",
          "242:             if (LOGGER.isLoggable(Level.FINER)) {",
          "243:                 LOGGER.finer(String.format(\"decrease(%d,%d)->%d\", oid, delta, available - delta));",
          "244:             }",
          "246:             written += delta;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PipeWriter.java||src/main/java/hudson/remoting/PipeWriter.java": [
          "File: src/main/java/hudson/remoting/PipeWriter.java -> src/main/java/hudson/remoting/PipeWriter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:         }",
          "107:         public synchronized Future<?> get() throws InterruptedException {",
          "109:                 wait();",
          "110:             return f;",
          "111:         }",
          "112:     }",
          "",
          "[Removed Lines]",
          "108:             while (f==null)",
          "114:     private final Map<Integer,FutureHolder> pendingIO = Collections.synchronizedMap(new HashMap<>());",
          "",
          "[Added Lines]",
          "108:             while (f == null) {",
          "110:             }",
          "115:     private final Map<Integer, FutureHolder> pendingIO = Collections.synchronizedMap(new HashMap<>());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140:     public Future<?> submit(final int id, final Runnable command) {",
          "142:             return base.submit(command);",
          "",
          "[Removed Lines]",
          "141:         if (id==0)",
          "",
          "[Added Lines]",
          "142:         if (id == 0) {",
          "144:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "147:         FutureHolder fh = new FutureHolder();",
          "149:         FutureHolder old = pendingIO.put(id, fh);",
          "152:         return fh.set(base.submit(new Runnable() {",
          "153:             @Override",
          "",
          "[Removed Lines]",
          "150:         assert old==null;",
          "",
          "[Added Lines]",
          "152:         assert old == null;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:                 final Thread t = Thread.currentThread();",
          "156:                 final String oldName = t.getName();",
          "157:                 try {",
          "159:                     command.run();",
          "160:                 } finally {",
          "161:                     FutureHolder old = pendingIO.remove(id);",
          "163:                     t.setName(oldName);",
          "164:                 }",
          "165:             }",
          "",
          "[Removed Lines]",
          "158:                     t.setName(oldName+\" : IO ID=\"+id+\" : seq#=\"+iota.getAndIncrement());",
          "162:                     assert old!=null;",
          "",
          "[Added Lines]",
          "160:                     t.setName(oldName + \" : IO ID=\" + id + \" : seq#=\" + iota.getAndIncrement());",
          "164:                     assert old != null;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "181:     public Future<?> get(int id) throws InterruptedException {",
          "182:         FutureHolder f = pendingIO.get(id);",
          "184:         return f.get();",
          "185:     }",
          "",
          "[Removed Lines]",
          "183:         if (f==null)    return SIGNALED;    // already completed",
          "",
          "[Added Lines]",
          "185:         if (f == null) {",
          "186:             return SIGNALED; // already completed",
          "187:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java": [
          "File: src/main/java/hudson/remoting/PreloadJarTask.java -> src/main/java/hudson/remoting/PreloadJarTask.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     private final URL[] jars;",
          "46:     @CheckForNull",
          "",
          "[Removed Lines]",
          "37: final class PreloadJarTask implements DelegatingCallable<Boolean,IOException> {",
          "",
          "[Added Lines]",
          "37: final class PreloadJarTask implements DelegatingCallable<Boolean, IOException> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     @Override",
          "60:     public Boolean call() throws IOException {",
          "61:         ClassLoader cl = Thread.currentThread().getContextClassLoader();",
          "63:             return false;",
          "65:         RemoteClassLoader rcl = (RemoteClassLoader) cl;",
          "66:         boolean r = false;",
          "68:             r |= rcl.prefetch(jar);",
          "69:         return r;",
          "70:     }",
          "",
          "[Removed Lines]",
          "62:         if (!(cl instanceof RemoteClassLoader))",
          "67:         for (URL jar : jars)",
          "",
          "[Added Lines]",
          "63:         if (!(cl instanceof RemoteClassLoader)) {",
          "65:         }",
          "69:         for (URL jar : jars) {",
          "71:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:     @Override",
          "77:     public void checkRoles(RoleChecker checker) throws SecurityException {",
          "79:     }",
          "81:     private static final long serialVersionUID = -773448303394727271L;",
          "",
          "[Removed Lines]",
          "78:         checker.check(this,Role.UNKNOWN);",
          "",
          "[Added Lines]",
          "81:         checker.check(this, Role.UNKNOWN);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ProxyException.java||src/main/java/hudson/remoting/ProxyException.java": [
          "File: src/main/java/hudson/remoting/ProxyException.java -> src/main/java/hudson/remoting/ProxyException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     @Override",
          "67:     public ProxyException getCause() {",
          "69:     }",
          "70: }",
          "",
          "[Removed Lines]",
          "68:         return (ProxyException)super.getCause();",
          "",
          "[Added Lines]",
          "68:         return (ProxyException) super.getCause();",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ProxyInputStream.java||src/main/java/hudson/remoting/ProxyInputStream.java": [
          "File: src/main/java/hudson/remoting/ProxyInputStream.java -> src/main/java/hudson/remoting/ProxyInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     public int read() throws IOException {",
          "65:         try {",
          "66:             Buffer buf = _read(1);",
          "72:                 return -1;",
          "73:         } catch (InterruptedException e) {",
          "75:             Thread.currentThread().interrupt(); // process interrupt later",
          "",
          "[Removed Lines]",
          "67:             if(buf.len==1)",
          "70:                 return ((int)buf.buf[0])&0xFF;",
          "71:             else",
          "",
          "[Added Lines]",
          "67:             if (buf.len == 1) {",
          "70:                 return ((int) buf.buf[0]) & 0xFF;",
          "71:             } else {",
          "73:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:     public int read(@NonNull byte[] b, int off, int len) throws IOException {",
          "87:         try {",
          "88:             Buffer buf = _read(len);",
          "91:             return buf.len;",
          "92:         } catch (InterruptedException e) {",
          "",
          "[Removed Lines]",
          "89:             if(buf.len==-1) return -1;",
          "90:             System.arraycopy(buf.buf,0,b,off,buf.len);",
          "",
          "[Added Lines]",
          "90:             if (buf.len == -1) {",
          "91:                 return -1;",
          "92:             }",
          "93:             System.arraycopy(buf.buf, 0, b, off, buf.len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100:     @Override",
          "101:     public synchronized void close() throws IOException {",
          "103:             channel.send(new EOF(oid));",
          "104:             channel = null;",
          "105:             oid = -1;",
          "",
          "[Removed Lines]",
          "102:         if(channel!=null) {",
          "",
          "[Added Lines]",
          "105:         if (channel != null) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115:         }",
          "117:         public void read(InputStream in) throws IOException {",
          "119:         }",
          "121:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "118:             len = in.read(buf,0,buf.length);",
          "",
          "[Added Lines]",
          "121:             len = in.read(buf, 0, buf.length);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:         private final int oid;",
          "129:         private final int len;",
          "",
          "[Removed Lines]",
          "127:     private static final class Chunk extends Request<Buffer,IOException> {",
          "",
          "[Added Lines]",
          "130:     private static final class Chunk extends Request<Buffer, IOException> {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "169:         @Override",
          "170:         protected void execute(Channel channel) {",
          "171:             final InputStream in = (InputStream) channel.getExportedObjectOrNull(oid);",
          "173:             if (in == null) { // Input stream has not been closed yet",
          "174:                 LOGGER.log(Level.FINE, \"InputStream with oid=%s has been already unexported\", oid);",
          "175:                 return;",
          "176:             }",
          "179:             IOUtils.closeQuietly(in);",
          "180:         }",
          "182:         @Override",
          "183:         public String toString() {",
          "185:         }",
          "187:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "178:             channel.unexport(oid,createdAt,false);",
          "184:             return \"ProxyInputStream.EOF(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "180:             channel.unexport(oid, createdAt, false);",
          "186:             return \"ProxyInputStream.EOF(\" + oid + \")\";",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ProxyOutputStream.java||src/main/java/hudson/remoting/ProxyOutputStream.java": [
          "File: src/main/java/hudson/remoting/ProxyOutputStream.java -> src/main/java/hudson/remoting/ProxyOutputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "61:     public ProxyOutputStream() {",
          "62:     }",
          "",
          "[Added Lines]",
          "61:     public ProxyOutputStream() {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:     public ProxyOutputStream(@NonNull Channel channel, int oid) throws IOException {",
          "72:     }",
          "77:     synchronized void connect(@NonNull Channel channel, int oid) throws IOException {",
          "79:             throw new IllegalStateException(\"Cannot connect twice\");",
          "81:             throw new IllegalArgumentException(\"oid=0\");",
          "82:         this.channel = channel;",
          "83:         this.oid = oid;",
          "88:             doClose(error);",
          "90:         notifyAll(); // release blocking writes",
          "91:     }",
          "93:     @Override",
          "94:     public void write(int b) throws IOException {",
          "96:     }",
          "98:     @Override",
          "99:     public synchronized void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "100:         try {",
          "104:                     throw new IOException(\"stream is already closed\");",
          "105:                 wait();",
          "106:             }",
          "108:             final int max = window.max();",
          "146:                 window.decrease(sendable);",
          "149:             }",
          "150:         } catch (InterruptedException e) {",
          "152:         }",
          "153:     }",
          "",
          "[Removed Lines]",
          "71:         connect(channel,oid);",
          "78:         if(this.channel!=null)",
          "80:         if(oid==0)",
          "85:         window =  channel.getPipeWindow(oid);",
          "87:         if(closed)  // already marked closed?",
          "95:         write(new byte[]{(byte)b},0,1);",
          "102:             while (channel==null) {",
          "103:                 if(closed)",
          "110:             while (len>0) {",
          "112:                     To avoid fragmentation of the pipe window, at least demand that 10% of the pipe window",
          "113:                     be reclaimed.",
          "115:                     Imagine a large latency network where we are always low on the window size,",
          "116:                     and we are continuously sending data of irregular size. In such a circumstance,",
          "117:                     a fragmentation will happen. We start sending out a small Chunk at a time (say 4 bytes),",
          "118:                     and when its Ack comes back, it gets immediately consumed by another out-bound Chunk of 4 bytes.",
          "120:                     Clearly, it's better to wait a bit until we have a sizable pipe window, then send out",
          "121:                     a bigger Chunk, since Chunks have static overheads. This code does just that.",
          "123:                     (Except when what we are trying to send as a whole is smaller than the current available",
          "124:                     window size, in which case there's no point in waiting.)",
          "126:                 int sendable = Math.min(window.get(Math.min(max/10,len)),len);",
          "128:                     Imagine if we have a lot of data to send and the pipe window is fully available.",
          "129:                     If we create one Chunk that fully uses the window size, we need to wait for the",
          "130:                     whole Chunk to get to the other side, then the Ack to come back to this side,",
          "131:                     before we can send a next Chunk. While the Ack is traveling back to us, we have",
          "132:                     to sit idle. This fails to utilize available bandwidth.",
          "134:                     A better strategy is to create a smaller Chunk, say half the window size.",
          "135:                     This allows the other side to send back the ack while we are sending the second",
          "136:                     Chunk. In a network with a non-trivial latency, this allows Chunk and Ack",
          "137:                     to overlap, and that improves the utilization.",
          "139:                     It's not clear what the best size of the chunk to send (there's a certain",
          "140:                     overhead in our Command structure, around 100-200 bytes), so I'm just starting",
          "141:                     with 2. Further analysis would be needed to determine the best value.",
          "143:                 sendable = Math.min(sendable, max /2);",
          "145:                 channel.send(new Chunk(channel.newIoId(),oid,b,off,sendable));",
          "147:                 off+=sendable;",
          "148:                 len-=sendable;",
          "151:             throw (IOException)new InterruptedIOException().initCause(e);",
          "",
          "[Added Lines]",
          "70:         connect(channel, oid);",
          "77:         if (this.channel != null) {",
          "79:         }",
          "80:         if (oid == 0) {",
          "82:         }",
          "86:         window = channel.getPipeWindow(oid);",
          "88:         if (closed) { // already marked closed?",
          "90:         }",
          "97:         write(new byte[] {(byte) b}, 0, 1);",
          "104:             while (channel == null) {",
          "105:                 if (closed) {",
          "107:                 }",
          "113:             while (len > 0) {",
          "115:                    To avoid fragmentation of the pipe window, at least demand that 10% of the pipe window",
          "116:                    be reclaimed.",
          "118:                    Imagine a large latency network where we are always low on the window size,",
          "119:                    and we are continuously sending data of irregular size. In such a circumstance,",
          "120:                    a fragmentation will happen. We start sending out a small Chunk at a time (say 4 bytes),",
          "121:                    and when its Ack comes back, it gets immediately consumed by another out-bound Chunk of 4 bytes.",
          "123:                    Clearly, it's better to wait a bit until we have a sizable pipe window, then send out",
          "124:                    a bigger Chunk, since Chunks have static overheads. This code does just that.",
          "126:                    (Except when what we are trying to send as a whole is smaller than the current available",
          "127:                    window size, in which case there's no point in waiting.)",
          "129:                 int sendable = Math.min(window.get(Math.min(max / 10, len)), len);",
          "131:                    Imagine if we have a lot of data to send and the pipe window is fully available.",
          "132:                    If we create one Chunk that fully uses the window size, we need to wait for the",
          "133:                    whole Chunk to get to the other side, then the Ack to come back to this side,",
          "134:                    before we can send a next Chunk. While the Ack is traveling back to us, we have",
          "135:                    to sit idle. This fails to utilize available bandwidth.",
          "137:                    A better strategy is to create a smaller Chunk, say half the window size.",
          "138:                    This allows the other side to send back the ack while we are sending the second",
          "139:                    Chunk. In a network with a non-trivial latency, this allows Chunk and Ack",
          "140:                    to overlap, and that improves the utilization.",
          "142:                    It's not clear what the best size of the chunk to send (there's a certain",
          "143:                    overhead in our Command structure, around 100-200 bytes), so I'm just starting",
          "144:                    with 2. Further analysis would be needed to determine the best value.",
          "146:                 sendable = Math.min(sendable, max / 2);",
          "148:                 channel.send(new Chunk(channel.newIoId(), oid, b, off, sendable));",
          "150:                 off += sendable;",
          "151:                 len -= sendable;",
          "154:             throw (IOException) new InterruptedIOException().initCause(e);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "170:             closed = true;",
          "171:             error = e;",
          "172:         }",
          "174:             doClose(e);",
          "176:     }",
          "178:     private void doClose(Throwable error) throws IOException {",
          "180:         channel = null;",
          "181:         oid = -1;",
          "182:     }",
          "",
          "[Removed Lines]",
          "173:         if(channel!=null)",
          "175:         notifyAll();    // unblock any pending write",
          "179:         channel.send(new EOF(channel.newIoId(),oid,error));",
          "",
          "[Added Lines]",
          "176:         if (channel != null) {",
          "178:         }",
          "179:         notifyAll(); // unblock any pending write",
          "183:         channel.send(new EOF(channel.newIoId(), oid, error));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "186:         super.finalize();",
          "191:             oid = -1;",
          "192:         }",
          "193:     }",
          "",
          "[Removed Lines]",
          "189:         if(channel != null && oid != -1) {",
          "190:             channel.send(new Unexport(channel.newIoId(),oid));",
          "",
          "[Added Lines]",
          "193:         if (channel != null && oid != -1) {",
          "194:             channel.send(new Unexport(channel.newIoId(), oid));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "214:     @Deprecated",
          "215:     private static void markForIoSync(Channel channel, int requestId, java.util.concurrent.Future<?> ioOp) {",
          "221:             call.lastIo = ioOp;",
          "222:     }",
          "",
          "[Removed Lines]",
          "216:         Request<?,?> call = channel.pendingCalls.get(requestId);",
          "220:         if (call!=null)",
          "",
          "[Added Lines]",
          "220:         Request<?, ?> call = channel.pendingCalls.get(requestId);",
          "224:         if (call != null) {",
          "226:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "237:             super(false);",
          "238:             this.ioId = ioId;",
          "239:             this.oid = oid;",
          "241:                 this.buf = buf;",
          "243:                 this.buf = new byte[len];",
          "245:             }",
          "246:         }",
          "",
          "[Removed Lines]",
          "240:             if (start==0 && len==buf.length)",
          "242:             else {",
          "244:                 System.arraycopy(buf,start,this.buf,0,len);",
          "",
          "[Added Lines]",
          "245:             if (start == 0 && len == buf.length) {",
          "247:             } else {",
          "249:                 System.arraycopy(buf, start, this.buf, 0, len);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "251:             try {",
          "252:                 os = (OutputStream) channel.getExportedObject(oid);",
          "253:             } catch (ExecutionException ex) {",
          "256:             }",
          "258:                 try {",
          "259:                     os.write(buf);",
          "260:                 } catch (IOException e) {",
          "261:                     try {",
          "263:                     } catch (ChannelClosedException x) {",
          "266:                     } catch (IOException x) {",
          "270:                     }",
          "271:                 } finally {",
          "272:                     if (channel.remoteCapability.supportsPipeThrottling()) {",
          "273:                         try {",
          "275:                         } catch (ChannelClosedException x) {",
          "278:                         } catch (IOException e) {",
          "281:                         }",
          "282:                     }",
          "283:                 }",
          "",
          "[Removed Lines]",
          "254:                 throw new ExecutionException(String.format(\"Channel %s: Output stream object has been released before sending last chunk for oid=%s\",",
          "255:                                 channel.getName(), oid), ex);",
          "257:             markForIoSync(channel,requestId,channel.pipeWriter.submit(ioId, () -> {",
          "262:                         channel.send(new NotifyDeadWriter(channel,e,oid));",
          "268:                         LOGGER.log(Level.WARNING, \"Failed to notify the sender that the write end is dead\",x);",
          "269:                         LOGGER.log(Level.WARNING, \"... the failed write was:\",e);",
          "274:                             channel.send(new Ack(oid,buf.length));",
          "280:                             LOGGER.log(Level.WARNING, \"Failed to ack the stream\",e);",
          "",
          "[Added Lines]",
          "259:                 throw new ExecutionException(",
          "260:                         String.format(",
          "261:                                 \"Channel %s: Output stream object has been released before sending last chunk for oid=%s\",",
          "262:                                 channel.getName(), oid),",
          "263:                         ex);",
          "265:             markForIoSync(channel, requestId, channel.pipeWriter.submit(ioId, () -> {",
          "270:                         channel.send(new NotifyDeadWriter(channel, e, oid));",
          "276:                         LOGGER.log(Level.WARNING, \"Failed to notify the sender that the write end is dead\", x);",
          "277:                         LOGGER.log(Level.WARNING, \"... the failed write was:\", e);",
          "282:                             channel.send(new Ack(oid, buf.length));",
          "288:                             LOGGER.log(Level.WARNING, \"Failed to ack the stream\", e);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "287:         @Override",
          "288:         public String toString() {",
          "290:         }",
          "292:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "289:             return \"Pipe.Chunk(\"+oid+\",\"+buf.length+\")\";",
          "",
          "[Added Lines]",
          "297:             return \"Pipe.Chunk(\" + oid + \",\" + buf.length + \")\";",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "309:         @Override",
          "310:         protected void execute(Channel channel) throws ExecutionException {",
          "311:             final OutputStream os = (OutputStream) channel.getExportedObject(oid);",
          "313:                 try {",
          "314:                     os.flush();",
          "315:                 } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "312:             markForIoSync(channel,requestId,channel.pipeWriter.submit(ioId, () -> {",
          "",
          "[Added Lines]",
          "320:             markForIoSync(channel, requestId, channel.pipeWriter.submit(ioId, () -> {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "321:         @Override",
          "322:         public String toString() {",
          "324:         }",
          "326:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "323:             return \"Pipe.Flush(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "331:             return \"Pipe.Flush(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "344:         @Override",
          "345:         protected void execute(final Channel channel) {",
          "347:         }",
          "349:         @Override",
          "350:         public String toString() {",
          "352:         }",
          "354:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "346:             channel.pipeWriter.submit(ioId, () -> channel.unexport(oid,createdAt,false));",
          "351:             return \"ProxyOutputStream.Unexport(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "354:             channel.pipeWriter.submit(ioId, () -> channel.unexport(oid, createdAt, false));",
          "359:             return \"ProxyOutputStream.Unexport(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "378:                 LOGGER.log(Level.FINE, \"InputStream with oid=%s has been already unexported\", oid);",
          "379:                 return;",
          "380:             }",
          "383:                 try {",
          "385:                         ((ErrorPropagatingOutputStream) os).error(error);",
          "386:                     os.close();",
          "387:                 } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "381:             markForIoSync(channel,requestId,channel.pipeWriter.submit(ioId, () -> {",
          "382:                 channel.unexport(oid,createdAt,false);",
          "384:                     if (error!=null && os instanceof ErrorPropagatingOutputStream)",
          "",
          "[Added Lines]",
          "388:             markForIoSync(channel, requestId, channel.pipeWriter.submit(ioId, () -> {",
          "389:                 channel.unexport(oid, createdAt, false);",
          "391:                     if (error != null && os instanceof ErrorPropagatingOutputStream) {",
          "393:                     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "393:         @Override",
          "394:         public String toString() {",
          "396:         }",
          "398:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "395:             return \"ProxyOutputStream.EOF(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "403:             return \"ProxyOutputStream.EOF(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "426:         @Override",
          "427:         public String toString() {",
          "429:         }",
          "431:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "428:             return \"ProxyOutputStream.Ack(\"+oid+','+size+\")\";",
          "",
          "[Added Lines]",
          "436:             return \"ProxyOutputStream.Ack(\" + oid + ',' + size + \")\";",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "437:     private static final class NotifyDeadWriter extends Command {",
          "438:         private final int oid;",
          "442:             this.oid = oid;",
          "443:         }",
          "",
          "[Removed Lines]",
          "440:         private NotifyDeadWriter(Channel channel,Throwable cause, int oid) {",
          "441:             super(channel,cause);",
          "",
          "[Added Lines]",
          "448:         private NotifyDeadWriter(Channel channel, Throwable cause, int oid) {",
          "449:             super(channel, cause);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "451:         @Override",
          "452:         public String toString() {",
          "454:         }",
          "456:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "453:             return \"ProxyOutputStream.Dead(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "461:             return \"ProxyOutputStream.Dead(\" + oid + \")\";",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ProxyWriter.java||src/main/java/hudson/remoting/ProxyWriter.java": [
          "File: src/main/java/hudson/remoting/ProxyWriter.java -> src/main/java/hudson/remoting/ProxyWriter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:     public ProxyWriter(@NonNull Channel channel, int oid) throws IOException {",
          "76:     }",
          "81:     synchronized void connect(@NonNull Channel channel, int oid) throws IOException {",
          "83:             throw new IllegalStateException(\"Cannot connect twice\");",
          "85:             throw new IllegalArgumentException(\"oid=0\");",
          "86:         this.channel = channel;",
          "87:         this.oid = oid;",
          "93:             char[] b = tmp.toCharArray();",
          "94:             tmp = null;",
          "95:             _write(b, 0, b.length);",
          "96:         }",
          "98:             close();",
          "99:         }",
          "100:     }",
          "102:     @Override",
          "103:     public void write(int c) throws IOException {",
          "105:     }",
          "107:     @Override",
          "",
          "[Removed Lines]",
          "75:         connect(channel,oid);",
          "82:         if(this.channel!=null)",
          "84:         if(oid==0)",
          "89:         window =  channel.getPipeWindow(oid);",
          "92:         if(tmp!=null) {",
          "97:         if(closeCause != null) { // already closed asynchronously?",
          "104:         write(new char[]{(char)c},0,1);",
          "",
          "[Added Lines]",
          "76:         connect(channel, oid);",
          "83:         if (this.channel != null) {",
          "85:         }",
          "86:         if (oid == 0) {",
          "88:         }",
          "92:         window = channel.getPipeWindow(oid);",
          "95:         if (tmp != null) {",
          "100:         if (closeCause != null) { // already closed asynchronously?",
          "107:         write(new char[] {(char) c}, 0, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:     private synchronized void _write(char[] cbuf, int off, int len) throws IOException {",
          "121:                 tmp = new CharArrayWriter();",
          "122:             tmp.write(cbuf);",
          "123:         } else {",
          "124:             final int max = window.max();",
          "127:                 int sendable;",
          "128:                 try {",
          "162:                 } catch (InterruptedException e) {",
          "164:                 }",
          "167:                 window.decrease(sendable);",
          "170:             }",
          "171:         }",
          "172:     }",
          "174:     @Override",
          "175:     public synchronized void flush() throws IOException {",
          "178:     }",
          "180:     @Override",
          "",
          "[Removed Lines]",
          "119:         if(channel==null) {",
          "120:             if(tmp==null)",
          "126:             while (len>0) {",
          "130:                         To avoid fragmentation of the pipe window, at least demand that 10% of the pipe window",
          "131:                         be reclaimed.",
          "133:                         Imagine a large latency network where we are always low on the window size,",
          "134:                         and we are continuously sending data of irregular size. In such a circumstance,",
          "135:                         a fragmentation will happen. We start sending out a small Chunk at a time (say 4 bytes),",
          "136:                         and when its Ack comes back, it gets immediately consumed by another out-bound Chunk of 4 bytes.",
          "138:                         Clearly, it's better to wait a bit until we have a sizable pipe window, then send out",
          "139:                         a bigger Chunk, since Chunks have static overheads. This code does just that.",
          "141:                         (Except when what we are trying to send as a whole is smaller than the current available",
          "142:                         window size, in which case there's no point in waiting.)",
          "144:                     sendable = Math.min(window.get(Math.min(max/10,len)),len);",
          "146:                         Imagine if we have a lot of data to send and the pipe window is fully available.",
          "147:                         If we create one Chunk that fully uses the window size, we need to wait for the",
          "148:                         whole Chunk to get to the other side, then the Ack to come back to this side,",
          "149:                         before we can send a next Chunk. While the Ack is traveling back to us, we have",
          "150:                         to sit idle. This fails to utilize available bandwidth.",
          "152:                         A better strategy is to create a smaller Chunk, say half the window size.",
          "153:                         This allows the other side to send back the ack while we are sending the second",
          "154:                         Chunk. In a network with a non-trivial latency, this allows Chunk and Ack",
          "155:                         to overlap, and that improves the utilization.",
          "157:                         It's not clear what the best size of the chunk to send (there's a certain",
          "158:                         overhead in our Command structure, around 100-200 bytes), so I'm just starting",
          "159:                         with 2. Further analysis would be needed to determine the best value.",
          "161:                     sendable = Math.min(sendable, max /2);",
          "163:                     throw (IOException)new InterruptedIOException().initCause(e);",
          "166:                 channel.send(new Chunk(channel.newIoId(),oid,cbuf,off,sendable));",
          "168:                 off+=sendable;",
          "169:                 len-=sendable;",
          "176:         if(channel!=null && channel.remoteCapability.supportsProxyWriter2_35())",
          "177:             channel.send(new Flush(channel.newIoId(),oid));",
          "",
          "[Added Lines]",
          "122:         if (channel == null) {",
          "123:             if (tmp == null) {",
          "125:             }",
          "130:             while (len > 0) {",
          "134:                        To avoid fragmentation of the pipe window, at least demand that 10% of the pipe window",
          "135:                        be reclaimed.",
          "137:                        Imagine a large latency network where we are always low on the window size,",
          "138:                        and we are continuously sending data of irregular size. In such a circumstance,",
          "139:                        a fragmentation will happen. We start sending out a small Chunk at a time (say 4 bytes),",
          "140:                        and when its Ack comes back, it gets immediately consumed by another out-bound Chunk of 4 bytes.",
          "142:                        Clearly, it's better to wait a bit until we have a sizable pipe window, then send out",
          "143:                        a bigger Chunk, since Chunks have static overheads. This code does just that.",
          "145:                        (Except when what we are trying to send as a whole is smaller than the current available",
          "146:                        window size, in which case there's no point in waiting.)",
          "148:                     sendable = Math.min(window.get(Math.min(max / 10, len)), len);",
          "150:                        Imagine if we have a lot of data to send and the pipe window is fully available.",
          "151:                        If we create one Chunk that fully uses the window size, we need to wait for the",
          "152:                        whole Chunk to get to the other side, then the Ack to come back to this side,",
          "153:                        before we can send a next Chunk. While the Ack is traveling back to us, we have",
          "154:                        to sit idle. This fails to utilize available bandwidth.",
          "156:                        A better strategy is to create a smaller Chunk, say half the window size.",
          "157:                        This allows the other side to send back the ack while we are sending the second",
          "158:                        Chunk. In a network with a non-trivial latency, this allows Chunk and Ack",
          "159:                        to overlap, and that improves the utilization.",
          "161:                        It's not clear what the best size of the chunk to send (there's a certain",
          "162:                        overhead in our Command structure, around 100-200 bytes), so I'm just starting",
          "163:                        with 2. Further analysis would be needed to determine the best value.",
          "165:                     sendable = Math.min(sendable, max / 2);",
          "167:                     throw (IOException) new InterruptedIOException().initCause(e);",
          "170:                 channel.send(new Chunk(channel.newIoId(), oid, cbuf, off, sendable));",
          "172:                 off += sendable;",
          "173:                 len -= sendable;",
          "180:         if (channel != null && channel.remoteCapability.supportsProxyWriter2_35()) {",
          "181:             channel.send(new Flush(channel.newIoId(), oid));",
          "182:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "224:         }",
          "226:         synchronized (this) {",
          "228:             if (channel != null) {",
          "232:                 channel = null;",
          "233:                 channelReleased = true;",
          "234:                 oid = -1;",
          "",
          "[Removed Lines]",
          "231:                 channel.send(new EOF(channel.newIoId(), oid/*,error*/));",
          "",
          "[Added Lines]",
          "238:                 channel.send(new EOF(channel.newIoId(), oid /*,error*/));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237:     }",
          "239:     @Override",
          "241:     @SuppressFBWarnings(value = \"FI_FINALIZER_NULLS_FIELDS\", justification = \"As designed\")",
          "242:     protected synchronized void finalize() throws Throwable {",
          "243:         super.finalize();",
          "251:             channel = null;",
          "252:             oid = -1;",
          "253:         }",
          "",
          "[Removed Lines]",
          "246:         if(channel!=null) {",
          "247:             if (channel.remoteCapability.supportsProxyWriter2_35())",
          "248:                 channel.send(new Unexport(channel.newIoId(),oid));",
          "249:             else",
          "250:                 channel.send(new EOF(channel.newIoId(),oid));",
          "",
          "[Added Lines]",
          "253:         if (channel != null) {",
          "254:             if (channel.remoteCapability.supportsProxyWriter2_35()) {",
          "255:                 channel.send(new Unexport(channel.newIoId(), oid));",
          "256:             } else {",
          "257:                 channel.send(new EOF(channel.newIoId(), oid));",
          "258:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "268:             super(false);",
          "269:             this.ioId = ioId;",
          "270:             this.oid = oid;",
          "272:                 this.buf = buf;",
          "274:                 this.buf = new char[len];",
          "276:             }",
          "277:         }",
          "",
          "[Removed Lines]",
          "271:             if (start==0 && len==buf.length)",
          "273:             else {",
          "275:                 System.arraycopy(buf,start,this.buf,0,len);",
          "",
          "[Added Lines]",
          "279:             if (start == 0 && len == buf.length) {",
          "281:             } else {",
          "283:                 System.arraycopy(buf, start, this.buf, 0, len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "284:                     os.write(buf);",
          "285:                 } catch (IOException e) {",
          "286:                     try {",
          "288:                             channel.send(new NotifyDeadWriter(channel, e, oid));",
          "289:                     } catch (ChannelClosedException x) {",
          "",
          "[Removed Lines]",
          "287:                         if (channel.remoteCapability.supportsProxyWriter2_35())",
          "",
          "[Added Lines]",
          "295:                         if (channel.remoteCapability.supportsProxyWriter2_35()) {",
          "297:                         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "313:         @Override",
          "314:         public String toString() {",
          "316:         }",
          "318:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "315:             return \"ProxyWriter.Chunk(\"+oid+\",\"+buf.length+\")\";",
          "",
          "[Added Lines]",
          "324:             return \"ProxyWriter.Chunk(\" + oid + \",\" + buf.length + \")\";",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "347:         @Override",
          "348:         public String toString() {",
          "350:         }",
          "352:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "349:             return \"ProxyWriter.Flush(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "358:             return \"ProxyWriter.Flush(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "371:         @Override",
          "372:         protected void execute(final Channel channel) {",
          "374:         }",
          "376:         @Override",
          "377:         public String toString() {",
          "379:         }",
          "381:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "373:             channel.pipeWriter.submit(ioId, () -> channel.unexport(oid,createdAt,false));",
          "378:             return \"ProxyWriter.Unexport(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "382:             channel.pipeWriter.submit(ioId, () -> channel.unexport(oid, createdAt, false));",
          "387:             return \"ProxyWriter.Unexport(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "388:         private final int oid;",
          "389:         private final int ioId;",
          "392:             this.ioId = ioId;",
          "393:             this.oid = oid;",
          "394:         }",
          "",
          "[Removed Lines]",
          "391:         public EOF(int ioId,int oid) {",
          "",
          "[Added Lines]",
          "400:         public EOF(int ioId, int oid) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "402:                 return;",
          "403:             }",
          "404:             channel.pipeWriter.submit(ioId, () -> {",
          "406:                 try {",
          "407:                     os.close();",
          "408:                 } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "405:                 channel.unexport(oid,createdAt,false);",
          "",
          "[Added Lines]",
          "414:                 channel.unexport(oid, createdAt, false);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "414:         @Override",
          "415:         public String toString() {",
          "417:         }",
          "419:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "416:             return \"ProxyWriter.EOF(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "425:             return \"ProxyWriter.EOF(\" + oid + \")\";",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "448:         @Override",
          "449:         public String toString() {",
          "451:         }",
          "453:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "450:             return \"ProxyWriter.Ack(\"+oid+','+size+\")\";",
          "",
          "[Added Lines]",
          "459:             return \"ProxyWriter.Ack(\" + oid + ',' + size + \")\";",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "460:     private static final class NotifyDeadWriter extends Command {",
          "461:         private final int oid;",
          "465:             this.oid = oid;",
          "466:         }",
          "",
          "[Removed Lines]",
          "463:         private NotifyDeadWriter(Channel channel,Throwable cause, int oid) {",
          "464:             super(channel,cause);",
          "",
          "[Added Lines]",
          "472:         private NotifyDeadWriter(Channel channel, Throwable cause, int oid) {",
          "473:             super(channel, cause);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "474:         @Override",
          "475:         public String toString() {",
          "477:         }",
          "479:         private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "476:             return \"ProxyWriter.Dead(\"+oid+\")\";",
          "",
          "[Added Lines]",
          "485:             return \"ProxyWriter.Dead(\" + oid + \")\";",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java": [
          "File: src/main/java/hudson/remoting/RemoteClassLoader.java -> src/main/java/hudson/remoting/RemoteClassLoader.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: @SuppressFBWarnings(",
          "73: final class RemoteClassLoader extends URLClassLoader {",
          "75:     private static final Logger LOGGER = Logger.getLogger(RemoteClassLoader.class.getName());",
          "",
          "[Removed Lines]",
          "67:         value = {",
          "68:             \"DMI_COLLECTION_OF_URLS\",",
          "69:             \"DMI_BLOCKING_METHODS_ON_URL\",",
          "70:             \"SIC_INNER_SHOULD_BE_STATIC_ANON\"",
          "71:         },",
          "72:         justification = \"Since this is based on the URLClassLoader, it is difficult to switch to URIs. We have no indication this causes noticeable resource issues. The implementations here and in URL reduce the impact.\")",
          "",
          "[Added Lines]",
          "67:         value = {\"DMI_COLLECTION_OF_URLS\", \"DMI_BLOCKING_METHODS_ON_URL\", \"SIC_INNER_SHOULD_BE_STATIC_ANON\"},",
          "68:         justification =",
          "69:                 \"Since this is based on the URLClassLoader, it is difficult to switch to URIs. We have no indication this causes noticeable resource issues. The implementations here and in URL reduce the impact.\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "103:     static int RETRY_SLEEP_DURATION_MILLISECONDS = Integer.getInteger(RemoteClassLoader.class.getName() + \"retrySleepDurationMilliseconds\", 100);",
          "",
          "[Added Lines]",
          "100:     static int RETRY_SLEEP_DURATION_MILLISECONDS =",
          "101:             Integer.getInteger(RemoteClassLoader.class.getName() + \"retrySleepDurationMilliseconds\", 100);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "167:         String name;",
          "168:         try {",
          "169:             name = proxy.getName();",
          "171:             name = String.format(Locale.ROOT, \"unknown-due-to-io-error %1$#x\", System.identityHashCode(proxy));",
          "172:         } catch (IllegalStateException ignored) {",
          "177:         }",
          "178:         return new RemoteClassLoader(name, parent, proxy);",
          "179:     }",
          "",
          "[Removed Lines]",
          "170:         } catch(IOException ignored) {",
          "176:             name = String.format(Locale.ROOT, \"upgrade-remoting-to-3244.vf7f977e04755-or-higher %1$#x\", System.identityHashCode(proxy));",
          "",
          "[Added Lines]",
          "168:         } catch (IOException ignored) {",
          "174:             name = String.format(",
          "175:                     Locale.ROOT,",
          "176:                     \"upgrade-remoting-to-3244.vf7f977e04755-or-higher %1$#x\",",
          "177:                     System.identityHashCode(proxy));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "248:     }",
          "250:     private Class<?> loadWithMultiClassLoader(String name, Channel channel) throws ClassNotFoundException {",
          "262:         long startTime = System.nanoTime();",
          "263:         ClassReference cr;",
          "264:         if (channel.remoteCapability.supportsPrefetch()) {",
          "",
          "[Removed Lines]",
          "252:         In multi-classloader setup, RemoteClassLoaders do not retain the relationships among the original classloaders,",
          "253:         so each RemoteClassLoader ends up loading classes on its own without delegating to other RemoteClassLoaders.",
          "255:         See the classloader X/Y examples in HUDSON-5048 for the depiction of the problem.",
          "257:         So instead, we find the right RemoteClassLoader to load the class on per class basis.",
          "258:         The communication is optimized for the single classloader use, by always returning the class file image",
          "259:         along with the reference to the initiating ClassLoader (if the initiating ClassLoader has already loaded this class,",
          "260:         then the class file image is wasted.)",
          "",
          "[Added Lines]",
          "253:            In multi-classloader setup, RemoteClassLoaders do not retain the relationships among the original classloaders,",
          "254:            so each RemoteClassLoader ends up loading classes on its own without delegating to other RemoteClassLoaders.",
          "256:            See the classloader X/Y examples in HUDSON-5048 for the depiction of the problem.",
          "258:            So instead, we find the right RemoteClassLoader to load the class on per class basis.",
          "259:            The communication is optimized for the single classloader use, by always returning the class file image",
          "260:            along with the reference to the initiating ClassLoader (if the initiating ClassLoader has already loaded this class,",
          "261:            then the class file image is wasted.)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "279:         }",
          "280:     }",
          "283:         synchronized (rcl.getClassLoadingLock(name)) {",
          "284:             Class<?> c = rcl.findLoadedClass(name);",
          "",
          "[Removed Lines]",
          "282:     private Class<?> loadRemoteClass(String name, Channel channel, ClassReference cr, RemoteClassLoader rcl) throws ClassNotFoundException {",
          "",
          "[Added Lines]",
          "283:     private Class<?> loadRemoteClass(String name, Channel channel, ClassReference cr, RemoteClassLoader rcl)",
          "284:             throws ClassNotFoundException {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "316:                         sleepForRetry();",
          "318:                         continue;",
          "319:                     }",
          "320:                     break;",
          "",
          "[Removed Lines]",
          "317:                         LOGGER.finer(\"Handling interrupt while loading remote class. Current retry count = \" + tries + \", maximum = \" + MAX_RETRIES);",
          "",
          "[Added Lines]",
          "319:                         LOGGER.finer(\"Handling interrupt while loading remote class. Current retry count = \" + tries",
          "320:                                 + \", maximum = \" + MAX_RETRIES);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "342:     private boolean isRetryException(Throwable e) {",
          "343:         return e instanceof InterruptedException",
          "344:                 || (e instanceof RemotingSystemException",
          "347:     }",
          "349:     private ClassReference prefetchClassReference(String name, Channel channel) throws ClassNotFoundException {",
          "",
          "[Removed Lines]",
          "345:                 && (e.getCause() instanceof InterruptedException",
          "346:                 || e.getCause() instanceof InterruptedIOException));",
          "",
          "[Added Lines]",
          "348:                         && (e.getCause() instanceof InterruptedException",
          "349:                                 || e.getCause() instanceof InterruptedIOException));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "396:                                     ref.rememberIn(cn, this);",
          "397:                                 }",
          "400:                             }",
          "402:                             ref.rememberIn(cn, ref.classLoader);",
          "",
          "[Removed Lines]",
          "399:                                 LOGGER.log(Level.FINER, \"prefetch {0} -> {1}\", new Object[]{name, cn});",
          "",
          "[Added Lines]",
          "402:                                 LOGGER.log(Level.FINER, \"prefetch {0} -> {1}\", new Object[] {name, cn});",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "412:                         sleepForRetry();",
          "414:                         continue;",
          "415:                     }",
          "416:                     throw determineRemotingSystemException(x);",
          "",
          "[Removed Lines]",
          "413:                         LOGGER.finer(\"Handling interrupt while fetching class reference. Current retry count = \" + tries + \", maximum = \" + MAX_RETRIES);",
          "",
          "[Added Lines]",
          "416:                         LOGGER.finer(\"Handling interrupt while fetching class reference. Current retry count = \" + tries",
          "417:                                 + \", maximum = \" + MAX_RETRIES);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "451:         short bytecodeLevel = (short) ((bytes[6] << 8) + (bytes[7] & 0xFF) - 44);",
          "452:         final Channel channel = channel();",
          "453:         if (channel != null && bytecodeLevel > channel.maximumBytecodeLevel) {",
          "455:         }",
          "",
          "[Removed Lines]",
          "454:             throw new UnsupportedClassVersionError(\"this channel is restricted to JDK 1.\" + channel.maximumBytecodeLevel + \" compatibility but \" + name + \" was compiled for 1.\" + bytecodeLevel);",
          "",
          "[Added Lines]",
          "458:             throw new UnsupportedClassVersionError(\"this channel is restricted to JDK 1.\" + channel.maximumBytecodeLevel",
          "459:                     + \" compatibility but \" + name + \" was compiled for 1.\" + bytecodeLevel);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "461:         definePackage(name);",
          "464:         try {",
          "465:             return defineClass(name, bytes, 0, bytes.length);",
          "466:         } catch (UnsupportedClassVersionError e) {",
          "468:         } catch (ClassFormatError e) {",
          "469:             throw (ClassFormatError) new ClassFormatError(\"Failed to load \" + name).initCause(e);",
          "470:         } catch (LinkageError e) {",
          "",
          "[Removed Lines]",
          "467:             throw (UnsupportedClassVersionError) new UnsupportedClassVersionError(\"Failed to load \" + name).initCause(e);",
          "",
          "[Added Lines]",
          "472:             throw (UnsupportedClassVersionError)",
          "473:                     new UnsupportedClassVersionError(\"Failed to load \" + name).initCause(e);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "484:         }",
          "486:         String packageName = name.substring(0, idx);",
          "488:             return;",
          "489:         }",
          "",
          "[Removed Lines]",
          "487:         if (getPackage(packageName) != null) {   // already defined",
          "",
          "[Added Lines]",
          "493:         if (getPackage(packageName) != null) { // already defined",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "507:                 if (resourceMap.containsKey(name)) {",
          "508:                     URLish f = resourceMap.get(name);",
          "509:                     if (f == null) {",
          "511:                     }",
          "512:                     URL u = f.toURL();",
          "513:                     if (u != null) {",
          "",
          "[Removed Lines]",
          "510:                         return null;    // no such resource",
          "",
          "[Added Lines]",
          "516:                         return null; // no such resource",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "546:                     sleepForRetry();",
          "548:                     continue;",
          "549:                 }",
          "550:                 throw determineRemotingSystemException(x);",
          "",
          "[Removed Lines]",
          "547:                     LOGGER.finer(\"Handling interrupt while finding resource. Current retry count = \" + tries + \", maximum = \" + MAX_RETRIES);",
          "",
          "[Added Lines]",
          "553:                     LOGGER.finer(\"Handling interrupt while finding resource. Current retry count = \" + tries",
          "554:                             + \", maximum = \" + MAX_RETRIES);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "575:         for (URLish s : src) {",
          "576:             URL u = s.toURL();",
          "577:             if (u == null) {",
          "579:             }",
          "580:             r.add(u);",
          "581:         }",
          "",
          "[Removed Lines]",
          "578:                 return null;    // abort",
          "",
          "[Added Lines]",
          "585:                 return null; // abort",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "641:                     sleepForRetry();",
          "643:                     continue;",
          "644:                 }",
          "645:                 throw determineRemotingSystemException(x);",
          "",
          "[Removed Lines]",
          "642:                     LOGGER.finer(\"Handling interrupt while finding resource. Current retry count = \" + tries + \", maximum = \" + MAX_RETRIES);",
          "",
          "[Added Lines]",
          "649:                     LOGGER.finer(\"Handling interrupt while finding resource. Current retry count = \" + tries",
          "650:                             + \", maximum = \" + MAX_RETRIES);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "765:         @SuppressFBWarnings(value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification = \"We're fine with the default null on the recipient side\")",
          "766:         transient final URL local;",
          "",
          "[Added Lines]",
          "772:         @SuppressFBWarnings(",
          "773:                 value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\",",
          "774:                 justification = \"We're fine with the default null on the recipient side\")",
          "775:         final transient URL local;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "822:         ClassFile2(int classLoader, ResourceImageRef image, ClassFile2 referer, Class<?> clazz, URL local) {",
          "823:             super(image, local);",
          "",
          "[Removed Lines]",
          "819:         @SuppressFBWarnings(value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification = \"We're fine with the default null on the recipient side\")",
          "820:         transient final Class<?> clazz;",
          "",
          "[Added Lines]",
          "828:         @SuppressFBWarnings(",
          "829:                 value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\",",
          "830:                 justification = \"We're fine with the default null on the recipient side\")",
          "831:         final transient Class<?> clazz;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "931:             final RemoteClassLoader rcl = (RemoteClassLoader) cl;",
          "932:             int oid = RemoteInvocationHandler.unwrap(rcl.proxy, local);",
          "934:         }",
          "935:         local.pin(new ClassLoaderProxy(cl, local));",
          "936:     }",
          "",
          "[Removed Lines]",
          "933:             if (oid != -1) return;",
          "",
          "[Added Lines]",
          "944:             if (oid != -1) {",
          "945:                 return;",
          "946:             }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "956:         }",
          "958:         @Override",
          "960:         public byte[] fetchJar(URL url) throws IOException {",
          "961:             return Util.readFully(url.openStream());",
          "962:         }",
          "",
          "[Removed Lines]",
          "959:         @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "[Added Lines]",
          "972:         @SuppressFBWarnings(",
          "973:                 value = \"URLCONNECTION_SSRF_FD\",",
          "974:                 justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "995:                 if (in == null) {",
          "996:                     throw new ClassNotFoundException(className + \" (\" + ecl + \" did not find class file)\");",
          "997:                 }",
          "1001:             } catch (IOException e) {",
          "1002:                 throw new ClassNotFoundException();",
          "1003:             }",
          "",
          "[Removed Lines]",
          "998:                 return new ClassFile(",
          "999:                         exportId(ecl, channel),",
          "1000:                         Util.readFully(in));",
          "",
          "[Added Lines]",
          "1013:                 return new ClassFile(exportId(ecl, channel), Util.readFully(in));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1019:                 if (USE_BOOTSTRAP_CLASSLOADER) {",
          "1020:                     ecl = PSEUDO_BOOTSTRAP;",
          "1021:                 } else {",
          "1023:                 }",
          "1024:             }",
          "",
          "[Removed Lines]",
          "1022:                     throw new ClassNotFoundException(\"Bootstrap pseudo-classloader disabled: \" + className + \" via \" + referrerClass);",
          "",
          "[Added Lines]",
          "1035:                     throw new ClassNotFoundException(",
          "1036:                             \"Bootstrap pseudo-classloader disabled: \" + className + \" via \" + referrerClass);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1029:                 try {",
          "1030:                     File jar = Which.jarFile(c);",
          "1032:                         Checksum sum = channel.jarLoader.calcChecksum(jar);",
          "1034:                         ResourceImageRef imageRef;",
          "",
          "[Removed Lines]",
          "1031:                     if (jar.isFile()) {// for historical reasons the jarFile method can return a directory",
          "",
          "[Added Lines]",
          "1045:                     if (jar.isFile()) { // for historical reasons the jarFile method can return a directory",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1038:                             imageRef = new ResourceImageBoth(urlOfClassFile, sum);",
          "1039:                         } else { // otherwise just send the checksum and save space",
          "1041:                         }",
          "1043:                         return new ClassFile2(exportId(ecl, channel), imageRef, referer, c, urlOfClassFile);",
          "",
          "[Removed Lines]",
          "1040:                             imageRef = new ResourceImageInJar(sum, null /* TODO: we need to check if the URL of c points to the expected location of the file */);",
          "",
          "[Added Lines]",
          "1054:                             imageRef = new ResourceImageInJar(",
          "1055:                                     sum,",
          "1056:                                     null /* TODO: we need to check if the URL of c points to the expected location of the file */);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1053:         }",
          "1055:         @Override",
          "1057:         public Map<String, ClassFile2> fetch3(String className) throws ClassNotFoundException {",
          "1058:             ClassFile2 cf = fetch4(className, null);",
          "1059:             Map<String, ClassFile2> all = new HashMap<>();",
          "",
          "[Removed Lines]",
          "1056:         @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "[Added Lines]",
          "1072:         @SuppressFBWarnings(",
          "1073:                 value = \"URLCONNECTION_SSRF_FD\",",
          "1074:                 justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1116:         private ResourceFile makeResource(String name, URL resource) throws IOException {",
          "1117:             try {",
          "1118:                 File jar = Which.jarFile(resource, name);",
          "1120:                     Checksum sum = channel.jarLoader.calcChecksum(jar);",
          "1121:                     ResourceImageRef ir;",
          "1122:                     if (!channel.jarLoader.isPresentOnRemote(sum)) {",
          "1124:                     } else {",
          "1125:                         ir = new ResourceImageInJar(sum, null);",
          "1126:                     }",
          "",
          "[Removed Lines]",
          "1119:                 if (jar.isFile()) {// for historical reasons the jarFile method can return a directory",
          "1123:                         ir = new ResourceImageBoth(resource, sum);   // remote probably doesn't have",
          "",
          "[Added Lines]",
          "1137:                 if (jar.isFile()) { // for historical reasons the jarFile method can return a directory",
          "1141:                         ir = new ResourceImageBoth(resource, sum); // remote probably doesn't have",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1133:         }",
          "1135:         @Override",
          "1137:                 justification = \"Null return value is a part of the public interface\")",
          "1138:         @CheckForNull",
          "1139:         public byte[] getResource(String name) throws IOException {",
          "",
          "[Removed Lines]",
          "1136:         @SuppressFBWarnings(value = \"PZLA_PREFER_ZERO_LENGTH_ARRAYS\",",
          "",
          "[Added Lines]",
          "1154:         @SuppressFBWarnings(",
          "1155:                 value = \"PZLA_PREFER_ZERO_LENGTH_ARRAYS\",",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1244:     private static class RemoteIClassLoader implements IClassLoader, SerializableOnlyOverRemoting {",
          "1246:         private final int oid;",
          "1248:         private RemoteIClassLoader(int oid, IClassLoader proxy) {",
          "",
          "[Removed Lines]",
          "1245:         private transient final IClassLoader proxy;",
          "",
          "[Added Lines]",
          "1264:         private final transient IClassLoader proxy;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1384:     private static final Enumeration<URL> EMPTY_ENUMERATION = new Vector<URL>().elements();",
          "1385: }",
          "",
          "[Removed Lines]",
          "1382:     public static boolean USE_BOOTSTRAP_CLASSLOADER = Boolean.getBoolean(RemoteClassLoader.class.getName() + \".useBootstrapClassLoader\");",
          "",
          "[Added Lines]",
          "1400:     public static boolean USE_BOOTSTRAP_CLASSLOADER =",
          "1401:             Boolean.getBoolean(RemoteClassLoader.class.getName() + \".useBootstrapClassLoader\");",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteInputStream.java||src/main/java/hudson/remoting/RemoteInputStream.java": [
          "File: src/main/java/hudson/remoting/RemoteInputStream.java -> src/main/java/hudson/remoting/RemoteInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:     @Deprecated",
          "80:     public RemoteInputStream(InputStream core, boolean autoUnexport) {",
          "82:     }",
          "87:     public RemoteInputStream(InputStream core, Flag f) {",
          "89:     }",
          "94:     public RemoteInputStream(InputStream core, Flag f1, Flag f2) {",
          "96:     }",
          "",
          "[Removed Lines]",
          "81:         this(core, RemoteInputStream.Flag.NOT_GREEDY, autoUnexport ? RemoteInputStream.Flag.NOT_GREEDY : RemoteInputStream.Flag.MANUAL_UNEXPORT);",
          "88:         this(core,EnumSet.of(f));",
          "95:         this(core,EnumSet.of(f1,f2));",
          "",
          "[Added Lines]",
          "81:         this(",
          "82:                 core,",
          "83:                 RemoteInputStream.Flag.NOT_GREEDY,",
          "84:                 autoUnexport ? RemoteInputStream.Flag.NOT_GREEDY : RemoteInputStream.Flag.MANUAL_UNEXPORT);",
          "91:         this(core, EnumSet.of(f));",
          "98:         this(core, EnumSet.of(f1, f2));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:     public RemoteInputStream(InputStream core, Set<Flag> flags) {",
          "102:         this.core = core;",
          "103:         greedy = flags.contains(RemoteInputStream.Flag.GREEDY);",
          "105:             greedyAt = new Greedy();",
          "106:         autoUnexport = !flags.contains(RemoteInputStream.Flag.MANUAL_UNEXPORT);",
          "107:     }",
          "",
          "[Removed Lines]",
          "104:         if (greedy)",
          "",
          "[Added Lines]",
          "107:         if (greedy) {",
          "109:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:                 new Thread(\"RemoteInputStream greedy pump thread: \" + greedyAt.print()) {",
          "120:                     {",
          "123:                         setDaemon(true);",
          "124:                     }",
          "",
          "[Removed Lines]",
          "121:                         setUncaughtExceptionHandler(",
          "122:                                 (t, e) -> LOGGER.log(Level.SEVERE, \"Uncaught exception in RemoteInputStream pump thread \" + t, e));",
          "",
          "[Added Lines]",
          "125:                         setUncaughtExceptionHandler((t, e) -> LOGGER.log(",
          "126:                                 Level.SEVERE, \"Uncaught exception in RemoteInputStream pump thread \" + t, e));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131:                             while (true) {",
          "132:                                 try {",
          "133:                                     len = i.read(buf);",
          "135:                                 } catch (IOException e) {",
          "137:                                     if (o instanceof ErrorPropagatingOutputStream) {",
          "",
          "[Removed Lines]",
          "134:                                     if (len < 0) break;",
          "",
          "[Added Lines]",
          "138:                                     if (len < 0) {",
          "139:                                         break;",
          "140:                                     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "175:         oos.writeInt(id);",
          "176:     }",
          "179:     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {",
          "180:         final Channel channel = getChannelForSerialization();",
          "181:         if (channel.remoteCapability.supportsGreedyRemoteInputStream()) {",
          "182:             boolean greedy = ois.readBoolean();",
          "183:             if (greedy) {",
          "185:                 this.core = p.getIn();",
          "186:                 return;",
          "187:             }",
          "",
          "[Removed Lines]",
          "178:     @SuppressFBWarnings(value = \"DESERIALIZATION_GADGET\", justification = \"Serializable only over remoting. Class filtering is done through JEP-200.\")",
          "184:                 Pipe p = (Pipe)ois.readObject();",
          "",
          "[Added Lines]",
          "184:     @SuppressFBWarnings(",
          "185:             value = \"DESERIALIZATION_GADGET\",",
          "186:             justification = \"Serializable only over remoting. Class filtering is done through JEP-200.\")",
          "192:                 Pipe p = (Pipe) ois.readObject();",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteInvocationHandler.java||src/main/java/hudson/remoting/RemoteInvocationHandler.java": [
          "File: src/main/java/hudson/remoting/RemoteInvocationHandler.java -> src/main/java/hudson/remoting/RemoteInvocationHandler.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:         this.channel = channel == null ? null : channel.ref();",
          "139:         this.oid = id;",
          "140:         this.userProxy = userProxy;",
          "",
          "[Removed Lines]",
          "135:     private RemoteInvocationHandler(Channel channel, int id, boolean userProxy,",
          "136:                             boolean autoUnexportByCaller, boolean userSpace,",
          "137:                             Class<?> proxyType, boolean recordCreatedAt) {",
          "",
          "[Added Lines]",
          "135:     private RemoteInvocationHandler(",
          "136:             Channel channel,",
          "137:             int id,",
          "138:             boolean userProxy,",
          "139:             boolean autoUnexportByCaller,",
          "140:             boolean userSpace,",
          "141:             Class<?> proxyType,",
          "142:             boolean recordCreatedAt) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:     @NonNull",
          "156:         ClassLoader cl = type.getClassLoader();",
          "159:             cl = IReadResolve.class.getClassLoader();",
          "161:         if (channel != null) {",
          "162:             if (!autoUnexportByCaller) {",
          "163:                 UNEXPORTER.watch(handler);",
          "164:             }",
          "165:         }",
          "167:     }",
          "",
          "[Removed Lines]",
          "155:     static <T> T wrap(Channel channel, int id, Class<T> type, boolean userProxy, boolean autoUnexportByCaller, boolean userSpace, boolean recordCreatedAt) {",
          "158:         if(cl==null || cl==ClassLoader.getSystemClassLoader())",
          "160:         RemoteInvocationHandler handler = new RemoteInvocationHandler(channel, id, userProxy, autoUnexportByCaller, userSpace, type, recordCreatedAt);",
          "166:         return type.cast(Proxy.newProxyInstance(cl, new Class[]{type, IReadResolve.class}, handler));",
          "",
          "[Added Lines]",
          "160:     static <T> T wrap(",
          "161:             Channel channel,",
          "162:             int id,",
          "163:             Class<T> type,",
          "164:             boolean userProxy,",
          "165:             boolean autoUnexportByCaller,",
          "166:             boolean userSpace,",
          "167:             boolean recordCreatedAt) {",
          "170:         if (cl == null || cl == ClassLoader.getSystemClassLoader()) {",
          "172:         }",
          "173:         RemoteInvocationHandler handler = new RemoteInvocationHandler(",
          "174:                 channel, id, userProxy, autoUnexportByCaller, userSpace, type, recordCreatedAt);",
          "180:         return type.cast(Proxy.newProxyInstance(cl, new Class[] {type, IReadResolve.class}, handler));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "210:         }",
          "211:         Channel c = ch.channel();",
          "212:         if (c == null) {",
          "214:         }",
          "215:         return c;",
          "216:     }",
          "",
          "[Removed Lines]",
          "213:             throw new IOException(\"Backing channel '\"+ch.name()+\"' is disconnected.\",ch.cause());",
          "",
          "[Added Lines]",
          "227:             throw new IOException(\"Backing channel '\" + ch.name() + \"' is disconnected.\", ch.cause());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "226:         InvocationHandler h = Proxy.getInvocationHandler(proxy);",
          "227:         if (h instanceof RemoteInvocationHandler) {",
          "228:             RemoteInvocationHandler rih = (RemoteInvocationHandler) h;",
          "230:                 return rih.oid;",
          "231:         }",
          "232:         return -1;",
          "233:     }",
          "",
          "[Removed Lines]",
          "229:             if(rih.channel()==src)",
          "",
          "[Added Lines]",
          "243:             if (rih.channel() == src) {",
          "245:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "249:     @Override",
          "250:     @Nullable",
          "251:     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {",
          "257:         }",
          "260:             throw new IllegalStateException(\"proxy is not connected to a channel\");",
          "264:         Class<?> dc = method.getDeclaringClass();",
          "267:             try {",
          "269:             } catch (InvocationTargetException e) {",
          "270:                 throw e.getTargetException();",
          "271:             }",
          "",
          "[Removed Lines]",
          "252:         if(method.getDeclaringClass()==IReadResolve.class) {",
          "255:             if(goingHome)   return Channel.currentOrFail().getExportedObject(oid);",
          "256:             else            return proxy;",
          "259:         if(channel==null)",
          "262:         if(args==null)  args = EMPTY_ARRAY;",
          "265:         if(dc ==Object.class) {",
          "268:                 return method.invoke(this,args);",
          "",
          "[Added Lines]",
          "267:         if (method.getDeclaringClass() == IReadResolve.class) {",
          "270:             if (goingHome) {",
          "271:                 return Channel.currentOrFail().getExportedObject(oid);",
          "272:             } else {",
          "273:                 return proxy;",
          "274:             }",
          "277:         if (channel == null) {",
          "279:         }",
          "281:         if (args == null) {",
          "282:             args = EMPTY_ARRAY;",
          "283:         }",
          "286:         if (dc == Object.class) {",
          "289:                 return method.invoke(this, args);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "278:                 ? new UserRPCRequest(oid, method, args, userProxy ? dc.getClassLoader() : null, recordCreatedAt)",
          "279:                 : new RPCRequest(oid, method, args, userProxy ? dc.getClassLoader() : null, recordCreatedAt);",
          "280:         try {",
          "284:             } else {",
          "287:             }",
          "288:             return null;",
          "289:         } catch (Throwable e) {",
          "290:             for (Class<?> exc : method.getExceptionTypes()) {",
          "293:             }",
          "",
          "[Removed Lines]",
          "281:             if(userProxy) {",
          "282:                 if (async)  channelOrFail().callAsync(req);",
          "283:                 else        return channelOrFail().call(req);",
          "285:                 if (async)  req.callAsync(channelOrFail());",
          "286:                 else        return req.call(channelOrFail());",
          "291:                 if (exc.isInstance(e))",
          "292:                     throw e;    // signature explicitly lists this exception",
          "294:             if (e instanceof RuntimeException || e instanceof Error)",
          "295:                 throw e;    // these can be thrown from any methods",
          "",
          "[Added Lines]",
          "302:             if (userProxy) {",
          "303:                 if (async) {",
          "304:                     channelOrFail().callAsync(req);",
          "305:                 } else {",
          "306:                     return channelOrFail().call(req);",
          "307:                 }",
          "309:                 if (async) {",
          "310:                     req.callAsync(channelOrFail());",
          "311:                 } else {",
          "312:                     return req.call(channelOrFail());",
          "313:                 }",
          "318:                 if (exc.isInstance(e)) {",
          "319:                     throw e; // signature explicitly lists this exception",
          "320:                 }",
          "321:             }",
          "322:             if (e instanceof RuntimeException || e instanceof Error) {",
          "323:                 throw e; // these can be thrown from any methods",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "319:     }",
          "321:     private void writeObject(ObjectOutputStream oos) throws IOException {",
          "323:         oos.defaultWriteObject();",
          "324:     }",
          "",
          "[Removed Lines]",
          "322:         goingHome = channel!=null;",
          "",
          "[Added Lines]",
          "351:         goingHome = channel != null;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "329:     @Override",
          "330:     public boolean equals(Object o) {",
          "332:             o = Proxy.getInvocationHandler(o);",
          "337:         RemoteInvocationHandler that = (RemoteInvocationHandler) o;",
          "341:     }",
          "343:     @Override",
          "",
          "[Removed Lines]",
          "331:         if(o!=null && Proxy.isProxyClass(o.getClass()))",
          "334:         if (this == o) return true;",
          "335:         if (o == null || getClass() != o.getClass()) return false;",
          "339:         return this.oid==that.oid && this.channel==that.channel;",
          "",
          "[Added Lines]",
          "360:         if (o != null && Proxy.isProxyClass(o.getClass())) {",
          "362:         }",
          "364:         if (this == o) {",
          "365:             return true;",
          "366:         }",
          "367:         if (o == null || getClass() != o.getClass()) {",
          "368:             return false;",
          "369:         }",
          "373:         return this.oid == that.oid && this.channel == that.channel;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "378:             super(referent, referenceQueue);",
          "379:             this.oid = referent.oid;",
          "380:             this.origin = Unexporter.retainOrigin ? referent.origin : null;",
          "",
          "[Removed Lines]",
          "376:         private PhantomReferenceImpl(RemoteInvocationHandler referent,",
          "377:                                     ReferenceQueue<? super RemoteInvocationHandler> referenceQueue) {",
          "",
          "[Added Lines]",
          "409:         private PhantomReferenceImpl(",
          "410:                 RemoteInvocationHandler referent, ReferenceQueue<? super RemoteInvocationHandler> referenceQueue) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "473:         private final ExecutorService svc = new AtmostOneThreadExecutor(",
          "",
          "[Removed Lines]",
          "453:         private static final int batchSize = Math.max(10, Math.min(10000, Integer.getInteger(",
          "454:                         Unexporter.class.getName() + \".batchSize\", 256)));",
          "459:         private static final double m1Alpha = 1.0 - Math.exp( -measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(1));",
          "464:         private static final double m5Alpha = 1.0 - Math.exp( -measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(5));",
          "469:         private static final double m15Alpha = 1.0 - Math.exp( -measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(15));",
          "474:                 new NamingThreadFactory(new DaemonThreadFactory(), RemoteInvocationHandler.class.getSimpleName())",
          "475:         );",
          "",
          "[Added Lines]",
          "486:         private static final int batchSize =",
          "487:                 Math.max(10, Math.min(10000, Integer.getInteger(Unexporter.class.getName() + \".batchSize\", 256)));",
          "492:         private static final double m1Alpha = 1.0 - Math.exp(-measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(1));",
          "497:         private static final double m5Alpha = 1.0 - Math.exp(-measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(5));",
          "502:         private static final double m15Alpha = 1.0 - Math.exp(-measureInterval * 1.0 / TimeUnit.MINUTES.toNanos(15));",
          "507:                 new NamingThreadFactory(new DaemonThreadFactory(), RemoteInvocationHandler.class.getSimpleName()));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "492:         private final ConcurrentMap<Channel.Ref,List<PhantomReferenceImpl>> referenceLists",
          "493:                 = new ConcurrentHashMap<>();",
          "",
          "[Added Lines]",
          "524:         private final ConcurrentMap<Channel.Ref, List<PhantomReferenceImpl>> referenceLists = new ConcurrentHashMap<>();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "562:             try {",
          "563:                 seconds = value == null || value.isEmpty() ? def : Double.parseDouble(value);",
          "564:             } catch (NumberFormatException e) {",
          "566:                         String.format(\"The system property '%s'='%s' could not be parsed\", name, value),",
          "569:                 seconds = def;",
          "570:             }",
          "571:             return (long) (1.0e9 * Math.max(min, Math.min(max, seconds)));",
          "",
          "[Removed Lines]",
          "565:                 logger.log(Level.WARNING,",
          "567:                         e",
          "568:                 );",
          "",
          "[Added Lines]",
          "596:                 logger.log(",
          "597:                         Level.WARNING,",
          "599:                         e);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "596:                         int batchIndex = 0;",
          "597:                         while (nextSweep - System.nanoTime() > 0) {",
          "598:                             while (batchIndex < batch.length",
          "600:                                 Reference<?> ref = queue.remove(remaining);",
          "601:                                 if (ref == null) {",
          "602:                                     break;",
          "",
          "[Removed Lines]",
          "599:                                     && (remaining = (nextSweep - System.nanoTime())/ NANOSECONDS_PER_MILLISECOND) > 0) {",
          "",
          "[Added Lines]",
          "630:                                     && (remaining = (nextSweep - System.nanoTime()) / NANOSECONDS_PER_MILLISECOND)",
          "631:                                             > 0) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "613:                                 } catch (ChannelClosedException e) {",
          "615:                                 } catch (Error e) {",
          "618:                                     throw e; // pass on as there is nothing we can do with an error",
          "619:                                 } catch (Throwable e) {",
          "622:                                 } finally {",
          "623:                                     if (channelRef != null) {",
          "624:                                         final List<PhantomReferenceImpl> referenceList = referenceLists.get(channelRef);",
          "",
          "[Removed Lines]",
          "616:                                     logger.log(Level.SEVERE, String.format(\"Couldn't clean up oid=%d from %s\",",
          "617:                                             batch[index].oid, batch[index].origin), e);",
          "620:                                     logger.log(Level.WARNING, String.format(\"Couldn't clean up oid=%d from %s\",",
          "621:                                             batch[index].oid, batch[index].origin), e);",
          "",
          "[Added Lines]",
          "648:                                     logger.log(",
          "649:                                             Level.SEVERE,",
          "650:                                             String.format(",
          "651:                                                     \"Couldn't clean up oid=%d from %s\",",
          "652:                                                     batch[index].oid, batch[index].origin),",
          "653:                                             e);",
          "656:                                     logger.log(",
          "657:                                             Level.WARNING,",
          "658:                                             String.format(",
          "659:                                                     \"Couldn't clean up oid=%d from %s\",",
          "660:                                                     batch[index].oid, batch[index].origin),",
          "661:                                             e);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "641:                         nextSweep = System.nanoTime() + sweepInterval;",
          "647:                             final Map.Entry<Channel.Ref, List<PhantomReferenceImpl>> entry = iterator.next();",
          "648:                             final Channel.Ref r = entry.getKey();",
          "649:                             if (r == null || r.channel() == null) {",
          "",
          "[Removed Lines]",
          "644:                         for (Iterator<Map.Entry<Channel.Ref, List<PhantomReferenceImpl>>>",
          "645:                              iterator = referenceLists.entrySet().iterator();",
          "646:                              iterator.hasNext(); ) {",
          "",
          "[Added Lines]",
          "684:                         for (Iterator<Map.Entry<Channel.Ref, List<PhantomReferenceImpl>>> iterator =",
          "685:                                         referenceLists.entrySet().iterator();",
          "686:                                 iterator.hasNext(); ) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "697:             double tStd = tCount <= 0 || tVarTimesCount < 0 ? 0 : Math.sqrt(tVarTimesCount / tCount);",
          "698:             Level targetLevel = m15Avg > 100 ? Level.INFO : m15Avg > 50 ? Level.FINE : Level.FINER;",
          "699:             if (logger.isLoggable(targetLevel)) {",
          "706:             }",
          "707:             if (tCount < 10L) {",
          "",
          "[Removed Lines]",
          "700:                 logger.log(targetLevel, () -> String.format(\"rate(1min) = %.1f\u00b1%.1f/sec; \"",
          "701:                                 + \"rate(5min) = %.1f\u00b1%.1f/sec; \"",
          "702:                                 + \"rate(15min) = %.1f\u00b1%.1f/sec; \"",
          "703:                                 + \"rate(total) = %.1f\u00b1%.1f/sec; N = %d\",",
          "704:                                 m1Avg, m1Std, m5Avg, m5Std, m15Avg, m15Std, tAvg, tStd, tCount",
          "705:                 ));",
          "",
          "[Added Lines]",
          "740:                 logger.log(",
          "741:                         targetLevel,",
          "742:                         () -> String.format(",
          "743:                                 \"rate(1min) = %.1f\u00b1%.1f/sec; \"",
          "744:                                         + \"rate(5min) = %.1f\u00b1%.1f/sec; \"",
          "745:                                         + \"rate(15min) = %.1f\u00b1%.1f/sec; \"",
          "746:                                         + \"rate(total) = %.1f\u00b1%.1f/sec; N = %d\",",
          "747:                                 m1Avg, m1Std, m5Avg, m5Std, m15Avg, m15Std, tAvg, tStd, tCount));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "712:             if (m15Std > 1 && 100 < m15Avg - 2 * m15Std) {",
          "713:                 if (tStd > 1 && 100 < tAvg - 2 * tStd) {",
          "725:                                                     + \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "726:                                                     + \"At the 95%% confidence level both are above 100.0/sec. \",",
          "728:                     return;",
          "729:                 }",
          "742:                 return;",
          "743:             }",
          "744:             if (m5Std > 1 && 100 < m5Avg - 2 * m5Std) {",
          "757:                 return;",
          "758:             }",
          "759:             if (m1Std > 1 && 100 < m1Avg - 2 * m1Std) {",
          "772:             }",
          "773:         }",
          "",
          "[Removed Lines]",
          "714:                     logger.log(Level.SEVERE,",
          "715:                             String.format(retainOrigin ?",
          "716:                                     \"The all time average rate is %.1f\u00b1%.1f/sec. \"",
          "717:                                     + \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "718:                                             + \"At the 95% confidence level both are above 100.0/sec. \"",
          "719:                                             + \"If this message is repeated often in the logs then PLEASE \"",
          "720:                                             + \"seriously consider setting system property 'hudson.remoting\"",
          "721:                                             + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "722:                                             + \"'false' to trade debug diagnostics for reduced memory \"",
          "723:                                             + \"pressure.\"",
          "724:                                     : \"The all time average rate is %.1f\u00b1%.1f/sec. \"",
          "727:                                     tAvg, tStd, m15Avg, m15Std));",
          "730:                 logger.log(Level.WARNING,",
          "731:                         String.format(retainOrigin ?",
          "732:                                 \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "733:                                         + \"At the 95% confidence level this is above 100.0/sec. \"",
          "734:                                         + \"If this message is repeated often in the logs then very \"",
          "735:                                         + \"seriously consider setting system property 'hudson.remoting\"",
          "736:                                         + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "737:                                         + \"'false' to trade debug diagnostics for reduced memory \"",
          "738:                                         + \"pressure.\"",
          "739:                                 : \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "740:                                         + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "741:                                 m15Avg, m15Std));",
          "745:                 logger.log(Level.WARNING,",
          "746:                         String.format(retainOrigin ?",
          "747:                                 \"The 5 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "748:                                         + \"At the 95% confidence level this is above 100.0/sec. \"",
          "749:                                         + \"If this message is repeated often in the logs then \"",
          "750:                                         + \"seriously consider setting system property 'hudson.remoting\"",
          "751:                                         + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "752:                                         + \"'false' to trade debug diagnostics for reduced memory \"",
          "753:                                         + \"pressure.\"",
          "754:                                 : \"The 5 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "755:                                         + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "756:                                 m5Avg, m5Std));",
          "760:                 logger.log(Level.INFO,",
          "761:                         String.format(retainOrigin ?",
          "762:                                 \"The 1 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "763:                                         + \"At the 95% confidence level this is above 100.0/sec. \"",
          "764:                                         + \"If this message is repeated often in the logs then \"",
          "765:                                         + \"consider setting system property 'hudson.remoting\"",
          "766:                                         + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "767:                                         + \"'false' to trade debug diagnostics for reduced memory \"",
          "768:                                         + \"pressure.\"",
          "769:                                 : \"The 1 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "770:                                         + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "771:                                 m1Avg, m1Std));",
          "",
          "[Added Lines]",
          "756:                     logger.log(",
          "757:                             Level.SEVERE,",
          "758:                             String.format(",
          "759:                                     retainOrigin",
          "760:                                             ? \"The all time average rate is %.1f\u00b1%.1f/sec. \"",
          "761:                                                     + \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "762:                                                     + \"At the 95% confidence level both are above 100.0/sec. \"",
          "763:                                                     + \"If this message is repeated often in the logs then PLEASE \"",
          "764:                                                     + \"seriously consider setting system property 'hudson.remoting\"",
          "765:                                                     + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "766:                                                     + \"'false' to trade debug diagnostics for reduced memory \"",
          "767:                                                     + \"pressure.\"",
          "768:                                             : \"The all time average rate is %.1f\u00b1%.1f/sec. \"",
          "771:                                     tAvg,",
          "772:                                     tStd,",
          "773:                                     m15Avg,",
          "774:                                     m15Std));",
          "777:                 logger.log(",
          "778:                         Level.WARNING,",
          "779:                         String.format(",
          "780:                                 retainOrigin",
          "781:                                         ? \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "782:                                                 + \"At the 95% confidence level this is above 100.0/sec. \"",
          "783:                                                 + \"If this message is repeated often in the logs then very \"",
          "784:                                                 + \"seriously consider setting system property 'hudson.remoting\"",
          "785:                                                 + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "786:                                                 + \"'false' to trade debug diagnostics for reduced memory \"",
          "787:                                                 + \"pressure.\"",
          "788:                                         : \"The 15 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "789:                                                 + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "790:                                 m15Avg,",
          "791:                                 m15Std));",
          "795:                 logger.log(",
          "796:                         Level.WARNING,",
          "797:                         String.format(",
          "798:                                 retainOrigin",
          "799:                                         ? \"The 5 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "800:                                                 + \"At the 95% confidence level this is above 100.0/sec. \"",
          "801:                                                 + \"If this message is repeated often in the logs then \"",
          "802:                                                 + \"seriously consider setting system property 'hudson.remoting\"",
          "803:                                                 + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "804:                                                 + \"'false' to trade debug diagnostics for reduced memory \"",
          "805:                                                 + \"pressure.\"",
          "806:                                         : \"The 5 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "807:                                                 + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "808:                                 m5Avg,",
          "809:                                 m5Std));",
          "813:                 logger.log(",
          "814:                         Level.INFO,",
          "815:                         String.format(",
          "816:                                 retainOrigin",
          "817:                                         ? \"The 1 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "818:                                                 + \"At the 95% confidence level this is above 100.0/sec. \"",
          "819:                                                 + \"If this message is repeated often in the logs then \"",
          "820:                                                 + \"consider setting system property 'hudson.remoting\"",
          "821:                                                 + \".RemoteInvocationHandler.Unexporter.retainOrigin' to \"",
          "822:                                                 + \"'false' to trade debug diagnostics for reduced memory \"",
          "823:                                                 + \"pressure.\"",
          "824:                                         : \"The 1 minute average rate is %.1f\u00b1%.1f/sec. \"",
          "825:                                                 + \"At the 95%% confidence level this is above 100.0/sec. \",",
          "826:                                 m1Avg,",
          "827:                                 m1Std));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "851:     static class RPCRequest extends Request<Serializable,Throwable> implements DelegatingCallable<Serializable,Throwable>, InternalCallable<Serializable, Throwable> {",
          "",
          "[Added Lines]",
          "907:     static class RPCRequest extends Request<Serializable, Throwable>",
          "908:             implements DelegatingCallable<Serializable, Throwable>, InternalCallable<Serializable, Throwable> {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "880:         @CheckForNull",
          "882:         private final transient ClassLoader classLoader;",
          "885:             super(recordCreatedAt);",
          "886:             this.oid = oid;",
          "887:             this.arguments = arguments;",
          "",
          "[Removed Lines]",
          "881:         @SuppressFBWarnings(value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification = \"We're fine with the default null on the recipient side\")",
          "884:         private RPCRequest(int oid, Method m, Object[] arguments, @CheckForNull ClassLoader cl, boolean recordCreatedAt) {",
          "",
          "[Added Lines]",
          "938:         @SuppressFBWarnings(",
          "939:                 value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\",",
          "940:                 justification = \"We're fine with the default null on the recipient side\")",
          "943:         private RPCRequest(",
          "944:                 int oid, Method m, Object[] arguments, @CheckForNull ClassLoader cl, boolean recordCreatedAt) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "892:             this.types = new String[arguments.length];",
          "893:             Class<?>[] params = m.getParameterTypes();",
          "895:                 types[i] = params[i].getName();",
          "896:         }",
          "898:         @Override",
          "",
          "[Removed Lines]",
          "894:             for( int i=0; i<arguments.length; i++ )",
          "",
          "[Added Lines]",
          "954:             for (int i = 0; i < arguments.length; i++) {",
          "956:             }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "903:         @Override",
          "904:         public ClassLoader getClassLoader() {",
          "906:                 return classLoader;",
          "908:                 return getClass().getClassLoader();",
          "909:         }",
          "911:         @Override",
          "",
          "[Removed Lines]",
          "905:             if(classLoader!=null)",
          "907:             else",
          "",
          "[Added Lines]",
          "966:             if (classLoader != null) {",
          "968:             } else {",
          "970:             }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "914:             Class<?>[] clazz = channel.getExportedTypes(oid);",
          "915:             try {",
          "916:                 Method m = choose(clazz);",
          "920:                 Object r;",
          "921:                 try {",
          "922:                     r = m.invoke(o, arguments);",
          "923:                 } catch (IllegalArgumentException x) {",
          "925:                 }",
          "927:                     return (Serializable) r;",
          "930:             } catch (InvocationTargetException e) {",
          "931:                 throw e.getTargetException();",
          "932:             }",
          "",
          "[Removed Lines]",
          "917:                 if(m==null)",
          "918:                     throw new IllegalStateException(\"Unable to call \" + methodName + \". No matching method found in \" + Arrays.toString(clazz) + \" for \" + o);",
          "919:                 m.setAccessible(true);  // in case the class is not public",
          "924:                     throw new RemotingSystemException(\"failed to invoke \" + m + \" on \" + o + Arrays.toString(arguments), x);",
          "926:                 if (r==null || r instanceof Serializable)",
          "928:                 else",
          "929:                     throw new RemotingSystemException(new ClassCastException(r.getClass()+\" is returned from \"+m+\" on \"+o.getClass()+\" but it's not serializable\"));",
          "",
          "[Added Lines]",
          "979:                 if (m == null) {",
          "980:                     throw new IllegalStateException(\"Unable to call \" + methodName + \". No matching method found in \"",
          "981:                             + Arrays.toString(clazz) + \" for \" + o);",
          "982:                 }",
          "983:                 m.setAccessible(true); // in case the class is not public",
          "988:                     throw new RemotingSystemException(",
          "989:                             \"failed to invoke \" + m + \" on \" + o + Arrays.toString(arguments), x);",
          "991:                 if (r == null || r instanceof Serializable) {",
          "993:                 } else {",
          "994:                     throw new RemotingSystemException(new ClassCastException(r.getClass() + \" is returned from \" + m",
          "995:                             + \" on \" + o.getClass() + \" but it's not serializable\"));",
          "996:                 }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "938:         private Method choose(Class<?>[] interfaces) {",
          "940:                 OUTER:",
          "941:                 for (Method m : clazz.getMethods()) {",
          "943:                         continue;",
          "944:                     Class<?>[] paramTypes = m.getParameterTypes();",
          "946:                         continue;",
          "947:                     for (int i = 0; i < types.length; i++) {",
          "949:                             continue OUTER;",
          "950:                     }",
          "951:                     return m;",
          "952:                 }",
          "",
          "[Removed Lines]",
          "939:             for(Class<?> clazz: interfaces) {",
          "942:                     if (!m.getName().equals(methodName))",
          "945:                     if (paramTypes.length != arguments.length)",
          "948:                         if (!types[i].equals(paramTypes[i].getName()))",
          "",
          "[Added Lines]",
          "1006:             for (Class<?> clazz : interfaces) {",
          "1009:                     if (!m.getName().equals(methodName)) {",
          "1011:                     }",
          "1013:                     if (paramTypes.length != arguments.length) {",
          "1015:                     }",
          "1017:                         if (!types[i].equals(paramTypes[i].getName())) {",
          "1019:                         }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "961:         @Override",
          "962:         public String toString() {",
          "964:             for (int i = 0; i < types.length; i++) {",
          "965:                 if (i > 0) {",
          "966:                     b.append(',');",
          "",
          "[Removed Lines]",
          "963:             StringBuilder b = new StringBuilder(getClass().getSimpleName()).append(':').append(declaringClassName).append('.').append(methodName).append('[');",
          "",
          "[Added Lines]",
          "1033:             StringBuilder b = new StringBuilder(getClass().getSimpleName())",
          "1034:                     .append(':')",
          "1035:                     .append(declaringClassName)",
          "1036:                     .append('.')",
          "1037:                     .append(methodName)",
          "1038:                     .append('[');",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1002:             if (channel.isClosingOrClosed()) {",
          "1005:             }",
          "1006:         }",
          "1007:     }",
          "",
          "[Removed Lines]",
          "1003:                 throw new ChannelClosedException(channel, \"The request cannot be executed on channel \" + channel + \". \"",
          "1004:                         + \"The channel is closing down or has closed down\", channel.getCloseRequestCause());",
          "",
          "[Added Lines]",
          "1078:                 throw new ChannelClosedException(",
          "1079:                         channel,",
          "1080:                         \"The request cannot be executed on channel \" + channel + \". \"",
          "1081:                                 + \"The channel is closing down or has closed down\",",
          "1082:                         channel.getCloseRequestCause());",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteOutputStream.java||src/main/java/hudson/remoting/RemoteOutputStream.java": [
          "File: src/main/java/hudson/remoting/RemoteOutputStream.java -> src/main/java/hudson/remoting/RemoteOutputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:     private transient OutputStream core;",
          "76:     public RemoteOutputStream(OutputStream core) {",
          "78:             throw new IllegalArgumentException();",
          "79:         this.core = core;",
          "80:     }",
          "82:     private void writeObject(ObjectOutputStream oos) throws IOException {",
          "84:         oos.writeInt(id);",
          "85:     }",
          "",
          "[Removed Lines]",
          "77:         if(core==null)",
          "83:         int id = getChannelForSerialization().internalExport(OutputStream.class, core, false); // this export is unexported in ProxyOutputStream.finalize()",
          "",
          "[Added Lines]",
          "77:         if (core == null) {",
          "79:         }",
          "84:         int id = getChannelForSerialization()",
          "85:                 .internalExport(",
          "86:                         OutputStream.class, core, false); // this export is unexported in ProxyOutputStream.finalize()",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteWriter.java||src/main/java/hudson/remoting/RemoteWriter.java": [
          "File: src/main/java/hudson/remoting/RemoteWriter.java -> src/main/java/hudson/remoting/RemoteWriter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     }",
          "66:     private void writeObject(ObjectOutputStream oos) throws IOException {",
          "68:         oos.writeInt(id);",
          "69:     }",
          "",
          "[Removed Lines]",
          "67:         int id = getChannelForSerialization().internalExport(Writer.class, core, false);  // this export is unexported in ProxyWriter.finalize()",
          "",
          "[Added Lines]",
          "67:         int id = getChannelForSerialization()",
          "68:                 .internalExport(Writer.class, core, false); // this export is unexported in ProxyWriter.finalize()",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Request.java||src/main/java/hudson/remoting/Request.java": [
          "File: src/main/java/hudson/remoting/Request.java -> src/main/java/hudson/remoting/Request.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "50: public abstract class Request<RSP extends Serializable,EXC extends Throwable> extends Command {",
          "",
          "[Added Lines]",
          "50: public abstract class Request<RSP extends Serializable, EXC extends Throwable> extends Command {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     private int lastIoId;",
          "84:     transient long startTime;",
          "",
          "[Removed Lines]",
          "82:     private volatile Response<RSP,? extends Throwable> response;",
          "89:     volatile transient Future<?> future;",
          "",
          "[Added Lines]",
          "82:     private volatile Response<RSP, ? extends Throwable> response;",
          "89:     transient volatile Future<?> future;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:     @Deprecated",
          "106:     Request() {",
          "107:         this(true);",
          "108:     }",
          "111:     Request(boolean recordCreatedAt) {",
          "112:         super(recordCreatedAt);",
          "114:             id = nextId++;",
          "115:         }",
          "116:     }",
          "",
          "[Removed Lines]",
          "110:     @SuppressFBWarnings(value=\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\", justification=\"That is why we synchronize on the class.\")",
          "113:         synchronized(Request.class) {",
          "",
          "[Added Lines]",
          "110:     @SuppressFBWarnings(",
          "111:             value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\",",
          "112:             justification = \"That is why we synchronize on the class.\")",
          "115:         synchronized (Request.class) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "151:         String name = t.getName();",
          "152:         try {",
          "153:             t.setName(name + \" / waiting for \" + channel.getName() + \" id=\" + id);",
          "167:             }",
          "180:                         throw new RequestAbortedException(null);",
          "183:                     try {",
          "185:                     } catch (ExecutionException e) {",
          "187:                     }",
          "200:                 }",
          "210:             }",
          "213:         } finally {",
          "214:             t.setName(name);",
          "215:         }",
          "",
          "[Removed Lines]",
          "154:         checkIfCanBeExecutedOnChannel(channel);",
          "155:         lastIoId = channel.lastIoId();",
          "160:         synchronized(channel) {",
          "161:             synchronized(this) {",
          "162:                 response=null;",
          "164:                 channel.pendingCalls.put(id,this);",
          "165:                 startTime = System.nanoTime();",
          "166:                 channel.send(this);",
          "168:         }",
          "170:         try {",
          "171:             synchronized(this) {",
          "172:                     while(response==null && !channel.isInClosed())",
          "176:                         wait(30*1000);",
          "178:                     if (response==null)",
          "182:                 if (lastIo != null)",
          "184:                         lastIo.get();",
          "189:                 try {",
          "190:                     channel.pipeWriter.get(responseIoId).get();",
          "191:                 } catch (ExecutionException e) {",
          "193:                 }",
          "195:                 Throwable exc = response.exception;",
          "197:                 if (exc!=null) {",
          "198:                     channel.attachCallSiteStackTrace(exc);",
          "199:                     throw (EXC)exc; // some versions of JDK fails to compile this line. If so, upgrade your JDK.",
          "202:                 return response.returnValue;",
          "203:             }",
          "204:         } catch (InterruptedException e) {",
          "207:             synchronized (channel) { // ... so that the close check and send won't be interrupted in the middle by a close",
          "208:                 if (!channel.isOutClosed())",
          "209:                     channel.send(new Cancel(id));   // only send a cancel if we can, or else ChannelClosedException will mask the original cause",
          "211:             throw e;",
          "212:         }",
          "",
          "[Added Lines]",
          "156:             checkIfCanBeExecutedOnChannel(channel);",
          "157:             lastIoId = channel.lastIoId();",
          "162:             synchronized (channel) {",
          "163:                 synchronized (this) {",
          "164:                     response = null;",
          "166:                     channel.pendingCalls.put(id, this);",
          "167:                     startTime = System.nanoTime();",
          "168:                     channel.send(this);",
          "169:                 }",
          "172:             try {",
          "173:                 synchronized (this) {",
          "174:                     while (response == null && !channel.isInClosed()) {",
          "179:                         wait(30 * 1000);",
          "180:                     }",
          "182:                     if (response == null) {",
          "185:                     }",
          "187:                     if (lastIo != null) {",
          "188:                         try {",
          "189:                             lastIo.get();",
          "190:                         } catch (ExecutionException e) {",
          "192:                         }",
          "193:                     }",
          "196:                         channel.pipeWriter.get(responseIoId).get();",
          "201:                     Throwable exc = response.exception;",
          "203:                     if (exc != null) {",
          "204:                         channel.attachCallSiteStackTrace(exc);",
          "205:                         throw (EXC) exc; // some versions of JDK fails to compile this line. If so, upgrade your JDK.",
          "206:                     }",
          "208:                     return response.returnValue;",
          "210:             } catch (InterruptedException e) {",
          "214:                 synchronized (",
          "215:                         channel) { // ... so that the close check and send won't be interrupted in the middle by a close",
          "216:                     if (!channel.isOutClosed()) {",
          "217:                         channel.send(new Cancel(",
          "218:                                 id)); // only send a cancel if we can, or else ChannelClosedException will mask the",
          "220:                     }",
          "221:                 }",
          "222:                 throw e;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "229:     final hudson.remoting.Future<RSP> callAsync(final Channel channel) throws IOException {",
          "230:         checkIfCanBeExecutedOnChannel(channel);",
          "233:         lastIoId = channel.lastIoId();",
          "236:         startTime = System.nanoTime();",
          "237:         channel.send(this);",
          "",
          "[Removed Lines]",
          "232:         response=null;",
          "235:         channel.pendingCalls.put(id,this);",
          "",
          "[Added Lines]",
          "243:         response = null;",
          "246:         channel.pendingCalls.put(id, this);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "301:             }",
          "303:             @Override",
          "305:                 synchronized (Request.this) {",
          "",
          "[Removed Lines]",
          "304:             public RSP get(long timeout, @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "[Added Lines]",
          "315:             public RSP get(long timeout, @NonNull TimeUnit unit)",
          "316:                     throws InterruptedException, ExecutionException, TimeoutException {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "317:                         Request.this.wait(Math.min(30 * 1000, Math.max(1, TimeUnit.NANOSECONDS.toMillis(end - now))));",
          "318:                         now = System.nanoTime();",
          "319:                     }",
          "321:                         throw new TimeoutException();",
          "324:                         throw new ExecutionException(response.exception);",
          "326:                     return response.returnValue;",
          "327:                 }",
          "",
          "[Removed Lines]",
          "320:                     if (response == null)",
          "323:                     if (response.exception != null)",
          "",
          "[Added Lines]",
          "332:                     if (response == null) {",
          "334:                     }",
          "336:                     if (response.exception != null) {",
          "338:                     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "351:     @Override",
          "352:     final void execute(final Channel channel) {",
          "354:         future = channel.executor.submit(new Runnable() {",
          "356:             private int startIoId;",
          "358:             private int calcLastIoId() {",
          "359:                 int endIoId = channel.lastIoId();",
          "361:                 return endIoId;",
          "362:             }",
          "364:             @Override",
          "365:             public void run() {",
          "366:                 String oldThreadName = Thread.currentThread().getName();",
          "368:                 try {",
          "369:                     Command rsp;",
          "370:                     CURRENT.set(Request.this);",
          "",
          "[Removed Lines]",
          "353:         channel.executingCalls.put(id,this);",
          "360:                 if (startIoId==endIoId) return 0;",
          "367:                 Thread.currentThread().setName(oldThreadName+\" for \"+channel.getName()+\" id=\"+id);",
          "",
          "[Added Lines]",
          "366:         channel.executingCalls.put(id, this);",
          "373:                 if (startIoId == endIoId) {",
          "374:                     return 0;",
          "375:                 }",
          "382:                 Thread.currentThread().setName(oldThreadName + \" for \" + channel.getName() + \" id=\" + id);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "382:                     } finally {",
          "383:                         CURRENT.remove();",
          "384:                     }",
          "386:                         rsp.chainCause(createdAt);",
          "387:                     }",
          "",
          "[Removed Lines]",
          "385:                     if(chainCause) {",
          "",
          "[Added Lines]",
          "400:                     if (chainCause) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "395:                         logger.info(() -> \"Failed to send back a reply to the request \" + Request.this + \": \" + e);",
          "396:                     } else {",
          "398:                     }",
          "399:                 } finally {",
          "400:                     channel.executingCalls.remove(id);",
          "",
          "[Removed Lines]",
          "397:                         logger.log(Level.WARNING, e, () -> \"Failed to send back a reply to the request \" + Request.this);",
          "",
          "[Added Lines]",
          "412:                         logger.log(",
          "413:                                 Level.WARNING, e, () -> \"Failed to send back a reply to the request \" + Request.this);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "412:     private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "410:     private static int nextId=0;",
          "",
          "[Added Lines]",
          "426:     private static int nextId = 0;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "420:     static boolean chainCause = Boolean.getBoolean(Request.class.getName()+\".chainCause\");",
          "",
          "[Added Lines]",
          "436:     static boolean chainCause = Boolean.getBoolean(Request.class.getName() + \".chainCause\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "433:         Request<?, ?> r = CURRENT.get();",
          "435:     }",
          "",
          "[Removed Lines]",
          "434:         return r!=null ? r.id : 0;",
          "",
          "[Added Lines]",
          "450:         return r != null ? r.id : 0;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "447:         @Override",
          "448:         protected void execute(Channel channel) {",
          "451:             Future<?> f = r.future;",
          "453:         }",
          "455:         @Override",
          "",
          "[Removed Lines]",
          "449:             Request<?,?> r = channel.executingCalls.get(id);",
          "450:             if(r==null)     return; // already completed",
          "452:             if(f!=null)     f.cancel(true);",
          "",
          "[Added Lines]",
          "465:             Request<?, ?> r = channel.executingCalls.get(id);",
          "466:             if (r == null) {",
          "467:                 return; // already completed",
          "468:             }",
          "470:             if (f != null) {",
          "471:                 f.cancel(true);",
          "472:             }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RequestAbortedException.java||src/main/java/hudson/remoting/RequestAbortedException.java": [
          "File: src/main/java/hudson/remoting/RequestAbortedException.java -> src/main/java/hudson/remoting/RequestAbortedException.java"
        ],
        "src/main/java/hudson/remoting/ResourceImageBoth.java||src/main/java/hudson/remoting/ResourceImageBoth.java": [
          "File: src/main/java/hudson/remoting/ResourceImageBoth.java -> src/main/java/hudson/remoting/ResourceImageBoth.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: class ResourceImageBoth extends ResourceImageDirect {",
          "16:     public ResourceImageBoth(URL resource, Checksum sum) throws IOException {",
          "17:         super(resource);",
          "",
          "[Removed Lines]",
          "14:     final long sum1,sum2;",
          "",
          "[Added Lines]",
          "14:     final long sum1, sum2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:     @Override",
          "29:     Future<URLish> resolveURL(Channel channel, String resourcePath) throws IOException, InterruptedException {",
          "30:         Future<URL> f = initiateJarRetrieval(channel);",
          "34:             return super.resolveURL(channel, resourcePath);",
          "35:     }",
          "",
          "[Removed Lines]",
          "31:         if (f.isDone()) // prefer using the jar URL if the stuff is already available",
          "32:             return new ResourceImageInJar(sum1,sum2,null).resolveURL(channel,resourcePath);",
          "33:         else",
          "",
          "[Added Lines]",
          "31:         if (f.isDone()) { // prefer using the jar URL if the stuff is already available",
          "32:             return new ResourceImageInJar(sum1, sum2, null).resolveURL(channel, resourcePath);",
          "33:         } else {",
          "35:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "44:     private Future<URL> initiateJarRetrieval(@NonNull Channel channel) throws IOException, InterruptedException {",
          "45:         JarCache c = channel.getJarCache();",
          "46:         if (c == null) {",
          "48:         }",
          "50:         try {",
          "",
          "[Removed Lines]",
          "47:             throw new IOException(\"Failed to initiate retrieval. JAR Cache is disabled for the channel \" + channel.getName());",
          "",
          "[Added Lines]",
          "48:             throw new IOException(",
          "49:                     \"Failed to initiate retrieval. JAR Cache is disabled for the channel \" + channel.getName());",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ResourceImageDirect.java||src/main/java/hudson/remoting/ResourceImageDirect.java": [
          "File: src/main/java/hudson/remoting/ResourceImageDirect.java -> src/main/java/hudson/remoting/ResourceImageDirect.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: class ResourceImageDirect extends ResourceImageRef {",
          "",
          "[Removed Lines]",
          "20: @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Used by the agent as part of jar cache management.\")",
          "",
          "[Added Lines]",
          "19: @SuppressFBWarnings(",
          "20:         value = \"URLCONNECTION_SSRF_FD\",",
          "21:         justification = \"Used by the agent as part of jar cache management.\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:     @Override",
          "36:     Future<byte[]> resolve(Channel channel, String resourcePath) throws IOException, InterruptedException {",
          "38:         return CompletableFuture.completedFuture(payload);",
          "39:     }",
          "",
          "[Removed Lines]",
          "37:         LOGGER.log(Level.FINE, resourcePath+\" image is direct\");",
          "",
          "[Added Lines]",
          "38:         LOGGER.log(Level.FINE, resourcePath + \" image is direct\");",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ResourceImageInJar.java||src/main/java/hudson/remoting/ResourceImageInJar.java": [
          "File: src/main/java/hudson/remoting/ResourceImageInJar.java -> src/main/java/hudson/remoting/ResourceImageInJar.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "26:     final long sum1,sum2;",
          "",
          "[Added Lines]",
          "26:     final long sum1, sum2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:     }",
          "41:     ResourceImageInJar(Checksum sum, String path) {",
          "43:     }",
          "45:     @Override",
          "",
          "[Removed Lines]",
          "42:         this(sum.sum1,sum.sum2,path);",
          "",
          "[Added Lines]",
          "42:         this(sum.sum1, sum.sum2, path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "47:         return _resolveJarURL(channel).thenApply(jar -> readContents(jar, resourcePath));",
          "48:     }",
          "51:     private byte[] readContents(URL jar, String resourcePath) {",
          "52:         try (InputStream in = toResourceURL(jar, resourcePath).openStream()) {",
          "53:             return Util.readFully(in);",
          "",
          "[Removed Lines]",
          "50:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "[Added Lines]",
          "50:     @SuppressFBWarnings(",
          "51:             value = \"URLCONNECTION_SSRF_FD\",",
          "52:             justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "72:     @NonNull",
          "73:     private URL toResourceURL(URL jar, String resourcePath) throws IOException {",
          "75:             resourcePath = path;",
          "84:     }",
          "86:     CompletableFuture<URL> _resolveJarURL(Channel channel) throws IOException, InterruptedException {",
          "87:         JarCache c = channel.getJarCache();",
          "88:         if (c == null) {",
          "90:                     sum1, sum2, channel.getName()));",
          "91:         }",
          "93:         return c.resolve(channel, sum1, sum2);",
          "95:     }",
          "97:     private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "74:         if (path!=null)",
          "77:             James Nord & Kohsuke:",
          "78:                 Note that when we open a stream from this jar:// URL, it internally caches",
          "79:                 open jar file (see sun.net.www.protocol.jar.JarURLConnection.JarURLInputStream.close())",
          "80:                 and leave it open. During unit test, this pins the file, and it prevents the test tear down code",
          "81:                 from deleting the file.",
          "83:         return new URL(\"jar:\"+ jar +\"!/\"+resourcePath);",
          "89:             throw new IOException(String.format(\"Failed to resolve a jar %016x%016x. JAR Cache is disabled for the channel %s\",",
          "",
          "[Added Lines]",
          "76:         if (path != null) {",
          "78:         }",
          "80:            James Nord & Kohsuke:",
          "81:                Note that when we open a stream from this jar:// URL, it internally caches",
          "82:                open jar file (see sun.net.www.protocol.jar.JarURLConnection.JarURLInputStream.close())",
          "83:                and leave it open. During unit test, this pins the file, and it prevents the test tear down code",
          "84:                from deleting the file.",
          "86:         return new URL(\"jar:\" + jar + \"!/\" + resourcePath);",
          "92:             throw new IOException(String.format(",
          "93:                     \"Failed to resolve a jar %016x%016x. JAR Cache is disabled for the channel %s\",",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/ResourceImageRef.java||src/main/java/hudson/remoting/ResourceImageRef.java": [
          "File: src/main/java/hudson/remoting/ResourceImageRef.java -> src/main/java/hudson/remoting/ResourceImageRef.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:     private static final long serialVersionUID = 1L;",
          "47: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38:             throws IOException, InterruptedException;",
          "46:             throws IOException, InterruptedException;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Response.java||src/main/java/hudson/remoting/Response.java": [
          "File: src/main/java/hudson/remoting/Response.java -> src/main/java/hudson/remoting/Response.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "40: public final class Response<RSP extends Serializable,EXC extends Throwable> extends Command {",
          "",
          "[Added Lines]",
          "40: public final class Response<RSP extends Serializable, EXC extends Throwable> extends Command {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:     final RSP returnValue;",
          "58:     final EXC exception;",
          "61:     private transient long totalTime;",
          "63:     private transient Request<RSP, ? extends Throwable> request;",
          "65:     Response(Request<RSP, ? extends Throwable> request, int id, int lastIoId, RSP returnValue) {",
          "",
          "[Removed Lines]",
          "60:     @SuppressFBWarnings(value=\"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification=\"Only supposed to be defined on one side.\")",
          "62:     @SuppressFBWarnings(value=\"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification=\"Bound after deserialization, in execute.\")",
          "",
          "[Added Lines]",
          "60:     @SuppressFBWarnings(",
          "61:             value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\",",
          "62:             justification = \"Only supposed to be defined on one side.\")",
          "65:     @SuppressFBWarnings(",
          "66:             value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\",",
          "67:             justification = \"Bound after deserialization, in execute.\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:     @Override",
          "85:     void execute(Channel channel) {",
          "86:         Request<RSP, ? extends Throwable> req = (Request<RSP, ? extends Throwable>) channel.pendingCalls.get(id);",
          "88:             return; // maybe aborted",
          "89:         req.responseIoId = lastIoId;",
          "91:         req.onCompleted(this);",
          "",
          "[Removed Lines]",
          "87:         if(req==null)",
          "",
          "[Added Lines]",
          "92:         if (req == null) {",
          "94:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102:     @Override",
          "103:     public String toString() {",
          "105:     }",
          "113:         return request;",
          "114:     }",
          "",
          "[Removed Lines]",
          "104:         return \"Response\" + (request != null ? \":\" + request : \"\") + \"(\" + (returnValue != null ? returnValue.getClass().getName() : exception != null ? exception.getClass().getName() : null) + \")\";",
          "111:     public @CheckForNull",
          "112:     Request<?, ?> getRequest() {",
          "",
          "[Added Lines]",
          "110:         return \"Response\" + (request != null ? \":\" + request : \"\") + \"(\"",
          "111:                 + (returnValue != null",
          "112:                         ? returnValue.getClass().getName()",
          "113:                         : exception != null ? exception.getClass().getName() : null)",
          "114:                 + \")\";",
          "121:     public @CheckForNull Request<?, ?> getRequest() {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/SingleLaneExecutorService.java||src/main/java/hudson/remoting/SingleLaneExecutorService.java": [
          "File: src/main/java/hudson/remoting/SingleLaneExecutorService.java -> src/main/java/hudson/remoting/SingleLaneExecutorService.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     @Override",
          "68:     public synchronized void shutdown() {",
          "69:         shuttingDown = true;",
          "71:             shutDown = true;",
          "72:     }",
          "",
          "[Removed Lines]",
          "70:         if (tasks.isEmpty())",
          "",
          "[Added Lines]",
          "70:         if (tasks.isEmpty()) {",
          "72:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     @Override",
          "112:     public synchronized void execute(@NonNull Runnable command) {",
          "113:         if (shuttingDown) {",
          "116:         }",
          "118:         this.tasks.add(command);",
          "121:         if (!scheduled) {",
          "122:             scheduled = true;",
          "",
          "[Removed Lines]",
          "114:             throw new ExecutorServiceUtils.FatalRejectedExecutionException(\"Cannot execute the command \" + command +",
          "115:                     \". The executor service is shutting down\");",
          "",
          "[Added Lines]",
          "115:             throw new ExecutorServiceUtils.FatalRejectedExecutionException(",
          "116:                     \"Cannot execute the command \" + command + \". The executor service is shutting down\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:                 ExecutorServiceUtils.submitAsync(base, runner);",
          "126:             } catch (ExecutorServiceUtils.ExecutionRejectedException ex) {",
          "129:             }",
          "130:         }",
          "131:     }",
          "",
          "[Removed Lines]",
          "128:                 throw new RejectedExecutionException(\"Base executor service \" + base + \" has rejected the task \" + command, ex);",
          "",
          "[Added Lines]",
          "129:                 throw new RejectedExecutionException(",
          "130:                         \"Base executor service \" + base + \" has rejected the task \" + command, ex);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "137:                 tasks.peek().run();",
          "138:             } finally {",
          "139:                 synchronized (SingleLaneExecutorService.this) {",
          "142:                     assert scheduled;",
          "143:                     if (!tasks.isEmpty()) {",
          "",
          "[Removed Lines]",
          "140:                     tasks.remove();// completed. this is needed because shutdown() looks at tasks.isEmpty()",
          "",
          "[Added Lines]",
          "142:                     tasks.remove(); // completed. this is needed because shutdown() looks at tasks.isEmpty()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "156:                         }",
          "157:                     } else {",
          "158:                         scheduled = false;",
          "",
          "[Removed Lines]",
          "152:                             LOGGER.log(Level.SEVERE, String.format(",
          "153:                                     \"Base executor service %s has rejected the queue task %s. Propagating the RuntimeException to the caller.\",",
          "154:                                     ex.getExecutorServiceDisplayName(), ex.getRunnableDisplayName()), ex);",
          "155:                             throw ExecutorServiceUtils.createRuntimeException(\"Base executor service has rejected the task from the queue\", ex);",
          "",
          "[Added Lines]",
          "154:                             LOGGER.log(",
          "155:                                     Level.SEVERE,",
          "156:                                     String.format(",
          "157:                                             \"Base executor service %s has rejected the queue task %s. Propagating the RuntimeException to the caller.\",",
          "158:                                             ex.getExecutorServiceDisplayName(), ex.getRunnableDisplayName()),",
          "159:                                     ex);",
          "160:                             throw ExecutorServiceUtils.createRuntimeException(",
          "161:                                     \"Base executor service has rejected the task from the queue\", ex);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/SocketChannelStream.java||src/main/java/hudson/remoting/SocketChannelStream.java": [
          "File: src/main/java/hudson/remoting/SocketChannelStream.java -> src/main/java/hudson/remoting/SocketChannelStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: public class SocketChannelStream {",
          "23:     public static InputStream in(Socket s) throws IOException {",
          "25:             return in(s.getChannel());",
          "27:             return new SocketInputStream(s);",
          "28:     }",
          "30:     public static InputStream in(final SocketChannel ch) throws IOException {",
          "",
          "[Removed Lines]",
          "24:         if (s.getChannel()!=null)",
          "26:         else",
          "",
          "[Added Lines]",
          "24:         if (s.getChannel() != null) {",
          "26:         } else {",
          "28:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     }",
          "61:     public static OutputStream out(Socket s) throws IOException {",
          "63:             return out(s.getChannel());",
          "65:             return new SocketOutputStream(s);",
          "66:     }",
          "68:     public static OutputStream out(final SocketChannel ch) throws IOException {",
          "",
          "[Removed Lines]",
          "62:         if (s.getChannel()!=null)",
          "64:         else",
          "",
          "[Added Lines]",
          "63:         if (s.getChannel() != null) {",
          "65:         } else {",
          "67:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/SocketInputStream.java||src/main/java/hudson/remoting/SocketInputStream.java": [
          "File: src/main/java/hudson/remoting/SocketInputStream.java -> src/main/java/hudson/remoting/SocketInputStream.java"
        ],
        "src/main/java/hudson/remoting/SocketOutputStream.java||src/main/java/hudson/remoting/SocketOutputStream.java": [
          "File: src/main/java/hudson/remoting/SocketOutputStream.java -> src/main/java/hudson/remoting/SocketOutputStream.java"
        ],
        "src/main/java/hudson/remoting/StandardOutputStream.java||src/main/java/hudson/remoting/StandardOutputStream.java": [
          "File: src/main/java/hudson/remoting/StandardOutputStream.java -> src/main/java/hudson/remoting/StandardOutputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:     public synchronized OutputStream swap(OutputStream another) {",
          "66:             throw new IllegalStateException();",
          "67:         OutputStream old = out;",
          "68:         out = another;",
          "69:         swapped = true;",
          "",
          "[Removed Lines]",
          "65:         if (swapped)",
          "",
          "[Added Lines]",
          "65:         if (swapped) {",
          "67:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/SynchronousCommandTransport.java||src/main/java/hudson/remoting/SynchronousCommandTransport.java": [
          "File: src/main/java/hudson/remoting/SynchronousCommandTransport.java -> src/main/java/hudson/remoting/SynchronousCommandTransport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: public abstract class SynchronousCommandTransport extends CommandTransport {",
          "19:     protected Channel channel;",
          "22:             SynchronousCommandTransport.class.getName() + \".failOnSocketTimeoutInReader\";",
          "29:     private static boolean RDR_FAIL_ON_SOCKET_TIMEOUT = Boolean.getBoolean(RDR_SOCKET_TIMEOUT_PROPERTY_NAME);",
          "",
          "[Removed Lines]",
          "21:     private static final String RDR_SOCKET_TIMEOUT_PROPERTY_NAME =",
          "",
          "[Added Lines]",
          "21:     private static final String RDR_SOCKET_TIMEOUT_PROPERTY_NAME =",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:         private final CommandReceiver receiver;",
          "45:         public ReaderThread(CommandReceiver receiver) {",
          "47:             this.receiver = receiver;",
          "48:             setUncaughtExceptionHandler((t, e) -> {",
          "50:                 channel.terminate(new IOException(\"Unexpected reader termination\", e));",
          "51:             });",
          "52:         }",
          "54:         @Override",
          "55:         public void run() {",
          "57:             try {",
          "58:                 while (!channel.isInClosed()) {",
          "59:                     Command cmd;",
          "",
          "[Removed Lines]",
          "46:             super(\"Channel reader thread: \"+channel.getName());",
          "49:                 LOGGER.log(Level.SEVERE, e, () -> \"Uncaught exception in SynchronousCommandTransport.ReaderThread \" + t);",
          "56:             final String name =channel.getName();",
          "",
          "[Added Lines]",
          "46:             super(\"Channel reader thread: \" + channel.getName());",
          "49:                 LOGGER.log(",
          "50:                         Level.SEVERE, e, () -> \"Uncaught exception in SynchronousCommandTransport.ReaderThread \" + t);",
          "57:             final String name = channel.getName();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:                         cmd = read();",
          "62:                     } catch (SocketTimeoutException ex) {",
          "63:                         if (RDR_FAIL_ON_SOCKET_TIMEOUT) {",
          "67:                             throw ex;",
          "68:                         }",
          "",
          "[Removed Lines]",
          "64:                             LOGGER.log(Level.SEVERE, ex, () -> \"Socket timeout in the Synchronous channel reader.\"",
          "65:                                     + \" The channel will be interrupted, because \" + RDR_SOCKET_TIMEOUT_PROPERTY_NAME",
          "66:                                     + \" is set\");",
          "",
          "[Added Lines]",
          "65:                             LOGGER.log(",
          "66:                                     Level.SEVERE,",
          "67:                                     ex,",
          "68:                                     () -> \"Socket timeout in the Synchronous channel reader.\"",
          "69:                                             + \" The channel will be interrupted, because \"",
          "70:                                             + RDR_SOCKET_TIMEOUT_PROPERTY_NAME",
          "71:                                             + \" is set\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82:                 }",
          "83:                 closeRead();",
          "84:             } catch (InterruptedException e) {",
          "86:                 Thread.currentThread().interrupt();",
          "87:                 channel.terminate((InterruptedIOException) new InterruptedIOException().initCause(e));",
          "88:             } catch (IOException e) {",
          "90:                 channel.terminate(e);",
          "91:             } catch (RuntimeException | Error e) {",
          "93:                 channel.terminate(new IOException(\"Unexpected reader termination\", e));",
          "94:                 throw e;",
          "95:             } finally {",
          "",
          "[Removed Lines]",
          "85:                 LOGGER.log(Level.SEVERE, e, () -> \"I/O error in channel \"+name);",
          "89:                 LOGGER.log(Level.INFO, e, () -> \"I/O error in channel \"+name);",
          "92:                 LOGGER.log(Level.SEVERE, e, () -> \"Unexpected error in channel \"+name);",
          "",
          "[Added Lines]",
          "90:                 LOGGER.log(Level.SEVERE, e, () -> \"I/O error in channel \" + name);",
          "94:                 LOGGER.log(Level.INFO, e, () -> \"I/O error in channel \" + name);",
          "97:                 LOGGER.log(Level.SEVERE, e, () -> \"Unexpected error in channel \" + name);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/SynchronousExecutorService.java||src/main/java/hudson/remoting/SynchronousExecutorService.java": [
          "File: src/main/java/hudson/remoting/SynchronousExecutorService.java -> src/main/java/hudson/remoting/SynchronousExecutorService.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:     @Override",
          "37:     public synchronized boolean isTerminated() {",
          "39:     }",
          "41:     @Override",
          "",
          "[Removed Lines]",
          "38:         return shutdown && count==0;",
          "",
          "[Added Lines]",
          "38:         return shutdown && count == 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:         long now = System.nanoTime();",
          "44:         long end = now + unit.toNanos(timeout);",
          "47:             long d = end - now;",
          "49:                 return false;",
          "50:             }",
          "51:             wait(TimeUnit.NANOSECONDS.toMillis(d));",
          "",
          "[Removed Lines]",
          "46:         while (count!=0) {",
          "48:             if (d<=0) {",
          "",
          "[Added Lines]",
          "46:         while (count != 0) {",
          "48:             if (d <= 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57:     @Override",
          "58:     public void execute(@NonNull Runnable command) {",
          "60:             throw new IllegalStateException(\"Already shut down\");",
          "61:         touchCount(1);",
          "62:         try {",
          "63:             command.run();",
          "",
          "[Removed Lines]",
          "59:         if (shutdown)",
          "",
          "[Added Lines]",
          "59:         if (shutdown) {",
          "61:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "69:     private synchronized void touchCount(int diff) {",
          "70:         count += diff;",
          "72:             notifyAll();",
          "73:     }",
          "74: }",
          "",
          "[Removed Lines]",
          "71:         if (count==0)",
          "",
          "[Added Lines]",
          "72:         if (count == 0) {",
          "74:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/TeeOutputStream.java||src/main/java/hudson/remoting/TeeOutputStream.java": [
          "File: src/main/java/hudson/remoting/TeeOutputStream.java -> src/main/java/hudson/remoting/TeeOutputStream.java"
        ],
        "src/main/java/hudson/remoting/URLDeserializationHelper.java||src/main/java/hudson/remoting/URLDeserializationHelper.java": [
          "File: src/main/java/hudson/remoting/URLDeserializationHelper.java -> src/main/java/hudson/remoting/URLDeserializationHelper.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: import java.net.URLStreamHandler;",
          "44: public class URLDeserializationHelper {",
          "46:     @SuppressFBWarnings(value = \"MS_SHOULD_BE_FINAL\", justification = \"Accessible via System Groovy Scripts\")",
          "49:     private static final SafeURLStreamHandler SAFE_HANDLER = new SafeURLStreamHandler();",
          "59:             return url;",
          "60:         }",
          "62:         if (url.getHost() == null || url.getHost().isEmpty()) {",
          "64:             return url;",
          "65:         }",
          "67:         return new URL(null, url.toString(), SAFE_HANDLER);",
          "68:     }",
          "70:     private static class SafeURLStreamHandler extends URLStreamHandler {",
          "71:         @Override",
          "75:             return new URL(u.toString()).openConnection(p);",
          "76:         }",
          "78:         @Override",
          "80:         protected URLConnection openConnection(URL u) throws IOException {",
          "81:             return new URL(u.toString()).openConnection();",
          "82:         }",
          "86:         @Override",
          "87:         protected int hashCode(URL u) {",
          "88:             return u.toExternalForm().hashCode();",
          "89:         }",
          "91:         @Override",
          "92:         protected boolean equals(URL u1, URL u2) {",
          "93:             return u1.toExternalForm().equals(u2.toExternalForm());",
          "",
          "[Removed Lines]",
          "47:     private static boolean AVOID_URL_WRAPPING = Boolean.getBoolean(URLDeserializationHelper.class + \".avoidUrlWrapping\");",
          "55:     public static @NonNull",
          "56:     URL wrapIfRequired(@NonNull URL url) throws IOException {",
          "57:         if(AVOID_URL_WRAPPING){",
          "72:         @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Used for safely handling URLs, not for opening a connection.\")",
          "73:         protected URLConnection openConnection(URL u, Proxy p) throws IOException",
          "74:         {",
          "79:         @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Used for safely handling URLs, not for opening a connection.\")",
          "",
          "[Added Lines]",
          "47:     private static boolean AVOID_URL_WRAPPING =",
          "48:             Boolean.getBoolean(URLDeserializationHelper.class + \".avoidUrlWrapping\");",
          "56:     public static @NonNull URL wrapIfRequired(@NonNull URL url) throws IOException {",
          "57:         if (AVOID_URL_WRAPPING) {",
          "72:         @SuppressFBWarnings(",
          "73:                 value = \"URLCONNECTION_SSRF_FD\",",
          "74:                 justification = \"Used for safely handling URLs, not for opening a connection.\")",
          "75:         protected URLConnection openConnection(URL u, Proxy p) throws IOException {",
          "80:         @SuppressFBWarnings(",
          "81:                 value = \"URLCONNECTION_SSRF_FD\",",
          "82:                 justification = \"Used for safely handling URLs, not for opening a connection.\")",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/URLish.java||src/main/java/hudson/remoting/URLish.java": [
          "File: src/main/java/hudson/remoting/URLish.java -> src/main/java/hudson/remoting/URLish.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:             URL toURL() throws MalformedURLException {",
          "49:                     return f.toURI().toURL();",
          "50:                 return null;",
          "51:             }",
          "52:         };",
          "",
          "[Removed Lines]",
          "48:                 if (f.exists())",
          "",
          "[Added Lines]",
          "48:                 if (f.exists()) {",
          "50:                 }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/UnexportCommand.java||src/main/java/hudson/remoting/UnexportCommand.java": [
          "File: src/main/java/hudson/remoting/UnexportCommand.java -> src/main/java/hudson/remoting/UnexportCommand.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     @Deprecated",
          "44:     public UnexportCommand(int oid) {",
          "46:     }",
          "48:     @Override",
          "49:     protected void execute(Channel channel) {",
          "51:     }",
          "53:     @Override",
          "",
          "[Removed Lines]",
          "45:         this(oid,null);",
          "50:         channel.unexport(oid,createdAt);",
          "",
          "[Added Lines]",
          "45:         this(oid, null);",
          "50:         channel.unexport(oid, createdAt);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/UserRequest.java||src/main/java/hudson/remoting/UserRequest.java": [
          "File: src/main/java/hudson/remoting/UserRequest.java -> src/main/java/hudson/remoting/UserRequest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     private static final Logger LOGGER = Logger.getLogger(UserRequest.class.getName());",
          "54:     private final byte[] request;",
          "56:     @NonNull",
          "58:     private final RemoteClassLoader.IClassLoader classLoaderProxy;",
          "59:     private final String toString;",
          "64:     @SuppressFBWarnings(value = \"SE_TRANSIENT_FIELD_NOT_RESTORED\", justification = \"We're fine with default null\")",
          "",
          "[Removed Lines]",
          "50: final class UserRequest<RSP,EXC extends Throwable> extends Request<UserRequest.ResponseToUserRequest<RSP,EXC>,EXC> {",
          "57:     @SuppressFBWarnings(value = \"SE_BAD_FIELD\", justification = \"RemoteClassLoader.export() always returns a serializable instance, but we cannot check it statically due to the java.lang.reflect.Proxy\")",
          "65:     private transient final ExportTable.ExportList exports;",
          "",
          "[Added Lines]",
          "50: final class UserRequest<RSP, EXC extends Throwable> extends Request<UserRequest.ResponseToUserRequest<RSP, EXC>, EXC> {",
          "57:     @SuppressFBWarnings(",
          "58:             value = \"SE_BAD_FIELD\",",
          "59:             justification =",
          "60:                     \"RemoteClassLoader.export() always returns a serializable instance, but we cannot check it statically due to the java.lang.reflect.Proxy\")",
          "69:     private final transient ExportTable.ExportList exports;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         this.toString = c.toString();",
          "75:         if (local.isClosingOrClosed()) {",
          "76:             Throwable createdAtValue = createdAt;",
          "",
          "[Removed Lines]",
          "73:     public UserRequest(Channel local, Callable<?,EXC> c) throws IOException {",
          "",
          "[Added Lines]",
          "77:     public UserRequest(Channel local, Callable<?, EXC> c) throws IOException {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:                 createdAtValue = new IllegalStateException(\"Command is created for the channel being interrupted\");",
          "80:             }",
          "83:         }",
          "87:         final ClassLoader cl = getClassLoader(c);",
          "88:         if (cl == null) {",
          "91:             throw new IOException(\"Cannot determine classloader for the command \" + toString);",
          "92:         }",
          "",
          "[Removed Lines]",
          "81:             throw new ChannelClosedException(local, \"Cannot create UserRequest for channel \" + local +",
          "82:                     \". The channel is closed or being closed.\", createdAtValue);",
          "",
          "[Added Lines]",
          "85:             throw new ChannelClosedException(",
          "86:                     local,",
          "87:                     \"Cannot create UserRequest for channel \" + local + \". The channel is closed or being closed.\",",
          "88:                     createdAtValue);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "95:         exports = local.startExportRecording();",
          "96:         try {",
          "98:         } finally {",
          "99:             exports.stopRecording();",
          "100:         }",
          "104:         this.classLoaderProxy = RemoteClassLoader.export(cl, local);",
          "105:     }",
          "",
          "[Removed Lines]",
          "97:             request = serialize(c,local);",
          "",
          "[Added Lines]",
          "103:             request = serialize(c, local);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "113:         if (channel.isClosingOrClosed()) {",
          "116:         }",
          "117:     }",
          "",
          "[Removed Lines]",
          "114:             throw new ChannelClosedException(channel, \"The request cannot be executed on channel \" + channel + \". \"",
          "115:                     + \"The channel is closing down or has closed down\", channel.getCloseRequestCause());",
          "",
          "[Added Lines]",
          "121:             throw new ChannelClosedException(",
          "122:                     channel,",
          "123:                     \"The request cannot be executed on channel \" + channel + \". \"",
          "124:                             + \"The channel is closing down or has closed down\",",
          "125:                     channel.getCloseRequestCause());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "127:     @CheckForNull",
          "129:         ClassLoader result = null;",
          "132:         }",
          "133:         if (result == null) {",
          "134:             result = c.getClass().getClassLoader();",
          "",
          "[Removed Lines]",
          "130:         if(c instanceof DelegatingCallable) {",
          "131:             result =((DelegatingCallable<?, ?>)c).getClassLoader();",
          "",
          "[Added Lines]",
          "140:         if (c instanceof DelegatingCallable) {",
          "141:             result = ((DelegatingCallable<?, ?>) c).getClassLoader();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "142:     }",
          "144:     private static boolean workaroundDone = false;",
          "145:     @Override",
          "147:         try {",
          "148:             ClassLoader cl = channel.importedClassLoaders.get(classLoaderProxy);",
          "",
          "[Removed Lines]",
          "146:     protected ResponseToUserRequest<RSP,EXC> perform(Channel channel) throws EXC {",
          "",
          "[Added Lines]",
          "157:     protected ResponseToUserRequest<RSP, EXC> perform(Channel channel) throws EXC {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "154:             final String clazz = System.getProperty(RemoteClassLoader.class.getName() + \".force\", null);",
          "157:                 String eventMsg = \"Loaded\";",
          "158:                 Level logLevel = Level.INFO;",
          "164:                     workaroundDone = true;",
          "165:                     try {",
          "166:                         Class.forName(clazz, true, cl);",
          "",
          "[Removed Lines]",
          "155:             if ( clazz != null && !workaroundDone) {",
          "162:                 synchronized(Object.class)",
          "163:                 {",
          "",
          "[Added Lines]",
          "166:             if (clazz != null && !workaroundDone) {",
          "173:                 synchronized (Object.class) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "171:                     }",
          "172:                 }",
          "173:                 final Logger logger = Logger.getLogger(RemoteClassLoader.class.getName());",
          "177:                 }",
          "178:             }",
          "",
          "[Removed Lines]",
          "174:                 if( logger.isLoggable(logLevel) )",
          "175:                 {",
          "176:                     logger.log(logLevel, \"{0} class ''{1}'' using classloader: {2}\", new Object[]{ eventMsg, clazz, cl.toString()} );",
          "",
          "[Added Lines]",
          "184:                 if (logger.isLoggable(logLevel)) {",
          "185:                     logger.log(logLevel, \"{0} class ''{1}'' using classloader: {2}\", new Object[] {",
          "186:                         eventMsg, clazz, cl.toString()",
          "187:                     });",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "182:             try {",
          "183:                 Object o;",
          "184:                 try {",
          "186:                 } catch (ClassNotFoundException e) {",
          "188:                 } catch (RuntimeException e) {",
          "192:                 }",
          "201:                 callable = channel.decorators.wrapUserRequest(callable);",
          "",
          "[Removed Lines]",
          "185:                     o = deserialize(channel,request,cl);",
          "187:                     throw new ClassNotFoundException(\"Failed to deserialize the Callable object. Perhaps you needed to implement DelegatingCallable?\", e);",
          "191:                     throw new Error(\"Failed to deserialize the Callable object.\",e);",
          "194:                 Callable<RSP,EXC> callable = (Callable<RSP,EXC>)o;",
          "195:                 if(!channel.isArbitraryCallableAllowed() && !(callable instanceof RemoteInvocationHandler.RPCRequest))",
          "199:                     throw new SecurityException(\"Execution of \"+callable.toString()+\" is prohibited because the channel is restricted\");",
          "",
          "[Added Lines]",
          "196:                     o = deserialize(channel, request, cl);",
          "198:                     throw new ClassNotFoundException(",
          "199:                             \"Failed to deserialize the Callable object. Perhaps you needed to implement DelegatingCallable?\",",
          "200:                             e);",
          "204:                     throw new Error(\"Failed to deserialize the Callable object.\", e);",
          "207:                 Callable<RSP, EXC> callable = (Callable<RSP, EXC>) o;",
          "208:                 if (!channel.isArbitraryCallableAllowed()",
          "209:                         && !(callable instanceof RemoteInvocationHandler.RPCRequest)) {",
          "215:                     throw new SecurityException(",
          "216:                             \"Execution of \" + callable.toString() + \" is prohibited because the channel is restricted\");",
          "217:                 }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "209:                     Thread.currentThread().setContextClassLoader(old);",
          "210:                 }",
          "211:             } catch (LinkageError e) {",
          "213:                 throw e;",
          "214:             } finally {",
          "215:                 Channel.setCurrent(oldc);",
          "216:             }",
          "220:         } catch (Throwable e) {",
          "222:             try {",
          "",
          "[Removed Lines]",
          "212:                 LOGGER.log(channel.isClosingOrClosed() ? Level.FINE : Level.WARNING, \"LinkageError while performing \" + this, e);",
          "218:             byte[] response = serialize(r,channel);",
          "219:             return channel.remoteCapability.supportsProxyExceptionFallback() ? new NormalResponse<>(response) : new UserResponse<>(response,false);",
          "",
          "[Added Lines]",
          "230:                 LOGGER.log(",
          "231:                         channel.isClosingOrClosed() ? Level.FINE : Level.WARNING,",
          "232:                         \"LinkageError while performing \" + this,",
          "233:                         e);",
          "239:             byte[] response = serialize(r, channel);",
          "240:             return channel.remoteCapability.supportsProxyExceptionFallback()",
          "241:                     ? new NormalResponse<>(response)",
          "242:                     : new UserResponse<>(response, false);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "241:                 return new UserResponse<>(response, true);",
          "242:             } catch (IOException x) {",
          "245:             }",
          "246:         }",
          "247:     }",
          "",
          "[Removed Lines]",
          "244:                 throw (EXC)x;",
          "",
          "[Added Lines]",
          "267:                 throw (EXC) x;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "251:         try {",
          "252:             ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "253:             ObjectOutputStream oos;",
          "257:                 oos = AnonymousClassWarnings.checkingObjectOutputStream(baos);",
          "259:             oos.writeObject(o);",
          "260:             return baos.toByteArray();",
          "",
          "[Removed Lines]",
          "254:             if (channel.remoteCapability.supportsMultiClassLoaderRPC())",
          "255:                 oos = new MultiClassLoaderSerializer.Output(channel,baos);",
          "256:             else",
          "",
          "[Added Lines]",
          "277:             if (channel.remoteCapability.supportsMultiClassLoaderRPC()) {",
          "278:                 oos = new MultiClassLoaderSerializer.Output(channel, baos);",
          "279:             } else {",
          "281:             }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "266:     private byte[] serialize(Object o, Channel localChannel) throws IOException {",
          "267:         try {",
          "270:             throw new IOException(\"Unable to serialize \" + o, e);",
          "271:         }",
          "272:     }",
          "276:         ByteArrayInputStream in = new ByteArrayInputStream(data);",
          "278:         ObjectInputStream ois;",
          "",
          "[Removed Lines]",
          "268:             return _serialize(o,localChannel);",
          "269:         } catch( NotSerializableException e ) {",
          "274:     @SuppressFBWarnings(value = \"OBJECT_DESERIALIZATION\", justification = \"Used for sending user requests between authorized agent and server.\")",
          "",
          "[Added Lines]",
          "292:             return _serialize(o, localChannel);",
          "293:         } catch (NotSerializableException e) {",
          "298:     @SuppressFBWarnings(",
          "299:             value = \"OBJECT_DESERIALIZATION\",",
          "300:             justification = \"Used for sending user requests between authorized agent and server.\")",
          "302:             throws IOException, ClassNotFoundException {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "296:     @Override",
          "297:     public String toString() {",
          "299:     }",
          "301:     private static final long serialVersionUID = 1L;",
          "",
          "[Removed Lines]",
          "298:         return \"UserRequest:\"+toString;",
          "303:     interface ResponseToUserRequest<RSP,EXC extends Throwable> extends Serializable {",
          "",
          "[Added Lines]",
          "325:         return \"UserRequest:\" + toString;",
          "330:     interface ResponseToUserRequest<RSP, EXC extends Throwable> extends Serializable {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "325:         }",
          "326:     }",
          "329:         private static final long serialVersionUID = 1L;",
          "330:         private @CheckForNull final byte[] rawResponse;",
          "331:         private final byte[] proxyResponse;",
          "332:         ExceptionResponse(@CheckForNull byte[] rawResponse, byte[] proxyResponse) {",
          "333:             this.rawResponse = rawResponse;",
          "334:             this.proxyResponse = proxyResponse;",
          "335:         }",
          "336:         @SuppressWarnings(\"unchecked\")",
          "337:         @Override",
          "338:         public RSP retrieve(Channel channel, ClassLoader cl) throws IOException, ClassNotFoundException, EXC {",
          "",
          "[Removed Lines]",
          "328:     private static final class ExceptionResponse<RSP, EXC extends Throwable> implements ResponseToUserRequest<RSP, EXC> {",
          "",
          "[Added Lines]",
          "357:     private static final class ExceptionResponse<RSP, EXC extends Throwable>",
          "358:             implements ResponseToUserRequest<RSP, EXC> {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "356:             }",
          "357:         }",
          "358:     }",
          "360: }",
          "365: @Deprecated",
          "367:     private final byte[] response;",
          "368:     private final boolean isException;",
          "",
          "[Removed Lines]",
          "366: final class UserResponse<RSP,EXC extends Throwable> implements UserRequest.ResponseToUserRequest<RSP, EXC> {",
          "",
          "[Added Lines]",
          "397: final class UserResponse<RSP, EXC extends Throwable> implements UserRequest.ResponseToUserRequest<RSP, EXC> {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "379:     public RSP retrieve(Channel channel, ClassLoader cl) throws IOException, ClassNotFoundException, EXC {",
          "380:         Channel old = Channel.setCurrent(channel);",
          "381:         try {",
          "386:                 throw (EXC) o;",
          "388:                 return (RSP) o;",
          "389:         } finally {",
          "390:             Channel.setCurrent(old);",
          "391:         }",
          "",
          "[Removed Lines]",
          "382:             Object o = UserRequest.deserialize(channel,response,cl);",
          "384:             if(isException) {",
          "385:                 channel.attachCallSiteStackTrace((Throwable)o);",
          "387:             } else",
          "",
          "[Added Lines]",
          "413:             Object o = UserRequest.deserialize(channel, response, cl);",
          "415:             if (isException) {",
          "416:                 channel.attachCallSiteStackTrace((Throwable) o);",
          "418:             } else {",
          "420:             }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Util.java||src/main/java/hudson/remoting/Util.java": [
          "File: src/main/java/hudson/remoting/Util.java -> src/main/java/hudson/remoting/Util.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:     static String getBaseName(String path) {",
          "38:     }",
          "40:     static byte[] readFully(InputStream in) throws IOException {",
          "42:         ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "44:         return baos.toByteArray();",
          "45:     }",
          "",
          "[Removed Lines]",
          "37:         return path.substring(path.lastIndexOf('/')+1);",
          "43:         copy(in,baos);",
          "",
          "[Added Lines]",
          "37:         return path.substring(path.lastIndexOf('/') + 1);",
          "43:         copy(in, baos);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:     }",
          "57:     @NonNull",
          "59:     static File makeResource(String name, byte[] image) throws IOException {",
          "60:         Path tmpDir = Files.createTempDirectory(\"resource-\");",
          "61:         File resource = new File(tmpDir.toFile(), name);",
          "62:         Files.createDirectories(PathUtils.fileToPath(resource.getParentFile()));",
          "63:         Files.createFile(PathUtils.fileToPath(resource));",
          "66:             fos.write(image);",
          "67:         }",
          "",
          "[Removed Lines]",
          "58:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"This path exists within a temp directory so the potential traversal is limited.\")",
          "65:         try(FileOutputStream fos = new FileOutputStream(resource)) {",
          "",
          "[Added Lines]",
          "58:     @SuppressFBWarnings(",
          "59:             value = \"PATH_TRAVERSAL_IN\",",
          "60:             justification = \"This path exists within a temp directory so the potential traversal is limited.\")",
          "67:         try (FileOutputStream fos = new FileOutputStream(resource)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:         if (dir.isDirectory()) {",
          "86:             File[] childFiles = dir.listFiles();",
          "87:             if (childFiles != null) { // listFiles may return null if there's an IO error",
          "89:             }",
          "90:         }",
          "91:     }",
          "",
          "[Removed Lines]",
          "88:                 for (File f: childFiles) { deleteDirectoryOnExit(f); }",
          "",
          "[Added Lines]",
          "90:                 for (File f : childFiles) {",
          "91:                     deleteDirectoryOnExit(f);",
          "92:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "94:         return \"    \" + s.trim().replace(\"\\n\", \"\\n    \");",
          "95:     }",
          "98:         String version = \"unknown\";",
          "99:         try {",
          "101:             while (resEnum.hasMoreElements()) {",
          "102:                 URL url = resEnum.nextElement();",
          "104:                     if (is != null) {",
          "105:                         Manifest manifest = new Manifest(is);",
          "106:                         version = manifest.getMainAttributes().getValue(\"Version\");",
          "108:                             break;",
          "109:                         }",
          "110:                     }",
          "",
          "[Removed Lines]",
          "97:     static public String getVersion() {",
          "100:             Enumeration<URL> resEnum = Thread.currentThread().getContextClassLoader().getResources(JarFile.MANIFEST_NAME);",
          "103:                 try(InputStream is = url.openStream()) {",
          "107:                         if(version != null) {",
          "",
          "[Added Lines]",
          "101:     public static String getVersion() {",
          "104:             Enumeration<URL> resEnum =",
          "105:                     Thread.currentThread().getContextClassLoader().getResources(JarFile.MANIFEST_NAME);",
          "108:                 try (InputStream is = url.openStream()) {",
          "112:                         if (version != null) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "123:         return Duration.between(firstAttempt, Instant.now()).compareTo(noReconnectAfter) > 0;",
          "124:     }",
          "129: }",
          "",
          "[Removed Lines]",
          "126:     private Util() {",
          "127:     }",
          "",
          "[Added Lines]",
          "131:     private Util() {}",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/VirtualChannel.java||src/main/java/hudson/remoting/VirtualChannel.java": [
          "File: src/main/java/hudson/remoting/VirtualChannel.java -> src/main/java/hudson/remoting/VirtualChannel.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "52:     <V,T extends Throwable>",
          "53:     V call(Callable<V,T> callable) throws IOException, T, InterruptedException;",
          "",
          "[Added Lines]",
          "52:     <V, T extends Throwable> V call(Callable<V, T> callable) throws IOException, T, InterruptedException;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "70:     <V,T extends Throwable>",
          "71:     Future<V> callAsync(final Callable<V,T> callable) throws IOException;",
          "",
          "[Added Lines]",
          "69:     <V, T extends Throwable> Future<V> callAsync(final Callable<V, T> callable) throws IOException;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/Which.java||src/main/java/hudson/remoting/Which.java": [
          "File: src/main/java/hudson/remoting/Which.java -> src/main/java/hudson/remoting/Which.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: public class Which {",
          "",
          "[Removed Lines]",
          "49: @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"Managed by the jar cache mechanism, using server data.\")",
          "",
          "[Added Lines]",
          "49: @SuppressFBWarnings(",
          "50:         value = \"PATH_TRAVERSAL_IN\",",
          "51:         justification = \"Managed by the jar cache mechanism, using server data.\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:     @NonNull",
          "61:     public static URL classFileUrl(Class<?> clazz) throws IOException {",
          "62:         ClassLoader cl = clazz.getClassLoader();",
          "64:             cl = ClassLoader.getSystemClassLoader();",
          "65:         URL res = cl.getResource(clazz.getName().replace('.', '/') + \".class\");",
          "68:         return res;",
          "69:     }",
          "",
          "[Removed Lines]",
          "63:         if(cl==null)",
          "66:         if(res==null)",
          "67:             throw new IllegalArgumentException(\"Unable to locate class file for \"+clazz);",
          "",
          "[Added Lines]",
          "65:         if (cl == null) {",
          "67:         }",
          "69:         if (res == null) {",
          "70:             throw new IllegalArgumentException(\"Unable to locate class file for \" + clazz);",
          "71:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:     @NonNull",
          "93:     public static File jarFile(Class<?> clazz) throws IOException {",
          "95:     }",
          "",
          "[Removed Lines]",
          "94:         return jarFile(classFileUrl(clazz),clazz.getName().replace('.','/')+\".class\");",
          "",
          "[Added Lines]",
          "98:         return jarFile(classFileUrl(clazz), clazz.getName().replace('.', '/') + \".class\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:     @NonNull",
          "116:         String resURL = res.toExternalForm();",
          "117:         String originalURL = resURL;",
          "119:             return fromJarUrlToFile(resURL);",
          "125:         }",
          "132:         }",
          "136:             int n = qualifiedName.split(\"/\").length; // how many slashes do wo need to cut?",
          "138:                 int idx = Math.max(resURL.lastIndexOf('/'), resURL.lastIndexOf('\\\\'));",
          "141:             }",
          "",
          "[Removed Lines]",
          "114:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Used by the agent as part of jar cache management.\")",
          "118:         if(resURL.startsWith(\"jar:file:\") || resURL.startsWith(\"wsjar:file:\"))",
          "121:         if(resURL.startsWith(\"code-source:/\")) {",
          "123:             resURL = resURL.substring(\"code-source:/\".length(), resURL.lastIndexOf('!')); // cut off jar: and the file name portion",
          "124:             return new File(decode(new URL(\"file:/\"+resURL).getPath()));",
          "127:         if(resURL.startsWith(\"zip:\")){",
          "130:             resURL = resURL.substring(\"zip:\".length(), resURL.lastIndexOf('!')); // cut off zip: and the file name portion",
          "131:             return new File(decode(new URL(\"file:\"+resURL).getPath()));",
          "134:         if(resURL.startsWith(\"file:\")) {",
          "137:             for( ; n>0; n-- ) {",
          "139:                 if(idx<0)   throw new IllegalArgumentException(originalURL + \" - \" + resURL);",
          "140:                 resURL = resURL.substring(0,idx);",
          "",
          "[Added Lines]",
          "118:     @SuppressFBWarnings(",
          "119:             value = \"URLCONNECTION_SSRF_FD\",",
          "120:             justification = \"Used by the agent as part of jar cache management.\")",
          "124:         if (resURL.startsWith(\"jar:file:\") || resURL.startsWith(\"wsjar:file:\")) {",
          "126:         }",
          "128:         if (resURL.startsWith(\"code-source:/\")) {",
          "130:             resURL = resURL.substring(",
          "131:                     \"code-source:/\".length(), resURL.lastIndexOf('!')); // cut off jar: and the file name portion",
          "132:             return new File(decode(new URL(\"file:/\" + resURL).getPath()));",
          "135:         if (resURL.startsWith(\"zip:\")) {",
          "138:             resURL = resURL.substring(",
          "139:                     \"zip:\".length(), resURL.lastIndexOf('!')); // cut off zip: and the file name portion",
          "140:             return new File(decode(new URL(\"file:\" + resURL).getPath()));",
          "143:         if (resURL.startsWith(\"file:\")) {",
          "146:             for (; n > 0; n--) {",
          "148:                 if (idx < 0) {",
          "149:                     throw new IllegalArgumentException(originalURL + \" - \" + resURL);",
          "150:                 }",
          "151:                 resURL = resURL.substring(0, idx);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "148:             return new File(decode(new URL(resURL).getPath()));",
          "149:         }",
          "154:                 Object delegate = is;",
          "156:                     Field f = delegate.getClass().getDeclaredField(\"delegate\");",
          "157:                     f.setAccessible(true);",
          "158:                     delegate = f.get(delegate);",
          "162:                         f = delegate.getClass().getDeclaredField(\"is\");",
          "163:                         f.setAccessible(true);",
          "164:                         delegate = f.get(delegate);",
          "",
          "[Removed Lines]",
          "151:         if(resURL.startsWith(\"vfszip:\")) {",
          "153:             try(InputStream is = res.openStream()) {",
          "155:                 while (delegate.getClass().getEnclosingClass()!=ZipFile.class) {",
          "161:                     if(delegate.getClass().getName().equals(\"java.util.jar.JarVerifier$VerifierStream\")){",
          "",
          "[Added Lines]",
          "162:         if (resURL.startsWith(\"vfszip:\")) {",
          "164:             try (InputStream is = res.openStream()) {",
          "166:                 while (delegate.getClass().getEnclosingClass() != ZipFile.class) {",
          "172:                     if (delegate.getClass().getName().equals(\"java.util.jar.JarVerifier$VerifierStream\")) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "166:                 }",
          "167:                 Field f = delegate.getClass().getDeclaredField(\"this$0\");",
          "168:                 f.setAccessible(true);",
          "170:                 return new File(zipFile.getName());",
          "171:             } catch (NoSuchFieldException | IllegalAccessException e) {",
          "174:             }",
          "175:         }",
          "179:             String dotdot = \"../\".repeat(Math.max(0, qualifiedName.split(\"/\").length - 1));",
          "181:             try {",
          "183:                 String path = jar.getPath();",
          "195:             }",
          "196:         }",
          "",
          "[Removed Lines]",
          "169:                 ZipFile zipFile = (ZipFile)f.get(delegate);",
          "173:                 LOGGER.log(Level.FINE, \"Failed to resolve vfszip into a jar location\",e);",
          "177:         if(resURL.startsWith(\"vfs:\")) {",
          "182:                 URL jar = new URL(res,dotdot);",
          "184:                 if (path.endsWith(\"/\")) path=path.substring(0,path.length()-1);",
          "186:                 String fileName = path.substring(path.lastIndexOf('/')+1);",
          "188:                 Object vfs = new URL(jar,\"..\").getContent(); // a VirtualFile object pointing to the parent of the jar",
          "189:                 File dir = (File)vfs.getClass().getMethod(\"getPhysicalFile\").invoke(vfs);",
          "191:                 File jarFile = new File(dir,fileName);",
          "192:                 if (jarFile.exists())   return jarFile;",
          "193:             } catch (RuntimeException | NoSuchMethodException | IllegalAccessException | IOException | InvocationTargetException e) {",
          "194:                 LOGGER.log(Level.FINE, \"Failed to resolve vfs file into a location\",e);",
          "",
          "[Added Lines]",
          "180:                 ZipFile zipFile = (ZipFile) f.get(delegate);",
          "184:                 LOGGER.log(Level.FINE, \"Failed to resolve vfszip into a jar location\", e);",
          "188:         if (resURL.startsWith(\"vfs:\")) {",
          "193:                 URL jar = new URL(res, dotdot);",
          "195:                 if (path.endsWith(\"/\")) {",
          "196:                     path = path.substring(0, path.length() - 1);",
          "197:                 }",
          "199:                 String fileName = path.substring(path.lastIndexOf('/') + 1);",
          "201:                 Object vfs = new URL(jar, \"..\").getContent(); // a VirtualFile object pointing to the parent of the jar",
          "202:                 File dir = (File) vfs.getClass().getMethod(\"getPhysicalFile\").invoke(vfs);",
          "204:                 File jarFile = new File(dir, fileName);",
          "205:                 if (jarFile.exists()) {",
          "206:                     return jarFile;",
          "207:                 }",
          "208:             } catch (RuntimeException",
          "209:                     | NoSuchMethodException",
          "210:                     | IllegalAccessException",
          "211:                     | IOException",
          "212:                     | InvocationTargetException e) {",
          "213:                 LOGGER.log(Level.FINE, \"Failed to resolve vfs file into a location\", e);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "199:         if (con instanceof JarURLConnection) {",
          "200:             JarURLConnection jcon = (JarURLConnection) con;",
          "201:             JarFile jarFile = jcon.getJarFile();",
          "203:                 String n = jarFile.getName();",
          "205:                     return new File(n);",
          "206:                 } else {",
          "",
          "[Removed Lines]",
          "202:             if (jarFile!=null) {",
          "204:                 if(n.length()>0) {// JDK6u10 needs this",
          "",
          "[Added Lines]",
          "221:             if (jarFile != null) {",
          "223:                 if (n.length() > 0) { // JDK6u10 needs this",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "213:                         f.setAccessible(true);",
          "214:                         return new File((String) f.get(jarFile));",
          "215:                     } catch (NoSuchFieldException | IllegalAccessException e) {",
          "217:                     }",
          "218:                 }",
          "219:             }",
          "",
          "[Removed Lines]",
          "216:                         LOGGER.log(Level.INFO, \"Failed to obtain the local cache file name of \"+resURL, e);",
          "",
          "[Added Lines]",
          "235:                         LOGGER.log(Level.INFO, \"Failed to obtain the local cache file name of \" + resURL, e);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "227:     }",
          "229:     private static File fromJarUrlToFile(String resURL) throws MalformedURLException {",
          "231:         return new File(decode(new URL(resURL).getPath()));",
          "232:     }",
          "",
          "[Removed Lines]",
          "230:         resURL = resURL.substring(resURL.indexOf(':')+1, resURL.lastIndexOf('!')); // cut off \"scheme:\" and the file name portion",
          "",
          "[Added Lines]",
          "249:         resURL = resURL.substring(",
          "250:                 resURL.indexOf(':') + 1, resURL.lastIndexOf('!')); // cut off \"scheme:\" and the file name portion",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "237:     private static String decode(String s) {",
          "238:         ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "240:             char ch = s.charAt(i);",
          "244:                 continue;",
          "245:             }",
          "246:             baos.write(ch);",
          "",
          "[Removed Lines]",
          "239:         for( int i=0; i<s.length();i++ ) {",
          "241:             if(ch=='%') {",
          "242:                 baos.write(hexToInt(s.charAt(i+1))*16 + hexToInt(s.charAt(i+2)));",
          "243:                 i+=2;",
          "",
          "[Added Lines]",
          "259:         for (int i = 0; i < s.length(); i++) {",
          "261:             if (ch == '%') {",
          "262:                 baos.write(hexToInt(s.charAt(i + 1)) * 16 + hexToInt(s.charAt(i + 2)));",
          "263:                 i += 2;",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/forward/CopyThread.java||src/main/java/hudson/remoting/forward/CopyThread.java": [
          "File: src/main/java/hudson/remoting/forward/CopyThread.java -> src/main/java/hudson/remoting/forward/CopyThread.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:                 LOGGER.log(Level.WARNING, e, () -> \"Uncaught exception in CopyThread \" + t + \", retrying copy\");",
          "33:                 new CopyThread(threadName, in, out, termination, remainingTries - 1).start();",
          "34:             } else {",
          "36:                 termination.run();",
          "37:             }",
          "38:         });",
          "",
          "[Removed Lines]",
          "35:                 LOGGER.log(Level.SEVERE, e, () ->  \"Uncaught exception in CopyThread \" + t + \", out of retries\");",
          "",
          "[Added Lines]",
          "35:                 LOGGER.log(Level.SEVERE, e, () -> \"Uncaught exception in CopyThread \" + t + \", out of retries\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:         try {",
          "44:             byte[] buf = new byte[8192];",
          "45:             int len;",
          "47:                 out.write(buf, 0, len);",
          "48:         } catch (IOException e) {",
          "49:             LOGGER.log(Level.WARNING, e, () -> \"Exception while copying in thread: \" + getName());",
          "50:         }",
          "",
          "[Removed Lines]",
          "46:             while ((len = in.read(buf)) > 0)",
          "",
          "[Added Lines]",
          "46:             while ((len = in.read(buf)) > 0) {",
          "48:             }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/forward/Forwarder.java||src/main/java/hudson/remoting/forward/Forwarder.java": [
          "File: src/main/java/hudson/remoting/forward/Forwarder.java -> src/main/java/hudson/remoting/forward/Forwarder.java"
        ],
        "src/main/java/hudson/remoting/forward/ForwarderFactory.java||src/main/java/hudson/remoting/forward/ForwarderFactory.java": [
          "File: src/main/java/hudson/remoting/forward/ForwarderFactory.java -> src/main/java/hudson/remoting/forward/ForwarderFactory.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:         return channel.call(new ForwarderCallable(remoteHost, remotePort));",
          "57:     }",
          "59:     public static Forwarder create(String remoteHost, int remotePort) {",
          "61:     }",
          "63:     private static class ForwarderImpl implements Forwarder, SerializableOnlyOverRemoting {",
          "",
          "[Removed Lines]",
          "55:     public static Forwarder create(VirtualChannel channel, final String remoteHost, final int remotePort) throws IOException, InterruptedException {",
          "60:         return new ForwarderImpl(remoteHost,remotePort);",
          "",
          "[Added Lines]",
          "55:     public static Forwarder create(VirtualChannel channel, final String remoteHost, final int remotePort)",
          "56:             throws IOException, InterruptedException {",
          "61:         return new ForwarderImpl(remoteHost, remotePort);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         public OutputStream connect(OutputStream out) throws IOException {",
          "75:             Socket s = new Socket(remoteHost, remotePort);",
          "76:             try (InputStream in = SocketChannelStream.in(s)) {",
          "82:                             try {",
          "83:                                 s.close();",
          "84:                             } catch (IOException e) {",
          "85:                                 LOGGER.log(Level.WARNING, \"Problem closing socket for ForwardingFactory\", e);",
          "86:                             }",
          "88:             }",
          "89:             return new RemoteOutputStream(SocketChannelStream.out(s));",
          "90:         }",
          "",
          "[Removed Lines]",
          "77:                 new CopyThread(",
          "78:                         String.format(\"Copier to %s:%d\", remoteHost, remotePort),",
          "79:                         in,",
          "80:                         out,",
          "81:                         () -> {",
          "87:                         }).start();",
          "",
          "[Added Lines]",
          "78:                 new CopyThread(String.format(\"Copier to %s:%d\", remoteHost, remotePort), in, out, () -> {",
          "84:                         })",
          "85:                         .start();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:     public static final Role ROLE = new Role(ForwarderFactory.class);",
          "109:         private static final long serialVersionUID = 1L;",
          "110:         private final String remoteHost;",
          "",
          "[Removed Lines]",
          "107:     private static class ForwarderCallable implements Callable<Forwarder,IOException> {",
          "",
          "[Added Lines]",
          "105:     private static class ForwarderCallable implements Callable<Forwarder, IOException> {",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/forward/PortForwarder.java||src/main/java/hudson/remoting/forward/PortForwarder.java": [
          "File: src/main/java/hudson/remoting/forward/PortForwarder.java -> src/main/java/hudson/remoting/forward/PortForwarder.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:     @SuppressFBWarnings(value = \"UNENCRYPTED_SERVER_SOCKET\", justification = \"Unused\")",
          "55:     public PortForwarder(int localPort, Forwarder forwarder) throws IOException {",
          "57:         this.forwarder = forwarder;",
          "58:         this.socket = new ServerSocket(localPort);",
          "",
          "[Removed Lines]",
          "56:         super(String.format(\"Port forwarder %d\",localPort));",
          "",
          "[Added Lines]",
          "56:         super(String.format(\"Port forwarder %d\", localPort));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:     public void run() {",
          "79:         try {",
          "80:             try {",
          "82:                     final Socket s = socket.accept();",
          "84:                         {",
          "87:                         }",
          "88:                         @Override",
          "89:                         public void run() {",
          "90:                             try (InputStream in = SocketChannelStream.in(s);",
          "97:                                             try {",
          "98:                                                 s.close();",
          "99:                                             } catch (IOException e) {",
          "100:                                                 LOGGER.log(Level.WARNING, \"Failed to close socket\", e);",
          "101:                                             }",
          "103:                             } catch (IOException e) {",
          "105:                                 LOGGER.log(Level.FINE, \"Port forwarding session was shut down abnormally\", e);",
          "",
          "[Removed Lines]",
          "81:                 while(true) {",
          "83:                     new Thread(\"Port forwarding session from \"+s.getRemoteSocketAddress()) {",
          "85:                             setUncaughtExceptionHandler(",
          "86:                                     (t, e) -> LOGGER.log(Level.SEVERE, e, () -> \"Unhandled exception in port forwarding session \" + t));",
          "91:                                     OutputStream out = forwarder.connect(new RemoteOutputStream(SocketChannelStream.out(s)))) {",
          "92:                                 new CopyThread(",
          "93:                                         \"Copier for \" + s.getRemoteSocketAddress(),",
          "94:                                         in,",
          "95:                                         out,",
          "96:                                         () -> {",
          "102:                                         }).start();",
          "",
          "[Added Lines]",
          "81:                 while (true) {",
          "83:                     new Thread(\"Port forwarding session from \" + s.getRemoteSocketAddress()) {",
          "85:                             setUncaughtExceptionHandler((t, e) -> LOGGER.log(",
          "86:                                     Level.SEVERE, e, () -> \"Unhandled exception in port forwarding session \" + t));",
          "92:                                     OutputStream out =",
          "93:                                             forwarder.connect(new RemoteOutputStream(SocketChannelStream.out(s)))) {",
          "94:                                 new CopyThread(\"Copier for \" + s.getRemoteSocketAddress(), in, out, () -> {",
          "100:                                         })",
          "101:                                         .start();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "136:         final Forwarder proxy = ch.export(Forwarder.class, forwarder);",
          "",
          "[Removed Lines]",
          "134:     public static ListeningPort create(VirtualChannel ch, final int acceptingPort, Forwarder forwarder) throws IOException, InterruptedException {",
          "",
          "[Added Lines]",
          "133:     public static ListeningPort create(VirtualChannel ch, final int acceptingPort, Forwarder forwarder)",
          "134:             throws IOException, InterruptedException {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "146:     public static final Role ROLE = new Role(PortForwarder.class);",
          "149:         private static final long serialVersionUID = 1L;",
          "150:         private final int acceptingPort;",
          "151:         private final Forwarder proxy;",
          "",
          "[Removed Lines]",
          "148:     private static class ListeningPortCallable implements Callable<ListeningPort,IOException> {",
          "",
          "[Added Lines]",
          "148:     private static class ListeningPortCallable implements Callable<ListeningPort, IOException> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "158:         @Override",
          "159:         public ListeningPort call() throws IOException {",
          "161:             PortForwarder t = new PortForwarder(acceptingPort, proxy);",
          "162:             t.start();",
          "164:         }",
          "166:         @Override",
          "",
          "[Removed Lines]",
          "160:             final Channel channel = getOpenChannelOrFail(); // We initialize it early, so the forwarder won's start its daemon if the channel is shutting down",
          "163:             return channel.export(ListeningPort.class,t);",
          "",
          "[Added Lines]",
          "160:             final Channel channel =",
          "161:                     getOpenChannelOrFail(); // We initialize it early, so the forwarder won's start its daemon if the",
          "165:             return channel.export(ListeningPort.class, t);",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/jnlp/package-info.java||src/main/java/hudson/remoting/jnlp/package-info.java": [
          "File: src/main/java/hudson/remoting/jnlp/package-info.java -> src/main/java/hudson/remoting/jnlp/package-info.java"
        ],
        "src/main/java/hudson/remoting/package-info.java||src/main/java/hudson/remoting/package-info.java": [
          "File: src/main/java/hudson/remoting/package-info.java -> src/main/java/hudson/remoting/package-info.java"
        ],
        "src/main/java/org/jenkinsci/remoting/CallableDecorator.java||src/main/java/org/jenkinsci/remoting/CallableDecorator.java": [
          "File: src/main/java/org/jenkinsci/remoting/CallableDecorator.java -> src/main/java/org/jenkinsci/remoting/CallableDecorator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:         return stem;",
          "45:     }",
          "46: }",
          "",
          "[Removed Lines]",
          "43:     public <V,T extends Throwable> Callable<V,T> userRequest(Callable<V,T> op, Callable<V,T> stem) {",
          "",
          "[Added Lines]",
          "43:     public <V, T extends Throwable> Callable<V, T> userRequest(Callable<V, T> op, Callable<V, T> stem) {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/ChannelStateException.java||src/main/java/org/jenkinsci/remoting/ChannelStateException.java": [
          "File: src/main/java/org/jenkinsci/remoting/ChannelStateException.java -> src/main/java/org/jenkinsci/remoting/ChannelStateException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     public ChannelStateException(@CheckForNull Channel channel, @NonNull String message) {",
          "54:         super(message);",
          "56:         channelName = channel != null ? channel.getName() : \"unknown\";",
          "57:     }",
          "59:     public ChannelStateException(@CheckForNull Channel channel, String message, @CheckForNull Throwable cause) {",
          "60:         super(message, cause);",
          "62:         channelName = channel != null ? channel.getName() : \"unknown\";",
          "63:     }",
          "",
          "[Removed Lines]",
          "55:         channelRef = channel != null ?  new WeakReference<>(channel) : null;",
          "61:         channelRef = channel != null ?  new WeakReference<>(channel) : null;",
          "",
          "[Added Lines]",
          "55:         channelRef = channel != null ? new WeakReference<>(channel) : null;",
          "61:         channelRef = channel != null ? new WeakReference<>(channel) : null;",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java||src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java": [
          "File: src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java -> src/main/java/org/jenkinsci/remoting/DurationOptionHandler.java"
        ],
        "src/main/java/org/jenkinsci/remoting/Role.java||src/main/java/org/jenkinsci/remoting/Role.java": [
          "File: src/main/java/org/jenkinsci/remoting/Role.java -> src/main/java/org/jenkinsci/remoting/Role.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     @Override",
          "71:     public String toString() {",
          "73:     }",
          "76:         return obj instanceof Role && ((Role) obj).name.equals(name);",
          "77:     }",
          "80:         return name.hashCode();",
          "81:     }",
          "",
          "[Removed Lines]",
          "72:         return super.toString()+\"[\"+name+\"]\";",
          "75:     @Override public boolean equals(Object obj) {",
          "79:     @Override public int hashCode() {",
          "",
          "[Added Lines]",
          "72:         return super.toString() + \"[\" + name + \"]\";",
          "75:     @Override",
          "76:     public boolean equals(Object obj) {",
          "80:     @Override",
          "81:     public int hashCode() {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/RoleChecker.java||src/main/java/org/jenkinsci/remoting/RoleChecker.java": [
          "File: src/main/java/org/jenkinsci/remoting/RoleChecker.java -> src/main/java/org/jenkinsci/remoting/RoleChecker.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:     public void check(@NonNull RoleSensitive subject, @NonNull Role expected) throws SecurityException {",
          "38:         check(subject, Set.of(expected));",
          "",
          "[Removed Lines]",
          "35:     public abstract void check(@NonNull RoleSensitive subject, @NonNull Collection<Role> expected) throws SecurityException;",
          "",
          "[Added Lines]",
          "35:     public abstract void check(@NonNull RoleSensitive subject, @NonNull Collection<Role> expected)",
          "36:             throws SecurityException;",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java||src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java": [
          "File: src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java -> src/main/java/org/jenkinsci/remoting/SerializableOnlyOverRemoting.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:             final Thread t = Thread.currentThread();",
          "66:             throw new NotSerializableException(\"The calling thread \" + t + \" has no associated channel. \"",
          "69:         }",
          "70:         return ch;",
          "71:     }",
          "",
          "[Removed Lines]",
          "67:                     + \"The current object \" + this + \" is \" + SerializableOnlyOverRemoting.class +",
          "68:                     \", but it is likely being serialized/deserialized without the channel\");",
          "",
          "[Added Lines]",
          "67:                     + \"The current object \" + this + \" is \" + SerializableOnlyOverRemoting.class",
          "68:                     + \", but it is likely being serialized/deserialized without the channel\");",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/HostPort.java||src/main/java/org/jenkinsci/remoting/engine/HostPort.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/HostPort.java -> src/main/java/org/jenkinsci/remoting/engine/HostPort.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:         if (portString.length() > 0) {",
          "33:             port = Integer.parseInt(portString);",
          "34:             if (port <= PORT_MIN || port > PORT_MAX) {",
          "36:             }",
          "37:         } else {",
          "38:             port = defaultPort;",
          "",
          "[Removed Lines]",
          "35:                 throw new IllegalArgumentException(\"Port \" + value + \" out of valid range [\" + PORT_MIN + \", \" + PORT_MAX + \")\");",
          "",
          "[Added Lines]",
          "35:                 throw new IllegalArgumentException(",
          "36:                         \"Port \" + value + \" out of valid range [\" + PORT_MIN + \", \" + PORT_MAX + \")\");",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java||src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java -> src/main/java/org/jenkinsci/remoting/engine/Jnlp4ConnectionState.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:         super(socket, listeners);",
          "55:     }",
          "",
          "[Removed Lines]",
          "52:     protected Jnlp4ConnectionState(@NonNull Socket socket,",
          "53:                                    List<? extends JnlpConnectionStateListener> listeners) {",
          "",
          "[Added Lines]",
          "52:     protected Jnlp4ConnectionState(@NonNull Socket socket, List<? extends JnlpConnectionStateListener> listeners) {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpoint.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:     @Deprecated",
          "88:         this(host, port, publicKey, protocols, null, null);",
          "89:     }",
          "",
          "[Removed Lines]",
          "86:     public JnlpAgentEndpoint(@NonNull String host, int port, @CheckForNull RSAPublicKey publicKey,",
          "87:                              @CheckForNull Set<String> protocols) {",
          "",
          "[Added Lines]",
          "87:     public JnlpAgentEndpoint(",
          "88:             @NonNull String host, int port, @CheckForNull RSAPublicKey publicKey, @CheckForNull Set<String> protocols) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:     @Deprecated",
          "97:         this(host, port, publicKey, protocols, serviceURL, null);",
          "98:     }",
          "",
          "[Removed Lines]",
          "95:     public JnlpAgentEndpoint(@NonNull String host, int port, @CheckForNull RSAPublicKey publicKey,",
          "96:                              @CheckForNull Set<String> protocols, @CheckForNull URL serviceURL) {",
          "",
          "[Added Lines]",
          "96:     public JnlpAgentEndpoint(",
          "97:             @NonNull String host,",
          "98:             int port,",
          "99:             @CheckForNull RSAPublicKey publicKey,",
          "100:             @CheckForNull Set<String> protocols,",
          "101:             @CheckForNull URL serviceURL) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113:         if (port <= 0 || 65536 <= port) {",
          "114:             throw new IllegalArgumentException(\"Port \" + port + \" is not in the range 1-65535\");",
          "115:         }",
          "116:         this.host = host;",
          "117:         this.port = port;",
          "118:         this.publicKey = publicKey;",
          "120:         this.serviceUrl = serviceURL;",
          "121:         this.proxyCredentials = proxyCredentials;",
          "122:     }",
          "",
          "[Removed Lines]",
          "111:     public JnlpAgentEndpoint(@NonNull String host, int port, @CheckForNull RSAPublicKey publicKey,",
          "112:                              @CheckForNull Set<String> protocols, @CheckForNull URL serviceURL, @CheckForNull String proxyCredentials) {",
          "119:         this.protocols = protocols == null || protocols.isEmpty() ? null : Collections.unmodifiableSet(new LinkedHashSet<>(protocols));",
          "",
          "[Added Lines]",
          "116:     public JnlpAgentEndpoint(",
          "117:             @NonNull String host,",
          "118:             int port,",
          "119:             @CheckForNull RSAPublicKey publicKey,",
          "120:             @CheckForNull Set<String> protocols,",
          "121:             @CheckForNull URL serviceURL,",
          "122:             @CheckForNull String proxyCredentials) {",
          "129:         this.protocols = protocols == null || protocols.isEmpty()",
          "130:                 ? null",
          "131:                 : Collections.unmodifiableSet(new LinkedHashSet<>(protocols));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "203:     public Socket open(int socketTimeout) throws IOException {",
          "204:         boolean isHttpProxy = false;",
          "205:         InetSocketAddress targetAddress = null;",
          "",
          "[Removed Lines]",
          "200:     @SuppressFBWarnings(value = \"VA_FORMAT_STRING_USES_NEWLINE\",",
          "201:                         justification = \"Unsafe endline symbol is a pert of the protocol. Unsafe to fix it. See TODO \"",
          "202:                                 + \"below\")",
          "",
          "[Added Lines]",
          "212:     @SuppressFBWarnings(",
          "213:             value = \"VA_FORMAT_STRING_USES_NEWLINE\",",
          "214:             justification = \"Unsafe endline symbol is a pert of the protocol. Unsafe to fix it. See TODO \" + \"below\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "230:             if (isHttpProxy) {",
          "231:                 String connectCommand = String.format(\"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s\\r\\n\", host, port, host);",
          "232:                 if (proxyCredentials != null) {",
          "234:                     connectCommand += \"Proxy-Authorization: Basic \" + encoding + \"\\r\\n\";",
          "235:                 }",
          "236:                 connectCommand += \"\\r\\n\";",
          "",
          "[Removed Lines]",
          "233:                     String encoding = Base64.getEncoder().encodeToString(proxyCredentials.getBytes(StandardCharsets.UTF_8));",
          "",
          "[Added Lines]",
          "245:                     String encoding =",
          "246:                             Base64.getEncoder().encodeToString(proxyCredentials.getBytes(StandardCharsets.UTF_8));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "240:                 BufferedInputStream is = new BufferedInputStream(socket.getInputStream());",
          "241:                 BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));",
          "242:                 String line = reader.readLine();",
          "244:                     throw new IOException(\"Proxy socket closed\");",
          "245:                 String[] responseLineParts = line.trim().split(\" \");",
          "246:                 if (responseLineParts.length < 2 || !responseLineParts[1].equals(\"200\")) {",
          "247:                     throw new IOException(\"Got a bad response from proxy: \" + line);",
          "",
          "[Removed Lines]",
          "243:                 if (line == null)",
          "",
          "[Added Lines]",
          "256:                 if (line == null) {",
          "258:                 }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "323:     @Override",
          "324:     public String toString() {",
          "330:     }",
          "331: }",
          "",
          "[Removed Lines]",
          "325:         return \"JnlpAgentEndpoint{\" + \"host=\" + host +",
          "326:                 \", port=\" + port +",
          "327:                 \", publicKey=\" + KeyUtils.fingerprint(publicKey) +",
          "328:                 \", protocols=\" + protocols +",
          "329:                 '}';",
          "",
          "[Added Lines]",
          "339:         return \"JnlpAgentEndpoint{\" + \"host=\" + host + \", port=\"",
          "340:                 + port + \", publicKey=\"",
          "341:                 + KeyUtils.fingerprint(publicKey) + \", protocols=\"",
          "342:                 + protocols + '}';",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointConfigurator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     private final String directionConnection;",
          "40:     private final String proxyCredentials;",
          "43:         this.directionConnection = directConnection;",
          "44:         this.instanceIdentity = instanceIdentity;",
          "45:         this.protocols = protocols;",
          "",
          "[Removed Lines]",
          "42:     public JnlpAgentEndpointConfigurator(String directConnection, String instanceIdentity, Set<String> protocols, String proxyCredentials) {",
          "",
          "[Added Lines]",
          "42:     public JnlpAgentEndpointConfigurator(",
          "43:             String directConnection, String instanceIdentity, Set<String> protocols, String proxyCredentials) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:         }",
          "60:         HostPort hostPort = new HostPort(directionConnection);",
          "63:     }",
          "65:     @Override",
          "66:     public void waitForReady() {",
          "67:         LOGGER.log(Level.INFO, \"Sleeping 10s before reconnect.\");",
          "68:     }",
          "70: }",
          "",
          "[Removed Lines]",
          "62:         return new JnlpAgentEndpoint(hostPort.getHost(), hostPort.getPort(), identity, protocols, null, proxyCredentials);",
          "",
          "[Added Lines]",
          "63:         return new JnlpAgentEndpoint(",
          "64:                 hostPort.getHost(), hostPort.getPort(), identity, protocols, null, proxyCredentials);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java||src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpAgentEndpointResolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:     private static String PROTOCOL_NAMES_TO_TRY =",
          "112:             System.getProperty(JnlpAgentEndpointResolver.class.getName() + \".protocolNamesToTry\");",
          "116:         this.jenkinsUrls = new ArrayList<>(jenkinsUrls);",
          "117:         this.agentName = agentName;",
          "118:         this.credentials = credentials;",
          "",
          "[Removed Lines]",
          "114:     public JnlpAgentEndpointResolver(@NonNull List<String> jenkinsUrls, String agentName, String credentials, String proxyCredentials,",
          "115:                                      String tunnel, SSLSocketFactory sslSocketFactory, boolean disableHttpsCertValidation, Duration noReconnectAfter) {",
          "",
          "[Added Lines]",
          "114:     public JnlpAgentEndpointResolver(",
          "115:             @NonNull List<String> jenkinsUrls,",
          "116:             String agentName,",
          "117:             String credentials,",
          "118:             String proxyCredentials,",
          "119:             String tunnel,",
          "120:             SSLSocketFactory sslSocketFactory,",
          "121:             boolean disableHttpsCertValidation,",
          "122:             Duration noReconnectAfter) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203:                 selectedJenkinsURL = new URL(jenkinsUrl);",
          "204:                 salURL = toAgentListenerURL(jenkinsUrl);",
          "205:             } catch (MalformedURLException ex) {",
          "207:                 continue;",
          "208:             }",
          "213:             try {",
          "214:                 try {",
          "215:                     con.setConnectTimeout(30000);",
          "216:                     con.setReadTimeout(60000);",
          "217:                     con.connect();",
          "218:                 } catch (IOException x) {",
          "221:                     continue;",
          "222:                 }",
          "223:                 if (con.getResponseCode() != 200) {",
          "226:                     continue;",
          "227:                 }",
          "",
          "[Removed Lines]",
          "206:                 LOGGER.log(Level.WARNING, String.format(\"Cannot parse agent endpoint URL %s. Skipping it\", jenkinsUrl), ex);",
          "211:             HttpURLConnection con =",
          "212:                     (HttpURLConnection) openURLConnection(salURL, agentName, credentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "219:                     firstError = ThrowableUtils.chain(firstError,",
          "220:                             new IOException(\"Failed to connect to \" + salURL + \": \" + x.getMessage(), x));",
          "224:                     firstError = ThrowableUtils.chain(firstError, new IOException(",
          "225:                             salURL + \" is invalid: \" + con.getResponseCode() + \" \" + con.getResponseMessage()));",
          "",
          "[Added Lines]",
          "212:                 LOGGER.log(",
          "213:                         Level.WARNING,",
          "214:                         String.format(\"Cannot parse agent endpoint URL %s. Skipping it\", jenkinsUrl),",
          "215:                         ex);",
          "220:             HttpURLConnection con = (HttpURLConnection) openURLConnection(",
          "221:                     salURL, agentName, credentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "228:                     firstError = ThrowableUtils.chain(",
          "229:                             firstError, new IOException(\"Failed to connect to \" + salURL + \": \" + x.getMessage(), x));",
          "233:                     firstError = ThrowableUtils.chain(",
          "234:                             firstError,",
          "235:                             new IOException(",
          "236:                                     salURL + \" is invalid: \" + con.getResponseCode() + \" \" + con.getResponseMessage()));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232:                     VersionNumber minimumSupportedVersion = new VersionNumber(minimumSupportedVersionHeader);",
          "233:                     VersionNumber currentVersion = new VersionNumber(Launcher.VERSION);",
          "234:                     if (currentVersion.isOlderThan(minimumSupportedVersion)) {",
          "238:                         continue;",
          "239:                     }",
          "240:                 }",
          "242:                 Set<String> agentProtocolNames = null;",
          "246:                 String protocols = con.getHeaderField(\"X-Jenkins-Agent-Protocols\");",
          "247:                 if (protocols != null) {",
          "",
          "[Removed Lines]",
          "235:                         firstError = ThrowableUtils.chain(firstError, new IOException(",
          "236:                                 \"Agent version \" + minimumSupportedVersion + \" or newer is required.\"",
          "237:                         ));",
          "244:                 String portStr = Optional.ofNullable(con.getHeaderField(\"X-Jenkins-JNLP-Port\")).orElse(con.getHeaderField(\"X-Hudson-JNLP-Port\"));",
          "245:                 String host = Optional.ofNullable(con.getHeaderField(\"X-Jenkins-JNLP-Host\")).orElse(salURL.getHost());",
          "",
          "[Added Lines]",
          "246:                         firstError = ThrowableUtils.chain(",
          "247:                                 firstError,",
          "248:                                 new IOException(\"Agent version \" + minimumSupportedVersion + \" or newer is required.\"));",
          "255:                 String portStr = Optional.ofNullable(con.getHeaderField(\"X-Jenkins-JNLP-Port\"))",
          "256:                         .orElse(con.getHeaderField(\"X-Hudson-JNLP-Port\"));",
          "257:                 String host = Optional.ofNullable(con.getHeaderField(\"X-Jenkins-JNLP-Host\"))",
          "258:                         .orElse(salURL.getHost());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "252:                             .collect(Collectors.toSet());",
          "254:                     if (agentProtocolNames.isEmpty()) {",
          "260:                     } else {",
          "262:                     }",
          "263:                 }",
          "265:                 if (PROTOCOL_NAMES_TO_TRY != null) {",
          "269:                     agentProtocolNames = Stream.of(PROTOCOL_NAMES_TO_TRY.split(\",\"))",
          "270:                             .map(String::trim)",
          "271:                             .filter(Predicate.not(String::isEmpty))",
          "",
          "[Removed Lines]",
          "255:                         LOGGER.log(Level.WARNING, \"Received the empty list of supported protocols from the server. \" +",
          "256:                                 \"All protocols are disabled on the controller side OR the 'X-Jenkins-Agent-Protocols' header is corrupted (JENKINS-41730). \" +",
          "257:                                 \"In the case of the header corruption as a workaround you can use the \" +",
          "258:                                 \"'org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.protocolNamesToTry' system property \" +",
          "259:                                 \"to define the supported protocols.\");",
          "261:                         LOGGER.log(Level.INFO, \"Remoting server accepts the following protocols: {0}\", agentProtocolNames);",
          "267:                     LOGGER.log(Level.INFO, \"Ignoring the list of supported remoting protocols provided by the server, because the \" +",
          "268:                         \"'org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.protocolNamesToTry' property is defined. Will try {0}\", PROTOCOL_NAMES_TO_TRY);",
          "",
          "[Added Lines]",
          "268:                         LOGGER.log(",
          "269:                                 Level.WARNING,",
          "270:                                 \"Received the empty list of supported protocols from the server. \"",
          "271:                                         + \"All protocols are disabled on the controller side OR the 'X-Jenkins-Agent-Protocols' header is corrupted (JENKINS-41730). \"",
          "272:                                         + \"In the case of the header corruption as a workaround you can use the \"",
          "273:                                         + \"'org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.protocolNamesToTry' system property \"",
          "274:                                         + \"to define the supported protocols.\");",
          "276:                         LOGGER.log(",
          "277:                                 Level.INFO, \"Remoting server accepts the following protocols: {0}\", agentProtocolNames);",
          "283:                     LOGGER.log(",
          "284:                             Level.INFO,",
          "285:                             \"Ignoring the list of supported remoting protocols provided by the server, because the \"",
          "286:                                     + \"'org.jenkinsci.remoting.engine.JnlpAgentEndpointResolver.protocolNamesToTry' property is defined. Will try {0}\",",
          "287:                             PROTOCOL_NAMES_TO_TRY);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "277:                 try {",
          "278:                     identity = getIdentity(idHeader);",
          "279:                     if (identity == null) {",
          "282:                         continue;",
          "283:                     }",
          "284:                 } catch (InvalidKeySpecException e) {",
          "287:                     continue;",
          "288:                 }",
          "",
          "[Removed Lines]",
          "280:                         firstError = ThrowableUtils.chain(firstError, new IOException(",
          "281:                                 salURL + \" appears to be publishing an invalid X-Instance-Identity.\"));",
          "285:                     firstError = ThrowableUtils.chain(firstError, new IOException(",
          "286:                             salURL + \" appears to be publishing an invalid X-Instance-Identity.\"));",
          "",
          "[Added Lines]",
          "299:                         firstError = ThrowableUtils.chain(",
          "300:                                 firstError,",
          "301:                                 new IOException(salURL + \" appears to be publishing an invalid X-Instance-Identity.\"));",
          "305:                     firstError = ThrowableUtils.chain(",
          "306:                             firstError,",
          "307:                             new IOException(salURL + \" appears to be publishing an invalid X-Instance-Identity.\"));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "295:                 try {",
          "296:                     port = Integer.parseInt(portStr);",
          "297:                 } catch (NumberFormatException e) {",
          "299:                     continue;",
          "300:                 }",
          "301:                 if (port <= 0 || 65536 <= port) {",
          "303:                     continue;",
          "304:                 }",
          "305:                 if (tunnel == null) {",
          "306:                     if (!isPortVisible(host, port)) {",
          "309:                         continue;",
          "310:                     } else {",
          "311:                         LOGGER.log(Level.FINE, \"TCP Agent Listener Port availability check passed\");",
          "312:                     }",
          "313:                 } else {",
          "316:                 }",
          "318:                 final String winningJenkinsUrl = jenkinsUrl;",
          "",
          "[Removed Lines]",
          "298:                     firstError = ThrowableUtils.chain(firstError, new IOException(jenkinsUrl + \" is publishing an invalid port\", e));",
          "302:                     firstError = ThrowableUtils.chain(firstError, new IOException(jenkinsUrl + \" is publishing an invalid port\"));",
          "307:                         firstError = ThrowableUtils.chain(firstError, new IOException(jenkinsUrl + \" provided port:\" + port",
          "308:                                 + \" is not reachable on host \" + host));",
          "314:                     LOGGER.log(Level.INFO, \"Remoting TCP connection tunneling is enabled. \" +",
          "315:                             \"Skipping the TCP Agent Listener Port availability check\");",
          "",
          "[Added Lines]",
          "319:                     firstError = ThrowableUtils.chain(",
          "320:                             firstError, new IOException(jenkinsUrl + \" is publishing an invalid port\", e));",
          "324:                     firstError = ThrowableUtils.chain(",
          "325:                             firstError, new IOException(jenkinsUrl + \" is publishing an invalid port\"));",
          "330:                         firstError = ThrowableUtils.chain(",
          "331:                                 firstError,",
          "332:                                 new IOException(",
          "333:                                         jenkinsUrl + \" provided port:\" + port + \" is not reachable on host \" + host));",
          "339:                     LOGGER.log(",
          "340:                             Level.INFO,",
          "341:                             \"Remoting TCP connection tunneling is enabled. \"",
          "342:                                     + \"Skipping the TCP Agent Listener Port availability check\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "331:                     port = hostPort.getPort();",
          "332:                 }",
          "336:             } finally {",
          "337:                 con.disconnect();",
          "338:             }",
          "",
          "[Removed Lines]",
          "335:                 return new JnlpAgentEndpoint(host, port, identity, agentProtocolNames, selectedJenkinsURL, proxyCredentials);",
          "",
          "[Added Lines]",
          "362:                 return new JnlpAgentEndpoint(",
          "363:                         host, port, identity, agentProtocolNames, selectedJenkinsURL, proxyCredentials);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "343:         return null;",
          "344:     }",
          "347:     private synchronized boolean isPortVisible(String hostname, int port) {",
          "348:         boolean exitStatus = false;",
          "349:         Socket s = null;",
          "",
          "[Removed Lines]",
          "346:     @SuppressFBWarnings(value = \"UNENCRYPTED_SOCKET\", justification = \"This just verifies connection to the port. No data is transmitted.\")",
          "",
          "[Added Lines]",
          "374:     @SuppressFBWarnings(",
          "375:             value = \"UNENCRYPTED_SOCKET\",",
          "376:             justification = \"This just verifies connection to the port. No data is transmitted.\")",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "362:                     @Override",
          "363:                     protected PasswordAuthentication getPasswordAuthentication() {",
          "364:                         if (getRequestorType().equals(RequestorType.PROXY)) {",
          "366:                         }",
          "367:                         return super.getPasswordAuthentication();",
          "368:                     }",
          "369:                 });",
          "370:             }",
          "372:             s = proxyToUse == null ? new Socket() : new Socket(new Proxy(Proxy.Type.HTTP, proxyToUse));",
          "373:             s.setReuseAddress(true);",
          "374:             SocketAddress sa = new InetSocketAddress(hostname, port);",
          "",
          "[Removed Lines]",
          "365:                             return new PasswordAuthentication(proxyCredentials.substring(0, index), proxyCredentials.substring(index + 1).toCharArray());",
          "371:             InetSocketAddress proxyToUse = getResolvedHttpProxyAddress(hostname,port);",
          "",
          "[Added Lines]",
          "395:                             return new PasswordAuthentication(",
          "396:                                     proxyCredentials.substring(0, index),",
          "397:                                     proxyCredentials.substring(index + 1).toCharArray());",
          "403:             InetSocketAddress proxyToUse = getResolvedHttpProxyAddress(hostname, port);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "425:                     retries++;",
          "426:                     t.setName(oldName + \": trying \" + url + \" for \" + retries + \" times\");",
          "430:                     con.setConnectTimeout(5000);",
          "431:                     con.setReadTimeout(5000);",
          "432:                     con.connect();",
          "433:                     if (con.getResponseCode() == 200) {",
          "434:                         return;",
          "435:                     }",
          "437:                             \"Controller isn''t ready to talk to us on {0}. Will try again: response code={1}\",",
          "439:                 } catch (SocketTimeoutException | ConnectException | NoRouteToHostException e) {",
          "442:                 } catch (IOException e) {",
          "444:                     LOGGER.log(Level.INFO, e, () -> \"Failed to connect to \" + firstUrl + \". Will try again\");",
          "",
          "[Removed Lines]",
          "428:                     HttpURLConnection con =",
          "429:                             (HttpURLConnection) openURLConnection(url, agentName, credentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "436:                     LOGGER.log(Level.INFO,",
          "438:                             new Object[]{url, con.getResponseCode()});",
          "440:                     LOGGER.log(Level.INFO, \"Failed to connect to {0}. Will try again: {1} {2}\",",
          "441:                             new String[] {firstUrl, e.getClass().getName(), e.getMessage()});",
          "",
          "[Added Lines]",
          "460:                     HttpURLConnection con = (HttpURLConnection) openURLConnection(",
          "461:                             url, agentName, credentials, proxyCredentials, sslSocketFactory, hostnameVerifier);",
          "468:                     LOGGER.log(",
          "469:                             Level.INFO,",
          "471:                             new Object[] {url, con.getResponseCode()});",
          "473:                     LOGGER.log(Level.INFO, \"Failed to connect to {0}. Will try again: {1} {2}\", new String[] {",
          "474:                         firstUrl, e.getClass().getName(), e.getMessage()",
          "475:                     });",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "452:     @CheckForNull",
          "453:     static InetSocketAddress getResolvedHttpProxyAddress(@NonNull String host, int port) throws IOException {",
          "454:         InetSocketAddress targetAddress = null;",
          "458:         while (targetAddress == null && proxies.hasNext()) {",
          "459:             Proxy proxy = proxies.next();",
          "460:             if (proxy.type() == Proxy.Type.DIRECT) {",
          "474:                 String nonProxyHosts = System.getProperty(\"http.nonProxyHosts\");",
          "477:                     StringJoiner sj = new StringJoiner(\"|\");",
          "478:                     nonProxyHosts = nonProxyHosts.toLowerCase(Locale.ENGLISH);",
          "481:                             continue;",
          "483:                             sj.add(\".*\" + Pattern.quote(entry.substring(1)));",
          "485:                             sj.add(Pattern.quote(entry.substring(0, entry.length() - 1)) + \".*\");",
          "487:                             sj.add(Pattern.quote(entry));",
          "491:                     }",
          "492:                     Pattern nonProxyRegexps = Pattern.compile(sj.toString());",
          "494:                         return null;",
          "495:                     } else {",
          "496:                         break;",
          "",
          "[Removed Lines]",
          "455:         Iterator<Proxy>",
          "456:                 proxies =",
          "457:                 ProxySelector.getDefault().select(URI.create(String.format(\"http://%s:%d\", host, port))).iterator();",
          "475:                 if(nonProxyHosts != null && nonProxyHosts.length() != 0) {",
          "479:                     for(String entry : nonProxyHosts.split(\"\\\\|\")) {",
          "480:                         if(entry.isEmpty())",
          "482:                         else if(entry.startsWith(\"*\"))",
          "484:                         else if(entry.endsWith(\"*\"))",
          "486:                         else",
          "489:                         if(entry.split(\"\\\\*\").length > 2)",
          "490:                             LOGGER.log(Level.WARNING, \"Using more than one wildcard is not supported in nonProxyHosts entries: {0}\", entry);",
          "493:                     if(nonProxyRegexps.matcher(host.toLowerCase(Locale.ENGLISH)).matches()) {",
          "",
          "[Added Lines]",
          "489:         Iterator<Proxy> proxies = ProxySelector.getDefault()",
          "490:                 .select(URI.create(String.format(\"http://%s:%d\", host, port)))",
          "491:                 .iterator();",
          "513:                 if (nonProxyHosts != null && nonProxyHosts.length() != 0) {",
          "517:                     for (String entry : nonProxyHosts.split(\"\\\\|\")) {",
          "518:                         if (entry.isEmpty()) {",
          "520:                         } else if (entry.startsWith(\"*\")) {",
          "522:                         } else if (entry.endsWith(\"*\")) {",
          "524:                         } else {",
          "526:                         }",
          "529:                         if (entry.split(\"\\\\*\").length > 2) {",
          "530:                             LOGGER.log(",
          "531:                                     Level.WARNING,",
          "532:                                     \"Using more than one wildcard is not supported in nonProxyHosts entries: {0}\",",
          "533:                                     entry);",
          "534:                         }",
          "537:                     if (nonProxyRegexps",
          "538:                             .matcher(host.toLowerCase(Locale.ENGLISH))",
          "539:                             .matches()) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "500:             if (proxy.type() == Proxy.Type.HTTP) {",
          "501:                 final SocketAddress address = proxy.address();",
          "502:                 if (!(address instanceof InetSocketAddress)) {",
          "504:                     continue;",
          "505:                 }",
          "506:                 InetSocketAddress proxyAddress = (InetSocketAddress) address;",
          "508:                     proxyAddress = new InetSocketAddress(proxyAddress.getHostName(), proxyAddress.getPort());",
          "509:                 targetAddress = proxyAddress;",
          "510:             }",
          "511:         }",
          "",
          "[Removed Lines]",
          "503:                     LOGGER.log(Level.WARNING, \"Unsupported proxy address type {0}\", (address != null ? address.getClass() : \"null\"));",
          "507:                 if (proxyAddress.isUnresolved())",
          "",
          "[Added Lines]",
          "549:                     LOGGER.log(",
          "550:                             Level.WARNING,",
          "551:                             \"Unsupported proxy address type {0}\",",
          "552:                             (address != null ? address.getClass() : \"null\"));",
          "556:                 if (proxyAddress.isUnresolved()) {",
          "558:                 }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "532:     @Restricted(NoExternalUse.class)",
          "534:     public static URLConnection openURLConnection(",
          "535:             URL url,",
          "536:             @CheckForNull String agentName,",
          "",
          "[Removed Lines]",
          "533:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Used by the agent for retrieving connection info from the server.\")",
          "",
          "[Added Lines]",
          "583:     @SuppressFBWarnings(",
          "584:             value = \"URLCONNECTION_SSRF_FD\",",
          "585:             justification = \"Used by the agent for retrieving connection info from the server.\")",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java||src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionState.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "55:     private static final ThreadLocal<Iterator<JnlpConnectionStateListener>> fireIterator",
          "56:             = new ThreadLocal<>();",
          "",
          "[Added Lines]",
          "55:     private static final ThreadLocal<Iterator<JnlpConnectionStateListener>> fireIterator = new ThreadLocal<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "526: }",
          "",
          "[Removed Lines]",
          "523:     public interface ListenerState {",
          "525:     }",
          "",
          "[Added Lines]",
          "522:     public interface ListenerState {}",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java||src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpConnectionStateListener.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "61:     public void beforeProperties(@NonNull JnlpConnectionState event) {",
          "63:     }",
          "",
          "[Added Lines]",
          "61:     public void beforeProperties(@NonNull JnlpConnectionState event) {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "81:     public void beforeChannel(@NonNull JnlpConnectionState event) {",
          "82:     }",
          "",
          "[Added Lines]",
          "79:     public void beforeChannel(@NonNull JnlpConnectionState event) {}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "98:     public void channelClosed(@NonNull JnlpConnectionState event) {",
          "100:     }",
          "",
          "[Added Lines]",
          "95:     public void channelClosed(@NonNull JnlpConnectionState event) {}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111: }",
          "",
          "[Removed Lines]",
          "108:     public void afterDisconnect(@NonNull JnlpConnectionState event) {",
          "110:     }",
          "",
          "[Added Lines]",
          "103:     public void afterDisconnect(@NonNull JnlpConnectionState event) {}",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java||src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpEndpointResolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     public abstract void waitForReady() throws InterruptedException;",
          "40:     protected RSAPublicKey getIdentity(String base64EncodedIdentity) throws InvalidKeySpecException {",
          "42:         try {",
          "43:             byte[] encodedKey = Base64.getDecoder().decode(base64EncodedIdentity);",
          "45:             X509EncodedKeySpec spec = new X509EncodedKeySpec(encodedKey);",
          "46:             KeyFactory kf = KeyFactory.getInstance(\"RSA\");",
          "47:             return (RSAPublicKey) kf.generatePublic(spec);",
          "48:         } catch (NoSuchAlgorithmException e) {",
          "50:         }",
          "51:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "41:         if (base64EncodedIdentity == null) return null;",
          "44:             if (encodedKey == null) return null;",
          "49:             throw new IllegalStateException(\"The Java Language Specification mandates RSA as a supported algorithm.\", e);",
          "",
          "[Added Lines]",
          "41:         if (base64EncodedIdentity == null) {",
          "42:             return null;",
          "43:         }",
          "46:             if (encodedKey == null) {",
          "47:                 return null;",
          "48:             }",
          "53:             throw new IllegalStateException(",
          "54:                     \"The Java Language Specification mandates RSA as a supported algorithm.\", e);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4Handler.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:         super(clientDatabase, preferNio);",
          "111:         this.threadPool = threadPool;",
          "112:         this.ioHub = ioHub;",
          "",
          "[Removed Lines]",
          "107:     public JnlpProtocol4Handler(@Nullable JnlpClientDatabase clientDatabase, @NonNull ExecutorService threadPool,",
          "108:                                 @NonNull IOHub ioHub, @NonNull SSLContext context, boolean needClientAuth,",
          "109:                                 boolean preferNio) {",
          "",
          "[Added Lines]",
          "107:     public JnlpProtocol4Handler(",
          "108:             @Nullable JnlpClientDatabase clientDatabase,",
          "109:             @NonNull ExecutorService threadPool,",
          "110:             @NonNull IOHub ioHub,",
          "111:             @NonNull SSLContext context,",
          "112:             boolean needClientAuth,",
          "113:             boolean preferNio) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:     @NonNull",
          "126:     @Override",
          "129:         return new Jnlp4ConnectionState(socket, listeners);",
          "130:     }",
          "",
          "[Removed Lines]",
          "127:     public Jnlp4ConnectionState createConnectionState(@NonNull Socket socket,",
          "128:                                                       @NonNull List<? extends JnlpConnectionStateListener> listeners) {",
          "",
          "[Added Lines]",
          "131:     public Jnlp4ConnectionState createConnectionState(",
          "132:             @NonNull Socket socket, @NonNull List<? extends JnlpConnectionStateListener> listeners) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:     @NonNull",
          "140:     @Override",
          "143:             throws IOException {",
          "144:         NetworkLayer networkLayer = createNetworkLayer(socket);",
          "145:         SSLEngine engine = createSSLEngine(socket);",
          "",
          "[Removed Lines]",
          "141:     public Future<Channel> handle(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "142:                                   @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "[Added Lines]",
          "145:     public Future<Channel> handle(",
          "146:             @NonNull Socket socket,",
          "147:             @NonNull Map<String, String> headers,",
          "148:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "167:     @NonNull",
          "168:     @Override",
          "171:         NetworkLayer networkLayer = createNetworkLayer(socket);",
          "172:         SSLEngine sslEngine = createSSLEngine(socket);",
          "173:         sslEngine.setUseClientMode(true);",
          "",
          "[Removed Lines]",
          "169:     public Future<Channel> connect(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "170:                                    @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException {",
          "",
          "[Added Lines]",
          "175:     public Future<Channel> connect(",
          "176:             @NonNull Socket socket,",
          "177:             @NonNull Map<String, String> headers,",
          "178:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "179:             throws IOException {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "195:         SocketChannel socketChannel = isPreferNio() ? socket.getChannel() : null;",
          "196:         LOGGER.fine(() -> \"prefer NIO? \" + isPreferNio() + \" actually using NIO? \" + (socketChannel != null));",
          "197:         if (socketChannel == null) {",
          "199:                     Channels.newChannel(SocketChannelStream.out(socket)));",
          "200:         } else {",
          "201:             networkLayer = new NIONetworkLayer(ioHub, socketChannel, socketChannel);",
          "",
          "[Removed Lines]",
          "198:             networkLayer = new BIONetworkLayer(ioHub, Channels.newChannel(SocketChannelStream.in(socket)),",
          "",
          "[Added Lines]",
          "207:             networkLayer = new BIONetworkLayer(",
          "208:                     ioHub,",
          "209:                     Channels.newChannel(SocketChannelStream.in(socket)),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "226:     private class Handler extends Channel.Listener implements SSLEngineFilterLayer.Listener,",
          "227:             ConnectionHeadersFilterLayer.Listener, ChannelApplicationLayer.Listener, ProtocolStack.Listener,",
          "228:             ChannelApplicationLayer.ChannelDecorator {",
          "",
          "[Added Lines]",
          "237:     private class Handler extends Channel.Listener",
          "238:             implements SSLEngineFilterLayer.Listener,",
          "239:                     ConnectionHeadersFilterLayer.Listener,",
          "240:                     ChannelApplicationLayer.Listener,",
          "241:                     ProtocolStack.Listener,",
          "242:                     ChannelApplicationLayer.ChannelDecorator {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "304:                         break;",
          "305:                     case INVALID:",
          "307:                                 \"An attempt was made to connect as {0} from {1} with an invalid client certificate\",",
          "309:                         throw new ConnectionRefusalException(\"Authentication failure\");",
          "310:                     default:",
          "311:                         String secretKey = clientDatabase.getSecretOf(clientName);",
          "",
          "[Removed Lines]",
          "306:                         LOGGER.log(Level.WARNING,",
          "308:                                 new Object[]{clientName, event.getRemoteEndpointDescription()});",
          "",
          "[Added Lines]",
          "320:                         LOGGER.log(",
          "321:                                 Level.WARNING,",
          "323:                                 new Object[] {clientName, event.getRemoteEndpointDescription()});",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "314:                             throw new ConnectionRefusalException(\"Unknown client name: \" + clientName);",
          "315:                         }",
          "318:                                     \"An attempt was made to connect as {0} from {1} with an incorrect secret\",",
          "320:                             throw new ConnectionRefusalException(\"Authorization failure\");",
          "321:                         }",
          "322:                         break;",
          "",
          "[Removed Lines]",
          "316:                         if (!MessageDigest.isEqual(secretKey.getBytes(StandardCharsets.UTF_8), headers.get(JnlpConnectionState.SECRET_KEY).getBytes(StandardCharsets.UTF_8))) {",
          "317:                             LOGGER.log(Level.WARNING,",
          "319:                                     new Object[]{clientName, event.getRemoteEndpointDescription()});",
          "",
          "[Added Lines]",
          "331:                         if (!MessageDigest.isEqual(",
          "332:                                 secretKey.getBytes(StandardCharsets.UTF_8),",
          "333:                                 headers.get(JnlpConnectionState.SECRET_KEY).getBytes(StandardCharsets.UTF_8))) {",
          "334:                             LOGGER.log(",
          "335:                                     Level.WARNING,",
          "337:                                     new Object[] {clientName, event.getRemoteEndpointDescription()});",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpProtocol4ProxyHandler.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:     @Override",
          "61:     @NonNull",
          "63:         LOGGER.fine(\"sending my name\");",
          "64:         DataOutputStream dos = new DataOutputStream(socket.getOutputStream());",
          "65:         dos.writeUTF(\"Protocol:\" + NAME);",
          "",
          "[Removed Lines]",
          "62:     public Future<Channel> connect(@NonNull Socket socket, @NonNull Map<String, String> headers, @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException {",
          "",
          "[Added Lines]",
          "62:     public Future<Channel> connect(",
          "63:             @NonNull Socket socket,",
          "64:             @NonNull Map<String, String> headers,",
          "65:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "66:             throws IOException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:     @Override",
          "80:     @NonNull",
          "82:         throw new UnsupportedOperationException(\"unused, API design mistake\");",
          "83:     }",
          "85:     @Override",
          "86:     @NonNull",
          "88:         throw new UnsupportedOperationException(\"unused, API design mistake\");",
          "89:     }",
          "91: }",
          "",
          "[Removed Lines]",
          "81:     public Future<Channel> handle(@NonNull Socket socket, @NonNull Map<String, String> headers, @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException {",
          "87:     protected JnlpConnectionState createConnectionState(@NonNull Socket socket, @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException {",
          "",
          "[Added Lines]",
          "85:     public Future<Channel> handle(",
          "86:             @NonNull Socket socket,",
          "87:             @NonNull Map<String, String> headers,",
          "88:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "89:             throws IOException {",
          "95:     protected JnlpConnectionState createConnectionState(",
          "96:             @NonNull Socket socket, @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandler.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     @NonNull",
          "",
          "[Removed Lines]",
          "111:     protected abstract STATE createConnectionState(@NonNull Socket socket,",
          "112:                                                    @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "113:             throws IOException;",
          "",
          "[Added Lines]",
          "111:     protected abstract STATE createConnectionState(",
          "112:             @NonNull Socket socket, @NonNull List<? extends JnlpConnectionStateListener> listeners) throws IOException;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:     @NonNull",
          "127:             throws IOException {",
          "128:         return handle(socket, headers, Arrays.asList(listeners));",
          "129:     }",
          "",
          "[Removed Lines]",
          "125:     public final Future<Channel> handle(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "126:                                         @NonNull JnlpConnectionStateListener... listeners)",
          "",
          "[Added Lines]",
          "124:     public final Future<Channel> handle(",
          "125:             @NonNull Socket socket,",
          "126:             @NonNull Map<String, String> headers,",
          "127:             @NonNull JnlpConnectionStateListener... listeners)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "140:     @NonNull",
          "143:             throws IOException;",
          "",
          "[Removed Lines]",
          "141:     public abstract Future<Channel> handle(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "142:                                            @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "[Added Lines]",
          "142:     public abstract Future<Channel> handle(",
          "143:             @NonNull Socket socket,",
          "144:             @NonNull Map<String, String> headers,",
          "145:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154:     @NonNull",
          "157:         return connect(socket, headers, Arrays.asList(listeners));",
          "158:     }",
          "",
          "[Removed Lines]",
          "155:     public final Future<Channel> connect(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "156:                                          @NonNull JnlpConnectionStateListener... listeners) throws IOException {",
          "",
          "[Added Lines]",
          "158:     public final Future<Channel> connect(",
          "159:             @NonNull Socket socket,",
          "160:             @NonNull Map<String, String> headers,",
          "161:             @NonNull JnlpConnectionStateListener... listeners)",
          "162:             throws IOException {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "169:     @NonNull",
          "172:             throws IOException;",
          "174: }",
          "",
          "[Removed Lines]",
          "170:     public abstract Future<Channel> connect(@NonNull Socket socket, @NonNull Map<String, String> headers,",
          "171:                                             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "[Added Lines]",
          "176:     public abstract Future<Channel> connect(",
          "177:             @NonNull Socket socket,",
          "178:             @NonNull Map<String, String> headers,",
          "179:             @NonNull List<? extends JnlpConnectionStateListener> listeners)",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java||src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java -> src/main/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerFactory.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "160:     public List<JnlpProtocolHandler<? extends JnlpConnectionState>> handlers() {",
          "161:         List<JnlpProtocolHandler<? extends JnlpConnectionState>> result = new ArrayList<>();",
          "162:         if (ioHub != null && context != null) {",
          "164:             result.add(new JnlpProtocol4ProxyHandler(jnlpProtocol4Handler));",
          "165:             result.add(jnlpProtocol4Handler);",
          "166:         }",
          "",
          "[Removed Lines]",
          "163:             JnlpProtocol4Handler jnlpProtocol4Handler = new JnlpProtocol4Handler(clientDatabase, threadPool, ioHub, context, needClientAuth, preferNio);",
          "",
          "[Added Lines]",
          "163:             JnlpProtocol4Handler jnlpProtocol4Handler =",
          "164:                     new JnlpProtocol4Handler(clientDatabase, threadPool, ioHub, context, needClientAuth, preferNio);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java||src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java": [
          "File: src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java -> src/main/java/org/jenkinsci/remoting/engine/WorkDirManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "185:     @CheckForNull",
          "186:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"Parameter supplied by user / administrator.\")",
          "189:         if (!internalDir.matches(SUPPORTED_INTERNAL_DIR_NAME_MASK)) {",
          "191:                     DirType.INTERNAL_DIR, internalDir, SUPPORTED_INTERNAL_DIR_NAME_MASK));",
          "192:         }",
          "194:         if (workDir == null) {",
          "197:             return null;",
          "198:         } else {",
          "",
          "[Removed Lines]",
          "187:     public Path initializeWorkDir(final @CheckForNull File workDir, final @NonNull String internalDir, final boolean failIfMissing) throws IOException {",
          "190:             throw new IOException(String.format(\"Name of %s ('%s') is not compliant with the required format: %s\",",
          "",
          "[Added Lines]",
          "186:     public Path initializeWorkDir(",
          "187:             final @CheckForNull File workDir, final @NonNull String internalDir, final boolean failIfMissing)",
          "188:             throws IOException {",
          "191:             throw new IOException(String.format(",
          "192:                     \"Name of %s ('%s') is not compliant with the required format: %s\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "219:     }",
          "221:     @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"Value supplied by user / administrator.\")",
          "224:         if (!disabledDirectories.contains(type)) {",
          "225:             final File directory = new File(internalDir, type.getDefaultLocation());",
          "226:             verifyDirectory(directory, type, false);",
          "",
          "[Removed Lines]",
          "222:     private void createInternalDirIfRequired(File internalDir, DirType type)",
          "223:             throws IOException {",
          "",
          "[Added Lines]",
          "225:     private void createInternalDirIfRequired(File internalDir, DirType type) throws IOException {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "243:         if (dir.exists()) {",
          "244:             if (!dir.isDirectory()) {",
          "246:             }",
          "247:             if (!dir.canWrite() || !dir.canRead() || !dir.canExecute()) {",
          "249:             }",
          "250:         } else if (failIfMissing) {",
          "251:             throw new IOException(\"The \" + type + \" is missing, but it is expected to exist: \" + dir.getPath());",
          "",
          "[Removed Lines]",
          "242:     private static void verifyDirectory(@NonNull File dir, @NonNull DirType type, boolean failIfMissing) throws IOException {",
          "245:                 throw new IOException(\"The specified \" + type + \" path points to a non-directory file: \" + dir.getPath());",
          "248:                 throw new IOException(\"The specified \" + type + \" should be fully accessible to the remoting executable (RWX): \" + dir.getPath());",
          "",
          "[Added Lines]",
          "244:     private static void verifyDirectory(@NonNull File dir, @NonNull DirType type, boolean failIfMissing)",
          "245:             throws IOException {",
          "248:                 throw new IOException(",
          "249:                         \"The specified \" + type + \" path points to a non-directory file: \" + dir.getPath());",
          "252:                 throw new IOException(\"The specified \" + type",
          "253:                         + \" should be fully accessible to the remoting executable (RWX): \" + dir.getPath());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "267:         if (loggingInitialized) {",
          "",
          "[Removed Lines]",
          "266:     public void setupLogging(@CheckForNull Path internalDirPath, @CheckForNull Path overrideLogPath) throws IOException {",
          "",
          "[Added Lines]",
          "271:     public void setupLogging(@CheckForNull Path internalDirPath, @CheckForNull Path overrideLogPath)",
          "272:             throws IOException {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "274:         final File configFile = getLoggingConfigFile();",
          "275:         if (configFile != null) {",
          "277:             LOGGER.log(Level.FINE, \"Reading Logging configuration from file: {0}\", configFile);",
          "279:                 LogManager.getLogManager().readConfiguration(fis);",
          "280:             }",
          "281:         }",
          "283:         if (overrideLogPath != null) { // Legacy behavior",
          "285:             System.out.flush(); // Just in case the channel",
          "286:             System.err.flush();",
          "287:             System.setErr(legacyCreateTeeStream(System.err, overrideLogPath));",
          "",
          "[Removed Lines]",
          "278:             try(FileInputStream fis =  new FileInputStream(configFile)) {",
          "284:             LOGGER.log(Level.INFO, \"Using {0} as an agent error log destination; output log will not be generated\", overrideLogPath);",
          "",
          "[Added Lines]",
          "285:             try (FileInputStream fis = new FileInputStream(configFile)) {",
          "291:             LOGGER.log(",
          "292:                     Level.INFO,",
          "293:                     \"Using {0} as an agent error log destination; output log will not be generated\",",
          "294:                     overrideLogPath);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "299:             if (configFile == null) {",
          "300:                 final Logger rootLogger = Logger.getLogger(\"\");",
          "301:                 final File julLog = new File(logsDir, \"remoting.log\");",
          "304:                 logHandler.setFormatter(new SimpleFormatter());",
          "305:                 logHandler.setLevel(Level.INFO);",
          "306:                 rootLogger.addHandler(logHandler);",
          "",
          "[Removed Lines]",
          "302:                 final FileHandler logHandler = new FileHandler(julLog.getAbsolutePath(),",
          "303:                                          10*1024*1024, 5, false);",
          "",
          "[Added Lines]",
          "312:                 final FileHandler logHandler = new FileHandler(julLog.getAbsolutePath(), 10 * 1024 * 1024, 5, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "310:         }",
          "311:     }",
          "314:     private PrintStream legacyCreateTeeStream(OutputStream ostream, Path destination) throws FileNotFoundException {",
          "315:         return new PrintStream(new TeeOutputStream(ostream, new FileOutputStream(destination.toFile())));",
          "316:     }",
          "",
          "[Removed Lines]",
          "313:     @SuppressFBWarnings(value = \"DM_DEFAULT_ENCODING\", justification = \"It is a legacy logging mode. Relying on the default is not fine, but it just behaves as it used to behave for years\")",
          "",
          "[Added Lines]",
          "322:     @SuppressFBWarnings(",
          "323:             value = \"DM_DEFAULT_ENCODING\",",
          "324:             justification =",
          "325:                     \"It is a legacy logging mode. Relying on the default is not fine, but it just behaves as it used to behave for years\")",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/Closeables.java||src/main/java/org/jenkinsci/remoting/nio/Closeables.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/Closeables.java -> src/main/java/org/jenkinsci/remoting/nio/Closeables.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:                 }",
          "29:                 maybeClose(s);",
          "30:             };",
          "32:             return ch;",
          "33:     }",
          "35:     public static Closeable output(SelectableChannel ch) {",
          "",
          "[Removed Lines]",
          "27:                     LOGGER.log(Level.FINE, \"Failed to close \"+s,e);",
          "31:         } else",
          "",
          "[Added Lines]",
          "27:                     LOGGER.log(Level.FINE, \"Failed to close \" + s, e);",
          "31:         } else {",
          "33:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:                     s.socket().shutdownOutput();",
          "41:                 } catch (IOException e) {",
          "44:                 }",
          "45:                 maybeClose(s);",
          "46:             };",
          "48:             return ch;",
          "49:     }",
          "",
          "[Removed Lines]",
          "43:                     LOGGER.log(Level.FINE, \"Failed to close \"+s,e);",
          "47:         } else",
          "",
          "[Added Lines]",
          "44:                     LOGGER.log(Level.FINE, \"Failed to close \" + s, e);",
          "48:         } else {",
          "50:         }",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java||src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java -> src/main/java/org/jenkinsci/remoting/nio/FifoBuffer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:         }",
          "58:         Pointer copy() {",
          "60:         }",
          "62:         void forward(int offset) {",
          "66:                 offset -= ch;",
          "67:                 off += ch;",
          "68:             }",
          "",
          "[Removed Lines]",
          "59:             return new Pointer(p,off);",
          "63:             while (offset>0) {",
          "64:                 int ch = Math.min(offset,chunk());",
          "65:                 assert 0<ch && ch<=offset;",
          "",
          "[Added Lines]",
          "59:             return new Pointer(p, off);",
          "63:             while (offset > 0) {",
          "64:                 int ch = Math.min(offset, chunk());",
          "65:                 assert 0 < ch && ch <= offset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         private int chunk() {",
          "80:             Page q = p.next;",
          "82:                 q = p.next = newPage();",
          "83:             p = q;",
          "84:             off = 0;",
          "85:             return pageSize;",
          "86:         }",
          "88:         public void write(ByteBuffer buf, int len) {",
          "91:                 buf.get(p.buf, off, chunk);",
          "95:             }",
          "96:         }",
          "98:         public void write(byte[] buf, int start, int len) {",
          "106:             }",
          "107:         }",
          "109:         public void read(byte[] buf, int start, int len) {",
          "122:             }",
          "123:         }",
          "",
          "[Removed Lines]",
          "75:             int sz = pageSize-off;",
          "76:             assert sz>=0;",
          "78:             if (sz>0)   return sz;",
          "81:             if (q==null)",
          "89:             while (len>0) {",
          "90:                 int chunk = Math.min(len,chunk());",
          "93:                 off+=chunk;",
          "94:                 len-=chunk;",
          "99:             while (len>0) {",
          "100:                 int chunk = Math.min(len,chunk());",
          "101:                 System.arraycopy(buf,start,p.buf,off,chunk);",
          "103:                 off+=chunk;",
          "104:                 len-=chunk;",
          "105:                 start+=chunk;",
          "110:             while (len>0) {",
          "111:                 int chunk = Math.min(len,chunk());",
          "112:                 assert off+chunk <= p.buf.length;",
          "113:                 assert start+chunk <= buf.length;",
          "114:                 assert off>=0;",
          "115:                 assert start>=0;",
          "116:                 assert chunk>=0;",
          "117:                 System.arraycopy(p.buf,off,buf,start,chunk);",
          "119:                 off+=chunk;",
          "120:                 len-=chunk;",
          "121:                 start+=chunk;",
          "",
          "[Added Lines]",
          "75:             int sz = pageSize - off;",
          "76:             assert sz >= 0;",
          "78:             if (sz > 0) {",
          "79:                 return sz;",
          "80:             }",
          "83:             if (q == null) {",
          "85:             }",
          "92:             while (len > 0) {",
          "93:                 int chunk = Math.min(len, chunk());",
          "96:                 off += chunk;",
          "97:                 len -= chunk;",
          "102:             while (len > 0) {",
          "103:                 int chunk = Math.min(len, chunk());",
          "104:                 System.arraycopy(buf, start, p.buf, off, chunk);",
          "106:                 off += chunk;",
          "107:                 len -= chunk;",
          "108:                 start += chunk;",
          "113:             while (len > 0) {",
          "114:                 int chunk = Math.min(len, chunk());",
          "115:                 assert off + chunk <= p.buf.length;",
          "116:                 assert start + chunk <= buf.length;",
          "117:                 assert off >= 0;",
          "118:                 assert start >= 0;",
          "119:                 assert chunk >= 0;",
          "120:                 System.arraycopy(p.buf, off, buf, start, chunk);",
          "122:                 off += chunk;",
          "123:                 len -= chunk;",
          "124:                 start += chunk;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:         private ByteBuffer asBuffer(int max) {",
          "131:         }",
          "133:         public int send(WritableByteChannel ch, int max) throws IOException {",
          "134:             int n = ch.write(asBuffer(max));",
          "136:             return n;",
          "137:         }",
          "139:         public int receive(ReadableByteChannel ch, int max) throws IOException {",
          "140:             int n = ch.read(asBuffer(max));",
          "142:             return n;",
          "143:         }",
          "144:     }",
          "",
          "[Removed Lines]",
          "129:             int ch = chunk();   // this needs to be done first",
          "130:             return ByteBuffer.wrap(p.buf,off,Math.min(ch,max));",
          "135:             off+=n;",
          "141:             if (n>=0)   off+=n;",
          "",
          "[Added Lines]",
          "132:             int ch = chunk(); // this needs to be done first",
          "133:             return ByteBuffer.wrap(p.buf, off, Math.min(ch, max));",
          "138:             off += n;",
          "144:             if (n >= 0) {",
          "145:                 off += n;",
          "146:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:     @GuardedBy(\"lock\")",
          "156:     private int limit;",
          "157:     private final int pageSize;",
          "",
          "[Removed Lines]",
          "162:     private Pointer r,w;",
          "",
          "[Added Lines]",
          "168:     private Pointer r, w;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "179:     private boolean closeRequested = false;",
          "181:     public FifoBuffer(int pageSize, int limit) {",
          "183:     }",
          "185:     public FifoBuffer(int limit) {",
          "187:     }",
          "189:     public FifoBuffer(Object lock, int pageSize, int limit) {",
          "191:         this.limit = limit;",
          "192:         this.pageSize = pageSize;",
          "194:         Page p = newPage();",
          "197:     }",
          "",
          "[Removed Lines]",
          "182:         this(null,pageSize,limit);",
          "186:         this(Math.max(limit/256,1024),limit);",
          "190:         this.lock = lock==null ? this : lock;",
          "195:         r = new Pointer(p,0);",
          "196:         w = new Pointer(p,0);",
          "",
          "[Added Lines]",
          "188:         this(null, pageSize, limit);",
          "192:         this(Math.max(limit / 256, 1024), limit);",
          "196:         this.lock = lock == null ? this : lock;",
          "201:         r = new Pointer(p, 0);",
          "202:         w = new Pointer(p, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223:     public int readable() {",
          "224:         synchronized (lock) {",
          "227:             return 0;",
          "228:         }",
          "229:     }",
          "237:     public int writable() {",
          "240:         }",
          "241:     }",
          "",
          "[Removed Lines]",
          "225:             if (sz>0)   return sz;",
          "226:             if (closed) return -1;",
          "238:         synchronized(lock) {",
          "239:             return Math.max(0,limit-readable());",
          "",
          "[Added Lines]",
          "231:             if (sz > 0) {",
          "232:                 return sz;",
          "233:             }",
          "234:             if (closed) {",
          "235:                 return -1;",
          "236:             }",
          "248:         synchronized (lock) {",
          "249:             return Math.max(0, limit - readable());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "272:     public int send(WritableByteChannel ch) throws IOException {",
          "275:         while (true) {",
          "276:             synchronized (lock) {",
          "277:                 int chunk = readable();",
          "283:                     if (closeRequested) { // Somebody requested the close operation in parallel thread",
          "284:                         handleCloseRequest();",
          "286:                     }",
          "288:                 }",
          "289:                 try {",
          "292:                     read += sent;",
          "293:                     sz -= sent;",
          "295:                     lock.notifyAll();",
          "298:                         return read;",
          "299:                 } catch (ClosedChannelException e) {",
          "301:                     close();",
          "",
          "[Removed Lines]",
          "273:         int read = 0;   // total # of bytes read",
          "278:                 if (chunk<=0) {",
          "281:                     if (read>0)     return read;    // we've already read some",
          "285:                         return -1;  // no more data",
          "287:                     return 0;   // no data to read",
          "290:                     int sent = r.send(ch, chunk);  // bytes actually written",
          "297:                     if (sent == 0)    // channel filled up",
          "",
          "[Added Lines]",
          "283:         int read = 0; // total # of bytes read",
          "288:                 if (chunk <= 0) {",
          "291:                     if (read > 0) {",
          "292:                         return read; // we've already read some",
          "293:                     }",
          "297:                         return -1; // no more data",
          "299:                     return 0; // no data to read",
          "302:                     int sent = r.send(ch, chunk); // bytes actually written",
          "309:                     if (sent == 0) { // channel filled up",
          "311:                     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "315:     public int writeNonBlock(ByteBuffer buf) {",
          "316:         synchronized (lock) {",
          "322:             sz += chunk;",
          "",
          "[Removed Lines]",
          "317:             int chunk = Math.min(buf.remaining(),writable());",
          "318:             if (chunk==0)   return 0;",
          "320:             w.write(buf,chunk);",
          "",
          "[Added Lines]",
          "329:             int chunk = Math.min(buf.remaining(), writable());",
          "330:             if (chunk == 0) {",
          "331:                 return 0;",
          "332:             }",
          "334:             w.write(buf, chunk);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "338:     public int receive(ReadableByteChannel ch) throws IOException {",
          "340:             throw new IOException(\"already closed\");",
          "342:         int written = 0;",
          "343:         while (true) {",
          "344:             synchronized (lock) {",
          "345:                 int chunk = writable();",
          "347:                     return written; // no more space to write",
          "",
          "[Removed Lines]",
          "339:         if (closed)",
          "346:                 if (chunk==0)",
          "",
          "[Added Lines]",
          "353:         if (closed) {",
          "355:         }",
          "361:                 if (chunk == 0) {",
          "363:                 }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "355:                 try {",
          "356:                     int received = w.receive(ch, chunk);",
          "358:                         return written; // channel is fully drained",
          "361:                         return written;",
          "362:                     }",
          "",
          "[Removed Lines]",
          "357:                     if (received==0)",
          "359:                     if (received==-1) {",
          "360:                         if (written==0)     return -1; // propagate EOF",
          "",
          "[Added Lines]",
          "373:                     if (received == 0) {",
          "375:                     }",
          "376:                     if (received == -1) {",
          "377:                         if (written == 0) {",
          "378:                             return -1; // propagate EOF",
          "379:                         }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "366:                 } catch (ClosedChannelException e) {",
          "368:                     close();",
          "370:                     return written;",
          "371:                 }",
          "373:                 lock.notifyAll();",
          "375:             }",
          "376:         }",
          "377:     }",
          "379:     public void write(byte[] buf) throws InterruptedException, IOException {",
          "381:     }",
          "383:     public void write(byte[] buf, int start, int len) throws InterruptedException, IOException {",
          "385:             throw new IOException(\"already closed\");",
          "388:             int chunk;",
          "390:             synchronized (lock) {",
          "392:                     if (closeRequested) {",
          "393:                         handleCloseRequest();",
          "394:                         throw new IOException(\"closed during write() operation\");",
          "",
          "[Removed Lines]",
          "369:                     if (written == 0) return -1; // propagate EOF",
          "380:         write(buf,0,buf.length);",
          "384:         if (closed)",
          "387:         while (len>0) {",
          "391:                 while ((chunk = Math.min(len,writable()))==0) {",
          "",
          "[Added Lines]",
          "388:                     if (written == 0) {",
          "389:                         return -1; // propagate EOF",
          "390:                     }",
          "400:         write(buf, 0, buf.length);",
          "404:         if (closed) {",
          "406:         }",
          "408:         while (len > 0) {",
          "412:                 while ((chunk = Math.min(len, writable())) == 0) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "450:     private void releaseRing() {",
          "452:             r = w = null;",
          "453:     }",
          "",
          "[Removed Lines]",
          "451:         if (readable()<0)",
          "",
          "[Added Lines]",
          "472:         if (readable() < 0) {",
          "474:         }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "463:     public int peek(int offset, byte[] data, int start, int len) {",
          "464:         synchronized (lock) {",
          "468:             Pointer v = this.r.copy();",
          "469:             v.forward(offset);",
          "471:             return len;",
          "472:         }",
          "473:     }",
          "475:     public int peek(int offset, byte[] data) {",
          "477:     }",
          "479:     public int read(byte[] buf) throws InterruptedException {",
          "481:     }",
          "",
          "[Removed Lines]",
          "465:             len = Math.min(len, readable()-offset); // can't read beyond the end of the readable buffer",
          "466:             if (len<=0) return 0;",
          "470:             v.read(data,start,len);",
          "476:         return peek(offset,data,0,data.length);",
          "480:         return read(buf,0,buf.length);",
          "",
          "[Added Lines]",
          "487:             len = Math.min(len, readable() - offset); // can't read beyond the end of the readable buffer",
          "488:             if (len <= 0) {",
          "489:                 return 0;",
          "490:             }",
          "494:             v.read(data, start, len);",
          "500:         return peek(offset, data, 0, data.length);",
          "504:         return read(buf, 0, buf.length);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "487:     public int read(byte[] buf, int start, int len) throws InterruptedException {",
          "489:         synchronized (lock) {",
          "490:             while (true) {",
          "494:             }",
          "495:         }",
          "496:     }",
          "",
          "[Removed Lines]",
          "488:         if (len==0)     return 0;   // the only case where we can legally return 0",
          "491:                 int r = readNonBlocking(buf,start,len);",
          "492:                 if (r!=0)   return r;",
          "493:                 lock.wait();    // wait until the writer gives us something",
          "",
          "[Added Lines]",
          "512:         if (len == 0) {",
          "513:             return 0; // the only case where we can legally return 0",
          "514:         }",
          "517:                 int r = readNonBlocking(buf, start, len);",
          "518:                 if (r != 0) {",
          "519:                     return r;",
          "520:                 }",
          "521:                 lock.wait(); // wait until the writer gives us something",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "506:     public int readNonBlocking(byte[] buf, int start, int len) {",
          "511:         while (true) {",
          "512:             int chunk;",
          "514:             synchronized (lock) {",
          "515:                 while (true) {",
          "523:                     if (closeRequested) {",
          "524:                         handleCloseRequest();",
          "526:                     }",
          "528:                     return 0; // nothing to read",
          "529:                 }",
          "533:                 start += chunk;",
          "534:                 len -= chunk;",
          "",
          "[Removed Lines]",
          "507:         if (len==0)     return 0;",
          "509:         int read = 0;   // total # of bytes read",
          "516:                     chunk = Math.min(len,readable());",
          "517:                     if (chunk>0)    break;",
          "521:                     if (read>0)     return read;    // we've already read some",
          "525:                         return -1;  // no more data",
          "531:                 r.read(buf,start,chunk);",
          "",
          "[Added Lines]",
          "535:         if (len == 0) {",
          "536:             return 0;",
          "537:         }",
          "539:         int read = 0; // total # of bytes read",
          "546:                     chunk = Math.min(len, readable());",
          "547:                     if (chunk > 0) {",
          "548:                         break;",
          "549:                     }",
          "553:                     if (read > 0) {",
          "554:                         return read; // we've already read some",
          "555:                     }",
          "559:                         return -1; // no more data",
          "565:                 r.read(buf, start, chunk);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "548:             @Override",
          "549:             public void write(int b) throws IOException {",
          "550:                 try {",
          "552:                     FifoBuffer.this.write(buf);",
          "553:                 } catch (InterruptedException e) {",
          "554:                     Thread.currentThread().interrupt();",
          "556:                 }",
          "557:             }",
          "559:             @Override",
          "560:             public void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "561:                 try {",
          "563:                 } catch (InterruptedException e) {",
          "564:                     Thread.currentThread().interrupt();",
          "566:                 }",
          "567:             }",
          "",
          "[Removed Lines]",
          "551:                     byte[] buf = new byte[]{(byte)b};",
          "555:                     throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "562:                     FifoBuffer.this.write(b,off,len);",
          "565:                     throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "",
          "[Added Lines]",
          "585:                     byte[] buf = new byte[] {(byte) b};",
          "589:                     throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "596:                     FifoBuffer.this.write(b, off, len);",
          "599:                     throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "583:                 try {",
          "584:                     byte[] b = new byte[1];",
          "585:                     int n = FifoBuffer.this.read(b);",
          "589:                 } catch (InterruptedException e) {",
          "590:                     Thread.currentThread().interrupt();",
          "592:                 }",
          "593:             }",
          "",
          "[Removed Lines]",
          "586:                     if (n<0)    return -1;",
          "587:                     if (n==0)   throw new AssertionError();",
          "588:                     return ((int)b[0])&0xFF;",
          "591:                     throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "",
          "[Added Lines]",
          "620:                     if (n < 0) {",
          "621:                         return -1;",
          "622:                     }",
          "623:                     if (n == 0) {",
          "624:                         throw new AssertionError();",
          "625:                     }",
          "626:                     return ((int) b[0]) & 0xFF;",
          "629:                     throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "598:                     return FifoBuffer.this.read(b, off, len);",
          "599:                 } catch (InterruptedException e) {",
          "600:                     Thread.currentThread().interrupt();",
          "602:                 }",
          "603:             }",
          "604:         };",
          "",
          "[Removed Lines]",
          "601:                     throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "",
          "[Added Lines]",
          "639:                     throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java||src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java -> src/main/java/org/jenkinsci/remoting/nio/NioChannelBuilder.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:         this.r = r;",
          "41:         this.w = w;",
          "42:         return super.build(",
          "45:     }",
          "47:     @Override",
          "48:     public Channel build(Socket s) throws IOException {",
          "49:         SocketChannel ch = s.getChannel();",
          "52:         return build(ch);",
          "53:     }",
          "56:     @Override",
          "57:     public NioChannelBuilder withBaseLoader(ClassLoader base) {",
          "59:     }",
          "61:     @Override",
          "62:     public NioChannelBuilder withMode(Channel.Mode mode) {",
          "64:     }",
          "66:     @Override",
          "",
          "[Removed Lines]",
          "43:                 Channels.newInputStream((ReadableByteChannel)r),",
          "44:                 Channels.newOutputStream((WritableByteChannel)w));",
          "50:         if (ch==null)",
          "51:             throw new IllegalArgumentException(s+\" doesn't have a channel\");",
          "58:         return (NioChannelBuilder)super.withBaseLoader(base);",
          "63:         return (NioChannelBuilder)super.withMode(mode);",
          "",
          "[Added Lines]",
          "43:                 Channels.newInputStream((ReadableByteChannel) r), Channels.newOutputStream((WritableByteChannel) w));",
          "49:         if (ch == null) {",
          "50:             throw new IllegalArgumentException(s + \" doesn't have a channel\");",
          "51:         }",
          "57:         return (NioChannelBuilder) super.withBaseLoader(base);",
          "62:         return (NioChannelBuilder) super.withMode(mode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     @Override",
          "92:     public NioChannelBuilder withClassFilter(ClassFilter filter) {",
          "94:     }",
          "95: }",
          "",
          "[Removed Lines]",
          "93:         return (NioChannelBuilder)super.withClassFilter(filter);",
          "",
          "[Added Lines]",
          "92:         return (NioChannelBuilder) super.withClassFilter(filter);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java||src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java -> src/main/java/org/jenkinsci/remoting/nio/NioChannelHub.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:     private int transportFrameSize = 8192;",
          "57:     private final SelectableFileChannelFactory factory = new SelectableFileChannelFactory();",
          "",
          "[Removed Lines]",
          "62:     private final Queue<Callable<Void,IOException>> selectorTasks",
          "63:             = new ConcurrentLinkedQueue<>();",
          "",
          "[Added Lines]",
          "63:     private final Queue<Callable<Void, IOException>> selectorTasks = new ConcurrentLinkedQueue<>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:         @CheckForNull",
          "115:         private AbstractByteArrayCommandTransport.ByteArrayReceiver receiver = null;",
          "",
          "[Removed Lines]",
          "108:         final FifoBuffer rb = new FifoBuffer(16*1024, Integer.MAX_VALUE);",
          "112:         final FifoBuffer wb = new FifoBuffer(16*1024,256*1024);",
          "",
          "[Added Lines]",
          "108:         final FifoBuffer rb = new FifoBuffer(16 * 1024, Integer.MAX_VALUE);",
          "112:         final FifoBuffer wb = new FifoBuffer(16 * 1024, 256 * 1024);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:         boolean wantsToRead() {",
          "151:         }",
          "",
          "[Removed Lines]",
          "150:             return receiver!=null && rb.writable()!=0;",
          "",
          "[Added Lines]",
          "150:             return receiver != null && rb.writable() != 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "157:         boolean wantsToWrite() {",
          "159:         }",
          "",
          "[Removed Lines]",
          "158:             return wb.readable()!=0;",
          "",
          "[Added Lines]",
          "158:             return wb.readable() != 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:         @SelectorThreadOnly",
          "187:         protected final void cancelKey(SelectionKey key) {",
          "189:                 key.cancel();",
          "190:         }",
          "192:         protected Channel getChannel() {",
          "193:             return channel;",
          "194:         }",
          "197:         @SelectorThreadOnly",
          "198:         public void abort(Throwable e) {",
          "199:             try {",
          "",
          "[Removed Lines]",
          "188:             if (key!=null)",
          "",
          "[Added Lines]",
          "188:             if (key != null) {",
          "190:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "209:             if (receiver == null) {",
          "210:                 throw new IllegalStateException(\"Aborting connection before it has been actually set up\");",
          "211:             }",
          "213:         }",
          "215:         @Override",
          "",
          "[Removed Lines]",
          "212:             receiver.terminate(new IOException(\"Connection aborted: \"+this, e));",
          "",
          "[Added Lines]",
          "213:             receiver.terminate(new IOException(\"Connection aborted: \" + this, e));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "221:                     int frame = Math.min(transportFrameSize, bytes.length - pos); // # of bytes we send in this chunk",
          "222:                     hasMore = frame + pos < bytes.length;",
          "223:                     wb.write(ChunkHeader.pack(frame, hasMore));",
          "225:                     scheduleReregister();",
          "228:             } catch (InterruptedException e) {",
          "229:                 Thread.currentThread().interrupt();",
          "231:             }",
          "232:         }",
          "234:         @Override",
          "235:         public void setup(AbstractByteArrayCommandTransport.ByteArrayReceiver receiver) {",
          "236:             this.receiver = receiver;",
          "238:         }",
          "240:         @Override",
          "",
          "[Removed Lines]",
          "224:                     wb.write(bytes,pos,frame);",
          "226:                     pos+=frame;",
          "227:                 } while(hasMore);",
          "230:                 throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "237:             scheduleReregister();   // ready to read bytes now",
          "",
          "[Added Lines]",
          "225:                     wb.write(bytes, pos, frame);",
          "227:                     pos += frame;",
          "228:                 } while (hasMore);",
          "231:                 throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "238:             scheduleReregister(); // ready to read bytes now",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "269:         @Override",
          "270:         public String toString() {",
          "272:         }",
          "273:     }",
          "",
          "[Removed Lines]",
          "271:             return super.toString()+\"[name=\"+name+\"]\";",
          "",
          "[Added Lines]",
          "272:             return super.toString() + \"[name=\" + name + \"]\";",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "287:         MonoNioTransport(String name, SelectableChannel ch, Capability remoteCapability) {",
          "290:             this.ch = ch;",
          "291:             this.rc = Closeables.input(ch);",
          "",
          "[Removed Lines]",
          "285:         Closeable rc,wc;",
          "288:             super(name,remoteCapability);",
          "",
          "[Added Lines]",
          "286:         Closeable rc, wc;",
          "289:             super(name, remoteCapability);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "295:         @Override",
          "296:         ReadableByteChannel rr() {",
          "298:         }",
          "300:         @Override",
          "301:         WritableByteChannel ww() {",
          "303:         }",
          "305:         @Override",
          "306:         boolean isWopen() {",
          "308:         }",
          "310:         @Override",
          "311:         boolean isRopen() {",
          "313:         }",
          "315:         @Override",
          "",
          "[Removed Lines]",
          "297:             return (ReadableByteChannel)ch;",
          "302:             return (WritableByteChannel)ch;",
          "307:             return wc!=null;",
          "312:             return rc!=null;",
          "",
          "[Added Lines]",
          "298:             return (ReadableByteChannel) ch;",
          "303:             return (WritableByteChannel) ch;",
          "308:             return wc != null;",
          "313:             return rc != null;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "326:         @Override",
          "327:         @SelectorThreadOnly",
          "328:         void closeW() throws IOException {",
          "330:                 wc.close();",
          "331:                 wc = null;",
          "332:                 wb.close(); // wb will not accept incoming data any more",
          "",
          "[Removed Lines]",
          "329:             if (wc!=null) {",
          "",
          "[Added Lines]",
          "330:             if (wc != null) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "337:         @Override",
          "338:         @SelectorThreadOnly",
          "339:         public void reregister() throws IOException {",
          "341:             if (ch.isOpen()) {",
          "342:                 ch.configureBlocking(false);",
          "343:                 ch.register(selector, flag).attach(this);",
          "",
          "[Removed Lines]",
          "340:             int flag = (wantsToWrite() && isWopen() ? SelectionKey.OP_WRITE : 0) + (wantsToRead() && isRopen() ? SelectionKey.OP_READ : 0);",
          "",
          "[Added Lines]",
          "341:             int flag = (wantsToWrite() && isWopen() ? SelectionKey.OP_WRITE : 0)",
          "342:                     + (wantsToRead() && isRopen() ? SelectionKey.OP_READ : 0);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "350:         @SelectorThreadOnly",
          "351:         private void maybeCancelKey() throws IOException {",
          "352:             SelectionKey key = ch.keyFor(selector);",
          "355:                 cancelKey(key);",
          "356:             } else {",
          "358:             }",
          "359:         }",
          "361:     }",
          "366:     class DualNioTransport extends NioTransport {",
          "369:         DualNioTransport(String name, SelectableChannel r, SelectableChannel w, Capability remoteCapability) {",
          "372:             assert r instanceof ReadableByteChannel && w instanceof WritableByteChannel;",
          "373:             this.r = r;",
          "",
          "[Removed Lines]",
          "353:             if (rc==null && wc==null) {",
          "357:                reregister();",
          "367:         private final SelectableChannel r,w;",
          "370:             super(name,remoteCapability);",
          "",
          "[Added Lines]",
          "355:             if (rc == null && wc == null) {",
          "359:                 reregister();",
          "368:         private final SelectableChannel r, w;",
          "371:             super(name, remoteCapability);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "427:         @SelectorThreadOnly",
          "428:         private void cancelKey(SelectableChannel c) {",
          "430:             cancelKey(c.keyFor(selector));",
          "431:         }",
          "432:     }",
          "",
          "[Removed Lines]",
          "429:             assert c==r || c==w;",
          "",
          "[Added Lines]",
          "430:             assert c == r || c == w;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "444:     }",
          "446:     public void setFrameSize(int sz) {",
          "448:         this.transportFrameSize = sz;",
          "449:     }",
          "",
          "[Removed Lines]",
          "447:         assert 0<sz && sz<=Short.MAX_VALUE;",
          "",
          "[Added Lines]",
          "447:         assert 0 < sz && sz <= Short.MAX_VALUE;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "458:     public NioChannelBuilder newChannelBuilder(String name, ExecutorService es) {",
          "462:             @Override",
          "467:                 if (r != null && w != null && mode == Channel.Mode.BINARY && cap.supportsChunking() && !disableNio) {",
          "468:                     try {",
          "472:                         synchronized (startedLock) {",
          "474:                                 startedLock.wait();",
          "475:                         }",
          "476:                     } catch (InterruptedException e) {",
          "477:                         Thread.currentThread().interrupt();",
          "479:                     }",
          "481:                     ensureValid();",
          "483:                     NioTransport t;",
          "486:                     t.scheduleReregister();",
          "487:                     return t;",
          "488:                 } else {",
          "",
          "[Removed Lines]",
          "459:         return new NioChannelBuilder(name,es) {",
          "463:             protected CommandTransport makeTransport(InputStream is, OutputStream os, Channel.Mode mode, Capability cap) throws IOException {",
          "464:                 if (r==null)    r = factory.create(is);",
          "465:                 if (w==null)    w = factory.create(os);",
          "466:                 boolean disableNio = Boolean.getBoolean(NioChannelHub.class.getName()+\".disabled\");",
          "473:                             while (!started)",
          "478:                         throw (InterruptedIOException)new InterruptedIOException().initCause(e);",
          "484:                     if (r==w)       t = new MonoNioTransport(getName(),r,cap);",
          "485:                     else            t = new DualNioTransport(getName(),r,w,cap);",
          "",
          "[Added Lines]",
          "459:         return new NioChannelBuilder(name, es) {",
          "463:             protected CommandTransport makeTransport(InputStream is, OutputStream os, Channel.Mode mode, Capability cap)",
          "464:                     throws IOException {",
          "465:                 if (r == null) {",
          "466:                     r = factory.create(is);",
          "467:                 }",
          "468:                 if (w == null) {",
          "469:                     w = factory.create(os);",
          "470:                 }",
          "471:                 boolean disableNio = Boolean.getBoolean(NioChannelHub.class.getName() + \".disabled\");",
          "478:                             while (!started) {",
          "480:                             }",
          "484:                         throw (InterruptedIOException) new InterruptedIOException().initCause(e);",
          "490:                     if (r == w) {",
          "491:                         t = new MonoNioTransport(getName(), r, cap);",
          "492:                     } else {",
          "493:                         t = new DualNioTransport(getName(), r, w, cap);",
          "494:                     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "516:         @Override",
          "517:         public Void call() throws IOException {",
          "518:             if (task == null) {",
          "520:             }",
          "521:             try {",
          "522:                 return task.call();",
          "",
          "[Removed Lines]",
          "519:                 throw new IOException(\"The callable \" + this + \" has been serialized somehow, but it is actually not serializable\");",
          "",
          "[Added Lines]",
          "528:                 throw new IOException(",
          "529:                         \"The callable \" + this + \" has been serialized somehow, but it is actually not serializable\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "568:                 try {",
          "569:                     while (true) {",
          "570:                         Callable<Void, IOException> t = selectorTasks.poll();",
          "572:                         try {",
          "573:                             t.call();",
          "574:                         } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "571:                         if (t==null)    break;",
          "",
          "[Added Lines]",
          "581:                         if (t == null) {",
          "582:                             break;",
          "583:                         }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "577:                         }",
          "578:                     }",
          "581:                     selector.select();",
          "582:                 } catch (IOException e) {",
          "583:                     whatKilledSelectorThread = e;",
          "",
          "[Removed Lines]",
          "580:                     selectorThread.setName(\"NioChannelHub keys=\" + selector.keys().size() + \" gen=\" + (gen++) + \": \" + oldName);",
          "",
          "[Added Lines]",
          "592:                     selectorThread.setName(",
          "593:                             \"NioChannelHub keys=\" + selector.keys().size() + \" gen=\" + (gen++) + \": \" + oldName);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "602:                                 }",
          "604:                                 final byte[] buf = new byte[ChunkHeader.SIZE];",
          "607:                                 while (true) {",
          "610:                                     int header = ChunkHeader.parse(buf);",
          "611:                                     int chunk = ChunkHeader.length(header);",
          "614:                                     boolean last = ChunkHeader.isLast(header);",
          "617:                                         final byte[] packet = new byte[packetSize];",
          "618:                                         int r_ptr = 0;",
          "619:                                         do {",
          "620:                                             int r = t.rb.readNonBlocking(buf);",
          "622:                                             header = ChunkHeader.parse(buf);",
          "623:                                             chunk = ChunkHeader.length(header);",
          "624:                                             last = ChunkHeader.isLast(header);",
          "625:                                             t.rb.readNonBlocking(packet, r_ptr, chunk);",
          "628:                                         } while (!last);",
          "630:                                         if (packet.length > 0) {",
          "631:                                             ExecutorServiceUtils.submitAsync(t.swimLane, () -> {",
          "633:                                                 if (receiver == null) {",
          "635:                                                 }",
          "636:                                                 receiver.handle(packet);",
          "637:                                             });",
          "638:                                         }",
          "640:                                     }",
          "641:                                 }",
          "645:                                     LOGGER.log(Level.WARNING, msg);",
          "647:                                     t.abort(new IOException(msg));",
          "648:                                 }",
          "649:                                 if (t.rb.isClosed()) {",
          "651:                                     ExecutorServiceUtils.submitAsync(t.swimLane, () -> {",
          "653:                                         if (!t.getChannel().isInClosed()) {",
          "656:                                         }",
          "657:                                     });",
          "658:                                 }",
          "659:                             }",
          "660:                             if (key.isValid() && key.isWritable()) {",
          "661:                                 t.wb.send(t.ww());",
          "664:                                     t.closeW();",
          "665:                                 }",
          "",
          "[Removed Lines]",
          "605:                                 int pos=0;",
          "606:                                 int packetSize=0;",
          "608:                                     if (t.rb.peek(pos,buf)<ChunkHeader.SIZE)",
          "609:                                         break;  // we don't have enough to parse header",
          "612:                                     pos+=ChunkHeader.SIZE+chunk;",
          "613:                                     packetSize+=chunk;",
          "615:                                     if (last && pos<=t.rb.readable()) {// do we have the whole packet in our buffer?",
          "621:                                             assert r==ChunkHeader.SIZE;",
          "626:                                             packetSize-=chunk;",
          "627:                                             r_ptr+=chunk;",
          "629:                                         assert packetSize==0;",
          "632:                                                 final AbstractByteArrayCommandTransport.ByteArrayReceiver receiver = t.receiver;",
          "634:                                                     throw new IllegalStateException(\"NIO transport layer has not been set up yet\");",
          "639:                                         pos=0;",
          "643:                                 if (t.rb.writable()==0 && t.rb.readable()>0) {",
          "644:                                     String msg = \"Command buffer overflow. Read \" + t.rb.readable() + \" bytes but still too small for a single command\";",
          "654:                                             t.getChannel().terminate(new IOException(\"Unexpected EOF while receiving the data from the channel. \"",
          "655:                                                     + \"FIFO buffer has been already closed\", t.rb.getCloseCause()));",
          "662:                                 if (t.wb.readable()<0) {",
          "",
          "[Added Lines]",
          "618:                                 int pos = 0;",
          "619:                                 int packetSize = 0;",
          "621:                                     if (t.rb.peek(pos, buf) < ChunkHeader.SIZE) {",
          "622:                                         break; // we don't have enough to parse header",
          "623:                                     }",
          "626:                                     pos += ChunkHeader.SIZE + chunk;",
          "627:                                     packetSize += chunk;",
          "629:                                     if (last && pos <= t.rb.readable()) { // do we have the whole packet in our buffer?",
          "635:                                             assert r == ChunkHeader.SIZE;",
          "640:                                             packetSize -= chunk;",
          "641:                                             r_ptr += chunk;",
          "643:                                         assert packetSize == 0;",
          "646:                                                 final AbstractByteArrayCommandTransport.ByteArrayReceiver receiver =",
          "647:                                                         t.receiver;",
          "649:                                                     throw new IllegalStateException(",
          "650:                                                             \"NIO transport layer has not been set up yet\");",
          "655:                                         pos = 0;",
          "659:                                 if (t.rb.writable() == 0 && t.rb.readable() > 0) {",
          "660:                                     String msg = \"Command buffer overflow. Read \" + t.rb.readable()",
          "661:                                             + \" bytes but still too small for a single command\";",
          "672:                                             t.getChannel()",
          "673:                                                     .terminate(new IOException(",
          "674:                                                             \"Unexpected EOF while receiving the data from the channel. \"",
          "675:                                                                     + \"FIFO buffer has been already closed\",",
          "676:                                                             t.rb.getCloseCause()));",
          "683:                                 if (t.wb.readable() < 0) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "667:                             t.reregister();",
          "668:                         } catch (IOException e) {",
          "671:                             t.abort(e);",
          "672:                         } catch (ExecutorServiceUtils.ExecutionRejectedException e) {",
          "676:                             t.abort(e);",
          "677:                         } catch (CancelledKeyException e) {",
          "",
          "[Removed Lines]",
          "670:                             LOGGER.log(Level.SEVERE, \"Communication problem in \" + t + \". NIO Transport will be aborted.\", e);",
          "675:                             LOGGER.log(Level.SEVERE, \"The underlying executor service rejected the task in \" + t + \". NIO Transport will be aborted.\", e);",
          "681:                             LOGGER.log(Level.SEVERE, \"Unexpected key cancellation for \" + t + \". NIO Transport will be aborted.\", e);",
          "",
          "[Added Lines]",
          "691:                             LOGGER.log(",
          "692:                                     Level.SEVERE,",
          "693:                                     \"Communication problem in \" + t + \". NIO Transport will be aborted.\",",
          "694:                                     e);",
          "699:                             LOGGER.log(",
          "700:                                     Level.SEVERE,",
          "701:                                     \"The underlying executor service rejected the task in \" + t",
          "702:                                             + \". NIO Transport will be aborted.\",",
          "703:                                     e);",
          "709:                             LOGGER.log(",
          "710:                                     Level.SEVERE,",
          "711:                                     \"Unexpected key cancellation for \" + t + \". NIO Transport will be aborted.\",",
          "712:                                     e);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "701:         } finally {",
          "702:             selectorThread.setName(oldName);",
          "703:             selectorThread = null;",
          "705:                 whatKilledSelectorThread = new AssertionError(\"NioChannelHub shouldn't exit normally\");",
          "706:         }",
          "707:     }",
          "716:     @SelectorThreadOnly",
          "717:     private void abortAll(Throwable e) {",
          "718:         Set<NioTransport> pairs = new HashSet<>();",
          "722:             p.abort(e);",
          "723:     }",
          "725:     public Selector getSelector() {",
          "",
          "[Removed Lines]",
          "704:             if (whatKilledSelectorThread==null)",
          "712:     protected void onSelected(SelectionKey key) {",
          "714:     }",
          "719:         for (SelectionKey k : selector.keys())",
          "720:             pairs.add((NioTransport)k.attachment());",
          "721:         for (NioTransport p : pairs)",
          "",
          "[Added Lines]",
          "735:             if (whatKilledSelectorThread == null) {",
          "737:             }",
          "744:     protected void onSelected(SelectionKey key) {}",
          "749:         for (SelectionKey k : selector.keys()) {",
          "750:             pairs.add((NioTransport) k.attachment());",
          "751:         }",
          "752:         for (NioTransport p : pairs) {",
          "754:         }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "738:     public void ensureValid() throws IOException {",
          "741:     }",
          "743:     private static final Logger LOGGER = Logger.getLogger(NioChannelHub.class.getName());",
          "",
          "[Removed Lines]",
          "739:         if (selectorThread==null)",
          "740:             throw new IOException(\"NIO selector thread is not running\",whatKilledSelectorThread);",
          "",
          "[Added Lines]",
          "771:         if (selectorThread == null) {",
          "772:             throw new IOException(\"NIO selector thread is not running\", whatKilledSelectorThread);",
          "773:         }",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java||src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java -> src/main/java/org/jenkinsci/remoting/nio/SelectableFileChannelFactory.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: public class SelectableFileChannelFactory {",
          "48:     @CheckForNull",
          "49:     protected FileInputStream unwrap(InputStream i) {",
          "50:         if (i instanceof BufferedInputStream) {",
          "51:             try {",
          "52:                 Field $in = FilterInputStream.class.getDeclaredField(\"in\");",
          "53:                 $in.setAccessible(true);",
          "55:             } catch (NoSuchFieldException | IllegalAccessException e) {",
          "56:                 warn(e);",
          "57:                 return null;",
          "",
          "[Removed Lines]",
          "54:                 return unwrap((InputStream)$in.get(i));",
          "",
          "[Added Lines]",
          "54:                 return unwrap((InputStream) $in.get(i));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:         if (i instanceof FileInputStream) {",
          "61:             return (FileInputStream) i;",
          "62:         }",
          "64:     }",
          "66:     @CheckForNull",
          "",
          "[Removed Lines]",
          "63:         return null;    // unknown type",
          "",
          "[Added Lines]",
          "63:         return null; // unknown type",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69:             try {",
          "70:                 Field $in = FilterOutputStream.class.getDeclaredField(\"out\");",
          "71:                 $in.setAccessible(true);",
          "73:             } catch (NoSuchFieldException | IllegalAccessException e) {",
          "74:                 warn(e);",
          "75:                 return null;",
          "",
          "[Removed Lines]",
          "72:                 return unwrap((OutputStream)$in.get(i));",
          "",
          "[Added Lines]",
          "72:                 return unwrap((OutputStream) $in.get(i));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "78:         if (i instanceof FileOutputStream) {",
          "79:             return (FileOutputStream) i;",
          "80:         }",
          "82:     }",
          "84:     @CheckForNull",
          "",
          "[Removed Lines]",
          "81:         return null;    // unknown type",
          "",
          "[Added Lines]",
          "81:         return null; // unknown type",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "94:     @CheckForNull",
          "95:     public SocketChannel create(FileInputStream in) throws IOException {",
          "97:         return create(in.getFD());",
          "98:     }",
          "100:     @CheckForNull",
          "101:     public SocketChannel create(FileOutputStream out) throws IOException {",
          "103:         return create(out.getFD());",
          "104:     }",
          "113:     @CheckForNull",
          "114:     public SocketChannel create(FileDescriptor fd) {",
          "116:             return null; // not selectable on Windows",
          "118:         try {",
          "124:             $c.setAccessible(true);",
          "",
          "[Removed Lines]",
          "96:         if (in==null)   return null;",
          "102:         if (out==null)   return null;",
          "115:         if (File.pathSeparatorChar==';')",
          "119:             Constructor<?> $c = Class.forName(\"sun.nio.ch.SocketChannelImpl\").getDeclaredConstructor(",
          "120:                 SelectorProvider.class,",
          "121:                 FileDescriptor.class,",
          "122:                 InetSocketAddress.class",
          "123:             );",
          "",
          "[Added Lines]",
          "96:         if (in == null) {",
          "97:             return null;",
          "98:         }",
          "104:         if (out == null) {",
          "105:             return null;",
          "106:         }",
          "119:         if (File.pathSeparatorChar == ';') {",
          "121:         }",
          "124:             Constructor<?> $c = Class.forName(\"sun.nio.ch.SocketChannelImpl\")",
          "125:                     .getDeclaredConstructor(SelectorProvider.class, FileDescriptor.class, InetSocketAddress.class);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "128:             $m.setAccessible(true);",
          "129:             $m.invoke(fd);",
          "133:             warn(e);",
          "134:             return null;",
          "135:         }",
          "",
          "[Removed Lines]",
          "131:             return (SocketChannel)$c.newInstance(SelectorProvider.provider(), fd, null);",
          "132:         } catch (NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException e) {",
          "",
          "[Added Lines]",
          "133:             return (SocketChannel) $c.newInstance(SelectorProvider.provider(), fd, null);",
          "134:         } catch (NoSuchMethodException",
          "135:                 | SecurityException",
          "136:                 | ClassNotFoundException",
          "137:                 | IllegalAccessException",
          "138:                 | InvocationTargetException",
          "139:                 | InstantiationException e) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "138:     private void warn(Exception e) {",
          "139:         if (!warned) {",
          "140:             warned = true;",
          "142:         }",
          "143:     }",
          "",
          "[Removed Lines]",
          "141:             LOGGER.log(Level.WARNING, \"Failed to wrap aFileDescriptor into SocketChannel\",e);",
          "",
          "[Added Lines]",
          "148:             LOGGER.log(Level.WARNING, \"Failed to wrap aFileDescriptor into SocketChannel\", e);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java||src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java": [
          "File: src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java -> src/main/java/org/jenkinsci/remoting/nio/SelectorThreadOnly.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: @Target(ElementType.METHOD)",
          "20: @Retention(RetentionPolicy.SOURCE)",
          "",
          "[Removed Lines]",
          "21: @interface SelectorThreadOnly {",
          "22: }",
          "",
          "[Added Lines]",
          "21: @interface SelectorThreadOnly {}",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java": [
          "File: src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java -> src/main/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtils.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:         private static final long UNSIGNED_INT_MASK = 0x0FFFFFFFFL;",
          "46:         public int asInteger(final String address) {",
          "47:             return toInteger(address);",
          "",
          "[Removed Lines]",
          "43:         private SubnetInfo() {",
          "44:         }",
          "",
          "[Added Lines]",
          "43:         private SubnetInfo() {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:         private String format(final int[] octets) {",
          "58:             final int last = octets.length - 1;",
          "59:             final StringBuilder builder = new StringBuilder();",
          "61:                 builder.append(octets[i]);",
          "62:                 if (i == last) {",
          "63:                     return builder.toString();",
          "",
          "[Removed Lines]",
          "60:             for (int i = 0;; i++) {",
          "",
          "[Added Lines]",
          "59:             for (int i = 0; ; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215:         @Override",
          "216:         public String toString() {",
          "224:         }",
          "225:     }",
          "",
          "[Removed Lines]",
          "217:             return \"CIDR Signature:\\t[\" + getCidrSignature() + \"]\\n\" +",
          "218:                     \"  Netmask: [\" + getNetmask() + \"]\\n\" +",
          "219:                     \"  Network: [\" + getNetworkAddress() + \"]\\n\" +",
          "220:                     \"  Broadcast: [\" + getBroadcastAddress() + \"]\\n\" +",
          "221:                     \"  First address: [\" + getLowAddress() + \"]\\n\" +",
          "222:                     \"  Last address: [\" + getHighAddress() + \"]\\n\" +",
          "223:                     \"  Address Count: [\" + getAddressCountLong() + \"]\\n\";",
          "",
          "[Added Lines]",
          "216:             return \"CIDR Signature:\\t[\" + getCidrSignature() + \"]\\n\" + \"  Netmask: [\"",
          "217:                     + getNetmask() + \"]\\n\" + \"  Network: [\"",
          "218:                     + getNetworkAddress() + \"]\\n\" + \"  Broadcast: [\"",
          "219:                     + getBroadcastAddress() + \"]\\n\" + \"  First address: [\"",
          "220:                     + getLowAddress() + \"]\\n\" + \"  Last address: [\"",
          "221:                     + getHighAddress() + \"]\\n\" + \"  Address Count: [\"",
          "222:                     + getAddressCountLong() + \"]\\n\";",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java": [
          "File: src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java -> src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:     private static final long serialVersionUID = -919201640201914789L;",
          "57:     private static final int IPV6_MAX_HEX_GROUPS = 8;",
          "",
          "[Removed Lines]",
          "53:     private static final String IPV4_REGEX =",
          "54:             \"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\";",
          "",
          "[Added Lines]",
          "53:     private static final String IPV4_REGEX = \"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\";",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java||src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java": [
          "File: src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java -> src/main/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:             if (regexs[i] == null || regexs[i].isEmpty()) {",
          "134:                 throw new IllegalArgumentException(\"Regular expression[\" + i + \"] is missing\");",
          "135:             }",
          "137:         }",
          "138:     }",
          "",
          "[Removed Lines]",
          "136:             patterns[i] =  Pattern.compile(regexs[i], flags);",
          "",
          "[Added Lines]",
          "136:             patterns[i] = Pattern.compile(regexs[i], flags);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java||src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/ApplicationLayer.java"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/FilterLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:     protected final void abort(@NonNull IOException cause) {",
          "150:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "151:             LogRecord record = new LogRecord(Level.FINEST, \"[{0}] Aborted\");",
          "153:             record.setThrown(cause);",
          "154:             LOGGER.log(record);",
          "155:         }",
          "",
          "[Removed Lines]",
          "152:             record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "152:             record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:         } catch (IOException e) {",
          "167:             if (LOGGER.isLoggable(Level.FINE)) {",
          "168:                 LogRecord record = new LogRecord(Level.FINE, \"[{0}] Close notification only partially completed\");",
          "170:                 record.setThrown(e);",
          "171:                 LOGGER.log(record);",
          "172:             }",
          "",
          "[Removed Lines]",
          "169:                 record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "169:                 record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/IOHub.java||src/main/java/org/jenkinsci/remoting/protocol/IOHub.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/IOHub.java -> src/main/java/org/jenkinsci/remoting/protocol/IOHub.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "79:     private static final long SELECTOR_WAKEUP_TIMEOUT_MS = Long.getLong(IOHub.class.getName() + \".selectorWakeupTimeout\", 1000);",
          "",
          "[Added Lines]",
          "79:     private static final long SELECTOR_WAKEUP_TIMEOUT_MS =",
          "80:             Long.getLong(IOHub.class.getName() + \".selectorWakeupTimeout\", 1000);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:     public static IOHub create(Executor executor) throws IOException {",
          "152:         IOHub result = new IOHub(executor);",
          "153:         executor.execute(result);",
          "155:         executor.execute(new IOHubSelectorWatcher(result));",
          "156:         return result;",
          "157:     }",
          "",
          "[Removed Lines]",
          "154:         LOGGER.log(Level.FINE, \"Starting an additional Selector wakeup thread. See JENKINS-47965 for more information.\");",
          "",
          "[Added Lines]",
          "156:         LOGGER.log(",
          "157:                 Level.FINE, \"Starting an additional Selector wakeup thread. See JENKINS-47965 for more information.\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "374:         int ops = 0;",
          "375:         if (accept) {",
          "376:             ops |= SelectionKey.OP_ACCEPT;",
          "",
          "[Removed Lines]",
          "371:     public final void register(SelectableChannel channel, IOHubReadyListener listener, boolean accept, boolean connect,",
          "372:                                boolean read, boolean write,",
          "373:                                IOHubRegistrationCallback callback) {",
          "",
          "[Added Lines]",
          "374:     public final void register(",
          "375:             SelectableChannel channel,",
          "376:             IOHubReadyListener listener,",
          "377:             boolean accept,",
          "378:             boolean connect,",
          "379:             boolean read,",
          "380:             boolean write,",
          "381:             IOHubRegistrationCallback callback) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "405:         IOHubRegistrationFutureAdapterImpl callback = new IOHubRegistrationFutureAdapterImpl();",
          "406:         register(channel, listener, accept, connect, read, write, callback);",
          "407:         return callback.getFuture();",
          "",
          "[Removed Lines]",
          "403:     public final Future<SelectionKey> register(SelectableChannel channel, IOHubReadyListener listener, boolean accept,",
          "404:                                                boolean connect, boolean read, boolean write) {",
          "",
          "[Added Lines]",
          "411:     public final Future<SelectionKey> register(",
          "412:             SelectableChannel channel,",
          "413:             IOHubReadyListener listener,",
          "414:             boolean accept,",
          "415:             boolean connect,",
          "416:             boolean read,",
          "417:             boolean write) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "490:                     long sleepNanos = System.nanoTime() - cpuOverheatProtection;",
          "491:                     if (sleepNanos > 0) {",
          "492:                         if (LOGGER.isLoggable(Level.FINEST)) {",
          "494:                                     \"Sleeping for {0,number}ns to prevent selector thread CPU monopolization!\",",
          "495:                                     sleepNanos);",
          "496:                         }",
          "",
          "[Removed Lines]",
          "493:                             LOGGER.log(Level.FINEST,",
          "",
          "[Added Lines]",
          "507:                             LOGGER.log(",
          "508:                                     Level.FINEST,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "724:             this.ops = ops;",
          "725:             this.channel = channel;",
          "726:             this.listener = listener;",
          "",
          "[Removed Lines]",
          "722:         Registration(int ops, SelectableChannel channel, IOHubReadyListener listener,",
          "723:                      IOHubRegistrationCallback callback) {",
          "",
          "[Added Lines]",
          "736:         Registration(",
          "737:                 int ops, SelectableChannel channel, IOHubReadyListener listener, IOHubRegistrationCallback callback) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "733:         @Override",
          "734:         public String toString() {",
          "740:         }",
          "742:     }",
          "",
          "[Removed Lines]",
          "735:             return \"Registration{\" + \"ops=\" + ops +",
          "736:                     \", channel=\" + channel +",
          "737:                     \", listener=\" + listener +",
          "738:                     \", callback=\" + callback +",
          "739:                     '}';",
          "",
          "[Added Lines]",
          "749:             return \"Registration{\" + \"ops=\" + ops + \", channel=\"",
          "750:                     + channel + \", listener=\"",
          "751:                     + listener + \", callback=\"",
          "752:                     + callback + '}';",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "780:                 workerThread.setName(\"IOHub#\" + _id + \": Worker[channel:\" + key.channel() + \"] / \" + oldName);",
          "781:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "788:                 }",
          "790:                         (ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT,",
          "791:                         (ops & SelectionKey.OP_READ) == SelectionKey.OP_READ,",
          "792:                         (ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE);",
          "",
          "[Removed Lines]",
          "783:                     LOGGER.log(Level.FINEST, \"Calling listener.ready({0}, {1}, {2}, {3}) for channel {4}\",",
          "784:                             new Object[] { (ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT,",
          "785:                                     (ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT,",
          "786:                                     (ops & SelectionKey.OP_READ) == SelectionKey.OP_READ,",
          "787:                                     (ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE, key.channel() });",
          "789:                 listener.ready((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT,",
          "",
          "[Added Lines]",
          "795:                     LOGGER.log(",
          "796:                             Level.FINEST, \"Calling listener.ready({0}, {1}, {2}, {3}) for channel {4}\", new Object[] {",
          "797:                                 (ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT,",
          "798:                                 (ops & SelectionKey.OP_CONNECT) == SelectionKey.OP_CONNECT,",
          "799:                                 (ops & SelectionKey.OP_READ) == SelectionKey.OP_READ,",
          "800:                                 (ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE,",
          "801:                                 key.channel()",
          "802:                             });",
          "804:                 listener.ready(",
          "805:                         (ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "794:                 if (LOGGER.isLoggable(Level.SEVERE)) {",
          "795:                     LogRecord record = new LogRecord(Level.SEVERE, \"[{0}] Listener {1} propagated an uncaught {2}\");",
          "796:                     record.setThrown(e);",
          "798:                     LOGGER.log(record);",
          "799:                 }",
          "800:                 if (e instanceof Error) {",
          "802:                 }",
          "803:             } finally {",
          "804:                 workerThread.setName(oldName);",
          "",
          "[Removed Lines]",
          "797:                     record.setParameters(new Object[]{workerThread.getName(), listener, e.getClass().getSimpleName()});",
          "801:                     throw (Error)e;",
          "",
          "[Added Lines]",
          "813:                     record.setParameters(new Object[] {",
          "814:                         workerThread.getName(), listener, e.getClass().getSimpleName()",
          "815:                     });",
          "819:                     throw (Error) e;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "846:         private boolean interestOps() {",
          "847:             if (LOGGER.isLoggable(Level.FINEST)) {",
          "851:             }",
          "852:             if (key.isValid()) {",
          "853:                 key.interestOps((key.interestOps() & opsAnd) | opsOr);",
          "",
          "[Removed Lines]",
          "849:                 LOGGER.log(Level.FINEST, \"updating interest ops &={0} |={1} on {2} with existing ops {3} on key {4}\",",
          "850:                         new Object[] { opsAnd, opsOr, key.channel(), key.interestOps(), key });",
          "",
          "[Added Lines]",
          "867:                 LOGGER.log(",
          "868:                         Level.FINEST,",
          "869:                         \"updating interest ops &={0} |={1} on {2} with existing ops {3} on key {4}\",",
          "870:                         new Object[] {opsAnd, opsOr, key.channel(), key.interestOps(), key});",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "949:                 final Thread workerThread = Thread.currentThread();",
          "950:                 final String oldName = workerThread.getName();",
          "951:                 try {",
          "958:                     task.run();",
          "959:                     synchronized (this) {",
          "960:                         done = true;",
          "",
          "[Removed Lines]",
          "952:                     workerThread.setName(",
          "953:                             String.format(\"IOHub#%d: Timeout[%s] / %s\",",
          "954:                                     _id,",
          "955:                                     task,",
          "956:                                     oldName)",
          "957:                     );",
          "",
          "[Added Lines]",
          "972:                     workerThread.setName(String.format(\"IOHub#%d: Timeout[%s] / %s\", _id, task, oldName));",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/NetworkLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "253:         } catch (IOException e) {",
          "254:             if (LOGGER.isLoggable(Level.FINEST)) {",
          "255:                 LogRecord record = new LogRecord(Level.FINEST, \"[{0}] Could not complete start\");",
          "257:                 record.setThrown(e);",
          "258:                 LOGGER.log(record);",
          "259:             }",
          "",
          "[Removed Lines]",
          "256:                 record.setParameters(new Object[]{ptr.stack().name()});",
          "",
          "[Added Lines]",
          "256:                 record.setParameters(new Object[] {ptr.stack().name()});",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java||src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java -> src/main/java/org/jenkinsci/remoting/protocol/ProtocolStack.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:         this.name = name;",
          "166:         this.network = network;",
          "167:         this.application = application;",
          "",
          "[Removed Lines]",
          "161:     private ProtocolStack(String name, NetworkLayer network,",
          "162:                           List<FilterLayer> filters,",
          "163:                           ApplicationLayer<T> application,",
          "164:                           List<Listener> listeners) {",
          "",
          "[Added Lines]",
          "161:     private ProtocolStack(",
          "162:             String name,",
          "163:             NetworkLayer network,",
          "164:             List<FilterLayer> filters,",
          "165:             ApplicationLayer<T> application,",
          "166:             List<Listener> listeners) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "210:             } catch (IOException e) {",
          "211:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "212:                     LogRecord record = new LogRecord(Level.FINEST, \"[{0}] Start failure\");",
          "214:                     record.setThrown(e);",
          "215:                     LOGGER.log(record);",
          "216:                 }",
          "",
          "[Removed Lines]",
          "213:                     record.setParameters(new Object[]{name()});",
          "",
          "[Added Lines]",
          "215:                     record.setParameters(new Object[] {name()});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "254:     public void name(String name) {",
          "255:         if (!(Objects.equals(this.name, name))) {",
          "256:             if (LOGGER.isLoggable(Level.FINER)) {",
          "258:             }",
          "259:             this.name = name != null && !name.isEmpty() ? name : this.name;",
          "260:         }",
          "",
          "[Removed Lines]",
          "257:                 LOGGER.log(Level.FINER, \"[{0}] is now known as [{1}]\", new Object[]{this.name, name});",
          "",
          "[Added Lines]",
          "259:                 LOGGER.log(Level.FINER, \"[{0}] is now known as [{1}]\", new Object[] {this.name, name});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "273:         } catch (IOException e) {",
          "274:             if (LOGGER.isLoggable(Level.FINEST)) {",
          "275:                 LogRecord record = new LogRecord(Level.FINEST, \"[{0}] Abnormal close\");",
          "277:                 record.setThrown(e);",
          "278:                 LOGGER.log(record);",
          "279:             }",
          "",
          "[Removed Lines]",
          "276:                 record.setParameters(new Object[]{name()});",
          "",
          "[Added Lines]",
          "278:                 record.setParameters(new Object[] {name()});",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "553:             }",
          "554:             checkNotBuilt();",
          "555:             built = true;",
          "563:             stack.init();",
          "564:             return stack;",
          "565:         }",
          "",
          "[Removed Lines]",
          "556:             ProtocolStack<T> stack =",
          "557:                     new ProtocolStack<>(",
          "558:                             name == null || name.isEmpty() ? String.format(\"Stack-%d\", id.incrementAndGet()) : name,",
          "559:                             network,",
          "560:                             filters,",
          "561:                             application,",
          "562:                             listeners);",
          "",
          "[Added Lines]",
          "557:             ProtocolStack<T> stack = new ProtocolStack<>(",
          "558:                     name == null || name.isEmpty() ? String.format(\"Stack-%d\", id.incrementAndGet()) : name,",
          "559:                     network,",
          "560:                     filters,",
          "561:                     application,",
          "562:                     listeners);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "865:                     while (this.nextSend != nextSend && this.nextSend != null && this.nextSend.removed) {",
          "866:                         assert this.nextSend.layer instanceof FilterLayer",
          "867:                                 : \"this is the layer before and there is a layer after nextSend thus nextSend \"",
          "869:                         ((FilterLayer) this.nextSend.layer).onSendRemoved();",
          "871:                         Ptr tmp = this.nextSend.nextSend;",
          "",
          "[Removed Lines]",
          "868:                                 + \"*must* be a FilterLayer\";",
          "",
          "[Added Lines]",
          "867:                                         + \"*must* be a FilterLayer\";",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "918:                     while (this.nextRecv != nextRecv && this.nextRecv != null && this.nextRecv.removed) {",
          "919:                         assert this.nextRecv.layer instanceof FilterLayer",
          "920:                                 : \"this is the layer before and there is a layer after nextRecv thus nextRecv \"",
          "922:                         ((FilterLayer) this.nextRecv.layer).onRecvRemoved();",
          "924:                         Ptr tmp = this.nextRecv.nextRecv;",
          "",
          "[Removed Lines]",
          "921:                                 + \"*must* be a FilterLayer\";",
          "",
          "[Added Lines]",
          "920:                                         + \"*must* be a FilterLayer\";",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java -> src/main/java/org/jenkinsci/remoting/protocol/cert/DelegatingX509ExtendedTrustManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:     @Override",
          "155:         validateAuthType(authType);",
          "156:         validateChain(chain);",
          "157:         delegate.checkClientTrusted(chain, authType);",
          "",
          "[Removed Lines]",
          "153:     public void checkClientTrusted(X509Certificate[] chain, String authType)",
          "154:             throws CertificateException {",
          "",
          "[Added Lines]",
          "153:     public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:     @Override",
          "166:         validateAuthType(authType);",
          "167:         validateChain(chain);",
          "168:         delegate.checkServerTrusted(chain, authType);",
          "",
          "[Removed Lines]",
          "164:     public void checkServerTrusted(X509Certificate[] chain, String authType)",
          "165:             throws CertificateException {",
          "",
          "[Added Lines]",
          "163:     public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java -> src/main/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:         this.publicKeys = new ArrayList<>(Arrays.asList(publicKeys));",
          "98:         this.strictClient = strictClient;",
          "99:         this.strictServer = strictServer;",
          "",
          "[Removed Lines]",
          "95:     public PublicKeyMatchingX509ExtendedTrustManager(boolean strictClient, boolean strictServer,",
          "96:                                                      PublicKey... publicKeys) {",
          "",
          "[Added Lines]",
          "95:     public PublicKeyMatchingX509ExtendedTrustManager(",
          "96:             boolean strictClient, boolean strictServer, PublicKey... publicKeys) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:         PublicKey chainKey = chain[0].getPublicKey();",
          "203:         byte[] chainKeyEncoded = chainKey.getEncoded();",
          "204:         if (chainKeyEncoded == null) {",
          "209:         }",
          "210:         synchronized (publicKeys) {",
          "211:             if (publicKeys.isEmpty() ? (client ? !strictClient : !strictServer) : isTrusted(chainKey)) {",
          "212:                 return;",
          "213:             }",
          "214:         }",
          "219:     }",
          "",
          "[Removed Lines]",
          "205:             throw new CertificateException(",
          "206:                     String.format(\"Public key of the first certificate in chain (subject: '%s') \"",
          "207:                                     + \"(algorithm: '%s'; format: '%s') does not support binary encoding\",",
          "208:                             chain[0].getSubjectDN(), chainKey.getAlgorithm(), chainKey.getFormat()));",
          "215:         throw new CertificateException(",
          "216:                 String.format(\"Public key of the first certificate in chain (subject: %s) \"",
          "217:                                 + \"is not in the list of trusted keys\",",
          "218:                         chain[0].getSubjectDN()));",
          "",
          "[Added Lines]",
          "205:             throw new CertificateException(String.format(",
          "206:                     \"Public key of the first certificate in chain (subject: '%s') \"",
          "207:                             + \"(algorithm: '%s'; format: '%s') does not support binary encoding\",",
          "208:                     chain[0].getSubjectDN(), chainKey.getAlgorithm(), chainKey.getFormat()));",
          "215:         throw new CertificateException(String.format(",
          "216:                 \"Public key of the first certificate in chain (subject: %s) \" + \"is not in the list of trusted keys\",",
          "217:                 chain[0].getSubjectDN()));",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java||src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java -> src/main/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:     @Override",
          "157:         validateAuthType(authType);",
          "158:         validateChain(chain);",
          "159:         checkValidity(chain);",
          "",
          "[Removed Lines]",
          "155:     public void checkClientTrusted(X509Certificate[] chain, String authType)",
          "156:             throws CertificateException {",
          "",
          "[Added Lines]",
          "155:     public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:     @Override",
          "169:         validateAuthType(authType);",
          "170:         validateChain(chain);",
          "171:         checkValidity(chain);",
          "",
          "[Removed Lines]",
          "167:     public void checkServerTrusted(X509Certificate[] chain, String authType)",
          "168:             throws CertificateException {",
          "",
          "[Added Lines]",
          "166:     public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:         return expectHex.toString();",
          "120:     }",
          "123:     private void abort(String type) throws ConnectionRefusalException {",
          "124:         aborted = true;",
          "125:         if (LOGGER.isLoggable(Level.WARNING)) {",
          "129:         }",
          "133:         abort(cause);",
          "134:         throw cause;",
          "135:     }",
          "",
          "[Removed Lines]",
          "122:     @SuppressFBWarnings(value = \"FORMAT_STRING_MANIPULATION\", justification = \"As this converts a String to a Hex string there is little that can be manipulated.\")",
          "126:             LOGGER.log(Level.WARNING,",
          "127:                     \"[{0}] {1} acknowledgement sequence, expected 0x{2} got 0x{3}\",",
          "128:                     new Object[]{stack().name(), type, toHexString(sendAck), toHexString(recvAck)});",
          "130:         ConnectionRefusalException cause = new ConnectionRefusalException(",
          "131:                 String.format(type + \" acknowledgement received, expected 0x%s got 0x%s\",",
          "132:                         toHexString(sendAck), toHexString(recvAck)));",
          "",
          "[Added Lines]",
          "122:     @SuppressFBWarnings(",
          "123:             value = \"FORMAT_STRING_MANIPULATION\",",
          "124:             justification = \"As this converts a String to a Hex string there is little that can be manipulated.\")",
          "128:             LOGGER.log(Level.WARNING, \"[{0}] {1} acknowledgement sequence, expected 0x{2} got 0x{3}\", new Object[] {",
          "129:                 stack().name(), type, toHexString(sendAck), toHexString(recvAck)",
          "130:             });",
          "132:         ConnectionRefusalException cause = new ConnectionRefusalException(String.format(",
          "133:                 type + \" acknowledgement received, expected 0x%s got 0x%s\",",
          "134:                 toHexString(sendAck),",
          "135:                 toHexString(recvAck)));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:     @Override",
          "173:     public void start() throws IOException {",
          "174:         synchronized (sendLock) {",
          "186:         }",
          "187:         try {",
          "188:             doSend(EMPTY_BUFFER);",
          "",
          "[Removed Lines]",
          "175:             timeout = stack().executeLater(() -> {",
          "176:                 LOGGER.info(\"Timeout waiting for ACK\");",
          "177:                 IOException cause = new IOException(\"Timeout waiting for ACK\");",
          "178:                 abort(cause);",
          "179:                 try {",
          "180:                     doCloseSend();",
          "181:                     onRecvClosed(cause);",
          "182:                 } catch (IOException e) {",
          "184:                 }",
          "185:             }, stack().getHandshakingTimeout(), stack().getHandshakingUnits());",
          "",
          "[Added Lines]",
          "178:             timeout = stack().executeLater(",
          "179:                             () -> {",
          "180:                                 LOGGER.info(\"Timeout waiting for ACK\");",
          "181:                                 IOException cause = new IOException(\"Timeout waiting for ACK\");",
          "182:                                 abort(cause);",
          "183:                                 try {",
          "184:                                     doCloseSend();",
          "185:                                     onRecvClosed(cause);",
          "186:                                 } catch (IOException e) {",
          "188:                                 }",
          "189:                             },",
          "190:                             stack().getHandshakingTimeout(),",
          "191:                             stack().getHandshakingUnits());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "199:         if (aborted) {",
          "201:             if (!sendAck.hasRemaining()) {",
          "205:             }",
          "206:             throw new ConnectionRefusalException(\"Connection closed before acknowledgement send\");",
          "207:         }",
          "",
          "[Removed Lines]",
          "202:                 throw new ConnectionRefusalException(",
          "203:                         String.format(\"Incorrect acknowledgement received, expected 0x%s got 0x%s\",",
          "204:                                 toHexString(sendAck), toHexString(recvAck)));",
          "",
          "[Added Lines]",
          "208:                 throw new ConnectionRefusalException(String.format(",
          "209:                         \"Incorrect acknowledgement received, expected 0x%s got 0x%s\",",
          "210:                         toHexString(sendAck), toHexString(recvAck)));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "213:                         abort(\"Incorrect\");",
          "214:                     } else {",
          "215:                         if (LOGGER.isLoggable(Level.FINEST)) {",
          "218:                         }",
          "219:                     }",
          "220:                     return;",
          "",
          "[Removed Lines]",
          "216:                             LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of acknowledgement\",",
          "217:                                     new Object[]{stack().name(), recvAck.remaining()});",
          "",
          "[Added Lines]",
          "222:                             LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of acknowledgement\", new Object[] {",
          "223:                                 stack().name(), recvAck.remaining()",
          "224:                             });",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "267:     public void onRecvClosed(IOException cause) throws IOException {",
          "268:         synchronized (recvLock) {",
          "269:             if (recvAck.hasRemaining() && recvAck.position() > 0) {",
          "271:                         \"Partial acknowledgement received, expecting 0x%s got 0x%s\",",
          "273:                 return;",
          "274:             }",
          "275:         }",
          "",
          "[Removed Lines]",
          "270:                 super.onRecvClosed(new ConnectionRefusalException(cause,",
          "272:                                 toHexString(sendAck), toHexString(recvAck)));",
          "",
          "[Added Lines]",
          "277:                 super.onRecvClosed(new ConnectionRefusalException(",
          "278:                         cause,",
          "280:                         toHexString(sendAck),",
          "281:                         toHexString(recvAck)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "301:     public void doSend(@NonNull ByteBuffer data) throws IOException {",
          "302:         if (aborted) {",
          "303:             if (!sendAck.hasRemaining()) {",
          "307:             }",
          "308:             throw new ConnectionRefusalException(\"Connection closed before acknowledgement send\");",
          "309:         }",
          "",
          "[Removed Lines]",
          "304:                 throw new ConnectionRefusalException(",
          "305:                         String.format(\"Incorrect acknowledgement received, expected 0x%s got 0x%s\",",
          "306:                                 toHexString(sendAck), toHexString(recvAck)));",
          "",
          "[Added Lines]",
          "313:                 throw new ConnectionRefusalException(String.format(",
          "314:                         \"Incorrect acknowledgement received, expected 0x%s got 0x%s\",",
          "315:                         toHexString(sendAck), toHexString(recvAck)));",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/AgentProtocolClientFilterLayer.java"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/BIONetworkLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:     @Override",
          "101:     protected void write(@NonNull ByteBuffer data) throws IOException {",
          "102:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "104:         }",
          "105:         if (!data.hasRemaining()) {",
          "",
          "[Removed Lines]",
          "103:             LOGGER.log(Level.FINEST, \"[{0}] SEND: {1} bytes\", new Object[]{stack().name(), data.remaining()});",
          "",
          "[Added Lines]",
          "103:             LOGGER.log(Level.FINEST, \"[{0}] SEND: {1} bytes\", new Object[] {stack().name(), data.remaining()});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "268:                                 LogRecord record = new LogRecord(Level.FINER, \"[{0}] Unexpected I/O exception\");",
          "269:                                 record.setThrown(e);",
          "271:                                 LOGGER.log(record);",
          "272:                             }",
          "273:                             onRecvClosed();",
          "",
          "[Removed Lines]",
          "270:                                 record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "270:                                 record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277:                             if (LOGGER.isLoggable(Level.WARNING)) {",
          "278:                                 LogRecord record = new LogRecord(Level.WARNING, \"[{0}] Uncaught {1}\");",
          "279:                                 record.setThrown(e);",
          "281:                             }",
          "282:                             onRecvClosed();",
          "283:                             return;",
          "284:                         }",
          "285:                         ((Buffer) buffer).flip();",
          "286:                         if (buffer.hasRemaining() && LOGGER.isLoggable(Level.FINEST)) {",
          "289:                         }",
          "290:                         while (buffer.hasRemaining()) {",
          "291:                             try {",
          "",
          "[Removed Lines]",
          "280:                                 record.setParameters(new Object[]{stack().name(), e.getClass().getSimpleName()});",
          "287:                             LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes\",",
          "288:                                     new Object[]{stack().name(), buffer.remaining()});",
          "",
          "[Added Lines]",
          "280:                                 record.setParameters(new Object[] {",
          "281:                                     stack().name(), e.getClass().getSimpleName()",
          "282:                                 });",
          "289:                             LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes\", new Object[] {",
          "290:                                 stack().name(), buffer.remaining()",
          "291:                             });",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "304:                 if (LOGGER.isLoggable(Level.SEVERE)) {",
          "305:                     LogRecord record = new LogRecord(Level.SEVERE, \"[{0}] Reader thread killed by {1}\");",
          "306:                     record.setThrown(e);",
          "308:                     LOGGER.log(record);",
          "309:                 }",
          "310:                 if (e instanceof Error) {",
          "",
          "[Removed Lines]",
          "307:                     record.setParameters(new Object[]{stack().name(), e.getClass().getSimpleName()});",
          "",
          "[Added Lines]",
          "310:                     record.setParameters(",
          "311:                             new Object[] {stack().name(), e.getClass().getSimpleName()});",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/ChannelApplicationLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:         this.executorService = executorService;",
          "106:         this.listener = listener;",
          "107:     }",
          "",
          "[Removed Lines]",
          "103:     public ChannelApplicationLayer(@NonNull ExecutorService executorService,",
          "104:                                    @CheckForNull Listener listener) {",
          "",
          "[Added Lines]",
          "104:     public ChannelApplicationLayer(@NonNull ExecutorService executorService, @CheckForNull Listener listener) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:     @Restricted(NoExternalUse.class)",
          "119:         this.executorService = executorService;",
          "120:         this.listener = listener;",
          "121:         this.cookie = cookie;",
          "",
          "[Removed Lines]",
          "117:     public ChannelApplicationLayer(@NonNull ExecutorService executorService,",
          "118:                                    @CheckForNull Listener listener, String cookie) {",
          "",
          "[Added Lines]",
          "117:     public ChannelApplicationLayer(",
          "118:             @NonNull ExecutorService executorService, @CheckForNull Listener listener, String cookie) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:                 if (capabilityLength.hasRemaining()) {",
          "150:                     return;",
          "151:                 }",
          "154:             }",
          "155:             assert capabilityContent != null;",
          "156:             if (capabilityContent.hasRemaining()) {",
          "",
          "[Removed Lines]",
          "152:                 capabilityContent = ByteBuffer",
          "153:                         .allocate(((capabilityLength.get(0) & 0xff) << 8) + (capabilityLength.get(1) & 0xff));",
          "",
          "[Added Lines]",
          "152:                 capabilityContent =",
          "153:                         ByteBuffer.allocate(((capabilityLength.get(0) & 0xff) << 8) + (capabilityLength.get(1) & 0xff));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "167:                 final Capability remoteCapability = Capability.read(new ByteArrayInputStream(capabilityBytes));",
          "168:                 transport = new ByteBufferCommandTransport(remoteCapability);",
          "169:                 try {",
          "172:                     if (listener instanceof ChannelDecorator) {",
          "174:                     } else {",
          "175:                         channel = decorate(builder).build(transport);",
          "176:                     }",
          "",
          "[Removed Lines]",
          "170:                     ChannelBuilder builder = new ChannelBuilder(stack().name(), executorService)",
          "171:                             .withMode(Channel.Mode.BINARY);",
          "173:                         channel = decorate(((ChannelDecorator) listener).decorate(builder)).build(transport);",
          "",
          "[Added Lines]",
          "170:                     ChannelBuilder builder =",
          "171:                             new ChannelBuilder(stack().name(), executorService).withMode(Channel.Mode.BINARY);",
          "173:                         channel = decorate(((ChannelDecorator) listener).decorate(builder))",
          "174:                                 .build(transport);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "251:     public void start() {",
          "252:         try {",
          "253:             ByteArrayOutputStream bos = new ByteArrayOutputStream();",
          "255:                 oos.writeObject(new Capability());",
          "256:             }",
          "257:             ByteBuffer buffer = ByteBufferUtils.wrapUTF8(bos.toString(StandardCharsets.US_ASCII));",
          "",
          "[Removed Lines]",
          "254:             try (ObjectOutputStream oos = AnonymousClassWarnings.checkingObjectOutputStream(BinarySafeStream.wrap(bos))) {",
          "",
          "[Added Lines]",
          "255:             try (ObjectOutputStream oos =",
          "256:                     AnonymousClassWarnings.checkingObjectOutputStream(BinarySafeStream.wrap(bos))) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "322:         @Override",
          "323:         protected void write(ByteBuffer headerAndData) throws IOException {",
          "325:             if (isWriteOpen()) {",
          "326:                 try {",
          "327:                     ChannelApplicationLayer.this.write(headerAndData);",
          "328:                 } catch (ClosedChannelException e) {",
          "331:                 }",
          "332:             } else {",
          "334:             }",
          "335:         }",
          "",
          "[Removed Lines]",
          "330:                     throw new ChannelClosedException(null, \"Protocol stack cannot write data anymore. ChannelApplicationLayer reports that the NIO Channel is closed\", e);",
          "333:                 throw new ChannelClosedException(null, \"Protocol stack cannot write data anymore. It is not open for write\", null);",
          "",
          "[Added Lines]",
          "332:                     throw new ChannelClosedException(",
          "333:                             null,",
          "334:                             \"Protocol stack cannot write data anymore. ChannelApplicationLayer reports that the NIO Channel is closed\",",
          "335:                             e);",
          "338:                 throw new ChannelClosedException(",
          "339:                         null, \"Protocol stack cannot write data anymore. It is not open for write\", null);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeaders.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "163:                     if (isWhitespace) {",
          "164:                         continue;",
          "165:                     }",
          "167:                             && data.charAt(i + 3) == 'l') {",
          "168:                         i += 3;",
          "169:                         result.put(key.toString(), null);",
          "",
          "[Removed Lines]",
          "166:                     if (c == 'n' && i + 3 < n && data.charAt(i + 1) == 'u' && data.charAt(i + 2) == 'l'",
          "",
          "[Added Lines]",
          "166:                     if (c == 'n'",
          "167:                             && i + 3 < n",
          "168:                             && data.charAt(i + 1) == 'u'",
          "169:                             && data.charAt(i + 2) == 'l'",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "56:     private static final ByteBuffer ABORT_MESSAGE = ByteBufferUtils.wrapUTF8(\"BYE\").asReadOnlyBuffer();",
          "",
          "[Added Lines]",
          "56:     private static final ByteBuffer ABORT_MESSAGE =",
          "57:             ByteBufferUtils.wrapUTF8(\"BYE\").asReadOnlyBuffer();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:                 ByteBufferUtils.put(data, headerInputLength);",
          "155:                 if (headerInputLength.hasRemaining()) {",
          "156:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "159:                     }",
          "160:                     return;",
          "161:                 }",
          "",
          "[Removed Lines]",
          "157:                         LOGGER.log(Level.FINEST, \"[{0}] expecting {1} more bytes of header length\",",
          "158:                                 new Object[]{stack().name(), headerInputLength.remaining()});",
          "",
          "[Added Lines]",
          "158:                         LOGGER.log(Level.FINEST, \"[{0}] expecting {1} more bytes of header length\", new Object[] {",
          "159:                             stack().name(), headerInputLength.remaining()",
          "160:                         });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:                 ((Buffer) headerInputLength).position(2);",
          "165:                 headerInputContent = ByteBuffer.allocate(length);",
          "166:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "169:                 }",
          "170:             }",
          "",
          "[Removed Lines]",
          "167:                     LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} bytes of headers\",",
          "168:                             new Object[]{stack().name(), length});",
          "",
          "[Added Lines]",
          "169:                     LOGGER.log(",
          "170:                             Level.FINEST, \"[{0}] Expecting {1} bytes of headers\", new Object[] {stack().name(), length",
          "171:                             });",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "176:                 ByteBufferUtils.put(data, headerInputContent);",
          "177:                 if (headerInputContent.hasRemaining()) {",
          "178:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "181:                     }",
          "182:                     return;",
          "183:                 }",
          "",
          "[Removed Lines]",
          "179:                         LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of headers\",",
          "180:                                 new Object[]{stack().name(), headerInputContent.remaining()});",
          "",
          "[Added Lines]",
          "182:                         LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of headers\", new Object[] {",
          "183:                             stack().name(), headerInputContent.remaining()",
          "184:                         });",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:                 headerInputContent.get(headerBytes, 0, headerInputContent.remaining());",
          "187:                 final String headerAsString = new String(headerBytes, StandardCharsets.UTF_8);",
          "188:                 if (LOGGER.isLoggable(Level.FINER)) {",
          "191:                 }",
          "192:                 try {",
          "193:                     Map<String, String> headers = ConnectionHeaders.fromString(headerAsString);",
          "194:                     if (LOGGER.isLoggable(Level.FINE)) {",
          "197:                     }",
          "198:                     listener.onReceiveHeaders(headers);",
          "199:                     if (LOGGER.isLoggable(Level.FINE)) {",
          "",
          "[Removed Lines]",
          "189:                     LOGGER.log(Level.FINER, \"[{0}] Received headers \\\"{1}\\\"\",",
          "190:                             new Object[]{stack().name(), headerAsString});",
          "195:                         LOGGER.log(Level.FINE, \"[{0}] Received headers {1}\",",
          "196:                                 new Object[]{stack().name(), headers});",
          "",
          "[Added Lines]",
          "193:                     LOGGER.log(",
          "194:                             Level.FINER, \"[{0}] Received headers \\\"{1}\\\"\", new Object[] {stack().name(), headerAsString",
          "195:                             });",
          "200:                         LOGGER.log(Level.FINE, \"[{0}] Received headers {1}\", new Object[] {stack().name(), headers});",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "201:                     }",
          "202:                 } catch (ConnectionHeaders.ParseException e) {",
          "203:                     if (LOGGER.isLoggable(Level.WARNING)) {",
          "206:                     }",
          "207:                     responseOutput = ByteBufferUtils.wrapUTF8(\"ERROR: Malformed connection header\");",
          "208:                     if (this.headerOutput.hasRemaining()) {",
          "210:                         next().doSend(this.headerOutput);",
          "211:                     }",
          "213:                             ByteBuffer.allocate(ABORT_MESSAGE.capacity()));",
          "214:                     next().doSend(responseOutput);",
          "215:                     return;",
          "216:                 } catch (ConnectionRefusalException e) {",
          "217:                     if (LOGGER.isLoggable(Level.INFO)) {",
          "223:                     }",
          "225:                             e instanceof PermanentConnectionRefusalException ? \"FATAL\" : \"ERROR\", e.getMessage()));",
          "226:                     if (this.headerOutput.hasRemaining()) {",
          "",
          "[Removed Lines]",
          "204:                         LOGGER.log(Level.WARNING, \"[{0}] Remote headers \\\"{1}\\\" could not be parsed: {2}\",",
          "205:                                 new Object[]{stack().name(), headerAsString, e.getMessage()});",
          "212:                     doStartAbort(new ConnectionRefusalException(\"Malformed connection header\"),",
          "218:                         LOGGER.log(Level.INFO, \"[{0}] {1} headers from remote: {2}\",",
          "219:                                 new Object[]{stack().name(),",
          "220:                                              e instanceof PermanentConnectionRefusalException",
          "221:                                                      ? \"Permanently refusing\" : \"Refusing\",",
          "222:                                              e.getMessage()});",
          "224:                     responseOutput = ByteBufferUtils.wrapUTF8(String.format(\"%s: %s\",",
          "",
          "[Added Lines]",
          "208:                         LOGGER.log(",
          "209:                                 Level.WARNING,",
          "210:                                 \"[{0}] Remote headers \\\"{1}\\\" could not be parsed: {2}\",",
          "211:                                 new Object[] {stack().name(), headerAsString, e.getMessage()});",
          "218:                     doStartAbort(",
          "219:                             new ConnectionRefusalException(\"Malformed connection header\"),",
          "225:                         LOGGER.log(Level.INFO, \"[{0}] {1} headers from remote: {2}\", new Object[] {",
          "226:                             stack().name(),",
          "227:                             e instanceof PermanentConnectionRefusalException ? \"Permanently refusing\" : \"Refusing\",",
          "228:                             e.getMessage()",
          "229:                         });",
          "231:                     responseOutput = ByteBufferUtils.wrapUTF8(String.format(",
          "232:                             \"%s: %s\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "235:                 if (this.headerOutput.hasRemaining()) {",
          "237:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "240:                     }",
          "241:                     next().doSend(this.headerOutput);",
          "242:                 }",
          "243:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "246:                 }",
          "247:                 next().doSend(responseOutput);",
          "248:                 responseInputLength = ByteBuffer.allocate(2);",
          "",
          "[Removed Lines]",
          "238:                         LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of headers\",",
          "239:                                 new Object[]{stack().name(), this.headerOutput.remaining()});",
          "244:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of response\",",
          "245:                             new Object[]{stack().name(), this.responseOutput.remaining()});",
          "",
          "[Added Lines]",
          "246:                         LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of headers\", new Object[] {",
          "247:                             stack().name(), this.headerOutput.remaining()",
          "248:                         });",
          "253:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of response\", new Object[] {",
          "254:                         stack().name(), this.responseOutput.remaining()",
          "255:                     });",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "261:                     return;",
          "262:                 }",
          "263:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "268:                 }",
          "269:                 abortConfirmationTimeout.cancel(false);",
          "270:                 onAbortCompleted();",
          "",
          "[Removed Lines]",
          "264:                     LOGGER.log(Level.FINEST, \"[{0}] Received confirmation of {1} headers\",",
          "265:                             new Object[]{stack().name(),",
          "266:                                          abortCause instanceof PermanentConnectionRefusalException",
          "267:                                     ? \"permanently refused\" : \"refused\"});",
          "",
          "[Added Lines]",
          "274:                     LOGGER.log(Level.FINEST, \"[{0}] Received confirmation of {1} headers\", new Object[] {",
          "275:                         stack().name(),",
          "276:                         abortCause instanceof PermanentConnectionRefusalException ? \"permanently refused\" : \"refused\"",
          "277:                     });",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "280:                 ((Buffer) this.responseInputLength).position(2);",
          "281:                 responseInputContent = ByteBuffer.allocate(length);",
          "282:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "285:                 }",
          "286:             }",
          "",
          "[Removed Lines]",
          "283:                     LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} bytes of response\",",
          "284:                             new Object[]{stack().name(), length});",
          "",
          "[Added Lines]",
          "293:                     LOGGER.log(",
          "294:                             Level.FINEST, \"[{0}] Expecting {1} bytes of response\", new Object[] {stack().name(), length",
          "295:                             });",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "292:                 ByteBufferUtils.put(data, responseInputContent);",
          "293:                 if (responseInputContent.hasRemaining()) {",
          "294:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "297:                     }",
          "298:                     return;",
          "299:                 }",
          "",
          "[Removed Lines]",
          "295:                         LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of response\",",
          "296:                                 new Object[]{stack().name(), responseInputContent.remaining()});",
          "",
          "[Added Lines]",
          "306:                         LOGGER.log(Level.FINEST, \"[{0}] Expecting {1} more bytes of response\", new Object[] {",
          "307:                             stack().name(), responseInputContent.remaining()",
          "308:                         });",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "302:                 responseInputContent.get(responseBytes, 0, responseInputContent.remaining());",
          "303:                 String response = new String(responseBytes, StandardCharsets.UTF_8);",
          "304:                 if (LOGGER.isLoggable(Level.FINE)) {",
          "307:                 }",
          "308:                 finished = true;",
          "309:                 if (response.startsWith(\"ERROR: \")) {",
          "310:                     String message = response.substring(\"ERROR: \".length());",
          "311:                     if (LOGGER.isLoggable(Level.INFO)) {",
          "314:                     }",
          "315:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "318:                     }",
          "319:                     next().doSend(ABORT_MESSAGE.duplicate());",
          "320:                     doStartAbort(new ConnectionRefusalException(message), EMPTY_BUFFER);",
          "",
          "[Removed Lines]",
          "305:                     LOGGER.log(Level.FINE, \"[{0}] Received response \\\"{1}\\\"\",",
          "306:                             new Object[]{stack().name(), response});",
          "312:                         LOGGER.log(Level.INFO, \"[{0}] Local headers refused by remote: {1}\",",
          "313:                                 new Object[]{stack().name(), message});",
          "316:                         LOGGER.log(Level.FINEST, \"[{0}] Confirming receipt of refused connection: {1}\",",
          "317:                                 new Object[]{stack().name(), message});",
          "",
          "[Added Lines]",
          "317:                     LOGGER.log(Level.FINE, \"[{0}] Received response \\\"{1}\\\"\", new Object[] {stack().name(), response});",
          "323:                         LOGGER.log(Level.INFO, \"[{0}] Local headers refused by remote: {1}\", new Object[] {",
          "324:                             stack().name(), message",
          "325:                         });",
          "328:                         LOGGER.log(Level.FINEST, \"[{0}] Confirming receipt of refused connection: {1}\", new Object[] {",
          "329:                             stack().name(), message",
          "330:                         });",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "323:                 if (response.startsWith(\"FATAL: \")) {",
          "324:                     String message = response.substring(\"FATAL: \".length());",
          "325:                     if (LOGGER.isLoggable(Level.WARNING)) {",
          "328:                     }",
          "329:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "332:                     }",
          "333:                     next().doSend(ABORT_MESSAGE.duplicate());",
          "334:                     doStartAbort(new PermanentConnectionRefusalException(message), EMPTY_BUFFER);",
          "",
          "[Removed Lines]",
          "326:                         LOGGER.log(Level.WARNING, \"[{0}] Local headers permanently rejected by remote: {1}\",",
          "327:                                 new Object[]{stack().name(), message});",
          "330:                         LOGGER.log(Level.FINEST, \"[{0}] Confirming receipt of permanently rejected connection: {1}\",",
          "331:                                 new Object[]{stack().name(), message});",
          "",
          "[Added Lines]",
          "339:                         LOGGER.log(",
          "340:                                 Level.WARNING,",
          "341:                                 \"[{0}] Local headers permanently rejected by remote: {1}\",",
          "342:                                 new Object[] {stack().name(), message});",
          "345:                         LOGGER.log(",
          "346:                                 Level.FINEST,",
          "347:                                 \"[{0}] Confirming receipt of permanently rejected connection: {1}\",",
          "348:                                 new Object[] {stack().name(), message});",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "438:         if (cause instanceof ClosedChannelException) {",
          "443:             super.onRecvClosed(ThrowableUtils.chain(newCause, cause));",
          "444:         } else {",
          "445:             super.onRecvClosed(cause);",
          "",
          "[Removed Lines]",
          "441:             ConnectionRefusalException newCause = new ConnectionRefusalException(",
          "442:                     \"Remote closed connection without specifying reason\");",
          "",
          "[Added Lines]",
          "458:             ConnectionRefusalException newCause =",
          "459:                     new ConnectionRefusalException(\"Remote closed connection without specifying reason\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "467:             if (this.headerOutput.hasRemaining()) {",
          "469:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "472:                 }",
          "473:                 next().doSend(this.headerOutput);",
          "474:                 if (!this.headerOutput.hasRemaining() && LOGGER.isLoggable(Level.FINE)) {",
          "",
          "[Removed Lines]",
          "470:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of headers\",",
          "471:                             new Object[]{stack().name(), this.headerOutput.remaining()});",
          "",
          "[Added Lines]",
          "487:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of headers\", new Object[] {",
          "488:                         stack().name(), this.headerOutput.remaining()",
          "489:                     });",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "478:             if (this.responseOutput != null && this.responseOutput.hasRemaining()) {",
          "480:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "483:                 }",
          "484:                 next().doSend(this.responseOutput);",
          "485:                 if (!this.responseOutput.hasRemaining() && LOGGER.isLoggable(Level.FINE)) {",
          "",
          "[Removed Lines]",
          "481:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of response\",",
          "482:                             new Object[]{stack().name(), this.responseOutput.remaining()});",
          "",
          "[Added Lines]",
          "499:                     LOGGER.log(Level.FINEST, \"[{0}] Sending {1} bytes of response\", new Object[] {",
          "500:                         stack().name(), this.responseOutput.remaining()",
          "501:                     });",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java||src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/ConnectionRefusalException.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: public class ConnectionRefusalException extends IOException {",
          "41:     public ConnectionRefusalException(String message) {",
          "42:         super(message);",
          "",
          "[Removed Lines]",
          "38:     public ConnectionRefusalException() {",
          "39:     }",
          "",
          "[Added Lines]",
          "38:     public ConnectionRefusalException() {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:     public ConnectionRefusalException(Throwable cause, String message, Object... args) {",
          "79:         super(String.format(message, args), cause);",
          "80:     }",
          "",
          "[Removed Lines]",
          "77:     @SuppressFBWarnings(value = \"FORMAT_STRING_MANIPULATION\", justification = \"This is only used with String conversion to hex string.\")",
          "",
          "[Added Lines]",
          "76:     @SuppressFBWarnings(",
          "77:             value = \"FORMAT_STRING_MANIPULATION\",",
          "78:             justification = \"This is only used with String conversion to hex string.\")",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/NIONetworkLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:         super(ioHub);",
          "99:         if (!(in instanceof SelectableChannel)) {",
          "100:             throw new IllegalArgumentException(\"Input channel must be a SelectableChannel\");",
          "",
          "[Removed Lines]",
          "96:     public NIONetworkLayer(IOHub ioHub, ReadableByteChannel in,",
          "97:                            WritableByteChannel out) {",
          "",
          "[Added Lines]",
          "96:     public NIONetworkLayer(IOHub ioHub, ReadableByteChannel in, WritableByteChannel out) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:     @Override",
          "126:     public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "127:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "130:         }",
          "131:         if (read) {",
          "132:             recvLock.lock();",
          "",
          "[Removed Lines]",
          "128:             LOGGER.log(Level.FINEST, \"{0} - entering ready({1}, {2}, {3}, {4})\",",
          "129:                     new Object[] { Thread.currentThread().getName(), accept, connect, read, write });",
          "",
          "[Added Lines]",
          "127:             LOGGER.log(Level.FINEST, \"{0} - entering ready({1}, {2}, {3}, {4})\", new Object[] {",
          "128:                 Thread.currentThread().getName(), accept, connect, read, write",
          "129:             });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:                                 default:",
          "155:                                     ((Buffer) recv).flip();",
          "156:                                     if (logFinest) {",
          "159:                                     }",
          "160:                                     while (recv.hasRemaining()) {",
          "161:                                         onRead(recv);",
          "",
          "[Removed Lines]",
          "157:                                         LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes\",",
          "158:                                                 new Object[]{stack().name(), recv.remaining()});",
          "",
          "[Added Lines]",
          "157:                                         LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes\", new Object[] {",
          "158:                                             stack().name(), recv.remaining()",
          "159:                                         });",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "174:                             LogRecord record = new LogRecord(Level.FINER, \"[{0}] Unexpected I/O exception\");",
          "175:                             record.setThrown(e);",
          "177:                             LOGGER.log(record);",
          "178:                         }",
          "179:                         recvKey.cancel();",
          "",
          "[Removed Lines]",
          "176:                             record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "177:                             record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "184:                             if (LOGGER.isLoggable(Level.SEVERE)) {",
          "185:                                 LogRecord record = new LogRecord(Level.SEVERE, \"[{0}] Uncaught {1}\");",
          "186:                                 record.setThrown(t);",
          "188:                                 LOGGER.log(record);",
          "189:                             }",
          "190:                         } finally {",
          "",
          "[Removed Lines]",
          "187:                                 record.setParameters(new Object[]{stack().name(), t.getClass().getSimpleName()});",
          "",
          "[Added Lines]",
          "188:                                 record.setParameters(new Object[] {",
          "189:                                     stack().name(), t.getClass().getSimpleName()",
          "190:                                 });",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "213:                     sendHasRemaining = sendQueue.hasRemaining();",
          "214:                 }",
          "215:                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "218:                 }",
          "219:                 ((Buffer) send).flip();",
          "220:                 try {",
          "221:                     final int sentBytes = out.write(send);",
          "222:                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "225:                     }",
          "226:                     if (sentBytes == -1) {",
          "227:                         sendKey.cancel();",
          "",
          "[Removed Lines]",
          "216:                     LOGGER.log(Level.FINEST, \"[{0}] sendHasRemaining - has remaining: {1}\",",
          "217:                             new Object[] { Thread.currentThread().getName(), sendHasRemaining });",
          "223:                         LOGGER.log(Level.FINEST, \"[{0}] sentBytes - sent {1} bytes\",",
          "224:                                 new Object[] { Thread.currentThread().getName(), sentBytes });",
          "",
          "[Added Lines]",
          "219:                     LOGGER.log(Level.FINEST, \"[{0}] sendHasRemaining - has remaining: {1}\", new Object[] {",
          "220:                         Thread.currentThread().getName(), sendHasRemaining",
          "221:                     });",
          "227:                         LOGGER.log(Level.FINEST, \"[{0}] sentBytes - sent {1} bytes\", new Object[] {",
          "228:                             Thread.currentThread().getName(), sentBytes",
          "229:                         });",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "236:                         LogRecord record = new LogRecord(Level.FINER, \"[{0}] Unexpected I/O exception\");",
          "237:                         record.setThrown(e);",
          "239:                         LOGGER.log(record);",
          "240:                     }",
          "241:                     sendKey.cancel();",
          "",
          "[Removed Lines]",
          "238:                         record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "243:                         record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "258:             }",
          "259:         }",
          "260:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "262:         }",
          "263:     }",
          "",
          "[Removed Lines]",
          "261:             LOGGER.log(Level.FINEST, \"{0} - leaving ready(...)\", Thread.currentThread().getName());",
          "",
          "[Added Lines]",
          "266:             LOGGER.log(",
          "267:                     Level.FINEST,",
          "268:                     \"{0} - leaving ready(...)\",",
          "269:                     Thread.currentThread().getName());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "268:     @Override",
          "269:     protected void write(@NonNull ByteBuffer data) throws IOException {",
          "270:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "272:         }",
          "273:         if (!data.hasRemaining()) {",
          "274:             return;",
          "",
          "[Removed Lines]",
          "271:             LOGGER.log(Level.FINEST, \"[{0}] SEND: {1} bytes\", new Object[]{stack().name(), data.remaining()});",
          "",
          "[Added Lines]",
          "279:             LOGGER.log(Level.FINEST, \"[{0}] SEND: {1} bytes\", new Object[] {stack().name(), data.remaining()});",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "315:         final SelectableChannel out = (SelectableChannel) this.out;",
          "316:         if (in == out) {",
          "317:             in.configureBlocking(false);",
          "321:         } else {",
          "322:             in.configureBlocking(false);",
          "323:             out.configureBlocking(false);",
          "327:             getIoHub().register(in, this, false, false, true, false, new RegistrationCallbackImpl(false, true, false));",
          "328:         }",
          "329:         super.start();",
          "",
          "[Removed Lines]",
          "318:             getIoHub().register(in, this, false, false, true, pendingWrite,",
          "319:                     new RegistrationCallbackImpl(true, true, pendingWrite)",
          "320:             );",
          "324:             getIoHub().register(out, this, false, false, false, pendingWrite,",
          "325:                     new RegistrationCallbackImpl(true, false, pendingWrite)",
          "326:             );",
          "",
          "[Added Lines]",
          "326:             getIoHub()",
          "327:                     .register(",
          "328:                             in,",
          "329:                             this,",
          "330:                             false,",
          "331:                             false,",
          "332:                             true,",
          "333:                             pendingWrite,",
          "334:                             new RegistrationCallbackImpl(true, true, pendingWrite));",
          "338:             getIoHub()",
          "339:                     .register(",
          "340:                             out,",
          "341:                             this,",
          "342:                             false,",
          "343:                             false,",
          "344:                             false,",
          "345:                             pendingWrite,",
          "346:                             new RegistrationCallbackImpl(true, false, pendingWrite));",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java||src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java": [
          "File: src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java -> src/main/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     @Override",
          "98:     public void start() throws IOException {",
          "99:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "103:         }",
          "104:         sslEngine.beginHandshake();",
          "105:         onRecv(EMPTY_BUFFER);",
          "",
          "[Removed Lines]",
          "100:             LOGGER.log(Level.FINEST, \"{0} Starting {1}\", new Object[]{",
          "101:                     stack().name(), sslEngine.getHandshakeStatus()",
          "102:             });",
          "",
          "[Added Lines]",
          "101:             LOGGER.log(Level.FINEST, \"{0} Starting {1}\", new Object[] {stack().name(), sslEngine.getHandshakeStatus()});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     @Override",
          "112:     public void onRecv(@NonNull ByteBuffer readBuffer) throws IOException {",
          "113:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "116:         }",
          "117:         try {",
          "118:             processRead(readBuffer);",
          "",
          "[Removed Lines]",
          "114:             LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes plus {2} retained\",",
          "115:                     new Object[]{stack().name(), readBuffer.remaining(), previous == null ? 0 : previous.remaining()});",
          "",
          "[Added Lines]",
          "113:             LOGGER.log(Level.FINEST, \"[{0}] RECV: {1} bytes plus {2} retained\", new Object[] {",
          "114:                 stack().name(), readBuffer.remaining(), previous == null ? 0 : previous.remaining()",
          "115:             });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "278:             onRecvClosed(null);",
          "279:         } catch (IOException e) {",
          "280:             if (LOGGER.isLoggable(Level.FINE)) {",
          "284:                 record.setThrown(e);",
          "285:                 LOGGER.log(record);",
          "286:             }",
          "",
          "[Removed Lines]",
          "281:                 LogRecord record = new LogRecord(Level.FINE,",
          "282:                         \"[{0}] Could not complete close of read after closure of SSL session\");",
          "283:                 record.setParameters(new Object[]{stack().name()});",
          "",
          "[Added Lines]",
          "281:                 LogRecord record = new LogRecord(",
          "282:                         Level.FINE, \"[{0}] Could not complete close of read after closure of SSL session\");",
          "283:                 record.setParameters(new Object[] {stack().name()});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "345:                     switch (result.getStatus()) {",
          "346:                         case BUFFER_UNDERFLOW:",
          "348:                         case CLOSED:",
          "350:                             done = true;",
          "351:                             break;",
          "352:                         case BUFFER_OVERFLOW:",
          "354:                             int newCapacity = appBuffer.capacity() * 2;",
          "355:                             stack().release(appBuffer);",
          "356:                             appBuffer = stack().acquire(newCapacity);",
          "357:                             break;",
          "358:                         case OK:",
          "361:                                 ((Buffer) appBuffer).flip();",
          "362:                                 if (LOGGER.isLoggable(Level.FINEST)) {",
          "365:                                 }",
          "366:                                 next().onRecv(appBuffer);",
          "367:                                 ((Buffer) appBuffer).clear();",
          "",
          "[Removed Lines]",
          "359:                             if ((handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) && (",
          "360:                                     result.bytesProduced() > 0)) {",
          "363:                                     LOGGER.log(Level.FINEST, \"[{0}] DECODE: {1} bytes\",",
          "364:                                             new Object[]{stack().name(), appBuffer.remaining()});",
          "",
          "[Added Lines]",
          "359:                             if ((handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)",
          "360:                                     && (result.bytesProduced() > 0)) {",
          "363:                                     LOGGER.log(Level.FINEST, \"[{0}] DECODE: {1} bytes\", new Object[] {",
          "364:                                         stack().name(), appBuffer.remaining()",
          "365:                                     });",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "400:                                 ((Buffer) appBuffer).flip();",
          "401:                                 if (appBuffer.hasRemaining()) {",
          "402:                                     if (LOGGER.isLoggable(Level.FINEST)) {",
          "405:                                     }",
          "406:                                     next().doSend(appBuffer);",
          "407:                                 }",
          "",
          "[Removed Lines]",
          "403:                                         LOGGER.log(Level.FINEST, \"[{0}] HANDSHAKE SEND: {1} bytes\",",
          "404:                                                 new Object[]{stack().name(), appBuffer.remaining()});",
          "",
          "[Added Lines]",
          "404:                                         LOGGER.log(Level.FINEST, \"[{0}] HANDSHAKE SEND: {1} bytes\", new Object[] {",
          "405:                                             stack().name(), appBuffer.remaining()",
          "406:                                         });",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "433:     private void processResult(SSLEngineResult.HandshakeStatus sessionStatus, SSLEngineResult operationStatus) {",
          "434:         if (LOGGER.isLoggable(Level.FINEST)) {",
          "437:         }",
          "438:         switch (sessionStatus) {",
          "439:             case NEED_TASK: // $FALL-THROUGH$",
          "",
          "[Removed Lines]",
          "435:             LOGGER.log(Level.FINEST, \"[{0}] Handshake status: {1} engine result: {2}\",",
          "436:                     new Object[]{stack().name(), sessionStatus, operationStatus});",
          "",
          "[Added Lines]",
          "437:             LOGGER.log(Level.FINEST, \"[{0}] Handshake status: {1} engine result: {2}\", new Object[] {",
          "438:                 stack().name(), sessionStatus, operationStatus",
          "439:             });",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "482:         while (!done) {",
          "484:             if (LOGGER.isLoggable(Level.FINEST)) {",
          "487:             }",
          "488:             SSLEngineResult result = sslEngine.wrap(message, appBuffer);",
          "489:             if (LOGGER.isLoggable(Level.FINEST)) {",
          "492:             }",
          "494:             switch (result.getStatus()) {",
          "",
          "[Removed Lines]",
          "485:                 LOGGER.log(Level.FINEST, \"[{0}] APP ENCODE: {1} bytes\",",
          "486:                         new Object[]{stack().name(), message.remaining()});",
          "490:                 LOGGER.log(Level.FINEST, \"[{0}] Handshake status: {1} engine result: {2}\",",
          "491:                         new Object[]{stack().name(), result.getHandshakeStatus(), result});",
          "",
          "[Added Lines]",
          "488:                 LOGGER.log(",
          "489:                         Level.FINEST, \"[{0}] APP ENCODE: {1} bytes\", new Object[] {stack().name(), message.remaining()",
          "490:                         });",
          "494:                 LOGGER.log(Level.FINEST, \"[{0}] Handshake status: {1} engine result: {2}\", new Object[] {",
          "495:                     stack().name(), result.getHandshakeStatus(), result",
          "496:                 });",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "508:                     done = !message.hasRemaining();",
          "509:                     if (appBuffer.hasRemaining()) {",
          "510:                         if (LOGGER.isLoggable(Level.FINEST)) {",
          "513:                         }",
          "514:                         while (appBuffer.hasRemaining()) {",
          "515:                             next().doSend(appBuffer);",
          "",
          "[Removed Lines]",
          "511:                             LOGGER.log(Level.FINEST, \"[{0}] APP SEND: {1} bytes\",",
          "512:                                     new Object[]{stack().name(), appBuffer.remaining()});",
          "",
          "[Added Lines]",
          "516:                             LOGGER.log(Level.FINEST, \"[{0}] APP SEND: {1} bytes\", new Object[] {",
          "517:                                 stack().name(), appBuffer.remaining()",
          "518:                             });",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java||src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java -> src/main/java/org/jenkinsci/remoting/util/AnonymousClassWarnings.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     }",
          "72:     private static void doCheck(@NonNull Class<?> c) {",
          "75:         } else if (c.isAnonymousClass()) { // e.g., pkg.Outer$1",
          "76:             warn(c, \"anonymous\");",
          "",
          "[Removed Lines]",
          "73:         if (Enum.class.isAssignableFrom(c)) { // e.g., com.cloudbees.plugins.credentials.CredentialsScope$1 ~ CredentialsScope.SYSTEM",
          "",
          "[Added Lines]",
          "74:         if (Enum.class.isAssignableFrom(",
          "75:                 c)) { // e.g., com.cloudbees.plugins.credentials.CredentialsScope$1 ~ CredentialsScope.SYSTEM",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:         String name = c.getName();",
          "86:         String codeSource = codeSource(c);",
          "87:         if (codeSource == null) {",
          "89:         } else {",
          "92:         }",
          "93:     }",
          "97:         CodeSource cs = c.getProtectionDomain().getCodeSource();",
          "98:         if (cs == null) {",
          "99:             return null;",
          "",
          "[Removed Lines]",
          "88:             LOGGER.warning(\"Attempt to (de-)serialize \" + kind + \" class \" + name + \"; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\");",
          "91:             LOGGER.warning(\"Attempt to (de-)serialize \" + kind + \" class \" + name + \" in \" + codeSource + \"; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\");",
          "95:     private static @CheckForNull",
          "96:     String codeSource(@NonNull Class<?> c) {",
          "",
          "[Added Lines]",
          "90:             LOGGER.warning(\"Attempt to (de-)serialize \" + kind + \" class \" + name",
          "91:                     + \"; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\");",
          "94:             LOGGER.warning(\"Attempt to (de-)serialize \" + kind + \" class \" + name + \" in \" + codeSource",
          "95:                     + \"; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\");",
          "99:     private static @CheckForNull String codeSource(@NonNull Class<?> c) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:         return new ObjectOutputStream(outputStream) {",
          "113:             @Override",
          "114:             protected void annotateClass(Class<?> c) throws IOException {",
          "",
          "[Removed Lines]",
          "111:     public static @NonNull ObjectOutputStream checkingObjectOutputStream(@NonNull OutputStream outputStream) throws IOException {",
          "",
          "[Added Lines]",
          "114:     public static @NonNull ObjectOutputStream checkingObjectOutputStream(@NonNull OutputStream outputStream)",
          "115:             throws IOException {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java||src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java -> src/main/java/org/jenkinsci/remoting/util/ByteBufferQueue.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:             }",
          "307:             int remaining = buffers[readIndex].position() - readPosition;",
          "308:             if (remaining > bytes) {",
          "310:                 skipped += bytes;",
          "311:                 break;",
          "312:             } else {",
          "",
          "[Removed Lines]",
          "309:                 readPosition += (int)bytes;",
          "",
          "[Added Lines]",
          "309:                 readPosition += (int) bytes;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "527:     @Override",
          "528:     public String toString() {",
          "541:     }",
          "",
          "[Removed Lines]",
          "529:         return getClass().getName() +",
          "530:                 \"[hasRemaining=\" +",
          "531:                 hasRemaining() +",
          "532:                 \",readIndex=\" +",
          "533:                 readIndex +",
          "534:                 \",writeIndex=\" +",
          "535:                 writeIndex +",
          "536:                 \",capacity=\" +",
          "537:                 buffers.length +",
          "538:                 \",bufSize=\" +",
          "539:                 bufferSize +",
          "540:                 ']';",
          "",
          "[Added Lines]",
          "529:         return getClass().getName() + \"[hasRemaining=\"",
          "530:                 + hasRemaining()",
          "531:                 + \",readIndex=\"",
          "532:                 + readIndex",
          "533:                 + \",writeIndex=\"",
          "534:                 + writeIndex",
          "535:                 + \",capacity=\"",
          "536:                 + buffers.length",
          "537:                 + \",bufSize=\"",
          "538:                 + bufferSize",
          "539:                 + ']';",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java||src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java -> src/main/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:         }",
          "162:         int l = mark.limit();",
          "163:         int p = mark.position();",
          "165:         queue.get(mark);",
          "166:         int skipped = mark.position() - p;",
          "167:         ((Buffer) mark).limit(l);",
          "",
          "[Removed Lines]",
          "164:         ((Buffer) mark).limit(mark.position() + (int)n);",
          "",
          "[Added Lines]",
          "165:         ((Buffer) mark).limit(mark.position() + (int) n);",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java||src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java -> src/main/java/org/jenkinsci/remoting/util/DurationFormatter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: @Restricted(NoExternalUse.class)",
          "35: public final class DurationFormatter {",
          "38:     public static String format(Duration d) {",
          "39:         StringBuilder sb = new StringBuilder();",
          "",
          "[Removed Lines]",
          "36:     private DurationFormatter(){}",
          "",
          "[Added Lines]",
          "36:     private DurationFormatter() {}",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/DurationStyle.java||src/main/java/org/jenkinsci/remoting/util/DurationStyle.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/DurationStyle.java -> src/main/java/org/jenkinsci/remoting/util/DurationStyle.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:                 String suffix = matcher.group(2);",
          "53:                 return ((suffix != null && !suffix.isEmpty()) ? Unit.fromSuffix(suffix) : Unit.fromChronoUnit(unit))",
          "54:                         .parse(matcher.group(1));",
          "57:                 throw new IllegalArgumentException(\"'\" + value + \"' is not a valid simple duration\", ex);",
          "58:             }",
          "59:         }",
          "",
          "[Removed Lines]",
          "55:             }",
          "56:             catch (Exception ex) {",
          "",
          "[Added Lines]",
          "55:             } catch (Exception ex) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         public Duration parse(String value, ChronoUnit unit) {",
          "75:             try {",
          "76:                 return Duration.parse(value);",
          "79:                 throw new IllegalArgumentException(\"'\" + value + \"' is not a valid ISO-8601 duration\", ex);",
          "80:             }",
          "81:         }",
          "",
          "[Removed Lines]",
          "77:             }",
          "78:             catch (Exception ex) {",
          "",
          "[Added Lines]",
          "75:             } catch (Exception ex) {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java||src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java -> src/main/java/org/jenkinsci/remoting/util/ExecutorServiceUtils.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: @Restricted(NoExternalUse.class)",
          "38: public class ExecutorServiceUtils {",
          "40:     private ExecutorServiceUtils() {",
          "42:     }",
          "54:             justification = \"User of this API explicitly submits the task in the async mode on his own risk\")",
          "55:     public static void submitAsync(@NonNull ExecutorService es, @NonNull Runnable runnable)",
          "56:             throws ExecutionRejectedException {",
          "",
          "[Removed Lines]",
          "53:     @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "",
          "[Added Lines]",
          "53:     @SuppressFBWarnings(",
          "54:             value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:     @NonNull",
          "74:     public static RejectedExecutionException createRuntimeException(",
          "77:         if (cause.isFatal()) {",
          "78:             return new FatalRejectedExecutionException(message, cause);",
          "79:         } else {",
          "80:             return new RejectedExecutionException(message, cause);",
          "81:         }",
          "82:     }",
          "",
          "[Removed Lines]",
          "75:             @NonNull String message,",
          "76:             @NonNull ExecutionRejectedException cause) {",
          "",
          "[Added Lines]",
          "76:             @NonNull String message, @NonNull ExecutionRejectedException cause) {",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java||src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java -> src/main/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStream.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:     @Override",
          "122:     @Override",
          "",
          "[Removed Lines]",
          "116:     public synchronized void mark(int readlimit) {",
          "117:     }",
          "123:     public synchronized void reset() throws IOException {",
          "124:     }",
          "",
          "[Added Lines]",
          "116:     public synchronized void mark(int readlimit) {}",
          "122:     public synchronized void reset() throws IOException {}",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/IOUtils.java||src/main/java/org/jenkinsci/remoting/util/IOUtils.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/IOUtils.java -> src/main/java/org/jenkinsci/remoting/util/IOUtils.java"
        ],
        "src/main/java/org/jenkinsci/remoting/util/SettableFuture.java||src/main/java/org/jenkinsci/remoting/util/SettableFuture.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/SettableFuture.java -> src/main/java/org/jenkinsci/remoting/util/SettableFuture.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "110:     private SettableFuture() {",
          "111:     }",
          "",
          "[Added Lines]",
          "110:     private SettableFuture() {}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "273:             try {",
          "274:                 executor.execute(listener);",
          "275:             } catch (RuntimeException e) {",
          "278:             }",
          "279:         }",
          "280:     }",
          "",
          "[Removed Lines]",
          "276:                 LOGGER.log(Level.SEVERE, e, () ->",
          "277:                         \"RuntimeException while executing runnable \" + listener + \" with executor \" + executor);",
          "",
          "[Added Lines]",
          "275:                 LOGGER.log(",
          "276:                         Level.SEVERE,",
          "277:                         e,",
          "278:                         () -> \"RuntimeException while executing runnable \" + listener + \" with executor \" + executor);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "294:             try {",
          "295:                 entry.getValue().execute(entry.getKey());",
          "296:             } catch (RuntimeException e) {",
          "299:                                 + entry.getValue());",
          "300:             }",
          "302:         }",
          "303:     }",
          "304: }",
          "",
          "[Removed Lines]",
          "297:                 LOGGER.log(Level.SEVERE, e, () ->",
          "298:                         \"RuntimeException while executing runnable \" + entry.getKey() + \" with executor \"",
          "",
          "[Added Lines]",
          "298:                 LOGGER.log(",
          "299:                         Level.SEVERE,",
          "300:                         e,",
          "301:                         () -> \"RuntimeException while executing runnable \" + entry.getKey() + \" with executor \"",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java||src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java -> src/main/java/org/jenkinsci/remoting/util/ThrowableUtils.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     @CheckForNull",
          "53:     public static <T extends Throwable, T1 extends T, T2 extends T> T chain(@CheckForNull T1 e1, @CheckForNull T2 e2) {",
          "56:         e1.addSuppressed(e2);",
          "57:         return e1;",
          "58:     }",
          "",
          "[Removed Lines]",
          "54:         if (e1 == null) return e2;",
          "55:         if (e2 == null) return e1;",
          "",
          "[Added Lines]",
          "54:         if (e1 == null) {",
          "55:             return e2;",
          "56:         }",
          "57:         if (e2 == null) {",
          "58:             return e1;",
          "59:         }",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/VersionNumber.java||src/main/java/org/jenkinsci/remoting/util/VersionNumber.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/VersionNumber.java -> src/main/java/org/jenkinsci/remoting/util/VersionNumber.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "102:         @Override",
          "103:         public int compare(Item item) {",
          "105:                 return 1;",
          "106:             switch (item.getType()) {",
          "107:                 case INTEGER_ITEM:",
          "108:                 case LIST_ITEM:",
          "",
          "[Removed Lines]",
          "104:             if (item==null) // 1.* ( > 1.99) > 1",
          "",
          "[Added Lines]",
          "105:             if (item == null) { // 1.* ( > 1.99) > 1",
          "107:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:         private static final BigInteger BigInteger_ZERO = new BigInteger(\"0\");",
          "141:         private final BigInteger value;",
          "",
          "[Removed Lines]",
          "137:     private static class IntegerItem",
          "138:             implements Item {",
          "",
          "[Added Lines]",
          "139:     private static class IntegerItem implements Item {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198:     private static class StringItem implements Item {",
          "205:         static {",
          "206:             ALIASES.put(\"ga\", \"\");",
          "",
          "[Removed Lines]",
          "199:         private final static String[] QUALIFIERS = {\"snapshot\", \"alpha\", \"beta\", \"milestone\", \"rc\", \"\", \"sp\"};",
          "201:         private final static List<String> _QUALIFIERS = Arrays.asList(QUALIFIERS);",
          "203:         private final static Properties ALIASES = new Properties();",
          "",
          "[Added Lines]",
          "200:         private static final String[] QUALIFIERS = {\"snapshot\", \"alpha\", \"beta\", \"milestone\", \"rc\", \"\", \"sp\"};",
          "202:         private static final List<String> _QUALIFIERS = Arrays.asList(QUALIFIERS);",
          "204:         private static final Properties ALIASES = new Properties();",
          "",
          "---------------"
        ],
        "src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java||src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java": [
          "File: src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java -> src/main/java/org/jenkinsci/remoting/util/https/NoCheckTrustManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: @SuppressFBWarnings(value = \"WEAK_TRUST_MANAGER\", justification = \"User set parameter to skip verifier.\")",
          "40: public class NoCheckTrustManager implements X509TrustManager {",
          "41:     @Override",
          "45:     @Override",
          "49:     @Override",
          "50:     public X509Certificate[] getAcceptedIssuers() {",
          "",
          "[Removed Lines]",
          "42:     public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {",
          "43:     }",
          "46:     public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {",
          "47:     }",
          "",
          "[Added Lines]",
          "42:     public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {}",
          "45:     public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {}",
          "",
          "---------------"
        ],
        "src/test/java/JarCertDump.java||src/test/java/JarCertDump.java": [
          "File: src/test/java/JarCertDump.java -> src/test/java/JarCertDump.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:     public static void main(String[] args) throws IOException {",
          "16:         try (JarFile j = new JarFile(new File(args[0]))) {",
          "17:             JarEntry je = j.getJarEntry(\"hudson/remoting/Channel.class\");",
          "19:             IOUtils.readLines(j.getInputStream(je), StandardCharsets.UTF_8);",
          "20:             for (Certificate c : je.getCertificates()) {",
          "21:                 System.out.println(\"################# Certificate #################\");",
          "",
          "[Removed Lines]",
          "18:             if (je==null)   throw new IllegalArgumentException();",
          "",
          "[Added Lines]",
          "18:             if (je == null) {",
          "19:                 throw new IllegalArgumentException();",
          "20:             }",
          "",
          "---------------"
        ],
        "src/test/java/OISInterception.java||src/test/java/OISInterception.java": [
          "File: src/test/java/OISInterception.java -> src/test/java/OISInterception.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: public class OISInterception {",
          "15:     public static void main(String[] args) throws Exception {",
          "16:         ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "18:             oos.writeObject(Set.of(\"foo\"));",
          "19:         }",
          "",
          "[Removed Lines]",
          "17:         try (ObjectOutputStream oos = new ObjectOutputStream(baos) ) {",
          "",
          "[Added Lines]",
          "17:         try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/AbstractNioChannelRunner.java||src/test/java/hudson/remoting/AbstractNioChannelRunner.java": [
          "File: src/test/java/hudson/remoting/AbstractNioChannelRunner.java -> src/test/java/hudson/remoting/AbstractNioChannelRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:         nio.close();",
          "35:         executor.shutdown();",
          "39:     }",
          "41:     @Override",
          "",
          "[Removed Lines]",
          "37:         if(failure!=null)",
          "38:             throw new AssertionError(failure);  // report a failure in the south side",
          "",
          "[Added Lines]",
          "36:         if (failure != null) {",
          "37:             throw new AssertionError(failure); // report a failure in the south side",
          "38:         }",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/BinarySafeStreamTest.java||src/test/java/hudson/remoting/BinarySafeStreamTest.java": [
          "File: src/test/java/hudson/remoting/BinarySafeStreamTest.java -> src/test/java/hudson/remoting/BinarySafeStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:             int ch = in.read();",
          "56:             assertEquals(b, ch);",
          "57:         }",
          "59:     }",
          "61:     @Test",
          "",
          "[Removed Lines]",
          "58:         assertEquals(-1,in.read());",
          "",
          "[Added Lines]",
          "58:         assertEquals(-1, in.read());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:         try (OutputStream o = BinarySafeStream.wrap(buf)) {",
          "68:             o.write(ds, 0, ds.length);",
          "69:         }",
          "71:     }",
          "73:     @Test",
          "",
          "[Removed Lines]",
          "70:         assertEquals(buf.toString(),master);",
          "",
          "[Added Lines]",
          "70:         assertEquals(buf.toString(), master);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:         String master = Base64.getEncoder().encodeToString(ds);",
          "78:         Random r = new Random(0);",
          "80:             ByteArrayOutputStream buf = new ByteArrayOutputStream();",
          "81:             OutputStream o = BinarySafeStream.wrap(buf);",
          "84:         }",
          "85:     }",
          "",
          "[Removed Lines]",
          "79:         for( int i=0; i<16; i++) {",
          "82:             randomCopy(r,new ByteArrayInputStream(ds),o,false);",
          "83:             assertEquals(buf.toString(),master);",
          "",
          "[Added Lines]",
          "79:         for (int i = 0; i < 16; i++) {",
          "82:             randomCopy(r, new ByteArrayInputStream(ds), o, false);",
          "83:             assertEquals(buf.toString(), master);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98:         byte[] dataSet = getDataSet(65536);",
          "99:         Random r = new Random(0);",
          "103:                 System.out.println(\"test started\");",
          "104:             ByteArrayOutputStream buf = new ByteArrayOutputStream();",
          "110:                 System.out.println(\"------\");",
          "112:             ByteArrayOutputStream dst = new ByteArrayOutputStream();",
          "115:             byte[] result = dst.toByteArray();",
          "117:                 String msg = print(result, 0, result.length);",
          "120:                 fail(msg);",
          "121:             }",
          "124:                 System.out.println(\"------\");",
          "125:         }",
          "126:     }",
          "",
          "[Removed Lines]",
          "101:         for(int i=0; i<16; i++) {",
          "102:             if(dump)",
          "105:             randomCopy(r,new ByteArrayInputStream(dataSet), BinarySafeStream.wrap(buf), flush);",
          "107:             decodeByMaster(buf.toString(),dataSet);",
          "109:             if(dump)",
          "113:             randomCopy(r,BinarySafeStream.wrap(new ByteArrayInputStream(buf.toByteArray())), dst,flush);",
          "116:             if(!Arrays.equals(dataSet, result)) {",
          "118:                 for( int j=0; j<result.length; j++ )",
          "119:                     assertEquals(result[j],dataSet[j], \"offset \"+j+\" at \"+msg);",
          "123:             if(dump)",
          "",
          "[Added Lines]",
          "101:         for (int i = 0; i < 16; i++) {",
          "102:             if (dump) {",
          "104:             }",
          "106:             randomCopy(r, new ByteArrayInputStream(dataSet), BinarySafeStream.wrap(buf), flush);",
          "108:             decodeByMaster(buf.toString(), dataSet);",
          "110:             if (dump) {",
          "112:             }",
          "115:             randomCopy(r, BinarySafeStream.wrap(new ByteArrayInputStream(buf.toByteArray())), dst, flush);",
          "118:             if (!Arrays.equals(dataSet, result)) {",
          "120:                 for (int j = 0; j < result.length; j++) {",
          "121:                     assertEquals(result[j], dataSet[j], \"offset \" + j + \" at \" + msg);",
          "122:                 }",
          "126:             if (dump) {",
          "128:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "131:     private void decodeByMaster(String s, byte[] dataSet) {",
          "136:             for (byte b : buf) {",
          "138:                     fail(\"encoding error at offset \" + ptr);",
          "139:                 ptr++;",
          "140:             }",
          "141:         }",
          "",
          "[Removed Lines]",
          "132:         int ptr=0;",
          "134:         for( int i=0; i<s.length(); i+=4 ) {",
          "135:             byte[] buf = Base64.getDecoder().decode(s.substring(i,i+4));",
          "137:                 if (b != dataSet[ptr])",
          "",
          "[Added Lines]",
          "136:         int ptr = 0;",
          "138:         for (int i = 0; i < s.length(); i += 4) {",
          "139:             byte[] buf = Base64.getDecoder().decode(s.substring(i, i + 4));",
          "141:                 if (b != dataSet[ptr]) {",
          "143:                 }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "147:     private byte[] getDataSet(int len) {",
          "148:         byte[] dataSet = new byte[len];",
          "151:         return dataSet;",
          "152:     }",
          "",
          "[Removed Lines]",
          "149:         for( int i=0; i<dataSet.length; i++ )",
          "150:             dataSet[i] = (byte)i;",
          "",
          "[Added Lines]",
          "154:         for (int i = 0; i < dataSet.length; i++) {",
          "155:             dataSet[i] = (byte) i;",
          "156:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "160:                         if (dump) {",
          "161:                             System.out.println(\"read1(\" + ch + ')');",
          "162:                         }",
          "164:                         if (ch == -1) {",
          "165:                             return;",
          "166:                         }",
          "",
          "[Removed Lines]",
          "163:                         assertTrue(255 >= ch && ch >= -1);  // make sure the range is [-1,255]",
          "",
          "[Added Lines]",
          "169:                         assertTrue(255 >= ch && ch >= -1); // make sure the range is [-1,255]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "175:                         byte[] tmp = new byte[start + chunk + trail];",
          "176:                         int len = in.read(tmp, start, chunk);",
          "177:                         if (dump) {",
          "179:                         }",
          "180:                         if (len == -1) {",
          "181:                             return;",
          "",
          "[Removed Lines]",
          "178:                             System.out.println(\"read2(\" + print(tmp, start, len) + \",len=\" + len + \",chunk=\" + chunk + \")\");",
          "",
          "[Added Lines]",
          "184:                             System.out.println(",
          "185:                                     \"read2(\" + print(tmp, start, len) + \",len=\" + len + \",chunk=\" + chunk + \")\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "219:         StringBuilder out = new StringBuilder();",
          "220:         out.append('{');",
          "221:         for (int i = 0; i < len; i++) {",
          "225:         }",
          "226:         return out.append('}').toString();",
          "227:     }",
          "",
          "[Removed Lines]",
          "222:             byte b = buf[i+start];",
          "223:             if(i>0) out.append(',');",
          "224:             out.append(((int)b)&0xFF);",
          "",
          "[Added Lines]",
          "229:             byte b = buf[i + start];",
          "230:             if (i > 0) {",
          "231:                 out.append(',');",
          "232:             }",
          "233:             out.append(((int) b) & 0xFF);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/CallableBase.java||src/test/java/hudson/remoting/CallableBase.java": [
          "File: src/test/java/hudson/remoting/CallableBase.java -> src/test/java/hudson/remoting/CallableBase.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     @Override",
          "11:     public void checkRoles(RoleChecker checker) throws SecurityException {",
          "13:     }",
          "15:     public static final Role ROLE = new Role(\"test callable\");",
          "",
          "[Removed Lines]",
          "9: public abstract class CallableBase<V,T extends Throwable> implements Callable<V,T> {",
          "12:         checker.check(this,ROLE);",
          "",
          "[Added Lines]",
          "9: public abstract class CallableBase<V, T extends Throwable> implements Callable<V, T> {",
          "12:         checker.check(this, ROLE);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ChannelFilterTest.java||src/test/java/hudson/remoting/ChannelFilterTest.java": [
          "File: src/test/java/hudson/remoting/ChannelFilterTest.java -> src/test/java/hudson/remoting/ChannelFilterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:         @Override",
          "50:         public Object call() throws Exception {",
          "52:         }",
          "53:         private static final long serialVersionUID = 1L;",
          "54:     }",
          "",
          "[Removed Lines]",
          "51:            return c.call();",
          "",
          "[Added Lines]",
          "51:             return c.call();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:         channelRunner.withChannel(channel -> {",
          "60:             channel.addLocalExecutionInterceptor(new CallableDecorator() {",
          "61:                 @Override",
          "64:                         throw new SecurityException(\"Rejecting \" + op.getClass().getName());",
          "65:                     return stem;",
          "66:                 }",
          "67:             });",
          "",
          "[Removed Lines]",
          "62:                 public <V, T extends Throwable> hudson.remoting.Callable<V, T> userRequest(hudson.remoting.Callable<V, T> op, hudson.remoting.Callable<V, T> stem) {",
          "63:                     if (op instanceof ShadyBusiness)",
          "",
          "[Added Lines]",
          "63:                 public <V, T extends Throwable> hudson.remoting.Callable<V, T> userRequest(",
          "64:                         hudson.remoting.Callable<V, T> op, hudson.remoting.Callable<V, T> stem) {",
          "65:                     if (op instanceof ShadyBusiness) {",
          "67:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:             assertEquals(\"gun\", channel.call(new GunImporter()));",
          "74:             final IOException e = assertThrows(IOException.class, () -> channel.call(new ReverseGunImporter()));",
          "76:         });",
          "77:     }",
          "78:     private static SecurityException findSecurityException(Throwable x) {",
          "79:         if (x instanceof SecurityException) {",
          "80:             return (SecurityException) x;",
          "",
          "[Removed Lines]",
          "75:             assertEquals(\"Rejecting \" + GunImporter.class.getName(), findSecurityException(e).getMessage());",
          "",
          "[Added Lines]",
          "77:             assertEquals(",
          "78:                     \"Rejecting \" + GunImporter.class.getName(),",
          "79:                     findSecurityException(e).getMessage());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "86:     }",
          "96:     private interface ShadyBusiness {}",
          "99:         @Override",
          "100:         public String call() {",
          "101:             return \"gun\";",
          "102:         }",
          "103:         private static final long serialVersionUID = 1L;",
          "104:     }",
          "",
          "[Removed Lines]",
          "89:         Option 1:",
          "90:                 define CallableFilter2 that decorates h.r.Callable, not j.u.c.Callable",
          "91:                 like 'callUserRequest' maybe",
          "92:         Option 2:",
          "93:                 define a separate interface.",
          "98:     static class GunImporter extends CallableBase<String,IOException> implements ShadyBusiness {",
          "",
          "[Added Lines]",
          "94:        Option 1:",
          "95:                define CallableFilter2 that decorates h.r.Callable, not j.u.c.Callable",
          "96:                like 'callUserRequest' maybe",
          "97:        Option 2:",
          "98:                define a separate interface.",
          "103:     static class GunImporter extends CallableBase<String, IOException> implements ShadyBusiness {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ChannelRunner.java||src/test/java/hudson/remoting/ChannelRunner.java": [
          "File: src/test/java/hudson/remoting/ChannelRunner.java -> src/test/java/hudson/remoting/ChannelRunner.java"
        ],
        "src/test/java/hudson/remoting/ChannelRunners.java||src/test/java/hudson/remoting/ChannelRunners.java": [
          "File: src/test/java/hudson/remoting/ChannelRunners.java -> src/test/java/hudson/remoting/ChannelRunners.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:                 new NioPipeRunner(),",
          "16:                 new InProcessCompatibilityRunner(),",
          "17:                 new ForkRunner(),",
          "20:     }",
          "21: }",
          "",
          "[Removed Lines]",
          "18:                 new ForkEBCDICRunner()",
          "19:         );",
          "",
          "[Added Lines]",
          "18:                 new ForkEBCDICRunner());",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ChannelTest.java||src/test/java/hudson/remoting/ChannelTest.java": [
          "File: src/test/java/hudson/remoting/ChannelTest.java -> src/test/java/hudson/remoting/ChannelTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:     @ParameterizedTest",
          "41:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "42:     public void testCapability(ChannelRunner channelRunner) throws Exception {",
          "44:         channelRunner.withChannel(channel -> assertTrue(channel.remoteCapability.supportsMultiClassLoaderRPC()));",
          "45:     }",
          "",
          "[Removed Lines]",
          "43:         assumeFalse(channelRunner instanceof InProcessCompatibilityRunner, \"In-process runner does not support multi-classloader RPC\");",
          "",
          "[Added Lines]",
          "43:         assumeFalse(",
          "44:                 channelRunner instanceof InProcessCompatibilityRunner,",
          "45:                 \"In-process runner does not support multi-classloader RPC\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:         });",
          "56:     }",
          "59:         @Override",
          "60:         public Object call() {",
          "61:             return null;",
          "",
          "[Removed Lines]",
          "58:     private static class CallableImpl extends CallableBase<Object,IOException> {",
          "",
          "[Added Lines]",
          "60:     private static class CallableImpl extends CallableBase<Object, IOException> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:                 final GreeterImpl g = new GreeterImpl();",
          "80:                 channel.call(new GreetingTask(g));",
          "81:                 assertEquals(g.name, \"Kohsuke\");",
          "83:             }",
          "84:         });",
          "85:     }",
          "",
          "[Removed Lines]",
          "82:                 assertFalse(channel.exportedObjects.isExported(g), \"in this scenario, auto-unexport by the caller should kick in.\");",
          "",
          "[Added Lines]",
          "85:                 assertFalse(",
          "86:                         channel.exportedObjects.isExported(g),",
          "87:                         \"in this scenario, auto-unexport by the caller should kick in.\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "153:         @Override",
          "154:         public Void call() throws Exception {",
          "155:             Thread.sleep(500);",
          "157:             return null;",
          "158:         }",
          "159:         private static final long serialVersionUID = 1L;",
          "160:     }",
          "",
          "[Removed Lines]",
          "156:             getChannelOrFail().setProperty(\"foo\",\"bar\");",
          "",
          "[Added Lines]",
          "161:             getChannelOrFail().setProperty(\"foo\", \"bar\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "166:     private static class GreeterImpl implements Greeter, SerializableOnlyOverRemoting {",
          "167:         String name;",
          "168:         @Override",
          "169:         public void greet(String name) {",
          "170:             this.name = name;",
          "171:         }",
          "173:         private Object writeReplace() throws ObjectStreamException {",
          "175:         }",
          "176:     }",
          "",
          "[Removed Lines]",
          "174:             return getChannelForSerialization().export(Greeter.class,this);",
          "",
          "[Added Lines]",
          "181:             return getChannelForSerialization().export(Greeter.class, this);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "201:         });",
          "202:     }",
          "205:         private final T t;",
          "207:         Echo(T t) {",
          "",
          "[Removed Lines]",
          "204:     private static class Echo<T> extends CallableBase<T,RuntimeException> {",
          "",
          "[Added Lines]",
          "211:     private static class Echo<T> extends CallableBase<T, RuntimeException> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "246:             assertEquals(RuntimeException.class, rootCause.getClass());",
          "247:             Throwable callSite = cause.getSuppressed()[0];",
          "248:             assertEquals(\"Remote call to north\", callSite.getMessage());",
          "250:         });",
          "251:     }",
          "",
          "[Removed Lines]",
          "249:             assertEquals(\"hudson.remoting.Channel$CallSiteStackTrace\", callSite.getClass().getName());",
          "",
          "[Added Lines]",
          "257:             assertEquals(",
          "258:                     \"hudson.remoting.Channel$CallSiteStackTrace\",",
          "259:                     callSite.getClass().getName());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "259:     }",
          "261:     private static class ThrowingCallable extends CallableBase<Void, IOException> {",
          "263:             throw new IOException(\"Node Nested\", new RuntimeException(\"Node says hello!\"));",
          "264:         }",
          "265:         private static final long serialVersionUID = 1L;",
          "266:     }",
          "",
          "[Removed Lines]",
          "262:         @Override public Void call() throws IOException {",
          "",
          "[Added Lines]",
          "272:         @Override",
          "273:         public Void call() throws IOException {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "302:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "303:     public void testShouldNotAcceptUserRPCRequestsWhenIsBeingClosed(ChannelRunner channelRunner) throws Exception {",
          "304:         channelRunner.withChannel(channel -> {",
          "306:             Collection<String> src = new ArrayList<>();",
          "307:             src.add(\"Hello\");",
          "308:             src.add(\"World\");",
          "314:             try (ChannelCloseLock ignored = new ChannelCloseLock(channel)) {",
          "",
          "[Removed Lines]",
          "312:             final Collection<String> remoteList = channel.call(new RMIObjectExportedCallable<>(src, Collection.class, true));",
          "",
          "[Added Lines]",
          "323:             final Collection<String> remoteList =",
          "324:                     channel.call(new RMIObjectExportedCallable<>(src, Collection.class, true));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "342:         }",
          "344:         @Override",
          "348:         private static final long serialVersionUID = 1L;",
          "349:     }",
          "",
          "[Removed Lines]",
          "345:         public void checkRoles(RoleChecker checker) throws SecurityException {",
          "347:         }",
          "",
          "[Added Lines]",
          "357:         public void checkRoles(RoleChecker checker) throws SecurityException {}",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "456:             };",
          "457:         }",
          "458:     }",
          "460:     private void assertFailsWithChannelClosedException(Channel channel, TestRunnable call) throws AssertionError {",
          "461:         try {",
          "462:             call.run(channel);",
          "464:             LOGGER.log(Level.WARNING, \"Call execution failed with exception\", ex);",
          "465:             Throwable cause = ex instanceof RemotingSystemException ? ex.getCause() : ex;",
          "466:             if (cause instanceof ChannelClosedException) {",
          "",
          "[Removed Lines]",
          "463:         } catch(Exception ex) {",
          "",
          "[Added Lines]",
          "473:         } catch (Exception ex) {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ChecksumTest.java||src/test/java/hudson/remoting/ChecksumTest.java": [
          "File: src/test/java/hudson/remoting/ChecksumTest.java -> src/test/java/hudson/remoting/ChecksumTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:     private static final String FILE_CONTENTS1 = \"These are the file contents\";",
          "25:     private static final String FILE_CONTENTS2 = \"These are some other file contents\";",
          "29:     @Test",
          "30:     public void testForFileAndURL() throws Exception {",
          "",
          "[Removed Lines]",
          "27:     @Rule public TemporaryFolder tmp = new TemporaryFolder();",
          "",
          "[Added Lines]",
          "27:     @Rule",
          "28:     public TemporaryFolder tmp = new TemporaryFolder();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:         HashCode hash2 = Files.asByteSource(tmpFile2).hash(Hashing.sha256());",
          "36:         assertEquals(createdExpectedChecksum(hash1), Checksum.forFile(tmpFile1));",
          "39:         assertEquals(createdExpectedChecksum(hash2), Checksum.forFile(tmpFile2));",
          "42:         assertNotEquals(Checksum.forFile(tmpFile1), Checksum.forFile(tmpFile2));",
          "43:     }",
          "",
          "[Removed Lines]",
          "37:         assertEquals(createdExpectedChecksum(hash1), Checksum.forURL(tmpFile1.toURI().toURL()));",
          "40:         assertEquals(createdExpectedChecksum(hash2), Checksum.forURL(tmpFile2.toURI().toURL()));",
          "",
          "[Added Lines]",
          "38:         assertEquals(",
          "39:                 createdExpectedChecksum(hash1), Checksum.forURL(tmpFile1.toURI().toURL()));",
          "42:         assertEquals(",
          "43:                 createdExpectedChecksum(hash2), Checksum.forURL(tmpFile2.toURI().toURL()));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56:             long nextLong = in.readLong();",
          "57:             if (i % 2 == 0) {",
          "58:                 sum1 ^= nextLong;",
          "61:                 sum2 ^= nextLong;",
          "62:             }",
          "63:         }",
          "",
          "[Removed Lines]",
          "59:             }",
          "60:             else {",
          "",
          "[Added Lines]",
          "62:             } else {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ChunkedInputStreamTest.java||src/test/java/hudson/remoting/ChunkedInputStreamTest.java": [
          "File: src/test/java/hudson/remoting/ChunkedInputStreamTest.java -> src/test/java/hudson/remoting/ChunkedInputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: public class ChunkedInputStreamTest extends Assert {",
          "26:     ChunkedInputStream i = new ChunkedInputStream(buf.getInputStream());",
          "29:     ExecutorService es = Executors.newFixedThreadPool(2);",
          "",
          "[Removed Lines]",
          "25:     FifoBuffer buf = new FifoBuffer(53,1024*1024);",
          "27:     ChunkedOutputStream o = new ChunkedOutputStream(37,buf.getOutputStream());",
          "",
          "[Added Lines]",
          "25:     FifoBuffer buf = new FifoBuffer(53, 1024 * 1024);",
          "27:     ChunkedOutputStream o = new ChunkedOutputStream(37, buf.getOutputStream());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:     @Test",
          "40:     public void tenMegaCopy() throws Exception {",
          "43:     }",
          "45:     @Test",
          "46:     public void boundaryPositionCheck() throws Exception {",
          "86:     }",
          "89:     private void test(final Workload w, final InputStream i, final OutputStream o) throws Exception {",
          "90:         Future<Object> fw = es.submit(() -> {",
          "91:             w.write(o);",
          "",
          "[Removed Lines]",
          "41:         test(new RandomWorkload(10*1024*1024),",
          "42:                 i, new AutoChunkedOutputStream(o));",
          "47:         test(new Workload() {",
          "48:             int size = 1024;",
          "50:             @Override",
          "51:             public void write(OutputStream o) throws IOException {",
          "52:                 Random boundary = new Random(0);",
          "53:                 Random data = new Random(1);",
          "55:                 for (int j=0; j<size; j++) {",
          "56:                     byte[] buf = new byte[boundary.nextInt(4096)];",
          "57:                     data.nextBytes(buf);",
          "58:                     o.write(buf);",
          "59:                     ((ChunkedOutputStream)o).sendBreak();",
          "60:                 }",
          "62:                 o.close();",
          "63:             }",
          "65:             @Override",
          "66:             public void read(InputStream i) throws IOException {",
          "67:                 Random boundary = new Random(0);",
          "68:                 Random data = new Random(1);",
          "70:                 for (int j=0; j<size; j++) {",
          "71:                     byte[] buf = new byte[boundary.nextInt(4096)];",
          "72:                     data.nextBytes(buf);",
          "74:                     ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "75:                     ((ChunkedInputStream) i).readUntilBreak(baos);",
          "77:                     assertEquals(buf.length, baos.size());",
          "78:                     assertArrayEquals(buf, baos.toByteArray());",
          "79:                 }",
          "81:                 assertEquals(-1, i.read());",
          "83:                 i.close();",
          "84:             }",
          "85:         },i,o);",
          "",
          "[Added Lines]",
          "41:         test(new RandomWorkload(10 * 1024 * 1024), i, new AutoChunkedOutputStream(o));",
          "46:         test(",
          "47:                 new Workload() {",
          "48:                     int size = 1024;",
          "50:                     @Override",
          "51:                     public void write(OutputStream o) throws IOException {",
          "52:                         Random boundary = new Random(0);",
          "53:                         Random data = new Random(1);",
          "55:                         for (int j = 0; j < size; j++) {",
          "56:                             byte[] buf = new byte[boundary.nextInt(4096)];",
          "57:                             data.nextBytes(buf);",
          "58:                             o.write(buf);",
          "59:                             ((ChunkedOutputStream) o).sendBreak();",
          "60:                         }",
          "62:                         o.close();",
          "63:                     }",
          "65:                     @Override",
          "66:                     public void read(InputStream i) throws IOException {",
          "67:                         Random boundary = new Random(0);",
          "68:                         Random data = new Random(1);",
          "70:                         for (int j = 0; j < size; j++) {",
          "71:                             byte[] buf = new byte[boundary.nextInt(4096)];",
          "72:                             data.nextBytes(buf);",
          "74:                             ByteArrayOutputStream baos = new ByteArrayOutputStream();",
          "75:                             ((ChunkedInputStream) i).readUntilBreak(baos);",
          "77:                             assertEquals(buf.length, baos.size());",
          "78:                             assertArrayEquals(buf, baos.toByteArray());",
          "79:                         }",
          "81:                         assertEquals(-1, i.read());",
          "83:                         i.close();",
          "84:                     }",
          "85:                 },",
          "86:                 i,",
          "87:                 o);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "113:         @Override",
          "114:         public void write(@NonNull byte[] b, int off, int len) throws IOException {",
          "115:             out.write(b, off, len);",
          "117:         }",
          "118:     }",
          "119: }",
          "",
          "[Removed Lines]",
          "116:             ((ChunkedOutputStream)out).sendBreak();",
          "",
          "[Added Lines]",
          "117:             ((ChunkedOutputStream) out).sendBreak();",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ClassFilterTest.java||src/test/java/hudson/remoting/ClassFilterTest.java": [
          "File: src/test/java/hudson/remoting/ClassFilterTest.java -> src/test/java/hudson/remoting/ClassFilterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:         setUp(new InProcessRunner() {",
          "61:             @Override",
          "62:             protected ChannelBuilder configureNorth() {",
          "65:             }",
          "66:         });",
          "67:     }",
          "",
          "[Removed Lines]",
          "63:                 return super.configureNorth()",
          "64:                         .withClassFilter(new TestFilter());",
          "",
          "[Added Lines]",
          "63:                 return super.configureNorth().withClassFilter(new TestFilter());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:         setUp(new InProcessRunner() {",
          "76:             @Override",
          "77:             protected ChannelBuilder configureNorth() {",
          "81:             }",
          "83:             @Override",
          "",
          "[Removed Lines]",
          "78:                 return super.configureNorth()",
          "79:                         .withCapability(Capability.NONE)",
          "80:                         .withClassFilter(new TestFilter());",
          "",
          "[Added Lines]",
          "77:                 return super.configureNorth().withCapability(Capability.NONE).withClassFilter(new TestFilter());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:     @After",
          "98:     public void tearDown() throws Exception {",
          "100:             runner.stop(north);",
          "101:     }",
          "",
          "[Removed Lines]",
          "99:         if (runner!=null)",
          "",
          "[Added Lines]",
          "96:         if (runner != null) {",
          "98:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:             oos.writeObject(new Security218(\"rifle\"));",
          "111:         }",
          "115:         assertEquals(\"Rejected: \" + Security218.class.getName(), e.getMessage());",
          "116:     }",
          "",
          "[Removed Lines]",
          "113:         final SecurityException e = assertThrows(SecurityException.class,",
          "114:                 () -> Capability.read(new ByteArrayInputStream(baos.toByteArray())));",
          "",
          "[Added Lines]",
          "111:         final SecurityException e = assertThrows(",
          "112:                 SecurityException.class, () -> Capability.read(new ByteArrayInputStream(baos.toByteArray())));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "188:         setUp(new NioSocketRunner() {",
          "189:             @Override",
          "190:             protected NioChannelBuilder configureNorth() {",
          "193:             }",
          "194:         });",
          "195:         commandStreamTestSequence();",
          "",
          "[Removed Lines]",
          "191:                 return super.configureNorth()",
          "192:                         .withClassFilter(new TestFilter());",
          "",
          "[Added Lines]",
          "189:                 return super.configureNorth().withClassFilter(new TestFilter());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "249:         private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {",
          "250:             ois.defaultReadObject();",
          "252:         }",
          "254:         @Override",
          "",
          "[Removed Lines]",
          "251:             System.setProperty(\"attack\", attack + \">\" + getChannelForSerialization().getName());",
          "",
          "[Added Lines]",
          "248:             System.setProperty(",
          "249:                     \"attack\", attack + \">\" + getChannelForSerialization().getName());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "281:         @Override",
          "282:         public Void call() {",
          "284:             return null;",
          "285:         }",
          "286:         private static final long serialVersionUID = 1L;",
          "287:     }",
          "288:     private static final long serialVersionUID = 1L;",
          "289: }",
          "",
          "[Removed Lines]",
          "283:             a.toString();   // this will ensure 'a' gets sent over",
          "",
          "[Added Lines]",
          "282:             a.toString(); // this will ensure 'a' gets sent over",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ClassRemoting2Test.java||src/test/java/hudson/remoting/ClassRemoting2Test.java": [
          "File: src/test/java/hudson/remoting/ClassRemoting2Test.java -> src/test/java/hudson/remoting/ClassRemoting2Test.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: @WithRunner({",
          "55: })",
          "56: public class ClassRemoting2Test {",
          "",
          "[Removed Lines]",
          "52:         InProcessRunner.class,",
          "53:         NioSocketRunner.class,",
          "54:         NioPipeRunner.class,",
          "",
          "[Added Lines]",
          "52:     InProcessRunner.class,",
          "53:     NioSocketRunner.class,",
          "54:     NioPipeRunner.class,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:     @SuppressWarnings(\"unused\") // used by JUnit",
          "61:     static Stream<ChannelRunner> provider() {",
          "67:     }",
          "69:     @After",
          "",
          "[Removed Lines]",
          "62:         return Stream.of(",
          "63:                 new InProcessRunner(),",
          "64:                 new NioSocketRunner(),",
          "65:                 new NioPipeRunner()",
          "66:         );",
          "",
          "[Added Lines]",
          "62:         return Stream.of(new InProcessRunner(), new NioSocketRunner(), new NioPipeRunner());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "205:     @Issue(\"JENKINS-61103\")",
          "206:     @ParameterizedTest",
          "207:     @MethodSource(PROVIDER_METHOD)",
          "209:         channelRunner.withChannel(channel -> {",
          "210:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticResourceReference.class);",
          "213:             RemoteClassLoader.TESTING_RESOURCE_LOAD = new InterruptInvocation(1, 1);",
          "214:             Future<Object> f1 = ClassRemotingTest.scheduleCallableLoad(channel, callable);",
          "",
          "[Removed Lines]",
          "208:     public void testSingleInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner) throws Exception {",
          "211:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "[Added Lines]",
          "204:     public void testSingleInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner)",
          "205:             throws Exception {",
          "208:             final Callable<Object, Exception> callable =",
          "209:                     (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "222:     @Issue(\"JENKINS-61103\")",
          "223:     @ParameterizedTest",
          "224:     @MethodSource(PROVIDER_METHOD)",
          "226:         channelRunner.withChannel(channel -> {",
          "227:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticResourceReference.class);",
          "230:             RemoteClassLoader.RETRY_SLEEP_DURATION_MILLISECONDS = 1;",
          "231:             RemoteClassLoader.MAX_RETRIES = 10;",
          "",
          "[Removed Lines]",
          "225:     public void testMultipleInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner) throws Exception {",
          "228:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "[Added Lines]",
          "223:     public void testMultipleInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner)",
          "224:             throws Exception {",
          "227:             final Callable<Object, Exception> callable =",
          "228:                     (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "241:     @Issue(\"JENKINS-61103\")",
          "242:     @ParameterizedTest",
          "243:     @MethodSource(PROVIDER_METHOD)",
          "245:         channelRunner.withChannel(channel -> {",
          "246:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticResourceReference.class);",
          "249:             RemoteClassLoader.RETRY_SLEEP_DURATION_MILLISECONDS = 1;",
          "250:             RemoteClassLoader.MAX_RETRIES = 3;",
          "",
          "[Removed Lines]",
          "244:     public void testContinuedInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner) throws Exception {",
          "247:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "[Added Lines]",
          "244:     public void testContinuedInterruptionOfClassInitializationWithStaticResourceReference(ChannelRunner channelRunner)",
          "245:             throws Exception {",
          "248:             final Callable<Object, Exception> callable =",
          "249:                     (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "261:     public void testSingleInterruptionOfFindResources(ChannelRunner channelRunner) throws Exception {",
          "262:         channelRunner.withChannel(channel -> {",
          "263:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticGetResources.class);",
          "266:             RemoteClassLoader.TESTING_RESOURCE_LOAD = new InterruptInvocation(1, 1);",
          "267:             Future<Object> f1 = ClassRemotingTest.scheduleCallableLoad(channel, callable);",
          "",
          "[Removed Lines]",
          "264:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "[Added Lines]",
          "266:             final Callable<Object, Exception> callable =",
          "267:                     (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "278:     public void testMultipleInterruptionOfFindResources(ChannelRunner channelRunner) throws Exception {",
          "279:         channelRunner.withChannel(channel -> {",
          "280:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticGetResources.class);",
          "283:             RemoteClassLoader.RETRY_SLEEP_DURATION_MILLISECONDS = 1;",
          "284:             RemoteClassLoader.MAX_RETRIES = 10;",
          "",
          "[Removed Lines]",
          "281:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "[Added Lines]",
          "284:             final Callable<Object, Exception> callable =",
          "285:                     (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "297:     public void testContinuedInterruptionOfFindResources(ChannelRunner channelRunner) throws Exception {",
          "298:         channelRunner.withChannel(channel -> {",
          "299:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticGetResources.class);",
          "302:             RemoteClassLoader.RETRY_SLEEP_DURATION_MILLISECONDS = 1;",
          "303:             RemoteClassLoader.MAX_RETRIES = 3;",
          "",
          "[Removed Lines]",
          "300:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "[Added Lines]",
          "304:             final Callable<Object, Exception> callable =",
          "305:                     (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ClassRemotingTest.java||src/test/java/hudson/remoting/ClassRemotingTest.java": [
          "File: src/test/java/hudson/remoting/ClassRemotingTest.java -> src/test/java/hudson/remoting/ClassRemotingTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:         channelRunner.withChannel(channel -> {",
          "63:             Object[] result = (Object[]) channel.call(callable);",
          "",
          "[Removed Lines]",
          "61:             Callable<Object, Exception> callable = (Callable<Object, Exception>) DummyClassLoader.apply(TestCallable.class);",
          "",
          "[Added Lines]",
          "61:             Callable<Object, Exception> callable =",
          "62:                     (Callable<Object, Exception>) DummyClassLoader.apply(TestCallable.class);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:     @ParameterizedTest",
          "74:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "75:     public void testRemoteProperty(ChannelRunner channelRunner) throws Exception {",
          "78:         channelRunner.withChannel(channel -> {",
          "79:             DummyClassLoader cl = new DummyClassLoader(TestCallable.class);",
          "80:             Callable<Object, Exception> c = (Callable<Object, Exception>) cl.load(TestCallable.class);",
          "81:             assertSame(c.getClass().getClassLoader(), cl);",
          "85:             channel.call(new RemotePropertyVerifier());",
          "86:         });",
          "",
          "[Removed Lines]",
          "76:         assumeFalse(channelRunner instanceof InProcessCompatibilityRunner,\"this test cannot run in the compatibility mode without the multi-classloader serialization support,\" +",
          "77:                 \"because it uses the class loader specified during proxy construction.\");",
          "83:             channel.setProperty(\"test\",c);",
          "",
          "[Added Lines]",
          "77:         assumeFalse(",
          "78:                 channelRunner instanceof InProcessCompatibilityRunner,",
          "79:                 \"this test cannot run in the compatibility mode without the multi-classloader serialization support,\"",
          "80:                         + \"because it uses the class loader specified during proxy construction.\");",
          "86:             channel.setProperty(\"test\", c);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:         channelRunner.withChannel(channel -> {",
          "95:             DummyClassLoader parent = new DummyClassLoader(TestCallable.class);",
          "96:             DummyClassLoader child1 = new DummyClassLoader(parent, TestCallable.Sub.class);",
          "98:             assertEquals(child1, c1.getClass().getClassLoader());",
          "99:             assertEquals(parent, c1.getClass().getSuperclass().getClassLoader());",
          "100:             DummyClassLoader child2 = new DummyClassLoader(parent, TestCallable.Sub.class);",
          "102:             assertEquals(child2, c2.getClass().getClassLoader());",
          "103:             assertEquals(parent, c2.getClass().getSuperclass().getClassLoader());",
          "104:             ExecutorService svc = Executors.newFixedThreadPool(2);",
          "",
          "[Removed Lines]",
          "97:             final Callable<Object,Exception> c1 = (Callable<Object, Exception>) child1.load(TestCallable.Sub.class);",
          "101:             final Callable<Object,Exception> c2 = (Callable<Object, Exception>) child2.load(TestCallable.Sub.class);",
          "",
          "[Added Lines]",
          "100:             final Callable<Object, Exception> c1 = (Callable<Object, Exception>) child1.load(TestCallable.Sub.class);",
          "104:             final Callable<Object, Exception> c2 = (Callable<Object, Exception>) child2.load(TestCallable.Sub.class);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "107:             java.util.concurrent.Future<Object> f2 = svc.submit(() -> channel.call(c2));",
          "108:             Object result1 = f1.get();",
          "109:             Object result2 = f2.get();",
          "112:         });",
          "113:     }",
          "",
          "[Removed Lines]",
          "110:             assertTestCallableResults((Object[])result1);",
          "111:             assertTestCallableResults((Object[])result2);",
          "",
          "[Added Lines]",
          "113:             assertTestCallableResults((Object[]) result1);",
          "114:             assertTestCallableResults((Object[]) result2);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "118:     public void testClassCreation_TestCallable(ChannelRunner channelRunner) throws Exception {",
          "119:         channelRunner.withChannel(channel -> {",
          "120:             DummyClassLoader dummyClassLoader = new DummyClassLoader(TestCallable.class);",
          "122:             java.util.concurrent.Future<Object> f1 = scheduleCallableLoad(channel, callable);",
          "124:             Object result = f1.get();",
          "127:             Object loadResult = dummyClassLoader.load(TestCallable.class);",
          "129:         });",
          "130:     }",
          "",
          "[Removed Lines]",
          "121:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dummyClassLoader.load(TestCallable.class);",
          "126:             assertTestCallableResults((Object[])result);",
          "128:             assertEquals(TESTCALLABLE_TRANSFORMED_CLASSNAME, loadResult.getClass().getName());",
          "",
          "[Added Lines]",
          "124:             final Callable<Object, Exception> callable =",
          "125:                     (Callable<Object, Exception>) dummyClassLoader.load(TestCallable.class);",
          "130:             assertTestCallableResults((Object[]) result);",
          "132:             assertEquals(",
          "133:                     TESTCALLABLE_TRANSFORMED_CLASSNAME, loadResult.getClass().getName());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "153:     public void testClassCreation_TestStaticResourceReference(ChannelRunner channelRunner) throws Exception {",
          "154:         channelRunner.withChannel(channel -> {",
          "155:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticResourceReference.class);",
          "157:             Future<Object> f1 = ClassRemotingTest.scheduleCallableLoad(channel, callable);",
          "159:             Object result = f1.get();",
          "",
          "[Removed Lines]",
          "156:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "[Added Lines]",
          "161:             final Callable<Object, Exception> callable =",
          "162:                     (Callable<Object, Exception>) dcl.load(TestStaticResourceReference.class);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "168:     public void testClassCreation_TestFindResources(ChannelRunner channelRunner) throws Exception {",
          "169:         channelRunner.withChannel(channel -> {",
          "170:             final DummyClassLoader dcl = new DummyClassLoader(TestStaticGetResources.class);",
          "172:             Future<Object> f1 = ClassRemotingTest.scheduleCallableLoad(channel, callable);",
          "174:             Object result = f1.get();",
          "",
          "[Removed Lines]",
          "171:             final Callable<Object, Exception> callable = (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "[Added Lines]",
          "177:             final Callable<Object, Exception> callable =",
          "178:                     (Callable<Object, Exception>) dcl.load(TestStaticGetResources.class);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "176:         });",
          "177:     }",
          "180:         assertEquals(String.class, channel.call(callable).getClass());",
          "181:         assertTrue(result.toString().contains(\"impossible\"));",
          "182:     }",
          "",
          "[Removed Lines]",
          "179:     static void assertTestStaticResourceReferenceResults(Channel channel, Callable<Object, Exception> callable, Object result) throws Exception {",
          "",
          "[Added Lines]",
          "186:     static void assertTestStaticResourceReferenceResults(",
          "187:             Channel channel, Callable<Object, Exception> callable, Object result) throws Exception {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "186:         return svc.submit(() -> channel.call(c));",
          "187:     }",
          "190:         assertEquals(String.class, channel.call(callable).getClass());",
          "191:         assertTrue(result.toString().startsWith(TESTLINKAGE_TRANSFORMED_CLASSNAME + \"$B\"));",
          "192:         Object loadResult = parent.load(TestLinkage.B.class);",
          "194:         loadResult = child1.load(TestLinkage.A.class);",
          "196:         loadResult = child2.load(TestLinkage.class);",
          "197:         assertEquals(TESTLINKAGE_TRANSFORMED_CLASSNAME, loadResult.getClass().getName());",
          "198:     }",
          "",
          "[Removed Lines]",
          "189:     static void assertTestLinkageResults(Channel channel, DummyClassLoader parent, DummyClassLoader child1, DummyClassLoader child2, Callable<Object, Exception> callable, Object result) throws Exception {",
          "193:         assertEquals(TESTLINKAGE_TRANSFORMED_CLASSNAME + \"$B\", loadResult.getClass().getName());",
          "195:         assertEquals(TESTLINKAGE_TRANSFORMED_CLASSNAME + \"$A\", loadResult.getClass().getName());",
          "",
          "[Added Lines]",
          "197:     static void assertTestLinkageResults(",
          "198:             Channel channel,",
          "199:             DummyClassLoader parent,",
          "200:             DummyClassLoader child1,",
          "201:             DummyClassLoader child2,",
          "202:             Callable<Object, Exception> callable,",
          "203:             Object result)",
          "204:             throws Exception {",
          "208:         assertEquals(",
          "209:                 TESTLINKAGE_TRANSFORMED_CLASSNAME + \"$B\", loadResult.getClass().getName());",
          "211:         assertEquals(",
          "212:                 TESTLINKAGE_TRANSFORMED_CLASSNAME + \"$A\", loadResult.getClass().getName());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "201:         assertTrue(result[0].toString().startsWith(\"hudson.remoting.RemoteClassLoader@\"));",
          "209:         assertTrue(result[2].toString().contains(TESTCALLABLE_TRANSFORMED_CLASSNAME.replace(\".\", \"/\") + \".class\"));",
          "210:     }",
          "",
          "[Removed Lines]",
          "204:         ClassReader cr = new ClassReader((byte[])result[1]);",
          "205:         cr.accept(new EmptyVisitor(),ClassReader.SKIP_DEBUG);",
          "208:         assertEquals(result[2],result[3]);",
          "",
          "[Added Lines]",
          "221:         ClassReader cr = new ClassReader((byte[]) result[1]);",
          "222:         cr.accept(new EmptyVisitor(), ClassReader.SKIP_DEBUG);",
          "225:         assertEquals(result[2], result[3]);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "217:     }",
          "219:     private static class RemotePropertyVerifier extends CallableBase<Object, IOException> {",
          "220:         public Object call() throws IOException {",
          "221:             Object o = getOpenChannelOrFail().getRemoteProperty(\"test\");",
          "222:             assertEquals(o.getClass().getName(), TESTCALLABLE_TRANSFORMED_CLASSNAME);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:         @Override",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/Copier.java||src/test/java/hudson/remoting/Copier.java": [
          "File: src/test/java/hudson/remoting/Copier.java -> src/test/java/hudson/remoting/Copier.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:         try {",
          "48:             byte[] buf = new byte[8192];",
          "49:             int len;",
          "52:             in.close();",
          "53:         } catch (IOException e) {",
          "",
          "[Removed Lines]",
          "50:             while((len=in.read(buf))>0)",
          "51:                 out.write(buf,0,len);",
          "",
          "[Added Lines]",
          "50:             while ((len = in.read(buf)) > 0) {",
          "51:                 out.write(buf, 0, len);",
          "52:             }",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java||src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java": [
          "File: src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java -> src/test/java/hudson/remoting/DeadRemoteOutputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:             System.gc();",
          "56:             Thread.sleep(1000);",
          "59:             final IOException e = assertThrows(IOException.class, () -> {",
          "61:                     os.write(0);",
          "62:                     System.gc();",
          "63:                     Thread.sleep(10);",
          "",
          "[Removed Lines]",
          "60:                 for (int i=0; i<100; i++) {",
          "",
          "[Added Lines]",
          "59:                 for (int i = 0; i < 100; i++) {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/DefaultClassFilterTest.java||src/test/java/hudson/remoting/DefaultClassFilterTest.java": [
          "File: src/test/java/hudson/remoting/DefaultClassFilterTest.java -> src/test/java/hudson/remoting/DefaultClassFilterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: public class DefaultClassFilterTest {",
          "57:     @Rule",
          "58:     public TemporaryFolder folder = new TemporaryFolder();",
          "",
          "[Removed Lines]",
          "48:     private static final List<String> defaultBadClasses = Arrays.asList(\"org.codehaus.groovy.runtime.Bob\",",
          "49:                                     \"org.apache.commons.collections.functors.Wibble\", \"org.apache.xalan.Bogus\",",
          "50:                                     \"com.sun.org.apache.xalan.bogus\", \"org.springframework.core.SomeClass\",",
          "51:                                     \"org.springframework.wibble.ExceptionHandler\");",
          "53:     private static final List<String> defaultOKClasses = Arrays.asList(\"java.lang.String\", \"java.lang.Object\",",
          "54:                                     \"java.util.ArrayList\", \"org.springframework.core.NestedRuntimeException\",",
          "55:                                     \"org.springframework.a.b.c.yada.SomeSuperException\");",
          "",
          "[Added Lines]",
          "48:     private static final List<String> defaultBadClasses = Arrays.asList(",
          "49:             \"org.codehaus.groovy.runtime.Bob\",",
          "50:             \"org.apache.commons.collections.functors.Wibble\",",
          "51:             \"org.apache.xalan.Bogus\",",
          "52:             \"com.sun.org.apache.xalan.bogus\",",
          "53:             \"org.springframework.core.SomeClass\",",
          "54:             \"org.springframework.wibble.ExceptionHandler\");",
          "56:     private static final List<String> defaultOKClasses = Arrays.asList(",
          "57:             \"java.lang.String\",",
          "58:             \"java.lang.Object\",",
          "59:             \"java.util.ArrayList\",",
          "60:             \"org.springframework.core.NestedRuntimeException\",",
          "61:             \"org.springframework.a.b.c.yada.SomeSuperException\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:     @Test",
          "69:     public void testDefaultsNoOverride() {",
          "74:     }",
          "",
          "[Removed Lines]",
          "70:         assertThat(\"Default blacklist is not blacklisting some classes\", defaultBadClasses,",
          "71:                                         everyItem(is(BlackListMatcher.blacklisted())));",
          "72:         assertThat(\"Default blacklist is not allowing some classes\", defaultOKClasses,",
          "73:                                         everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "",
          "[Added Lines]",
          "76:         assertThat(",
          "77:                 \"Default blacklist is not blacklisting some classes\",",
          "78:                 defaultBadClasses,",
          "79:                 everyItem(is(BlackListMatcher.blacklisted())));",
          "80:         assertThat(",
          "81:                 \"Default blacklist is not allowing some classes\",",
          "82:                 defaultOKClasses,",
          "83:                 everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:             }",
          "88:         }",
          "89:         setOverrideProperty(f.getAbsolutePath());",
          "91:         assertThat(\"Custom blacklist should be used\", badClasses, everyItem(is(BlackListMatcher.blacklisted())));",
          "93:     }",
          "99:     public void testDefaultsAreUsedIfOverridesAreGarbage() throws Exception {",
          "100:         List<String> badClasses = List.of(\"Z{100,0}\" /* min > max for repetition */);",
          "101:         File f = folder.newFile(\"overrides.txt\");",
          "",
          "[Removed Lines]",
          "90:         assertThat(\"Default blacklist should not be used\", defaultBadClasses, everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "92:         assertThat(\"Custom blacklist is not allowing some classes\", defaultOKClasses, everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "98:     @Test(expected=Error.class)",
          "",
          "[Added Lines]",
          "100:         assertThat(",
          "101:                 \"Default blacklist should not be used\",",
          "102:                 defaultBadClasses,",
          "103:                 everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "105:         assertThat(",
          "106:                 \"Custom blacklist is not allowing some classes\",",
          "107:                 defaultOKClasses,",
          "108:                 everyItem(is(not(BlackListMatcher.blacklisted()))));",
          "114:     @Test(expected = Error.class)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "117:     public void testDefaultsRemainWhenOverrideDoesExists() throws Exception {",
          "120:         ClassFilter.createDefaultInstance();",
          "121:     }",
          "",
          "[Removed Lines]",
          "116:     @Test(expected=Error.class)",
          "118:         setOverrideProperty(folder.getRoot().toString()",
          "119:                 + \"/DO_NOT_CREATE_THIS_FILE_OR_ELSE_BAD_THINGS_WILL_HAPPEN_TO_YOU\");",
          "",
          "[Added Lines]",
          "132:     @Test(expected = Error.class)",
          "134:         setOverrideProperty(",
          "135:                 folder.getRoot().toString() + \"/DO_NOT_CREATE_THIS_FILE_OR_ELSE_BAD_THINGS_WILL_HAPPEN_TO_YOU\");",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java||src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java": [
          "File: src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java -> src/test/java/hudson/remoting/DiagnosedStreamCorruptionExceptionTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: public class DiagnosedStreamCorruptionExceptionTest {",
          "19:     byte[] payload = {",
          "23:     };",
          "25:     @Test",
          "26:     public void exercise() throws Exception {",
          "33:         verify(ct);",
          "34:     }",
          "",
          "[Removed Lines]",
          "27:         ClassicCommandTransport ct = (ClassicCommandTransport)",
          "28:                 new ChannelBuilder(\"dummy\",null)",
          "29:                     .withMode(Channel.Mode.BINARY)",
          "30:                     .withBaseLoader(getClass().getClassLoader())",
          "31:                     .negotiate(new ByteArrayInputStream(payload), OutputStream.nullOutputStream());",
          "",
          "[Added Lines]",
          "20:         0,",
          "21:         0,",
          "22:         0,",
          "24:         (byte) 0xAC,",
          "25:         (byte) 0xED,",
          "26:         0x00,",
          "28:         1,",
          "29:         2,",
          "30:         3,",
          "31:         4,",
          "37:         ClassicCommandTransport ct = (ClassicCommandTransport) new ChannelBuilder(\"dummy\", null)",
          "38:                 .withMode(Channel.Mode.BINARY)",
          "39:                 .withBaseLoader(getClass().getClassLoader())",
          "40:                 .negotiate(new ByteArrayInputStream(payload), OutputStream.nullOutputStream());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:             }",
          "46:             String msg = s.toString();",
          "49:             assertSame(StreamCorruptedException.class, e.getCause().getClass());",
          "50:         }",
          "51:     }",
          "",
          "[Removed Lines]",
          "47:             assertTrue(msg,msg.contains(\"Read ahead: 0x02 0x03 0x04 0x05\"));",
          "48:             assertTrue(msg,msg.contains(\"invalid type code: 01\"));",
          "",
          "[Added Lines]",
          "56:             assertTrue(msg, msg.contains(\"Read ahead: 0x02 0x03 0x04 0x05\"));",
          "57:             assertTrue(msg, msg.contains(\"invalid type code: 01\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "57:     public void blockingStreamShouldNotPreventDiagnosis() throws Exception {",
          "58:         try (FastPipedInputStream in = new FastPipedInputStream();",
          "60:             out.write(payload);",
          "68:             verify(ct);",
          "69:         }",
          "",
          "[Removed Lines]",
          "56:     @Test(timeout=3000)",
          "59:             FastPipedOutputStream out = new FastPipedOutputStream(in)) {",
          "62:             ClassicCommandTransport ct = (ClassicCommandTransport)",
          "63:                     new ChannelBuilder(\"dummy\",null)",
          "64:                         .withMode(Channel.Mode.BINARY)",
          "65:                         .withBaseLoader(getClass().getClassLoader())",
          "66:                         .negotiate(in, OutputStream.nullOutputStream());",
          "",
          "[Added Lines]",
          "65:     @Test(timeout = 3000)",
          "68:                 FastPipedOutputStream out = new FastPipedOutputStream(in)) {",
          "71:             ClassicCommandTransport ct = (ClassicCommandTransport) new ChannelBuilder(\"dummy\", null)",
          "72:                     .withMode(Channel.Mode.BINARY)",
          "73:                     .withBaseLoader(getClass().getClassLoader())",
          "74:                     .negotiate(in, OutputStream.nullOutputStream());",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/DummyClassLoader.java||src/test/java/hudson/remoting/DummyClassLoader.java": [
          "File: src/test/java/hudson/remoting/DummyClassLoader.java -> src/test/java/hudson/remoting/DummyClassLoader.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:     public DummyClassLoader(ClassLoader parent, Class<?>... classes) {",
          "89:         super(parent);",
          "91:         for (Class<?> c : classes) {",
          "92:             entries.add(new Entry(c));",
          "93:         }",
          "",
          "[Removed Lines]",
          "90:         assert classes.length!=0;",
          "",
          "[Added Lines]",
          "89:         assert classes.length != 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107:     public Object load(Class<?> c) {",
          "108:         for (Entry e : entries) {",
          "110:                 try {",
          "111:                     return loadClass(e.logicalName).getConstructor().newInstance();",
          "114:                     throw new Error(x);",
          "115:                 }",
          "116:             }",
          "",
          "[Removed Lines]",
          "109:             if (e.c==c) {",
          "112:                 } catch (InstantiationException | IllegalAccessException | ClassNotFoundException",
          "113:                         | NoSuchMethodException | InvocationTargetException x) {",
          "",
          "[Added Lines]",
          "108:             if (e.c == c) {",
          "111:                 } catch (InstantiationException",
          "112:                         | IllegalAccessException",
          "113:                         | ClassNotFoundException",
          "114:                         | NoSuchMethodException",
          "115:                         | InvocationTargetException x) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "118:         throw new IllegalStateException();",
          "119:     }",
          "122:     @Override",
          "123:     protected Class<?> findClass(String name) throws ClassNotFoundException {",
          "124:         for (Entry e : entries) {",
          "127:                 try {",
          "128:                     byte[] bytes = e.loadTransformedClassImage();",
          "130:                 } catch (IOException x) {",
          "132:                 }",
          "133:             }",
          "134:         }",
          "",
          "[Removed Lines]",
          "125:             if(name.equals(e.logicalName)) {",
          "129:                     return defineClass(name,bytes,0,bytes.length);",
          "131:                     throw new ClassNotFoundException(\"Bytecode manipulation failed\",x);",
          "",
          "[Added Lines]",
          "126:             if (name.equals(e.logicalName)) {",
          "130:                     return defineClass(name, bytes, 0, bytes.length);",
          "132:                     throw new ClassNotFoundException(\"Bytecode manipulation failed\", x);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:         return super.findResource(name);",
          "157:     }",
          "160:         return super.toString() + \"[\" + entries + \"]\";",
          "161:     }",
          "163: }",
          "",
          "[Removed Lines]",
          "159:     @Override public String toString() {",
          "",
          "[Added Lines]",
          "159:     @Override",
          "160:     public String toString() {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/DummyClassLoaderTest.java||src/test/java/hudson/remoting/DummyClassLoaderTest.java": [
          "File: src/test/java/hudson/remoting/DummyClassLoaderTest.java -> src/test/java/hudson/remoting/DummyClassLoaderTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:         Callable<Object, Throwable> c = (Callable<Object, Throwable>) DummyClassLoader.apply(TestCallable.class);",
          "37:         System.out.println(c.call());",
          "40:     }",
          "41: }",
          "",
          "[Removed Lines]",
          "39:         assertTrue(((Object[])c.call())[0].toString().startsWith(DummyClassLoader.class.getName()));",
          "",
          "[Added Lines]",
          "39:         assertTrue(((Object[]) c.call())[0].toString().startsWith(DummyClassLoader.class.getName()));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/EngineTest.java||src/test/java/hudson/remoting/EngineTest.java": [
          "File: src/test/java/hudson/remoting/EngineTest.java -> src/test/java/hudson/remoting/EngineTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: public class EngineTest {",
          "50:     private static final String SECRET_KEY = \"Hello, world!\";",
          "51:     private static final String AGENT_NAME = \"testAgent\";",
          "52:     private List<URL> jenkinsUrls;",
          "54:     @Rule",
          "55:     public TemporaryFolder tmpDir = new TemporaryFolder();",
          "57:     @Rule",
          "58:     public WorkDirManagerRule mgr = new WorkDirManagerRule();",
          "60:     @Before",
          "61:     public void init() throws Exception {",
          "62:         jenkinsUrls = List.of(new URL(\"http://my.jenkins.not.existent\"));",
          "63:     }",
          "65:     @Test",
          "66:     @Issue(\"JENKINS-44290\")",
          "67:     public void shouldInitializeCorrectlyWithDefaults() throws Exception {",
          "68:         EngineListener l = new TestEngineListener();",
          "69:         Engine engine = new Engine(l, jenkinsUrls, SECRET_KEY, AGENT_NAME);",
          "70:         engine.startEngine(true);",
          "74:                 JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION.exists());",
          "75:     }",
          "77:     @Test",
          "78:     public void shouldInitializeCorrectlyWithCustomCache() throws Exception {",
          "79:         File jarCache = new File(tmpDir.getRoot(), \"jarCache\");",
          "81:         EngineListener l = new TestEngineListener();",
          "82:         Engine engine = new Engine(l, jenkinsUrls, SECRET_KEY, AGENT_NAME);",
          "83:         engine.setJarCache(new FileSystemJarCache(jarCache, true));",
          "84:         engine.startEngine(true);",
          "89:     }",
          "91:     @Test",
          "92:     public void shouldInitializeCorrectlyWithWorkDir() throws Exception {",
          "93:         File workDir = new File(tmpDir.getRoot(), \"workDir\");",
          "",
          "[Removed Lines]",
          "73:         assertTrue(\"Default JarCache should be touched: \" + JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION.getAbsolutePath(),",
          "87:         assertTrue(\"The specified JarCache should be touched: \" + jarCache.getAbsolutePath(),",
          "88:                 jarCache.exists());",
          "",
          "[Added Lines]",
          "73:         assertTrue(",
          "74:                 \"Default JarCache should be touched: \" + JarCache.DEFAULT_NOWS_JAR_CACHE_LOCATION.getAbsolutePath(),",
          "88:         assertTrue(\"The specified JarCache should be touched: \" + jarCache.getAbsolutePath(), jarCache.exists());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:         Engine engine = new Engine(l, jenkinsUrls, SECRET_KEY, AGENT_NAME);",
          "96:         engine.setWorkDir(workDir.toPath());",
          "97:         engine.startEngine(true);",
          "99:         WorkDirManager mgr = WorkDirManager.getInstance();",
          "100:         File workDirLoc = mgr.getLocation(WorkDirManager.DirType.WORK_DIR);",
          "103:         assertTrue(\"The work directory should exist\", workDir.exists());",
          "104:     }",
          "106:     @Test",
          "107:     public void shouldUseCustomCacheDirIfRequired() throws Exception {",
          "108:         File workDir = new File(tmpDir.getRoot(), \"workDir\");",
          "",
          "[Removed Lines]",
          "101:         assertThat(\"The initialized work directory should equal to the one passed in parameters\",",
          "102:                 workDirLoc, equalTo(workDir));",
          "",
          "[Added Lines]",
          "101:         assertThat(",
          "102:                 \"The initialized work directory should equal to the one passed in parameters\",",
          "103:                 workDirLoc,",
          "104:                 equalTo(workDir));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/FileSystemJarCacheTest.java||src/test/java/hudson/remoting/FileSystemJarCacheTest.java": [
          "File: src/test/java/hudson/remoting/FileSystemJarCacheTest.java -> src/test/java/hudson/remoting/FileSystemJarCacheTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     private static final String CONTENTS = \"These are the contents\";",
          "48:     private FileSystemJarCache fileSystemJarCache;",
          "49:     private Checksum expectedChecksum;",
          "",
          "[Removed Lines]",
          "44:     @Rule public TemporaryFolder tmp = new TemporaryFolder();",
          "46:     @Mock private Channel mockChannel;",
          "47:     @Mock private JarLoader mockJarLoader;",
          "",
          "[Added Lines]",
          "44:     @Rule",
          "45:     public TemporaryFolder tmp = new TemporaryFolder();",
          "47:     @Mock",
          "48:     private Channel mockChannel;",
          "50:     @Mock",
          "51:     private JarLoader mockJarLoader;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:         assertTrue(expectedFile.createNewFile());",
          "72:         writeToFile(expectedFile, CONTENTS);",
          "76:         assertEquals(expectedFile.toURI().toURL(), url);",
          "80:         writeToFile(expectedFile, \"Something else\");",
          "83:         assertEquals(expectedFile.toURI().toURL(), url);",
          "84:     }",
          "",
          "[Removed Lines]",
          "74:         URL url = fileSystemJarCache.retrieve(",
          "75:                 mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "81:         url = fileSystemJarCache.retrieve(",
          "82:                 mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "",
          "[Added Lines]",
          "79:         URL url = fileSystemJarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "85:         url = fileSystemJarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:     public void testSuccessfulRetrieve() throws Exception {",
          "88:         mockCorrectLoad();",
          "92:         assertEquals(expectedChecksum, Checksum.forURL(url));",
          "93:     }",
          "",
          "[Removed Lines]",
          "90:         URL url = fileSystemJarCache.retrieve(",
          "91:                 mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "",
          "[Added Lines]",
          "93:         URL url = fileSystemJarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "96:     public void testRetrieveChecksumDifferent() throws Exception {",
          "97:         when(mockChannel.getProperty(JarLoader.THEIRS)).thenReturn(mockJarLoader);",
          "98:         doAnswer((Answer<Void>) invocationOnMock -> {",
          "108:                 () -> fileSystemJarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2));",
          "109:         assertThat(ex.getCause(), hasMessage(containsString(\"Incorrect checksum of retrieved jar\")));",
          "110:     }",
          "",
          "[Removed Lines]",
          "99:             RemoteOutputStream o = (RemoteOutputStream) invocationOnMock.getArguments()[2];",
          "100:             o.write(\"Some other contents\".getBytes(StandardCharsets.UTF_8));",
          "101:             return null;",
          "102:         }).when(mockJarLoader).writeJarTo(",
          "103:                 eq(expectedChecksum.sum1),",
          "104:                 eq(expectedChecksum.sum2),",
          "105:                 any(RemoteOutputStream.class));",
          "107:         final IOException ex = assertThrows(IOException.class,",
          "",
          "[Added Lines]",
          "101:                     RemoteOutputStream o = (RemoteOutputStream) invocationOnMock.getArguments()[2];",
          "102:                     o.write(\"Some other contents\".getBytes(StandardCharsets.UTF_8));",
          "103:                     return null;",
          "104:                 })",
          "105:                 .when(mockJarLoader)",
          "106:                 .writeJarTo(eq(expectedChecksum.sum1), eq(expectedChecksum.sum2), any(RemoteOutputStream.class));",
          "108:         final IOException ex = assertThrows(",
          "109:                 IOException.class,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "142:         when(spy.renameTo(expectedFile)).thenReturn(false);",
          "143:         assertFalse(expectedFile.exists());",
          "147:         assertThat(ex.getCause(), hasMessage(containsString(\"Unable to create\")));",
          "148:     }",
          "",
          "[Removed Lines]",
          "145:         final IOException ex = assertThrows(IOException.class,",
          "146:                 () -> jarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2));",
          "",
          "[Added Lines]",
          "147:         final IOException ex = assertThrows(",
          "148:                 IOException.class, () -> jarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "157:         mockCorrectLoad();",
          "158:         doAnswer((Answer<Boolean>) invocationOnMock -> {",
          "167:         assertThat(ex.getCause(), hasMessage(containsString(\"Incorrect checksum of previous jar\")));",
          "168:     }",
          "170:     private void mockCorrectLoad() throws IOException, InterruptedException {",
          "171:         when(mockChannel.getProperty(JarLoader.THEIRS)).thenReturn(mockJarLoader);",
          "172:         doAnswer((Answer<Void>) invocationOnMock -> {",
          "180:     }",
          "181: }",
          "",
          "[Removed Lines]",
          "159:             Files.createParentDirs(expectedFile);",
          "160:             expectedFile.createNewFile();",
          "161:             Files.asCharSink(expectedFile, StandardCharsets.UTF_8, FileWriteMode.APPEND).write(\"Some other contents\");",
          "162:             return false;",
          "163:         }).when(fileSpy).renameTo(expectedFile);",
          "165:         final IOException ex = assertThrows(IOException.class,",
          "166:                 () -> jarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2));",
          "173:             RemoteOutputStream o = (RemoteOutputStream) invocationOnMock.getArguments()[2];",
          "174:             o.write(CONTENTS.getBytes(StandardCharsets.UTF_8));",
          "175:             return null;",
          "176:         }).when(mockJarLoader).writeJarTo(",
          "177:                 eq(expectedChecksum.sum1),",
          "178:                 eq(expectedChecksum.sum2),",
          "179:                 any(RemoteOutputStream.class));",
          "",
          "[Added Lines]",
          "161:                     Files.createParentDirs(expectedFile);",
          "162:                     expectedFile.createNewFile();",
          "163:                     Files.asCharSink(expectedFile, StandardCharsets.UTF_8, FileWriteMode.APPEND)",
          "164:                             .write(\"Some other contents\");",
          "165:                     return false;",
          "166:                 })",
          "167:                 .when(fileSpy)",
          "168:                 .renameTo(expectedFile);",
          "170:         final IOException ex = assertThrows(",
          "171:                 IOException.class, () -> jarCache.retrieve(mockChannel, expectedChecksum.sum1, expectedChecksum.sum2));",
          "178:                     RemoteOutputStream o = (RemoteOutputStream) invocationOnMock.getArguments()[2];",
          "179:                     o.write(CONTENTS.getBytes(StandardCharsets.UTF_8));",
          "180:                     return null;",
          "181:                 })",
          "182:                 .when(mockJarLoader)",
          "183:                 .writeJarTo(eq(expectedChecksum.sum1), eq(expectedChecksum.sum2), any(RemoteOutputStream.class));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java||src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java": [
          "File: src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java -> src/test/java/hudson/remoting/FlightRecorderInputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:         oos.writeObject(\"abc\");",
          "24:         oos.writeObject(\"def\");",
          "25:         oos.flush();",
          "27:         oos.writeObject(\"ghi\");",
          "29:         FlightRecorderInputStream fis = new FlightRecorderInputStream(new ByteArrayInputStream(baos.toByteArray()));",
          "",
          "[Removed Lines]",
          "26:         baos.write(0xFF);  // corruption",
          "",
          "[Added Lines]",
          "26:         baos.write(0xFF); // corruption",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32:         fis.clear();",
          "33:         assertEquals(\"def\", ois.readObject());",
          "36:         DiagnosedStreamCorruptionException t = fis.analyzeCrash(e, \"test\");",
          "37:         t.printStackTrace();",
          "38:         assertNull(t.getDiagnoseFailure());",
          "42:     }",
          "45:         int sz = (int) (FlightRecorderInputStream.BUFFER_SIZE * /* not a round multiple */ 5.3);",
          "46:         byte[] stuff = new byte[sz];",
          "47:         for (int i = 0; i < sz; i++) {",
          "49:         }",
          "50:         FlightRecorderInputStream fris = new FlightRecorderInputStream(new ByteArrayInputStream(stuff));",
          "51:         byte[] stuff2 = new byte[sz];",
          "",
          "[Removed Lines]",
          "35:         final StreamCorruptedException e = assertThrows(\"Expecting a corruption\", StreamCorruptedException.class, ois::readObject);",
          "40:         assertArrayEquals(new byte[]{TC_STRING, 0, 3, 'd', 'e', 'f', -1}, t.getReadBack());",
          "41:         assertArrayEquals(new byte[]{TC_STRING, 0, 3, 'g', 'h', 'i'}, t.getReadAhead());",
          "44:     @Test public void bounding() throws Exception {",
          "48:             stuff[i] = (byte) (i % /* arbitrary cycle, not a power of 2 */213);",
          "",
          "[Added Lines]",
          "35:         final StreamCorruptedException e =",
          "36:                 assertThrows(\"Expecting a corruption\", StreamCorruptedException.class, ois::readObject);",
          "41:         assertArrayEquals(new byte[] {TC_STRING, 0, 3, 'd', 'e', 'f', -1}, t.getReadBack());",
          "42:         assertArrayEquals(new byte[] {TC_STRING, 0, 3, 'g', 'h', 'i'}, t.getReadAhead());",
          "45:     @Test",
          "46:     public void bounding() throws Exception {",
          "50:             stuff[i] = (byte) (i % /* arbitrary cycle, not a power of 2 */ 213);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ForkEBCDICRunner.java||src/test/java/hudson/remoting/ForkEBCDICRunner.java": [
          "File: src/test/java/hudson/remoting/ForkEBCDICRunner.java -> src/test/java/hudson/remoting/ForkEBCDICRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:     @Override",
          "10:     protected List<String> buildCommandLine() {",
          "11:         List<String> r = super.buildCommandLine();",
          "13:         return r;",
          "14:     }",
          "",
          "[Removed Lines]",
          "12:         r.add(0,\"-Dfile.encoding=CP037\");",
          "",
          "[Added Lines]",
          "12:         r.add(0, \"-Dfile.encoding=CP037\");",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ForkRunner.java||src/test/java/hudson/remoting/ForkRunner.java": [
          "File: src/test/java/hudson/remoting/ForkRunner.java -> src/test/java/hudson/remoting/ForkRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     @Override",
          "32:     public Channel start() throws Exception {",
          "33:         List<String> cmds = buildCommandLine();",
          "35:         proc = Runtime.getRuntime().exec(cmds.toArray(new String[0]));",
          "38:         copier.start();",
          "40:         executor = Executors.newCachedThreadPool();",
          "",
          "[Removed Lines]",
          "34:         cmds.add(0,\"java\");",
          "37:         copier = new Copier(\"copier\",proc.getErrorStream(),System.out);",
          "",
          "[Added Lines]",
          "33:         cmds.add(0, \"java\");",
          "36:         copier = new Copier(\"copier\", proc.getErrorStream(), System.out);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:     @Override",
          "46:     public void stop(Channel channel) throws Exception {",
          "47:         channel.close();",
          "50:         executor.shutdown();",
          "",
          "[Removed Lines]",
          "48:         channel.join(10*1000);",
          "",
          "[Added Lines]",
          "47:         channel.join(10 * 1000);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/HexDumpTest.java||src/test/java/hudson/remoting/HexDumpTest.java": [
          "File: src/test/java/hudson/remoting/HexDumpTest.java -> src/test/java/hudson/remoting/HexDumpTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: public class HexDumpTest {",
          "11:     @Test",
          "13:         assertEquals(\"0x00 0x01 0xff 'A'\", HexDump.toHex(new byte[] {0, 1, -1, 65}));",
          "14:         assertEquals(\"0x00 0x01 0xff 'ABC'\", HexDump.toHex(new byte[] {0, 1, -1, 65, 66, 67}));",
          "15:         assertEquals(\"'AAAA' 0x00\", HexDump.toHex(new byte[] {65, 65, 65, 65, 0}));",
          "",
          "[Removed Lines]",
          "12:     public  void test1() {",
          "",
          "[Added Lines]",
          "12:     public void test1() {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18:     @Test",
          "19:     public void testMultiline() {",
          "21:     }",
          "22: }",
          "",
          "[Removed Lines]",
          "20:         assertEquals(\"'A A' 0x0a\\n' AA'\",  HexDump.toHex(new byte[] {65, 32, 65, 10, 32, 65, 65}));",
          "",
          "[Added Lines]",
          "20:         assertEquals(\"'A A' 0x0a\\n' AA'\", HexDump.toHex(new byte[] {65, 32, 65, 10, 32, 65, 65}));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/InProcessCompatibilityRunner.java||src/test/java/hudson/remoting/InProcessCompatibilityRunner.java": [
          "File: src/test/java/hudson/remoting/InProcessCompatibilityRunner.java -> src/test/java/hudson/remoting/InProcessCompatibilityRunner.java"
        ],
        "src/test/java/hudson/remoting/InProcessRunner.java||src/test/java/hudson/remoting/InProcessRunner.java": [
          "File: src/test/java/hudson/remoting/InProcessRunner.java -> src/test/java/hudson/remoting/InProcessRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:             @Override",
          "35:             public void run() {",
          "36:                 try {",
          "38:                     southHandoff.put(south);",
          "39:                     south.join();",
          "40:                     System.out.println(\"south completed\");",
          "",
          "[Removed Lines]",
          "37:                     Channel south = configureSouth().build(in2,out1);",
          "",
          "[Added Lines]",
          "38:                     Channel south = configureSouth().build(in2, out1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:         executor.shutdown();",
          "77:     }",
          "79:     @Override",
          "",
          "[Removed Lines]",
          "75:         if(failure!=null)",
          "76:             throw failure;  // report a failure in the south side",
          "",
          "[Added Lines]",
          "76:         if (failure != null) {",
          "77:             throw failure; // report a failure in the south side",
          "78:         }",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/LauncherTest.java||src/test/java/hudson/remoting/LauncherTest.java": [
          "File: src/test/java/hudson/remoting/LauncherTest.java -> src/test/java/hudson/remoting/LauncherTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     }",
          "57:     private void shouldFailWithDoctype(FileInputStream jnlpFile) {",
          "60:         assertThat(spe.getMessage(), containsString(\"\\\"http://apache.org/xml/features/disallow-doctype-decl\\\"\"));",
          "61:     }",
          "63: }",
          "",
          "[Removed Lines]",
          "58:         final SAXParseException spe = assertThrows(\"Dom loading should have failed.\", SAXParseException.class,",
          "59:                 () -> Launcher.loadDom(jnlpFile));",
          "",
          "[Added Lines]",
          "58:         final SAXParseException spe = assertThrows(",
          "59:                 \"Dom loading should have failed.\", SAXParseException.class, () -> Launcher.loadDom(jnlpFile));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/NioPipeRunner.java||src/test/java/hudson/remoting/NioPipeRunner.java": [
          "File: src/test/java/hudson/remoting/NioPipeRunner.java -> src/test/java/hudson/remoting/NioPipeRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:         final Pipe s2n = Pipe.open();",
          "27:         nio = new NioChannelHub(executor);",
          "30:         executor.submit(() -> {",
          "31:             try {",
          "32:                 nio.run();",
          "33:             } catch (Throwable e) {",
          "35:                 failure = e;",
          "36:             }",
          "37:         });",
          "38:         executor.submit(() -> {",
          "39:             try {",
          "41:                         .build(n2s.source(), s2n.sink());",
          "42:                 southHandoff.put(south);",
          "43:                 south.join();",
          "",
          "[Removed Lines]",
          "28:         nio.setFrameSize(132);  // force unaligned boundaries to shake things up a bit",
          "34:                 LOGGER.log(Level.WARNING, \"Faield to keep the NIO selector thread going\",e);",
          "40:                 Channel south = nio.newChannelBuilder(\"south\",executor).withMode(Channel.Mode.NEGOTIATE)",
          "",
          "[Added Lines]",
          "28:         nio.setFrameSize(132); // force unaligned boundaries to shake things up a bit",
          "34:                 LOGGER.log(Level.WARNING, \"Faield to keep the NIO selector thread going\", e);",
          "40:                 Channel south = nio.newChannelBuilder(\"south\", executor)",
          "41:                         .withMode(Channel.Mode.NEGOTIATE)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:         });",
          "53:                 .build(s2n.source(), n2s.sink());",
          "54:         south = southHandoff.poll(10, TimeUnit.SECONDS);",
          "55:         return north;",
          "",
          "[Removed Lines]",
          "52:         Channel north = nio.newChannelBuilder(\"north\", executor).withMode(Channel.Mode.BINARY)",
          "",
          "[Added Lines]",
          "53:         Channel north = nio.newChannelBuilder(\"north\", executor)",
          "54:                 .withMode(Channel.Mode.BINARY)",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/NioSocketRunner.java||src/test/java/hudson/remoting/NioSocketRunner.java": [
          "File: src/test/java/hudson/remoting/NioSocketRunner.java -> src/test/java/hudson/remoting/NioSocketRunner.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:                         }",
          "48:                     });",
          "49:                 } catch (IOException e) {",
          "51:                     failure = e;",
          "52:                 }",
          "53:             }",
          "54:         };",
          "57:         ss.register(nio.getSelector(), SelectionKey.OP_ACCEPT);",
          "58:         LOGGER.info(\"Waiting for connection\");",
          "",
          "[Removed Lines]",
          "50:                     LOGGER.log(Level.WARNING, \"Failed to accept a socket\",e);",
          "55:         nio.setFrameSize(115);  // force unaligned boundaries to shake things up a bit",
          "",
          "[Added Lines]",
          "50:                     LOGGER.log(Level.WARNING, \"Failed to accept a socket\", e);",
          "55:         nio.setFrameSize(115); // force unaligned boundaries to shake things up a bit",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:             try {",
          "61:                 nio.run();",
          "62:             } catch (Throwable e) {",
          "64:                 failure = e;",
          "65:             }",
          "66:         });",
          "70:         Channel north = configureNorth().build(client);",
          "71:         south = southHandoff.poll(10, TimeUnit.SECONDS);",
          "72:         return north;",
          "",
          "[Removed Lines]",
          "63:                 LOGGER.log(Level.WARNING, \"Failed to keep the NIO selector thread going\",e);",
          "69:         SocketChannel client = SocketChannel.open(new InetSocketAddress(\"localhost\", ss.socket().getLocalPort()));",
          "",
          "[Added Lines]",
          "63:                 LOGGER.log(Level.WARNING, \"Failed to keep the NIO selector thread going\", e);",
          "69:         SocketChannel client = SocketChannel.open(",
          "70:                 new InetSocketAddress(\"localhost\", ss.socket().getLocalPort()));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/NoProxyEvaluatorTest.java||src/test/java/hudson/remoting/NoProxyEvaluatorTest.java": [
          "File: src/test/java/hudson/remoting/NoProxyEvaluatorTest.java -> src/test/java/hudson/remoting/NoProxyEvaluatorTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:     @Test",
          "82:     public void testSubFWDNWithDotMinimalSuffixMixedCase() {",
          "85:         assertFalse(evaluator.shouldProxyHost(\"bn-myproj.svc\"));",
          "86:     }",
          "",
          "[Removed Lines]",
          "83:         NoProxyEvaluator evaluator = new NoProxyEvaluator(\".svc,.default,.local,localhost,.boehringer.com,10.250.0.0/16,10.251.0.0/16,10.183.195.106,10.183.195.107,10.183.195.108,10.183.195.109,10.183.195.11,10.183.195.111,10.183.195.112,10.183.195.113,10.183.195.13,10.250.127.\");",
          "",
          "[Added Lines]",
          "83:         NoProxyEvaluator evaluator = new NoProxyEvaluator(",
          "84:                 \".svc,.default,.local,localhost,.boehringer.com,10.250.0.0/16,10.251.0.0/16,10.183.195.106,10.183.195.107,10.183.195.108,10.183.195.109,10.183.195.11,10.183.195.111,10.183.195.112,10.183.195.113,10.183.195.13,10.250.127.\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:         assertFalse(evaluator.shouldProxyHost(\"2001:0db8:0a0b:12f0:0000:0000:0000:0001\"));",
          "248:         assertFalse(evaluator.shouldProxyHost(\"2001:0db8:0a0b:12f0::0001\"));",
          "249:     }",
          "",
          "[Removed Lines]",
          "251: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/NonSerializableExceptionTest.java||src/test/java/hudson/remoting/NonSerializableExceptionTest.java": [
          "File: src/test/java/hudson/remoting/NonSerializableExceptionTest.java -> src/test/java/hudson/remoting/NonSerializableExceptionTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "37: public class NonSerializableExceptionTest  {",
          "",
          "[Added Lines]",
          "37: public class NonSerializableExceptionTest {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:         private NoneSerializableException(String msg, Throwable cause) {",
          "63:             super(msg, cause);",
          "64:         }",
          "65:         private static final long serialVersionUID = 1L;",
          "66:     }",
          "68:     private static final class Failure extends CallableBase<Object, Throwable> {",
          "69:         @Override",
          "70:         public Object call() throws Throwable {",
          "72:         }",
          "73:         private static final long serialVersionUID = 1L;",
          "74:     }",
          "75: }",
          "",
          "[Removed Lines]",
          "71:             throw new NoneSerializableException(\"message1\",new SocketException(\"message2\"));",
          "",
          "[Added Lines]",
          "72:             throw new NoneSerializableException(\"message1\", new SocketException(\"message2\"));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/PipeTest.java||src/test/java/hudson/remoting/PipeTest.java": [
          "File: src/test/java/hudson/remoting/PipeTest.java -> src/test/java/hudson/remoting/PipeTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:             int r = f.get();",
          "67:             System.out.println(\"result=\" + r);",
          "69:         });",
          "70:     }",
          "",
          "[Removed Lines]",
          "68:             assertEquals(5,r);",
          "",
          "[Added Lines]",
          "68:             assertEquals(5, r);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:             int r = f.get();",
          "142:             System.out.println(\"result=\" + r);",
          "144:         });",
          "145:     }",
          "",
          "[Removed Lines]",
          "143:             assertEquals(5,r);",
          "",
          "[Added Lines]",
          "145:             assertEquals(5, r);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:     public interface ISaturationTest {",
          "164:         void ensureConnected();",
          "165:         int readFirst() throws IOException;",
          "166:         void readRest() throws IOException;",
          "167:     }",
          "169:     @ParameterizedTest",
          "170:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "171:     public void testSaturation(ChannelRunner channelRunner) throws Exception {",
          "173:         channelRunner.withChannel(channel -> {",
          "174:             final Pipe p = Pipe.createLocalToRemote();",
          "176:             Thread writer = new Thread() {",
          "179:                 @Override",
          "180:                 public void run() {",
          "",
          "[Removed Lines]",
          "172:         assumeFalse(channelRunner instanceof InProcessCompatibilityRunner, \"can't do this test without the throttling support.\");",
          "177:                 final Thread mainThread = Thread.currentThread(); // this makes it easy to see the relationship between the thread pair in the debugger",
          "",
          "[Added Lines]",
          "176:         assumeFalse(",
          "177:                 channelRunner instanceof InProcessCompatibilityRunner,",
          "178:                 \"can't do this test without the throttling support.\");",
          "183:                 final Thread mainThread =",
          "184:                         Thread.currentThread(); // this makes it easy to see the relationship between the thread pair",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "212:         });",
          "213:     }",
          "216:         private final Pipe pipe;",
          "218:         public CreateSaturationTestProxy(Pipe pipe) {",
          "",
          "[Removed Lines]",
          "215:     private static class CreateSaturationTestProxy extends CallableBase<ISaturationTest,IOException> {",
          "",
          "[Added Lines]",
          "224:     private static class CreateSaturationTestProxy extends CallableBase<ISaturationTest, IOException> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "236:                 @Override",
          "237:                 public void readRest() throws IOException {",
          "239:                 }",
          "240:             });",
          "241:         }",
          "242:         private static final long serialVersionUID = 1L;",
          "243:     }",
          "",
          "[Removed Lines]",
          "238:                     new DataInputStream(in).readFully(new byte[Channel.PIPE_WINDOW_SIZE*2]);",
          "",
          "[Added Lines]",
          "248:                     new DataInputStream(in).readFully(new byte[Channel.PIPE_WINDOW_SIZE * 2]);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "253:         public Integer call() throws IOException {",
          "254:             try {",
          "255:                 read(pipe);",
          "258:                 throw new IOException(\"Assertion failed\", ex);",
          "259:             }",
          "260:             return 5;",
          "261:         }",
          "262:         private static final long serialVersionUID = 1L;",
          "263:     }",
          "",
          "[Removed Lines]",
          "256:             } catch(AssertionError ex) {",
          "",
          "[Added Lines]",
          "267:             } catch (AssertionError ex) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "275:     private static void read(Pipe p) throws IOException, AssertionError {",
          "276:         try (InputStream in = p.getIn()) {",
          "279:             }",
          "281:         }",
          "282:     }",
          "285:     @ParameterizedTest",
          "286:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "287:     @Disabled",
          "",
          "[Removed Lines]",
          "277:             for( int cnt=0; cnt<256*256; cnt++ ) {",
          "278:                 assertEquals(cnt/256,in.read());",
          "280:             assertEquals(-1,in.read());",
          "",
          "[Added Lines]",
          "289:             for (int cnt = 0; cnt < 256 * 256; cnt++) {",
          "290:                 assertEquals(cnt / 256, in.read());",
          "292:             assertEquals(-1, in.read());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "315:         });",
          "316:     }",
          "",
          "[Removed Lines]",
          "314:             assertEquals(1,(int)f.get());",
          "",
          "[Added Lines]",
          "325:             assertEquals(1, (int) f.get());",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/PipeWriterTest.java||src/test/java/hudson/remoting/PipeWriterTest.java": [
          "File: src/test/java/hudson/remoting/PipeWriterTest.java -> src/test/java/hudson/remoting/PipeWriterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     transient SlowOutputStream slow = new SlowOutputStream();",
          "22:     RemoteOutputStream ros = new RemoteOutputStream(slow);",
          "27:     PipeWriterTestChecker checker;",
          "31:     }",
          "37:         @Override",
          "38:         public Object call() throws Exception {",
          "39:             long start = System.currentTimeMillis();",
          "40:             System.out.println(\"touch\");",
          "41:             touch();",
          "44:             class CheckerThread extends Thread {",
          "45:                 Throwable death;",
          "46:                 @Override",
          "47:                 public void run() {",
          "48:                     try {",
          "",
          "[Removed Lines]",
          "28:     <T extends Exception> void withChannel(ChannelRunner channelRunner, ChannelRunner.ConsumerThrowable<Channel, T> f) throws Exception {",
          "30:         channelRunner.withChannel(((ChannelRunner.ConsumerThrowable<Channel, T>) channel -> checker = channel.export(PipeWriterTestChecker.class, PipeWriterTest.this, false, true, true)).andThen(f));",
          "36:     abstract class ResponseIoCoordCallable extends CallableBase<Object,Exception> {",
          "42:             assertTrue(System.currentTimeMillis()-start<1000); // write() itself shouldn't block",
          "",
          "[Added Lines]",
          "30:     <T extends Exception> void withChannel(ChannelRunner channelRunner, ChannelRunner.ConsumerThrowable<Channel, T> f)",
          "31:             throws Exception {",
          "33:         channelRunner.withChannel(((ChannelRunner.ConsumerThrowable<Channel, T>) channel ->",
          "34:                         checker = channel.export(PipeWriterTestChecker.class, PipeWriterTest.this, false, true, true))",
          "35:                 .andThen(f));",
          "41:     abstract class ResponseIoCoordCallable extends CallableBase<Object, Exception> {",
          "47:             assertTrue(System.currentTimeMillis() - start < 1000); // write() itself shouldn't block",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:             CheckerThread t = new CheckerThread();",
          "62:             t.start();",
          "63:             t.join();",
          "65:                 throw new AssertionError(t.death);",
          "67:             System.out.println(\"returning\");",
          "68:             return null;",
          "",
          "[Removed Lines]",
          "64:             if (t.death!=null)",
          "",
          "[Added Lines]",
          "70:             if (t.death != null) {",
          "72:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:         });",
          "117:     }",
          "124:         @Override",
          "125:         public Object call() throws IOException {",
          "126:             long start = System.currentTimeMillis();",
          "127:             System.out.println(\"touch\");",
          "128:             touch();",
          "129:             System.out.println(\"verify\");",
          "132:             System.out.println(\"end\");",
          "133:             return null;",
          "134:         }",
          "",
          "[Removed Lines]",
          "123:     abstract class RequestIoCoordCallable extends CallableBase<Object,Exception> {",
          "130:             assertTrue(System.currentTimeMillis()-start<1000); // write() itself shouldn't block",
          "131:             checker.assertSlowStreamTouched();  // but this call should",
          "",
          "[Added Lines]",
          "130:     abstract class RequestIoCoordCallable extends CallableBase<Object, Exception> {",
          "137:             assertTrue(System.currentTimeMillis() - start < 1000); // write() itself shouldn't block",
          "138:             checker.assertSlowStreamTouched(); // but this call should",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "185:     static class SlowOutputStream extends OutputStream {",
          "188:         @Override",
          "189:         public void write(int b) throws IOException {",
          "",
          "[Removed Lines]",
          "186:         boolean closed,flushed,written;",
          "",
          "[Added Lines]",
          "194:         boolean closed, flushed, written;",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/PipeWriterTestChecker.java||src/test/java/hudson/remoting/PipeWriterTestChecker.java": [
          "File: src/test/java/hudson/remoting/PipeWriterTestChecker.java -> src/test/java/hudson/remoting/PipeWriterTestChecker.java"
        ],
        "src/test/java/hudson/remoting/PrefetchTest.java||src/test/java/hudson/remoting/PrefetchTest.java": [
          "File: src/test/java/hudson/remoting/PrefetchTest.java -> src/test/java/hudson/remoting/PrefetchTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:         });",
          "48:     }",
          "51:         @Override",
          "52:         public String call() throws IOException {",
          "53:             return \"verified\";",
          "54:         }",
          "55:         private static final long serialVersionUID = 1L;",
          "56:     }",
          "57: }",
          "",
          "[Removed Lines]",
          "50:     private static class VerifyTask extends CallableBase<String,IOException> {",
          "",
          "[Added Lines]",
          "50:     private static class VerifyTask extends CallableBase<String, IOException> {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/PrefetchingTest.java||src/test/java/hudson/remoting/PrefetchingTest.java": [
          "File: src/test/java/hudson/remoting/PrefetchingTest.java -> src/test/java/hudson/remoting/PrefetchingTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:     private File dir;",
          "40:         channelRunner.withChannel(((ChannelRunner.ConsumerThrowable<Channel, Exception>) this::setUp).andThen(f));",
          "41:     }",
          "44:     protected void setUp(Channel channel) throws Exception {",
          "45:         URL jar1 = getClass().getClassLoader().getResource(\"remoting-test-client.jar\");",
          "46:         URL jar2 = getClass().getClassLoader().getResource(\"remoting-test-client-tests.jar\");",
          "",
          "[Removed Lines]",
          "37:     private Checksum sum1,sum2;",
          "39:     void withChannel(ChannelRunner channelRunner, ChannelRunner.ConsumerThrowable<Channel, Exception> f) throws Exception {",
          "",
          "[Added Lines]",
          "37:     private Checksum sum1, sum2;",
          "39:     void withChannel(ChannelRunner channelRunner, ChannelRunner.ConsumerThrowable<Channel, Exception> f)",
          "40:             throws Exception {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:         if (dir != null) {",
          "86:                 try {",
          "87:                     FileUtils.deleteDirectory(dir);",
          "88:                     return;",
          "89:                 } catch (IOException e) {",
          "91:                     Thread.sleep(1000);",
          "92:                 }",
          "93:             }",
          "",
          "[Removed Lines]",
          "85:             for (int i=0; ; i++) {",
          "90:                     if (i==3)   throw e;",
          "",
          "[Added Lines]",
          "85:             for (int i = 0; ; i++) {",
          "90:                     if (i == 3) {",
          "91:                         throw e;",
          "92:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:             channel.call(new ForceJarLoad(sum1));",
          "106:             channel.call(new ForceJarLoad(sum2));",
          "109:             ((Function<Function<Object, Object>, Void>) sc).apply(new Verifier());",
          "110:             assertNull(channel.call(sc));",
          "111:         });",
          "112:     }",
          "115:         @Override",
          "116:         public Object apply(Object o) {",
          "117:             try {",
          "",
          "[Removed Lines]",
          "108:             Callable<Void, IOException> sc = (Callable<Void, IOException>) cl.loadClass(\"test.ClassLoadingFromJarTester\").getDeclaredConstructor().newInstance();",
          "114:     private static class Verifier implements Function<Object,Object>, Serializable {",
          "",
          "[Added Lines]",
          "110:             Callable<Void, IOException> sc =",
          "111:                     (Callable<Void, IOException>) cl.loadClass(\"test.ClassLoadingFromJarTester\")",
          "112:                             .getDeclaredConstructor()",
          "113:                             .newInstance();",
          "119:     private static class Verifier implements Function<Object, Object>, Serializable {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:             channel.call(new ForceJarLoad(sum1));",
          "136:             channel.call(new ForceJarLoad(sum2));",
          "139:             String v = channel.call(c);",
          "140:             System.out.println(v);",
          "",
          "[Removed Lines]",
          "138:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResource\").getDeclaredConstructor().newInstance();",
          "",
          "[Added Lines]",
          "144:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResource\")",
          "145:                     .getDeclaredConstructor()",
          "146:                     .newInstance();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "148:     public void testGetResource_precache(ChannelRunner channelRunner) throws Exception {",
          "149:         withChannel(channelRunner, channel -> {",
          "151:             String v = channel.call(c);",
          "152:             System.out.println(v);",
          "",
          "[Removed Lines]",
          "150:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResource\").getDeclaredConstructor().newInstance();",
          "",
          "[Added Lines]",
          "158:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResource\")",
          "159:                     .getDeclaredConstructor()",
          "160:                     .newInstance();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "159:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "160:     public void testGetResourceAsStream(ChannelRunner channelRunner) throws Exception {",
          "161:         withChannel(channelRunner, channel -> {",
          "163:             String v = channel.call(c);",
          "164:             assertEquals(\"hello\", v);",
          "165:         });",
          "",
          "[Removed Lines]",
          "162:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResourceAsStream\").getDeclaredConstructor().newInstance();",
          "",
          "[Added Lines]",
          "172:             Callable<String, IOException> c =",
          "173:                     (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResourceAsStream\")",
          "174:                             .getDeclaredConstructor()",
          "175:                             .newInstance();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "171:     private void verifyResource(String v) {",
          "175:     }",
          "",
          "[Removed Lines]",
          "172:         assertThat(v, allOf(startsWith(\"jar:file:\"),",
          "173:                                    containsString(dir.toURI().getPath()),",
          "174:                                    endsWith(\"::hello\")));",
          "",
          "[Added Lines]",
          "185:         assertThat(v, allOf(startsWith(\"jar:file:\"), containsString(dir.toURI().getPath()), endsWith(\"::hello\")));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "193:             channel.call(new ForceJarLoad(sum1));",
          "194:             channel.call(new ForceJarLoad(sum2));",
          "197:             String v = channel.call(c);",
          "200:             String[] lines = v.split(\"\\n\");",
          "202:             verifyResource(lines[0]);",
          "207:         });",
          "208:     }",
          "214:     @ParameterizedTest",
          "215:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "216:     public void testGetResources_precache(ChannelRunner channelRunner) throws Exception {",
          "217:         withChannel(channelRunner, channel -> {",
          "219:             String v = channel.call(c);",
          "222:             String[] lines = v.split(\"\\n\");",
          "",
          "[Removed Lines]",
          "196:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResources\").getDeclaredConstructor().newInstance();",
          "198:             System.out.println(v);  // should find two resources",
          "204:             assertThat(lines[1], allOf(startsWith(\"jar:file:\"),",
          "205:                     containsString(dir.toURI().getPath()),",
          "206:                     endsWith(\"::hello2\")));",
          "213:     @Disabled(\"TODO flakes: jar:file:/tmp/remoting-cache\u2026.jar!/test/hello.txt::hello ==> expected: <true> but was: <false>\")",
          "218:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResources\").getDeclaredConstructor().newInstance();",
          "220:             System.out.println(v);  // should find two resources",
          "",
          "[Added Lines]",
          "207:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResources\")",
          "208:                     .getDeclaredConstructor()",
          "209:                     .newInstance();",
          "211:             System.out.println(v); // should find two resources",
          "217:             assertThat(",
          "218:                     lines[1],",
          "219:                     allOf(startsWith(\"jar:file:\"), containsString(dir.toURI().getPath()), endsWith(\"::hello2\")));",
          "226:     @Disabled(",
          "227:             \"TODO flakes: jar:file:/tmp/remoting-cache\u2026.jar!/test/hello.txt::hello ==> expected: <true> but was: <false>\")",
          "232:             Callable<String, IOException> c = (Callable<String, IOException>) cl.loadClass(\"test.HelloGetResources\")",
          "233:                     .getDeclaredConstructor()",
          "234:                     .newInstance();",
          "236:             System.out.println(v); // should find two resources",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "241:         });",
          "242:     }",
          "245:         V value;",
          "247:         @Override",
          "248:         public V call() {",
          "249:             return value;",
          "250:         }",
          "251:         private static final long serialVersionUID = 1L;",
          "252:     }",
          "260:         private ForceJarLoad(Checksum sum) {",
          "261:             this.sum1 = sum.sum1;",
          "",
          "[Removed Lines]",
          "244:     private static final class Echo<V> extends CallableBase<V,IOException> implements Serializable {",
          "257:     private static final class ForceJarLoad extends CallableBase<Void,IOException> implements Serializable{",
          "258:         private final long sum1,sum2;",
          "",
          "[Added Lines]",
          "260:     private static final class Echo<V> extends CallableBase<V, IOException> implements Serializable {",
          "274:     private static final class ForceJarLoad extends CallableBase<Void, IOException> implements Serializable {",
          "275:         private final long sum1, sum2;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "270:                 if (jarCache == null) {",
          "271:                     throw new IOException(\"Cannot Force JAR load, JAR cache is disabled\");",
          "272:                 }",
          "274:                 return null;",
          "275:             } catch (InterruptedException | ExecutionException e) {",
          "276:                 throw new IOException(e);",
          "277:             }",
          "278:         }",
          "279:         private static final long serialVersionUID = 1L;",
          "280:     }",
          "",
          "[Removed Lines]",
          "273:                 jarCache.resolve(ch,sum1,sum2).get();",
          "",
          "[Added Lines]",
          "290:                 jarCache.resolve(ch, sum1, sum2).get();",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ProxyExceptionTest.java||src/test/java/hudson/remoting/ProxyExceptionTest.java": [
          "File: src/test/java/hudson/remoting/ProxyExceptionTest.java -> src/test/java/hudson/remoting/ProxyExceptionTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:         ProxyException pe1 = new ProxyException(cyclic1);",
          "57:         assertThat(pe1.getMessage(), is(cyclic1.toString()));",
          "58:         assertThat(pe1.getStackTrace(), is(cyclic1.getStackTrace()));",
          "60:         assertThat(pe2.getMessage(), is(cyclic2.toString()));",
          "61:         assertThat(pe2.getStackTrace(), is(cyclic2.getStackTrace()));",
          "62:         assertThat(pe2.getSuppressed(), is(emptyArray()));",
          "",
          "[Removed Lines]",
          "59:         ProxyException pe2 = (ProxyException)pe1.getSuppressed()[0];",
          "",
          "[Added Lines]",
          "59:         ProxyException pe2 = (ProxyException) pe1.getSuppressed()[0];",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/ProxyWriterTest.java||src/test/java/hudson/remoting/ProxyWriterTest.java": [
          "File: src/test/java/hudson/remoting/ProxyWriterTest.java -> src/test/java/hudson/remoting/ProxyWriterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: public class ProxyWriterTest implements Serializable {",
          "27:     ByteArrayOutputStream log = new ByteArrayOutputStream();",
          "29:         @Override",
          "30:         public synchronized void publish(LogRecord record) {",
          "31:             super.publish(record);",
          "",
          "[Removed Lines]",
          "28:     StreamHandler logRecorder = new StreamHandler(log,new SimpleFormatter()) {",
          "",
          "[Added Lines]",
          "28:     StreamHandler logRecorder = new StreamHandler(log, new SimpleFormatter()) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:             writeBunchOfData(correct);",
          "65:             assertEquals(sw.toString(), correct.toString());",
          "67:         });",
          "68:     }",
          "70:     private static void writeBunchOfData(Writer w) throws IOException {",
          "72:             w.write('1');",
          "73:             w.write(\"hello\".toCharArray());",
          "74:             w.write(\"abcdef\".toCharArray(), 0, 3);",
          "75:         }",
          "76:         w.flush();",
          "78:             w.write(\"hello\");",
          "80:         }",
          "81:         w.close();",
          "82:     }",
          "",
          "[Removed Lines]",
          "66:             assertEquals(0, log.size());    // no warning should be reported",
          "71:         for (int i=0; i<1000; i++) {",
          "77:         for (int i=0; i<1000; i++) {",
          "79:             w.write(\"abcdef\",0,3);",
          "",
          "[Added Lines]",
          "65:             assertEquals(0, log.size()); // no warning should be reported",
          "70:         for (int i = 0; i < 1000; i++) {",
          "76:         for (int i = 0; i < 1000; i++) {",
          "78:             w.write(\"abcdef\", 0, 3);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:     @ParameterizedTest",
          "89:     @MethodSource(ChannelRunners.PROVIDER_METHOD)",
          "90:     public void testRemoteGC(ChannelRunner channelRunner) throws Exception {",
          "92:         channelRunner.withChannel(channel -> {",
          "93:             StringWriter sw = new StringWriter() {",
          "94:                 @Override",
          "",
          "[Removed Lines]",
          "91:         assumeFalse(channelRunner instanceof InProcessCompatibilityRunner, \"in the legacy mode ProxyWriter will try to close the stream, so can't run this test\");",
          "",
          "[Added Lines]",
          "90:         assumeFalse(",
          "91:                 channelRunner instanceof InProcessCompatibilityRunner,",
          "92:                 \"in the legacy mode ProxyWriter will try to close the stream, so can't run this test\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "107:                 assertEquals(0, log.size(), \"There shouldn't be any errors: \" + log.toString());",
          "109:                 Thread.sleep(100);",
          "111:                     break;",
          "112:             }",
          "114:             channel.syncIO();",
          "",
          "[Removed Lines]",
          "106:             for (int i=0; i<30; i++) {",
          "110:                 if (channel.call(new GcCallable()))",
          "",
          "[Added Lines]",
          "107:             for (int i = 0; i < 30; i++) {",
          "111:                 if (channel.call(new GcCallable())) {",
          "113:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "130:             StringWriter sw = new StringWriter();",
          "131:             final RemoteWriter w = new RemoteWriter(sw);",
          "134:                 channel.call(new WriterCallable(w));",
          "135:                 w.write(\"2\");",
          "136:             }",
          "139:         });",
          "140:     }",
          "",
          "[Removed Lines]",
          "133:             for (int i=0; i<16; i++) {",
          "138:             assertEquals(\"12121212121212121212121212121212\",sw.toString());",
          "",
          "[Added Lines]",
          "134:             for (int i = 0; i < 16; i++) {",
          "139:             assertEquals(\"12121212121212121212121212121212\", sw.toString());",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/RegExpBenchmark.java||src/test/java/hudson/remoting/RegExpBenchmark.java": [
          "File: src/test/java/hudson/remoting/RegExpBenchmark.java -> src/test/java/hudson/remoting/RegExpBenchmark.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: @Ignore(\"This is not a test just a benchmark and is here for ease of running\")",
          "37: public class RegExpBenchmark {",
          "39:     final Pattern p1 = Pattern.compile(\"^org\\\\.codehaus\\\\.groovy\\\\.runtime\\\\..*\");",
          "40:     final Pattern p2 = Pattern.compile(\"^org\\\\.apache\\\\.commons\\\\.collections\\\\.functors\\\\..*\");",
          "41:     final Pattern p3 = Pattern.compile(\"^.*org\\\\.apache\\\\.xalan\\\\..*\");",
          "46:     final String s1 = \"org.codehaus.groovy.runtime.\";",
          "47:     final String s2 = \"org.apache.commons.collections.functors.\";",
          "48:     final String s3 = \"org.apache.xalan.\";",
          "50:     @Test",
          "51:     public void repeatedBenchMark() throws Exception {",
          "53:             benchmark();",
          "55:         }",
          "56:     }",
          "58:     @Test",
          "59:     public void benchmark() throws Exception {",
          "60:         System.out.println(\"there are \" + getAllRTClasses().size());",
          "62:         List<String> classes = getAllRTClasses();",
          "63:         final long startRegExp = System.nanoTime();",
          "64:         final List<String> matchesRegExp = checkClassesRegExp(classes);",
          "65:         final long durationRegexpNanos = System.nanoTime() - startRegExp;",
          "70:         classes = getAllRTClasses();",
          "71:         final long startSingleRegExp = System.nanoTime();",
          "72:         final List<String> matchesSingleRegExp = checkClassesSingleRegExp(classes);",
          "73:         final long durationSingleRegexpNanos = System.nanoTime() - startSingleRegExp;",
          "77:         classes = getAllRTClasses();",
          "78:         final long startString = System.nanoTime();",
          "79:         final List<String> matchesString = checkClassesString(classes);",
          "80:         final long durationStringNanos = System.nanoTime() - startString;",
          "88:     }",
          "90:     private List<String> checkClassesRegExp(List<String> classnames) {",
          "91:         List<String> blacklistedClasses = new ArrayList<>();",
          "92:         for (String s : classnames) {",
          "95:                 blacklistedClasses.add(s);",
          "96:             }",
          "",
          "[Removed Lines]",
          "43:     final Pattern p4 = Pattern.compile(\"^(?:(?:org\\\\.(?:codehaus\\\\.groovy\\\\.runtime|apache\\\\.commons\\\\.collections\\\\.functors))|.*?org\\\\.apache\\\\.xalan)\\\\..*\");",
          "52:         for (int i=0; i < 10; i++) {",
          "54:             System.gc();System.gc();System.gc();",
          "67:         System.gc();System.gc();System.gc();",
          "74:         System.gc();System.gc();System.gc();",
          "82:         System.out.printf(Locale.ENGLISH, \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\", \"RegExp \", matchesRegExp.size(), durationRegexpNanos, durationRegexpNanos/classes.size());",
          "83:         System.out.printf(Locale.ENGLISH, \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\", \"SingleRegExp \", matchesSingleRegExp.size(), durationSingleRegexpNanos, durationSingleRegexpNanos/classes.size());",
          "84:         System.out.printf(Locale.ENGLISH, \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\", \"String \", matchesString.size(), durationStringNanos, durationStringNanos/classes.size());",
          "86:         System.out.println(\"Regular Expression is \" + durationRegexpNanos/durationStringNanos + \" times slower\");",
          "87:         System.out.println(\"Single Regular Expression is \" + durationSingleRegexpNanos/durationStringNanos + \" times slower\\n\");",
          "93:             if (p1.matcher(s).matches() || p2.matcher(s).matches() || p3.matcher(s).matches()) {",
          "",
          "[Added Lines]",
          "43:     final Pattern p4 = Pattern.compile(",
          "44:             \"^(?:(?:org\\\\.(?:codehaus\\\\.groovy\\\\.runtime|apache\\\\.commons\\\\.collections\\\\.functors))|.*?org\\\\.apache\\\\.xalan)\\\\..*\");",
          "52:         for (int i = 0; i < 10; i++) {",
          "54:             System.gc();",
          "55:             System.gc();",
          "56:             System.gc();",
          "69:         System.gc();",
          "70:         System.gc();",
          "71:         System.gc();",
          "79:         System.gc();",
          "80:         System.gc();",
          "81:         System.gc();",
          "90:         System.out.printf(",
          "91:                 Locale.ENGLISH,",
          "92:                 \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\",",
          "93:                 \"RegExp \",",
          "94:                 matchesRegExp.size(),",
          "95:                 durationRegexpNanos,",
          "96:                 durationRegexpNanos / classes.size());",
          "97:         System.out.printf(",
          "98:                 Locale.ENGLISH,",
          "99:                 \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\",",
          "100:                 \"SingleRegExp \",",
          "101:                 matchesSingleRegExp.size(),",
          "102:                 durationSingleRegexpNanos,",
          "103:                 durationSingleRegexpNanos / classes.size());",
          "104:         System.out.printf(",
          "105:                 Locale.ENGLISH,",
          "106:                 \"%-13s: %d blacklisted classes in %9dns.  Average class check time is %dns%n\",",
          "107:                 \"String \",",
          "108:                 matchesString.size(),",
          "109:                 durationStringNanos,",
          "110:                 durationStringNanos / classes.size());",
          "112:         System.out.println(\"Regular Expression is \" + durationRegexpNanos / durationStringNanos + \" times slower\");",
          "113:         System.out.println(",
          "114:                 \"Single Regular Expression is \" + durationSingleRegexpNanos / durationStringNanos + \" times slower\\n\");",
          "120:             if (p1.matcher(s).matches()",
          "121:                     || p2.matcher(s).matches()",
          "122:                     || p3.matcher(s).matches()) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:         }",
          "120:         return blacklistedClasses;",
          "121:     }",
          "123:     private List<String> getAllRTClasses() throws Exception {",
          "124:         List<String> classes = new ArrayList<>();",
          "126:         String javaHome = System.getProperty(\"java.home\");",
          "128:         for (JarEntry je : Collections.list(jf.entries())) {",
          "129:             if (!je.isDirectory() && je.getName().endsWith(\".class\")) {",
          "130:                 String name = je.getName().replace('/', '.');",
          "",
          "[Removed Lines]",
          "127:         JarFile jf = new JarFile(javaHome +  \"/lib/rt.jar\");",
          "",
          "[Added Lines]",
          "156:         JarFile jf = new JarFile(javaHome + \"/lib/rt.jar\");",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/RemoteInputStreamTest.java||src/test/java/hudson/remoting/RemoteInputStreamTest.java": [
          "File: src/test/java/hudson/remoting/RemoteInputStreamTest.java -> src/test/java/hudson/remoting/RemoteInputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:             Thread.sleep(100);",
          "48:                 assertEquals(-1, in.read());",
          "51:                 assertEquals('5', in.read());",
          "52:             }",
          "",
          "[Removed Lines]",
          "47:             if (channel.remoteCapability.supportsGreedyRemoteInputStream())",
          "49:             else {",
          "",
          "[Added Lines]",
          "47:             if (channel.remoteCapability.supportsGreedyRemoteInputStream()) {",
          "49:             } else {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:         private final RemoteInputStream in;",
          "61:         private final byte[] expected;",
          "",
          "[Removed Lines]",
          "59:     private static class Read extends CallableBase<Object,IOException> {",
          "",
          "[Added Lines]",
          "59:     private static class Read extends CallableBase<Object, IOException> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:         });",
          "90:     }",
          "93:         private final RemoteInputStream i;",
          "95:         public TestGreedy2(RemoteInputStream i) {",
          "",
          "[Removed Lines]",
          "92:     private static class TestGreedy2 extends CallableBase<Void,IOException> {",
          "",
          "[Added Lines]",
          "92:     private static class TestGreedy2 extends CallableBase<Void, IOException> {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116:         channelRunner.withChannel(channel -> {",
          "117:             for (RemoteInputStream.Flag f : List.of(RemoteInputStream.Flag.GREEDY, RemoteInputStream.Flag.NOT_GREEDY)) {",
          "118:                 InputStream in = new SequenceInputStream(",
          "122:                 final RemoteInputStream i = new RemoteInputStream(in, f);",
          "124:                 channel.call(new TestErrorPropagation(i));",
          "",
          "[Removed Lines]",
          "119:                         new ByteArrayInputStream(toBytes(\"1234\")),",
          "120:                         new BrokenInputStream(new SkyIsFalling())",
          "121:                 );",
          "",
          "[Added Lines]",
          "119:                         new ByteArrayInputStream(toBytes(\"1234\")), new BrokenInputStream(new SkyIsFalling()));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "126:         });",
          "127:     }",
          "131:     private static class TestErrorPropagation extends CallableBase<Void, IOException> {",
          "132:         private final RemoteInputStream i;",
          "",
          "[Removed Lines]",
          "129:     private static class SkyIsFalling extends IOException {private static final long serialVersionUID = 1L;}",
          "",
          "[Added Lines]",
          "127:     private static class SkyIsFalling extends IOException {",
          "128:         private static final long serialVersionUID = 1L;",
          "129:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "147:                 return null;",
          "148:             } catch (IOException e) {",
          "150:                     return null;",
          "151:                 throw e;",
          "152:             }",
          "153:         }",
          "154:         private static final long serialVersionUID = 1L;",
          "155:     }",
          "158:     private static byte[] readFully(InputStream in, int n) throws IOException {",
          "159:         byte[] actual = new byte[n];",
          "160:         new DataInputStream(in).readFully(actual);",
          "",
          "[Removed Lines]",
          "149:                 if (e.getCause() instanceof SkyIsFalling)",
          "",
          "[Added Lines]",
          "149:                 if (e.getCause() instanceof SkyIsFalling) {",
          "151:                 }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "162:     }",
          "164:     private static void assertArrayEquals(byte[] b1, byte[] b2) {",
          "167:         }",
          "168:     }",
          "",
          "[Removed Lines]",
          "165:         if (!Arrays.equals(b1,b2)) {",
          "166:             fail(\"Expected \"+ HexDump.toHex(b1)+\" but got \"+ HexDump.toHex(b2));",
          "",
          "[Added Lines]",
          "166:         if (!Arrays.equals(b1, b2)) {",
          "167:             fail(\"Expected \" + HexDump.toHex(b1) + \" but got \" + HexDump.toHex(b2));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java||src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java": [
          "File: src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java -> src/test/java/hudson/remoting/RemoteInvocationHandlerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:         }",
          "73:     }",
          "76:         private final Contract c;",
          "77:         Task(Contract c) {",
          "78:             this.c = c;",
          "79:         }",
          "80:         @Override",
          "81:         public Void call() throws Error {",
          "82:             c.meth(\"value\");",
          "83:             return null;",
          "84:         }",
          "85:         private static final long serialVersionUID = 1L;",
          "86:     }",
          "89:         private final Contract2 c;",
          "90:         Task2(Contract2 c) {",
          "91:             this.c = c;",
          "92:         }",
          "93:         @Override",
          "94:         public Void call() throws Error {",
          "95:             c.meth2(\"value\");",
          "96:             return null;",
          "97:         }",
          "98:         private static final long serialVersionUID = 1L;",
          "99:     }",
          "",
          "[Removed Lines]",
          "75:     private static class Task extends CallableBase<Void,Error> {",
          "88:     private static class Task2 extends CallableBase<Void,Error> {",
          "",
          "[Added Lines]",
          "78:     private static class Task extends CallableBase<Void, Error> {",
          "94:     private static class Task2 extends CallableBase<Void, Error> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:             synchronized (i) {",
          "109:                 channel.call(new AsyncTask(c));",
          "113:                     i.wait();",
          "115:             }",
          "116:         });",
          "117:     }",
          "",
          "[Removed Lines]",
          "110:                 assertNull(i.arg);  // async call should be blocking",
          "112:                 while (i.arg == null)",
          "114:                 assertEquals(\"value\", i.arg);  // once we let the call complete, we should see 'value'",
          "",
          "[Added Lines]",
          "119:                 assertNull(i.arg); // async call should be blocking",
          "121:                 while (i.arg == null) {",
          "123:                 }",
          "124:                 assertEquals(\"value\", i.arg); // once we let the call complete, we should see 'value'",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "130:                 notifyAll();",
          "131:             }",
          "132:         }",
          "133:         private static final long serialVersionUID = 1L;",
          "134:     }",
          "137:         private final AsyncContract c;",
          "138:         AsyncTask(AsyncContract c) {",
          "139:             this.c = c;",
          "140:         }",
          "141:         @Override",
          "142:         public Void call() throws Error {",
          "143:             c.meth(\"value\");",
          "144:             return null;",
          "145:         }",
          "146:         private static final long serialVersionUID = 1L;",
          "147:     }",
          "148: }",
          "",
          "[Removed Lines]",
          "136:     private static class AsyncTask extends CallableBase<Void,Error> {",
          "",
          "[Added Lines]",
          "148:     private static class AsyncTask extends CallableBase<Void, Error> {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/SimpleTest.java||src/test/java/hudson/remoting/SimpleTest.java": [
          "File: src/test/java/hudson/remoting/SimpleTest.java -> src/test/java/hudson/remoting/SimpleTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     public void test1Async(ChannelRunner channelRunner) throws Exception {",
          "58:         channelRunner.withChannel(channel -> {",
          "59:             Future<Integer> r = channel.callAsync(new Callable1());",
          "62:         });",
          "63:     }",
          "",
          "[Removed Lines]",
          "60:             System.out.println(\"result=\"+r.get());",
          "61:             assertEquals(5,(int)r.get());",
          "",
          "[Added Lines]",
          "60:             System.out.println(\"result=\" + r.get());",
          "61:             assertEquals(5, (int) r.get());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:     public void test2(ChannelRunner channelRunner) throws Exception {",
          "77:         channelRunner.withChannel(channel -> {",
          "78:             final RuntimeException e = assertThrows(RuntimeException.class, () -> channel.call(new Callable2()));",
          "80:         });",
          "81:     }",
          "",
          "[Removed Lines]",
          "79:             assertEquals(e.getMessage(),\"foo\");",
          "",
          "[Added Lines]",
          "80:             assertEquals(e.getMessage(), \"foo\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:                 Future<Integer> r = channel.callAsync(new Callable2());",
          "89:                 r.get();",
          "90:             });",
          "92:         });",
          "93:     }",
          "",
          "[Removed Lines]",
          "91:             assertEquals(e.getCause().getMessage(),\"foo\");",
          "",
          "[Added Lines]",
          "92:             assertEquals(e.getCause().getMessage(), \"foo\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:         channelRunner.withChannel(channel -> {",
          "110:             Foo c = new Foo() {};",
          "111:             Foo r = channel.call(new Echo<>(channel.export(Foo.class, c)));",
          "113:         });",
          "114:     }",
          "116:     public interface Foo {}",
          "119:         private final T t;",
          "121:         Echo(T t) {",
          "",
          "[Removed Lines]",
          "112:             assertSame(c,r);",
          "118:     private static class Echo<T> extends CallableBase<T,RuntimeException> {",
          "",
          "[Added Lines]",
          "114:             assertSame(c, r);",
          "120:     private static class Echo<T> extends CallableBase<T, RuntimeException> {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java||src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java": [
          "File: src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java -> src/test/java/hudson/remoting/SingleLaneExecutorServiceTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:         final StringBuilder record = new StringBuilder();",
          "35:         synchronized (lock) {",
          "36:             lane1.submit(() -> {",
          "38:                 sleep(1000);",
          "39:                 record.append(\"x\");",
          "40:             });",
          "",
          "[Removed Lines]",
          "37:                 synchronized (lock) {}",
          "",
          "[Added Lines]",
          "37:                 synchronized (lock) {",
          "38:                 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:         waitForCompletion(lane1);",
          "49:         waitForCompletion(lane2);",
          "52:     }",
          "",
          "[Removed Lines]",
          "51:         assertEquals(\"zxy\",record.toString());",
          "",
          "[Added Lines]",
          "52:         assertEquals(\"zxy\", record.toString());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:             ExecutorService lane = new SingleLaneExecutorService(base);",
          "66:             Workload() {",
          "68:                     final char ch = t;",
          "69:                     tasks.add(() -> {",
          "71:                         record.append(ch);",
          "72:                     });",
          "73:                 }",
          "",
          "[Removed Lines]",
          "67:                 for (char t='a'; t<='z'; t++) {",
          "70:                         sleep(50+r.nextInt(100));",
          "",
          "[Added Lines]",
          "68:                 for (char t = 'a'; t <= 'z'; t++) {",
          "71:                         sleep(50 + r.nextInt(100));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "75:         }",
          "77:         List<Workload> works = new ArrayList<>();",
          "79:             works.add(new Workload());",
          "82:         List<Workload> remaining = new ArrayList<>(works);",
          "83:         int total = (('z' - 'a') + 1) * works.size();",
          "85:             while (true) {",
          "86:                 int j = r.nextInt(remaining.size());",
          "87:                 Workload wl = remaining.get(j);",
          "",
          "[Removed Lines]",
          "78:         for (int i=0; i<5; i++)",
          "84:         for (int i=0; i<total; i++) {",
          "",
          "[Added Lines]",
          "79:         for (int i = 0; i < 5; i++) {",
          "81:         }",
          "86:         for (int i = 0; i < total; i++) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "98:         for (Workload wl : works) {",
          "99:             waitForCompletion(wl.lane);",
          "101:         }",
          "102:     }",
          "",
          "[Removed Lines]",
          "100:             assertEquals(\"abcdefghijklmnopqrstuvwxyz\",wl.record.toString());",
          "",
          "[Added Lines]",
          "102:             assertEquals(\"abcdefghijklmnopqrstuvwxyz\", wl.record.toString());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "113:             throw new Error();",
          "114:         }",
          "115:     }",
          "",
          "[Removed Lines]",
          "116: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/TestCallable.java||src/test/java/hudson/remoting/TestCallable.java": [
          "File: src/test/java/hudson/remoting/TestCallable.java -> src/test/java/hudson/remoting/TestCallable.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:         byte[] buf = new byte[8192];",
          "53:         int len;",
          "56:         in.close();",
          "58:         r[1] = baos.toByteArray();",
          "",
          "[Removed Lines]",
          "54:         while((len=in.read(buf))>0)",
          "55:             baos.write(buf,0,len);",
          "",
          "[Added Lines]",
          "54:         while ((len = in.read(buf)) > 0) {",
          "55:             baos.write(buf, 0, len);",
          "56:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:     }",
          "67:     @Override",
          "69:     }",
          "72:     private static final long serialVersionUID = 1L;",
          "73: }",
          "",
          "[Removed Lines]",
          "68:     public void checkRoles(RoleChecker checker) throws SecurityException {",
          "71:     public static class Sub extends TestCallable {private static final long serialVersionUID = 1L;}",
          "",
          "[Added Lines]",
          "69:     public void checkRoles(RoleChecker checker) throws SecurityException {}",
          "71:     public static class Sub extends TestCallable {",
          "72:         private static final long serialVersionUID = 1L;",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/TestLinkage.java||src/test/java/hudson/remoting/TestLinkage.java": [
          "File: src/test/java/hudson/remoting/TestLinkage.java -> src/test/java/hudson/remoting/TestLinkage.java"
        ],
        "src/test/java/hudson/remoting/TestStaticGetResources.java||src/test/java/hudson/remoting/TestStaticGetResources.java": [
          "File: src/test/java/hudson/remoting/TestStaticGetResources.java -> src/test/java/hudson/remoting/TestStaticGetResources.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     static {",
          "12:         try {",
          "14:         } catch (IOException e) {",
          "15:             e.printStackTrace();",
          "16:         }",
          "17:     }",
          "19:     public Object call() {",
          "20:         return \"found the impossible: \" + FIRST_RESOURCE;",
          "21:     }",
          "23: }",
          "",
          "[Removed Lines]",
          "13:             FIRST_RESOURCE = TestStaticGetResources.class.getClassLoader().getResources(\"BLAH\").hasMoreElements();",
          "",
          "[Added Lines]",
          "13:             FIRST_RESOURCE = TestStaticGetResources.class",
          "14:                     .getClassLoader()",
          "15:                     .getResources(\"BLAH\")",
          "16:                     .hasMoreElements();",
          "22:     @Override",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/TestStaticResourceReference.java||src/test/java/hudson/remoting/TestStaticResourceReference.java": [
          "File: src/test/java/hudson/remoting/TestStaticResourceReference.java -> src/test/java/hudson/remoting/TestStaticResourceReference.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:     private static final long serialVersionUID = 1L;",
          "10:     public Object call() {",
          "11:         return \"found the impossible: \" + FALSE;",
          "12:     }",
          "14: }",
          "",
          "[Removed Lines]",
          "8:     private static boolean FALSE = TestStaticResourceReference.class.getClassLoader().getResource(\"BLAH\") != null;",
          "",
          "[Added Lines]",
          "8:     private static boolean FALSE =",
          "9:             TestStaticResourceReference.class.getClassLoader().getResource(\"BLAH\") != null;",
          "11:     @Override",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/TrafficAnalyzer.java||src/test/java/hudson/remoting/TrafficAnalyzer.java": [
          "File: src/test/java/hudson/remoting/TrafficAnalyzer.java -> src/test/java/hudson/remoting/TrafficAnalyzer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:     public static void main(String[] args) throws Exception {",
          "19:         File f = new File(\"/home/kohsuke/ws/hudson/investigations/javafx-windows-hang/out.log\");",
          "20:         try (DataInputStream fin = new DataInputStream(new FileInputStream(f))) {",
          "34:                     }",
          "36:                 }",
          "39:             }",
          "40:         }",
          "41:     }",
          "43: }",
          "",
          "[Removed Lines]",
          "21:         fin.readFully(new byte[4]); // skip preamble",
          "22:         try (ObjectInputStream ois = new ObjectInputStream(fin)) {",
          "23:             for (int n=0; ; n++) {",
          "24:                 Command o = (Command)ois.readObject();",
          "25:                 System.out.println(\"#\"+n+\" : \"+o);",
          "26:                 if (o instanceof RemoteInvocationHandler.RPCRequest) {",
          "27:                     RemoteInvocationHandler.RPCRequest request = (RemoteInvocationHandler.RPCRequest) o;",
          "28:                     System.out.print(\"  (\");",
          "29:                     boolean first=true;",
          "30:                     for (Object argument : request.getArguments()) {",
          "31:                         if(first)   first=false;",
          "32:                         else        System.out.print(\",\");",
          "33:                         System.out.print(argument);",
          "35:                     System.out.println(\")\");",
          "37:                 if (o.createdAt!=null)",
          "38:                     o.createdAt.printStackTrace(System.out);",
          "42:     }",
          "",
          "[Added Lines]",
          "21:             fin.readFully(new byte[4]); // skip preamble",
          "22:             try (ObjectInputStream ois = new ObjectInputStream(fin)) {",
          "23:                 for (int n = 0; ; n++) {",
          "24:                     Command o = (Command) ois.readObject();",
          "25:                     System.out.println(\"#\" + n + \" : \" + o);",
          "26:                     if (o instanceof RemoteInvocationHandler.RPCRequest) {",
          "27:                         RemoteInvocationHandler.RPCRequest request = (RemoteInvocationHandler.RPCRequest) o;",
          "28:                         System.out.print(\"  (\");",
          "29:                         boolean first = true;",
          "30:                         for (Object argument : request.getArguments()) {",
          "31:                             if (first) {",
          "32:                                 first = false;",
          "33:                             } else {",
          "34:                                 System.out.print(\",\");",
          "35:                             }",
          "36:                             System.out.print(argument);",
          "37:                         }",
          "38:                         System.out.println(\")\");",
          "39:                     }",
          "40:                     if (o.createdAt != null) {",
          "41:                         o.createdAt.printStackTrace(System.out);",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/URLDeserializatinHelperTest.java||src/test/java/hudson/remoting/URLDeserializatinHelperTest.java": [
          "File: src/test/java/hudson/remoting/URLDeserializatinHelperTest.java -> src/test/java/hudson/remoting/URLDeserializatinHelperTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: import java.net.URL;",
          "6: import org.junit.Test;",
          "10:     @Test",
          "13:         URL original = new URL(\"https://localhost\");",
          "14:         URL url = URLDeserializationHelper.wrapIfRequired(original);",
          "15:         url.openConnection(Proxy.NO_PROXY);",
          "",
          "[Removed Lines]",
          "8: public class URLDeserializatinHelperTest",
          "9: {",
          "11:     public void openURLWithProxy() throws IOException",
          "12:     {",
          "",
          "[Added Lines]",
          "8: public class URLDeserializatinHelperTest {",
          "10:     public void openURLWithProxy() throws IOException {",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/pipe/RandomWorkload.java||src/test/java/hudson/remoting/pipe/RandomWorkload.java": [
          "File: src/test/java/hudson/remoting/pipe/RandomWorkload.java -> src/test/java/hudson/remoting/pipe/RandomWorkload.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:         Random data = new Random(0);",
          "29:         Random boundary = new Random(1);",
          "32:             int c = boundary.nextInt(4096);",
          "35:             byte[] buf = new byte[c];",
          "39:             o.write(buf);",
          "41:         }",
          "43:         o.close();",
          "",
          "[Removed Lines]",
          "31:         for (long l=0; l<size; ) {",
          "33:             c = (int)Math.min(c, size-l);",
          "36:             for (int i=0; i<c; i++)",
          "37:                 buf[i] = (byte)data.nextInt();",
          "40:             l+=c;",
          "",
          "[Added Lines]",
          "31:         for (long l = 0; l < size; ) {",
          "33:             c = (int) Math.min(c, size - l);",
          "36:             for (int i = 0; i < c; i++) {",
          "37:                 buf[i] = (byte) data.nextInt();",
          "38:             }",
          "41:             l += c;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:         Random data = new Random(0);",
          "49:         Random boundary = new Random(2);",
          "52:         while (true) {",
          "53:             int c = boundary.nextInt(4096);",
          "54:             byte[] buf = new byte[c];",
          "56:             int n = i.read(buf);",
          "63:         }",
          "65:         i.close();",
          "",
          "[Removed Lines]",
          "51:         long total=0;",
          "57:             if (n<0)    break;",
          "59:             for (int j=0; j<n; j++)",
          "60:                 assertEquals(buf[j], (byte)data.nextInt());",
          "62:             total+=n;",
          "",
          "[Added Lines]",
          "52:         long total = 0;",
          "58:             if (n < 0) {",
          "59:                 break;",
          "60:             }",
          "62:             for (int j = 0; j < n; j++) {",
          "63:                 assertEquals(buf[j], (byte) data.nextInt());",
          "64:             }",
          "66:             total += n;",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/pipe/Workload.java||src/test/java/hudson/remoting/pipe/Workload.java": [
          "File: src/test/java/hudson/remoting/pipe/Workload.java -> src/test/java/hudson/remoting/pipe/Workload.java"
        ],
        "src/test/java/hudson/remoting/throughput/DumbReceiver.java||src/test/java/hudson/remoting/throughput/DumbReceiver.java": [
          "File: src/test/java/hudson/remoting/throughput/DumbReceiver.java -> src/test/java/hudson/remoting/throughput/DumbReceiver.java"
        ],
        "src/test/java/hudson/remoting/throughput/DumbSender.java||src/test/java/hudson/remoting/throughput/DumbSender.java": [
          "File: src/test/java/hudson/remoting/throughput/DumbSender.java -> src/test/java/hudson/remoting/throughput/DumbSender.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:     public static void main(String[] args) throws Exception {",
          "14:         byte[] payload = getRandomSequence();",
          "17:             try (Socket s = new Socket(\"127.0.0.2\", DumbReceiver.PORT)) {",
          "18:                 System.out.println(\"Started\");",
          "19:                 long start = System.nanoTime();",
          "20:                 IOUtils.copy(new ByteArrayInputStream(payload), s.getOutputStream());",
          "22:             }",
          "23:         }",
          "24:     }",
          "26:     private static byte[] getRandomSequence() {",
          "28:         new Random(0).nextBytes(buf);",
          "29:         return buf;",
          "30:     }",
          "32: }",
          "",
          "[Removed Lines]",
          "16:         for (int i=0; i<2; i++) {",
          "21:                 System.out.println(\"Done: \"+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime()-start));",
          "27:         byte[] buf = new byte[10*1024*1024];",
          "",
          "[Added Lines]",
          "16:         for (int i = 0; i < 2; i++) {",
          "21:                 System.out.println(\"Done: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));",
          "27:         byte[] buf = new byte[10 * 1024 * 1024];",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/throughput/Receiver.java||src/test/java/hudson/remoting/throughput/Receiver.java": [
          "File: src/test/java/hudson/remoting/throughput/Receiver.java -> src/test/java/hudson/remoting/throughput/Receiver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:                 try (Socket s = ss.accept()) {",
          "23:                     s.setTcpNoDelay(true);",
          "24:                     System.out.println(\"Accepted\");",
          "28:                     ch.join();",
          "29:                 }",
          "30:             }",
          "31:         }",
          "32:     }",
          "33:     public static final int PORT = 9532;",
          "",
          "[Removed Lines]",
          "25:                     Channel ch = new ChannelBuilder(\"bogus\", Executors.newCachedThreadPool()).build(",
          "26:                             new BufferedInputStream(SocketChannelStream.in(s)),",
          "27:                             new BufferedOutputStream(SocketChannelStream.out(s)));",
          "34: }",
          "",
          "[Added Lines]",
          "25:                     Channel ch = new ChannelBuilder(\"bogus\", Executors.newCachedThreadPool())",
          "26:                             .build(",
          "27:                                     new BufferedInputStream(SocketChannelStream.in(s)),",
          "28:                                     new BufferedOutputStream(SocketChannelStream.out(s)));",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/throughput/Sender.java||src/test/java/hudson/remoting/throughput/Sender.java": [
          "File: src/test/java/hudson/remoting/throughput/Sender.java -> src/test/java/hudson/remoting/throughput/Sender.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:         byte[] digest = digest(new ByteArrayInputStream(payload));",
          "35:         while (true) {",
          "37:             s.setTcpNoDelay(true);",
          "42:             final Pipe p = Pipe.createLocalToRemote();",
          "43:             Future<byte[]> f = ch.callAsync(new DigestCallable(p));",
          "45:             System.out.println(\"Started\");",
          "46:             long start = System.nanoTime();",
          "48:             p.getOut().close();",
          "49:             f.get();",
          "52:             assertArrayEquals(digest, f.get()); // verify the correctness of the result",
          "",
          "[Removed Lines]",
          "36:             Socket s = new Socket(\"127.0.0.2\",Receiver.PORT);",
          "38:             Channel ch = new ChannelBuilder(\"bogus\", Executors.newCachedThreadPool()).build(",
          "39:                     new BufferedInputStream(SocketChannelStream.in(s)),",
          "40:                     new BufferedOutputStream(SocketChannelStream.out(s)));",
          "47:             IOUtils.copy(new ByteArrayInputStream(payload),p.getOut());",
          "50:             System.out.println(\"Done: \"+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime()-start));",
          "",
          "[Added Lines]",
          "36:             Socket s = new Socket(\"127.0.0.2\", Receiver.PORT);",
          "38:             Channel ch = new ChannelBuilder(\"bogus\", Executors.newCachedThreadPool())",
          "39:                     .build(",
          "40:                             new BufferedInputStream(SocketChannelStream.in(s)),",
          "41:                             new BufferedOutputStream(SocketChannelStream.out(s)));",
          "48:             IOUtils.copy(new ByteArrayInputStream(payload), p.getOut());",
          "51:             System.out.println(\"Done: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:     }",
          "60:     private static byte[] digest(InputStream in) throws NoSuchAlgorithmException, IOException {",
          "62:         IOUtils.copy(in, dos);",
          "63:         return dos.getMessageDigest().digest();",
          "64:     }",
          "66:     private static byte[] getRandomSequence() {",
          "68:         new Random(0).nextBytes(buf);",
          "69:         return buf;",
          "70:     }",
          "",
          "[Removed Lines]",
          "61:         DigestOutputStream dos = new DigestOutputStream(OutputStream.nullOutputStream(), MessageDigest.getInstance(\"MD5\"));",
          "67:         byte[] buf = new byte[10*1024*1024];",
          "",
          "[Added Lines]",
          "62:         DigestOutputStream dos =",
          "63:                 new DigestOutputStream(OutputStream.nullOutputStream(), MessageDigest.getInstance(\"MD5\"));",
          "69:         byte[] buf = new byte[10 * 1024 * 1024];",
          "",
          "---------------"
        ],
        "src/test/java/hudson/remoting/util/GCTask.java||src/test/java/hudson/remoting/util/GCTask.java": [
          "File: src/test/java/hudson/remoting/util/GCTask.java -> src/test/java/hudson/remoting/util/GCTask.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     public Object call() throws IOException {",
          "24:         if (agressive) {",
          "25:             Set<Object[]> objects = new HashSet<>();",
          "27:             while (true) {",
          "28:                 try {",
          "29:                     objects.add(new Object[size]);",
          "",
          "[Removed Lines]",
          "26:             int size = ((int)Math.min(Runtime.getRuntime().freeMemory(), Integer.MAX_VALUE)) / 32;",
          "",
          "[Added Lines]",
          "26:             int size = ((int) Math.min(Runtime.getRuntime().freeMemory(), Integer.MAX_VALUE)) / 32;",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java||src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java -> src/test/java/org/jenkinsci/remoting/engine/HandlerLoopbackLoadStress.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:     public HandlerLoopbackLoadStress(Config config)",
          "142:             throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException,",
          "144:         this.config = config;",
          "145:         KeyPairGenerator gen = KeyPairGenerator.getInstance(\"RSA\");",
          "146:         gen.initialize(2048); // maximum supported by JVM with export restrictions",
          "",
          "[Removed Lines]",
          "143:             UnrecoverableKeyException, KeyManagementException, OperatorCreationException {",
          "",
          "[Added Lines]",
          "143:                     UnrecoverableKeyException, KeyManagementException, OperatorCreationException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:                 .build();",
          "162:         X509v3CertificateBuilder certGen = new X509v3CertificateBuilder(",
          "171:         JcaX509ExtensionUtils instance = new JcaX509ExtensionUtils();",
          "178:         ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\")",
          "179:                 .setProvider(BOUNCY_CASTLE_PROVIDER)",
          "",
          "[Removed Lines]",
          "163:                 subject,",
          "164:                 BigInteger.ONE,",
          "165:                 firstDate,",
          "166:                 lastDate,",
          "167:                 subject,",
          "168:                 subjectPublicKeyInfo",
          "169:         );",
          "173:         certGen.addExtension(Extension.subjectKeyIdentifier,",
          "174:                 false,",
          "175:                 instance.createSubjectKeyIdentifier(subjectPublicKeyInfo)",
          "176:         );",
          "",
          "[Added Lines]",
          "163:                 subject, BigInteger.ONE, firstDate, lastDate, subject, subjectPublicKeyInfo);",
          "167:         certGen.addExtension(",
          "168:                 Extension.subjectKeyIdentifier, false, instance.createSubjectKeyIdentifier(subjectPublicKeyInfo));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "188:         KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());",
          "189:         store.load(null, password);",
          "192:         KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",
          "193:         kmf.init(store, password);",
          "195:         SSLContext context = SSLContext.getInstance(\"TLS\");",
          "199:         mainHub = IOHub.create(executorService);",
          "",
          "[Removed Lines]",
          "190:         store.setKeyEntry(\"alias\", keyPair.getPrivate(), password, new Certificate[]{certificate});",
          "196:         context.init(kmf.getKeyManagers(),",
          "197:                 new TrustManager[]{new BlindTrustX509ExtendedTrustManager()}, null);",
          "",
          "[Added Lines]",
          "182:         store.setKeyEntry(\"alias\", keyPair.getPrivate(), password, new Certificate[] {certificate});",
          "188:         context.init(kmf.getKeyManagers(), new TrustManager[] {new BlindTrustX509ExtendedTrustManager()}, null);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:             p.printUsage(System.err);",
          "300:             System.exit(0);",
          "301:         }",
          "303:                         + \"(%.1f/sec) to give a total expected rate of %.1f/sec%n\",",
          "306:         System.out.println(!config.bio ? \"Preferring NIO\" : \"Prefering BIO\");",
          "307:         final HandlerLoopbackLoadStress stress = new HandlerLoopbackLoadStress(config);",
          "308:         stress.mainHub.execute(stress.stats);",
          "",
          "[Removed Lines]",
          "302:         System.out.printf(\"Starting stress test of %s with %d clients making calls (payload %d bytes) every %dms \"",
          "304:                 config.name, config.numClients, config.payload, config.clientIntervalMs,",
          "305:                 1000.0 / config.clientIntervalMs, 1000.0 / config.clientIntervalMs * config.numClients);",
          "",
          "[Added Lines]",
          "293:         System.out.printf(",
          "294:                 \"Starting stress test of %s with %d clients making calls (payload %d bytes) every %dms \"",
          "296:                 config.name,",
          "297:                 config.numClients,",
          "298:                 config.payload,",
          "299:                 config.clientIntervalMs,",
          "300:                 1000.0 / config.clientIntervalMs,",
          "301:                 1000.0 / config.clientIntervalMs * config.numClients);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "325:                         System.out.println(\"Starting client \" + i);",
          "326:                     }",
          "327:                     final int clientNumber = i;",
          "330:                         try {",
          "333:                         } finally {",
          "334:                             started.countDown();",
          "335:                         }",
          "336:                         return null;",
          "337:                     }));",
          "338:                 }",
          "340:                     future.get(60, TimeUnit.SECONDS);",
          "341:                 }",
          "342:                 started.await(60, TimeUnit.SECONDS);",
          "",
          "[Removed Lines]",
          "328:                     clients.add(",
          "329:                     stress.executorService.submit(() -> {",
          "331:                             stress.startClient(clientNumber, serverAddress, config.clientIntervalMs,",
          "332:                                     config.payload);",
          "339:                 for (Future<Void> future: clients) {",
          "",
          "[Added Lines]",
          "324:                     clients.add(stress.executorService.submit(() -> {",
          "326:                             stress.startClient(clientNumber, serverAddress, config.clientIntervalMs, config.payload);",
          "333:                 for (Future<Void> future : clients) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "389:     private Long getProcessCpuTime() {",
          "390:         Object r = null;",
          "391:         if (operatingSystemMXBean instanceof com.sun.management.OperatingSystemMXBean) {",
          "393:         } else if (_getProcessCpuTime != null) {",
          "395:             try {",
          "",
          "[Removed Lines]",
          "392:             r = ((com.sun.management.OperatingSystemMXBean)operatingSystemMXBean).getProcessCpuTime();",
          "",
          "[Added Lines]",
          "386:             r = ((com.sun.management.OperatingSystemMXBean) operatingSystemMXBean).getProcessCpuTime();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "416:         String clientName = runtimeMXBean.getName() + \"-client-\" + n;",
          "417:         headers.put(JnlpConnectionState.CLIENT_NAME_KEY, clientName);",
          "418:         headers.put(JnlpConnectionState.SECRET_KEY, secretFor(clientName));",
          "430:                     long start = System.currentTimeMillis();",
          "455:                         }",
          "456:                     }",
          "465:     }",
          "467:     public static class Config {",
          "",
          "[Removed Lines]",
          "419:         final Channel clientChannel = handler.connect(toServer.socket(), headers, clientListener)",
          "420:                 .get(15, TimeUnit.SECONDS);",
          "421:         timer[n % timer.length].scheduleAtFixedRate(new TimerTask() {",
          "422:             long start = System.currentTimeMillis();",
          "423:             int index = 0;",
          "424:             int times = 0;",
          "425:             private NoOpCallable callable = new NoOpCallable(payloadSize == -1 ? null : new byte[payloadSize]);",
          "427:             @Override",
          "428:             public void run() {",
          "429:                 try {",
          "431:                     clientChannel.call(callable);",
          "432:                     if (config.client != null) {",
          "433:                         NoOpCallable.noops.incrementAndGet();",
          "434:                     }",
          "435:                     times++;",
          "436:                     if (times % 1000 == 0) {",
          "437:                         System.out.printf(\"  %s has run %d No-op callables. Rate %.1f/s expect %.1f/s%n\",",
          "438:                                 clientChannel.getName(), times,",
          "439:                                 times * 1000.0 / (System.currentTimeMillis() - this.start), 1000.0 / clientIntervalMs);",
          "440:                     }",
          "441:                     long duration = System.currentTimeMillis() - start;",
          "442:                     if (duration > 250L) {",
          "443:                         System.err.printf(\"  %s took %dms to complete a callable%n\", clientChannel.getName(),",
          "444:                                 duration);",
          "445:                     }",
          "446:                     if (callable.payload != null && callable.payload.length > 0) {",
          "448:                         int count = callable.payload.length;",
          "449:                         if (count > 100) {",
          "450:                             count = 100;",
          "451:                         }",
          "452:                         for (int j = 0; j < count; j++) {",
          "453:                             callable.payload[index] = (byte) (callable.payload[index] * 31 + times);",
          "454:                             index = Math.abs(index + 1) % callable.payload.length;",
          "457:                 } catch (Exception e) {",
          "458:                     e.printStackTrace(System.err);",
          "459:                     IOUtils.closeQuietly(clientChannel);",
          "460:                     cancel();",
          "461:                     System.exit(2);",
          "462:                 }",
          "463:             }",
          "464:         }, entropy.nextInt(clientIntervalMs), clientIntervalMs);",
          "",
          "[Added Lines]",
          "413:         final Channel clientChannel =",
          "414:                 handler.connect(toServer.socket(), headers, clientListener).get(15, TimeUnit.SECONDS);",
          "415:         timer[n % timer.length].scheduleAtFixedRate(",
          "416:                 new TimerTask() {",
          "418:                     int index = 0;",
          "419:                     int times = 0;",
          "420:                     private NoOpCallable callable = new NoOpCallable(payloadSize == -1 ? null : new byte[payloadSize]);",
          "422:                     @Override",
          "423:                     public void run() {",
          "424:                         try {",
          "425:                             long start = System.currentTimeMillis();",
          "426:                             clientChannel.call(callable);",
          "427:                             if (config.client != null) {",
          "428:                                 NoOpCallable.noops.incrementAndGet();",
          "429:                             }",
          "430:                             times++;",
          "431:                             if (times % 1000 == 0) {",
          "432:                                 System.out.printf(",
          "433:                                         \"  %s has run %d No-op callables. Rate %.1f/s expect %.1f/s%n\",",
          "434:                                         clientChannel.getName(),",
          "435:                                         times,",
          "436:                                         times * 1000.0 / (System.currentTimeMillis() - this.start),",
          "437:                                         1000.0 / clientIntervalMs);",
          "438:                             }",
          "439:                             long duration = System.currentTimeMillis() - start;",
          "440:                             if (duration > 250L) {",
          "441:                                 System.err.printf(",
          "442:                                         \"  %s took %dms to complete a callable%n\", clientChannel.getName(), duration);",
          "443:                             }",
          "444:                             if (callable.payload != null && callable.payload.length > 0) {",
          "446:                                 int count = callable.payload.length;",
          "447:                                 if (count > 100) {",
          "448:                                     count = 100;",
          "449:                                 }",
          "450:                                 for (int j = 0; j < count; j++) {",
          "451:                                     callable.payload[index] = (byte) (callable.payload[index] * 31 + times);",
          "452:                                     index = Math.abs(index + 1) % callable.payload.length;",
          "453:                                 }",
          "454:                             }",
          "455:                         } catch (Exception e) {",
          "456:                             e.printStackTrace(System.err);",
          "457:                             IOUtils.closeQuietly(clientChannel);",
          "458:                             cancel();",
          "459:                             System.exit(2);",
          "462:                 },",
          "463:                 entropy.nextInt(clientIntervalMs),",
          "464:                 clientIntervalMs);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "471:         @Option(name = \"--clients\", metaVar = \"CLIENTS\", usage = \"The number of clients to simulate\")",
          "472:         public int numClients = 100;",
          "475:                 metaVar = \"MILLISECONDS\",",
          "476:                 usage = \"The number of milliseconds each client waits before sending a command\")",
          "477:         public int clientIntervalMs = 100;",
          "",
          "[Removed Lines]",
          "474:         @Option(name = \"--interval\",",
          "",
          "[Added Lines]",
          "474:         @Option(",
          "475:                 name = \"--interval\",",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "479:         @Option(name = \"--size\", metaVar = \"BYTES\", usage = \"The number of bytes to pad the command with\")",
          "480:         public int payload = -1;",
          "483:                 metaVar = \"SECONDS\",",
          "484:                 usage = \"The number of seconds after all connections are established to warm up before resetting stats\")",
          "485:         public int warmup = -1;",
          "488:                 metaVar = \"SECONDS\",",
          "489:                 usage = \"The number of seconds after all connections are established to collect stats for before \"",
          "490:                         + \"stopping\")",
          "",
          "[Removed Lines]",
          "482:         @Option(name = \"--warmup\",",
          "487:         @Option(name = \"--collect\",",
          "",
          "[Added Lines]",
          "483:         @Option(",
          "484:                 name = \"--warmup\",",
          "489:         @Option(",
          "490:                 name = \"--collect\",",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "502:         @Option(name = \"--server\", usage = \"Specify to run as a server only\")",
          "503:         public boolean server;",
          "506:                 metaVar = \"HOST:PORT\",",
          "507:                 usage = \"Specify to run as a client only and connect to a server on the specified HOST:PORT\")",
          "508:         public String client;",
          "511:                 usage = \"The number of milliseconds to wait between client starts\")",
          "512:         public int connectDelay = -1;",
          "515:         public boolean help;",
          "516:     }",
          "",
          "[Removed Lines]",
          "505:         @Option(name = \"--client\",",
          "510:         @Option(name=\"--connect\", metaVar = \"MILLIS\",",
          "514:         @Option(name = \"--help\", aliases = {\"-h\", \"-?\"})",
          "",
          "[Added Lines]",
          "508:         @Option(",
          "509:                 name = \"--client\",",
          "514:         @Option(",
          "515:                 name = \"--connect\",",
          "516:                 metaVar = \"MILLIS\",",
          "520:         @Option(",
          "521:                 name = \"--help\",",
          "522:                 aliases = {\"-h\", \"-?\"})",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "536:         public void afterChannel(@NonNull JnlpConnectionState event) {",
          "537:             String clientName = event.getProperty(JnlpConnectionState.CLIENT_NAME_KEY);",
          "538:             if (clientName != null) {",
          "540:             }",
          "541:         }",
          "542:     }",
          "",
          "[Removed Lines]",
          "539:                 System.out.println(\"Accepted connection from client \" + clientName + \" on \" + event.getRemoteEndpointDescription());",
          "",
          "[Added Lines]",
          "547:                 System.out.println(\"Accepted connection from client \" + clientName + \" on \"",
          "548:                         + event.getRemoteEndpointDescription());",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "558:         }",
          "560:         @Override",
          "564:         private static final long serialVersionUID = 1L;",
          "565:     }",
          "",
          "[Removed Lines]",
          "561:         public void checkRoles(RoleChecker checker) throws SecurityException {",
          "563:         }",
          "",
          "[Added Lines]",
          "570:         public void checkRoles(RoleChecker checker) throws SecurityException {}",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "578:             memoryA = Runtime.getRuntime().totalMemory();",
          "579:             memoryS = 0;",
          "580:             memoryCount = 1;",
          "589:         }",
          "591:         private synchronized void clientsStarted() {",
          "",
          "[Removed Lines]",
          "581:             System.out.printf(\"%n%-7s   %-29s   %-20s   %8s   %14s%n\",",
          "582:                     \"\", \"          Calls rate\", \"JVM CPU utilization\", \"\", \"\");",
          "583:             System.out.printf(\"%-7s   %9s %9s %9s   %6s %6s %6s   %8s   %14s%n\",",
          "584:                     \"Time\", \"cur\", \"all\", \"expect\", \"cur\", \"all\",",
          "585:                     \"expect\", \"Sys load\", \"Average Memory\");",
          "586:             System.out.printf(\"%7s   %9s %9s %9s   %6s %6s %6s   %8s   %14s%n\",",
          "587:                     \"=======\", \"=========\", \"=========\", \"=========\", \"======\", \"======\",",
          "588:                     \"======\", \"========\", \"==============\");",
          "",
          "[Added Lines]",
          "589:             System.out.printf(",
          "590:                     \"%n%-7s   %-29s   %-20s   %8s   %14s%n\", \"\", \"          Calls rate\", \"JVM CPU utilization\", \"\", \"\");",
          "591:             System.out.printf(",
          "592:                     \"%-7s   %9s %9s %9s   %6s %6s %6s   %8s   %14s%n\",",
          "593:                     \"Time\", \"cur\", \"all\", \"expect\", \"cur\", \"all\", \"expect\", \"Sys load\", \"Average Memory\");",
          "594:             System.out.printf(",
          "595:                     \"%7s   %9s %9s %9s   %6s %6s %6s   %8s   %14s%n\",",
          "596:                     \"=======\",",
          "597:                     \"=========\",",
          "598:                     \"=========\",",
          "599:                     \"=========\",",
          "600:                     \"======\",",
          "601:                     \"======\",",
          "602:                     \"======\",",
          "603:                     \"========\",",
          "604:                     \"==============\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "625:                 double noopsPerSecond = current.noopsPerSecond(last);",
          "626:                 double vmLoad0 = current.vmLoad(start);",
          "627:                 double vmLoad = current.vmLoad(last);",
          "629:                         (current.uptime - start.uptime) / 60000.0,",
          "630:                         noopsPerSecond,",
          "631:                         noopsPerSecond0,",
          "",
          "[Removed Lines]",
          "628:                 System.out.printf(\"%-4.1fmin   %7.1f/s %7.1f/s %7.1f/s   %6.2f %6.2f %6.2f   %8.2f   %7.1fkB \u00b1 %.1f %ddf   %s%n\",",
          "",
          "[Added Lines]",
          "644:                 System.out.printf(",
          "645:                         \"%-4.1fmin   %7.1f/s %7.1f/s %7.1f/s   %6.2f %6.2f %6.2f   %8.2f   %7.1fkB \u00b1 %.1f %ddf   %s%n\",",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "637:                         memoryCount > 0 ? memoryA / 1024 : Double.NaN,",
          "638:                         memoryCount > 1 ? Math.sqrt(memoryS / (memoryCount - 1)) / 1024 : Double.NaN,",
          "639:                         memoryCount,",
          "642:                 System.out.flush();",
          "643:                 last = current;",
          "646:                     System.out.println(\"Warmup completed\");",
          "647:                     clearStats();",
          "648:                     warmed = true;",
          "650:                         && current.uptime - start.uptime > config.collect * 1000L) {",
          "651:                     if (config.file != null) {",
          "652:                         try {",
          "",
          "[Removed Lines]",
          "640:                         current.gcSummary(start)",
          "641:                 );",
          "644:                 if (started && !warmed && (config.warmup <= 0",
          "645:                         || current.uptime - start.uptime > config.warmup * 1000L)) {",
          "649:                 } else if (started && warmed && config.collect > 0",
          "",
          "[Added Lines]",
          "657:                         current.gcSummary(start));",
          "660:                 if (started",
          "661:                         && !warmed",
          "662:                         && (config.warmup <= 0 || current.uptime - start.uptime > config.warmup * 1000L)) {",
          "666:                 } else if (started",
          "667:                         && warmed",
          "668:                         && config.collect > 0",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "663:                                 pw = new PrintWriter(new FileWriter(f, true));",
          "664:                             }",
          "665:                             try {",
          "667:                                         config.name,",
          "668:                                         config.bio ? \"blocking\" : \"non-blocking\",",
          "669:                                         config.numClients,",
          "",
          "[Removed Lines]",
          "666:                                 pw.printf(\"\\\"%s\\\",\\\"%s\\\",%d,%d,%d,%.1f,%.1f,%.2f,%.2f,%d,%.2f,%.2f,%d,%.2f,%s%n\",",
          "",
          "[Added Lines]",
          "685:                                 pw.printf(",
          "686:                                         \"\\\"%s\\\",\\\"%s\\\",%d,%d,%d,%.1f,%.1f,%.2f,%.2f,%d,%.2f,%.2f,%d,%.2f,%s%n\",",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "678:                                         memoryCount > 1 ? Math.sqrt(memoryS / (memoryCount - 1)) / 1024 : Double.NaN,",
          "679:                                         memoryCount,",
          "680:                                         Runtime.getRuntime().maxMemory() / 1024.0,",
          "683:                             } finally {",
          "684:                                 pw.close();",
          "685:                             }",
          "",
          "[Removed Lines]",
          "681:                                         current.gcData(start)",
          "682:                                 );",
          "",
          "[Added Lines]",
          "701:                                         current.gcData(start));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "707:                             memoryCount > 1 ? Math.sqrt(memoryS / (memoryCount - 1)) / 1024 : Double.NaN,",
          "708:                             memoryCount,",
          "709:                             Runtime.getRuntime().maxMemory() / 1024.0,",
          "712:                     System.exit(0);",
          "713:                 }",
          "714:             }",
          "715:         }",
          "717:     }",
          "719:     private static class GCStats {",
          "",
          "[Removed Lines]",
          "710:                             current.gcData(start)",
          "711:                     );",
          "",
          "[Added Lines]",
          "729:                             current.gcData(start));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "731:         private long noops;",
          "732:         private long uptime;",
          "733:         private @CheckForNull Long cpu;",
          "736:         public Metrics() {",
          "737:             time = System.currentTimeMillis();",
          "",
          "[Removed Lines]",
          "734:         private Map<String,GCStats> gc;",
          "",
          "[Added Lines]",
          "751:         private Map<String, GCStats> gc;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "739:             uptime = runtimeMXBean.getUptime();",
          "740:             cpu = getProcessCpuTime();",
          "741:             gc = new TreeMap<>();",
          "743:                 this.gc.put(bean.getName(), new GCStats(bean));",
          "744:             }",
          "745:         }",
          "",
          "[Removed Lines]",
          "742:             for (GarbageCollectorMXBean bean: garbageCollectorMXBeans) {",
          "",
          "[Added Lines]",
          "759:             for (GarbageCollectorMXBean bean : garbageCollectorMXBeans) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "780:         public String gcData(Metrics reference) {",
          "781:             StringBuilder result = new StringBuilder();",
          "782:             boolean first = true;",
          "784:                 String name = g.getName();",
          "785:                 GCStats s = reference.gc.get(name);",
          "786:                 GCStats x = gc.get(name);",
          "",
          "[Removed Lines]",
          "783:             for (GarbageCollectorMXBean g: garbageCollectorMXBeans) {",
          "",
          "[Added Lines]",
          "800:             for (GarbageCollectorMXBean g : garbageCollectorMXBeans) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "792:                 result.append(\"\\\"\").append(name).append(\"\\\",\");",
          "793:                 if (x == null) {",
          "794:                     result.append(0).append(',').append(0.0);",
          "797:                 } else {",
          "798:                     result.append(x.count - s.count).append(',').append((x.time - s.time) / 1000.0);",
          "799:                 }",
          "",
          "[Removed Lines]",
          "795:                 } else  if (s == null) {",
          "796:                     result.append(x.count).append(',').append(x.time/1000.0);",
          "",
          "[Added Lines]",
          "812:                 } else if (s == null) {",
          "813:                     result.append(x.count).append(',').append(x.time / 1000.0);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "805:             StringBuilder result = new StringBuilder();",
          "806:             int i = 0;",
          "807:             for (GarbageCollectorMXBean g : garbageCollectorMXBeans) {",
          "809:                 result.append(\"\\\"gc[\").append(i).append(\"].name\\\",\");",
          "810:                 result.append(\"\\\"gc[\").append(i).append(\"].count\\\",\");",
          "811:                 result.append(\"\\\"gc[\").append(i).append(\"].time\\\"\");",
          "",
          "[Removed Lines]",
          "808:                 if (i > 0) result.append(\",\");",
          "",
          "[Added Lines]",
          "825:                 if (i > 0) {",
          "826:                     result.append(\",\");",
          "827:                 }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "902:         }",
          "904:         @Override",
          "908:     }",
          "910: }",
          "",
          "[Removed Lines]",
          "905:         public void onClosedChannel(ClosedChannelException e) {",
          "907:         }",
          "",
          "[Added Lines]",
          "924:         public void onClosedChannel(ClosedChannelException e) {}",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java||src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java -> src/test/java/org/jenkinsci/remoting/engine/HostPortTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:     public void testSeparatorNoPort() {",
          "102:         HostPort hostPort = new HostPort(\"hostname:\", null, 7777);",
          "103:         assertThat(hostPort.getHost(), is(\"hostname\"));",
          "105:     }",
          "107:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "104:         assertThat(hostPort.getPort(), is( 7777));",
          "",
          "[Added Lines]",
          "104:         assertThat(hostPort.getPort(), is(7777));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:     public void testOnlySeparator() {",
          "119:         HostPort hostPort = new HostPort(\":\", \"hostname\", 7777);",
          "120:         assertThat(hostPort.getHost(), is(\"hostname\"));",
          "122:     }",
          "124:     @Test(expected = NumberFormatException.class)",
          "125:     public void testPortNotANumber() {",
          "126:         new HostPort(\"hostname:notAPort\");",
          "127:     }",
          "129: }",
          "",
          "[Removed Lines]",
          "121:         assertThat(hostPort.getPort(), is( 7777));",
          "",
          "[Added Lines]",
          "121:         assertThat(hostPort.getPort(), is(7777));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java||src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java -> src/test/java/org/jenkinsci/remoting/engine/JnlpProtocolHandlerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: public class JnlpProtocolHandlerTest {",
          "51:     private static final Consumer<JnlpConnectionState> APPROVING_STATE_CONSUMER = JnlpConnectionState::approve;",
          "55:     private static final String SECRET_KEY = \"SecretKey-1234\";",
          "57:     private static ExecutorService executorService;",
          "",
          "[Removed Lines]",
          "52:     private static final Consumer<JnlpConnectionState> REJECTING_STATE_CONSUMER = (event) -> event.reject(new ConnectionRefusalException(\"I don't like you\"));",
          "53:     private static final Consumer<JnlpConnectionState> IGNORING_STATE_CONSUMER = (event) -> {",
          "54:     };",
          "",
          "[Added Lines]",
          "52:     private static final Consumer<JnlpConnectionState> REJECTING_STATE_CONSUMER =",
          "53:             event -> event.reject(new ConnectionRefusalException(\"I don't like you\"));",
          "54:     private static final Consumer<JnlpConnectionState> IGNORING_STATE_CONSUMER = event -> {};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     private static RSAKeyPairRule serverKey = new RSAKeyPairRule();",
          "63:     private static RSAKeyPairRule caRootKey = new RSAKeyPairRule();",
          "64:     private static X509CertificateRule caRootCert = X509CertificateRule.create(\"caRoot\", caRootKey, caRootKey, null);",
          "67:     private static X509CertificateRule expiredClientCert =",
          "68:             X509CertificateRule.create(\"expiredClient\", clientKey, caRootKey, caRootCert, -10, -5, TimeUnit.DAYS);",
          "69:     private static X509CertificateRule notYetValidServerCert =",
          "70:             X509CertificateRule.create(\"notYetValidServer\", serverKey, caRootKey, caRootCert, +5, +10, TimeUnit.DAYS);",
          "91:     private static SSLContextRule untrustingClientCtx =",
          "95:     private static SSLContextRule untrustingServerCtx =",
          "99:     @ClassRule",
          "100:     public static RuleChain staticCtx = RuleChain.outerRule(caRootKey)",
          "101:             .around(clientKey)",
          "",
          "[Removed Lines]",
          "65:     private static X509CertificateRule clientCert = X509CertificateRule.create(\"client\", clientKey, caRootKey, caRootCert);",
          "66:     private static X509CertificateRule serverCert = X509CertificateRule.create(\"server\", serverKey, caRootKey, caRootCert);",
          "71:     private static SSLContextRule clientCtx =",
          "72:             new SSLContextRule(\"client\")",
          "73:                     .as(clientKey, clientCert, caRootCert)",
          "74:                     .trusting(caRootCert)",
          "75:                     .trusting(serverCert);",
          "76:     private static SSLContextRule serverCtx =",
          "77:             new SSLContextRule(\"server\")",
          "78:                     .as(serverKey, serverCert, caRootCert)",
          "79:                     .trusting(caRootCert)",
          "80:                     .trusting(clientCert);",
          "81:     private static SSLContextRule expiredClientCtx =",
          "82:             new SSLContextRule(\"expiredClient\")",
          "83:                     .as(clientKey, expiredClientCert, caRootCert)",
          "84:                     .trusting(caRootCert)",
          "85:                     .trusting(serverCert);",
          "86:     private static SSLContextRule notYetValidServerCtx =",
          "87:             new SSLContextRule(\"notYetValidServer\")",
          "88:                     .as(serverKey, notYetValidServerCert, caRootCert)",
          "89:                     .trusting(caRootCert)",
          "90:                     .trusting(clientCert);",
          "92:             new SSLContextRule(\"untrustingClient\")",
          "93:                     .as(clientKey, clientCert)",
          "94:                     .trusting(caRootCert);",
          "96:             new SSLContextRule(\"untrustingServer\")",
          "97:                     .as(serverKey, serverCert)",
          "98:                     .trusting(caRootCert);",
          "",
          "[Added Lines]",
          "65:     private static X509CertificateRule clientCert =",
          "66:             X509CertificateRule.create(\"client\", clientKey, caRootKey, caRootCert);",
          "67:     private static X509CertificateRule serverCert =",
          "68:             X509CertificateRule.create(\"server\", serverKey, caRootKey, caRootCert);",
          "73:     private static SSLContextRule clientCtx = new SSLContextRule(\"client\")",
          "74:             .as(clientKey, clientCert, caRootCert)",
          "75:             .trusting(caRootCert)",
          "76:             .trusting(serverCert);",
          "77:     private static SSLContextRule serverCtx = new SSLContextRule(\"server\")",
          "78:             .as(serverKey, serverCert, caRootCert)",
          "79:             .trusting(caRootCert)",
          "80:             .trusting(clientCert);",
          "81:     private static SSLContextRule expiredClientCtx = new SSLContextRule(\"expiredClient\")",
          "82:             .as(clientKey, expiredClientCert, caRootCert)",
          "83:             .trusting(caRootCert)",
          "84:             .trusting(serverCert);",
          "85:     private static SSLContextRule notYetValidServerCtx = new SSLContextRule(\"notYetValidServer\")",
          "86:             .as(serverKey, notYetValidServerCert, caRootCert)",
          "87:             .trusting(caRootCert)",
          "88:             .trusting(clientCert);",
          "90:             new SSLContextRule(\"untrustingClient\").as(clientKey, clientCert).trusting(caRootCert);",
          "92:             new SSLContextRule(\"untrustingServer\").as(serverKey, serverCert).trusting(caRootCert);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155:     @Theory",
          "156:     public void happyPath(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Throwable {",
          "159:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "161:         readAndCheckProtocol(factory);",
          "163:         serverRemotingChannel = serverChannelFuture.get(10, TimeUnit.SECONDS);",
          "164:         assertThat(serverRemotingChannel, notNullValue());",
          "165:         serverRemotingChannel.call(new TestCallable());",
          "",
          "[Removed Lines]",
          "157:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "158:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "160:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "162:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "",
          "[Added Lines]",
          "152:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "153:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "154:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "155:                 createClientProtocolHandler(factory, useNioHubClient);",
          "157:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "158:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "160:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "161:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170:     @Theory",
          "171:     public void serverRejects(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "174:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "176:         readAndCheckProtocol(factory);",
          "178:         assertChannelFails(clientChannelFuture, serverChannelFuture, ConnectionRefusalException.class);",
          "179:     }",
          "181:     @Theory",
          "182:     public void serverIgnores(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "185:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "187:         readAndCheckProtocol(factory);",
          "189:         assertChannelFails(clientChannelFuture, serverChannelFuture, IOException.class);",
          "190:     }",
          "192:     @Theory",
          "193:     public void clientRejects(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "196:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "198:         readAndCheckProtocol(factory);",
          "200:         assertChannelFails(clientChannelFuture, serverChannelFuture, IOException.class);",
          "201:     }",
          "203:     @Theory",
          "204:     public void clientIgnores(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "207:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "209:         readAndCheckProtocol(factory);",
          "211:         assertChannelFails(clientChannelFuture, serverChannelFuture, ConnectionRefusalException.class);",
          "212:     }",
          "214:     @Theory",
          "215:     public void doesNotExist(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "218:         HashMap<String, String> clientProps = createClientProperties(factory, SECRET_KEY);",
          "220:         readAndCheckProtocol(factory);",
          "222:         assertChannelFails(clientChannelFuture, serverChannelFuture, ConnectionRefusalException.class);",
          "223:     }",
          "225:     @Theory",
          "226:     public void wrongSecret(Factory factory, boolean useNioHubServer, boolean useNioHubClient) throws Exception {",
          "227:         Logger.getLogger(JnlpProtocol4Handler.class.getName()).setLevel(Level.SEVERE);",
          "230:         HashMap<String, String> clientProps = createClientProperties(factory, \"WrongSecret\");",
          "232:         readAndCheckProtocol(factory);",
          "234:         assertChannelFails(clientChannelFuture, serverChannelFuture, ConnectionRefusalException.class);",
          "235:     }",
          "241:     }",
          "247:     }",
          "249:     private HashMap<String, String> createClientProperties(Factory factory, String secretKey) {",
          "",
          "[Removed Lines]",
          "172:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "173:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "175:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "177:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), REJECTING_STATE_CONSUMER);",
          "183:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "184:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "186:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, IGNORING_STATE_CONSUMER);",
          "188:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "194:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "195:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "197:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "199:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), REJECTING_STATE_CONSUMER);",
          "205:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "206:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "208:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "210:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), IGNORING_STATE_CONSUMER);",
          "216:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, false);",
          "217:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "219:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "221:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "228:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler = createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "229:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler = createClientProtocolHandler(factory, useNioHubClient);",
          "231:         Future<Channel> clientChannelFuture = createChannelConnector(clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "233:         Future<Channel> serverChannelFuture = createChannelHandler(serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "237:     private Future<Channel> createChannelConnector(SocketChannel channel, JnlpProtocolHandler<? extends JnlpConnectionState> protocolHandler,",
          "238:                                                    HashMap<String, String> properties,",
          "239:                                                    Consumer<JnlpConnectionState> afterPropertiesConsumer) throws IOException {",
          "240:         return protocolHandler.connect(channel.socket(), properties, new StateListener(afterPropertiesConsumer, Channel.Mode.BINARY));",
          "243:     private Future<Channel> createChannelHandler(SocketChannel channel, JnlpProtocolHandler<? extends JnlpConnectionState> protocolHandler,",
          "244:                                                  HashMap<String, String> properties,",
          "245:                                                  Consumer<JnlpConnectionState> afterPropertiesConsumer) throws IOException {",
          "246:         return protocolHandler.handle(channel.socket(), properties, new StateListener(afterPropertiesConsumer, Channel.Mode.NEGOTIATE));",
          "",
          "[Added Lines]",
          "171:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "172:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "173:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "174:                 createClientProtocolHandler(factory, useNioHubClient);",
          "176:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "177:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "179:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "180:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), REJECTING_STATE_CONSUMER);",
          "186:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "187:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "188:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "189:                 createClientProtocolHandler(factory, useNioHubClient);",
          "191:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "192:                 clientSocketChannel, clientProtocolHandler, clientProps, IGNORING_STATE_CONSUMER);",
          "194:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "195:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "201:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "202:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "203:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "204:                 createClientProtocolHandler(factory, useNioHubClient);",
          "206:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "207:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "209:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "210:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), REJECTING_STATE_CONSUMER);",
          "216:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "217:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "218:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "219:                 createClientProtocolHandler(factory, useNioHubClient);",
          "221:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "222:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "224:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "225:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), IGNORING_STATE_CONSUMER);",
          "231:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "232:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, false);",
          "233:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "234:                 createClientProtocolHandler(factory, useNioHubClient);",
          "236:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "237:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "239:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "240:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "247:         JnlpProtocolHandler<? extends JnlpConnectionState> serverProtocolHandler =",
          "248:                 createServerProtocolHandler(factory, useNioHubServer, SECRET_KEY, true);",
          "249:         JnlpProtocolHandler<? extends JnlpConnectionState> clientProtocolHandler =",
          "250:                 createClientProtocolHandler(factory, useNioHubClient);",
          "252:         Future<Channel> clientChannelFuture = createChannelConnector(",
          "253:                 clientSocketChannel, clientProtocolHandler, clientProps, APPROVING_STATE_CONSUMER);",
          "255:         Future<Channel> serverChannelFuture = createChannelHandler(",
          "256:                 serverSocketChannel, serverProtocolHandler, new HashMap<>(), APPROVING_STATE_CONSUMER);",
          "260:     private Future<Channel> createChannelConnector(",
          "261:             SocketChannel channel,",
          "262:             JnlpProtocolHandler<? extends JnlpConnectionState> protocolHandler,",
          "263:             HashMap<String, String> properties,",
          "264:             Consumer<JnlpConnectionState> afterPropertiesConsumer)",
          "265:             throws IOException {",
          "266:         return protocolHandler.connect(",
          "267:                 channel.socket(), properties, new StateListener(afterPropertiesConsumer, Channel.Mode.BINARY));",
          "270:     private Future<Channel> createChannelHandler(",
          "271:             SocketChannel channel,",
          "272:             JnlpProtocolHandler<? extends JnlpConnectionState> protocolHandler,",
          "273:             HashMap<String, String> properties,",
          "274:             Consumer<JnlpConnectionState> afterPropertiesConsumer)",
          "275:             throws IOException {",
          "276:         return protocolHandler.handle(",
          "277:                 channel.socket(), properties, new StateListener(afterPropertiesConsumer, Channel.Mode.NEGOTIATE));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "253:         return clientProps;",
          "254:     }",
          "258:     }",
          "275:     }",
          "277:     private void readAndCheckProtocol(Factory factory) throws IOException {",
          "",
          "[Removed Lines]",
          "256:     private JnlpProtocolHandler<? extends JnlpConnectionState> createClientProtocolHandler(Factory factory, boolean useNioHubClient) {",
          "257:         return factory.create(null, executorService, selector, useNioHubClient ? hub : null, clientCtx.context(), useNioHubClient);",
          "260:     private JnlpProtocolHandler<? extends JnlpConnectionState> createServerProtocolHandler(Factory factory,",
          "261:                                                                                            boolean useNioHubServer,",
          "262:                                                                                            String secretKey,",
          "263:                                                                                            boolean exists) {",
          "264:         return factory.create(new JnlpClientDatabase() {",
          "265:             @Override",
          "266:             public boolean exists(String clientName) {",
          "267:                 return exists;",
          "268:             }",
          "270:             @Override",
          "271:             public String getSecretOf(@NonNull String clientName) {",
          "272:                 return secretKey;",
          "273:             }",
          "274:         }, executorService, selector, hub, serverCtx.context(), useNioHubServer);",
          "",
          "[Added Lines]",
          "287:     private JnlpProtocolHandler<? extends JnlpConnectionState> createClientProtocolHandler(",
          "288:             Factory factory, boolean useNioHubClient) {",
          "289:         return factory.create(",
          "290:                 null, executorService, selector, useNioHubClient ? hub : null, clientCtx.context(), useNioHubClient);",
          "293:     private JnlpProtocolHandler<? extends JnlpConnectionState> createServerProtocolHandler(",
          "294:             Factory factory, boolean useNioHubServer, String secretKey, boolean exists) {",
          "295:         return factory.create(",
          "296:                 new JnlpClientDatabase() {",
          "297:                     @Override",
          "298:                     public boolean exists(String clientName) {",
          "299:                         return exists;",
          "300:                     }",
          "302:                     @Override",
          "303:                     public String getSecretOf(@NonNull String clientName) {",
          "304:                         return secretKey;",
          "305:                     }",
          "306:                 },",
          "307:                 executorService,",
          "308:                 selector,",
          "309:                 hub,",
          "310:                 serverCtx.context(),",
          "311:                 useNioHubServer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "287:         assertThat(new String(bytes, StandardCharsets.UTF_8), is(\"Protocol:\" + factory.toString()));",
          "288:     }",
          "293:         try {",
          "294:             serverRemotingChannel = serverChannelFuture.get(10, TimeUnit.SECONDS);",
          "295:             fail();",
          "",
          "[Removed Lines]",
          "290:     private void assertChannelFails(Future<Channel> clientChannelFuture,",
          "291:                                     Future<Channel> serverChannelFuture,",
          "292:                                     Class<? extends Exception> serverExceptionType) throws InterruptedException, TimeoutException {",
          "",
          "[Added Lines]",
          "327:     private void assertChannelFails(",
          "328:             Future<Channel> clientChannelFuture,",
          "329:             Future<Channel> serverChannelFuture,",
          "330:             Class<? extends Exception> serverExceptionType)",
          "331:             throws InterruptedException, TimeoutException {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "307:     @DataPoints",
          "308:     public static boolean[] useNioHub() {",
          "310:     }",
          "312:     @DataPoints",
          "313:     public static Factory[] protocols() {",
          "330:                 }",
          "331:         };",
          "332:     }",
          "",
          "[Removed Lines]",
          "309:         return new boolean[]{true, false};",
          "314:         return new Factory[]{",
          "315:                 new Factory() {",
          "316:                     @Override",
          "317:                     public JnlpProtocolHandler<? extends JnlpConnectionState> create(JnlpClientDatabase db,",
          "318:                                                                                      ExecutorService svc,",
          "319:                                                                                      IOHub selector, NioChannelHub hub,",
          "320:                                                                                      SSLContext ctx,",
          "321:                                                                                      boolean preferNio) {",
          "322:                         return new JnlpProtocol4Handler(db, svc, selector, ctx, false, preferNio);",
          "324:                     }",
          "326:                     @Override",
          "327:                     public String toString() {",
          "328:                         return \"JNLP4-connect\";",
          "329:                     }",
          "",
          "[Added Lines]",
          "348:         return new boolean[] {true, false};",
          "353:         return new Factory[] {",
          "354:             new Factory() {",
          "355:                 @Override",
          "356:                 public JnlpProtocolHandler<? extends JnlpConnectionState> create(",
          "357:                         JnlpClientDatabase db,",
          "358:                         ExecutorService svc,",
          "359:                         IOHub selector,",
          "360:                         NioChannelHub hub,",
          "361:                         SSLContext ctx,",
          "362:                         boolean preferNio) {",
          "363:                     return new JnlpProtocol4Handler(db, svc, selector, ctx, false, preferNio);",
          "364:                 }",
          "366:                 @Override",
          "367:                 public String toString() {",
          "368:                     return \"JNLP4-connect\";",
          "370:             }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "351:         }",
          "353:         @Override",
          "356:     }",
          "358:     public interface Factory {",
          "362:     }",
          "364: }",
          "",
          "[Removed Lines]",
          "354:         public void afterChannel(@NonNull JnlpConnectionState event) {",
          "355:         }",
          "359:         JnlpProtocolHandler<? extends JnlpConnectionState> create(JnlpClientDatabase db, ExecutorService svc,",
          "360:                                                                   IOHub selector, NioChannelHub hub, SSLContext ctx,",
          "361:                                                                   boolean preferNio);",
          "",
          "[Added Lines]",
          "394:         public void afterChannel(@NonNull JnlpConnectionState event) {}",
          "398:         JnlpProtocolHandler<? extends JnlpConnectionState> create(",
          "399:                 JnlpClientDatabase db,",
          "400:                 ExecutorService svc,",
          "401:                 IOHub selector,",
          "402:                 NioChannelHub hub,",
          "403:                 SSLContext ctx,",
          "404:                 boolean preferNio);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java||src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java -> src/test/java/org/jenkinsci/remoting/engine/PropertiesStringMatcher.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:     private String expected;",
          "37:     public PropertiesStringMatcher(String expected) {",
          "40:     }",
          "42:     @Override",
          "",
          "[Removed Lines]",
          "38:         this.expected = expected.substring(",
          "39:                 expected.indexOf(System.getProperty(\"line.separator\")));",
          "",
          "[Added Lines]",
          "38:         this.expected = expected.substring(expected.indexOf(System.getProperty(\"line.separator\")));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java||src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java -> src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerRule.java"
        ],
        "src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java||src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java -> src/test/java/org/jenkinsci/remoting/engine/WorkDirManagerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:         Files.writeString(probeFileInInternalDir, \"Hello!\", StandardCharsets.UTF_8);",
          "86:         assertExists(WorkDirManager.DirType.JAR_CACHE_DIR);",
          "",
          "[Removed Lines]",
          "78:         final Path createdDir = WorkDirManager.getInstance().initializeWorkDir(dir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "79:         assertThat(\"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\", createdDir, equalTo(remotingDir));",
          "82:         Assert.assertTrue(\"Probe file in the \" + WorkDirManager.DirType.WORK_DIR + \" has been wiped\", Files.exists(probeFileInWorkDir));",
          "83:         Assert.assertTrue(\"Probe file in the \" + WorkDirManager.DirType.INTERNAL_DIR + \" has been wiped\", Files.exists(probeFileInInternalDir));",
          "",
          "[Added Lines]",
          "78:         final Path createdDir = WorkDirManager.getInstance()",
          "79:                 .initializeWorkDir(dir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "80:         assertThat(",
          "81:                 \"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\",",
          "82:                 createdDir,",
          "83:                 equalTo(remotingDir));",
          "86:         Assert.assertTrue(",
          "87:                 \"Probe file in the \" + WorkDirManager.DirType.WORK_DIR + \" has been wiped\",",
          "88:                 Files.exists(probeFileInWorkDir));",
          "89:         Assert.assertTrue(",
          "90:                 \"Probe file in the \" + WorkDirManager.DirType.INTERNAL_DIR + \" has been wiped\",",
          "91:                 Files.exists(probeFileInInternalDir));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     public void shouldPerformMkdirsIfRequired() throws Exception {",
          "92:         final File tmpDirFile = tmpDir.newFolder(\"foo\");",
          "93:         final File workDir = new File(tmpDirFile, \"just/a/long/non/existent/path\");",
          "97:         final File remotingDir = new File(workDir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation());",
          "103:     }",
          "105:     @Test",
          "",
          "[Removed Lines]",
          "94:         Assert.assertFalse(\"The \" +  WorkDirManager.DirType.INTERNAL_DIR + \" should not exist in the test\", workDir.exists());",
          "100:         final Path createdDir = WorkDirManager.getInstance().initializeWorkDir(workDir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "101:         assertThat(\"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\", createdDir.toFile(), equalTo(remotingDir));",
          "102:         Assert.assertTrue(\"Remoting \" + WorkDirManager.DirType.INTERNAL_DIR +  \" should have been initialized\", remotingDir.exists());",
          "",
          "[Added Lines]",
          "102:         Assert.assertFalse(",
          "103:                 \"The \" + WorkDirManager.DirType.INTERNAL_DIR + \" should not exist in the test\", workDir.exists());",
          "109:         final Path createdDir = WorkDirManager.getInstance()",
          "110:                 .initializeWorkDir(workDir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "111:         assertThat(",
          "112:                 \"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\",",
          "113:                 createdDir.toFile(),",
          "114:                 equalTo(remotingDir));",
          "115:         Assert.assertTrue(",
          "116:                 \"Remoting \" + WorkDirManager.DirType.INTERNAL_DIR + \" should have been initialized\",",
          "117:                 remotingDir.exists());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:         final String internalDirectoryName = \"myRemotingLogs\";",
          "108:         final File tmpDirFile = tmpDir.newFolder(\"foo\");",
          "109:         final File workDir = new File(tmpDirFile, \"just/another/path\");",
          "113:         final File remotingDir = new File(workDir, internalDirectoryName);",
          "116:         final Path createdDir = WorkDirManager.getInstance().initializeWorkDir(workDir, internalDirectoryName, false);",
          "119:     }",
          "121:     @Test",
          "122:     public void shouldFailIfWorkDirIsAFile() throws IOException {",
          "123:         File foo = tmpDir.newFile(\"foo\");",
          "124:         try {",
          "126:         } catch (IOException ex) {",
          "129:             return;",
          "130:         }",
          "132:     }",
          "134:     @Test",
          "",
          "[Removed Lines]",
          "110:         Assert.assertFalse(\"The \" + WorkDirManager.DirType.WORK_DIR + \" should not exist in the test\", workDir.exists());",
          "117:         assertThat(\"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\", createdDir.toFile(), equalTo(remotingDir));",
          "118:         Assert.assertTrue(\"Remoting \" + WorkDirManager.DirType.INTERNAL_DIR + \" should have been initialized\", remotingDir.exists());",
          "125:             WorkDirManager.getInstance().initializeWorkDir(foo, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "127:             assertThat(\"Wrong exception message\",",
          "128:                     ex.getMessage(), containsString(\"The specified \" + WorkDirManager.DirType.WORK_DIR + \" path points to a non-directory file\"));",
          "131:         Assert.fail(\"The \" + WorkDirManager.DirType.WORK_DIR + \" has been initialized, but it should fail due to the conflicting file\");",
          "",
          "[Added Lines]",
          "125:         Assert.assertFalse(",
          "126:                 \"The \" + WorkDirManager.DirType.WORK_DIR + \" should not exist in the test\", workDir.exists());",
          "133:         assertThat(",
          "134:                 \"The initialized \" + WorkDirManager.DirType.INTERNAL_DIR + \" differs from the expected one\",",
          "135:                 createdDir.toFile(),",
          "136:                 equalTo(remotingDir));",
          "137:         Assert.assertTrue(",
          "138:                 \"Remoting \" + WorkDirManager.DirType.INTERNAL_DIR + \" should have been initialized\",",
          "139:                 remotingDir.exists());",
          "146:             WorkDirManager.getInstance()",
          "147:                     .initializeWorkDir(foo, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "149:             assertThat(",
          "150:                     \"Wrong exception message\",",
          "151:                     ex.getMessage(),",
          "152:                     containsString(\"The specified \" + WorkDirManager.DirType.WORK_DIR",
          "153:                             + \" path points to a non-directory file\"));",
          "156:         Assert.fail(\"The \" + WorkDirManager.DirType.WORK_DIR",
          "157:                 + \" has been initialized, but it should fail due to the conflicting file\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180:     public void shouldFailToStartupIf_WorkDir_IsMissing_andRequired() throws Exception {",
          "181:         final File tmpDirFile = tmpDir.newFolder(\"foo\");",
          "182:         final File workDir = new File(tmpDirFile, \"just/a/long/non/existent/path\");",
          "185:         assertAllocationFailsForMissingDir(workDir, WorkDirManager.DirType.WORK_DIR);",
          "186:     }",
          "",
          "[Removed Lines]",
          "183:         Assert.assertFalse(\"The \" +  WorkDirManager.DirType.INTERNAL_DIR + \" should not exist in the test\", workDir.exists());",
          "",
          "[Added Lines]",
          "207:         Assert.assertFalse(",
          "208:                 \"The \" + WorkDirManager.DirType.INTERNAL_DIR + \" should not exist in the test\", workDir.exists());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "238:     @Test",
          "239:     public void shouldUseLoggingSettingsFromFileDefinedBySystemProperty() throws Exception {",
          "240:         final File loggingConfigFile = new File(tmpDir.getRoot(), \"julSettings.prop\");",
          "242:         try {",
          "243:             doTestLoggingConfig(loggingConfigFile, false);",
          "244:         } finally {",
          "",
          "[Removed Lines]",
          "241:         final String oldValue = System.setProperty(WorkDirManager.JUL_CONFIG_FILE_SYSTEM_PROPERTY_NAME, loggingConfigFile.getAbsolutePath());",
          "",
          "[Added Lines]",
          "266:         final String oldValue = System.setProperty(",
          "267:                 WorkDirManager.JUL_CONFIG_FILE_SYSTEM_PROPERTY_NAME, loggingConfigFile.getAbsolutePath());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "247:         }",
          "248:     }",
          "251:         final File workDir = tmpDir.newFolder(\"workDir\");",
          "252:         final File customLogDir = tmpDir.newFolder(\"mylogs\");",
          "254:         Properties p = new Properties();",
          "255:         p.setProperty(\"handlers\", \"java.util.logging.FileHandler\");",
          "257:         p.setProperty(\"java.util.logging.FileHandler.limit\", \"81920\");",
          "258:         p.setProperty(\"java.util.logging.FileHandler.count\", \"5\");",
          "",
          "[Removed Lines]",
          "250:     private void doTestLoggingConfig(File loggingConfigFile, boolean passToManager) throws IOException, AssertionError{",
          "256:         p.setProperty(\"java.util.logging.FileHandler.pattern\", customLogDir.getAbsolutePath() + File.separator  + \"mylog.log.%g\");",
          "",
          "[Added Lines]",
          "276:     private void doTestLoggingConfig(File loggingConfigFile, boolean passToManager) throws IOException, AssertionError {",
          "282:         p.setProperty(",
          "283:                 \"java.util.logging.FileHandler.pattern\",",
          "284:                 customLogDir.getAbsolutePath() + File.separator + \"mylog.log.%g\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "278:         assertExists(WorkDirManager.DirType.LOGS_DIR);",
          "279:         File defaultLog0 = new File(mngr.getLocation(WorkDirManager.DirType.LOGS_DIR), \"remoting.log.0\");",
          "281:                 defaultLog0.exists());",
          "",
          "[Removed Lines]",
          "280:         Assert.assertFalse(\"Log settings have been passed from the config file, the default log should not exist: \" + defaultLog0,",
          "",
          "[Added Lines]",
          "308:         Assert.assertFalse(",
          "309:                 \"Log settings have been passed from the config file, the default log should not exist: \" + defaultLog0,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "288:     }",
          "290:     private void assertFileLogsExist(File logsDir, String prefix, int logFilesNumber) {",
          "292:             File log = new File(logsDir, prefix + \".\" + i);",
          "293:             Assert.assertTrue(\"Log file should exist: \" + log, log.exists());",
          "294:         }",
          "",
          "[Removed Lines]",
          "291:         for (int i=0; i<logFilesNumber; ++i) {",
          "",
          "[Added Lines]",
          "320:         for (int i = 0; i < logFilesNumber; ++i) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "297:     private void assertAllocationFailsForMissingDir(File workDir, WorkDirManager.DirType expectedCheckFailure) {",
          "299:         try {",
          "301:         } catch (IOException ex) {",
          "303:                     containsString(\"The \" + expectedCheckFailure + \" is missing, but it is expected to exist:\"));",
          "304:             return;",
          "305:         }",
          "",
          "[Removed Lines]",
          "300:             WorkDirManager.getInstance().initializeWorkDir(workDir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), true);",
          "302:             assertThat(\"Unexpected exception message\", ex.getMessage(),",
          "",
          "[Added Lines]",
          "329:             WorkDirManager.getInstance()",
          "330:                     .initializeWorkDir(workDir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), true);",
          "332:             assertThat(",
          "333:                     \"Unexpected exception message\",",
          "334:                     ex.getMessage(),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "309:     private void assertAllocationFails(File workDir, String internalDirName) throws AssertionError {",
          "310:         try {",
          "311:             WorkDirManager.getInstance().initializeWorkDir(workDir, internalDirName, false);",
          "315:             return;",
          "316:         }",
          "318:     }",
          "320:     private void assertExists(@NonNull WorkDirManager.DirType type) throws AssertionError {",
          "",
          "[Removed Lines]",
          "312:         }  catch (IOException ex) {",
          "313:             assertThat(ex.getMessage(), containsString(String.format(\"Name of %s ('%s') is not compliant with the required format\",",
          "314:                     WorkDirManager.DirType.INTERNAL_DIR, internalDirName)));",
          "317:         Assert.fail(\"Initialization of WorkDirManager with invalid internal directory '\" + internalDirName + \"' should have failed\");",
          "",
          "[Added Lines]",
          "344:         } catch (IOException ex) {",
          "345:             assertThat(",
          "346:                     ex.getMessage(),",
          "347:                     containsString(String.format(",
          "348:                             \"Name of %s ('%s') is not compliant with the required format\",",
          "349:                             WorkDirManager.DirType.INTERNAL_DIR, internalDirName)));",
          "352:         Assert.fail(\"Initialization of WorkDirManager with invalid internal directory '\" + internalDirName",
          "353:                 + \"' should have failed\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "323:         Assert.assertTrue(\"Cannot find the \" + type + \" directory: \" + location, location.exists());",
          "324:     }",
          "327:         WorkDirManager instance = WorkDirManager.getInstance();",
          "328:         instance.disable(type);",
          "329:         instance.initializeWorkDir(workDir, \"remoting\", false);",
          "334:         File internalDir = instance.getLocation(WorkDirManager.DirType.INTERNAL_DIR);",
          "335:         File expectedDir = new File(internalDir, type.getDefaultLocation());",
          "336:         Assert.assertFalse(\"The logs directoy should not exist\", expectedDir.exists());",
          "337:     }",
          "341:         final File dir = tmpDir.newFolder(\"test-\" + type.getClass().getSimpleName() + \"-\" + flag);",
          "343:         boolean success = false;",
          "",
          "[Removed Lines]",
          "326:     private void assertDoesNotCreateDisabledDir(File workDir, WorkDirManager.DirType type) throws AssertionError, IOException {",
          "332:         assertThat(\"Directory \" + type + \" has been added to the cache. Expected WirkDirManager to ignore it\",",
          "333:                 instance.getLocation(type), nullValue());",
          "339:     private void verifyDirectoryFlag(WorkDirManager.DirType type, DirectoryFlag flag) throws IOException, AssertionError {",
          "340:         Assume.assumeThat(\"need to be running as a regular user for file permission checks to be meaningful\", System.getProperty(\"user.name\"), not(equalTo(\"root\")));",
          "",
          "[Added Lines]",
          "362:     private void assertDoesNotCreateDisabledDir(File workDir, WorkDirManager.DirType type)",
          "363:             throws AssertionError, IOException {",
          "369:         assertThat(",
          "370:                 \"Directory \" + type + \" has been added to the cache. Expected WirkDirManager to ignore it\",",
          "371:                 instance.getLocation(type),",
          "372:                 nullValue());",
          "378:     private void verifyDirectoryFlag(WorkDirManager.DirType type, DirectoryFlag flag)",
          "379:             throws IOException, AssertionError {",
          "380:         Assume.assumeThat(",
          "381:                 \"need to be running as a regular user for file permission checks to be meaningful\",",
          "382:                 System.getProperty(\"user.name\"),",
          "383:                 not(equalTo(\"root\")));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "358:         Assume.assumeTrue(String.format(\"Failed to modify flag %s of %s\", flag, dirToModify), success);",
          "360:         try {",
          "362:         } catch (IOException ex) {",
          "365:             return;",
          "366:         }",
          "367:         Assert.fail(\"The directory has been initialized, but it should fail since the target dir is \" + flag);",
          "",
          "[Removed Lines]",
          "361:             WorkDirManager.getInstance().initializeWorkDir(dir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "363:             assertThat(\"Wrong exception message for \" + flag,",
          "364:                     ex.getMessage(), containsString(\"The specified \" + type + \" should be fully accessible to the remoting executable\"));",
          "",
          "[Added Lines]",
          "404:             WorkDirManager.getInstance()",
          "405:                     .initializeWorkDir(dir, WorkDirManager.DirType.INTERNAL_DIR.getDefaultLocation(), false);",
          "407:             assertThat(",
          "408:                     \"Wrong exception message for \" + flag,",
          "409:                     ex.getMessage(),",
          "410:                     containsString(\"The specified \" + type + \" should be fully accessible to the remoting executable\"));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java||src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java -> src/test/java/org/jenkinsci/remoting/nio/FifoBufferTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: public class FifoBufferTest extends Assert {",
          "20:     @Test",
          "21:     public void readWrite() throws Exception {",
          "",
          "[Removed Lines]",
          "18:     FifoBuffer buf = new FifoBuffer(8,256);",
          "",
          "[Added Lines]",
          "18:     FifoBuffer buf = new FifoBuffer(8, 256);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:         byte[] b = new byte[16];",
          "27:         int r = buf.read(b);",
          "31:         assertEquals(-1, buf.readable());",
          "32:     }",
          "",
          "[Removed Lines]",
          "28:         assertEquals(r,10);",
          "29:         assertEquals(new String(b,0,r),TEN);",
          "",
          "[Added Lines]",
          "28:         assertEquals(r, 10);",
          "29:         assertEquals(new String(b, 0, r), TEN);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42:         int r = buf.send(ch);",
          "44:         assertEquals(TEN, baos.toString());",
          "",
          "[Removed Lines]",
          "43:         assertEquals(10,r);",
          "",
          "[Added Lines]",
          "43:         assertEquals(10, r);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "51:         buf.close();",
          "52:         assertEquals(-1, buf.readable());",
          "54:     }",
          "56:     @Test",
          "57:     public void nonBlockingWrite() throws Exception {",
          "58:         buf.setLimit(185);",
          "62:         }",
          "70:         byte[] b = new byte[5];",
          "71:         buf.read(b);",
          "75:     }",
          "77:     @Test",
          "78:     public void receive() throws Exception {",
          "80:             assertEquals(10, buf.receive(Channels.newChannel(bs(TEN))));",
          "81:         }",
          "",
          "[Removed Lines]",
          "53:         assertEquals(-1,buf.send(ch));",
          "60:         for (int i=0; i<18; i++) {",
          "61:             assertEquals(10,buf.writeNonBlock(bb(TEN)));",
          "63:         assertEquals(5,buf.writeNonBlock(bb(TEN)));",
          "66:         assertEquals(0,buf.writeNonBlock(bb(TEN)));",
          "67:         assertEquals(185,buf.readable());",
          "72:         assertEquals(FIVE,new String(b));",
          "74:         assertEquals(5,buf.writeNonBlock(bb(TEN)));",
          "79:         for (int i=0; i<25; i++) {",
          "",
          "[Added Lines]",
          "53:         assertEquals(-1, buf.send(ch));",
          "60:         for (int i = 0; i < 18; i++) {",
          "61:             assertEquals(10, buf.writeNonBlock(bb(TEN)));",
          "63:         assertEquals(5, buf.writeNonBlock(bb(TEN)));",
          "66:         assertEquals(0, buf.writeNonBlock(bb(TEN)));",
          "67:         assertEquals(185, buf.readable());",
          "72:         assertEquals(FIVE, new String(b));",
          "74:         assertEquals(5, buf.writeNonBlock(bb(TEN)));",
          "79:         for (int i = 0; i < 25; i++) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "89:         byte[] d = new byte[10];",
          "90:         assertEquals(4, ch.read(ByteBuffer.wrap(d)));",
          "93:     }",
          "95:     @Test",
          "96:     public void peek() throws Exception {",
          "98:             buf.write(b(TEN));",
          "101:             byte[] d = new byte[10];",
          "103:             assertEquals(TEN, new String(d));",
          "104:         }",
          "107:         byte[] d = new byte[10];",
          "108:         assertEquals(4, buf.peek(36, d));",
          "110:     }",
          "112:     private InputStream bs(String s) {",
          "",
          "[Removed Lines]",
          "92:         assertEquals(\"6789\", new String(d,0,4));",
          "97:         for (int i=0; i<4; i++)",
          "100:         for (int i=0; i<4; i++) {",
          "102:             assertEquals(10, buf.peek(i*10, d));",
          "109:         assertEquals(\"6789\", new String(d,0,4));",
          "",
          "[Added Lines]",
          "92:         assertEquals(\"6789\", new String(d, 0, 4));",
          "97:         for (int i = 0; i < 4; i++) {",
          "99:         }",
          "101:         for (int i = 0; i < 4; i++) {",
          "103:             assertEquals(10, buf.peek(i * 10, d));",
          "110:         assertEquals(\"6789\", new String(d, 0, 4));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/nio/Main.java||src/test/java/org/jenkinsci/remoting/nio/Main.java": [
          "File: src/test/java/org/jenkinsci/remoting/nio/Main.java -> src/test/java/org/jenkinsci/remoting/nio/Main.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: public class Main {",
          "41:     public static void main(String[] args) throws Exception {",
          "42:         testProcessSelection();",
          "",
          "[Removed Lines]",
          "18:         Non-blocking stream copier",
          "19:         --------------------------",
          "21:         Allow arbitrary pair of InputStream+OutputStream and pump them all just by using a single thread.",
          "23:         InputStream needs to be SelectableChannel or FileInputStream on Linux.",
          "24:         Now OutputStream, this is a bigger problem!",
          "25:             - SelectableChannel, such as another FileOutputStream or Socket is fine",
          "26:             - ProxyOutputStream, to send bits remotely. But this involves window support.",
          "27:               -> if ProxyOutputStream can't write, set the bytes aside and don't look for OP_READ",
          "28:                  in corresponding reader.",
          "29:               -> when window size becomes available, notify and act",
          "31:               -> but ProxyOutputStream is still a blocking write.",
          "34:        Pumping executors forking builds aren't too interesting. But ChannelReaderThread can",
          "35:        benefit from this.",
          "37:        Need an additional framing mechanism",
          "",
          "[Added Lines]",
          "18:        Non-blocking stream copier",
          "19:        --------------------------",
          "21:        Allow arbitrary pair of InputStream+OutputStream and pump them all just by using a single thread.",
          "23:        InputStream needs to be SelectableChannel or FileInputStream on Linux.",
          "24:        Now OutputStream, this is a bigger problem!",
          "25:            - SelectableChannel, such as another FileOutputStream or Socket is fine",
          "26:            - ProxyOutputStream, to send bits remotely. But this involves window support.",
          "27:              -> if ProxyOutputStream can't write, set the bytes aside and don't look for OP_READ",
          "28:                 in corresponding reader.",
          "29:              -> when window size becomes available, notify and act",
          "31:              -> but ProxyOutputStream is still a blocking write.",
          "34:       Pumping executors forking builds aren't too interesting. But ChannelReaderThread can",
          "35:       benefit from this.",
          "37:       Need an additional framing mechanism",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:         while (true) {",
          "63:             sel.select();",
          "64:             for (SelectionKey sk : sel.selectedKeys()) {",
          "68:                 ByteBuffer buf = ByteBuffer.allocate(1024);",
          "69:                 c.read(buf);",
          "",
          "[Removed Lines]",
          "65:                 System.out.println(\"==== \"+sk.attachment());",
          "66:                 SocketChannel c = (SocketChannel)sk.channel();",
          "",
          "[Added Lines]",
          "65:                 System.out.println(\"==== \" + sk.attachment());",
          "66:                 SocketChannel c = (SocketChannel) sk.channel();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:             if (i instanceof FilterInputStream) {",
          "79:                 Field $in = FilterInputStream.class.getDeclaredField(\"in\");",
          "80:                 $in.setAccessible(true);",
          "82:                 continue;",
          "83:             }",
          "84:             if (i instanceof FileInputStream) {",
          "85:                 return (FileInputStream) i;",
          "86:             }",
          "88:         }",
          "89:     }",
          "",
          "[Removed Lines]",
          "81:                 i = (InputStream)$in.get(i);",
          "87:             return null;    // unknown type",
          "",
          "[Added Lines]",
          "81:                 i = (InputStream) $in.get(i);",
          "87:             return null; // unknown type",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java||src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java": [
          "File: src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java -> src/test/java/org/jenkinsci/remoting/nio/SocketClientMain.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: public class SocketClientMain {",
          "15:     public static void main(String[] args) throws Exception {",
          "16:         final ExecutorService es = Executors.newCachedThreadPool();",
          "18:         LOGGER.info(\"Cnonected\");",
          "19:         Channel ch = new ChannelBuilder(\"client\", es)",
          "20:                 .withHeaderStream(new FlushEveryByteStream(System.out))",
          "",
          "[Removed Lines]",
          "17:         Socket s = new Socket(\"localhost\",9953);",
          "",
          "[Added Lines]",
          "17:         Socket s = new Socket(\"localhost\", 9953);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:                 .build(s);",
          "23:         LOGGER.info(\"Established.\");",
          "27:         ch.close();",
          "28:         ch.join();",
          "",
          "[Removed Lines]",
          "25:         LOGGER.info(\"Got \"+echo(ch,\"Hello!\"));",
          "",
          "[Added Lines]",
          "25:         LOGGER.info(\"Got \" + echo(ch, \"Hello!\"));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java||src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java": [
          "File: src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java -> src/test/java/org/jenkinsci/remoting/nio/SocketServerMain.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:                         }",
          "45:                     });",
          "46:                 } catch (IOException e) {",
          "48:                 }",
          "49:             }",
          "50:         };",
          "",
          "[Removed Lines]",
          "47:                     LOGGER.log(Level.WARNING, \"Failed to accept a soccket\",e);",
          "",
          "[Added Lines]",
          "47:                     LOGGER.log(Level.WARNING, \"Failed to accept a soccket\", e);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java -> src/test/java/org/jenkinsci/remoting/org/apache/commons/net/util/SubnetUtilsTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:         assertEquals(-1062731775, info.asInteger(\"192.168.0.1\"));",
          "46:         assertThrows(IllegalArgumentException.class, () -> info.asInteger(\"bad\"));",
          "49:     }",
          "51:     public void testAddressIllegalArgument() {",
          "",
          "[Removed Lines]",
          "48:         assertArrayEquals(new String[] { \"192.168.0.1\", \"192.168.0.2\", \"192.168.0.3\", \"192.168.0.4\", \"192.168.0.5\", \"192.168.0.6\" }, info.getAllAddresses());",
          "",
          "[Added Lines]",
          "48:         assertArrayEquals(",
          "49:                 new String[] {\"192.168.0.1\", \"192.168.0.2\", \"192.168.0.3\", \"192.168.0.4\", \"192.168.0.5\", \"192.168.0.6\"},",
          "50:                 info.getAllAddresses());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "311:     public void testParseSimpleNetmask() {",
          "312:         final String address = \"192.168.0.1\";",
          "323:         for (int i = 0; i < masks.length; ++i) {",
          "324:             final SubnetUtils utils = new SubnetUtils(address, masks[i]);",
          "",
          "[Removed Lines]",
          "313:         final String[] masks = { \"255.0.0.0\", \"255.255.0.0\", \"255.255.255.0\", \"255.255.255.248\" };",
          "314:         final String[] bcastAddresses = { \"192.255.255.255\", \"192.168.255.255\", \"192.168.0.255\", \"192.168.0.7\" };",
          "315:         final String[] lowAddresses = { \"192.0.0.1\", \"192.168.0.1\", \"192.168.0.1\", \"192.168.0.1\" };",
          "316:         final String[] highAddresses = { \"192.255.255.254\", \"192.168.255.254\", \"192.168.0.254\", \"192.168.0.6\" };",
          "317:         final String[] nextAddresses = { \"192.168.0.2\", \"192.168.0.2\", \"192.168.0.2\", \"192.168.0.2\" };",
          "318:         final String[] previousAddresses = { \"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\" };",
          "319:         final String[] networkAddresses = { \"192.0.0.0\", \"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\" };",
          "320:         final String[] cidrSignatures = { \"192.168.0.1/8\", \"192.168.0.1/16\", \"192.168.0.1/24\", \"192.168.0.1/29\" };",
          "321:         final int[] usableAddresses = { 16777214, 65534, 254, 6 };",
          "",
          "[Added Lines]",
          "314:         final String[] masks = {\"255.0.0.0\", \"255.255.0.0\", \"255.255.255.0\", \"255.255.255.248\"};",
          "315:         final String[] bcastAddresses = {\"192.255.255.255\", \"192.168.255.255\", \"192.168.0.255\", \"192.168.0.7\"};",
          "316:         final String[] lowAddresses = {\"192.0.0.1\", \"192.168.0.1\", \"192.168.0.1\", \"192.168.0.1\"};",
          "317:         final String[] highAddresses = {\"192.255.255.254\", \"192.168.255.254\", \"192.168.0.254\", \"192.168.0.6\"};",
          "318:         final String[] nextAddresses = {\"192.168.0.2\", \"192.168.0.2\", \"192.168.0.2\", \"192.168.0.2\"};",
          "319:         final String[] previousAddresses = {\"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\"};",
          "320:         final String[] networkAddresses = {\"192.0.0.0\", \"192.168.0.0\", \"192.168.0.0\", \"192.168.0.0\"};",
          "321:         final String[] cidrSignatures = {\"192.168.0.1/8\", \"192.168.0.1/16\", \"192.168.0.1/24\", \"192.168.0.1/29\"};",
          "322:         final int[] usableAddresses = {16777214, 65534, 254, 6};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:     public void testParseSimpleNetmaskExclusive() {",
          "339:         final String address = \"192.168.15.7\";",
          "349:         for (int i = 0; i < masks.length; ++i) {",
          "",
          "[Removed Lines]",
          "340:         final String[] masks = { \"255.255.255.252\", \"255.255.255.254\", \"255.255.255.255\" };",
          "341:         final String[] bcast = { \"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\" };",
          "342:         final String[] netwk = { \"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\" };",
          "343:         final String[] lowAd = { \"192.168.15.5\", \"0.0.0.0\", \"0.0.0.0\" };",
          "344:         final String[] highA = { \"192.168.15.6\", \"0.0.0.0\", \"0.0.0.0\" };",
          "345:         final String[] cidrS = { \"192.168.15.7/30\", \"192.168.15.7/31\", \"192.168.15.7/32\" };",
          "346:         final int[] usableAd = { 2, 0, 0 };",
          "",
          "[Added Lines]",
          "341:         final String[] masks = {\"255.255.255.252\", \"255.255.255.254\", \"255.255.255.255\"};",
          "342:         final String[] bcast = {\"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\"};",
          "343:         final String[] netwk = {\"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\"};",
          "344:         final String[] lowAd = {\"192.168.15.5\", \"0.0.0.0\", \"0.0.0.0\"};",
          "345:         final String[] highA = {\"192.168.15.6\", \"0.0.0.0\", \"0.0.0.0\"};",
          "346:         final String[] cidrS = {\"192.168.15.7/30\", \"192.168.15.7/31\", \"192.168.15.7/32\"};",
          "347:         final int[] usableAd = {2, 0, 0};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:     public void testParseSimpleNetmaskInclusive() {",
          "363:         final String address = \"192.168.15.7\";",
          "372:         for (int i = 0; i < masks.length; ++i) {",
          "373:             final SubnetUtils utils = new SubnetUtils(address, masks[i]);",
          "",
          "[Removed Lines]",
          "364:         final String[] masks = { \"255.255.255.252\", \"255.255.255.254\", \"255.255.255.255\" };",
          "365:         final String[] bcast = { \"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\" };",
          "366:         final String[] netwk = { \"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\" };",
          "367:         final String[] lowAd = { \"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\" };",
          "368:         final String[] highA = { \"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\" };",
          "369:         final String[] cidrS = { \"192.168.15.7/30\", \"192.168.15.7/31\", \"192.168.15.7/32\" };",
          "370:         final int[] usableAd = { 4, 2, 1 };",
          "",
          "[Added Lines]",
          "365:         final String[] masks = {\"255.255.255.252\", \"255.255.255.254\", \"255.255.255.255\"};",
          "366:         final String[] bcast = {\"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\"};",
          "367:         final String[] netwk = {\"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\"};",
          "368:         final String[] lowAd = {\"192.168.15.4\", \"192.168.15.6\", \"192.168.15.7\"};",
          "369:         final String[] highA = {\"192.168.15.7\", \"192.168.15.7\", \"192.168.15.7\"};",
          "370:         final String[] cidrS = {\"192.168.15.7/30\", \"192.168.15.7/31\", \"192.168.15.7/32\"};",
          "371:         final int[] usableAd = {4, 2, 1};",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java -> src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/InetAddressValidatorTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:     public void testInetAddressesFromTheWild() {",
          "51:     }",
          "53:     public void testVALIDATOR_335() {",
          "55:     }",
          "57:     public void testVALIDATOR_419() {",
          "",
          "[Removed Lines]",
          "47:         assertTrue(\"www.apache.org IP should be valid\",       validator.isValid(\"140.211.11.130\"));",
          "48:         assertTrue(\"www.l.google.com IP should be valid\",     validator.isValid(\"72.14.253.103\"));",
          "49:         assertTrue(\"fsf.org IP should be valid\",              validator.isValid(\"199.232.41.5\"));",
          "50:         assertTrue(\"appscs.ign.com IP should be valid\",       validator.isValid(\"216.35.123.87\"));",
          "54:         assertTrue(\"2001:0438:FFFE:0000:0000:0000:0000:0A35 should be valid\",       validator.isValid(\"2001:0438:FFFE:0000:0000:0000:0000:0A35\"));",
          "",
          "[Added Lines]",
          "47:         assertTrue(\"www.apache.org IP should be valid\", validator.isValid(\"140.211.11.130\"));",
          "48:         assertTrue(\"www.l.google.com IP should be valid\", validator.isValid(\"72.14.253.103\"));",
          "49:         assertTrue(\"fsf.org IP should be valid\", validator.isValid(\"199.232.41.5\"));",
          "50:         assertTrue(\"appscs.ign.com IP should be valid\", validator.isValid(\"216.35.123.87\"));",
          "54:         assertTrue(",
          "55:                 \"2001:0438:FFFE:0000:0000:0000:0000:0A35 should be valid\",",
          "56:                 validator.isValid(\"2001:0438:FFFE:0000:0000:0000:0000:0A35\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:     public void testVALIDATOR_445() {",
          "79:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876\",",
          "80:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/123\",",
          "81:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0\",",
          "82:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%0\",",
          "83:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abcdefgh\",",
          "86:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/129\", // too big",
          "87:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/-0\", // sign not allowed",
          "88:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/+0\", // sign not allowed",
          "",
          "[Removed Lines]",
          "78:         String [] valid = {",
          "84:             };",
          "85:         String [] invalid = {",
          "",
          "[Added Lines]",
          "80:         String[] valid = {",
          "86:         };",
          "87:         String[] invalid = {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0%0\", // /bits before %node-id",
          "91:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc defgh\", // space in node id",
          "92:             \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc%defgh\", // '%' in node id",
          "94:         for (String item : valid) {",
          "95:             assertTrue(String.format(\"%s should be valid\", item), validator.isValid(item));",
          "96:         }",
          "",
          "[Removed Lines]",
          "93:             };",
          "",
          "[Added Lines]",
          "95:         };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "105:     public void testInetAddressesByClass() {",
          "120:     }",
          "125:     public void testReservedInetAddresses() {",
          "128:     }",
          "133:     public void testBrokenInetAddresses() {",
          "137:         assertFalse(\"IP with leading zeroes should be invalid\", validator.isValid(\"124.14.32.01\"));",
          "140:         assertFalse(\"IP empty string should be invalid\", validator.isValidInet6Address(\"\")); // empty string",
          "141:     }",
          "",
          "[Removed Lines]",
          "106:         assertTrue(\"class A IP should be valid\",              validator.isValid(\"24.25.231.12\"));",
          "107:         assertFalse(\"illegal class A IP should be invalid\",   validator.isValid(\"2.41.32.324\"));",
          "109:         assertTrue(\"class B IP should be valid\",              validator.isValid(\"135.14.44.12\"));",
          "110:         assertFalse(\"illegal class B IP should be invalid\",   validator.isValid(\"154.123.441.123\"));",
          "112:         assertTrue(\"class C IP should be valid\",              validator.isValid(\"213.25.224.32\"));",
          "113:         assertFalse(\"illegal class C IP should be invalid\",   validator.isValid(\"201.543.23.11\"));",
          "115:         assertTrue(\"class D IP should be valid\",              validator.isValid(\"229.35.159.6\"));",
          "116:         assertFalse(\"illegal class D IP should be invalid\",   validator.isValid(\"231.54.11.987\"));",
          "118:         assertTrue(\"class E IP should be valid\",              validator.isValid(\"248.85.24.92\"));",
          "119:         assertFalse(\"illegal class E IP should be invalid\",   validator.isValid(\"250.21.323.48\"));",
          "126:         assertTrue(\"localhost IP should be valid\",            validator.isValid(\"127.0.0.1\"));",
          "127:         assertTrue(\"broadcast IP should be valid\",            validator.isValid(\"255.255.255.255\"));",
          "134:         assertFalse(\"IP with characters should be invalid\",     validator.isValid(\"124.14.32.abc\"));",
          "138:         assertFalse(\"IP with three groups should be invalid\",   validator.isValid(\"23.64.12\"));",
          "139:         assertFalse(\"IP with five groups should be invalid\",    validator.isValid(\"26.34.23.77.234\"));",
          "",
          "[Added Lines]",
          "108:         assertTrue(\"class A IP should be valid\", validator.isValid(\"24.25.231.12\"));",
          "109:         assertFalse(\"illegal class A IP should be invalid\", validator.isValid(\"2.41.32.324\"));",
          "111:         assertTrue(\"class B IP should be valid\", validator.isValid(\"135.14.44.12\"));",
          "112:         assertFalse(\"illegal class B IP should be invalid\", validator.isValid(\"154.123.441.123\"));",
          "114:         assertTrue(\"class C IP should be valid\", validator.isValid(\"213.25.224.32\"));",
          "115:         assertFalse(\"illegal class C IP should be invalid\", validator.isValid(\"201.543.23.11\"));",
          "117:         assertTrue(\"class D IP should be valid\", validator.isValid(\"229.35.159.6\"));",
          "118:         assertFalse(\"illegal class D IP should be invalid\", validator.isValid(\"231.54.11.987\"));",
          "120:         assertTrue(\"class E IP should be valid\", validator.isValid(\"248.85.24.92\"));",
          "121:         assertFalse(\"illegal class E IP should be invalid\", validator.isValid(\"250.21.323.48\"));",
          "128:         assertTrue(\"localhost IP should be valid\", validator.isValid(\"127.0.0.1\"));",
          "129:         assertTrue(\"broadcast IP should be valid\", validator.isValid(\"255.255.255.255\"));",
          "136:         assertFalse(\"IP with characters should be invalid\", validator.isValid(\"124.14.32.abc\"));",
          "140:         assertFalse(\"IP with three groups should be invalid\", validator.isValid(\"23.64.12\"));",
          "141:         assertFalse(\"IP with five groups should be invalid\", validator.isValid(\"26.34.23.77.234\"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "152:         assertFalse(\"IPV6 empty string should be invalid\", validator.isValidInet6Address(\"\")); // empty string",
          "177:         assertTrue(\"IPV6 2::10 should be valid\", validator.isValidInet6Address(\"2::10\"));",
          "178:         assertTrue(\"IPV6 ff02::1 should be valid\", validator.isValidInet6Address(\"ff02::1\"));",
          "179:         assertTrue(\"IPV6 fe80:: should be valid\", validator.isValidInet6Address(\"fe80::\"));",
          "",
          "[Removed Lines]",
          "153:         assertTrue(\"IPV6 ::1 should be valid\", validator.isValidInet6Address(\"::1\")); // loopback, compressed, non-routable",
          "154:         assertTrue(\"IPV6 :: should be valid\", validator.isValidInet6Address(\"::\")); // unspecified, compressed, non-routable",
          "155:         assertTrue(\"IPV6 0:0:0:0:0:0:0:1 should be valid\", validator.isValidInet6Address(\"0:0:0:0:0:0:0:1\")); // loopback, full",
          "156:         assertTrue(\"IPV6 0:0:0:0:0:0:0:0 should be valid\", validator.isValidInet6Address(\"0:0:0:0:0:0:0:0\")); // unspecified, full",
          "157:         assertTrue(\"IPV6 2001:DB8:0:0:8:800:200C:417A should be valid\", validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A\")); // unicast, full",
          "158:         assertTrue(\"IPV6 FF01:0:0:0:0:0:0:101 should be valid\", validator.isValidInet6Address(\"FF01:0:0:0:0:0:0:101\")); // multicast, full",
          "159:         assertTrue(\"IPV6 2001:DB8::8:800:200C:417A should be valid\", validator.isValidInet6Address(\"2001:DB8::8:800:200C:417A\")); // unicast, compressed",
          "160:         assertTrue(\"IPV6 FF01::101 should be valid\", validator.isValidInet6Address(\"FF01::101\")); // multicast, compressed",
          "161:         assertFalse(\"IPV6 2001:DB8:0:0:8:800:200C:417A:221 should be invalid\", validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A:221\")); // unicast, full",
          "162:         assertFalse(\"IPV6 FF01::101::2 should be invalid\", validator.isValidInet6Address(\"FF01::101::2\")); // multicast, compressed",
          "163:         assertTrue(\"IPV6 fe80::217:f2ff:fe07:ed62 should be valid\", validator.isValidInet6Address(\"fe80::217:f2ff:fe07:ed62\"));",
          "164:         assertTrue(\"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 should be valid\", validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876\"));",
          "165:         assertTrue(\"IPV6 3ffe:0b00:0000:0000:0001:0000:0000:000a should be valid\", validator.isValidInet6Address(\"3ffe:0b00:0000:0000:0001:0000:0000:000a\"));",
          "166:         assertTrue(\"IPV6 FF02:0000:0000:0000:0000:0000:0000:0001 should be valid\", validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0001\"));",
          "167:         assertTrue(\"IPV6 0000:0000:0000:0000:0000:0000:0000:0001 should be valid\", validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0001\"));",
          "168:         assertTrue(\"IPV6 0000:0000:0000:0000:0000:0000:0000:0000 should be valid\", validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0000\"));",
          "169:         assertFalse(\"IPV6 02001:0000:1234:0000:0000:C1C0:ABCD:0876 should be invalid\", validator.isValidInet6Address(\"02001:0000:1234:0000:0000:C1C0:ABCD:0876\")); // extra 0 not allowed!",
          "170:         assertFalse(\"IPV6 2001:0000:1234:0000:00001:C1C0:ABCD:0876 should be invalid\", validator.isValidInet6Address(\"2001:0000:1234:0000:00001:C1C0:ABCD:0876\")); // extra 0 not allowed!",
          "171:         assertFalse(\"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 0 should be invalid\", validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876 0\")); // junk after valid address",
          "172:         assertFalse(\"IPV6 2001:0000:1234: 0000:0000:C1C0:ABCD:0876 should be invalid\", validator.isValidInet6Address(\"2001:0000:1234: 0000:0000:C1C0:ABCD:0876\")); // internal space",
          "173:         assertFalse(\"IPV6 3ffe:0b00:0000:0001:0000:0000:000a should be invalid\", validator.isValidInet6Address(\"3ffe:0b00:0000:0001:0000:0000:000a\")); // seven segments",
          "174:         assertFalse(\"IPV6 FF02:0000:0000:0000:0000:0000:0000:0000:0001 should be invalid\", validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0000:0001\")); // nine segments",
          "175:         assertFalse(\"IPV6 3ffe:b00::1::a should be invalid\", validator.isValidInet6Address(\"3ffe:b00::1::a\")); // double \"::\"",
          "176:         assertFalse(\"IPV6 ::1111:2222:3333:4444:5555:6666:: should be invalid\", validator.isValidInet6Address(\"::1111:2222:3333:4444:5555:6666::\")); // double \"::\"",
          "",
          "[Added Lines]",
          "155:         assertTrue(",
          "156:                 \"IPV6 ::1 should be valid\", validator.isValidInet6Address(\"::1\")); // loopback, compressed, non-routable",
          "157:         assertTrue(",
          "158:                 \"IPV6 :: should be valid\",",
          "159:                 validator.isValidInet6Address(\"::\")); // unspecified, compressed, non-routable",
          "160:         assertTrue(",
          "161:                 \"IPV6 0:0:0:0:0:0:0:1 should be valid\",",
          "162:                 validator.isValidInet6Address(\"0:0:0:0:0:0:0:1\")); // loopback, full",
          "163:         assertTrue(",
          "164:                 \"IPV6 0:0:0:0:0:0:0:0 should be valid\",",
          "165:                 validator.isValidInet6Address(\"0:0:0:0:0:0:0:0\")); // unspecified, full",
          "166:         assertTrue(",
          "167:                 \"IPV6 2001:DB8:0:0:8:800:200C:417A should be valid\",",
          "168:                 validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A\")); // unicast, full",
          "169:         assertTrue(",
          "170:                 \"IPV6 FF01:0:0:0:0:0:0:101 should be valid\",",
          "171:                 validator.isValidInet6Address(\"FF01:0:0:0:0:0:0:101\")); // multicast, full",
          "172:         assertTrue(",
          "173:                 \"IPV6 2001:DB8::8:800:200C:417A should be valid\",",
          "174:                 validator.isValidInet6Address(\"2001:DB8::8:800:200C:417A\")); // unicast, compressed",
          "175:         assertTrue(",
          "176:                 \"IPV6 FF01::101 should be valid\", validator.isValidInet6Address(\"FF01::101\")); // multicast, compressed",
          "177:         assertFalse(",
          "178:                 \"IPV6 2001:DB8:0:0:8:800:200C:417A:221 should be invalid\",",
          "179:                 validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A:221\")); // unicast, full",
          "180:         assertFalse(",
          "181:                 \"IPV6 FF01::101::2 should be invalid\",",
          "182:                 validator.isValidInet6Address(\"FF01::101::2\")); // multicast, compressed",
          "183:         assertTrue(",
          "184:                 \"IPV6 fe80::217:f2ff:fe07:ed62 should be valid\",",
          "185:                 validator.isValidInet6Address(\"fe80::217:f2ff:fe07:ed62\"));",
          "186:         assertTrue(",
          "187:                 \"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 should be valid\",",
          "188:                 validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876\"));",
          "189:         assertTrue(",
          "190:                 \"IPV6 3ffe:0b00:0000:0000:0001:0000:0000:000a should be valid\",",
          "191:                 validator.isValidInet6Address(\"3ffe:0b00:0000:0000:0001:0000:0000:000a\"));",
          "192:         assertTrue(",
          "193:                 \"IPV6 FF02:0000:0000:0000:0000:0000:0000:0001 should be valid\",",
          "194:                 validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0001\"));",
          "195:         assertTrue(",
          "196:                 \"IPV6 0000:0000:0000:0000:0000:0000:0000:0001 should be valid\",",
          "197:                 validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0001\"));",
          "198:         assertTrue(",
          "199:                 \"IPV6 0000:0000:0000:0000:0000:0000:0000:0000 should be valid\",",
          "200:                 validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0000\"));",
          "201:         assertFalse(",
          "202:                 \"IPV6 02001:0000:1234:0000:0000:C1C0:ABCD:0876 should be invalid\",",
          "203:                 validator.isValidInet6Address(\"02001:0000:1234:0000:0000:C1C0:ABCD:0876\")); // extra 0 not allowed!",
          "204:         assertFalse(",
          "205:                 \"IPV6 2001:0000:1234:0000:00001:C1C0:ABCD:0876 should be invalid\",",
          "206:                 validator.isValidInet6Address(\"2001:0000:1234:0000:00001:C1C0:ABCD:0876\")); // extra 0 not allowed!",
          "207:         assertFalse(",
          "208:                 \"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 0 should be invalid\",",
          "209:                 validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876 0\")); // junk after valid address",
          "210:         assertFalse(",
          "211:                 \"IPV6 2001:0000:1234: 0000:0000:C1C0:ABCD:0876 should be invalid\",",
          "212:                 validator.isValidInet6Address(\"2001:0000:1234: 0000:0000:C1C0:ABCD:0876\")); // internal space",
          "213:         assertFalse(",
          "214:                 \"IPV6 3ffe:0b00:0000:0001:0000:0000:000a should be invalid\",",
          "215:                 validator.isValidInet6Address(\"3ffe:0b00:0000:0001:0000:0000:000a\")); // seven segments",
          "216:         assertFalse(",
          "217:                 \"IPV6 FF02:0000:0000:0000:0000:0000:0000:0000:0001 should be invalid\",",
          "218:                 validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0000:0001\")); // nine segments",
          "219:         assertFalse(",
          "220:                 \"IPV6 3ffe:b00::1::a should be invalid\",",
          "221:                 validator.isValidInet6Address(\"3ffe:b00::1::a\")); // double \"::\"",
          "222:         assertFalse(",
          "223:                 \"IPV6 ::1111:2222:3333:4444:5555:6666:: should be invalid\",",
          "224:                 validator.isValidInet6Address(\"::1111:2222:3333:4444:5555:6666::\")); // double \"::\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "207:         assertTrue(\"IPV6 1:2:: should be valid\", validator.isValidInet6Address(\"1:2::\"));",
          "208:         assertTrue(\"IPV6 1:: should be valid\", validator.isValidInet6Address(\"1::\"));",
          "209:         assertTrue(\"IPV6 1:2:3:4:5::7:8 should be valid\", validator.isValidInet6Address(\"1:2:3:4:5::7:8\"));",
          "211:         assertFalse(\"IPV6 12345::6:7:8 should be invalid\", validator.isValidInet6Address(\"12345::6:7:8\"));",
          "212:         assertTrue(\"IPV6 1:2:3:4::7:8 should be valid\", validator.isValidInet6Address(\"1:2:3:4::7:8\"));",
          "213:         assertTrue(\"IPV6 1:2:3::7:8 should be valid\", validator.isValidInet6Address(\"1:2:3::7:8\"));",
          "",
          "[Removed Lines]",
          "210:         assertFalse(\"IPV6 1:2:3::4:5::7:8 should be invalid\", validator.isValidInet6Address(\"1:2:3::4:5::7:8\")); // Double \"::\"",
          "",
          "[Added Lines]",
          "258:         assertFalse(",
          "259:                 \"IPV6 1:2:3::4:5::7:8 should be invalid\",",
          "260:                 validator.isValidInet6Address(\"1:2:3::4:5::7:8\")); // Double \"::\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "239:         assertFalse(\"IPV6 1::5:1.900.3.4 should be invalid\", validator.isValidInet6Address(\"1::5:1.900.3.4\"));",
          "240:         assertFalse(\"IPV6 1::5:1.2.900.4 should be invalid\", validator.isValidInet6Address(\"1::5:1.2.900.4\"));",
          "241:         assertFalse(\"IPV6 1::5:1.2.3.900 should be invalid\", validator.isValidInet6Address(\"1::5:1.2.3.900\"));",
          "243:         assertFalse(\"IPV6 1::5:3000.30.30.30 should be invalid\", validator.isValidInet6Address(\"1::5:3000.30.30.30\"));",
          "244:         assertFalse(\"IPV6 1::400.2.3.4 should be invalid\", validator.isValidInet6Address(\"1::400.2.3.4\"));",
          "245:         assertFalse(\"IPV6 1::260.2.3.4 should be invalid\", validator.isValidInet6Address(\"1::260.2.3.4\"));",
          "",
          "[Removed Lines]",
          "242:         assertFalse(\"IPV6 1::5:300.300.300.300 should be invalid\", validator.isValidInet6Address(\"1::5:300.300.300.300\"));",
          "",
          "[Added Lines]",
          "292:         assertFalse(",
          "293:                 \"IPV6 1::5:300.300.300.300 should be invalid\", validator.isValidInet6Address(\"1::5:300.300.300.300\"));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "273:         assertFalse(\"IPV6 ::1.2.3.900 should be invalid\", validator.isValidInet6Address(\"::1.2.3.900\"));",
          "274:         assertFalse(\"IPV6 ::300.300.300.300 should be invalid\", validator.isValidInet6Address(\"::300.300.300.300\"));",
          "275:         assertFalse(\"IPV6 ::3000.30.30.30 should be invalid\", validator.isValidInet6Address(\"::3000.30.30.30\"));",
          "277:         assertTrue(\"IPV6 ::ffff:192.168.1.26 should be valid\", validator.isValidInet6Address(\"::ffff:192.168.1.26\"));",
          "280:         assertTrue(\"IPV6 ::ffff:192.168.1.1 should be valid\", validator.isValidInet6Address(\"::ffff:192.168.1.1\"));",
          "287:         assertTrue(\"IPV6 ::ffff:12.34.56.78 should be valid\", validator.isValidInet6Address(\"::ffff:12.34.56.78\"));",
          "288:         assertFalse(\"IPV6 ::ffff:2.3.4 should be invalid\", validator.isValidInet6Address(\"::ffff:2.3.4\"));",
          "289:         assertFalse(\"IPV6 ::ffff:257.1.2.3 should be invalid\", validator.isValidInet6Address(\"::ffff:257.1.2.3\"));",
          "290:         assertFalse(\"IPV6 1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1.2.3.4\"));",
          "294:         assertFalse(\"IPV6 1.2.3.4:1111::5555 should be invalid\", validator.isValidInet6Address(\"1.2.3.4:1111::5555\"));",
          "295:         assertFalse(\"IPV6 1.2.3.4::5555 should be invalid\", validator.isValidInet6Address(\"1.2.3.4::5555\"));",
          "296:         assertFalse(\"IPV6 1.2.3.4:: should be invalid\", validator.isValidInet6Address(\"1.2.3.4::\"));",
          "309:         assertFalse(\"IPV6 : should be invalid\", validator.isValidInet6Address(\":\"));",
          "310:         assertTrue(\"IPV6 ::ffff:c000:280 should be valid\", validator.isValidInet6Address(\"::ffff:c000:280\"));",
          "313:         assertFalse(\"IPV6 1111:2222::5555: should be invalid\", validator.isValidInet6Address(\"1111:2222::5555:\"));",
          "314:         assertFalse(\"IPV6 1111::5555: should be invalid\", validator.isValidInet6Address(\"1111::5555:\"));",
          "315:         assertFalse(\"IPV6 ::5555: should be invalid\", validator.isValidInet6Address(\"::5555:\"));",
          "316:         assertFalse(\"IPV6 ::: should be invalid\", validator.isValidInet6Address(\":::\"));",
          "317:         assertFalse(\"IPV6 1111: should be invalid\", validator.isValidInet6Address(\"1111:\"));",
          "320:         assertFalse(\"IPV6 :1111:2222::5555 should be invalid\", validator.isValidInet6Address(\":1111:2222::5555\"));",
          "321:         assertFalse(\"IPV6 :1111::5555 should be invalid\", validator.isValidInet6Address(\":1111::5555\"));",
          "322:         assertFalse(\"IPV6 :::5555 should be invalid\", validator.isValidInet6Address(\":::5555\"));",
          "330:         assertTrue(\"IPV6 2001:0db8::1428:57ab should be valid\", validator.isValidInet6Address(\"2001:0db8::1428:57ab\"));",
          "331:         assertTrue(\"IPV6 2001:db8::1428:57ab should be valid\", validator.isValidInet6Address(\"2001:db8::1428:57ab\"));",
          "332:         assertTrue(\"IPV6 ::ffff:0c22:384e should be valid\", validator.isValidInet6Address(\"::ffff:0c22:384e\"));",
          "335:         assertTrue(\"IPV6 2001:db8:a::123 should be valid\", validator.isValidInet6Address(\"2001:db8:a::123\"));",
          "336:         assertFalse(\"IPV6 123 should be invalid\", validator.isValidInet6Address(\"123\"));",
          "337:         assertFalse(\"IPV6 ldkfj should be invalid\", validator.isValidInet6Address(\"ldkfj\"));",
          "338:         assertFalse(\"IPV6 2001::FFD3::57ab should be invalid\", validator.isValidInet6Address(\"2001::FFD3::57ab\"));",
          "341:         assertFalse(\"IPV6 1:2:3:4:5:6:7:8:9 should be invalid\", validator.isValidInet6Address(\"1:2:3:4:5:6:7:8:9\"));",
          "342:         assertFalse(\"IPV6 1::2::3 should be invalid\", validator.isValidInet6Address(\"1::2::3\"));",
          "343:         assertFalse(\"IPV6 1:::3:4:5 should be invalid\", validator.isValidInet6Address(\"1:::3:4:5\"));",
          "344:         assertFalse(\"IPV6 1:2:3::4:5:6:7:8:9 should be invalid\", validator.isValidInet6Address(\"1:2:3::4:5:6:7:8:9\"));",
          "350:         assertTrue(\"IPV6 1111:2222:3333:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333::\"));",
          "351:         assertTrue(\"IPV6 1111:2222:: should be valid\", validator.isValidInet6Address(\"1111:2222::\"));",
          "352:         assertTrue(\"IPV6 1111:: should be valid\", validator.isValidInet6Address(\"1111::\"));",
          "356:         assertTrue(\"IPV6 1111:2222:3333::8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::8888\"));",
          "357:         assertTrue(\"IPV6 1111:2222::8888 should be valid\", validator.isValidInet6Address(\"1111:2222::8888\"));",
          "358:         assertTrue(\"IPV6 1111::8888 should be valid\", validator.isValidInet6Address(\"1111::8888\"));",
          "359:         assertTrue(\"IPV6 ::8888 should be valid\", validator.isValidInet6Address(\"::8888\"));",
          "363:         assertTrue(\"IPV6 1111:2222::7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222::7777:8888\"));",
          "364:         assertTrue(\"IPV6 1111::7777:8888 should be valid\", validator.isValidInet6Address(\"1111::7777:8888\"));",
          "365:         assertTrue(\"IPV6 ::7777:8888 should be valid\", validator.isValidInet6Address(\"::7777:8888\"));",
          "369:         assertTrue(\"IPV6 1111::6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111::6666:7777:8888\"));",
          "370:         assertTrue(\"IPV6 ::6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::6666:7777:8888\"));",
          "387:         assertTrue(\"IPV6 ::123.123.123.123 should be valid\", validator.isValidInet6Address(\"::123.123.123.123\"));",
          "",
          "[Removed Lines]",
          "276:         assertTrue(\"IPV6 fe80::217:f2ff:254.7.237.98 should be valid\", validator.isValidInet6Address(\"fe80::217:f2ff:254.7.237.98\"));",
          "278:         assertFalse(\"IPV6 2001:1:1:1:1:1:255Z255X255Y255 should be invalid\", validator.isValidInet6Address(\"2001:1:1:1:1:1:255Z255X255Y255\")); // garbage instead of \".\" in IPv4",
          "279:         assertFalse(\"IPV6 ::ffff:192x168.1.26 should be invalid\", validator.isValidInet6Address(\"::ffff:192x168.1.26\")); // ditto",
          "281:         assertTrue(\"IPV6 0:0:0:0:0:0:13.1.68.3 should be valid\", validator.isValidInet6Address(\"0:0:0:0:0:0:13.1.68.3\")); // IPv4-compatible IPv6 address, full, deprecated",
          "282:         assertTrue(\"IPV6 0:0:0:0:0:FFFF:129.144.52.38 should be valid\", validator.isValidInet6Address(\"0:0:0:0:0:FFFF:129.144.52.38\")); // IPv4-mapped IPv6 address, full",
          "283:         assertTrue(\"IPV6 ::13.1.68.3 should be valid\", validator.isValidInet6Address(\"::13.1.68.3\")); // IPv4-compatible IPv6 address, compressed, deprecated",
          "284:         assertTrue(\"IPV6 ::FFFF:129.144.52.38 should be valid\", validator.isValidInet6Address(\"::FFFF:129.144.52.38\")); // IPv4-mapped IPv6 address, compressed",
          "285:         assertTrue(\"IPV6 fe80:0:0:0:204:61ff:254.157.241.86 should be valid\", validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:254.157.241.86\"));",
          "286:         assertTrue(\"IPV6 fe80::204:61ff:254.157.241.86 should be valid\", validator.isValidInet6Address(\"fe80::204:61ff:254.157.241.86\"));",
          "291:         assertFalse(\"IPV6 1.2.3.4:1111:2222:3333:4444::5555 should be invalid\", validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333:4444::5555\"));",
          "292:         assertFalse(\"IPV6 1.2.3.4:1111:2222:3333::5555 should be invalid\", validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333::5555\"));",
          "293:         assertFalse(\"IPV6 1.2.3.4:1111:2222::5555 should be invalid\", validator.isValidInet6Address(\"1.2.3.4:1111:2222::5555\"));",
          "300:         assertFalse(\"IPV6 fe80:0000:0000:0000:0204:61ff:254.157.241.086 should be invalid\", validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:254.157.241.086\"));",
          "301:         assertTrue(\"IPV6 ::ffff:192.0.2.128 should be valid\", validator.isValidInet6Address(\"::ffff:192.0.2.128\")); // but this is OK, since there's a single digit",
          "302:         assertFalse(\"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4\"));",
          "303:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:00.00.00.00 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:00.00.00.00\"));",
          "304:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:000.000.000.000 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:000.000.000.000\"));",
          "305:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:256.256.256.256 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:256.256.256.256\"));",
          "306:         assertTrue(\"IPV6 fe80:0000:0000:0000:0204:61ff:fe9d:f156 should be valid\", validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:fe9d:f156\"));",
          "307:         assertTrue(\"IPV6 fe80:0:0:0:204:61ff:fe9d:f156 should be valid\", validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:fe9d:f156\"));",
          "308:         assertTrue(\"IPV6 fe80::204:61ff:fe9d:f156 should be valid\", validator.isValidInet6Address(\"fe80::204:61ff:fe9d:f156\"));",
          "311:         assertFalse(\"IPV6 1111:2222:3333:4444::5555: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::5555:\"));",
          "312:         assertFalse(\"IPV6 1111:2222:3333::5555: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555:\"));",
          "318:         assertFalse(\"IPV6 :1111:2222:3333:4444::5555 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::5555\"));",
          "319:         assertFalse(\"IPV6 :1111:2222:3333::5555 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::5555\"));",
          "323:         assertTrue(\"IPV6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 should be valid\", validator.isValidInet6Address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"));",
          "324:         assertTrue(\"IPV6 2001:db8:85a3:0:0:8a2e:370:7334 should be valid\", validator.isValidInet6Address(\"2001:db8:85a3:0:0:8a2e:370:7334\"));",
          "325:         assertTrue(\"IPV6 2001:db8:85a3::8a2e:370:7334 should be valid\", validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370:7334\"));",
          "326:         assertTrue(\"IPV6 2001:0db8:0000:0000:0000:0000:1428:57ab should be valid\", validator.isValidInet6Address(\"2001:0db8:0000:0000:0000:0000:1428:57ab\"));",
          "327:         assertTrue(\"IPV6 2001:0db8:0000:0000:0000::1428:57ab should be valid\", validator.isValidInet6Address(\"2001:0db8:0000:0000:0000::1428:57ab\"));",
          "328:         assertTrue(\"IPV6 2001:0db8:0:0:0:0:1428:57ab should be valid\", validator.isValidInet6Address(\"2001:0db8:0:0:0:0:1428:57ab\"));",
          "329:         assertTrue(\"IPV6 2001:0db8:0:0::1428:57ab should be valid\", validator.isValidInet6Address(\"2001:0db8:0:0::1428:57ab\"));",
          "333:         assertTrue(\"IPV6 2001:0db8:1234:0000:0000:0000:0000:0000 should be valid\", validator.isValidInet6Address(\"2001:0db8:1234:0000:0000:0000:0000:0000\"));",
          "334:         assertTrue(\"IPV6 2001:0db8:1234:ffff:ffff:ffff:ffff:ffff should be valid\", validator.isValidInet6Address(\"2001:0db8:1234:ffff:ffff:ffff:ffff:ffff\"));",
          "339:         assertFalse(\"IPV6 2001:db8:85a3::8a2e:37023:7334 should be invalid\", validator.isValidInet6Address(\"2001:db8:85a3::8a2e:37023:7334\"));",
          "340:         assertFalse(\"IPV6 2001:db8:85a3::8a2e:370k:7334 should be invalid\", validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370k:7334\"));",
          "345:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888\"));",
          "346:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:6666:7777:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777::\"));",
          "347:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:6666:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::\"));",
          "348:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::\"));",
          "349:         assertTrue(\"IPV6 1111:2222:3333:4444:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::\"));",
          "353:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:6666::8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888\"));",
          "354:         assertTrue(\"IPV6 1111:2222:3333:4444:5555::8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888\"));",
          "355:         assertTrue(\"IPV6 1111:2222:3333:4444::8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::8888\"));",
          "360:         assertTrue(\"IPV6 1111:2222:3333:4444:5555::7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888\"));",
          "361:         assertTrue(\"IPV6 1111:2222:3333:4444::7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888\"));",
          "362:         assertTrue(\"IPV6 1111:2222:3333::7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::7777:8888\"));",
          "366:         assertTrue(\"IPV6 1111:2222:3333:4444::6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888\"));",
          "367:         assertTrue(\"IPV6 1111:2222:3333::6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888\"));",
          "368:         assertTrue(\"IPV6 1111:2222::6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222::6666:7777:8888\"));",
          "371:         assertTrue(\"IPV6 1111:2222:3333::5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888\"));",
          "372:         assertTrue(\"IPV6 1111:2222::5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888\"));",
          "373:         assertTrue(\"IPV6 1111::5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111::5555:6666:7777:8888\"));",
          "374:         assertTrue(\"IPV6 ::5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::5555:6666:7777:8888\"));",
          "375:         assertTrue(\"IPV6 1111:2222::4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888\"));",
          "376:         assertTrue(\"IPV6 1111::4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888\"));",
          "377:         assertTrue(\"IPV6 ::4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::4444:5555:6666:7777:8888\"));",
          "378:         assertTrue(\"IPV6 1111::3333:4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888\"));",
          "379:         assertTrue(\"IPV6 ::3333:4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888\"));",
          "380:         assertTrue(\"IPV6 ::2222:3333:4444:5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888\"));",
          "381:         assertTrue(\"IPV6 1111:2222:3333:4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:123.123.123.123\"));",
          "382:         assertTrue(\"IPV6 1111:2222:3333:4444:5555::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::123.123.123.123\"));",
          "383:         assertTrue(\"IPV6 1111:2222:3333:4444::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::123.123.123.123\"));",
          "384:         assertTrue(\"IPV6 1111:2222:3333::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::123.123.123.123\"));",
          "385:         assertTrue(\"IPV6 1111:2222::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222::123.123.123.123\"));",
          "386:         assertTrue(\"IPV6 1111::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::123.123.123.123\"));",
          "388:         assertTrue(\"IPV6 1111:2222:3333:4444::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::6666:123.123.123.123\"));",
          "389:         assertTrue(\"IPV6 1111:2222:3333::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::6666:123.123.123.123\"));",
          "390:         assertTrue(\"IPV6 1111:2222::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222::6666:123.123.123.123\"));",
          "391:         assertTrue(\"IPV6 1111::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::6666:123.123.123.123\"));",
          "392:         assertTrue(\"IPV6 ::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"::6666:123.123.123.123\"));",
          "393:         assertTrue(\"IPV6 1111:2222:3333::5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222:3333::5555:6666:123.123.123.123\"));",
          "394:         assertTrue(\"IPV6 1111:2222::5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222::5555:6666:123.123.123.123\"));",
          "395:         assertTrue(\"IPV6 1111::5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::5555:6666:123.123.123.123\"));",
          "396:         assertTrue(\"IPV6 ::5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"::5555:6666:123.123.123.123\"));",
          "397:         assertTrue(\"IPV6 1111:2222::4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111:2222::4444:5555:6666:123.123.123.123\"));",
          "398:         assertTrue(\"IPV6 1111::4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::4444:5555:6666:123.123.123.123\"));",
          "399:         assertTrue(\"IPV6 ::4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"::4444:5555:6666:123.123.123.123\"));",
          "400:         assertTrue(\"IPV6 1111::3333:4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::3333:4444:5555:6666:123.123.123.123\"));",
          "401:         assertTrue(\"IPV6 ::2222:3333:4444:5555:6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:123.123.123.123\"));",
          "",
          "[Added Lines]",
          "327:         assertTrue(",
          "328:                 \"IPV6 fe80::217:f2ff:254.7.237.98 should be valid\",",
          "329:                 validator.isValidInet6Address(\"fe80::217:f2ff:254.7.237.98\"));",
          "331:         assertFalse(",
          "332:                 \"IPV6 2001:1:1:1:1:1:255Z255X255Y255 should be invalid\",",
          "333:                 validator.isValidInet6Address(\"2001:1:1:1:1:1:255Z255X255Y255\")); // garbage instead of \".\" in IPv4",
          "334:         assertFalse(",
          "335:                 \"IPV6 ::ffff:192x168.1.26 should be invalid\",",
          "336:                 validator.isValidInet6Address(\"::ffff:192x168.1.26\")); // ditto",
          "338:         assertTrue(",
          "339:                 \"IPV6 0:0:0:0:0:0:13.1.68.3 should be valid\",",
          "340:                 validator.isValidInet6Address(",
          "341:                         \"0:0:0:0:0:0:13.1.68.3\")); // IPv4-compatible IPv6 address, full, deprecated",
          "342:         assertTrue(",
          "343:                 \"IPV6 0:0:0:0:0:FFFF:129.144.52.38 should be valid\",",
          "344:                 validator.isValidInet6Address(\"0:0:0:0:0:FFFF:129.144.52.38\")); // IPv4-mapped IPv6 address, full",
          "345:         assertTrue(",
          "346:                 \"IPV6 ::13.1.68.3 should be valid\",",
          "347:                 validator.isValidInet6Address(\"::13.1.68.3\")); // IPv4-compatible IPv6 address, compressed, deprecated",
          "348:         assertTrue(",
          "349:                 \"IPV6 ::FFFF:129.144.52.38 should be valid\",",
          "350:                 validator.isValidInet6Address(\"::FFFF:129.144.52.38\")); // IPv4-mapped IPv6 address, compressed",
          "351:         assertTrue(",
          "352:                 \"IPV6 fe80:0:0:0:204:61ff:254.157.241.86 should be valid\",",
          "353:                 validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:254.157.241.86\"));",
          "354:         assertTrue(",
          "355:                 \"IPV6 fe80::204:61ff:254.157.241.86 should be valid\",",
          "356:                 validator.isValidInet6Address(\"fe80::204:61ff:254.157.241.86\"));",
          "361:         assertFalse(",
          "362:                 \"IPV6 1.2.3.4:1111:2222:3333:4444::5555 should be invalid\",",
          "363:                 validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333:4444::5555\"));",
          "364:         assertFalse(",
          "365:                 \"IPV6 1.2.3.4:1111:2222:3333::5555 should be invalid\",",
          "366:                 validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333::5555\"));",
          "367:         assertFalse(",
          "368:                 \"IPV6 1.2.3.4:1111:2222::5555 should be invalid\",",
          "369:                 validator.isValidInet6Address(\"1.2.3.4:1111:2222::5555\"));",
          "377:         assertFalse(",
          "378:                 \"IPV6 fe80:0000:0000:0000:0204:61ff:254.157.241.086 should be invalid\",",
          "379:                 validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:254.157.241.086\"));",
          "380:         assertTrue(",
          "381:                 \"IPV6 ::ffff:192.0.2.128 should be valid\",",
          "382:                 validator.isValidInet6Address(\"::ffff:192.0.2.128\")); // but this is OK, since there's a single digit",
          "383:         assertFalse(",
          "384:                 \"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4 should be invalid\",",
          "385:                 validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4\"));",
          "386:         assertFalse(",
          "387:                 \"IPV6 1111:2222:3333:4444:5555:6666:00.00.00.00 should be invalid\",",
          "388:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:00.00.00.00\"));",
          "389:         assertFalse(",
          "390:                 \"IPV6 1111:2222:3333:4444:5555:6666:000.000.000.000 should be invalid\",",
          "391:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:000.000.000.000\"));",
          "392:         assertFalse(",
          "393:                 \"IPV6 1111:2222:3333:4444:5555:6666:256.256.256.256 should be invalid\",",
          "394:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:256.256.256.256\"));",
          "395:         assertTrue(",
          "396:                 \"IPV6 fe80:0000:0000:0000:0204:61ff:fe9d:f156 should be valid\",",
          "397:                 validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:fe9d:f156\"));",
          "398:         assertTrue(",
          "399:                 \"IPV6 fe80:0:0:0:204:61ff:fe9d:f156 should be valid\",",
          "400:                 validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:fe9d:f156\"));",
          "401:         assertTrue(",
          "402:                 \"IPV6 fe80::204:61ff:fe9d:f156 should be valid\",",
          "403:                 validator.isValidInet6Address(\"fe80::204:61ff:fe9d:f156\"));",
          "406:         assertFalse(",
          "407:                 \"IPV6 1111:2222:3333:4444::5555: should be invalid\",",
          "408:                 validator.isValidInet6Address(\"1111:2222:3333:4444::5555:\"));",
          "409:         assertFalse(",
          "410:                 \"IPV6 1111:2222:3333::5555: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555:\"));",
          "416:         assertFalse(",
          "417:                 \"IPV6 :1111:2222:3333:4444::5555 should be invalid\",",
          "418:                 validator.isValidInet6Address(\":1111:2222:3333:4444::5555\"));",
          "419:         assertFalse(",
          "420:                 \"IPV6 :1111:2222:3333::5555 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::5555\"));",
          "424:         assertTrue(",
          "425:                 \"IPV6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 should be valid\",",
          "426:                 validator.isValidInet6Address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"));",
          "427:         assertTrue(",
          "428:                 \"IPV6 2001:db8:85a3:0:0:8a2e:370:7334 should be valid\",",
          "429:                 validator.isValidInet6Address(\"2001:db8:85a3:0:0:8a2e:370:7334\"));",
          "430:         assertTrue(",
          "431:                 \"IPV6 2001:db8:85a3::8a2e:370:7334 should be valid\",",
          "432:                 validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370:7334\"));",
          "433:         assertTrue(",
          "434:                 \"IPV6 2001:0db8:0000:0000:0000:0000:1428:57ab should be valid\",",
          "435:                 validator.isValidInet6Address(\"2001:0db8:0000:0000:0000:0000:1428:57ab\"));",
          "436:         assertTrue(",
          "437:                 \"IPV6 2001:0db8:0000:0000:0000::1428:57ab should be valid\",",
          "438:                 validator.isValidInet6Address(\"2001:0db8:0000:0000:0000::1428:57ab\"));",
          "439:         assertTrue(",
          "440:                 \"IPV6 2001:0db8:0:0:0:0:1428:57ab should be valid\",",
          "441:                 validator.isValidInet6Address(\"2001:0db8:0:0:0:0:1428:57ab\"));",
          "442:         assertTrue(",
          "443:                 \"IPV6 2001:0db8:0:0::1428:57ab should be valid\",",
          "444:                 validator.isValidInet6Address(\"2001:0db8:0:0::1428:57ab\"));",
          "448:         assertTrue(",
          "449:                 \"IPV6 2001:0db8:1234:0000:0000:0000:0000:0000 should be valid\",",
          "450:                 validator.isValidInet6Address(\"2001:0db8:1234:0000:0000:0000:0000:0000\"));",
          "451:         assertTrue(",
          "452:                 \"IPV6 2001:0db8:1234:ffff:ffff:ffff:ffff:ffff should be valid\",",
          "453:                 validator.isValidInet6Address(\"2001:0db8:1234:ffff:ffff:ffff:ffff:ffff\"));",
          "458:         assertFalse(",
          "459:                 \"IPV6 2001:db8:85a3::8a2e:37023:7334 should be invalid\",",
          "460:                 validator.isValidInet6Address(\"2001:db8:85a3::8a2e:37023:7334\"));",
          "461:         assertFalse(",
          "462:                 \"IPV6 2001:db8:85a3::8a2e:370k:7334 should be invalid\",",
          "463:                 validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370k:7334\"));",
          "468:         assertTrue(",
          "469:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888 should be valid\",",
          "470:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888\"));",
          "471:         assertTrue(",
          "472:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:: should be valid\",",
          "473:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777::\"));",
          "474:         assertTrue(",
          "475:                 \"IPV6 1111:2222:3333:4444:5555:6666:: should be valid\",",
          "476:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::\"));",
          "477:         assertTrue(",
          "478:                 \"IPV6 1111:2222:3333:4444:5555:: should be valid\",",
          "479:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::\"));",
          "480:         assertTrue(",
          "481:                 \"IPV6 1111:2222:3333:4444:: should be valid\", validator.isValidInet6Address(\"1111:2222:3333:4444::\"));",
          "485:         assertTrue(",
          "486:                 \"IPV6 1111:2222:3333:4444:5555:6666::8888 should be valid\",",
          "487:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888\"));",
          "488:         assertTrue(",
          "489:                 \"IPV6 1111:2222:3333:4444:5555::8888 should be valid\",",
          "490:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888\"));",
          "491:         assertTrue(",
          "492:                 \"IPV6 1111:2222:3333:4444::8888 should be valid\",",
          "493:                 validator.isValidInet6Address(\"1111:2222:3333:4444::8888\"));",
          "498:         assertTrue(",
          "499:                 \"IPV6 1111:2222:3333:4444:5555::7777:8888 should be valid\",",
          "500:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888\"));",
          "501:         assertTrue(",
          "502:                 \"IPV6 1111:2222:3333:4444::7777:8888 should be valid\",",
          "503:                 validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888\"));",
          "504:         assertTrue(",
          "505:                 \"IPV6 1111:2222:3333::7777:8888 should be valid\",",
          "506:                 validator.isValidInet6Address(\"1111:2222:3333::7777:8888\"));",
          "510:         assertTrue(",
          "511:                 \"IPV6 1111:2222:3333:4444::6666:7777:8888 should be valid\",",
          "512:                 validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888\"));",
          "513:         assertTrue(",
          "514:                 \"IPV6 1111:2222:3333::6666:7777:8888 should be valid\",",
          "515:                 validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888\"));",
          "516:         assertTrue(",
          "517:                 \"IPV6 1111:2222::6666:7777:8888 should be valid\",",
          "518:                 validator.isValidInet6Address(\"1111:2222::6666:7777:8888\"));",
          "521:         assertTrue(",
          "522:                 \"IPV6 1111:2222:3333::5555:6666:7777:8888 should be valid\",",
          "523:                 validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888\"));",
          "524:         assertTrue(",
          "525:                 \"IPV6 1111:2222::5555:6666:7777:8888 should be valid\",",
          "526:                 validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888\"));",
          "527:         assertTrue(",
          "528:                 \"IPV6 1111::5555:6666:7777:8888 should be valid\",",
          "529:                 validator.isValidInet6Address(\"1111::5555:6666:7777:8888\"));",
          "530:         assertTrue(",
          "531:                 \"IPV6 ::5555:6666:7777:8888 should be valid\", validator.isValidInet6Address(\"::5555:6666:7777:8888\"));",
          "532:         assertTrue(",
          "533:                 \"IPV6 1111:2222::4444:5555:6666:7777:8888 should be valid\",",
          "534:                 validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888\"));",
          "535:         assertTrue(",
          "536:                 \"IPV6 1111::4444:5555:6666:7777:8888 should be valid\",",
          "537:                 validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888\"));",
          "538:         assertTrue(",
          "539:                 \"IPV6 ::4444:5555:6666:7777:8888 should be valid\",",
          "540:                 validator.isValidInet6Address(\"::4444:5555:6666:7777:8888\"));",
          "541:         assertTrue(",
          "542:                 \"IPV6 1111::3333:4444:5555:6666:7777:8888 should be valid\",",
          "543:                 validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888\"));",
          "544:         assertTrue(",
          "545:                 \"IPV6 ::3333:4444:5555:6666:7777:8888 should be valid\",",
          "546:                 validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888\"));",
          "547:         assertTrue(",
          "548:                 \"IPV6 ::2222:3333:4444:5555:6666:7777:8888 should be valid\",",
          "549:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888\"));",
          "550:         assertTrue(",
          "551:                 \"IPV6 1111:2222:3333:4444:5555:6666:123.123.123.123 should be valid\",",
          "552:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:123.123.123.123\"));",
          "553:         assertTrue(",
          "554:                 \"IPV6 1111:2222:3333:4444:5555::123.123.123.123 should be valid\",",
          "555:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::123.123.123.123\"));",
          "556:         assertTrue(",
          "557:                 \"IPV6 1111:2222:3333:4444::123.123.123.123 should be valid\",",
          "558:                 validator.isValidInet6Address(\"1111:2222:3333:4444::123.123.123.123\"));",
          "559:         assertTrue(",
          "560:                 \"IPV6 1111:2222:3333::123.123.123.123 should be valid\",",
          "561:                 validator.isValidInet6Address(\"1111:2222:3333::123.123.123.123\"));",
          "562:         assertTrue(",
          "563:                 \"IPV6 1111:2222::123.123.123.123 should be valid\",",
          "564:                 validator.isValidInet6Address(\"1111:2222::123.123.123.123\"));",
          "565:         assertTrue(",
          "566:                 \"IPV6 1111::123.123.123.123 should be valid\", validator.isValidInet6Address(\"1111::123.123.123.123\"));",
          "568:         assertTrue(",
          "569:                 \"IPV6 1111:2222:3333:4444::6666:123.123.123.123 should be valid\",",
          "570:                 validator.isValidInet6Address(\"1111:2222:3333:4444::6666:123.123.123.123\"));",
          "571:         assertTrue(",
          "572:                 \"IPV6 1111:2222:3333::6666:123.123.123.123 should be valid\",",
          "573:                 validator.isValidInet6Address(\"1111:2222:3333::6666:123.123.123.123\"));",
          "574:         assertTrue(",
          "575:                 \"IPV6 1111:2222::6666:123.123.123.123 should be valid\",",
          "576:                 validator.isValidInet6Address(\"1111:2222::6666:123.123.123.123\"));",
          "577:         assertTrue(",
          "578:                 \"IPV6 1111::6666:123.123.123.123 should be valid\",",
          "579:                 validator.isValidInet6Address(\"1111::6666:123.123.123.123\"));",
          "580:         assertTrue(",
          "581:                 \"IPV6 ::6666:123.123.123.123 should be valid\", validator.isValidInet6Address(\"::6666:123.123.123.123\"));",
          "582:         assertTrue(",
          "583:                 \"IPV6 1111:2222:3333::5555:6666:123.123.123.123 should be valid\",",
          "584:                 validator.isValidInet6Address(\"1111:2222:3333::5555:6666:123.123.123.123\"));",
          "585:         assertTrue(",
          "586:                 \"IPV6 1111:2222::5555:6666:123.123.123.123 should be valid\",",
          "587:                 validator.isValidInet6Address(\"1111:2222::5555:6666:123.123.123.123\"));",
          "588:         assertTrue(",
          "589:                 \"IPV6 1111::5555:6666:123.123.123.123 should be valid\",",
          "590:                 validator.isValidInet6Address(\"1111::5555:6666:123.123.123.123\"));",
          "591:         assertTrue(",
          "592:                 \"IPV6 ::5555:6666:123.123.123.123 should be valid\",",
          "593:                 validator.isValidInet6Address(\"::5555:6666:123.123.123.123\"));",
          "594:         assertTrue(",
          "595:                 \"IPV6 1111:2222::4444:5555:6666:123.123.123.123 should be valid\",",
          "596:                 validator.isValidInet6Address(\"1111:2222::4444:5555:6666:123.123.123.123\"));",
          "597:         assertTrue(",
          "598:                 \"IPV6 1111::4444:5555:6666:123.123.123.123 should be valid\",",
          "599:                 validator.isValidInet6Address(\"1111::4444:5555:6666:123.123.123.123\"));",
          "600:         assertTrue(",
          "601:                 \"IPV6 ::4444:5555:6666:123.123.123.123 should be valid\",",
          "602:                 validator.isValidInet6Address(\"::4444:5555:6666:123.123.123.123\"));",
          "603:         assertTrue(",
          "604:                 \"IPV6 1111::3333:4444:5555:6666:123.123.123.123 should be valid\",",
          "605:                 validator.isValidInet6Address(\"1111::3333:4444:5555:6666:123.123.123.123\"));",
          "606:         assertTrue(",
          "607:                 \"IPV6 ::2222:3333:4444:5555:6666:123.123.123.123 should be valid\",",
          "608:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:123.123.123.123\"));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "417:         assertTrue(\"IPV6 0:0:: should be valid\", validator.isValidInet6Address(\"0:0::\"));",
          "418:         assertTrue(\"IPV6 0:: should be valid\", validator.isValidInet6Address(\"0::\"));",
          "429:         assertFalse(\"IPV6 1111:2222:3333:4444 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444\"));",
          "430:         assertFalse(\"IPV6 1111:2222:3333 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333\"));",
          "431:         assertFalse(\"IPV6 1111:2222 should be invalid\", validator.isValidInet6Address(\"1111:2222\"));",
          "432:         assertFalse(\"IPV6 1111 should be invalid\", validator.isValidInet6Address(\"1111\"));",
          "447:         assertFalse(\"IPV6 1111:2222:3333: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:\"));",
          "448:         assertFalse(\"IPV6 1111:2222: should be invalid\", validator.isValidInet6Address(\"1111:2222:\"));",
          "449:         assertFalse(\"IPV6 :8888 should be invalid\", validator.isValidInet6Address(\":8888\"));",
          "450:         assertFalse(\"IPV6 :7777:8888 should be invalid\", validator.isValidInet6Address(\":7777:8888\"));",
          "451:         assertFalse(\"IPV6 :6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":6666:7777:8888\"));",
          "498:         assertFalse(\"IPV6 1111:2222:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:1.2.3.4\"));",
          "499:         assertFalse(\"IPV6 1111:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:1.2.3.4\"));",
          "500:         assertFalse(\"IPV6 1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1.2.3.4\"));",
          "513:         assertFalse(\"IPV6 :1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1.2.3.4\"));",
          "514:         assertFalse(\"IPV6 :6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":6666:1.2.3.4\"));",
          "515:         assertFalse(\"IPV6 :5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":5555:6666:1.2.3.4\"));",
          "539:         assertFalse(\"IPV6 ::. should be invalid\", validator.isValidInet6Address(\"::.\"));",
          "540:         assertFalse(\"IPV6 ::.. should be invalid\", validator.isValidInet6Address(\"::..\"));",
          "",
          "[Removed Lines]",
          "420:         assertFalse(\"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX should be invalid\", validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX\"));",
          "422:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:9999\"));",
          "423:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888::\"));",
          "424:         assertFalse(\"IPV6 ::2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:9999\"));",
          "426:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777\"));",
          "427:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666\"));",
          "428:         assertFalse(\"IPV6 1111:2222:3333:4444:5555 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555\"));",
          "434:         assertFalse(\"IPV6 11112222:3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:7777:8888\"));",
          "435:         assertFalse(\"IPV6 1111:22223333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:7777:8888\"));",
          "436:         assertFalse(\"IPV6 1111:2222:33334444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:7777:8888\"));",
          "437:         assertFalse(\"IPV6 1111:2222:3333:44445555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:7777:8888\"));",
          "438:         assertFalse(\"IPV6 1111:2222:3333:4444:55556666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:7777:8888\"));",
          "439:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:66667777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66667777:8888\"));",
          "440:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:77778888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:77778888\"));",
          "442:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:\"));",
          "443:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:\"));",
          "444:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:\"));",
          "445:         assertFalse(\"IPV6 1111:2222:3333:4444:5555: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:\"));",
          "446:         assertFalse(\"IPV6 1111:2222:3333:4444: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:\"));",
          "452:         assertFalse(\"IPV6 :5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":5555:6666:7777:8888\"));",
          "453:         assertFalse(\"IPV6 :4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":4444:5555:6666:7777:8888\"));",
          "454:         assertFalse(\"IPV6 :3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":3333:4444:5555:6666:7777:8888\"));",
          "455:         assertFalse(\"IPV6 :2222:3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":2222:3333:4444:5555:6666:7777:8888\"));",
          "456:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777:8888\"));",
          "458:         assertFalse(\"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"));",
          "459:         assertFalse(\"IPV6 1111:::3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:7777:8888\"));",
          "460:         assertFalse(\"IPV6 1111:2222:::4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:7777:8888\"));",
          "461:         assertFalse(\"IPV6 1111:2222:3333:::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:7777:8888\"));",
          "462:         assertFalse(\"IPV6 1111:2222:3333:4444:::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:7777:8888\"));",
          "463:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:::7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::7777:8888\"));",
          "464:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:::8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::8888\"));",
          "465:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"));",
          "467:         assertFalse(\"IPV6 ::2222::4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"::2222::4444:5555:6666:7777:8888\"));",
          "468:         assertFalse(\"IPV6 ::2222:3333::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"::2222:3333::5555:6666:7777:8888\"));",
          "469:         assertFalse(\"IPV6 ::2222:3333:4444::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444::6666:7777:8888\"));",
          "470:         assertFalse(\"IPV6 ::2222:3333:4444:5555::7777:8888 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555::7777:8888\"));",
          "471:         assertFalse(\"IPV6 ::2222:3333:4444:5555:7777::8888 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:7777::8888\"));",
          "472:         assertFalse(\"IPV6 ::2222:3333:4444:5555:7777:8888:: should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:7777:8888::\"));",
          "473:         assertFalse(\"IPV6 1111::3333::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111::3333::5555:6666:7777:8888\"));",
          "474:         assertFalse(\"IPV6 1111::3333:4444::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111::3333:4444::6666:7777:8888\"));",
          "475:         assertFalse(\"IPV6 1111::3333:4444:5555::7777:8888 should be invalid\", validator.isValidInet6Address(\"1111::3333:4444:5555::7777:8888\"));",
          "476:         assertFalse(\"IPV6 1111::3333:4444:5555:6666::8888 should be invalid\", validator.isValidInet6Address(\"1111::3333:4444:5555:6666::8888\"));",
          "477:         assertFalse(\"IPV6 1111::3333:4444:5555:6666:7777:: should be invalid\", validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777::\"));",
          "478:         assertFalse(\"IPV6 1111:2222::4444::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222::4444::6666:7777:8888\"));",
          "479:         assertFalse(\"IPV6 1111:2222::4444:5555::7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222::4444:5555::7777:8888\"));",
          "480:         assertFalse(\"IPV6 1111:2222::4444:5555:6666::8888 should be invalid\", validator.isValidInet6Address(\"1111:2222::4444:5555:6666::8888\"));",
          "481:         assertFalse(\"IPV6 1111:2222::4444:5555:6666:7777:: should be invalid\", validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777::\"));",
          "482:         assertFalse(\"IPV6 1111:2222:3333::5555::7777:8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555::7777:8888\"));",
          "483:         assertFalse(\"IPV6 1111:2222:3333::5555:6666::8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555:6666::8888\"));",
          "484:         assertFalse(\"IPV6 1111:2222:3333::5555:6666:7777:: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777::\"));",
          "485:         assertFalse(\"IPV6 1111:2222:3333:4444::6666::8888 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::6666::8888\"));",
          "486:         assertFalse(\"IPV6 1111:2222:3333:4444::6666:7777:: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777::\"));",
          "487:         assertFalse(\"IPV6 1111:2222:3333:4444:5555::7777:: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777::\"));",
          "489:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4\"));",
          "490:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:1.2.3.4\"));",
          "491:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::1.2.3.4\"));",
          "492:         assertFalse(\"IPV6 ::2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:1.2.3.4\"));",
          "493:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:1.2.3.4.5 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:1.2.3.4.5\"));",
          "495:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:1.2.3.4\"));",
          "496:         assertFalse(\"IPV6 1111:2222:3333:4444:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:1.2.3.4\"));",
          "497:         assertFalse(\"IPV6 1111:2222:3333:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:1.2.3.4\"));",
          "502:         assertFalse(\"IPV6 11112222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:1.2.3.4\"));",
          "503:         assertFalse(\"IPV6 1111:22223333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:1.2.3.4\"));",
          "504:         assertFalse(\"IPV6 1111:2222:33334444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:1.2.3.4\"));",
          "505:         assertFalse(\"IPV6 1111:2222:3333:44445555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:1.2.3.4\"));",
          "506:         assertFalse(\"IPV6 1111:2222:3333:4444:55556666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:1.2.3.4\"));",
          "507:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:66661.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66661.2.3.4\"));",
          "509:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:255255.255.255 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255255.255.255\"));",
          "510:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:255.255255.255 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255255.255\"));",
          "511:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:255.255.255255 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255.255255\"));",
          "516:         assertFalse(\"IPV6 :4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":4444:5555:6666:1.2.3.4\"));",
          "517:         assertFalse(\"IPV6 :3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":3333:4444:5555:6666:1.2.3.4\"));",
          "518:         assertFalse(\"IPV6 :2222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":2222:3333:4444:5555:6666:1.2.3.4\"));",
          "519:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"));",
          "521:         assertFalse(\"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"));",
          "522:         assertFalse(\"IPV6 1111:::3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:1.2.3.4\"));",
          "523:         assertFalse(\"IPV6 1111:2222:::4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:1.2.3.4\"));",
          "524:         assertFalse(\"IPV6 1111:2222:3333:::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:1.2.3.4\"));",
          "525:         assertFalse(\"IPV6 1111:2222:3333:4444:::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:1.2.3.4\"));",
          "526:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::1.2.3.4\"));",
          "528:         assertFalse(\"IPV6 ::2222::4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"::2222::4444:5555:6666:1.2.3.4\"));",
          "529:         assertFalse(\"IPV6 ::2222:3333::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"::2222:3333::5555:6666:1.2.3.4\"));",
          "530:         assertFalse(\"IPV6 ::2222:3333:4444::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444::6666:1.2.3.4\"));",
          "531:         assertFalse(\"IPV6 ::2222:3333:4444:5555::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555::1.2.3.4\"));",
          "532:         assertFalse(\"IPV6 1111::3333::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111::3333::5555:6666:1.2.3.4\"));",
          "533:         assertFalse(\"IPV6 1111::3333:4444::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111::3333:4444::6666:1.2.3.4\"));",
          "534:         assertFalse(\"IPV6 1111::3333:4444:5555::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111::3333:4444:5555::1.2.3.4\"));",
          "535:         assertFalse(\"IPV6 1111:2222::4444::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222::4444::6666:1.2.3.4\"));",
          "536:         assertFalse(\"IPV6 1111:2222::4444:5555::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222::4444:5555::1.2.3.4\"));",
          "537:         assertFalse(\"IPV6 1111:2222:3333::5555::1.2.3.4 should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555::1.2.3.4\"));",
          "",
          "[Added Lines]",
          "627:         assertFalse(",
          "628:                 \"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX should be invalid\",",
          "629:                 validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX\"));",
          "631:         assertFalse(",
          "632:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\",",
          "633:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:9999\"));",
          "634:         assertFalse(",
          "635:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:: should be invalid\",",
          "636:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888::\"));",
          "637:         assertFalse(",
          "638:                 \"IPV6 ::2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\",",
          "639:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:9999\"));",
          "641:         assertFalse(",
          "642:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777 should be invalid\",",
          "643:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777\"));",
          "644:         assertFalse(",
          "645:                 \"IPV6 1111:2222:3333:4444:5555:6666 should be invalid\",",
          "646:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666\"));",
          "647:         assertFalse(",
          "648:                 \"IPV6 1111:2222:3333:4444:5555 should be invalid\",",
          "649:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555\"));",
          "655:         assertFalse(",
          "656:                 \"IPV6 11112222:3333:4444:5555:6666:7777:8888 should be invalid\",",
          "657:                 validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:7777:8888\"));",
          "658:         assertFalse(",
          "659:                 \"IPV6 1111:22223333:4444:5555:6666:7777:8888 should be invalid\",",
          "660:                 validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:7777:8888\"));",
          "661:         assertFalse(",
          "662:                 \"IPV6 1111:2222:33334444:5555:6666:7777:8888 should be invalid\",",
          "663:                 validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:7777:8888\"));",
          "664:         assertFalse(",
          "665:                 \"IPV6 1111:2222:3333:44445555:6666:7777:8888 should be invalid\",",
          "666:                 validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:7777:8888\"));",
          "667:         assertFalse(",
          "668:                 \"IPV6 1111:2222:3333:4444:55556666:7777:8888 should be invalid\",",
          "669:                 validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:7777:8888\"));",
          "670:         assertFalse(",
          "671:                 \"IPV6 1111:2222:3333:4444:5555:66667777:8888 should be invalid\",",
          "672:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66667777:8888\"));",
          "673:         assertFalse(",
          "674:                 \"IPV6 1111:2222:3333:4444:5555:6666:77778888 should be invalid\",",
          "675:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:77778888\"));",
          "677:         assertFalse(",
          "678:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888: should be invalid\",",
          "679:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:\"));",
          "680:         assertFalse(",
          "681:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777: should be invalid\",",
          "682:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:\"));",
          "683:         assertFalse(",
          "684:                 \"IPV6 1111:2222:3333:4444:5555:6666: should be invalid\",",
          "685:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:\"));",
          "686:         assertFalse(",
          "687:                 \"IPV6 1111:2222:3333:4444:5555: should be invalid\",",
          "688:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:\"));",
          "689:         assertFalse(",
          "690:                 \"IPV6 1111:2222:3333:4444: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:\"));",
          "696:         assertFalse(",
          "697:                 \"IPV6 :5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":5555:6666:7777:8888\"));",
          "698:         assertFalse(",
          "699:                 \"IPV6 :4444:5555:6666:7777:8888 should be invalid\",",
          "700:                 validator.isValidInet6Address(\":4444:5555:6666:7777:8888\"));",
          "701:         assertFalse(",
          "702:                 \"IPV6 :3333:4444:5555:6666:7777:8888 should be invalid\",",
          "703:                 validator.isValidInet6Address(\":3333:4444:5555:6666:7777:8888\"));",
          "704:         assertFalse(",
          "705:                 \"IPV6 :2222:3333:4444:5555:6666:7777:8888 should be invalid\",",
          "706:                 validator.isValidInet6Address(\":2222:3333:4444:5555:6666:7777:8888\"));",
          "707:         assertFalse(",
          "708:                 \"IPV6 :1111:2222:3333:4444:5555:6666:7777:8888 should be invalid\",",
          "709:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777:8888\"));",
          "711:         assertFalse(",
          "712:                 \"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\",",
          "713:                 validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"));",
          "714:         assertFalse(",
          "715:                 \"IPV6 1111:::3333:4444:5555:6666:7777:8888 should be invalid\",",
          "716:                 validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:7777:8888\"));",
          "717:         assertFalse(",
          "718:                 \"IPV6 1111:2222:::4444:5555:6666:7777:8888 should be invalid\",",
          "719:                 validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:7777:8888\"));",
          "720:         assertFalse(",
          "721:                 \"IPV6 1111:2222:3333:::5555:6666:7777:8888 should be invalid\",",
          "722:                 validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:7777:8888\"));",
          "723:         assertFalse(",
          "724:                 \"IPV6 1111:2222:3333:4444:::6666:7777:8888 should be invalid\",",
          "725:                 validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:7777:8888\"));",
          "726:         assertFalse(",
          "727:                 \"IPV6 1111:2222:3333:4444:5555:::7777:8888 should be invalid\",",
          "728:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::7777:8888\"));",
          "729:         assertFalse(",
          "730:                 \"IPV6 1111:2222:3333:4444:5555:6666:::8888 should be invalid\",",
          "731:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::8888\"));",
          "732:         assertFalse(",
          "733:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\",",
          "734:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"));",
          "736:         assertFalse(",
          "737:                 \"IPV6 ::2222::4444:5555:6666:7777:8888 should be invalid\",",
          "738:                 validator.isValidInet6Address(\"::2222::4444:5555:6666:7777:8888\"));",
          "739:         assertFalse(",
          "740:                 \"IPV6 ::2222:3333::5555:6666:7777:8888 should be invalid\",",
          "741:                 validator.isValidInet6Address(\"::2222:3333::5555:6666:7777:8888\"));",
          "742:         assertFalse(",
          "743:                 \"IPV6 ::2222:3333:4444::6666:7777:8888 should be invalid\",",
          "744:                 validator.isValidInet6Address(\"::2222:3333:4444::6666:7777:8888\"));",
          "745:         assertFalse(",
          "746:                 \"IPV6 ::2222:3333:4444:5555::7777:8888 should be invalid\",",
          "747:                 validator.isValidInet6Address(\"::2222:3333:4444:5555::7777:8888\"));",
          "748:         assertFalse(",
          "749:                 \"IPV6 ::2222:3333:4444:5555:7777::8888 should be invalid\",",
          "750:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:7777::8888\"));",
          "751:         assertFalse(",
          "752:                 \"IPV6 ::2222:3333:4444:5555:7777:8888:: should be invalid\",",
          "753:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:7777:8888::\"));",
          "754:         assertFalse(",
          "755:                 \"IPV6 1111::3333::5555:6666:7777:8888 should be invalid\",",
          "756:                 validator.isValidInet6Address(\"1111::3333::5555:6666:7777:8888\"));",
          "757:         assertFalse(",
          "758:                 \"IPV6 1111::3333:4444::6666:7777:8888 should be invalid\",",
          "759:                 validator.isValidInet6Address(\"1111::3333:4444::6666:7777:8888\"));",
          "760:         assertFalse(",
          "761:                 \"IPV6 1111::3333:4444:5555::7777:8888 should be invalid\",",
          "762:                 validator.isValidInet6Address(\"1111::3333:4444:5555::7777:8888\"));",
          "763:         assertFalse(",
          "764:                 \"IPV6 1111::3333:4444:5555:6666::8888 should be invalid\",",
          "765:                 validator.isValidInet6Address(\"1111::3333:4444:5555:6666::8888\"));",
          "766:         assertFalse(",
          "767:                 \"IPV6 1111::3333:4444:5555:6666:7777:: should be invalid\",",
          "768:                 validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777::\"));",
          "769:         assertFalse(",
          "770:                 \"IPV6 1111:2222::4444::6666:7777:8888 should be invalid\",",
          "771:                 validator.isValidInet6Address(\"1111:2222::4444::6666:7777:8888\"));",
          "772:         assertFalse(",
          "773:                 \"IPV6 1111:2222::4444:5555::7777:8888 should be invalid\",",
          "774:                 validator.isValidInet6Address(\"1111:2222::4444:5555::7777:8888\"));",
          "775:         assertFalse(",
          "776:                 \"IPV6 1111:2222::4444:5555:6666::8888 should be invalid\",",
          "777:                 validator.isValidInet6Address(\"1111:2222::4444:5555:6666::8888\"));",
          "778:         assertFalse(",
          "779:                 \"IPV6 1111:2222::4444:5555:6666:7777:: should be invalid\",",
          "780:                 validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777::\"));",
          "781:         assertFalse(",
          "782:                 \"IPV6 1111:2222:3333::5555::7777:8888 should be invalid\",",
          "783:                 validator.isValidInet6Address(\"1111:2222:3333::5555::7777:8888\"));",
          "784:         assertFalse(",
          "785:                 \"IPV6 1111:2222:3333::5555:6666::8888 should be invalid\",",
          "786:                 validator.isValidInet6Address(\"1111:2222:3333::5555:6666::8888\"));",
          "787:         assertFalse(",
          "788:                 \"IPV6 1111:2222:3333::5555:6666:7777:: should be invalid\",",
          "789:                 validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777::\"));",
          "790:         assertFalse(",
          "791:                 \"IPV6 1111:2222:3333:4444::6666::8888 should be invalid\",",
          "792:                 validator.isValidInet6Address(\"1111:2222:3333:4444::6666::8888\"));",
          "793:         assertFalse(",
          "794:                 \"IPV6 1111:2222:3333:4444::6666:7777:: should be invalid\",",
          "795:                 validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777::\"));",
          "796:         assertFalse(",
          "797:                 \"IPV6 1111:2222:3333:4444:5555::7777:: should be invalid\",",
          "798:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777::\"));",
          "800:         assertFalse(",
          "801:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4 should be invalid\",",
          "802:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4\"));",
          "803:         assertFalse(",
          "804:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\",",
          "805:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:1.2.3.4\"));",
          "806:         assertFalse(",
          "807:                 \"IPV6 1111:2222:3333:4444:5555:6666::1.2.3.4 should be invalid\",",
          "808:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::1.2.3.4\"));",
          "809:         assertFalse(",
          "810:                 \"IPV6 ::2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\",",
          "811:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:1.2.3.4\"));",
          "812:         assertFalse(",
          "813:                 \"IPV6 1111:2222:3333:4444:5555:6666:1.2.3.4.5 should be invalid\",",
          "814:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:1.2.3.4.5\"));",
          "816:         assertFalse(",
          "817:                 \"IPV6 1111:2222:3333:4444:5555:1.2.3.4 should be invalid\",",
          "818:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:1.2.3.4\"));",
          "819:         assertFalse(",
          "820:                 \"IPV6 1111:2222:3333:4444:1.2.3.4 should be invalid\",",
          "821:                 validator.isValidInet6Address(\"1111:2222:3333:4444:1.2.3.4\"));",
          "822:         assertFalse(",
          "823:                 \"IPV6 1111:2222:3333:1.2.3.4 should be invalid\",",
          "824:                 validator.isValidInet6Address(\"1111:2222:3333:1.2.3.4\"));",
          "829:         assertFalse(",
          "830:                 \"IPV6 11112222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "831:                 validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:1.2.3.4\"));",
          "832:         assertFalse(",
          "833:                 \"IPV6 1111:22223333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "834:                 validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:1.2.3.4\"));",
          "835:         assertFalse(",
          "836:                 \"IPV6 1111:2222:33334444:5555:6666:1.2.3.4 should be invalid\",",
          "837:                 validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:1.2.3.4\"));",
          "838:         assertFalse(",
          "839:                 \"IPV6 1111:2222:3333:44445555:6666:1.2.3.4 should be invalid\",",
          "840:                 validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:1.2.3.4\"));",
          "841:         assertFalse(",
          "842:                 \"IPV6 1111:2222:3333:4444:55556666:1.2.3.4 should be invalid\",",
          "843:                 validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:1.2.3.4\"));",
          "844:         assertFalse(",
          "845:                 \"IPV6 1111:2222:3333:4444:5555:66661.2.3.4 should be invalid\",",
          "846:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66661.2.3.4\"));",
          "848:         assertFalse(",
          "849:                 \"IPV6 1111:2222:3333:4444:5555:6666:255255.255.255 should be invalid\",",
          "850:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255255.255.255\"));",
          "851:         assertFalse(",
          "852:                 \"IPV6 1111:2222:3333:4444:5555:6666:255.255255.255 should be invalid\",",
          "853:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255255.255\"));",
          "854:         assertFalse(",
          "855:                 \"IPV6 1111:2222:3333:4444:5555:6666:255.255.255255 should be invalid\",",
          "856:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255.255255\"));",
          "861:         assertFalse(",
          "862:                 \"IPV6 :4444:5555:6666:1.2.3.4 should be invalid\",",
          "863:                 validator.isValidInet6Address(\":4444:5555:6666:1.2.3.4\"));",
          "864:         assertFalse(",
          "865:                 \"IPV6 :3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "866:                 validator.isValidInet6Address(\":3333:4444:5555:6666:1.2.3.4\"));",
          "867:         assertFalse(",
          "868:                 \"IPV6 :2222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "869:                 validator.isValidInet6Address(\":2222:3333:4444:5555:6666:1.2.3.4\"));",
          "870:         assertFalse(",
          "871:                 \"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "872:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"));",
          "874:         assertFalse(",
          "875:                 \"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "876:                 validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"));",
          "877:         assertFalse(",
          "878:                 \"IPV6 1111:::3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "879:                 validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:1.2.3.4\"));",
          "880:         assertFalse(",
          "881:                 \"IPV6 1111:2222:::4444:5555:6666:1.2.3.4 should be invalid\",",
          "882:                 validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:1.2.3.4\"));",
          "883:         assertFalse(",
          "884:                 \"IPV6 1111:2222:3333:::5555:6666:1.2.3.4 should be invalid\",",
          "885:                 validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:1.2.3.4\"));",
          "886:         assertFalse(",
          "887:                 \"IPV6 1111:2222:3333:4444:::6666:1.2.3.4 should be invalid\",",
          "888:                 validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:1.2.3.4\"));",
          "889:         assertFalse(",
          "890:                 \"IPV6 1111:2222:3333:4444:5555:::1.2.3.4 should be invalid\",",
          "891:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::1.2.3.4\"));",
          "893:         assertFalse(",
          "894:                 \"IPV6 ::2222::4444:5555:6666:1.2.3.4 should be invalid\",",
          "895:                 validator.isValidInet6Address(\"::2222::4444:5555:6666:1.2.3.4\"));",
          "896:         assertFalse(",
          "897:                 \"IPV6 ::2222:3333::5555:6666:1.2.3.4 should be invalid\",",
          "898:                 validator.isValidInet6Address(\"::2222:3333::5555:6666:1.2.3.4\"));",
          "899:         assertFalse(",
          "900:                 \"IPV6 ::2222:3333:4444::6666:1.2.3.4 should be invalid\",",
          "901:                 validator.isValidInet6Address(\"::2222:3333:4444::6666:1.2.3.4\"));",
          "902:         assertFalse(",
          "903:                 \"IPV6 ::2222:3333:4444:5555::1.2.3.4 should be invalid\",",
          "904:                 validator.isValidInet6Address(\"::2222:3333:4444:5555::1.2.3.4\"));",
          "905:         assertFalse(",
          "906:                 \"IPV6 1111::3333::5555:6666:1.2.3.4 should be invalid\",",
          "907:                 validator.isValidInet6Address(\"1111::3333::5555:6666:1.2.3.4\"));",
          "908:         assertFalse(",
          "909:                 \"IPV6 1111::3333:4444::6666:1.2.3.4 should be invalid\",",
          "910:                 validator.isValidInet6Address(\"1111::3333:4444::6666:1.2.3.4\"));",
          "911:         assertFalse(",
          "912:                 \"IPV6 1111::3333:4444:5555::1.2.3.4 should be invalid\",",
          "913:                 validator.isValidInet6Address(\"1111::3333:4444:5555::1.2.3.4\"));",
          "914:         assertFalse(",
          "915:                 \"IPV6 1111:2222::4444::6666:1.2.3.4 should be invalid\",",
          "916:                 validator.isValidInet6Address(\"1111:2222::4444::6666:1.2.3.4\"));",
          "917:         assertFalse(",
          "918:                 \"IPV6 1111:2222::4444:5555::1.2.3.4 should be invalid\",",
          "919:                 validator.isValidInet6Address(\"1111:2222::4444:5555::1.2.3.4\"));",
          "920:         assertFalse(",
          "921:                 \"IPV6 1111:2222:3333::5555::1.2.3.4 should be invalid\",",
          "922:                 validator.isValidInet6Address(\"1111:2222:3333::5555::1.2.3.4\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "549:         assertFalse(\"IPV6 ::..3.4 should be invalid\", validator.isValidInet6Address(\"::..3.4\"));",
          "550:         assertFalse(\"IPV6 ::...4 should be invalid\", validator.isValidInet6Address(\"::...4\"));",
          "556:         assertFalse(\"IPV6 :1111:2222:3333:: should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::\"));",
          "557:         assertFalse(\"IPV6 :1111:2222:: should be invalid\", validator.isValidInet6Address(\":1111:2222::\"));",
          "558:         assertFalse(\"IPV6 :1111:: should be invalid\", validator.isValidInet6Address(\":1111::\"));",
          "563:         assertFalse(\"IPV6 :1111:2222::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::8888\"));",
          "564:         assertFalse(\"IPV6 :1111::8888 should be invalid\", validator.isValidInet6Address(\":1111::8888\"));",
          "565:         assertFalse(\"IPV6 :::8888 should be invalid\", validator.isValidInet6Address(\":::8888\"));",
          "570:         assertFalse(\"IPV6 :1111::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::7777:8888\"));",
          "571:         assertFalse(\"IPV6 :::7777:8888 should be invalid\", validator.isValidInet6Address(\":::7777:8888\"));",
          "576:         assertFalse(\"IPV6 :::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::6666:7777:8888\"));",
          "591:         assertFalse(\"IPV6 :1111:2222::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222::1.2.3.4\"));",
          "592:         assertFalse(\"IPV6 :1111::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111::1.2.3.4\"));",
          "593:         assertFalse(\"IPV6 :::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::1.2.3.4\"));",
          "597:         assertFalse(\"IPV6 :1111::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111::6666:1.2.3.4\"));",
          "598:         assertFalse(\"IPV6 :::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::6666:1.2.3.4\"));",
          "613:         assertFalse(\"IPV6 1111:2222:3333::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:::\"));",
          "614:         assertFalse(\"IPV6 1111:2222::: should be invalid\", validator.isValidInet6Address(\"1111:2222:::\"));",
          "615:         assertFalse(\"IPV6 1111::: should be invalid\", validator.isValidInet6Address(\"1111:::\"));",
          "620:         assertFalse(\"IPV6 1111:2222::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::8888:\"));",
          "621:         assertFalse(\"IPV6 1111::8888: should be invalid\", validator.isValidInet6Address(\"1111::8888:\"));",
          "622:         assertFalse(\"IPV6 ::8888: should be invalid\", validator.isValidInet6Address(\"::8888:\"));",
          "627:         assertFalse(\"IPV6 1111::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::7777:8888:\"));",
          "628:         assertFalse(\"IPV6 ::7777:8888: should be invalid\", validator.isValidInet6Address(\"::7777:8888:\"));",
          "633:         assertFalse(\"IPV6 ::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"::6666:7777:8888:\"));",
          "644:         assertTrue(\"IPV6 0:a:b:c:d:e:f:: should be valid\", validator.isValidInet6Address(\"0:a:b:c:d:e:f::\"));",
          "646:         assertTrue(\"IPV6 a:b:c:d:e:f:0:: should be valid\", validator.isValidInet6Address(\"a:b:c:d:e:f:0::\"));",
          "647:         assertFalse(\"IPV6 ':10.0.0.1 should be invalid\", validator.isValidInet6Address(\"':10.0.0.1\"));",
          "648:     }",
          "",
          "[Removed Lines]",
          "552:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666:7777:: should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777::\"));",
          "553:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666:: should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::\"));",
          "554:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:: should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555::\"));",
          "555:         assertFalse(\"IPV6 :1111:2222:3333:4444:: should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::\"));",
          "559:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::8888\"));",
          "560:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555::8888\"));",
          "561:         assertFalse(\"IPV6 :1111:2222:3333:4444::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::8888\"));",
          "562:         assertFalse(\"IPV6 :1111:2222:3333::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::8888\"));",
          "566:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555::7777:8888\"));",
          "567:         assertFalse(\"IPV6 :1111:2222:3333:4444::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::7777:8888\"));",
          "568:         assertFalse(\"IPV6 :1111:2222:3333::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::7777:8888\"));",
          "569:         assertFalse(\"IPV6 :1111:2222::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::7777:8888\"));",
          "572:         assertFalse(\"IPV6 :1111:2222:3333:4444::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::6666:7777:8888\"));",
          "573:         assertFalse(\"IPV6 :1111:2222:3333::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::6666:7777:8888\"));",
          "574:         assertFalse(\"IPV6 :1111:2222::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::6666:7777:8888\"));",
          "575:         assertFalse(\"IPV6 :1111::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::6666:7777:8888\"));",
          "577:         assertFalse(\"IPV6 :1111:2222:3333::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::5555:6666:7777:8888\"));",
          "578:         assertFalse(\"IPV6 :1111:2222::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::5555:6666:7777:8888\"));",
          "579:         assertFalse(\"IPV6 :1111::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::5555:6666:7777:8888\"));",
          "580:         assertFalse(\"IPV6 :::5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::5555:6666:7777:8888\"));",
          "581:         assertFalse(\"IPV6 :1111:2222::4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::4444:5555:6666:7777:8888\"));",
          "582:         assertFalse(\"IPV6 :1111::4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::4444:5555:6666:7777:8888\"));",
          "583:         assertFalse(\"IPV6 :::4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::4444:5555:6666:7777:8888\"));",
          "584:         assertFalse(\"IPV6 :1111::3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::3333:4444:5555:6666:7777:8888\"));",
          "585:         assertFalse(\"IPV6 :::3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::3333:4444:5555:6666:7777:8888\"));",
          "586:         assertFalse(\"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"));",
          "587:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"));",
          "588:         assertFalse(\"IPV6 :1111:2222:3333:4444:5555::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444:5555::1.2.3.4\"));",
          "589:         assertFalse(\"IPV6 :1111:2222:3333:4444::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::1.2.3.4\"));",
          "590:         assertFalse(\"IPV6 :1111:2222:3333::1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::1.2.3.4\"));",
          "594:         assertFalse(\"IPV6 :1111:2222:3333:4444::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333:4444::6666:1.2.3.4\"));",
          "595:         assertFalse(\"IPV6 :1111:2222:3333::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::6666:1.2.3.4\"));",
          "596:         assertFalse(\"IPV6 :1111:2222::6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222::6666:1.2.3.4\"));",
          "599:         assertFalse(\"IPV6 :1111:2222:3333::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::5555:6666:1.2.3.4\"));",
          "600:         assertFalse(\"IPV6 :1111:2222::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222::5555:6666:1.2.3.4\"));",
          "601:         assertFalse(\"IPV6 :1111::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111::5555:6666:1.2.3.4\"));",
          "602:         assertFalse(\"IPV6 :::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::5555:6666:1.2.3.4\"));",
          "603:         assertFalse(\"IPV6 :1111:2222::4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111:2222::4444:5555:6666:1.2.3.4\"));",
          "604:         assertFalse(\"IPV6 :1111::4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111::4444:5555:6666:1.2.3.4\"));",
          "605:         assertFalse(\"IPV6 :::4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::4444:5555:6666:1.2.3.4\"));",
          "606:         assertFalse(\"IPV6 :1111::3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":1111::3333:4444:5555:6666:1.2.3.4\"));",
          "607:         assertFalse(\"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"));",
          "609:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"));",
          "610:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::\"));",
          "611:         assertFalse(\"IPV6 1111:2222:3333:4444:5555::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::\"));",
          "612:         assertFalse(\"IPV6 1111:2222:3333:4444::: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:::\"));",
          "616:         assertFalse(\"IPV6 1111:2222:3333:4444:5555:6666::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888:\"));",
          "617:         assertFalse(\"IPV6 1111:2222:3333:4444:5555::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888:\"));",
          "618:         assertFalse(\"IPV6 1111:2222:3333:4444::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::8888:\"));",
          "619:         assertFalse(\"IPV6 1111:2222:3333::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::8888:\"));",
          "623:         assertFalse(\"IPV6 1111:2222:3333:4444:5555::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888:\"));",
          "624:         assertFalse(\"IPV6 1111:2222:3333:4444::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888:\"));",
          "625:         assertFalse(\"IPV6 1111:2222:3333::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::7777:8888:\"));",
          "626:         assertFalse(\"IPV6 1111:2222::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::7777:8888:\"));",
          "629:         assertFalse(\"IPV6 1111:2222:3333:4444::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888:\"));",
          "630:         assertFalse(\"IPV6 1111:2222:3333::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888:\"));",
          "631:         assertFalse(\"IPV6 1111:2222::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::6666:7777:8888:\"));",
          "632:         assertFalse(\"IPV6 1111::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::6666:7777:8888:\"));",
          "634:         assertFalse(\"IPV6 1111:2222:3333::5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888:\"));",
          "635:         assertFalse(\"IPV6 1111:2222::5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888:\"));",
          "636:         assertFalse(\"IPV6 1111::5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::5555:6666:7777:8888:\"));",
          "637:         assertFalse(\"IPV6 ::5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"::5555:6666:7777:8888:\"));",
          "638:         assertFalse(\"IPV6 1111:2222::4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888:\"));",
          "639:         assertFalse(\"IPV6 1111::4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888:\"));",
          "640:         assertFalse(\"IPV6 ::4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"::4444:5555:6666:7777:8888:\"));",
          "641:         assertFalse(\"IPV6 1111::3333:4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888:\"));",
          "642:         assertFalse(\"IPV6 ::3333:4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888:\"));",
          "643:         assertFalse(\"IPV6 ::2222:3333:4444:5555:6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:\"));",
          "645:         assertTrue(\"IPV6 ::0:a:b:c:d:e:f should be valid\", validator.isValidInet6Address(\"::0:a:b:c:d:e:f\")); // syntactically correct, but bad form (::0:... could be combined)",
          "",
          "[Added Lines]",
          "937:         assertFalse(",
          "938:                 \"IPV6 :1111:2222:3333:4444:5555:6666:7777:: should be invalid\",",
          "939:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777::\"));",
          "940:         assertFalse(",
          "941:                 \"IPV6 :1111:2222:3333:4444:5555:6666:: should be invalid\",",
          "942:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::\"));",
          "943:         assertFalse(",
          "944:                 \"IPV6 :1111:2222:3333:4444:5555:: should be invalid\",",
          "945:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555::\"));",
          "946:         assertFalse(",
          "947:                 \"IPV6 :1111:2222:3333:4444:: should be invalid\",",
          "948:                 validator.isValidInet6Address(\":1111:2222:3333:4444::\"));",
          "952:         assertFalse(",
          "953:                 \"IPV6 :1111:2222:3333:4444:5555:6666::8888 should be invalid\",",
          "954:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::8888\"));",
          "955:         assertFalse(",
          "956:                 \"IPV6 :1111:2222:3333:4444:5555::8888 should be invalid\",",
          "957:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555::8888\"));",
          "958:         assertFalse(",
          "959:                 \"IPV6 :1111:2222:3333:4444::8888 should be invalid\",",
          "960:                 validator.isValidInet6Address(\":1111:2222:3333:4444::8888\"));",
          "961:         assertFalse(",
          "962:                 \"IPV6 :1111:2222:3333::8888 should be invalid\", validator.isValidInet6Address(\":1111:2222:3333::8888\"));",
          "966:         assertFalse(",
          "967:                 \"IPV6 :1111:2222:3333:4444:5555::7777:8888 should be invalid\",",
          "968:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555::7777:8888\"));",
          "969:         assertFalse(",
          "970:                 \"IPV6 :1111:2222:3333:4444::7777:8888 should be invalid\",",
          "971:                 validator.isValidInet6Address(\":1111:2222:3333:4444::7777:8888\"));",
          "972:         assertFalse(",
          "973:                 \"IPV6 :1111:2222:3333::7777:8888 should be invalid\",",
          "974:                 validator.isValidInet6Address(\":1111:2222:3333::7777:8888\"));",
          "975:         assertFalse(",
          "976:                 \"IPV6 :1111:2222::7777:8888 should be invalid\", validator.isValidInet6Address(\":1111:2222::7777:8888\"));",
          "979:         assertFalse(",
          "980:                 \"IPV6 :1111:2222:3333:4444::6666:7777:8888 should be invalid\",",
          "981:                 validator.isValidInet6Address(\":1111:2222:3333:4444::6666:7777:8888\"));",
          "982:         assertFalse(",
          "983:                 \"IPV6 :1111:2222:3333::6666:7777:8888 should be invalid\",",
          "984:                 validator.isValidInet6Address(\":1111:2222:3333::6666:7777:8888\"));",
          "985:         assertFalse(",
          "986:                 \"IPV6 :1111:2222::6666:7777:8888 should be invalid\",",
          "987:                 validator.isValidInet6Address(\":1111:2222::6666:7777:8888\"));",
          "988:         assertFalse(",
          "989:                 \"IPV6 :1111::6666:7777:8888 should be invalid\", validator.isValidInet6Address(\":1111::6666:7777:8888\"));",
          "991:         assertFalse(",
          "992:                 \"IPV6 :1111:2222:3333::5555:6666:7777:8888 should be invalid\",",
          "993:                 validator.isValidInet6Address(\":1111:2222:3333::5555:6666:7777:8888\"));",
          "994:         assertFalse(",
          "995:                 \"IPV6 :1111:2222::5555:6666:7777:8888 should be invalid\",",
          "996:                 validator.isValidInet6Address(\":1111:2222::5555:6666:7777:8888\"));",
          "997:         assertFalse(",
          "998:                 \"IPV6 :1111::5555:6666:7777:8888 should be invalid\",",
          "999:                 validator.isValidInet6Address(\":1111::5555:6666:7777:8888\"));",
          "1000:         assertFalse(",
          "1001:                 \"IPV6 :::5555:6666:7777:8888 should be invalid\",",
          "1002:                 validator.isValidInet6Address(\":::5555:6666:7777:8888\"));",
          "1003:         assertFalse(",
          "1004:                 \"IPV6 :1111:2222::4444:5555:6666:7777:8888 should be invalid\",",
          "1005:                 validator.isValidInet6Address(\":1111:2222::4444:5555:6666:7777:8888\"));",
          "1006:         assertFalse(",
          "1007:                 \"IPV6 :1111::4444:5555:6666:7777:8888 should be invalid\",",
          "1008:                 validator.isValidInet6Address(\":1111::4444:5555:6666:7777:8888\"));",
          "1009:         assertFalse(",
          "1010:                 \"IPV6 :::4444:5555:6666:7777:8888 should be invalid\",",
          "1011:                 validator.isValidInet6Address(\":::4444:5555:6666:7777:8888\"));",
          "1012:         assertFalse(",
          "1013:                 \"IPV6 :1111::3333:4444:5555:6666:7777:8888 should be invalid\",",
          "1014:                 validator.isValidInet6Address(\":1111::3333:4444:5555:6666:7777:8888\"));",
          "1015:         assertFalse(",
          "1016:                 \"IPV6 :::3333:4444:5555:6666:7777:8888 should be invalid\",",
          "1017:                 validator.isValidInet6Address(\":::3333:4444:5555:6666:7777:8888\"));",
          "1018:         assertFalse(",
          "1019:                 \"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\",",
          "1020:                 validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"));",
          "1021:         assertFalse(",
          "1022:                 \"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "1023:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"));",
          "1024:         assertFalse(",
          "1025:                 \"IPV6 :1111:2222:3333:4444:5555::1.2.3.4 should be invalid\",",
          "1026:                 validator.isValidInet6Address(\":1111:2222:3333:4444:5555::1.2.3.4\"));",
          "1027:         assertFalse(",
          "1028:                 \"IPV6 :1111:2222:3333:4444::1.2.3.4 should be invalid\",",
          "1029:                 validator.isValidInet6Address(\":1111:2222:3333:4444::1.2.3.4\"));",
          "1030:         assertFalse(",
          "1031:                 \"IPV6 :1111:2222:3333::1.2.3.4 should be invalid\",",
          "1032:                 validator.isValidInet6Address(\":1111:2222:3333::1.2.3.4\"));",
          "1036:         assertFalse(",
          "1037:                 \"IPV6 :1111:2222:3333:4444::6666:1.2.3.4 should be invalid\",",
          "1038:                 validator.isValidInet6Address(\":1111:2222:3333:4444::6666:1.2.3.4\"));",
          "1039:         assertFalse(",
          "1040:                 \"IPV6 :1111:2222:3333::6666:1.2.3.4 should be invalid\",",
          "1041:                 validator.isValidInet6Address(\":1111:2222:3333::6666:1.2.3.4\"));",
          "1042:         assertFalse(",
          "1043:                 \"IPV6 :1111:2222::6666:1.2.3.4 should be invalid\",",
          "1044:                 validator.isValidInet6Address(\":1111:2222::6666:1.2.3.4\"));",
          "1047:         assertFalse(",
          "1048:                 \"IPV6 :1111:2222:3333::5555:6666:1.2.3.4 should be invalid\",",
          "1049:                 validator.isValidInet6Address(\":1111:2222:3333::5555:6666:1.2.3.4\"));",
          "1050:         assertFalse(",
          "1051:                 \"IPV6 :1111:2222::5555:6666:1.2.3.4 should be invalid\",",
          "1052:                 validator.isValidInet6Address(\":1111:2222::5555:6666:1.2.3.4\"));",
          "1053:         assertFalse(",
          "1054:                 \"IPV6 :1111::5555:6666:1.2.3.4 should be invalid\",",
          "1055:                 validator.isValidInet6Address(\":1111::5555:6666:1.2.3.4\"));",
          "1056:         assertFalse(",
          "1057:                 \"IPV6 :::5555:6666:1.2.3.4 should be invalid\", validator.isValidInet6Address(\":::5555:6666:1.2.3.4\"));",
          "1058:         assertFalse(",
          "1059:                 \"IPV6 :1111:2222::4444:5555:6666:1.2.3.4 should be invalid\",",
          "1060:                 validator.isValidInet6Address(\":1111:2222::4444:5555:6666:1.2.3.4\"));",
          "1061:         assertFalse(",
          "1062:                 \"IPV6 :1111::4444:5555:6666:1.2.3.4 should be invalid\",",
          "1063:                 validator.isValidInet6Address(\":1111::4444:5555:6666:1.2.3.4\"));",
          "1064:         assertFalse(",
          "1065:                 \"IPV6 :::4444:5555:6666:1.2.3.4 should be invalid\",",
          "1066:                 validator.isValidInet6Address(\":::4444:5555:6666:1.2.3.4\"));",
          "1067:         assertFalse(",
          "1068:                 \"IPV6 :1111::3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "1069:                 validator.isValidInet6Address(\":1111::3333:4444:5555:6666:1.2.3.4\"));",
          "1070:         assertFalse(",
          "1071:                 \"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\",",
          "1072:                 validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"));",
          "1074:         assertFalse(",
          "1075:                 \"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\",",
          "1076:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"));",
          "1077:         assertFalse(",
          "1078:                 \"IPV6 1111:2222:3333:4444:5555:6666::: should be invalid\",",
          "1079:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::\"));",
          "1080:         assertFalse(",
          "1081:                 \"IPV6 1111:2222:3333:4444:5555::: should be invalid\",",
          "1082:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::\"));",
          "1083:         assertFalse(",
          "1084:                 \"IPV6 1111:2222:3333:4444::: should be invalid\",",
          "1085:                 validator.isValidInet6Address(\"1111:2222:3333:4444:::\"));",
          "1089:         assertFalse(",
          "1090:                 \"IPV6 1111:2222:3333:4444:5555:6666::8888: should be invalid\",",
          "1091:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888:\"));",
          "1092:         assertFalse(",
          "1093:                 \"IPV6 1111:2222:3333:4444:5555::8888: should be invalid\",",
          "1094:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888:\"));",
          "1095:         assertFalse(",
          "1096:                 \"IPV6 1111:2222:3333:4444::8888: should be invalid\",",
          "1097:                 validator.isValidInet6Address(\"1111:2222:3333:4444::8888:\"));",
          "1098:         assertFalse(",
          "1099:                 \"IPV6 1111:2222:3333::8888: should be invalid\", validator.isValidInet6Address(\"1111:2222:3333::8888:\"));",
          "1103:         assertFalse(",
          "1104:                 \"IPV6 1111:2222:3333:4444:5555::7777:8888: should be invalid\",",
          "1105:                 validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888:\"));",
          "1106:         assertFalse(",
          "1107:                 \"IPV6 1111:2222:3333:4444::7777:8888: should be invalid\",",
          "1108:                 validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888:\"));",
          "1109:         assertFalse(",
          "1110:                 \"IPV6 1111:2222:3333::7777:8888: should be invalid\",",
          "1111:                 validator.isValidInet6Address(\"1111:2222:3333::7777:8888:\"));",
          "1112:         assertFalse(",
          "1113:                 \"IPV6 1111:2222::7777:8888: should be invalid\", validator.isValidInet6Address(\"1111:2222::7777:8888:\"));",
          "1116:         assertFalse(",
          "1117:                 \"IPV6 1111:2222:3333:4444::6666:7777:8888: should be invalid\",",
          "1118:                 validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888:\"));",
          "1119:         assertFalse(",
          "1120:                 \"IPV6 1111:2222:3333::6666:7777:8888: should be invalid\",",
          "1121:                 validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888:\"));",
          "1122:         assertFalse(",
          "1123:                 \"IPV6 1111:2222::6666:7777:8888: should be invalid\",",
          "1124:                 validator.isValidInet6Address(\"1111:2222::6666:7777:8888:\"));",
          "1125:         assertFalse(",
          "1126:                 \"IPV6 1111::6666:7777:8888: should be invalid\", validator.isValidInet6Address(\"1111::6666:7777:8888:\"));",
          "1128:         assertFalse(",
          "1129:                 \"IPV6 1111:2222:3333::5555:6666:7777:8888: should be invalid\",",
          "1130:                 validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888:\"));",
          "1131:         assertFalse(",
          "1132:                 \"IPV6 1111:2222::5555:6666:7777:8888: should be invalid\",",
          "1133:                 validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888:\"));",
          "1134:         assertFalse(",
          "1135:                 \"IPV6 1111::5555:6666:7777:8888: should be invalid\",",
          "1136:                 validator.isValidInet6Address(\"1111::5555:6666:7777:8888:\"));",
          "1137:         assertFalse(",
          "1138:                 \"IPV6 ::5555:6666:7777:8888: should be invalid\",",
          "1139:                 validator.isValidInet6Address(\"::5555:6666:7777:8888:\"));",
          "1140:         assertFalse(",
          "1141:                 \"IPV6 1111:2222::4444:5555:6666:7777:8888: should be invalid\",",
          "1142:                 validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888:\"));",
          "1143:         assertFalse(",
          "1144:                 \"IPV6 1111::4444:5555:6666:7777:8888: should be invalid\",",
          "1145:                 validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888:\"));",
          "1146:         assertFalse(",
          "1147:                 \"IPV6 ::4444:5555:6666:7777:8888: should be invalid\",",
          "1148:                 validator.isValidInet6Address(\"::4444:5555:6666:7777:8888:\"));",
          "1149:         assertFalse(",
          "1150:                 \"IPV6 1111::3333:4444:5555:6666:7777:8888: should be invalid\",",
          "1151:                 validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888:\"));",
          "1152:         assertFalse(",
          "1153:                 \"IPV6 ::3333:4444:5555:6666:7777:8888: should be invalid\",",
          "1154:                 validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888:\"));",
          "1155:         assertFalse(",
          "1156:                 \"IPV6 ::2222:3333:4444:5555:6666:7777:8888: should be invalid\",",
          "1157:                 validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:\"));",
          "1159:         assertTrue(",
          "1160:                 \"IPV6 ::0:a:b:c:d:e:f should be valid\",",
          "1161:                 validator.isValidInet6Address(",
          "1162:                         \"::0:a:b:c:d:e:f\")); // syntactically correct, but bad form (::0:... could be combined)",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java||src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java -> src/test/java/org/jenkinsci/remoting/org/apache/commons/validator/routines/RegexValidatorTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: public class RegexValidatorTest extends TestCase {",
          "35:     private static final String COMPONENT_1 = \"([abc]{3})\";",
          "36:     private static final String COMPONENT_2 = \"([DEF]{3})\";",
          "37:     private static final String COMPONENT_3 = \"([123]{3})\";",
          "42:     private static final String REGEX_3 = \"^\" + COMPONENT_1 + COMPONENT_2 + COMPONENT_3 + \"$\";",
          "43:     private static final String[] MULTIPLE_REGEX = new String[] {REGEX_1, REGEX_2, REGEX_3};",
          "",
          "[Removed Lines]",
          "33:     private static final String REGEX         = \"^([abc]*)(?:\\\\-)([DEF]*)(?:\\\\-)([123]*)$\";",
          "38:     private static final String SEPARATOR_1  = \"(?:\\\\-)\";",
          "39:     private static final String SEPARATOR_2  = \"(?:\\\\s)\";",
          "40:     private static final String REGEX_1 = \"^\" + COMPONENT_1 + SEPARATOR_1 + COMPONENT_2 + SEPARATOR_1 + COMPONENT_3 + \"$\";",
          "41:     private static final String REGEX_2 = \"^\" + COMPONENT_1 + SEPARATOR_2 + COMPONENT_2 + SEPARATOR_2 + COMPONENT_3 + \"$\";",
          "",
          "[Added Lines]",
          "33:     private static final String REGEX = \"^([abc]*)(?:\\\\-)([DEF]*)(?:\\\\-)([123]*)$\";",
          "38:     private static final String SEPARATOR_1 = \"(?:\\\\-)\";",
          "39:     private static final String SEPARATOR_2 = \"(?:\\\\s)\";",
          "40:     private static final String REGEX_1 =",
          "41:             \"^\" + COMPONENT_1 + SEPARATOR_1 + COMPONENT_2 + SEPARATOR_1 + COMPONENT_3 + \"$\";",
          "42:     private static final String REGEX_2 =",
          "43:             \"^\" + COMPONENT_1 + SEPARATOR_2 + COMPONENT_2 + SEPARATOR_2 + COMPONENT_3 + \"$\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:     public void testSingle() {",
          "58:         RegexValidator insensitive = new RegexValidator(REGEX, false);",
          "",
          "[Removed Lines]",
          "57:         RegexValidator sensitive   = new RegexValidator(REGEX);",
          "",
          "[Added Lines]",
          "59:         RegexValidator sensitive = new RegexValidator(REGEX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:         assertFalse(\"Insensitive isValid() invalid\", insensitive.isValid(\"ABd-de-1\"));",
          "68:         assertNull(\"Sensitive validate() invalid\", sensitive.validate(\"AB-de-1\"));",
          "70:         assertNull(\"Insensitive validate() invalid\", insensitive.validate(\"ABd-de-1\"));",
          "77:         assertEquals(\"validate one\", \"ABC\", (new RegexValidator(\"^([A-Z]*)$\")).validate(\"ABC\"));",
          "78:         checkArray(\"match one\", new String[] {\"ABC\"}, (new RegexValidator(\"^([A-Z]*)$\")).match(\"ABC\"));",
          "79:     }",
          "",
          "[Removed Lines]",
          "67:         assertEquals(\"Sensitive validate() valid\",     \"acDE1\", sensitive.validate(\"ac-DE-1\"));",
          "69:         assertEquals(\"Insensitive validate() valid\",   \"ABde1\", insensitive.validate(\"AB-de-1\"));",
          "73:         checkArray(\"Sensitive match() valid\",     new String[] {\"ac\", \"DE\", \"1\"}, sensitive.match(\"ac-DE-1\"));",
          "74:         checkArray(\"Sensitive match() invalid\",   null,                           sensitive.match(\"AB-de-1\"));",
          "75:         checkArray(\"Insensitive match() valid\",   new String[] {\"AB\", \"de\", \"1\"}, insensitive.match(\"AB-de-1\"));",
          "76:         checkArray(\"Insensitive match() invalid\", null,                           insensitive.match(\"ABd-de-1\"));",
          "",
          "[Added Lines]",
          "69:         assertEquals(\"Sensitive validate() valid\", \"acDE1\", sensitive.validate(\"ac-DE-1\"));",
          "71:         assertEquals(\"Insensitive validate() valid\", \"ABde1\", insensitive.validate(\"AB-de-1\"));",
          "75:         checkArray(\"Sensitive match() valid\", new String[] {\"ac\", \"DE\", \"1\"}, sensitive.match(\"ac-DE-1\"));",
          "76:         checkArray(\"Sensitive match() invalid\", null, sensitive.match(\"AB-de-1\"));",
          "77:         checkArray(\"Insensitive match() valid\", new String[] {\"AB\", \"de\", \"1\"}, insensitive.match(\"AB-de-1\"));",
          "78:         checkArray(\"Insensitive match() invalid\", null, insensitive.match(\"ABd-de-1\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84:     public void testMultipleSensitive() {",
          "93:         String value = \"aac FDE 321\";",
          "",
          "[Removed Lines]",
          "87:         RegexValidator multiple   = new RegexValidator(MULTIPLE_REGEX);",
          "88:         RegexValidator single1   = new RegexValidator(REGEX_1);",
          "89:         RegexValidator single2   = new RegexValidator(REGEX_2);",
          "90:         RegexValidator single3   = new RegexValidator(REGEX_3);",
          "",
          "[Added Lines]",
          "89:         RegexValidator multiple = new RegexValidator(MULTIPLE_REGEX);",
          "90:         RegexValidator single1 = new RegexValidator(REGEX_1);",
          "91:         RegexValidator single2 = new RegexValidator(REGEX_2);",
          "92:         RegexValidator single3 = new RegexValidator(REGEX_3);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "104:         assertEquals(\"Sensitive validate() Multiple\", expect, multiple.validate(value));",
          "105:         assertNull(\"Sensitive validate() 1st\", single1.validate(value));",
          "107:         assertNull(\"Sensitive validate() 3rd\", single3.validate(value));",
          "110:         checkArray(\"Sensitive match() Multiple\", array, multiple.match(value));",
          "116:         value = \"AAC*FDE*321\";",
          "",
          "[Removed Lines]",
          "106:         assertEquals(\"Sensitive validate() 2nd\",      expect, single2.validate(value));",
          "111:         checkArray(\"Sensitive match() 1st\",      null,  single1.match(value));",
          "112:         checkArray(\"Sensitive match() 2nd\",      array, single2.match(value));",
          "113:         checkArray(\"Sensitive match() 3rd\",      null,  single3.match(value));",
          "",
          "[Added Lines]",
          "108:         assertEquals(\"Sensitive validate() 2nd\", expect, single2.validate(value));",
          "113:         checkArray(\"Sensitive match() 1st\", null, single1.match(value));",
          "114:         checkArray(\"Sensitive match() 2nd\", array, single2.match(value));",
          "115:         checkArray(\"Sensitive match() 3rd\", null, single3.match(value));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "128:         RegexValidator multiple = new RegexValidator(MULTIPLE_REGEX, false);",
          "134:         String value = \"AAC FDE 321\";",
          "",
          "[Removed Lines]",
          "129:         RegexValidator single1   = new RegexValidator(REGEX_1, false);",
          "130:         RegexValidator single2   = new RegexValidator(REGEX_2, false);",
          "131:         RegexValidator single3   = new RegexValidator(REGEX_3, false);",
          "",
          "[Added Lines]",
          "131:         RegexValidator single1 = new RegexValidator(REGEX_1, false);",
          "132:         RegexValidator single2 = new RegexValidator(REGEX_2, false);",
          "133:         RegexValidator single3 = new RegexValidator(REGEX_3, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "145:         assertEquals(\"validate() Multiple\", expect, multiple.validate(value));",
          "146:         assertNull(\"validate() 1st\", single1.validate(value));",
          "148:         assertNull(\"validate() 3rd\", single3.validate(value));",
          "151:         checkArray(\"match() Multiple\", array, multiple.match(value));",
          "157:         value = \"AAC*FDE*321\";",
          "",
          "[Removed Lines]",
          "147:         assertEquals(\"validate() 2nd\",      expect, single2.validate(value));",
          "152:         checkArray(\"match() 1st\",      null,  single1.match(value));",
          "153:         checkArray(\"match() 2nd\",      array, single2.match(value));",
          "154:         checkArray(\"match() 3rd\",      null,  single3.match(value));",
          "",
          "[Added Lines]",
          "149:         assertEquals(\"validate() 2nd\", expect, single2.validate(value));",
          "154:         checkArray(\"match() 1st\", null, single1.match(value));",
          "155:         checkArray(\"match() 2nd\", array, single2.match(value));",
          "156:         checkArray(\"match() 3rd\", null, single3.match(value));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "180:         {",
          "183:             assertEquals(\"Single Null\", \"Regular expression[0] is missing\", e.getMessage());",
          "184:         }",
          "187:         {",
          "190:             assertEquals(\"Single Zero Length\", \"Regular expression[0] is missing\", e.getMessage());",
          "191:         }",
          "194:         {",
          "197:             assertEquals(\"Null Array\", \"Regular expressions are missing\", e.getMessage());",
          "198:         }",
          "201:         {",
          "204:             assertEquals(\"Zero Length Array\", \"Regular expressions are missing\", e.getMessage());",
          "205:         }",
          "208:         {",
          "209:             String[] expressions = new String[] {\"ABC\", null};",
          "212:             assertEquals(\"Array has Null\", \"Regular expression[1] is missing\", e.getMessage());",
          "213:         }",
          "216:         {",
          "217:             String[] expressions = new String[] {\"\", \"ABC\"};",
          "220:             assertEquals(\"Array has Zero Length\", \"Regular expression[0] is missing\", e.getMessage());",
          "221:         }",
          "222:     }",
          "",
          "[Removed Lines]",
          "181:             final IllegalArgumentException e = assertThrows(\"Single Null - expected IllegalArgumentException\",",
          "182:                     IllegalArgumentException.class, () -> new RegexValidator((String) null));",
          "188:             final IllegalArgumentException e = assertThrows(\"Single Zero Length - expected IllegalArgumentException\",",
          "189:                     IllegalArgumentException.class, () -> new RegexValidator(\"\"));",
          "195:             final IllegalArgumentException e = assertThrows(\"Null Array - expected IllegalArgumentException\",",
          "196:                     IllegalArgumentException.class, () -> new RegexValidator((String[]) null));",
          "202:             final IllegalArgumentException e = assertThrows(\"Zero Length Array - expected IllegalArgumentException\",",
          "203:                     IllegalArgumentException.class, () -> new RegexValidator(new String[0]));",
          "210:             final IllegalArgumentException e = assertThrows(\"Array has Null - expected IllegalArgumentException\",",
          "211:                     IllegalArgumentException.class, () -> new RegexValidator(expressions));",
          "218:             final IllegalArgumentException e = assertThrows(\"Array has Zero Length - expected IllegalArgumentException\",",
          "219:                     IllegalArgumentException.class, () -> new RegexValidator(expressions));",
          "",
          "[Added Lines]",
          "183:             final IllegalArgumentException e = assertThrows(",
          "184:                     \"Single Null - expected IllegalArgumentException\",",
          "185:                     IllegalArgumentException.class,",
          "186:                     () -> new RegexValidator((String) null));",
          "192:             final IllegalArgumentException e = assertThrows(",
          "193:                     \"Single Zero Length - expected IllegalArgumentException\",",
          "194:                     IllegalArgumentException.class,",
          "195:                     () -> new RegexValidator(\"\"));",
          "201:             final IllegalArgumentException e = assertThrows(",
          "202:                     \"Null Array - expected IllegalArgumentException\",",
          "203:                     IllegalArgumentException.class,",
          "204:                     () -> new RegexValidator((String[]) null));",
          "210:             final IllegalArgumentException e = assertThrows(",
          "211:                     \"Zero Length Array - expected IllegalArgumentException\",",
          "212:                     IllegalArgumentException.class,",
          "213:                     () -> new RegexValidator(new String[0]));",
          "220:             final IllegalArgumentException e = assertThrows(",
          "221:                     \"Array has Null - expected IllegalArgumentException\",",
          "222:                     IllegalArgumentException.class,",
          "223:                     () -> new RegexValidator(expressions));",
          "230:             final IllegalArgumentException e = assertThrows(",
          "231:                     \"Array has Zero Length - expected IllegalArgumentException\",",
          "232:                     IllegalArgumentException.class,",
          "233:                     () -> new RegexValidator(expressions));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java||src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java -> src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcher.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "136:     public void receive(@NonNull ByteBuffer data) {",
          "137:         int r = data.remaining();",
          "138:         if (name != null) {",
          "140:         }",
          "141:         try {",
          "142:             channel.write(data);",
          "",
          "[Removed Lines]",
          "139:             LOGGER.log(Level.INFO, \"[{0}] Receiving {1} bytes\", new Object[]{name, r});",
          "",
          "[Added Lines]",
          "140:             LOGGER.log(Level.INFO, \"[{0}] Receiving {1} bytes\", new Object[] {name, r});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152:         }",
          "153:         if (name != null) {",
          "155:         }",
          "156:     }",
          "",
          "[Removed Lines]",
          "154:             LOGGER.log(Level.INFO, \"[{0}] Received {1} bytes: \u00ab{2}\u00bb\", new Object[]{name, r - data.remaining(), this});",
          "",
          "[Added Lines]",
          "155:             LOGGER.log(Level.INFO, \"[{0}] Received {1} bytes: \u00ab{2}\u00bb\", new Object[] {name, r - data.remaining(), this});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:     @Override",
          "167:     public String toString() {",
          "171:     }",
          "",
          "[Removed Lines]",
          "168:         return \"SimpleBufferReceiver{\" + \"name='\" + name + '\\'' +",
          "169:                 \", content='\" + asString() + '\\'' +",
          "170:                 '}';",
          "",
          "[Added Lines]",
          "169:         return \"SimpleBufferReceiver{\" + \"name='\" + name + '\\'' + \", content='\" + asString() + '\\'' + '}';",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "255:         } finally {",
          "256:             state.unlock();",
          "257:         }",
          "259:     }",
          "263:         long giveUp = System.nanoTime() + unit.toNanos(timeout);",
          "264:         state.lock();",
          "265:         try {",
          "",
          "[Removed Lines]",
          "261:     public boolean awaitByteContent(Matcher<byte[]> matcher, long timeout, TimeUnit unit)",
          "262:             throws InterruptedException {",
          "",
          "[Added Lines]",
          "258:     public boolean awaitByteContent(Matcher<byte[]> matcher, long timeout, TimeUnit unit) throws InterruptedException {",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java||src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java -> src/test/java/org/jenkinsci/remoting/protocol/IOBufferMatcherLayer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:                 doCloseWrite();",
          "58:                 super.close(cause);",
          "59:             }",
          "61:         };",
          "62:     }",
          "64:     @Override",
          "68:     @Override",
          "69:     public IOBufferMatcher get() {",
          "",
          "[Removed Lines]",
          "65:     public void start() {",
          "66:     }",
          "",
          "[Added Lines]",
          "64:     public void start() {}",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java||src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java -> src/test/java/org/jenkinsci/remoting/protocol/IOHubRule.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:     @Override",
          "83:     public Statement apply(final Statement base, final Description description) {",
          "84:         Skip skip = description.getAnnotation(Skip.class);",
          "86:             return base;",
          "87:         }",
          "88:         final AtomicInteger counter = new AtomicInteger();",
          "89:         return new Statement() {",
          "90:             @Override",
          "91:             public void evaluate() throws Throwable {",
          "93:                         r -> new Thread(",
          "94:                                 r,",
          "95:                                 String.format(",
          "96:                                         \"%s%s-%d\",",
          "97:                                         description.getDisplayName(),",
          "98:                                         id == null || id.isEmpty() ? \"\" : \"-\" + id,",
          "101:                 selector = IOHub.create(executorService);",
          "102:                 try {",
          "103:                     base.evaluate();",
          "",
          "[Removed Lines]",
          "85:         if (skip != null && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "92:                 executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2 - 1,",
          "99:                                         counter.incrementAndGet())",
          "100:                         ));",
          "",
          "[Added Lines]",
          "85:         if (skip != null",
          "86:                 && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "93:                 executorService = Executors.newFixedThreadPool(",
          "94:                         Runtime.getRuntime().availableProcessors() * 2 - 1,",
          "101:                                         counter.incrementAndGet())));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java||src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java -> src/test/java/org/jenkinsci/remoting/protocol/IOHubTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:         final AtomicReference<SelectionKey> key = new AtomicReference<>();",
          "101:         final AtomicBoolean oops = new AtomicBoolean(false);",
          "102:         IOHub h = hub.hub();",
          "117:                     }",
          "137:         Socket client = new Socket();",
          "138:         client.connect(srv.getLocalAddress(), 100);",
          "139:         assertThat(IOUtils.toString(client.getInputStream(), StandardCharsets.UTF_8), is(\"Go away #1\"));",
          "",
          "[Removed Lines]",
          "103:         h.register(srv, new IOHubReadyListener() {",
          "105:             final AtomicInteger count = new AtomicInteger(0);",
          "107:             @Override",
          "108:             public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "109:                 if (accept) {",
          "110:                     try {",
          "111:                         SocketChannel channel = srv.accept();",
          "112:                         channel.write(ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "113:                                 .getBytes(StandardCharsets.UTF_8)));",
          "114:                         channel.close();",
          "115:                     } catch (IOException e) {",
          "118:                     h.addInterestAccept(key.get());",
          "119:                 } else {",
          "120:                     oops.set(true);",
          "121:                 }",
          "122:                 if (connect || read || write) {",
          "123:                     oops.set(true);",
          "124:                 }",
          "125:             }",
          "126:         }, true, false, false, false, new IOHubRegistrationCallback() {",
          "127:             @Override",
          "128:             public void onRegistered(SelectionKey selectionKey) {",
          "129:                 key.set(selectionKey);",
          "130:             }",
          "132:             @Override",
          "133:             public void onClosedChannel(ClosedChannelException e) {",
          "135:             }",
          "136:         });",
          "",
          "[Added Lines]",
          "102:         h.register(",
          "103:                 srv,",
          "104:                 new IOHubReadyListener() {",
          "106:                     final AtomicInteger count = new AtomicInteger(0);",
          "108:                     @Override",
          "109:                     public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "110:                         if (accept) {",
          "111:                             try {",
          "112:                                 SocketChannel channel = srv.accept();",
          "113:                                 channel.write(ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "114:                                         .getBytes(StandardCharsets.UTF_8)));",
          "115:                                 channel.close();",
          "116:                             } catch (IOException e) {",
          "118:                             }",
          "119:                             h.addInterestAccept(key.get());",
          "120:                         } else {",
          "121:                             oops.set(true);",
          "122:                         }",
          "123:                         if (connect || read || write) {",
          "124:                             oops.set(true);",
          "125:                         }",
          "126:                     }",
          "127:                 },",
          "128:                 true,",
          "129:                 false,",
          "130:                 false,",
          "131:                 false,",
          "132:                 new IOHubRegistrationCallback() {",
          "133:                     @Override",
          "134:                     public void onRegistered(SelectionKey selectionKey) {",
          "135:                         key.set(selectionKey);",
          "138:                     @Override",
          "139:                     public void onClosedChannel(ClosedChannelException e) {}",
          "140:                 });",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152:         srv.configureBlocking(false);",
          "153:         final AtomicReference<SelectionKey> key = new AtomicReference<>();",
          "154:         final AtomicBoolean oops = new AtomicBoolean(false);",
          "188:         try (Socket client = new Socket()) {",
          "189:             client.setSoTimeout(100);",
          "190:             client.connect(srv.getLocalAddress(), 100);",
          "",
          "[Removed Lines]",
          "155:         hub.hub().register(srv, new IOHubReadyListener() {",
          "157:             final AtomicInteger count = new AtomicInteger(0);",
          "159:             @Override",
          "160:             public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "161:                 if (accept) {",
          "162:                     try {",
          "163:                         SocketChannel channel = srv.accept();",
          "164:                         channel.write(ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "165:                                 .getBytes(StandardCharsets.UTF_8)));",
          "166:                         channel.close();",
          "167:                     } catch (IOException e) {",
          "169:                     }",
          "170:                 } else {",
          "171:                     oops.set(true);",
          "172:                 }",
          "173:                 if (connect || read || write) {",
          "174:                     oops.set(true);",
          "175:                 }",
          "176:             }",
          "177:         }, true, false, false, false, new IOHubRegistrationCallback() {",
          "178:             @Override",
          "179:             public void onRegistered(SelectionKey selectionKey) {",
          "180:                 key.set(selectionKey);",
          "181:             }",
          "183:             @Override",
          "184:             public void onClosedChannel(ClosedChannelException e) {",
          "186:             }",
          "187:         });",
          "",
          "[Added Lines]",
          "159:         hub.hub()",
          "160:                 .register(",
          "161:                         srv,",
          "162:                         new IOHubReadyListener() {",
          "164:                             final AtomicInteger count = new AtomicInteger(0);",
          "166:                             @Override",
          "167:                             public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "168:                                 if (accept) {",
          "169:                                     try {",
          "170:                                         SocketChannel channel = srv.accept();",
          "171:                                         channel.write(",
          "172:                                                 ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "173:                                                         .getBytes(StandardCharsets.UTF_8)));",
          "174:                                         channel.close();",
          "175:                                     } catch (IOException e) {",
          "177:                                     }",
          "178:                                 } else {",
          "179:                                     oops.set(true);",
          "180:                                 }",
          "181:                                 if (connect || read || write) {",
          "182:                                     oops.set(true);",
          "183:                                 }",
          "184:                             }",
          "185:                         },",
          "186:                         true,",
          "187:                         false,",
          "188:                         false,",
          "189:                         false,",
          "190:                         new IOHubRegistrationCallback() {",
          "191:                             @Override",
          "192:                             public void onRegistered(SelectionKey selectionKey) {",
          "193:                                 key.set(selectionKey);",
          "194:                             }",
          "196:                             @Override",
          "197:                             public void onClosedChannel(ClosedChannelException e) {}",
          "198:                         });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:             client.setSoTimeout(100);",
          "195:             client.connect(srv.getLocalAddress(), 100);",
          "199:             assertThat(e.getMessage(), containsString(\"timed out\"));",
          "201:             hub.hub().addInterestAccept(key.get());",
          "",
          "[Removed Lines]",
          "197:             final SocketTimeoutException e = assertThrows(SocketTimeoutException.class,",
          "198:                     () -> assertThat(IOUtils.toString(client.getInputStream(), StandardCharsets.UTF_8), is(\"Go away #2\")));",
          "",
          "[Added Lines]",
          "208:             final SocketTimeoutException e = assertThrows(",
          "209:                     SocketTimeoutException.class,",
          "210:                     () -> assertThat(",
          "211:                             IOUtils.toString(client.getInputStream(), StandardCharsets.UTF_8), is(\"Go away #2\")));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "204:         }",
          "205:     }",
          "208:     @Test",
          "209:     public void noReadyCallbackIfInterestRemoved() throws Exception {",
          "210:         final ServerSocketChannel srv = ServerSocketChannel.open();",
          "",
          "[Removed Lines]",
          "207:     @Ignore(\"TODO flakes: Read timed out; or expected java.net.SocketTimeoutException to be thrown, but nothing was thrown\")",
          "",
          "[Added Lines]",
          "220:     @Ignore(",
          "221:             \"TODO flakes: Read timed out; or expected java.net.SocketTimeoutException to be thrown, but nothing was thrown\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:         final AtomicReference<SelectionKey> key = new AtomicReference<>();",
          "214:         final AtomicBoolean oops = new AtomicBoolean(false);",
          "215:         IOHub h = hub.hub();",
          "230:                     }",
          "252:         while (key.get() == null) {",
          "",
          "[Removed Lines]",
          "216:         h.register(srv, new IOHubReadyListener() {",
          "218:             final AtomicInteger count = new AtomicInteger(0);",
          "220:             @Override",
          "221:             public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "222:                 if (accept) {",
          "223:                     try {",
          "224:                         SocketChannel channel = srv.accept();",
          "225:                         channel.write(ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "226:                                 .getBytes(StandardCharsets.UTF_8)));",
          "227:                         channel.close();",
          "228:                     } catch (IOException e) {",
          "231:                     h.addInterestAccept(key.get());",
          "232:                 } else {",
          "233:                     oops.set(true);",
          "234:                 }",
          "235:                 if (connect || read || write) {",
          "236:                     oops.set(true);",
          "237:                 }",
          "238:             }",
          "239:         }, true, false, false, false, new IOHubRegistrationCallback() {",
          "240:             @Override",
          "241:             public void onRegistered(SelectionKey selectionKey) {",
          "242:                 key.set(selectionKey);",
          "243:             }",
          "245:             @Override",
          "246:             public void onClosedChannel(ClosedChannelException e) {",
          "248:             }",
          "249:         });",
          "",
          "[Added Lines]",
          "230:         h.register(",
          "231:                 srv,",
          "232:                 new IOHubReadyListener() {",
          "234:                     final AtomicInteger count = new AtomicInteger(0);",
          "236:                     @Override",
          "237:                     public void ready(boolean accept, boolean connect, boolean read, boolean write) {",
          "238:                         if (accept) {",
          "239:                             try {",
          "240:                                 SocketChannel channel = srv.accept();",
          "241:                                 channel.write(ByteBuffer.wrap(String.format(\"Go away #%d\", count.incrementAndGet())",
          "242:                                         .getBytes(StandardCharsets.UTF_8)));",
          "243:                                 channel.close();",
          "244:                             } catch (IOException e) {",
          "246:                             }",
          "247:                             h.addInterestAccept(key.get());",
          "248:                         } else {",
          "249:                             oops.set(true);",
          "250:                         }",
          "251:                         if (connect || read || write) {",
          "252:                             oops.set(true);",
          "253:                         }",
          "254:                     }",
          "255:                 },",
          "256:                 true,",
          "257:                 false,",
          "258:                 false,",
          "259:                 false,",
          "260:                 new IOHubRegistrationCallback() {",
          "261:                     @Override",
          "262:                     public void onRegistered(SelectionKey selectionKey) {",
          "263:                         key.set(selectionKey);",
          "266:                     @Override",
          "267:                     public void onClosedChannel(ClosedChannelException e) {}",
          "268:                 });",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "267:             client.setSoTimeout(100);",
          "268:             client.connect(srv.getLocalAddress(), 100);",
          "272:             assertThat(e.getMessage(), containsString(\"timed out\"));",
          "274:             h.addInterestAccept(key.get());",
          "",
          "[Removed Lines]",
          "270:             final SocketTimeoutException e = assertThrows(SocketTimeoutException.class,",
          "271:                     () -> assertThat(IOUtils.toString(client.getInputStream(), StandardCharsets.UTF_8), is(\"Go away #2\")));",
          "",
          "[Added Lines]",
          "289:             final SocketTimeoutException e = assertThrows(",
          "290:                     SocketTimeoutException.class,",
          "291:                     () -> assertThat(",
          "292:                             IOUtils.toString(client.getInputStream(), StandardCharsets.UTF_8), is(\"Go away #2\")));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java||src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java -> src/test/java/org/jenkinsci/remoting/protocol/NetworkLayerFactory.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: public interface NetworkLayerFactory {",
          "38:     class NIO implements NetworkLayerFactory {",
          "",
          "[Removed Lines]",
          "33:     NetworkLayerFactory[] ALL = new NetworkLayerFactory[]{new NIO(), new BIO()};",
          "35:     NetworkLayer create(IOHub selector, ReadableByteChannel in,",
          "36:                         WritableByteChannel out);",
          "",
          "[Added Lines]",
          "33:     NetworkLayerFactory[] ALL = new NetworkLayerFactory[] {new NIO(), new BIO()};",
          "35:     NetworkLayer create(IOHub selector, ReadableByteChannel in, WritableByteChannel out);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java -> src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackImplTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     @Rule",
          "71:     public IOHubRule selector = new IOHubRule();",
          "72:     @Rule",
          "73:     public TestName name = new TestName();",
          "74:     private static RSAKeyPairRule keys = new RSAKeyPairRule();",
          "75:     private static X509CertificateRule certificate = X509CertificateRule.selfSigned(keys);",
          "77:     @ClassRule",
          "81:     @Rule",
          "85:     @Test",
          "86:     public void basicReadthrough() throws Exception {",
          "87:         Pipe input = Pipe.open();",
          "88:         Pipe output = Pipe.open();",
          "93:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "94:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "95:         data.put(expected);",
          "",
          "[Removed Lines]",
          "76:     private static SSLContextRule context = new SSLContextRule().as(keys, certificate).trusting(certificate);",
          "78:     public static RuleChain staticCtx = RuleChain.outerRule(keys)",
          "79:             .around(certificate)",
          "80:             .around(context);",
          "82:     public RuleChain ctx = RuleChain.outerRule(new RepeatRule())",
          "83:             .around(new Timeout(60, TimeUnit.SECONDS));",
          "90:         ProtocolStack<IOBufferMatcher> instance =",
          "91:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), input.source(), output.sink()))",
          "92:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "78:     private static SSLContextRule context =",
          "79:             new SSLContextRule().as(keys, certificate).trusting(certificate);",
          "82:     public static RuleChain staticCtx =",
          "83:             RuleChain.outerRule(keys).around(certificate).around(context);",
          "86:     public RuleChain ctx = RuleChain.outerRule(new RepeatRule()).around(new Timeout(60, TimeUnit.SECONDS));",
          "93:         ProtocolStack<IOBufferMatcher> instance = ProtocolStack.on(",
          "94:                         new BIONetworkLayer(selector.hub(), input.source(), output.sink()))",
          "95:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107:         Pipe input = Pipe.open();",
          "108:         Pipe output = Pipe.open();",
          "113:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "114:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "115:         data.put(expected);",
          "",
          "[Removed Lines]",
          "110:         ProtocolStack<IOBufferMatcher> instance =",
          "111:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), input.source(), output.sink()))",
          "112:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "113:         ProtocolStack<IOBufferMatcher> instance = ProtocolStack.on(",
          "114:                         new BIONetworkLayer(selector.hub(), input.source(), output.sink()))",
          "115:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198:     public void pipeBasicBackToBack() throws Exception {",
          "199:         Pipe eastToWest = Pipe.open();",
          "200:         Pipe westToEast = Pipe.open();",
          "208:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "209:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "210:         data.put(expected);",
          "",
          "[Removed Lines]",
          "201:         ProtocolStack<IOBufferMatcher> east =",
          "202:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "203:                         .build(new IOBufferMatcherLayer());",
          "205:         ProtocolStack<IOBufferMatcher> west =",
          "206:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "207:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "204:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "205:                         new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "206:                 .build(new IOBufferMatcherLayer());",
          "208:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "209:                         new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "210:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "223:         SocketChannel westChannel = SocketChannel.open();",
          "224:         westChannel.connect(eastServer.getLocalAddress());",
          "225:         SocketChannel eastChannel = eastServer.accept();",
          "233:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "234:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "235:         data.put(expected);",
          "",
          "[Removed Lines]",
          "226:         ProtocolStack<IOBufferMatcher> east =",
          "227:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "228:                         .build(new IOBufferMatcherLayer());",
          "230:         ProtocolStack<IOBufferMatcher> west =",
          "231:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "232:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "229:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "230:                         new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "231:                 .build(new IOBufferMatcherLayer());",
          "233:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "234:                         new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "235:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "245:     public void pipeBasicBackToBackWithAck() throws Exception {",
          "246:         Pipe eastToWest = Pipe.open();",
          "247:         Pipe westToEast = Pipe.open();",
          "259:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "260:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "248:         ProtocolStack<IOBufferMatcher> east =",
          "249:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "250:                         .filter(new AckFilterLayer())",
          "251:                         .build(new IOBufferMatcherLayer());",
          "254:         ProtocolStack<IOBufferMatcher> west =",
          "255:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "256:                         .filter(new AckFilterLayer())",
          "257:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "251:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "252:                         new NIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "253:                 .filter(new AckFilterLayer())",
          "254:                 .build(new IOBufferMatcherLayer());",
          "256:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "257:                         new NIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "258:                 .filter(new AckFilterLayer())",
          "259:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "274:         SocketChannel westChannel = SocketChannel.open();",
          "275:         westChannel.connect(eastServer.getLocalAddress());",
          "276:         SocketChannel eastChannel = eastServer.accept();",
          "288:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "289:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "277:         ProtocolStack<IOBufferMatcher> east =",
          "278:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "279:                         .filter(new AckFilterLayer())",
          "280:                         .build(new IOBufferMatcherLayer());",
          "283:         ProtocolStack<IOBufferMatcher> west =",
          "284:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "285:                         .filter(new AckFilterLayer())",
          "286:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "279:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "280:                         new NIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "281:                 .filter(new AckFilterLayer())",
          "282:                 .build(new IOBufferMatcherLayer());",
          "284:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "285:                         new NIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "286:                 .filter(new AckFilterLayer())",
          "287:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "306:         SSLEngine eastEngine = context.createSSLEngine();",
          "307:         eastEngine.setUseClientMode(true);",
          "322:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "323:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "309:         ProtocolStack<IOBufferMatcher> east =",
          "310:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "311:                         .filter(new AckFilterLayer())",
          "312:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "313:                         .build(new IOBufferMatcherLayer());",
          "316:         ProtocolStack<IOBufferMatcher> west =",
          "317:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "318:                         .filter(new AckFilterLayer())",
          "319:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "320:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "310:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "311:                         new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "312:                 .filter(new AckFilterLayer())",
          "313:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "314:                 .build(new IOBufferMatcherLayer());",
          "316:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "317:                         new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "318:                 .filter(new AckFilterLayer())",
          "319:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "320:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "343:         SSLEngine eastEngine = context.createSSLEngine();",
          "344:         eastEngine.setUseClientMode(true);",
          "359:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "360:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "346:         ProtocolStack<IOBufferMatcher> east =",
          "347:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "348:                         .filter(new AckFilterLayer())",
          "349:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "350:                         .build(new IOBufferMatcherLayer());",
          "353:         ProtocolStack<IOBufferMatcher> west =",
          "354:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "355:                         .filter(new AckFilterLayer())",
          "356:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "357:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "346:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "347:                         new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "348:                 .filter(new AckFilterLayer())",
          "349:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "350:                 .build(new IOBufferMatcherLayer());",
          "352:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "353:                         new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "354:                 .filter(new AckFilterLayer())",
          "355:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "356:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "377:         SSLEngine eastEngine = context.createSSLEngine();",
          "378:         eastEngine.setUseClientMode(true);",
          "397:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "398:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "380:         ProtocolStack<IOBufferMatcher> east =",
          "381:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "382:                         .filter(new AckFilterLayer())",
          "383:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "384:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "385:                                 headers -> {}))",
          "386:                         .build(new IOBufferMatcherLayer());",
          "389:         ProtocolStack<IOBufferMatcher> west =",
          "390:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "391:                         .filter(new AckFilterLayer())",
          "392:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "393:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "394:                                 headers -> {}))",
          "395:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "379:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "380:                         new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "381:                 .filter(new AckFilterLayer())",
          "382:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "383:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "384:                 .build(new IOBufferMatcherLayer());",
          "386:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "387:                         new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "388:                 .filter(new AckFilterLayer())",
          "389:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "390:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "391:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "418:         SSLEngine eastEngine = context.createSSLEngine();",
          "419:         eastEngine.setUseClientMode(true);",
          "438:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "439:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "421:         ProtocolStack<IOBufferMatcher> east =",
          "422:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "423:                         .filter(new AckFilterLayer())",
          "424:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "425:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "426:                                 headers -> {}))",
          "427:                         .build(new IOBufferMatcherLayer());",
          "430:         ProtocolStack<IOBufferMatcher> west =",
          "431:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "432:                         .filter(new AckFilterLayer())",
          "433:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "434:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "435:                                 headers -> {}))",
          "436:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "417:         ProtocolStack<IOBufferMatcher> east = ProtocolStack.on(",
          "418:                         new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "419:                 .filter(new AckFilterLayer())",
          "420:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "421:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "422:                 .build(new IOBufferMatcherLayer());",
          "424:         ProtocolStack<IOBufferMatcher> west = ProtocolStack.on(",
          "425:                         new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "426:                 .filter(new AckFilterLayer())",
          "427:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "428:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "429:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "456:         SSLEngine eastEngine = context.createSSLEngine();",
          "457:         eastEngine.setUseClientMode(true);",
          "474:         east.get().get().call(new ProbeCallable());",
          "475:         west.get().get().call(new ProbeCallable());",
          "476:         west.get().get().close();",
          "",
          "[Removed Lines]",
          "459:         ProtocolStack<Future<Channel>> east =",
          "460:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "461:                         .filter(new AckFilterLayer())",
          "462:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "463:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "464:                                 headers -> {}))",
          "465:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "467:         ProtocolStack<Future<Channel>> west =",
          "468:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "469:                         .filter(new AckFilterLayer())",
          "470:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "471:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "472:                                 headers -> {}))",
          "473:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "[Added Lines]",
          "452:         ProtocolStack<Future<Channel>> east = ProtocolStack.on(",
          "453:                         new BIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "454:                 .filter(new AckFilterLayer())",
          "455:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "456:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "457:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "459:         ProtocolStack<Future<Channel>> west = ProtocolStack.on(",
          "460:                         new BIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "461:                 .filter(new AckFilterLayer())",
          "462:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "463:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "464:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "490:         SSLEngine eastEngine = context.createSSLEngine();",
          "491:         eastEngine.setUseClientMode(true);",
          "510:         east.get().get().call(new ProbeCallable());",
          "511:         west.get().get().call(new ProbeCallable());",
          "512:         west.get().get().close();",
          "",
          "[Removed Lines]",
          "493:         ProtocolStack<Future<Channel>> east =",
          "494:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "495:                         .named(\"east\")",
          "496:                         .filter(new AckFilterLayer())",
          "497:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "498:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "499:                                 headers -> {}))",
          "500:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "502:         ProtocolStack<Future<Channel>> west =",
          "503:                 ProtocolStack.on(new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "504:                         .named(\"west\")",
          "505:                         .filter(new AckFilterLayer())",
          "506:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "507:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "508:                                 headers -> {}))",
          "509:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "[Added Lines]",
          "484:         ProtocolStack<Future<Channel>> east = ProtocolStack.on(",
          "485:                         new BIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "486:                 .named(\"east\")",
          "487:                 .filter(new AckFilterLayer())",
          "488:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "489:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "490:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "492:         ProtocolStack<Future<Channel>> west = ProtocolStack.on(",
          "493:                         new BIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "494:                 .named(\"west\")",
          "495:                 .filter(new AckFilterLayer())",
          "496:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "497:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "498:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "523:         SSLEngine eastEngine = context.createSSLEngine();",
          "524:         eastEngine.setUseClientMode(true);",
          "541:         east.get().get().call(new ProbeCallable());",
          "542:         west.get().get().call(new ProbeCallable());",
          "543:         west.get().get().close();",
          "544:         east.get().get().close();",
          "546:     }",
          "548:     @Test",
          "",
          "[Removed Lines]",
          "526:         ProtocolStack<Future<Channel>> east =",
          "527:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "528:                         .filter(new AckFilterLayer())",
          "529:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "530:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "531:                                 headers -> {}))",
          "532:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "534:         ProtocolStack<Future<Channel>> west =",
          "535:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "536:                         .filter(new AckFilterLayer())",
          "537:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "538:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "539:                                 headers -> {}))",
          "540:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "[Added Lines]",
          "515:         ProtocolStack<Future<Channel>> east = ProtocolStack.on(",
          "516:                         new NIONetworkLayer(selector.hub(), westToEast.source(), eastToWest.sink()))",
          "517:                 .filter(new AckFilterLayer())",
          "518:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "519:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "520:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "522:         ProtocolStack<Future<Channel>> west = ProtocolStack.on(",
          "523:                         new NIONetworkLayer(selector.hub(), eastToWest.source(), westToEast.sink()))",
          "524:                 .filter(new AckFilterLayer())",
          "525:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "526:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "527:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "558:         SSLEngine eastEngine = context.createSSLEngine();",
          "559:         eastEngine.setUseClientMode(true);",
          "576:         east.get().get().call(new ProbeCallable());",
          "577:         west.get().get().call(new ProbeCallable());",
          "578:         west.get().get().close();",
          "579:         east.get().get().close();",
          "581:     }",
          "583:     @Test",
          "",
          "[Removed Lines]",
          "561:         ProtocolStack<Future<Channel>> east =",
          "562:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "563:                         .filter(new AckFilterLayer())",
          "564:                         .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "565:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"),",
          "566:                                 headers -> {}))",
          "567:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "569:         ProtocolStack<Future<Channel>> west =",
          "570:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "571:                         .filter(new AckFilterLayer())",
          "572:                         .filter(new SSLEngineFilterLayer(westEngine, null))",
          "573:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"),",
          "574:                                 headers -> {}))",
          "575:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "[Added Lines]",
          "547:         ProtocolStack<Future<Channel>> east = ProtocolStack.on(",
          "548:                         new NIONetworkLayer(selector.hub(), eastChannel, eastChannel))",
          "549:                 .filter(new AckFilterLayer())",
          "550:                 .filter(new SSLEngineFilterLayer(eastEngine, null))",
          "551:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"east\"), headers -> {}))",
          "552:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "554:         ProtocolStack<Future<Channel>> west = ProtocolStack.on(",
          "555:                         new NIONetworkLayer(selector.hub(), westChannel, westChannel))",
          "556:                 .filter(new AckFilterLayer())",
          "557:                 .filter(new SSLEngineFilterLayer(westEngine, null))",
          "558:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"west\"), headers -> {}))",
          "559:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "591:         SSLEngine clientEngine = context.createSSLEngine();",
          "592:         clientEngine.setUseClientMode(true);",
          "616:         assertThat(ce.getCause(), instanceOf(ConnectionRefusalException.class));",
          "622:     }",
          "624:     @Test",
          "",
          "[Removed Lines]",
          "594:         ProtocolStack<Future<Channel>> client =",
          "595:                 ProtocolStack",
          "596:                         .on(new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "597:                         .filter(new AckFilterLayer())",
          "598:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "599:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "600:                                 headers -> {",
          "601:                                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "602:                                 }))",
          "603:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "605:         ProtocolStack<Future<Channel>> server =",
          "606:                 ProtocolStack",
          "607:                         .on(new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "608:                         .filter(new AckFilterLayer())",
          "609:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "610:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "611:                                 headers -> {}))",
          "612:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "614:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "615:                 () -> client.get().get().call(new ProbeCallable()));",
          "618:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "619:                 () -> server.get().get().call(new ProbeCallable()));",
          "620:         assertThat(se.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "621:                 ClosedChannelException.class)));",
          "",
          "[Added Lines]",
          "577:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "578:                         new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "579:                 .filter(new AckFilterLayer())",
          "580:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "581:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {",
          "582:                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "583:                 }))",
          "584:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "586:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "587:                         new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "588:                 .filter(new AckFilterLayer())",
          "589:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "590:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {}))",
          "591:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "593:         final ExecutionException ce =",
          "594:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "595:                         .get()",
          "596:                         .call(new ProbeCallable()));",
          "599:         final ExecutionException se =",
          "600:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "601:                         .get()",
          "602:                         .call(new ProbeCallable()));",
          "603:         assertThat(",
          "604:                 se.getCause(),",
          "605:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "635:         SSLEngine clientEngine = context.createSSLEngine();",
          "636:         clientEngine.setUseClientMode(true);",
          "658:         assertThat(ce.getCause(), instanceOf(ConnectionRefusalException.class));",
          "664:     }",
          "666:     @Test",
          "",
          "[Removed Lines]",
          "638:         ProtocolStack<Future<Channel>> client =",
          "639:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "640:                         .filter(new AckFilterLayer())",
          "641:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "642:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "643:                                 headers -> {",
          "644:                                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "645:                                 }))",
          "646:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "648:         ProtocolStack<Future<Channel>> server =",
          "649:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "650:                         .filter(new AckFilterLayer())",
          "651:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "652:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "653:                                 headers -> {}))",
          "654:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "656:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "657:                 () -> client.get().get().call(new ProbeCallable()));",
          "660:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "661:                 () -> server.get().get().call(new ProbeCallable()));",
          "662:         assertThat(se.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "663:                 ClosedChannelException.class)));",
          "",
          "[Added Lines]",
          "622:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "623:                         new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "624:                 .filter(new AckFilterLayer())",
          "625:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "626:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {",
          "627:                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "628:                 }))",
          "629:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "631:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "632:                         new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "633:                 .filter(new AckFilterLayer())",
          "634:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "635:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {}))",
          "636:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "638:         final ExecutionException ce =",
          "639:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "640:                         .get()",
          "641:                         .call(new ProbeCallable()));",
          "644:         final ExecutionException se =",
          "645:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "646:                         .get()",
          "647:                         .call(new ProbeCallable()));",
          "648:         assertThat(",
          "649:                 se.getCause(),",
          "650:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "674:         SSLEngine clientEngine = context.createSSLEngine();",
          "675:         clientEngine.setUseClientMode(true);",
          "704:         assertThat(se.getCause(), instanceOf(ConnectionRefusalException.class));",
          "705:     }",
          "",
          "[Removed Lines]",
          "677:         ProtocolStack<Future<Channel>> client =",
          "678:                 ProtocolStack",
          "679:                         .on(new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "680:                         .filter(new AckFilterLayer())",
          "681:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "682:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "683:                                 headers -> {}))",
          "684:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "686:         ProtocolStack<Future<Channel>> server =",
          "687:                 ProtocolStack",
          "688:                         .on(new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "689:                         .filter(new AckFilterLayer())",
          "690:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "691:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "692:                                 headers -> {",
          "693:                                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "694:                                 }))",
          "695:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "697:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "698:                 () -> client.get().get().call(new ProbeCallable()));",
          "699:         assertThat(ce.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "700:                 ClosedChannelException.class)));",
          "702:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "703:                 () -> server.get().get().call(new ProbeCallable()));",
          "",
          "[Added Lines]",
          "664:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "665:                         new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "666:                 .filter(new AckFilterLayer())",
          "667:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "668:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {}))",
          "669:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "671:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "672:                         new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "673:                 .filter(new AckFilterLayer())",
          "674:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "675:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {",
          "676:                     throw new ConnectionRefusalException(\"I don't like you, Mr. Server\");",
          "677:                 }))",
          "678:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "680:         final ExecutionException ce =",
          "681:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "682:                         .get()",
          "683:                         .call(new ProbeCallable()));",
          "684:         assertThat(",
          "685:                 ce.getCause(),",
          "686:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "688:         final ExecutionException se =",
          "689:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "690:                         .get()",
          "691:                         .call(new ProbeCallable()));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "718:         SSLEngine clientEngine = context.createSSLEngine();",
          "719:         clientEngine.setUseClientMode(true);",
          "746:         assertThat(se.getCause(), instanceOf(ConnectionRefusalException.class));",
          "747:     }",
          "",
          "[Removed Lines]",
          "721:         ProtocolStack<Future<Channel>> client =",
          "722:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "723:                         .filter(new AckFilterLayer())",
          "724:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "725:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "726:                                 headers -> {}))",
          "727:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "729:         ProtocolStack<Future<Channel>> server =",
          "730:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "731:                         .filter(new AckFilterLayer())",
          "732:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "733:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "734:                                 headers -> {",
          "735:                                     throw new ConnectionRefusalException(\"I don't like you, Mr. Client\");",
          "736:                                 }))",
          "737:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "739:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "740:                 () -> client.get().get().call(new ProbeCallable()));",
          "741:         assertThat(ce.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "742:                 ClosedChannelException.class)));",
          "744:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "745:                 () -> server.get().get().call(new ProbeCallable()));",
          "",
          "[Added Lines]",
          "709:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "710:                         new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "711:                 .filter(new AckFilterLayer())",
          "712:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "713:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {}))",
          "714:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "716:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "717:                         new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "718:                 .filter(new AckFilterLayer())",
          "719:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "720:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {",
          "721:                     throw new ConnectionRefusalException(\"I don't like you, Mr. Client\");",
          "722:                 }))",
          "723:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "725:         final ExecutionException ce =",
          "726:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "727:                         .get()",
          "728:                         .call(new ProbeCallable()));",
          "729:         assertThat(",
          "730:                 ce.getCause(),",
          "731:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "733:         final ExecutionException se =",
          "734:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "735:                         .get()",
          "736:                         .call(new ProbeCallable()));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "759:         clientEngine.setUseClientMode(true);",
          "761:         HoldFilterLayer clientHold = new HoldFilterLayer();",
          "772:         HoldFilterLayer serverHold = new HoldFilterLayer();",
          "782:         clientHold.release();",
          "783:         serverHold.release();",
          "794:     }",
          "797:     @Test",
          "798:     @Repeat(16)",
          "799:     public void socketChannelFullProtocolNIO_invalidAck() throws Exception {",
          "",
          "[Removed Lines]",
          "762:         ProtocolStack<Future<Channel>> client =",
          "763:                 ProtocolStack",
          "764:                         .on(new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "765:                         .filter(clientHold)",
          "766:                         .filter(new AckFilterLayer())",
          "767:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "768:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "769:                                 headers -> {}))",
          "770:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "773:         ProtocolStack<Future<Channel>> server =",
          "774:                 ProtocolStack",
          "775:                         .on(new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "776:                         .filter(serverHold)",
          "777:                         .filter(new AckFilterLayer(\"ACk\"))",
          "778:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "779:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "780:                                 headers -> {}))",
          "781:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "785:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "786:                 () -> client.get().get().call(new ProbeCallable()));",
          "787:         assertThat(ce.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "788:                 ClosedChannelException.class)));",
          "790:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "791:                 () -> server.get().get().call(new ProbeCallable()));",
          "792:         assertThat(se.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "793:                 ClosedChannelException.class)));",
          "796:     @Ignore(\"TODO flake: ConnectionRefusalException: Incorrect acknowledgement received, expected 0x000341436b got 0x0000000000\")",
          "",
          "[Added Lines]",
          "753:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "754:                         new NIONetworkLayer(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "755:                 .filter(clientHold)",
          "756:                 .filter(new AckFilterLayer())",
          "757:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "758:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {}))",
          "759:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "762:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "763:                         new NIONetworkLayer(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "764:                 .filter(serverHold)",
          "765:                 .filter(new AckFilterLayer(\"ACk\"))",
          "766:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "767:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {}))",
          "768:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "772:         final ExecutionException ce =",
          "773:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "774:                         .get()",
          "775:                         .call(new ProbeCallable()));",
          "776:         assertThat(",
          "777:                 ce.getCause(),",
          "778:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "780:         final ExecutionException se =",
          "781:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "782:                         .get()",
          "783:                         .call(new ProbeCallable()));",
          "784:         assertThat(",
          "785:                 se.getCause(),",
          "786:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "789:     @Ignore(",
          "790:             \"TODO flake: ConnectionRefusalException: Incorrect acknowledgement received, expected 0x000341436b got 0x0000000000\")",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "809:         clientEngine.setUseClientMode(true);",
          "811:         HoldFilterLayer clientHold = new HoldFilterLayer();",
          "821:         HoldFilterLayer serverHold = new HoldFilterLayer();",
          "830:         clientHold.release();",
          "831:         serverHold.release();",
          "842:     }",
          "844:     private static class ProbeCallable implements Callable<String, IOException> {",
          "",
          "[Removed Lines]",
          "812:         ProtocolStack<Future<Channel>> client =",
          "813:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "814:                         .filter(clientHold)",
          "815:                         .filter(new AckFilterLayer())",
          "816:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "817:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "818:                                 headers -> {}))",
          "819:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "822:         ProtocolStack<Future<Channel>> server =",
          "823:                 ProtocolStack.on(new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "824:                         .filter(serverHold)",
          "825:                         .filter(new AckFilterLayer(\"ACk\"))",
          "826:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "827:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "828:                                 headers -> {}))",
          "829:                         .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "833:         final ExecutionException ce = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "834:                 () -> client.get().get().call(new ProbeCallable()));",
          "835:         assertThat(ce.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "836:                 ClosedChannelException.class)));",
          "838:         final ExecutionException se = assertThrows(\"Expected Connection refusal\", ExecutionException.class,",
          "839:                 () -> server.get().get().call(new ProbeCallable()));",
          "840:         assertThat(se.getCause(), anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(",
          "841:                 ClosedChannelException.class)));",
          "",
          "[Added Lines]",
          "806:         ProtocolStack<Future<Channel>> client = ProtocolStack.on(",
          "807:                         new NIONetworkLayer(selector.hub(), clientSocketChannel, clientSocketChannel))",
          "808:                 .filter(clientHold)",
          "809:                 .filter(new AckFilterLayer())",
          "810:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "811:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {}))",
          "812:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "815:         ProtocolStack<Future<Channel>> server = ProtocolStack.on(",
          "816:                         new NIONetworkLayer(selector.hub(), serverSocketChannel, serverSocketChannel))",
          "817:                 .filter(serverHold)",
          "818:                 .filter(new AckFilterLayer(\"ACk\"))",
          "819:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "820:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {}))",
          "821:                 .build(new ChannelApplicationLayer(selector.executorService(), null));",
          "825:         final ExecutionException ce =",
          "826:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> client.get()",
          "827:                         .get()",
          "828:                         .call(new ProbeCallable()));",
          "829:         assertThat(",
          "830:                 ce.getCause(),",
          "831:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "833:         final ExecutionException se =",
          "834:                 assertThrows(\"Expected Connection refusal\", ExecutionException.class, () -> server.get()",
          "835:                         .get()",
          "836:                         .call(new ProbeCallable()));",
          "837:         assertThat(",
          "838:                 se.getCause(),",
          "839:                 anyOf(instanceOf(ConnectionRefusalException.class), instanceOf(ClosedChannelException.class)));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "849:         }",
          "851:         @Override",
          "855:         private static final long serialVersionUID = 1L;",
          "856:     }",
          "858: }",
          "",
          "[Removed Lines]",
          "852:         public void checkRoles(RoleChecker checker) throws SecurityException {",
          "854:         }",
          "",
          "[Added Lines]",
          "850:         public void checkRoles(RoleChecker checker) throws SecurityException {}",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java -> src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackLoopbackLoadStress.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:     public ProtocolStackLoopbackLoadStress(boolean nio, boolean ssl)",
          "111:             throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException,",
          "113:         KeyPairGenerator gen = KeyPairGenerator.getInstance(\"RSA\");",
          "114:         gen.initialize(2048); // maximum supported by JVM with export restrictions",
          "115:         KeyPair keyPair = gen.generateKeyPair();",
          "",
          "[Removed Lines]",
          "112:             UnrecoverableKeyException, KeyManagementException, OperatorCreationException {",
          "",
          "[Added Lines]",
          "112:                     UnrecoverableKeyException, KeyManagementException, OperatorCreationException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:                 .build();",
          "130:         X509v3CertificateBuilder certGen = new X509v3CertificateBuilder(",
          "139:         JcaX509ExtensionUtils instance = new JcaX509ExtensionUtils();",
          "146:         ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\")",
          "147:                 .setProvider(BOUNCY_CASTLE_PROVIDER)",
          "",
          "[Removed Lines]",
          "131:                 subject,",
          "132:                 BigInteger.ONE,",
          "133:                 firstDate,",
          "134:                 lastDate,",
          "135:                 subject,",
          "136:                 subjectPublicKeyInfo",
          "137:         );",
          "141:         certGen.addExtension(Extension.subjectKeyIdentifier,",
          "142:                 false,",
          "143:                 instance.createSubjectKeyIdentifier(subjectPublicKeyInfo)",
          "144:         );",
          "",
          "[Added Lines]",
          "131:                 subject, BigInteger.ONE, firstDate, lastDate, subject, subjectPublicKeyInfo);",
          "135:         certGen.addExtension(",
          "136:                 Extension.subjectKeyIdentifier, false, instance.createSubjectKeyIdentifier(subjectPublicKeyInfo));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156:         KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());",
          "157:         store.load(null, password);",
          "160:         KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",
          "161:         kmf.init(store, password);",
          "163:         context = SSLContext.getInstance(\"TLS\");",
          "167:         hub = IOHub.create(executorService);",
          "168:         serverSocketChannel = ServerSocketChannel.open();",
          "",
          "[Removed Lines]",
          "158:         store.setKeyEntry(\"alias\", keyPair.getPrivate(), password, new Certificate[]{certificate});",
          "164:         context.init(kmf.getKeyManagers(),",
          "165:                 new TrustManager[]{new PublicKeyMatchingX509ExtendedTrustManager(keyPair.getPublic())}, null);",
          "",
          "[Added Lines]",
          "150:         store.setKeyEntry(\"alias\", keyPair.getPrivate(), password, new Certificate[] {certificate});",
          "156:         context.init(",
          "157:                 kmf.getKeyManagers(),",
          "158:                 new TrustManager[] {new PublicKeyMatchingX509ExtendedTrustManager(keyPair.getPublic())},",
          "159:                 null);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "187:         }",
          "189:         @Override",
          "193:         private static final long serialVersionUID = 1L;",
          "194:     }",
          "",
          "[Removed Lines]",
          "190:         public void checkRoles(RoleChecker checker) throws SecurityException {",
          "192:         }",
          "",
          "[Added Lines]",
          "184:         public void checkRoles(RoleChecker checker) throws SecurityException {}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "213:                     SSLEngine sslEngine = context.createSSLEngine();",
          "214:                     sslEngine.setUseClientMode(false);",
          "215:                     sslEngine.setNeedClientAuth(true);",
          "218:                             .named(String.format(\"Serving client %s\", fromClient.toString()))",
          "219:                             .filter(new AckFilterLayer())",
          "220:                             .filter(ssl ? new SSLEngineFilterLayer(sslEngine, null) : null)",
          "223:                             .build(new ChannelApplicationLayer(executorService, null));",
          "224:                     hub.execute(() -> {",
          "225:                         try {",
          "",
          "[Removed Lines]",
          "216:                     final ProtocolStack<Future<Channel>> channelFromClient =",
          "217:                             ProtocolStack.on(nio ? new NIONetworkLayer(hub, fromClient, fromClient) : new BIONetworkLayer(hub, fromClient, fromClient))",
          "221:                             .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"),",
          "222:                                     headers -> {}))",
          "",
          "[Added Lines]",
          "209:                     final ProtocolStack<Future<Channel>> channelFromClient = ProtocolStack.on(",
          "210:                                     nio",
          "211:                                             ? new NIONetworkLayer(hub, fromClient, fromClient)",
          "212:                                             : new BIONetworkLayer(hub, fromClient, fromClient))",
          "216:                             .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"server\"), headers -> {}))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "256:         }",
          "258:         @Override",
          "262:     }",
          "264:     public static void main(String[] args) throws Exception {",
          "",
          "[Removed Lines]",
          "259:         public void onClosedChannel(ClosedChannelException e) {",
          "261:         }",
          "",
          "[Added Lines]",
          "252:         public void onClosedChannel(ClosedChannelException e) {}",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "267:         boolean nio = args.length < 3 || !\"bio\".equalsIgnoreCase(args[2]);",
          "268:         final boolean ssl = args.length < 4 || !\"cleartext\".equalsIgnoreCase(args[3]);",
          "269:         final double expectNoopsPerSecond = 1000.0 / clientIntervalMs * numClients;",
          "271:         System.out.printf(\"Server using %s%n\", nio ? \"Non-blocking I/O\" : \"Reader thread per client I/O\");",
          "272:         System.out.printf(\"Protocol stack using %s%n\", ssl ? \"TLS encrypted transport\" : \"cleartext transport\");",
          "273:         ProtocolStackLoopbackLoadStress stress = new ProtocolStackLoopbackLoadStress(nio, ssl);",
          "",
          "[Removed Lines]",
          "270:         System.out.printf(\"Starting stress test with %d clients making calls every %dms (%.1f/sec) to give a total expected rate of %.1f/sec%n\", numClients, clientIntervalMs, 1000.0 / clientIntervalMs, expectNoopsPerSecond);",
          "",
          "[Added Lines]",
          "261:         System.out.printf(",
          "262:                 \"Starting stress test with %d clients making calls every %dms (%.1f/sec) to give a total expected rate of %.1f/sec%n\",",
          "263:                 numClients, clientIntervalMs, 1000.0 / clientIntervalMs, expectNoopsPerSecond);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "290:                 long currentNoops = NoOpCallable.noops.get();",
          "291:                 double noopsPerSecond = (currentNoops - initialNoops) * 1000.0 / (now - start);",
          "292:                 double instantNoopsPerSecond = (currentNoops - previousNoops) * 1000.0 / (now - last);",
          "295:                 System.out.flush();",
          "296:                 last = now;",
          "297:                 previousNoops = currentNoops;",
          "",
          "[Removed Lines]",
          "293:                 System.out.printf(\"%nTotal rate %.1f/sec, instant %.1f/sec, expect %.1f/sec%n\", noopsPerSecond,",
          "294:                         instantNoopsPerSecond, expectNoopsPerSecond);",
          "",
          "[Added Lines]",
          "286:                 System.out.printf(",
          "287:                         \"%nTotal rate %.1f/sec, instant %.1f/sec, expect %.1f/sec%n\",",
          "288:                         noopsPerSecond, instantNoopsPerSecond, expectNoopsPerSecond);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "306:             stress.startClient(i, serverAddress, clientIntervalMs, ssl);",
          "307:         }",
          "308:         System.out.println(\"All clients started\");",
          "310:     }",
          "313:         SocketChannel toServer = SocketChannel.open();",
          "314:         toServer.connect(serverAddress);",
          "315:         SSLEngine sslEngine = context.createSSLEngine();",
          "316:         sslEngine.setUseClientMode(true);",
          "332:                     long start = System.currentTimeMillis();",
          "343:                     }",
          "351:     }",
          "353: }",
          "",
          "[Removed Lines]",
          "312:     private void startClient(int n, SocketAddress serverAddress, final int clientIntervalMs, boolean ssl) throws IOException, ExecutionException, InterruptedException {",
          "317:         final Channel clientChannel =",
          "318:                 ProtocolStack.on(new NIONetworkLayer(hub, toServer, toServer))",
          "319:                         .named(String.format(\"Client %d:  %s -> %s\", n, toServer.getLocalAddress(), serverAddress))",
          "320:                         .filter(new AckFilterLayer())",
          "321:                         .filter(ssl ? new SSLEngineFilterLayer(sslEngine, null) : null)",
          "322:                         .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"),",
          "323:                                 headers -> {}))",
          "324:                         .build(new ChannelApplicationLayer(executorService, null)).get().get();",
          "325:         timer[n % timer.length].scheduleAtFixedRate(new TimerTask() {",
          "326:             private NoOpCallable callable = new NoOpCallable();",
          "327:             long start = System.currentTimeMillis();",
          "328:             int times = 0;",
          "329:             @Override",
          "330:             public void run() {",
          "331:                 try {",
          "333:                     clientChannel.call(callable);",
          "334:                     times++;",
          "335:                     if (times % 1000 == 0) {",
          "336:                         System.out.printf(\"  %s has run %d No-op callables. Rate %.1f/s expect %.1f/s%n\",",
          "337:                                 clientChannel.getName(), times,",
          "338:                                 times * 1000.0 / (System.currentTimeMillis() - this.start), 1000.0 / clientIntervalMs);",
          "339:                     }",
          "340:                     long duration = System.currentTimeMillis() - start;",
          "341:                     if (duration > 250L) {",
          "342:                         System.err.printf(\"  %s took %dms to complete a callable%n\", clientChannel.getName(), duration);",
          "344:                 } catch (Exception e) {",
          "345:                     e.printStackTrace(System.err);",
          "346:                     IOUtils.closeQuietly(clientChannel);",
          "347:                     cancel();",
          "348:                 }",
          "349:             }",
          "350:         }, entropy.nextInt(clientIntervalMs), clientIntervalMs);",
          "",
          "[Added Lines]",
          "305:     private void startClient(int n, SocketAddress serverAddress, final int clientIntervalMs, boolean ssl)",
          "306:             throws IOException, ExecutionException, InterruptedException {",
          "311:         final Channel clientChannel = ProtocolStack.on(new NIONetworkLayer(hub, toServer, toServer))",
          "312:                 .named(String.format(\"Client %d:  %s -> %s\", n, toServer.getLocalAddress(), serverAddress))",
          "313:                 .filter(new AckFilterLayer())",
          "314:                 .filter(ssl ? new SSLEngineFilterLayer(sslEngine, null) : null)",
          "315:                 .filter(new ConnectionHeadersFilterLayer(Map.of(\"id\", \"client\"), headers -> {}))",
          "316:                 .build(new ChannelApplicationLayer(executorService, null))",
          "317:                 .get()",
          "318:                 .get();",
          "319:         timer[n % timer.length].scheduleAtFixedRate(",
          "320:                 new TimerTask() {",
          "321:                     private NoOpCallable callable = new NoOpCallable();",
          "323:                     int times = 0;",
          "325:                     @Override",
          "326:                     public void run() {",
          "327:                         try {",
          "328:                             long start = System.currentTimeMillis();",
          "329:                             clientChannel.call(callable);",
          "330:                             times++;",
          "331:                             if (times % 1000 == 0) {",
          "332:                                 System.out.printf(",
          "333:                                         \"  %s has run %d No-op callables. Rate %.1f/s expect %.1f/s%n\",",
          "334:                                         clientChannel.getName(),",
          "335:                                         times,",
          "336:                                         times * 1000.0 / (System.currentTimeMillis() - this.start),",
          "337:                                         1000.0 / clientIntervalMs);",
          "338:                             }",
          "339:                             long duration = System.currentTimeMillis() - start;",
          "340:                             if (duration > 250L) {",
          "341:                                 System.err.printf(",
          "342:                                         \"  %s took %dms to complete a callable%n\", clientChannel.getName(), duration);",
          "343:                             }",
          "344:                         } catch (Exception e) {",
          "345:                             e.printStackTrace(System.err);",
          "346:                             IOUtils.closeQuietly(clientChannel);",
          "347:                             cancel();",
          "348:                         }",
          "350:                 },",
          "351:                 entropy.nextInt(clientIntervalMs),",
          "352:                 clientIntervalMs);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java||src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java -> src/test/java/org/jenkinsci/remoting/protocol/ProtocolStackTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:             final AtomicInteger state = new AtomicInteger();",
          "78:             ProtocolStack.on(new NetworkLayer(selector) {",
          "156:             assertThat(\"Init in sequence\", state.get(), is(4));",
          "165:         } finally {",
          "166:             logger.removeHandler(handler);",
          "167:             logger.setLevel(oldLevel);",
          "",
          "[Removed Lines]",
          "80:                 @Override",
          "81:                 protected void write(@NonNull ByteBuffer data) {",
          "82:                 }",
          "84:                 @Override",
          "85:                 public void start() {",
          "86:                     state.compareAndSet(0, 1);",
          "87:                 }",
          "89:                 @Override",
          "90:                 public void doCloseSend() {",
          "91:                 }",
          "93:                 @Override",
          "94:                 public void doCloseRecv() {",
          "95:                 }",
          "97:                 @Override",
          "98:                 public boolean isSendOpen() {",
          "99:                     return true;",
          "100:                 }",
          "102:             }).filter(new FilterLayer() {",
          "103:                 @Override",
          "104:                 public void start() {",
          "105:                     state.compareAndSet(1, 2);",
          "106:                 }",
          "108:                 @Override",
          "109:                 public void onRecv(@NonNull ByteBuffer data) {",
          "110:                 }",
          "112:                 @Override",
          "113:                 public void doSend(@NonNull ByteBuffer data) {",
          "114:                 }",
          "116:             }).filter(new FilterLayer() {",
          "117:                 @Override",
          "118:                 public void start() {",
          "119:                     state.compareAndSet(2, 3);",
          "120:                 }",
          "122:                 @Override",
          "123:                 public void onRecv(@NonNull ByteBuffer data) {",
          "124:                 }",
          "126:                 @Override",
          "127:                 public void doSend(@NonNull ByteBuffer data) {",
          "128:                 }",
          "130:             }).named(\"initSeq\").build(new ApplicationLayer<Void>() {",
          "131:                 @Override",
          "132:                 public Void get() {",
          "133:                     return null;",
          "134:                 }",
          "136:                 @Override",
          "137:                 public void onRead(@NonNull ByteBuffer data) {",
          "138:                 }",
          "140:                 @Override",
          "141:                 public void start() {",
          "142:                     state.compareAndSet(3, 4);",
          "143:                 }",
          "146:                 @Override",
          "147:                 public void onReadClosed(IOException cause) {",
          "148:                 }",
          "150:                 @Override",
          "151:                 public boolean isReadOpen() {",
          "152:                     return true;",
          "153:                 }",
          "155:             });",
          "157:             assertThat(handler.logRecords, contains(",
          "158:                     allOf(hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "159:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"}))),",
          "160:                     allOf(hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "161:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"}))),",
          "162:                     allOf(hasProperty(\"message\", is(\"[{0}] Started\")),",
          "163:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"})))",
          "164:             ));",
          "",
          "[Added Lines]",
          "80:                         @Override",
          "81:                         protected void write(@NonNull ByteBuffer data) {}",
          "83:                         @Override",
          "84:                         public void start() {",
          "85:                             state.compareAndSet(0, 1);",
          "86:                         }",
          "88:                         @Override",
          "89:                         public void doCloseSend() {}",
          "91:                         @Override",
          "92:                         public void doCloseRecv() {}",
          "94:                         @Override",
          "95:                         public boolean isSendOpen() {",
          "96:                             return true;",
          "97:                         }",
          "98:                     })",
          "99:                     .filter(new FilterLayer() {",
          "100:                         @Override",
          "101:                         public void start() {",
          "102:                             state.compareAndSet(1, 2);",
          "103:                         }",
          "105:                         @Override",
          "106:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "108:                         @Override",
          "109:                         public void doSend(@NonNull ByteBuffer data) {}",
          "110:                     })",
          "111:                     .filter(new FilterLayer() {",
          "112:                         @Override",
          "113:                         public void start() {",
          "114:                             state.compareAndSet(2, 3);",
          "115:                         }",
          "117:                         @Override",
          "118:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "120:                         @Override",
          "121:                         public void doSend(@NonNull ByteBuffer data) {}",
          "122:                     })",
          "123:                     .named(\"initSeq\")",
          "124:                     .build(new ApplicationLayer<Void>() {",
          "125:                         @Override",
          "126:                         public Void get() {",
          "127:                             return null;",
          "128:                         }",
          "130:                         @Override",
          "131:                         public void onRead(@NonNull ByteBuffer data) {}",
          "133:                         @Override",
          "134:                         public void start() {",
          "135:                             state.compareAndSet(3, 4);",
          "136:                         }",
          "138:                         @Override",
          "139:                         public void onReadClosed(IOException cause) {}",
          "141:                         @Override",
          "142:                         public boolean isReadOpen() {",
          "143:                             return true;",
          "144:                         }",
          "145:                     });",
          "147:             assertThat(",
          "148:                     handler.logRecords,",
          "149:                     contains(",
          "150:                             allOf(",
          "151:                                     hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "152:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"}))),",
          "153:                             allOf(",
          "154:                                     hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "155:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"}))),",
          "156:                             allOf(",
          "157:                                     hasProperty(\"message\", is(\"[{0}] Started\")),",
          "158:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"})))));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "181:             final AtomicInteger state = new AtomicInteger();",
          "182:             final IOException e = assertThrows(IOException.class, () -> ProtocolStack.on(new NetworkLayer(selector) {",
          "268:             assertThat(e.getMessage(), is(\"boom\"));",
          "279:             assertThat(\"Init in sequence\", state.get(), is(4));",
          "280:         } finally {",
          "281:             logger.removeHandler(handler);",
          "",
          "[Removed Lines]",
          "184:                 @Override",
          "185:                 protected void write(@NonNull ByteBuffer data) {",
          "186:                 }",
          "188:                 @Override",
          "189:                 public void start() {",
          "190:                     state.compareAndSet(0, 1);",
          "191:                 }",
          "193:                 @Override",
          "194:                 public void doCloseSend() {",
          "195:                 }",
          "197:                 @Override",
          "198:                 public void doCloseRecv() {",
          "199:                 }",
          "202:                 @Override",
          "203:                 public boolean isSendOpen() {",
          "204:                     return true;",
          "205:                 }",
          "207:             }).filter(new FilterLayer() {",
          "208:                 @Override",
          "209:                 public void start() throws IOException {",
          "210:                     state.compareAndSet(1, 2);",
          "211:                     throw new IOException(\"boom\");",
          "212:                 }",
          "214:                 @Override",
          "215:                 public void onRecv(@NonNull ByteBuffer data) {",
          "216:                 }",
          "218:                 @Override",
          "219:                 public void doSend(@NonNull ByteBuffer data) {",
          "220:                 }",
          "222:             }).filter(new FilterLayer() {",
          "223:                 @Override",
          "224:                 public void start() {",
          "225:                     state.set(-2);",
          "226:                 }",
          "228:                 @Override",
          "229:                 public void onRecv(@NonNull ByteBuffer data) {",
          "230:                 }",
          "232:                 @Override",
          "233:                 public void doSend(@NonNull ByteBuffer data) {",
          "234:                 }",
          "236:                 @Override",
          "237:                 public void onRecvClosed(IOException cause) throws IOException {",
          "238:                     state.compareAndSet(2, 3);",
          "239:                     super.onRecvClosed(cause);",
          "240:                 }",
          "241:             }).named(\"initSeq\").build(new ApplicationLayer<Void>() {",
          "242:                 @Override",
          "243:                 public Void get() {",
          "244:                     return null;",
          "245:                 }",
          "247:                 @Override",
          "248:                 public void onRead(@NonNull ByteBuffer data) {",
          "249:                 }",
          "251:                 @Override",
          "252:                 public void start() {",
          "253:                     state.set(-3);",
          "254:                 }",
          "257:                 @Override",
          "258:                 public void onReadClosed(IOException cause) {",
          "259:                     state.compareAndSet(3, 4);",
          "260:                 }",
          "262:                 @Override",
          "263:                 public boolean isReadOpen() {",
          "264:                     return true;",
          "265:                 }",
          "267:             }));",
          "270:             assertThat(handler.logRecords, contains(",
          "271:                     allOf(hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "272:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"}))),",
          "273:                     allOf(hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "274:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"}))),",
          "275:                     allOf(hasProperty(\"message\", is(\"[{0}] Start failure\")),",
          "276:                             hasProperty(\"parameters\", is(new Object[]{\"initSeq\"})),",
          "277:                             hasProperty(\"thrown\", hasProperty(\"message\", is(\"boom\"))))",
          "278:             ));",
          "",
          "[Added Lines]",
          "178:                         @Override",
          "179:                         protected void write(@NonNull ByteBuffer data) {}",
          "181:                         @Override",
          "182:                         public void start() {",
          "183:                             state.compareAndSet(0, 1);",
          "184:                         }",
          "186:                         @Override",
          "187:                         public void doCloseSend() {}",
          "189:                         @Override",
          "190:                         public void doCloseRecv() {}",
          "192:                         @Override",
          "193:                         public boolean isSendOpen() {",
          "194:                             return true;",
          "195:                         }",
          "196:                     })",
          "197:                     .filter(new FilterLayer() {",
          "198:                         @Override",
          "199:                         public void start() throws IOException {",
          "200:                             state.compareAndSet(1, 2);",
          "201:                             throw new IOException(\"boom\");",
          "202:                         }",
          "204:                         @Override",
          "205:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "207:                         @Override",
          "208:                         public void doSend(@NonNull ByteBuffer data) {}",
          "209:                     })",
          "210:                     .filter(new FilterLayer() {",
          "211:                         @Override",
          "212:                         public void start() {",
          "213:                             state.set(-2);",
          "214:                         }",
          "216:                         @Override",
          "217:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "219:                         @Override",
          "220:                         public void doSend(@NonNull ByteBuffer data) {}",
          "222:                         @Override",
          "223:                         public void onRecvClosed(IOException cause) throws IOException {",
          "224:                             state.compareAndSet(2, 3);",
          "225:                             super.onRecvClosed(cause);",
          "226:                         }",
          "227:                     })",
          "228:                     .named(\"initSeq\")",
          "229:                     .build(new ApplicationLayer<Void>() {",
          "230:                         @Override",
          "231:                         public Void get() {",
          "232:                             return null;",
          "233:                         }",
          "235:                         @Override",
          "236:                         public void onRead(@NonNull ByteBuffer data) {}",
          "238:                         @Override",
          "239:                         public void start() {",
          "240:                             state.set(-3);",
          "241:                         }",
          "243:                         @Override",
          "244:                         public void onReadClosed(IOException cause) {",
          "245:                             state.compareAndSet(3, 4);",
          "246:                         }",
          "248:                         @Override",
          "249:                         public boolean isReadOpen() {",
          "250:                             return true;",
          "251:                         }",
          "252:                     }));",
          "255:             assertThat(",
          "256:                     handler.logRecords,",
          "257:                     contains(",
          "258:                             allOf(",
          "259:                                     hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "260:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"}))),",
          "261:                             allOf(",
          "262:                                     hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "263:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"}))),",
          "264:                             allOf(",
          "265:                                     hasProperty(\"message\", is(\"[{0}] Start failure\")),",
          "266:                                     hasProperty(\"parameters\", is(new Object[] {\"initSeq\"})),",
          "267:                                     hasProperty(\"thrown\", hasProperty(\"message\", is(\"boom\"))))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "297:             final AtomicInteger state = new AtomicInteger();",
          "298:             ProtocolStack.on(new NetworkLayer(selector) {",
          "399:             assertThat(\"Close in sequence\", state.get(), is(7));",
          "412:         } finally {",
          "413:             logger.removeHandler(handler);",
          "414:             logger.setLevel(oldLevel);",
          "",
          "[Removed Lines]",
          "300:                 @Override",
          "301:                 public void start() {",
          "302:                 }",
          "304:                 @Override",
          "305:                 protected void write(@NonNull ByteBuffer data) {",
          "306:                 }",
          "308:                 @Override",
          "309:                 public void doCloseRecv() {",
          "310:                     state.compareAndSet(3, 4);",
          "311:                     onRecvClosed();",
          "312:                 }",
          "314:                 @Override",
          "315:                 public void doCloseSend() {",
          "316:                     state.compareAndSet(2, 3);",
          "317:                     doCloseRecv();",
          "318:                 }",
          "320:                 @Override",
          "321:                 public boolean isSendOpen() {",
          "322:                     return true;",
          "323:                 }",
          "325:             }).filter(new FilterLayer() {",
          "326:                 @Override",
          "327:                 public void start() {",
          "328:                 }",
          "330:                 @Override",
          "331:                 public void onRecv(@NonNull ByteBuffer data) {",
          "332:                 }",
          "334:                 @Override",
          "335:                 public void doSend(@NonNull ByteBuffer data) {",
          "336:                 }",
          "338:                 @Override",
          "339:                 public void doCloseSend() throws IOException {",
          "340:                     state.compareAndSet(1, 2);",
          "341:                     super.doCloseSend();",
          "342:                 }",
          "344:                 @Override",
          "345:                 public void onRecvClosed(IOException cause) throws IOException {",
          "346:                     state.compareAndSet(4, 5);",
          "347:                     super.onRecvClosed(cause);",
          "348:                 }",
          "349:             }).filter(new FilterLayer() {",
          "350:                 @Override",
          "351:                 public void start() {",
          "352:                 }",
          "354:                 @Override",
          "355:                 public void onRecv(@NonNull ByteBuffer data) {",
          "356:                 }",
          "358:                 @Override",
          "359:                 public void doSend(@NonNull ByteBuffer data) {",
          "360:                 }",
          "362:                 @Override",
          "363:                 public void doCloseSend() throws IOException {",
          "364:                     state.compareAndSet(0, 1);",
          "365:                     super.doCloseSend();",
          "366:                 }",
          "368:                 @Override",
          "369:                 public void onRecvClosed(IOException cause) throws IOException {",
          "370:                     state.compareAndSet(5, 6);",
          "371:                     super.onRecvClosed(cause);",
          "372:                 }",
          "373:             }).named(\"closeSeq\").build(new ApplicationLayer<Void>() {",
          "374:                 @Override",
          "375:                 public boolean isReadOpen() {",
          "376:                     return true;",
          "377:                 }",
          "379:                 @Override",
          "380:                 public void onRead(@NonNull ByteBuffer data) {",
          "381:                 }",
          "383:                 @Override",
          "384:                 public Void get() {",
          "385:                     return null;",
          "386:                 }",
          "388:                 @Override",
          "389:                 public void start() {",
          "390:                 }",
          "393:                 @Override",
          "394:                 public void onReadClosed(IOException cause) {",
          "395:                     state.compareAndSet(6, 7);",
          "396:                 }",
          "398:             }).close();",
          "400:             assertThat(handler.logRecords, contains(",
          "401:                     allOf(hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "402:                             hasProperty(\"parameters\", is(new Object[]{\"closeSeq\"}))),",
          "403:                     allOf(hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "404:                             hasProperty(\"parameters\", is(new Object[]{\"closeSeq\"}))),",
          "405:                     allOf(hasProperty(\"message\", is(\"[{0}] Started\")),",
          "406:                             hasProperty(\"parameters\", is(new Object[]{\"closeSeq\"}))),",
          "407:                     allOf(hasProperty(\"message\", is(\"[{0}] Closing\")),",
          "408:                             hasProperty(\"parameters\", is(new Object[]{\"closeSeq\"}))),",
          "409:                     allOf(hasProperty(\"message\", is(\"[{0}] Closed\")),",
          "410:                             hasProperty(\"parameters\", is(new Object[]{\"closeSeq\"})))",
          "411:             ));",
          "",
          "[Added Lines]",
          "289:                         @Override",
          "290:                         public void start() {}",
          "292:                         @Override",
          "293:                         protected void write(@NonNull ByteBuffer data) {}",
          "295:                         @Override",
          "296:                         public void doCloseRecv() {",
          "297:                             state.compareAndSet(3, 4);",
          "298:                             onRecvClosed();",
          "299:                         }",
          "301:                         @Override",
          "302:                         public void doCloseSend() {",
          "303:                             state.compareAndSet(2, 3);",
          "304:                             doCloseRecv();",
          "305:                         }",
          "307:                         @Override",
          "308:                         public boolean isSendOpen() {",
          "309:                             return true;",
          "310:                         }",
          "311:                     })",
          "312:                     .filter(new FilterLayer() {",
          "313:                         @Override",
          "314:                         public void start() {}",
          "316:                         @Override",
          "317:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "319:                         @Override",
          "320:                         public void doSend(@NonNull ByteBuffer data) {}",
          "322:                         @Override",
          "323:                         public void doCloseSend() throws IOException {",
          "324:                             state.compareAndSet(1, 2);",
          "325:                             super.doCloseSend();",
          "326:                         }",
          "328:                         @Override",
          "329:                         public void onRecvClosed(IOException cause) throws IOException {",
          "330:                             state.compareAndSet(4, 5);",
          "331:                             super.onRecvClosed(cause);",
          "332:                         }",
          "333:                     })",
          "334:                     .filter(new FilterLayer() {",
          "335:                         @Override",
          "336:                         public void start() {}",
          "338:                         @Override",
          "339:                         public void onRecv(@NonNull ByteBuffer data) {}",
          "341:                         @Override",
          "342:                         public void doSend(@NonNull ByteBuffer data) {}",
          "344:                         @Override",
          "345:                         public void doCloseSend() throws IOException {",
          "346:                             state.compareAndSet(0, 1);",
          "347:                             super.doCloseSend();",
          "348:                         }",
          "350:                         @Override",
          "351:                         public void onRecvClosed(IOException cause) throws IOException {",
          "352:                             state.compareAndSet(5, 6);",
          "353:                             super.onRecvClosed(cause);",
          "354:                         }",
          "355:                     })",
          "356:                     .named(\"closeSeq\")",
          "357:                     .build(new ApplicationLayer<Void>() {",
          "358:                         @Override",
          "359:                         public boolean isReadOpen() {",
          "360:                             return true;",
          "361:                         }",
          "363:                         @Override",
          "364:                         public void onRead(@NonNull ByteBuffer data) {}",
          "366:                         @Override",
          "367:                         public Void get() {",
          "368:                             return null;",
          "369:                         }",
          "371:                         @Override",
          "372:                         public void start() {}",
          "374:                         @Override",
          "375:                         public void onReadClosed(IOException cause) {",
          "376:                             state.compareAndSet(6, 7);",
          "377:                         }",
          "378:                     })",
          "379:                     .close();",
          "381:             assertThat(",
          "382:                     handler.logRecords,",
          "383:                     contains(",
          "384:                             allOf(",
          "385:                                     hasProperty(\"message\", is(\"[{0}] Initializing\")),",
          "386:                                     hasProperty(\"parameters\", is(new Object[] {\"closeSeq\"}))),",
          "387:                             allOf(",
          "388:                                     hasProperty(\"message\", is(\"[{0}] Starting\")),",
          "389:                                     hasProperty(\"parameters\", is(new Object[] {\"closeSeq\"}))),",
          "390:                             allOf(",
          "391:                                     hasProperty(\"message\", is(\"[{0}] Started\")),",
          "392:                                     hasProperty(\"parameters\", is(new Object[] {\"closeSeq\"}))),",
          "393:                             allOf(",
          "394:                                     hasProperty(\"message\", is(\"[{0}] Closing\")),",
          "395:                                     hasProperty(\"parameters\", is(new Object[] {\"closeSeq\"}))),",
          "396:                             allOf(",
          "397:                                     hasProperty(\"message\", is(\"[{0}] Closed\")),",
          "398:                                     hasProperty(\"parameters\", is(new Object[] {\"closeSeq\"})))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "429:         }",
          "431:         @Override",
          "435:         @Override",
          "438:     }",
          "439: }",
          "",
          "[Removed Lines]",
          "432:         public void flush() {",
          "433:         }",
          "436:         public void close() throws SecurityException {",
          "437:         }",
          "",
          "[Added Lines]",
          "419:         public void flush() {}",
          "422:         public void close() throws SecurityException {}",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/Repeat.java||src/test/java/org/jenkinsci/remoting/protocol/Repeat.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/Repeat.java -> src/test/java/org/jenkinsci/remoting/protocol/Repeat.java"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java||src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java -> src/test/java/org/jenkinsci/remoting/protocol/RepeatRule.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:     @Override",
          "37:     public Statement apply(final Statement base, final Description description) {",
          "38:         final Repeat repeat = description.getAnnotation(Repeat.class);",
          "55:                     }",
          "85:     }",
          "86: }",
          "",
          "[Removed Lines]",
          "39:         return repeat == null || (repeat.value() <= 0 && repeat.stopAfter() <= 0L) ? base : new Statement() {",
          "40:             @Override",
          "41:             public void evaluate() throws Throwable {",
          "42:                 long nextProgress = System.currentTimeMillis() + 10000;",
          "43:                 int lastLoopCount = 0;",
          "44:                 int maxLoops;",
          "45:                 long stopNanos;",
          "46:                 String text;",
          "47:                 if (repeat.stopAfter() <= 0L) {",
          "48:                     stopNanos = Long.MAX_VALUE;",
          "49:                     if (repeat.value() <= 0) {",
          "50:                         maxLoops = 1;",
          "51:                         text = \"once\";",
          "52:                     } else {",
          "53:                         maxLoops = repeat.value();",
          "54:                         text = String.format(\"%d times\", maxLoops);",
          "56:                 } else {",
          "57:                     if (repeat.value() <= 0) {",
          "58:                         maxLoops = Integer.MAX_VALUE;",
          "59:                         text = String.format(\"for %d %s\", repeat.stopAfter(), repeat.stopAfterUnits().name());",
          "60:                     } else {",
          "61:                         maxLoops = repeat.value();",
          "62:                         text = String.format(\"for %d times or %d %s\", maxLoops, repeat.stopAfter(),",
          "63:                                 repeat.stopAfterUnits().name());",
          "64:                     }",
          "65:                     stopNanos = System.currentTimeMillis() + repeat.stopAfterUnits().toMillis(repeat.stopAfter());",
          "66:                 }",
          "67:                 int loopCount;",
          "68:                 for (loopCount = 0; loopCount < maxLoops && System.currentTimeMillis() < stopNanos; loopCount++) {",
          "69:                     base.evaluate();",
          "70:                     if (System.currentTimeMillis() > nextProgress) {",
          "71:                         double loopsPerSec = (loopCount - lastLoopCount + 1) / 10.0;",
          "72:                         LOGGER.log(Level.INFO, \"Repeating {0} {1} at {2,number,0.0} runs per second, {3,number} done\",",
          "73:                                 new Object[]{description.getDisplayName(), text, loopsPerSec, loopCount + 1});",
          "74:                         lastLoopCount = loopCount;",
          "75:                         nextProgress = System.currentTimeMillis() + 10000;",
          "76:                         System.gc();",
          "77:                     }",
          "78:                 }",
          "79:                 if (repeat.stopAfter() > 0) {",
          "80:                     LOGGER.log(Level.INFO, \"Repeated {0} {1,number} times\",",
          "81:                             new Object[]{description.getDisplayName(), loopCount});",
          "82:                 }",
          "83:             }",
          "84:         };",
          "",
          "[Added Lines]",
          "39:         return repeat == null || (repeat.value() <= 0 && repeat.stopAfter() <= 0L)",
          "40:                 ? base",
          "41:                 : new Statement() {",
          "42:                     @Override",
          "43:                     public void evaluate() throws Throwable {",
          "44:                         long nextProgress = System.currentTimeMillis() + 10000;",
          "45:                         int lastLoopCount = 0;",
          "46:                         int maxLoops;",
          "47:                         long stopNanos;",
          "48:                         String text;",
          "49:                         if (repeat.stopAfter() <= 0L) {",
          "50:                             stopNanos = Long.MAX_VALUE;",
          "51:                             if (repeat.value() <= 0) {",
          "52:                                 maxLoops = 1;",
          "53:                                 text = \"once\";",
          "54:                             } else {",
          "55:                                 maxLoops = repeat.value();",
          "56:                                 text = String.format(\"%d times\", maxLoops);",
          "57:                             }",
          "58:                         } else {",
          "59:                             if (repeat.value() <= 0) {",
          "60:                                 maxLoops = Integer.MAX_VALUE;",
          "61:                                 text = String.format(",
          "62:                                         \"for %d %s\",",
          "63:                                         repeat.stopAfter(),",
          "64:                                         repeat.stopAfterUnits().name());",
          "65:                             } else {",
          "66:                                 maxLoops = repeat.value();",
          "67:                                 text = String.format(",
          "68:                                         \"for %d times or %d %s\",",
          "69:                                         maxLoops,",
          "70:                                         repeat.stopAfter(),",
          "71:                                         repeat.stopAfterUnits().name());",
          "72:                             }",
          "73:                             stopNanos = System.currentTimeMillis()",
          "74:                                     + repeat.stopAfterUnits().toMillis(repeat.stopAfter());",
          "75:                         }",
          "76:                         int loopCount;",
          "77:                         for (loopCount = 0;",
          "78:                                 loopCount < maxLoops && System.currentTimeMillis() < stopNanos;",
          "79:                                 loopCount++) {",
          "80:                             base.evaluate();",
          "81:                             if (System.currentTimeMillis() > nextProgress) {",
          "82:                                 double loopsPerSec = (loopCount - lastLoopCount + 1) / 10.0;",
          "83:                                 LOGGER.log(",
          "84:                                         Level.INFO,",
          "85:                                         \"Repeating {0} {1} at {2,number,0.0} runs per second, {3,number} done\",",
          "86:                                         new Object[] {description.getDisplayName(), text, loopsPerSec, loopCount + 1});",
          "87:                                 lastLoopCount = loopCount;",
          "88:                                 nextProgress = System.currentTimeMillis() + 10000;",
          "89:                                 System.gc();",
          "90:                             }",
          "91:                         }",
          "92:                         if (repeat.stopAfter() > 0) {",
          "93:                             LOGGER.log(Level.INFO, \"Repeated {0} {1,number} times\", new Object[] {",
          "94:                                 description.getDisplayName(), loopCount",
          "95:                             });",
          "96:                         }",
          "98:                 };",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/BlindTrustX509ExtendedTrustManagerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     public static X509CertificateRule cert = new X509CertificateRule(\"main\", key, key, null, -1, 1, TimeUnit.HOURS);",
          "45:     @ClassRule",
          "49:     @Test",
          "50:     public void checkClientTrusted() throws Exception {",
          "52:     }",
          "54:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "46:     public static RuleChain chain = RuleChain.outerRule(key)",
          "47:             .around(cert);",
          "51:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "46:     public static RuleChain chain = RuleChain.outerRule(key).around(cert);",
          "50:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     @Test(expected = IllegalArgumentException.class)",
          "60:     public void checkClientTrusted_nonNullNull() throws Exception {",
          "62:     }",
          "64:     @Test(expected = IllegalArgumentException.class)",
          "65:     public void checkClientTrusted_nonNullEmpty() throws Exception {",
          "67:     }",
          "69:     @Test",
          "70:     public void checkServerTrusted() throws Exception {",
          "72:     }",
          "74:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "61:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "66:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "71:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "60:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "65:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "70:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:     @Test(expected = IllegalArgumentException.class)",
          "80:     public void checkServerTrusted_nonNullNull() throws Exception {",
          "82:     }",
          "84:     @Test(expected = IllegalArgumentException.class)",
          "85:     public void checkServerTrusted_nonNullEmpty() throws Exception {",
          "87:     }",
          "89:     @Test",
          "90:     public void checkClientTrusted1() throws Exception {",
          "92:     }",
          "94:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "81:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "86:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "91:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "80:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "85:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "90:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "99:     @Test(expected = IllegalArgumentException.class)",
          "100:     public void checkClientTrusted1_nonNullNull() throws Exception {",
          "102:     }",
          "104:     @Test(expected = IllegalArgumentException.class)",
          "105:     public void checkClientTrusted1_nonNullEmpty() throws Exception {",
          "107:     }",
          "109:     @Test",
          "110:     public void checkServerTrusted1() throws Exception {",
          "112:     }",
          "114:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "101:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "106:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "111:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "100:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "105:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "110:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:     @Test(expected = IllegalArgumentException.class)",
          "120:     public void checkServerTrusted1_nonNullNull() throws Exception {",
          "122:     }",
          "124:     @Test(expected = IllegalArgumentException.class)",
          "125:     public void checkServerTrusted1_nonNullEmpty() throws Exception {",
          "127:     }",
          "129:     @Test",
          "130:     public void checkClientTrusted2() throws Exception {",
          "132:     }",
          "134:     @Test(expected = IllegalArgumentException.class)",
          "135:     public void checkClientTrusted2_nullNonNull() throws Exception {",
          "137:     }",
          "139:     @Test(expected = IllegalArgumentException.class)",
          "140:     public void checkClientTrusted2_nonNullNull() throws Exception {",
          "142:     }",
          "144:     @Test(expected = IllegalArgumentException.class)",
          "145:     public void checkClientTrusted2_nonNullEmpty() throws Exception {",
          "147:     }",
          "149:     @Test",
          "150:     public void checkServerTrusted2() throws Exception {",
          "152:     }",
          "154:     @Test(expected = IllegalArgumentException.class)",
          "155:     public void checkServerTrusted2_nullNonNull() throws Exception {",
          "157:     }",
          "159:     @Test(expected = IllegalArgumentException.class)",
          "160:     public void checkServerTrusted2_nonNullNull() throws Exception {",
          "162:     }",
          "164:     @Test(expected = IllegalArgumentException.class)",
          "165:     public void checkServerTrusted2_nonNullEmpty() throws Exception {",
          "167:     }",
          "169:     @Test",
          "170:     public void getAcceptedIssuers() {",
          "171:         assertThat(instance.getAcceptedIssuers(), notNullValue());",
          "172:     }",
          "174: }",
          "",
          "[Removed Lines]",
          "121:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "126:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "131:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "136:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine)null);",
          "141:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "146:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "151:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "156:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine)null);",
          "161:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "166:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "",
          "[Added Lines]",
          "120:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "125:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "130:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "135:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine) null);",
          "140:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "145:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "150:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "155:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine) null);",
          "160:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "165:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/KeyPairRule.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:     @Override",
          "61:     public Statement apply(final Statement base, Description description) {",
          "62:         Skip skip = description.getAnnotation(Skip.class);",
          "64:             return base;",
          "65:         }",
          "66:         return new Statement() {",
          "",
          "[Removed Lines]",
          "63:         if (skip != null && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "[Added Lines]",
          "63:         if (skip != null",
          "64:                 && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/PublicKeyMatchingX509ExtendedTrustManagerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: public class PublicKeyMatchingX509ExtendedTrustManagerTest {",
          "42:     public static RSAKeyPairRule key = new RSAKeyPairRule(\"main\");",
          "43:     public static RSAKeyPairRule altKey = new RSAKeyPairRule(\"main\");",
          "45:     public static X509CertificateRule cert = new X509CertificateRule(\"main\", key, key, null, -1, 1, TimeUnit.HOURS);",
          "48:     @ClassRule",
          "54:     @Test",
          "55:     public void checkClientTrusted() throws Exception {",
          "57:     }",
          "59:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "40:     private PublicKeyMatchingX509ExtendedTrustManager instance = new PublicKeyMatchingX509ExtendedTrustManager(key.getPublic());",
          "46:     public static X509CertificateRule altCert = new X509CertificateRule(\"main\", altKey, altKey, null,  -1, 1, TimeUnit.HOURS);",
          "49:     public static RuleChain chain = RuleChain.outerRule(key)",
          "50:             .around(cert)",
          "51:             .around(altKey)",
          "52:             .around(altCert);",
          "56:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "40:     private PublicKeyMatchingX509ExtendedTrustManager instance =",
          "41:             new PublicKeyMatchingX509ExtendedTrustManager(key.getPublic());",
          "47:     public static X509CertificateRule altCert =",
          "48:             new X509CertificateRule(\"main\", altKey, altKey, null, -1, 1, TimeUnit.HOURS);",
          "51:     public static RuleChain chain =",
          "52:             RuleChain.outerRule(key).around(cert).around(altKey).around(altCert);",
          "56:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     @Test(expected = IllegalArgumentException.class)",
          "65:     public void checkClientTrusted_nonNullNull() throws Exception {",
          "67:     }",
          "69:     @Test(expected = IllegalArgumentException.class)",
          "70:     public void checkClientTrusted_nonNullEmpty() throws Exception {",
          "72:     }",
          "74:     @Test",
          "75:     public void checkServerTrusted() throws Exception {",
          "77:     }",
          "79:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "66:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "71:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "76:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "66:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "71:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "76:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:     @Test(expected = IllegalArgumentException.class)",
          "85:     public void checkServerTrusted_nonNullNull() throws Exception {",
          "87:     }",
          "89:     @Test(expected = IllegalArgumentException.class)",
          "90:     public void checkServerTrusted_nonNullEmpty() throws Exception {",
          "92:     }",
          "94:     @Test",
          "95:     public void checkClientTrusted1() throws Exception {",
          "97:     }",
          "99:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "86:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "91:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "96:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "86:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "91:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "96:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "104:     @Test(expected = IllegalArgumentException.class)",
          "105:     public void checkClientTrusted1_nonNullNull() throws Exception {",
          "107:     }",
          "109:     @Test(expected = IllegalArgumentException.class)",
          "110:     public void checkClientTrusted1_nonNullEmpty() throws Exception {",
          "112:     }",
          "114:     @Test",
          "115:     public void checkServerTrusted1() throws Exception {",
          "117:     }",
          "119:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "106:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "111:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "116:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "106:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "111:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "116:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "124:     @Test(expected = IllegalArgumentException.class)",
          "125:     public void checkServerTrusted1_nonNullNull() throws Exception {",
          "127:     }",
          "129:     @Test(expected = IllegalArgumentException.class)",
          "130:     public void checkServerTrusted1_nonNullEmpty() throws Exception {",
          "132:     }",
          "134:     @Test",
          "135:     public void checkClientTrusted2() throws Exception {",
          "137:     }",
          "139:     @Test(expected = IllegalArgumentException.class)",
          "140:     public void checkClientTrusted2_nullNonNull() throws Exception {",
          "142:     }",
          "144:     @Test(expected = IllegalArgumentException.class)",
          "145:     public void checkClientTrusted2_nonNullNull() throws Exception {",
          "147:     }",
          "149:     @Test(expected = IllegalArgumentException.class)",
          "150:     public void checkClientTrusted2_nonNullEmpty() throws Exception {",
          "152:     }",
          "154:     @Test",
          "155:     public void checkServerTrusted2() throws Exception {",
          "157:     }",
          "159:     @Test(expected = IllegalArgumentException.class)",
          "160:     public void checkServerTrusted2_nullNonNull() throws Exception {",
          "162:     }",
          "164:     @Test(expected = IllegalArgumentException.class)",
          "165:     public void checkServerTrusted2_nonNullNull() throws Exception {",
          "167:     }",
          "169:     @Test(expected = IllegalArgumentException.class)",
          "170:     public void checkServerTrusted2_nonNullEmpty() throws Exception {",
          "172:     }",
          "174:     @Test(expected = CertificateException.class)",
          "175:     public void checkClientUntrusted() throws Exception {",
          "177:     }",
          "179:     @Test(expected = CertificateException.class)",
          "180:     public void checkServerUntrusted() throws Exception {",
          "182:     }",
          "184:     @Test(expected = CertificateException.class)",
          "185:     public void checkClientUntrusted1() throws Exception {",
          "187:     }",
          "189:     @Test(expected = CertificateException.class)",
          "190:     public void checkServerUntrusted1() throws Exception {",
          "192:     }",
          "194:     @Test(expected = CertificateException.class)",
          "195:     public void checkClientUntrusted2() throws Exception {",
          "197:     }",
          "199:     @Test(expected = CertificateException.class)",
          "200:     public void checkServerUntrusted2() throws Exception {",
          "202:     }",
          "204:     @Test",
          "205:     public void getAcceptedIssuers() {",
          "206:         assertThat(instance.getAcceptedIssuers(), notNullValue());",
          "207:     }",
          "209: }",
          "",
          "[Removed Lines]",
          "126:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "131:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "136:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "141:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine)null);",
          "146:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "151:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "156:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "161:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine)null);",
          "166:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "171:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "176:         instance.checkClientTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\");",
          "181:         instance.checkServerTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\");",
          "186:         instance.checkClientTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\", new Socket());",
          "191:         instance.checkServerTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\", new Socket());",
          "196:         instance.checkClientTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\", (SSLEngine)null);",
          "201:         instance.checkServerTrusted(new X509Certificate[]{altCert.certificate()}, \"RSA\", (SSLEngine)null);",
          "",
          "[Added Lines]",
          "126:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "131:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "136:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "141:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine) null);",
          "146:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "151:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "156:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "161:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine) null);",
          "166:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "171:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "176:         instance.checkClientTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\");",
          "181:         instance.checkServerTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\");",
          "186:         instance.checkClientTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\", new Socket());",
          "191:         instance.checkServerTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\", new Socket());",
          "196:         instance.checkClientTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\", (SSLEngine) null);",
          "201:         instance.checkServerTrusted(new X509Certificate[] {altCert.certificate()}, \"RSA\", (SSLEngine) null);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/SSLContextRule.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:         this.id = id;",
          "75:     }",
          "80:             throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {",
          "81:         KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());",
          "82:         int id = 1;",
          "",
          "[Removed Lines]",
          "77:     private static KeyStore createKeyStore(@CheckForNull List<X509CertificateRule> certificates,",
          "78:                                            @CheckForNull List<KeyWithChain> keys,",
          "79:                                            @NonNull char[] password)",
          "",
          "[Added Lines]",
          "77:     private static KeyStore createKeyStore(",
          "78:             @CheckForNull List<X509CertificateRule> certificates,",
          "79:             @CheckForNull List<KeyWithChain> keys,",
          "80:             @NonNull char[] password)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:     @Override",
          "180:     public Statement apply(final Statement base, Description description) {",
          "181:         Skip skip = description.getAnnotation(Skip.class);",
          "183:             return base;",
          "184:         }",
          "185:         return new Statement() {",
          "",
          "[Removed Lines]",
          "182:         if (skip != null && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "[Added Lines]",
          "183:         if (skip != null",
          "184:                 && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:                         TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());",
          "196:                 tmf.init(createKeyStore(certificates, null, password));",
          "197:                 TrustManager[] trustManagers = new TrustManager[1];",
          "202:                 context.init(keyManagers, trustManagers, null);",
          "203:                 try {",
          "",
          "[Removed Lines]",
          "198:                 trustManagers[0] = validityChecking ? new ValidityCheckingX509ExtendedTrustManager(",
          "199:                         findFirst(X509ExtendedTrustManager.class, tmf.getTrustManagers())) : findFirst(",
          "200:                         X509ExtendedTrustManager.class, tmf.getTrustManagers());",
          "",
          "[Added Lines]",
          "200:                 trustManagers[0] = validityChecking",
          "201:                         ? new ValidityCheckingX509ExtendedTrustManager(",
          "202:                                 findFirst(X509ExtendedTrustManager.class, tmf.getTrustManagers()))",
          "203:                         : findFirst(X509ExtendedTrustManager.class, tmf.getTrustManagers());",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java||src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/ValidityCheckingX509ExtendedTrustManagerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     public static RSAKeyPairRule key = new RSAKeyPairRule(\"main\");",
          "44:     public static X509CertificateRule cert = new X509CertificateRule(\"main\", key, key, null, -1, 1, TimeUnit.HOURS);",
          "47:     @ClassRule",
          "52:     @Test",
          "53:     public void checkClientTrusted() throws Exception {",
          "55:     }",
          "57:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "45:     public static X509CertificateRule expired = new X509CertificateRule(\"main\", key, key, null, -100, -99, TimeUnit.HOURS);",
          "48:     public static RuleChain chain = RuleChain.outerRule(key)",
          "49:             .around(cert)",
          "50:             .around(expired);",
          "54:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "45:     public static X509CertificateRule expired =",
          "46:             new X509CertificateRule(\"main\", key, key, null, -100, -99, TimeUnit.HOURS);",
          "49:     public static RuleChain chain = RuleChain.outerRule(key).around(cert).around(expired);",
          "53:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     @Test(expected = IllegalArgumentException.class)",
          "63:     public void checkClientTrusted_nonNullNull() throws Exception {",
          "65:     }",
          "67:     @Test(expected = IllegalArgumentException.class)",
          "68:     public void checkClientTrusted_nonNullEmpty() throws Exception {",
          "70:     }",
          "72:     @Test",
          "73:     public void checkServerTrusted() throws Exception {",
          "75:     }",
          "77:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "64:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "69:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "74:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\");",
          "",
          "[Added Lines]",
          "63:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "68:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "73:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "82:     @Test(expected = IllegalArgumentException.class)",
          "83:     public void checkServerTrusted_nonNullNull() throws Exception {",
          "85:     }",
          "87:     @Test(expected = IllegalArgumentException.class)",
          "88:     public void checkServerTrusted_nonNullEmpty() throws Exception {",
          "90:     }",
          "92:     @Test",
          "93:     public void checkClientTrusted1() throws Exception {",
          "95:     }",
          "97:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "84:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null);",
          "89:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\");",
          "94:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "83:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null);",
          "88:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\");",
          "93:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "102:     @Test(expected = IllegalArgumentException.class)",
          "103:     public void checkClientTrusted1_nonNullNull() throws Exception {",
          "105:     }",
          "107:     @Test(expected = IllegalArgumentException.class)",
          "108:     public void checkClientTrusted1_nonNullEmpty() throws Exception {",
          "110:     }",
          "112:     @Test",
          "113:     public void checkServerTrusted1() throws Exception {",
          "115:     }",
          "117:     @Test(expected = IllegalArgumentException.class)",
          "",
          "[Removed Lines]",
          "104:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "109:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "114:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", new Socket());",
          "",
          "[Added Lines]",
          "103:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "108:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "113:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", new Socket());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "122:     @Test(expected = IllegalArgumentException.class)",
          "123:     public void checkServerTrusted1_nonNullNull() throws Exception {",
          "125:     }",
          "127:     @Test(expected = IllegalArgumentException.class)",
          "128:     public void checkServerTrusted1_nonNullEmpty() throws Exception {",
          "130:     }",
          "132:     @Test",
          "133:     public void checkClientTrusted2() throws Exception {",
          "135:     }",
          "137:     @Test(expected = IllegalArgumentException.class)",
          "138:     public void checkClientTrusted2_nullNonNull() throws Exception {",
          "140:     }",
          "142:     @Test(expected = IllegalArgumentException.class)",
          "143:     public void checkClientTrusted2_nonNullNull() throws Exception {",
          "145:     }",
          "147:     @Test(expected = IllegalArgumentException.class)",
          "148:     public void checkClientTrusted2_nonNullEmpty() throws Exception {",
          "150:     }",
          "152:     @Test",
          "153:     public void checkServerTrusted2() throws Exception {",
          "155:     }",
          "157:     @Test(expected = IllegalArgumentException.class)",
          "158:     public void checkServerTrusted2_nullNonNull() throws Exception {",
          "160:     }",
          "162:     @Test(expected = IllegalArgumentException.class)",
          "163:     public void checkServerTrusted2_nonNullNull() throws Exception {",
          "165:     }",
          "167:     @Test(expected = IllegalArgumentException.class)",
          "168:     public void checkServerTrusted2_nonNullEmpty() throws Exception {",
          "170:     }",
          "172:     @Test(expected = CertificateException.class)",
          "173:     public void checkClientExpired() throws Exception {",
          "175:     }",
          "177:     @Test(expected = CertificateException.class)",
          "178:     public void checkServerExpired() throws Exception {",
          "180:     }",
          "182:     @Test(expected = CertificateException.class)",
          "183:     public void checkClientExpired1() throws Exception {",
          "185:     }",
          "187:     @Test(expected = CertificateException.class)",
          "188:     public void checkServerExpired1() throws Exception {",
          "190:     }",
          "192:     @Test(expected = CertificateException.class)",
          "193:     public void checkClientExpired2() throws Exception {",
          "195:     }",
          "197:     @Test(expected = CertificateException.class)",
          "198:     public void checkServerExpired2() throws Exception {",
          "200:     }",
          "202:     @Test",
          "203:     public void getAcceptedIssuers() {",
          "204:         assertThat(instance.getAcceptedIssuers(), notNullValue());",
          "205:     }",
          "207: }",
          "",
          "[Removed Lines]",
          "124:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, new Socket());",
          "129:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", new Socket());",
          "134:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "139:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine)null);",
          "144:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "149:         instance.checkClientTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "154:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"RSA\", (SSLEngine)null);",
          "159:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine)null);",
          "164:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, null, (SSLEngine)null);",
          "169:         instance.checkServerTrusted(new X509Certificate[]{cert.certificate()}, \"\", (SSLEngine)null);",
          "174:         instance.checkClientTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\");",
          "179:         instance.checkServerTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\");",
          "184:         instance.checkClientTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\", new Socket());",
          "189:         instance.checkServerTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\", new Socket());",
          "194:         instance.checkClientTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\", (SSLEngine)null);",
          "199:         instance.checkServerTrusted(new X509Certificate[]{expired.certificate()}, \"RSA\", (SSLEngine)null);",
          "",
          "[Added Lines]",
          "123:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, new Socket());",
          "128:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", new Socket());",
          "133:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "138:         instance.checkClientTrusted(null, \"RSA\", (SSLEngine) null);",
          "143:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "148:         instance.checkClientTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "153:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"RSA\", (SSLEngine) null);",
          "158:         instance.checkServerTrusted(null, \"RSA\", (SSLEngine) null);",
          "163:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, null, (SSLEngine) null);",
          "168:         instance.checkServerTrusted(new X509Certificate[] {cert.certificate()}, \"\", (SSLEngine) null);",
          "173:         instance.checkClientTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\");",
          "178:         instance.checkServerTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\");",
          "183:         instance.checkClientTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\", new Socket());",
          "188:         instance.checkServerTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\", new Socket());",
          "193:         instance.checkClientTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\", (SSLEngine) null);",
          "198:         instance.checkServerTrusted(new X509Certificate[] {expired.certificate()}, \"RSA\", (SSLEngine) null);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java||src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java -> src/test/java/org/jenkinsci/remoting/protocol/cert/X509CertificateRule.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     private final String id;",
          "60:     private X509Certificate certificate;",
          "63:         return new X509CertificateRule(id, subject, subject, null, -7, 7, TimeUnit.DAYS);",
          "64:     }",
          "68:         return new X509CertificateRule(id, subject, signer, signerCertificate, -7, 7, TimeUnit.DAYS);",
          "69:     }",
          "72:         return selfSigned(\"\", subject);",
          "73:     }",
          "77:         return create(\"\", subject, signer, signerCertificate);",
          "78:     }",
          "87:         return new X509CertificateRule(id, subject, signer, signerCertificate, startDateOffset, endDateOffset, units);",
          "88:     }",
          "92:         this.id = id;",
          "93:         this.subjectKey = subjectKey;",
          "94:         this.signerKey = signerKey;",
          "",
          "[Removed Lines]",
          "62:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule selfSigned(String id, KeyPairRule<PUB,PRIV> subject) {",
          "66:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(String id, KeyPairRule<PUB,PRIV> subject,",
          "67:                                                                                               KeyPairRule<PUB, PRIV> signer, X509CertificateRule signerCertificate) {",
          "71:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule selfSigned(KeyPairRule<PUB,PRIV> subject) {",
          "75:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(KeyPairRule<PUB,PRIV> subject,",
          "76:                                                                                               KeyPairRule<PUB, PRIV> signer, X509CertificateRule signerCertificate) {",
          "80:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(String id,",
          "81:                                                                                               KeyPairRule<PUB,PRIV> subject,",
          "82:                                                                                               KeyPairRule<PUB, PRIV> signer,",
          "83:                                                                                               X509CertificateRule signerCertificate,",
          "84:                                                                                               long startDateOffset,",
          "85:                                                                                               long endDateOffset,",
          "86:                                                                                               TimeUnit units) {",
          "90:     public X509CertificateRule(String id, KeyPairRule<? extends PublicKey, ? extends PrivateKey> subjectKey,",
          "91:                                KeyPairRule<? extends PublicKey, ? extends PrivateKey> signerKey, X509CertificateRule signerCertificate, long startDateOffset, long endDateOffset, TimeUnit units) {",
          "",
          "[Added Lines]",
          "62:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule selfSigned(",
          "63:             String id, KeyPairRule<PUB, PRIV> subject) {",
          "67:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(",
          "68:             String id,",
          "69:             KeyPairRule<PUB, PRIV> subject,",
          "70:             KeyPairRule<PUB, PRIV> signer,",
          "71:             X509CertificateRule signerCertificate) {",
          "75:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule selfSigned(",
          "76:             KeyPairRule<PUB, PRIV> subject) {",
          "80:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(",
          "81:             KeyPairRule<PUB, PRIV> subject, KeyPairRule<PUB, PRIV> signer, X509CertificateRule signerCertificate) {",
          "85:     public static <PUB extends PublicKey, PRIV extends PrivateKey> X509CertificateRule create(",
          "86:             String id,",
          "87:             KeyPairRule<PUB, PRIV> subject,",
          "88:             KeyPairRule<PUB, PRIV> signer,",
          "89:             X509CertificateRule signerCertificate,",
          "90:             long startDateOffset,",
          "91:             long endDateOffset,",
          "92:             TimeUnit units) {",
          "96:     public X509CertificateRule(",
          "97:             String id,",
          "98:             KeyPairRule<? extends PublicKey, ? extends PrivateKey> subjectKey,",
          "99:             KeyPairRule<? extends PublicKey, ? extends PrivateKey> signerKey,",
          "100:             X509CertificateRule signerCertificate,",
          "101:             long startDateOffset,",
          "102:             long endDateOffset,",
          "103:             TimeUnit units) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:     @Override",
          "105:     public Statement apply(final Statement base, final Description description) {",
          "106:         Skip skip = description.getAnnotation(Skip.class);",
          "108:             return base;",
          "109:         }",
          "110:         return new Statement() {",
          "",
          "[Removed Lines]",
          "107:         if (skip != null && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "[Added Lines]",
          "119:         if (skip != null",
          "120:                 && (skip.value().length == 0 || Arrays.asList(skip.value()).contains(id))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121:                 X500Principal subject = new X500Principal(nameBuilder",
          "122:                         .addRDN(BCStyle.CN, description.getDisplayName())",
          "123:                         .addRDN(BCStyle.C, \"US\")",
          "128:                 X509v3CertificateBuilder certGen = new JcaX509v3CertificateBuilder(",
          "137:                 JcaX509ExtensionUtils instance = new JcaX509ExtensionUtils();",
          "140:                         false,",
          "144:                 ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\")",
          "145:                         .setProvider(BOUNCY_CASTLE_PROVIDER)",
          "",
          "[Removed Lines]",
          "124:                         .build().toString());",
          "126:                 X500Principal issuer = signerCertificate != null ? signerCertificate.certificate().getSubjectX500Principal() : subject;",
          "129:                         issuer,",
          "130:                         BigInteger.ONE,",
          "131:                         firstDate,",
          "132:                         lastDate,",
          "133:                         subject,",
          "134:                         subjectKey.getPublic()",
          "135:                 );",
          "139:                 certGen.addExtension(Extension.subjectKeyIdentifier,",
          "141:                         instance.createSubjectKeyIdentifier(subjectKey.getPublic())",
          "142:                 );",
          "",
          "[Added Lines]",
          "137:                         .build()",
          "138:                         .toString());",
          "140:                 X500Principal issuer = signerCertificate != null",
          "141:                         ? signerCertificate.certificate().getSubjectX500Principal()",
          "142:                         : subject;",
          "145:                         issuer, BigInteger.ONE, firstDate, lastDate, subject, subjectKey.getPublic());",
          "149:                 certGen.addExtension(",
          "150:                         Extension.subjectKeyIdentifier,",
          "152:                         instance.createSubjectKeyIdentifier(subjectKey.getPublic()));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/AckFilterLayerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:     @Rule",
          "57:     public TestName name = new TestName();",
          "58:     private IOHubRule selector = new IOHubRule();",
          "59:     @Rule",
          "64:     private Pipe clientToServer;",
          "65:     private Pipe serverToClient;",
          "",
          "[Removed Lines]",
          "60:     public RuleChain chain = RuleChain.outerRule(selector)",
          "61:             .around(new RepeatRule())",
          "62:             .around(new Timeout(10, TimeUnit.SECONDS));",
          "",
          "[Added Lines]",
          "62:     public RuleChain chain =",
          "63:             RuleChain.outerRule(selector).around(new RepeatRule()).around(new Timeout(10, TimeUnit.SECONDS));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     @Theory",
          "92:     public void smokes(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "106:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "107:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "93:         ProtocolStack<IOBufferMatcher> client =",
          "94:                 ProtocolStack",
          "95:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "96:                         .filter(new AckFilterLayer(\"ACK\"))",
          "97:                         .build(new IOBufferMatcherLayer());",
          "100:         ProtocolStack<IOBufferMatcher> server =",
          "101:                 ProtocolStack",
          "102:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "103:                         .filter(new AckFilterLayer(\"ACK\"))",
          "104:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "94:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "95:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "96:                 .filter(new AckFilterLayer(\"ACK\"))",
          "97:                 .build(new IOBufferMatcherLayer());",
          "99:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "100:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "101:                 .filter(new AckFilterLayer(\"ACK\"))",
          "102:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117:     @Theory",
          "118:     public void clientSendsShortAck(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory)",
          "119:             throws Exception {",
          "133:         client.get().awaitClose();",
          "134:         assertThat(client.get().getCloseCause(), instanceOf(ConnectionRefusalException.class));",
          "",
          "[Removed Lines]",
          "120:         ProtocolStack<IOBufferMatcher> client =",
          "121:                 ProtocolStack",
          "122:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "123:                         .filter(new AckFilterLayer(\"AC\"))",
          "124:                         .build(new IOBufferMatcherLayer());",
          "127:         ProtocolStack<IOBufferMatcher> server =",
          "128:                 ProtocolStack",
          "129:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "130:                         .filter(new AckFilterLayer(\"ACK\"))",
          "131:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "118:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "119:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "120:                 .filter(new AckFilterLayer(\"AC\"))",
          "121:                 .build(new IOBufferMatcherLayer());",
          "123:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "124:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "125:                 .filter(new AckFilterLayer(\"ACK\"))",
          "126:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "140:     @Repeat(100)",
          "141:     public void serverSendsShortAck(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory)",
          "142:             throws Exception {",
          "156:         client.get().awaitClose();",
          "157:         assertThat(client.get().getCloseCause(), instanceOf(ConnectionRefusalException.class));",
          "",
          "[Removed Lines]",
          "143:         ProtocolStack<IOBufferMatcher> client =",
          "144:                 ProtocolStack",
          "145:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "146:                         .filter(new AckFilterLayer(\"ACK\"))",
          "147:                         .build(new IOBufferMatcherLayer());",
          "150:         ProtocolStack<IOBufferMatcher> server =",
          "151:                 ProtocolStack",
          "152:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "153:                         .filter(new AckFilterLayer(\"AC\"))",
          "154:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "138:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "139:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "140:                 .filter(new AckFilterLayer(\"ACK\"))",
          "141:                 .build(new IOBufferMatcherLayer());",
          "143:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "144:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "145:                 .filter(new AckFilterLayer(\"AC\"))",
          "146:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "162:     @Theory",
          "163:     @Repeat(100)",
          "164:     public void ackMismatch(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "178:         client.get().awaitClose();",
          "179:         assertThat(client.get().getCloseCause(), instanceOf(ConnectionRefusalException.class));",
          "180:         server.get().awaitClose();",
          "181:         assertThat(server.get().getCloseCause(), instanceOf(ConnectionRefusalException.class));",
          "182:     }",
          "184: }",
          "",
          "[Removed Lines]",
          "165:         ProtocolStack<IOBufferMatcher> client =",
          "166:                 ProtocolStack",
          "167:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "168:                         .filter(new AckFilterLayer(\"AcK\"))",
          "169:                         .build(new IOBufferMatcherLayer());",
          "172:         ProtocolStack<IOBufferMatcher> server =",
          "173:                 ProtocolStack",
          "174:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "175:                         .filter(new AckFilterLayer(\"ACK\"))",
          "176:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "157:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "158:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "159:                 .filter(new AckFilterLayer(\"AcK\"))",
          "160:                 .build(new IOBufferMatcherLayer());",
          "162:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "163:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "164:                 .filter(new AckFilterLayer(\"ACK\"))",
          "165:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersFilterLayerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     @Rule",
          "65:     public TestName name = new TestName();",
          "66:     private IOHubRule selector = new IOHubRule();",
          "67:     @Rule",
          "72:     private Pipe clientToServer;",
          "73:     private Pipe serverToClient;",
          "",
          "[Removed Lines]",
          "68:     public RuleChain chain = RuleChain.outerRule(selector)",
          "69:             .around(new RepeatRule())",
          "70:             .around(new Timeout(10, TimeUnit.SECONDS));",
          "",
          "[Added Lines]",
          "70:     public RuleChain chain =",
          "71:             RuleChain.outerRule(selector).around(new RepeatRule()).around(new Timeout(10, TimeUnit.SECONDS));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:     @Theory",
          "100:     public void smokes(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "115:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "116:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "101:         ProtocolStack<IOBufferMatcher> client =",
          "102:                 ProtocolStack",
          "103:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "104:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "105:                                 headers -> {}))",
          "106:                         .build(new IOBufferMatcherLayer());",
          "108:         ProtocolStack<IOBufferMatcher> server =",
          "109:                 ProtocolStack",
          "110:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "111:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "112:                                 headers -> {}))",
          "113:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "102:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "103:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "104:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "105:                 .build(new IOBufferMatcherLayer());",
          "107:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "108:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "109:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "110:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:     @Theory",
          "127:     public void clientRejects(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "144:         client.get().awaitClose();",
          "145:         assertThat(client.get().getCloseCause(), instanceOf(PermanentConnectionRefusalException.class));",
          "",
          "[Removed Lines]",
          "128:         ProtocolStack<IOBufferMatcher> client =",
          "129:                 ProtocolStack",
          "130:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "131:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "132:                                 headers -> {",
          "133:                                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "134:                                 }))",
          "135:                         .build(new IOBufferMatcherLayer());",
          "137:         ProtocolStack<IOBufferMatcher> server =",
          "138:                 ProtocolStack",
          "139:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "140:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "141:                                 headers -> {}))",
          "142:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "125:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "126:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "127:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "128:                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "129:                 }))",
          "130:                 .build(new IOBufferMatcherLayer());",
          "132:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "133:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "134:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "135:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:     @Theory",
          "151:     public void serverRejects(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "168:         client.get().awaitClose();",
          "169:         assertThat(client.get().getCloseCause(), instanceOf(PermanentConnectionRefusalException.class));",
          "",
          "[Removed Lines]",
          "152:         ProtocolStack<IOBufferMatcher> client =",
          "153:                 ProtocolStack",
          "154:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "155:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "156:                                 headers -> {}))",
          "157:                         .build(new IOBufferMatcherLayer());",
          "159:         ProtocolStack<IOBufferMatcher> server =",
          "160:                 ProtocolStack",
          "161:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "162:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "163:                                 headers -> {",
          "164:                                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "165:                                 }))",
          "166:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "145:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "146:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "147:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "148:                 .build(new IOBufferMatcherLayer());",
          "150:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "151:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "152:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "153:                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "154:                 }))",
          "155:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "174:     @Theory",
          "175:     public void bothReject(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "194:         client.get().awaitClose();",
          "198:         server.get().awaitClose();",
          "202:     }",
          "204:     @Theory",
          "205:     public void clientRefuses(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "222:         client.get().awaitClose();",
          "225:         server.get().awaitClose();",
          "229:     }",
          "231:     @Theory",
          "232:     public void serverRefuses(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "249:         client.get().awaitClose();",
          "253:         server.get().awaitClose();",
          "256:     }",
          "258:     @Theory",
          "259:     public void bothRefuse(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "278:         client.get().awaitClose();",
          "282:         server.get().awaitClose();",
          "286:     }",
          "288:     @Theory",
          "",
          "[Removed Lines]",
          "176:         ProtocolStack<IOBufferMatcher> client =",
          "177:                 ProtocolStack",
          "178:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "179:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "180:                                 headers -> {",
          "181:                                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "182:                                 }))",
          "183:                         .build(new IOBufferMatcherLayer());",
          "185:         ProtocolStack<IOBufferMatcher> server =",
          "186:                 ProtocolStack",
          "187:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "188:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "189:                                 headers -> {",
          "190:                                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "191:                                 }))",
          "192:                         .build(new IOBufferMatcherLayer());",
          "195:         assertThat(client.get().getCloseCause(),",
          "196:                 instanceOf(PermanentConnectionRefusalException.class)",
          "197:         );",
          "199:         assertThat(server.get().getCloseCause(),",
          "200:                 instanceOf(PermanentConnectionRefusalException.class)",
          "201:         );",
          "206:         ProtocolStack<IOBufferMatcher> client =",
          "207:                 ProtocolStack",
          "208:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "209:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "210:                                 headers -> {",
          "211:                                     throw new ConnectionRefusalException(\"Go away\");",
          "212:                                 }))",
          "213:                         .build(new IOBufferMatcherLayer());",
          "215:         ProtocolStack<IOBufferMatcher> server =",
          "216:                 ProtocolStack",
          "217:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "218:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "219:                                 headers -> {}))",
          "220:                         .build(new IOBufferMatcherLayer());",
          "223:         assertThat(client.get().getCloseCause(),",
          "224:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class))));",
          "226:         assertThat(server.get().getCloseCause(),",
          "227:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class)))",
          "228:         );",
          "233:         ProtocolStack<IOBufferMatcher> client =",
          "234:                 ProtocolStack",
          "235:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "236:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "237:                                 headers -> {}))",
          "238:                         .build(new IOBufferMatcherLayer());",
          "240:         ProtocolStack<IOBufferMatcher> server =",
          "241:                 ProtocolStack",
          "242:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "243:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "244:                                 headers -> {",
          "245:                                     throw new ConnectionRefusalException(\"Go away\");",
          "246:                                 }))",
          "247:                         .build(new IOBufferMatcherLayer());",
          "250:         assertThat(client.get().getCloseCause(),",
          "251:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class)))",
          "252:         );",
          "254:         assertThat(server.get().getCloseCause(),",
          "255:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class))));",
          "260:         ProtocolStack<IOBufferMatcher> client =",
          "261:                 ProtocolStack",
          "262:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "263:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "264:                                 headers -> {",
          "265:                                     throw new ConnectionRefusalException(\"Go away\");",
          "266:                                 }))",
          "267:                         .build(new IOBufferMatcherLayer());",
          "269:         ProtocolStack<IOBufferMatcher> server =",
          "270:                 ProtocolStack",
          "271:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "272:                         .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(),",
          "273:                                 headers -> {",
          "274:                                     throw new ConnectionRefusalException(\"Go away\");",
          "275:                                 }))",
          "276:                         .build(new IOBufferMatcherLayer());",
          "279:         assertThat(client.get().getCloseCause(),",
          "280:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class)))",
          "281:         );",
          "283:         assertThat(server.get().getCloseCause(),",
          "284:                 allOf(instanceOf(ConnectionRefusalException.class), not(instanceOf(PermanentConnectionRefusalException.class)))",
          "285:         );",
          "",
          "[Added Lines]",
          "165:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "166:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "167:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "168:                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "169:                 }))",
          "170:                 .build(new IOBufferMatcherLayer());",
          "172:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "173:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "174:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "175:                     throw new PermanentConnectionRefusalException(\"Go away\");",
          "176:                 }))",
          "177:                 .build(new IOBufferMatcherLayer());",
          "180:         assertThat(client.get().getCloseCause(), instanceOf(PermanentConnectionRefusalException.class));",
          "182:         assertThat(server.get().getCloseCause(), instanceOf(PermanentConnectionRefusalException.class));",
          "187:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "188:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "189:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "190:                     throw new ConnectionRefusalException(\"Go away\");",
          "191:                 }))",
          "192:                 .build(new IOBufferMatcherLayer());",
          "194:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "195:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "196:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "197:                 .build(new IOBufferMatcherLayer());",
          "200:         assertThat(",
          "201:                 client.get().getCloseCause(),",
          "202:                 allOf(",
          "203:                         instanceOf(ConnectionRefusalException.class),",
          "204:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "206:         assertThat(",
          "207:                 server.get().getCloseCause(),",
          "208:                 allOf(",
          "209:                         instanceOf(ConnectionRefusalException.class),",
          "210:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "215:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "216:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "217:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {}))",
          "218:                 .build(new IOBufferMatcherLayer());",
          "220:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "221:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "222:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "223:                     throw new ConnectionRefusalException(\"Go away\");",
          "224:                 }))",
          "225:                 .build(new IOBufferMatcherLayer());",
          "228:         assertThat(",
          "229:                 client.get().getCloseCause(),",
          "230:                 allOf(",
          "231:                         instanceOf(ConnectionRefusalException.class),",
          "232:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "234:         assertThat(",
          "235:                 server.get().getCloseCause(),",
          "236:                 allOf(",
          "237:                         instanceOf(ConnectionRefusalException.class),",
          "238:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "243:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "244:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "245:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "246:                     throw new ConnectionRefusalException(\"Go away\");",
          "247:                 }))",
          "248:                 .build(new IOBufferMatcherLayer());",
          "250:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "251:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "252:                 .filter(new ConnectionHeadersFilterLayer(Collections.emptyMap(), headers -> {",
          "253:                     throw new ConnectionRefusalException(\"Go away\");",
          "254:                 }))",
          "255:                 .build(new IOBufferMatcherLayer());",
          "258:         assertThat(",
          "259:                 client.get().getCloseCause(),",
          "260:                 allOf(",
          "261:                         instanceOf(ConnectionRefusalException.class),",
          "262:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "264:         assertThat(",
          "265:                 server.get().getCloseCause(),",
          "266:                 allOf(",
          "267:                         instanceOf(ConnectionRefusalException.class),",
          "268:                         not(instanceOf(PermanentConnectionRefusalException.class))));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "293:         for (int i = 1 + entropy.nextInt(50); i > 0; i--) {",
          "294:             clientExpectedHeaders.put(Long.toHexString(entropy.nextLong()), Long.toHexString(entropy.nextLong()));",
          "295:         }",
          "303:         final CompletableFuture<Map<String, String>> clientActualHeaders = new CompletableFuture<>();",
          "304:         Map<String, String> serverExpectedHeaders = new HashMap<>();",
          "305:         for (int i = 1 + entropy.nextInt(50); i > 0; i--) {",
          "306:             serverExpectedHeaders.put(Long.toHexString(entropy.nextLong()), Long.toHexString(entropy.nextLong()));",
          "307:         }",
          "315:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "316:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "296:         ProtocolStack<IOBufferMatcher> client =",
          "297:                 ProtocolStack",
          "298:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "299:                         .filter(new ConnectionHeadersFilterLayer(clientExpectedHeaders,",
          "300:                                 serverActualHeaders::complete))",
          "301:                         .build(new IOBufferMatcherLayer());",
          "308:         ProtocolStack<IOBufferMatcher> server =",
          "309:                 ProtocolStack",
          "310:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "311:                         .filter(new ConnectionHeadersFilterLayer(serverExpectedHeaders,",
          "312:                                 clientActualHeaders::complete))",
          "313:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "279:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "280:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "281:                 .filter(new ConnectionHeadersFilterLayer(clientExpectedHeaders, serverActualHeaders::complete))",
          "282:                 .build(new IOBufferMatcherLayer());",
          "289:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "290:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "291:                 .filter(new ConnectionHeadersFilterLayer(serverExpectedHeaders, clientActualHeaders::complete))",
          "292:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "334:         }",
          "336:         final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> {",
          "341:                     .build(new IOBufferMatcherLayer());",
          "342:         });",
          "343:         assertThat(e.getMessage(), containsString(\"less than 65536\"));",
          "344:     }",
          "346: }",
          "",
          "[Removed Lines]",
          "337:             ProtocolStack",
          "338:                     .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "339:                     .filter(new ConnectionHeadersFilterLayer(clientExpectedHeaders,",
          "340:                             serverActualHeaders::complete))",
          "",
          "[Added Lines]",
          "316:             ProtocolStack.on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "317:                     .filter(new ConnectionHeadersFilterLayer(clientExpectedHeaders, serverActualHeaders::complete))",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/ConnectionHeadersTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     @Test",
          "43:     public void emptyRoundTrip() throws Exception {",
          "45:                 is(Collections.<String, String>emptyMap()));",
          "46:     }",
          "48:     @Test",
          "49:     public void singleValueRoundTrip() throws Exception {",
          "52:     }",
          "54:     @Test",
          "",
          "[Removed Lines]",
          "44:         assertThat(ConnectionHeaders.fromString(ConnectionHeaders.toString(Collections.emptyMap())),",
          "50:         assertThat(ConnectionHeaders.fromString(ConnectionHeaders.toString(Map.of(\"a\", \"b\"))),",
          "51:                 is(Map.of(\"a\", \"b\")));",
          "",
          "[Added Lines]",
          "44:         assertThat(",
          "45:                 ConnectionHeaders.fromString(ConnectionHeaders.toString(Collections.emptyMap())),",
          "51:         assertThat(ConnectionHeaders.fromString(ConnectionHeaders.toString(Map.of(\"a\", \"b\"))), is(Map.of(\"a\", \"b\")));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:         payload.put(\"e\\u0009\", \"'hi\\u0008there'\");",
          "63:         payload.put(\"\\f\\b\\n\\r\\t/\\\\\", \"null\");",
          "64:         payload.put(\"a/b/c/d\", \"e\\\\f\\\\g\\\\h\");",
          "67:     }",
          "69:     @Test",
          "70:     public void newlineEscaping() {",
          "73:     }",
          "75:     @Test",
          "",
          "[Removed Lines]",
          "65:         assertThat(ConnectionHeaders.fromString(ConnectionHeaders.toString(payload)),",
          "66:                 is(payload));",
          "71:         assertThat(ConnectionHeaders.toString(Map.of(\"a\\nmultiline\\nkey\", \"b\")),",
          "72:                 not(containsString(\"\\n\")));",
          "",
          "[Added Lines]",
          "65:         assertThat(ConnectionHeaders.fromString(ConnectionHeaders.toString(payload)), is(payload));",
          "70:         assertThat(ConnectionHeaders.toString(Map.of(\"a\\nmultiline\\nkey\", \"b\")), not(containsString(\"\\n\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:         Map<String, String> expected = new TreeMap<>();",
          "78:         expected.put(\"key\", \"value\");",
          "79:         expected.put(\"foo\", \"bar\");",
          "81:                 is(expected));",
          "82:     }",
          "",
          "[Removed Lines]",
          "80:         assertThat(ConnectionHeaders.fromString(\"\\n{\\n  \\\"key\\\"\\t:\\f\\\"value\\\"\\n,\\n\\\"foo\\\"   :   \\\"bar\\\"\\n}\\n\\n\"),",
          "",
          "[Added Lines]",
          "78:         assertThat(",
          "79:                 ConnectionHeaders.fromString(\"\\n{\\n  \\\"key\\\"\\t:\\f\\\"value\\\"\\n,\\n\\\"foo\\\"   :   \\\"bar\\\"\\n}\\n\\n\"),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "86:         Map<String, String> expected = new TreeMap<>();",
          "87:         expected.put(\"key\", \"value/other\");",
          "88:         expected.put(\"foo\", \"bar\\\\manchu\");",
          "92:                 is(expected));",
          "93:     }",
          "",
          "[Removed Lines]",
          "89:         assertThat(ConnectionHeaders.fromString(",
          "90:                 \" \\b\\t\\n\\r\\f{ \\b\\t\\n\\r\\f\\\"key\\\" \\b\\t\\n\\r\\f: \\b\\t\\n\\r\\f\\\"value\\\\/other\\\" \\b\\t\\n\\r\\f, \\b\\t\\n\\r\\f\\\"foo\\\" \"",
          "91:                         + \"\\b\\t\\n\\r\\f: \\b\\t\\n\\r\\f\\\"bar\\\\\\\\manchu\\\" \\b\\t\\n\\r\\f} \\b\\t\\n\\r\\f\"),",
          "",
          "[Added Lines]",
          "88:         assertThat(",
          "89:                 ConnectionHeaders.fromString(",
          "90:                         \" \\b\\t\\n\\r\\f{ \\b\\t\\n\\r\\f\\\"key\\\" \\b\\t\\n\\r\\f: \\b\\t\\n\\r\\f\\\"value\\\\/other\\\" \\b\\t\\n\\r\\f, \\b\\t\\n\\r\\f\\\"foo\\\" \"",
          "91:                                 + \"\\b\\t\\n\\r\\f: \\b\\t\\n\\r\\f\\\"bar\\\\\\\\manchu\\\" \\b\\t\\n\\r\\f} \\b\\t\\n\\r\\f\"),",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java||src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/HoldFilterLayer.java"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/NetworkLayerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:     }",
          "83:     @Theory",
          "96:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "97:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "84:     public void doBasicSendReceive(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "85:         ProtocolStack<IOBufferMatcher> client =",
          "86:                 ProtocolStack",
          "87:                         .on(clientFactory.create(hub, serverToClient.source(), clientToServer.sink()))",
          "88:                         .build(new IOBufferMatcherLayer());",
          "91:         ProtocolStack<IOBufferMatcher> server =",
          "92:                 ProtocolStack",
          "93:                         .on(serverFactory.create(hub, clientToServer.source(), serverToClient.sink()))",
          "94:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "84:     public void doBasicSendReceive(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory)",
          "85:             throws Exception {",
          "86:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "87:                         clientFactory.create(hub, serverToClient.source(), clientToServer.sink()))",
          "88:                 .build(new IOBufferMatcherLayer());",
          "90:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "91:                         serverFactory.create(hub, clientToServer.source(), serverToClient.sink()))",
          "92:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java||src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/NoOpFilterLayer.java"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java||src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/SSLEngineFilterLayerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:     private static RSAKeyPairRule serverKey = new RSAKeyPairRule();",
          "75:     private static RSAKeyPairRule caRootKey = new RSAKeyPairRule();",
          "76:     private static X509CertificateRule caRootCert = X509CertificateRule.create(\"caRoot\", caRootKey, caRootKey, null);",
          "79:     private static X509CertificateRule expiredClientCert =",
          "80:             X509CertificateRule.create(\"expiredClient\", clientKey, caRootKey, caRootCert, -10, -5, TimeUnit.DAYS);",
          "81:     private static X509CertificateRule notYetValidServerCert =",
          "82:             X509CertificateRule.create(\"notYetValidServer\", serverKey, caRootKey, caRootCert, +5, +10, TimeUnit.DAYS);",
          "103:     private static SSLContextRule untrustingClientCtx =",
          "107:     private static SSLContextRule untrustingServerCtx =",
          "111:     @ClassRule",
          "112:     public static RuleChain staticCtx = RuleChain.outerRule(caRootKey)",
          "113:             .around(clientKey)",
          "",
          "[Removed Lines]",
          "77:     private static X509CertificateRule clientCert = X509CertificateRule.create(\"client\", clientKey, caRootKey, caRootCert);",
          "78:     private static X509CertificateRule serverCert = X509CertificateRule.create(\"server\", serverKey, caRootKey, caRootCert);",
          "83:     private static SSLContextRule clientCtx =",
          "84:             new SSLContextRule(\"client\")",
          "85:                     .as(clientKey, clientCert, caRootCert)",
          "86:                     .trusting(caRootCert)",
          "87:                     .trusting(serverCert);",
          "88:     private static SSLContextRule serverCtx =",
          "89:             new SSLContextRule(\"server\")",
          "90:                     .as(serverKey, serverCert, caRootCert)",
          "91:                     .trusting(caRootCert)",
          "92:                     .trusting(clientCert);",
          "93:     private static SSLContextRule expiredClientCtx =",
          "94:             new SSLContextRule(\"expiredClient\")",
          "95:                     .as(clientKey, expiredClientCert, caRootCert)",
          "96:                     .trusting(caRootCert)",
          "97:                     .trusting(serverCert);",
          "98:     private static SSLContextRule notYetValidServerCtx =",
          "99:             new SSLContextRule(\"notYetValidServer\")",
          "100:                     .as(serverKey, notYetValidServerCert, caRootCert)",
          "101:                     .trusting(caRootCert)",
          "102:                     .trusting(clientCert);",
          "104:             new SSLContextRule(\"untrustingClient\")",
          "105:                     .as(clientKey, clientCert)",
          "106:                     .trusting(caRootCert);",
          "108:             new SSLContextRule(\"untrustingServer\")",
          "109:                     .as(serverKey, serverCert)",
          "110:                     .trusting(caRootCert);",
          "",
          "[Added Lines]",
          "77:     private static X509CertificateRule clientCert =",
          "78:             X509CertificateRule.create(\"client\", clientKey, caRootKey, caRootCert);",
          "79:     private static X509CertificateRule serverCert =",
          "80:             X509CertificateRule.create(\"server\", serverKey, caRootKey, caRootCert);",
          "85:     private static SSLContextRule clientCtx = new SSLContextRule(\"client\")",
          "86:             .as(clientKey, clientCert, caRootCert)",
          "87:             .trusting(caRootCert)",
          "88:             .trusting(serverCert);",
          "89:     private static SSLContextRule serverCtx = new SSLContextRule(\"server\")",
          "90:             .as(serverKey, serverCert, caRootCert)",
          "91:             .trusting(caRootCert)",
          "92:             .trusting(clientCert);",
          "93:     private static SSLContextRule expiredClientCtx = new SSLContextRule(\"expiredClient\")",
          "94:             .as(clientKey, expiredClientCert, caRootCert)",
          "95:             .trusting(caRootCert)",
          "96:             .trusting(serverCert);",
          "97:     private static SSLContextRule notYetValidServerCtx = new SSLContextRule(\"notYetValidServer\")",
          "98:             .as(serverKey, notYetValidServerCert, caRootCert)",
          "99:             .trusting(caRootCert)",
          "100:             .trusting(clientCert);",
          "102:             new SSLContextRule(\"untrustingClient\").as(clientKey, clientCert).trusting(caRootCert);",
          "104:             new SSLContextRule(\"untrustingServer\").as(serverKey, serverCert).trusting(caRootCert);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:         SSLEngine clientEngine = clientCtx.createSSLEngine();",
          "188:         clientEngine.setUseClientMode(true);",
          "192:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "199:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "203:         byte[] expected = \"Here is some sample data\".getBytes(StandardCharsets.UTF_8);",
          "204:         ByteBuffer data = ByteBuffer.allocate(expected.length);",
          "",
          "[Removed Lines]",
          "190:         ProtocolStack<IOBufferMatcher> client =",
          "191:                 ProtocolStack.on(",
          "193:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "194:                         .build(new IOBufferMatcherLayer());",
          "197:         ProtocolStack<IOBufferMatcher> server =",
          "198:                 ProtocolStack.on(",
          "200:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "201:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "189:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "191:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "192:                 .build(new IOBufferMatcherLayer());",
          "194:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "196:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "197:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:     }",
          "214:     @Theory",
          "216:         SSLEngine serverEngine = serverCtx.createSSLEngine();",
          "217:         serverEngine.setUseClientMode(false);",
          "218:         serverEngine.setNeedClientAuth(true);",
          "219:         SSLEngine clientEngine = clientCtx.createSSLEngine();",
          "220:         clientEngine.setUseClientMode(true);",
          "224:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "233:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "237:         IOBufferMatcher clientMatcher = client.get();",
          "238:         IOBufferMatcher serverMatcher = server.get();",
          "",
          "[Removed Lines]",
          "215:     public void clientRejectsServer(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "222:         ProtocolStack<IOBufferMatcher> client =",
          "223:                 ProtocolStack.on(",
          "225:                         .filter(new SSLEngineFilterLayer(clientEngine, session -> {",
          "226:                             throw new ConnectionRefusalException(\"Bad server\");",
          "227:                         }))",
          "228:                         .build(new IOBufferMatcherLayer());",
          "231:         ProtocolStack<IOBufferMatcher> server =",
          "232:                 ProtocolStack.on(",
          "234:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "235:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "211:     public void clientRejectsServer(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory)",
          "212:             throws Exception {",
          "219:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "221:                 .filter(new SSLEngineFilterLayer(clientEngine, session -> {",
          "222:                     throw new ConnectionRefusalException(\"Bad server\");",
          "223:                 }))",
          "224:                 .build(new IOBufferMatcherLayer());",
          "226:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "228:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "229:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "243:         assertThat(serverMatcher.getCloseCause(), instanceOf(ClosedChannelException.class));",
          "244:     }",
          "247:     @Theory",
          "253:                 });",
          "254:         SSLEngine serverEngine = serverCtx.createSSLEngine();",
          "255:         serverEngine.setUseClientMode(false);",
          "",
          "[Removed Lines]",
          "248:     public void serverRejectsClient(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "249:         Logger.getLogger(name.getMethodName()).log(",
          "250:                 Level.INFO, \"Starting test with server {0} client {1}\", new Object[]{",
          "251:                         serverFactory.getClass().getSimpleName(),",
          "252:                         clientFactory.getClass().getSimpleName(),",
          "",
          "[Added Lines]",
          "241:     public void serverRejectsClient(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory)",
          "242:             throws Exception {",
          "243:         Logger.getLogger(name.getMethodName())",
          "244:                 .log(Level.INFO, \"Starting test with server {0} client {1}\", new Object[] {",
          "245:                     serverFactory.getClass().getSimpleName(),",
          "246:                     clientFactory.getClass().getSimpleName(),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "257:         SSLEngine clientEngine = clientCtx.createSSLEngine();",
          "258:         clientEngine.setUseClientMode(true);",
          "262:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "269:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "275:         IOBufferMatcher clientMatcher = client.get();",
          "276:         IOBufferMatcher serverMatcher = server.get();",
          "",
          "[Removed Lines]",
          "260:         ProtocolStack<IOBufferMatcher> client =",
          "261:                 ProtocolStack.on(",
          "263:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "264:                         .build(new IOBufferMatcherLayer());",
          "267:         ProtocolStack<IOBufferMatcher> server =",
          "268:                 ProtocolStack.on(",
          "270:                         .filter(new SSLEngineFilterLayer(serverEngine, session -> {",
          "271:                             throw new ConnectionRefusalException(\"Bad client\");",
          "272:                         }))",
          "273:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "254:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "256:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "257:                 .build(new IOBufferMatcherLayer());",
          "259:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "261:                 .filter(new SSLEngineFilterLayer(serverEngine, session -> {",
          "262:                     throw new ConnectionRefusalException(\"Bad client\");",
          "263:                 }))",
          "264:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "293:         SSLEngine clientEngine = untrustingClientCtx.createSSLEngine();",
          "294:         clientEngine.setUseClientMode(true);",
          "298:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "305:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "309:         IOBufferMatcher clientMatcher = client.get();",
          "310:         IOBufferMatcher serverMatcher = server.get();",
          "",
          "[Removed Lines]",
          "296:         ProtocolStack<IOBufferMatcher> client =",
          "297:                 ProtocolStack.on(",
          "299:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "300:                         .build(new IOBufferMatcherLayer());",
          "303:         ProtocolStack<IOBufferMatcher> server =",
          "304:                 ProtocolStack.on(",
          "306:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "307:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "287:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "289:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "290:                 .build(new IOBufferMatcherLayer());",
          "292:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "294:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "295:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "324:         SSLEngine clientEngine = expiredClientCtx.createSSLEngine();",
          "325:         clientEngine.setUseClientMode(true);",
          "329:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "336:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "340:         IOBufferMatcher clientMatcher = client.get();",
          "341:         IOBufferMatcher serverMatcher = server.get();",
          "",
          "[Removed Lines]",
          "327:         ProtocolStack<IOBufferMatcher> client =",
          "328:                 ProtocolStack.on(",
          "330:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "331:                         .build(new IOBufferMatcherLayer());",
          "334:         ProtocolStack<IOBufferMatcher> server =",
          "335:                 ProtocolStack.on(",
          "337:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "338:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "315:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "317:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "318:                 .build(new IOBufferMatcherLayer());",
          "320:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "322:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "323:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "347:     }",
          "349:     @Theory",
          "352:         SSLEngine serverEngine = notYetValidServerCtx.createSSLEngine();",
          "353:         serverEngine.setUseClientMode(false);",
          "354:         serverEngine.setNeedClientAuth(true);",
          "355:         SSLEngine clientEngine = expiredClientCtx.createSSLEngine();",
          "356:         clientEngine.setUseClientMode(true);",
          "360:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "367:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "371:         IOBufferMatcher clientMatcher = client.get();",
          "372:         IOBufferMatcher serverMatcher = server.get();",
          "",
          "[Removed Lines]",
          "350:     public void clientDoesNotConnectToNotYetValidServer(NetworkLayerFactory serverFactory,",
          "351:                                                         NetworkLayerFactory clientFactory) throws Exception {",
          "358:         ProtocolStack<IOBufferMatcher> client =",
          "359:                 ProtocolStack.on(",
          "361:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "362:                         .build(new IOBufferMatcherLayer());",
          "365:         ProtocolStack<IOBufferMatcher> server =",
          "366:                 ProtocolStack.on(",
          "368:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "369:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "335:     public void clientDoesNotConnectToNotYetValidServer(",
          "336:             NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory) throws Exception {",
          "343:         ProtocolStack<IOBufferMatcher> client = ProtocolStack.on(",
          "345:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "346:                 .build(new IOBufferMatcherLayer());",
          "348:         ProtocolStack<IOBufferMatcher> server = ProtocolStack.on(",
          "350:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "351:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "461:         concurrentStress(serverFactory, clientFactory, 65536, 65536);",
          "462:     }",
          "466:             throws IOException, InterruptedException, ExecutionException {",
          "473:         SSLEngine serverEngine = serverCtx.createSSLEngine();",
          "474:         serverEngine.setUseClientMode(false);",
          "475:         serverEngine.setNeedClientAuth(true);",
          "476:         SSLEngine clientEngine = clientCtx.createSSLEngine();",
          "477:         clientEngine.setUseClientMode(true);",
          "481:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "488:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "492:         final IOBufferMatcher client = clientStack.get();",
          "493:         final IOBufferMatcher server = serverStack.get();",
          "",
          "[Removed Lines]",
          "464:     private void concurrentStress(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory, int serverLimit,",
          "465:                                   int clientLimit)",
          "467:         Logger.getLogger(name.getMethodName()).log(",
          "468:                 Level.INFO, \"Starting test with server {0} client {1} serverLimit {2} clientLimit {3}\", new Object[]{",
          "469:                         serverFactory.getClass().getSimpleName(),",
          "470:                         clientFactory.getClass().getSimpleName(),",
          "471:                         serverLimit, clientLimit",
          "472:                 });",
          "479:         ProtocolStack<IOBufferMatcher> clientStack =",
          "480:                 ProtocolStack.on(",
          "482:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "483:                         .build(new IOBufferMatcherLayer());",
          "486:         ProtocolStack<IOBufferMatcher> serverStack =",
          "487:                 ProtocolStack.on(",
          "489:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "490:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "446:     private void concurrentStress(",
          "447:             NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory, int serverLimit, int clientLimit)",
          "449:         Logger.getLogger(name.getMethodName())",
          "450:                 .log(",
          "451:                         Level.INFO,",
          "452:                         \"Starting test with server {0} client {1} serverLimit {2} clientLimit {3}\",",
          "453:                         new Object[] {",
          "454:                             serverFactory.getClass().getSimpleName(),",
          "455:                             clientFactory.getClass().getSimpleName(),",
          "456:                             serverLimit,",
          "457:                             clientLimit",
          "458:                         });",
          "465:         ProtocolStack<IOBufferMatcher> clientStack = ProtocolStack.on(",
          "467:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "468:                 .build(new IOBufferMatcherLayer());",
          "470:         ProtocolStack<IOBufferMatcher> serverStack = ProtocolStack.on(",
          "472:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "473:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "511:     }",
          "513:     @Theory",
          "516:             throws IOException, InterruptedException, ExecutionException {",
          "522:                 });",
          "523:         SSLEngine serverEngine = serverCtx.createSSLEngine();",
          "524:         serverEngine.setUseClientMode(false);",
          "",
          "[Removed Lines]",
          "514:     public void sendingBiggerAndBiggerBatches(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory,",
          "515:                                               BatchSendBufferingFilterLayer batch)",
          "517:         Logger.getLogger(name.getMethodName()).log(",
          "518:                 Level.INFO, \"Starting test with server {0} client {1} batch {2}\", new Object[]{",
          "519:                         serverFactory.getClass().getSimpleName(),",
          "520:                         clientFactory.getClass().getSimpleName(),",
          "521:                         batch",
          "",
          "[Added Lines]",
          "497:     public void sendingBiggerAndBiggerBatches(",
          "498:             NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory, BatchSendBufferingFilterLayer batch)",
          "500:         Logger.getLogger(name.getMethodName())",
          "501:                 .log(Level.INFO, \"Starting test with server {0} client {1} batch {2}\", new Object[] {",
          "502:                     serverFactory.getClass().getSimpleName(),",
          "503:                     clientFactory.getClass().getSimpleName(),",
          "504:                     batch",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "526:         SSLEngine clientEngine = clientCtx.createSSLEngine();",
          "527:         clientEngine.setUseClientMode(true);",
          "543:         final IOBufferMatcher client = clientStack.get();",
          "544:         final IOBufferMatcher server = serverStack.get();",
          "",
          "[Removed Lines]",
          "529:         ProtocolStack<IOBufferMatcher> clientStack =",
          "530:                 ProtocolStack",
          "531:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "532:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "533:                         .build(new IOBufferMatcherLayer());",
          "536:         ProtocolStack<IOBufferMatcher> serverStack =",
          "537:                 ProtocolStack",
          "538:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "539:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "540:                         .filter(batch)",
          "541:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "512:         ProtocolStack<IOBufferMatcher> clientStack = ProtocolStack.on(",
          "513:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "514:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "515:                 .build(new IOBufferMatcherLayer());",
          "517:         ProtocolStack<IOBufferMatcher> serverStack = ProtocolStack.on(",
          "518:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "519:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "520:                 .filter(batch)",
          "521:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "560:     }",
          "562:     @Theory",
          "565:             throws IOException, InterruptedException, ExecutionException {",
          "571:                 });",
          "572:         SSLEngine serverEngine = serverCtx.createSSLEngine();",
          "573:         serverEngine.setUseClientMode(false);",
          "",
          "[Removed Lines]",
          "563:     public void bidiSendingBiggerAndBiggerBatches(NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory,",
          "564:                                                   BatchSendBufferingFilterLayer batch)",
          "566:         Logger.getLogger(name.getMethodName()).log(",
          "567:                 Level.INFO, \"Starting test with server {0} client {1} batch {2}\", new Object[]{",
          "568:                         serverFactory.getClass().getSimpleName(),",
          "569:                         clientFactory.getClass().getSimpleName(),",
          "570:                         batch",
          "",
          "[Added Lines]",
          "543:     public void bidiSendingBiggerAndBiggerBatches(",
          "544:             NetworkLayerFactory serverFactory, NetworkLayerFactory clientFactory, BatchSendBufferingFilterLayer batch)",
          "546:         Logger.getLogger(name.getMethodName())",
          "547:                 .log(Level.INFO, \"Starting test with server {0} client {1} batch {2}\", new Object[] {",
          "548:                     serverFactory.getClass().getSimpleName(),",
          "549:                     clientFactory.getClass().getSimpleName(),",
          "550:                     batch",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "576:         clientEngine.setUseClientMode(true);",
          "578:         BatchSendBufferingFilterLayer clientBatch = batch.clone();",
          "598:         final IOBufferMatcher client = clientStack.get();",
          "599:         final IOBufferMatcher server = serverStack.get();",
          "",
          "[Removed Lines]",
          "579:         ProtocolStack<IOBufferMatcher> clientStack =",
          "580:                 ProtocolStack",
          "581:                         .on(clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "582:                         .filter(new NoOpFilterLayer())",
          "583:                         .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "584:                         .filter(clientBatch)",
          "585:                         .filter(new NoOpFilterLayer())",
          "586:                         .build(new IOBufferMatcherLayer());",
          "589:         ProtocolStack<IOBufferMatcher> serverStack =",
          "590:                 ProtocolStack",
          "591:                         .on(serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "592:                         .filter(new NoOpFilterLayer())",
          "593:                         .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "594:                         .filter(batch)",
          "595:                         .filter(new NoOpFilterLayer())",
          "596:                         .build(new IOBufferMatcherLayer());",
          "",
          "[Added Lines]",
          "559:         ProtocolStack<IOBufferMatcher> clientStack = ProtocolStack.on(",
          "560:                         clientFactory.create(selector.hub(), serverToClient.source(), clientToServer.sink()))",
          "561:                 .filter(new NoOpFilterLayer())",
          "562:                 .filter(new SSLEngineFilterLayer(clientEngine, null))",
          "563:                 .filter(clientBatch)",
          "564:                 .filter(new NoOpFilterLayer())",
          "565:                 .build(new IOBufferMatcherLayer());",
          "567:         ProtocolStack<IOBufferMatcher> serverStack = ProtocolStack.on(",
          "568:                         serverFactory.create(selector.hub(), clientToServer.source(), serverToClient.sink()))",
          "569:                 .filter(new NoOpFilterLayer())",
          "570:                 .filter(new SSLEngineFilterLayer(serverEngine, null))",
          "571:                 .filter(batch)",
          "572:                 .filter(new NoOpFilterLayer())",
          "573:                 .build(new IOBufferMatcherLayer());",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java||src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java": [
          "File: src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java -> src/test/java/org/jenkinsci/remoting/protocol/impl/SequentialSender.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:             }",
          "124:             if (nextLog - System.nanoTime() < 0) {",
          "125:                 nextLog = System.nanoTime() + TimeUnit.SECONDS.toNanos(5);",
          "127:             }",
          "128:         }",
          "130:         return null;",
          "131:     }",
          "",
          "[Removed Lines]",
          "126:                 LOGGER.log(Level.INFO, \"Sent {0} in {1} blocks\", new Object[]{count, n});",
          "129:         LOGGER.log(Level.INFO, \"Done {0} in {1} blocks\", new Object[]{limit, n});",
          "",
          "[Added Lines]",
          "126:                 LOGGER.log(Level.INFO, \"Sent {0} in {1} blocks\", new Object[] {count, n});",
          "129:         LOGGER.log(Level.INFO, \"Done {0} in {1} blocks\", new Object[] {limit, n});",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java -> src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueInputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "114:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "116:             StringBuilder buf = new StringBuilder();",
          "117:             int b;",
          "118:             do {",
          "",
          "[Removed Lines]",
          "115:         try (ByteBufferQueueInputStream instance = new ByteBufferQueueInputStream(queue) ) {",
          "",
          "[Added Lines]",
          "115:         try (ByteBufferQueueInputStream instance = new ByteBufferQueueInputStream(queue)) {",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java -> src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueOutputStreamTest.java"
        ],
        "src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java||src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java -> src/test/java/org/jenkinsci/remoting/util/ByteBufferQueueTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     public void putGetByteAndHasRemaining() {",
          "60:         ByteBufferQueue queue = new ByteBufferQueue(100);",
          "61:         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {",
          "63:             queue.put(b);",
          "64:             assertThat(queue.hasRemaining(), is(true));",
          "65:             assertThat(queue.get(), is(b));",
          "",
          "[Removed Lines]",
          "62:             byte b = (byte)i;",
          "",
          "[Added Lines]",
          "62:             byte b = (byte) i;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:         ByteBufferQueue queue = new ByteBufferQueue(100);",
          "73:         ByteBuffer src = ByteBuffer.allocate(1);",
          "74:         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {",
          "76:             src.clear();",
          "77:             src.put(b);",
          "78:             src.flip();",
          "",
          "[Removed Lines]",
          "75:             byte b = (byte)i;",
          "",
          "[Added Lines]",
          "75:             byte b = (byte) i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:         ByteBufferQueue queue = new ByteBufferQueue(100);",
          "93:         ByteBuffer src = ByteBuffer.allocate(1);",
          "94:         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {",
          "96:             queue.put(b);",
          "97:             assertThat(queue.hasRemaining(), is(true));",
          "98:         }",
          "",
          "[Removed Lines]",
          "95:             byte b = (byte)i;",
          "",
          "[Added Lines]",
          "95:             byte b = (byte) i;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:     public void putGetByteSequences() {",
          "112:         ByteBufferQueue queue = new ByteBufferQueue(100);",
          "113:         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {",
          "115:             queue.put(b);",
          "116:             assertThat(queue.hasRemaining(), is(true));",
          "117:         }",
          "",
          "[Removed Lines]",
          "114:             byte b = (byte)i;",
          "",
          "[Added Lines]",
          "114:             byte b = (byte) i;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:         ByteBufferQueue queue = new ByteBufferQueue(100);",
          "129:         byte[] dst = new byte[1];",
          "130:         for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {",
          "132:             queue.put(b);",
          "133:             assertThat(queue.hasRemaining(), is(true));",
          "134:         }",
          "",
          "[Removed Lines]",
          "131:             byte b = (byte)i;",
          "",
          "[Added Lines]",
          "131:             byte b = (byte) i;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "484:     }",
          "486:     @Test",
          "488:         interleavingReadWrite(7, 11, 13, 853, 19, 5);",
          "489:     }",
          "491:     @Test",
          "493:         interleavingReadWrite(7, 11, 13, 853, 19, 5);",
          "494:     }",
          "496:     @Test",
          "498:         interleavingReadWrite(23, 37, 53, 1051, 13, 29);",
          "499:     }",
          "502:         ByteBufferQueue queue = new ByteBufferQueue(intSize);",
          "503:         ByteBuffer src = ByteBuffer.allocate(srcSize);",
          "504:         ByteBuffer dst = ByteBuffer.allocate(dstSize);",
          "",
          "[Removed Lines]",
          "487:     public void interleavingReadWrite_7_11_13_853_19_5(){",
          "492:     public void interleavingReadWrite_7_11_13_853_5_19(){",
          "497:     public void interleavingReadWrite_23_37_53_1051_13_29(){",
          "501:     public void interleavingReadWrite(int intSize, int srcSize, int dstSize, int srcCount, int srcModulus, int dstModulus) {",
          "",
          "[Added Lines]",
          "487:     public void interleavingReadWrite_7_11_13_853_19_5() {",
          "492:     public void interleavingReadWrite_7_11_13_853_5_19() {",
          "497:     public void interleavingReadWrite_23_37_53_1051_13_29() {",
          "501:     public void interleavingReadWrite(",
          "502:             int intSize, int srcSize, int dstSize, int srcCount, int srcModulus, int dstModulus) {",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java||src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java -> src/test/java/org/jenkinsci/remoting/util/DurationFormatterTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     public void typical() {",
          "11:         assertEquals(\"1 second\", DurationFormatter.format(Duration.ofSeconds(1)));",
          "12:         assertEquals(\"2 seconds\", DurationFormatter.format(Duration.ofSeconds(2)));",
          "21:     }",
          "22: }",
          "",
          "[Removed Lines]",
          "13:         assertEquals(\"1 day, 2 seconds\", DurationFormatter.format(Duration.ofDays(1).plus(Duration.ofSeconds(2))));",
          "14:         assertEquals(\"2 days, 3 hours, 2 seconds\", DurationFormatter.format(Duration.ofDays(2).plus(Duration.ofHours(3)).plus(Duration.ofSeconds(2))));",
          "15:         assertEquals(\"2 days, 3 hours, 1 minute, 2 seconds\", DurationFormatter.format(",
          "16:                 Duration.ofDays(2)",
          "17:                 .plus(Duration.ofHours(3))",
          "18:                 .plus(Duration.ofMinutes(1))",
          "19:                 .plus(Duration.ofSeconds(2)",
          "20:                 )));",
          "",
          "[Added Lines]",
          "13:         assertEquals(",
          "14:                 \"1 day, 2 seconds\", DurationFormatter.format(Duration.ofDays(1).plus(Duration.ofSeconds(2))));",
          "15:         assertEquals(",
          "16:                 \"2 days, 3 hours, 2 seconds\",",
          "17:                 DurationFormatter.format(",
          "18:                         Duration.ofDays(2).plus(Duration.ofHours(3)).plus(Duration.ofSeconds(2))));",
          "19:         assertEquals(",
          "20:                 \"2 days, 3 hours, 1 minute, 2 seconds\",",
          "21:                 DurationFormatter.format(Duration.ofDays(2)",
          "22:                         .plus(Duration.ofHours(3))",
          "23:                         .plus(Duration.ofMinutes(1))",
          "24:                         .plus(Duration.ofSeconds(2))));",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java||src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java -> src/test/java/org/jenkinsci/remoting/util/FastByteBufferQueueInputStreamTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "64:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "67:         assertThat(read(instance, 10), is(\"AbCdEfGhIj\"));",
          "68:     }",
          "",
          "[Removed Lines]",
          "65:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue,26);",
          "",
          "[Added Lines]",
          "65:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue, 26);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "75:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "78:         byte[] bytes = new byte[10];",
          "79:         assertThat(instance.read(bytes), is(10));",
          "",
          "[Removed Lines]",
          "76:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue,26);",
          "",
          "[Added Lines]",
          "76:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue, 26);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "93:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "96:         byte[] bytes = new byte[10];",
          "98:         assertThat(new String(bytes, StandardCharsets.UTF_8), is(\"\\u0000\\u0000\\u0000\\u0000\\u0000AbC\\u0000\\u0000\"));",
          "99:         assertThat(instance.read(bytes, 0, 2), is(2));",
          "100:         assertThat(new String(bytes, StandardCharsets.UTF_8), is(\"dE\\u0000\\u0000\\u0000AbC\\u0000\\u0000\"));",
          "",
          "[Removed Lines]",
          "94:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue,26);",
          "97:         assertThat(instance.read(bytes,5,3), is(3));",
          "",
          "[Added Lines]",
          "94:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue, 26);",
          "97:         assertThat(instance.read(bytes, 5, 3), is(3));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "114:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "115:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "117:             StringBuilder buf = new StringBuilder();",
          "118:             int b;",
          "119:             do {",
          "",
          "[Removed Lines]",
          "116:         try (FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue,26)) {",
          "",
          "[Added Lines]",
          "116:         try (FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue, 26)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "138:         ByteBufferQueue queue = new ByteBufferQueue(10);",
          "139:         queue.put(ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8)));",
          "141:         assertThat(instance.markSupported(), is(false));",
          "142:         instance.close();",
          "143:     }",
          "",
          "[Removed Lines]",
          "140:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue,26);",
          "",
          "[Added Lines]",
          "140:         FastByteBufferQueueInputStream instance = new FastByteBufferQueueInputStream(queue, 26);",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java||src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java -> src/test/java/org/jenkinsci/remoting/util/SettableFutureTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:         assertFalse(async.set(42));",
          "143:     }",
          "147:         assertTrue(future.isDone());",
          "148:         assertFalse(future.isCancelled());",
          "",
          "[Removed Lines]",
          "145:     public void assertCompletedFuture(@Nullable Object expectedValue)",
          "146:             throws InterruptedException, ExecutionException {",
          "",
          "[Added Lines]",
          "145:     public void assertCompletedFuture(@Nullable Object expectedValue) throws InterruptedException, ExecutionException {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:         assertEquals(expectedValue, future.get());",
          "155:     }",
          "159:         assertTrue(future.isDone());",
          "160:         assertTrue(future.isCancelled());",
          "",
          "[Removed Lines]",
          "157:     public void assertCancelledFuture()",
          "158:             throws InterruptedException, ExecutionException {",
          "",
          "[Added Lines]",
          "156:     public void assertCancelledFuture() throws InterruptedException, ExecutionException {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:         assertTrue(future.isDone());",
          "164:         assertTrue(future.isCancelled());",
          "168:     }",
          "172:         assertTrue(future.isDone());",
          "173:         assertFalse(future.isCancelled());",
          "",
          "[Removed Lines]",
          "166:         assertThrows(\"Future should throw CancellationException on cancel.\",",
          "167:                 CancellationException.class, () -> future.get());",
          "170:     public void assertFailedFuture(@Nullable String message)",
          "171:             throws InterruptedException {",
          "",
          "[Added Lines]",
          "164:         assertThrows(",
          "165:                 \"Future should throw CancellationException on cancel.\",",
          "166:                 CancellationException.class,",
          "167:                 () -> future.get());",
          "170:     public void assertFailedFuture(@Nullable String message) throws InterruptedException {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "176:         assertTrue(future.isDone());",
          "177:         assertFalse(future.isCancelled());",
          "181:         assertThat(e.getCause().getMessage(), is(message));",
          "182:     }",
          "184: }",
          "",
          "[Removed Lines]",
          "179:         final ExecutionException e = assertThrows(\"Future should rethrow the exception.\",",
          "180:                 ExecutionException.class, () -> future.get());",
          "",
          "[Added Lines]",
          "178:         final ExecutionException e =",
          "179:                 assertThrows(\"Future should rethrow the exception.\", ExecutionException.class, () -> future.get());",
          "",
          "---------------"
        ],
        "src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java||src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java": [
          "File: src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java -> src/test/java/org/jenkinsci/remoting/util/VersionNumberTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: public class VersionNumberTest extends TestCase {",
          "37:     public void testIsNewerThan() {",
          "50:     }",
          "52:     public void testEarlyAccess() {",
          "56:     }",
          "58:     public void testSnapshots() {",
          "63:         assertNotEquals(new VersionNumber(\"1.12-SNAPSHOT\"), new VersionNumber(\"1.11.*\"));",
          "64:         assertTrue(new VersionNumber(\"1.11.*\").isNewerThan(new VersionNumber(\"1.11.9\")));",
          "",
          "[Removed Lines]",
          "38:        assertTrue(new VersionNumber(\"2.0.*\").isNewerThan(new VersionNumber(\"2.0\")));",
          "39:        assertTrue(new VersionNumber(\"2.1-SNAPSHOT\").isNewerThan(new VersionNumber(\"2.0.*\")));",
          "40:        assertTrue(new VersionNumber(\"2.1\").isNewerThan(new VersionNumber(\"2.1-SNAPSHOT\")));",
          "41:        assertTrue(new VersionNumber(\"2.0.*\").isNewerThan(new VersionNumber(\"2.0.1\")));",
          "42:        assertTrue(new VersionNumber(\"2.0.1\").isNewerThan(new VersionNumber(\"2.0.1-SNAPSHOT\")));",
          "43:        assertTrue(new VersionNumber(\"2.0.1-SNAPSHOT\").isNewerThan(new VersionNumber(\"2.0.0.99\")));",
          "44:        assertTrue(new VersionNumber(\"2.0.0.99\").isNewerThan(new VersionNumber(\"2.0.0\")));",
          "45:        assertTrue(new VersionNumber(\"2.0.0\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "46:        assertTrue(new VersionNumber(\"2.0\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "49:        assertEquals(new VersionNumber(\"2.0.0\"), new VersionNumber(\"2.0\"));",
          "53:        assertTrue(new VersionNumber(\"2.0.ea2\").isNewerThan(new VersionNumber(\"2.0.ea1\")));",
          "54:        assertTrue(new VersionNumber(\"2.0.ea1\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "55:        assertEquals(new VersionNumber(\"2.0.ea\"), new VersionNumber(\"2.0.ea0\"));",
          "59:         assertTrue(new VersionNumber(\"1.12\").isNewerThan(new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\")));",
          "60:         assertTrue(new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\").isNewerThan(new VersionNumber(\"1.11\")));",
          "61:         assertEquals(new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\"), new VersionNumber(\"1.12-SNAPSHOT\"));",
          "",
          "[Added Lines]",
          "39:         assertTrue(new VersionNumber(\"2.0.*\").isNewerThan(new VersionNumber(\"2.0\")));",
          "40:         assertTrue(new VersionNumber(\"2.1-SNAPSHOT\").isNewerThan(new VersionNumber(\"2.0.*\")));",
          "41:         assertTrue(new VersionNumber(\"2.1\").isNewerThan(new VersionNumber(\"2.1-SNAPSHOT\")));",
          "42:         assertTrue(new VersionNumber(\"2.0.*\").isNewerThan(new VersionNumber(\"2.0.1\")));",
          "43:         assertTrue(new VersionNumber(\"2.0.1\").isNewerThan(new VersionNumber(\"2.0.1-SNAPSHOT\")));",
          "44:         assertTrue(new VersionNumber(\"2.0.1-SNAPSHOT\").isNewerThan(new VersionNumber(\"2.0.0.99\")));",
          "45:         assertTrue(new VersionNumber(\"2.0.0.99\").isNewerThan(new VersionNumber(\"2.0.0\")));",
          "46:         assertTrue(new VersionNumber(\"2.0.0\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "47:         assertTrue(new VersionNumber(\"2.0\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "50:         assertEquals(new VersionNumber(\"2.0.0\"), new VersionNumber(\"2.0\"));",
          "54:         assertTrue(new VersionNumber(\"2.0.ea2\").isNewerThan(new VersionNumber(\"2.0.ea1\")));",
          "55:         assertTrue(new VersionNumber(\"2.0.ea1\").isNewerThan(new VersionNumber(\"2.0.ea\")));",
          "56:         assertEquals(new VersionNumber(\"2.0.ea\"), new VersionNumber(\"2.0.ea0\"));",
          "60:         assertTrue(new VersionNumber(\"1.12\")",
          "61:                 .isNewerThan(new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\")));",
          "62:         assertTrue(new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\")",
          "63:                 .isNewerThan(new VersionNumber(\"1.11\")));",
          "64:         assertEquals(",
          "65:                 new VersionNumber(\"1.12-SNAPSHOT (private-08/24/2008 12:13-hudson)\"),",
          "66:                 new VersionNumber(\"1.12-SNAPSHOT\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:         assertTrue(new VersionNumber(\"2.0.3-20170207.105042-1\").isNewerThan(new VersionNumber(\"2.0.2\")));",
          "69:         assertTrue(new VersionNumber(\"2.0.3\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-1\")));",
          "70:         assertEquals(new VersionNumber(\"2.0.3-20170207.105042-1\"), new VersionNumber(\"2.0.3-SNAPSHOT\"));",
          "75:         assertFalse(new VersionNumber(\"2.0.3-20170207.105042-1\").isNewerThan(new VersionNumber(\"2.0.3-SNAPSHOT\")));",
          "76:         assertFalse(new VersionNumber(\"2.0.3-20170207.105042-1\").isOlderThan(new VersionNumber(\"2.0.3-SNAPSHOT\")));",
          "77:     }",
          "",
          "[Removed Lines]",
          "71:         assertEquals(new VersionNumber(\"2.0.3-20170207.105042-1\"), new VersionNumber(\"2.0.3-SNAPSHOT (private-08/24/2008 12:13-hudson)\"));",
          "72:         assertTrue(new VersionNumber(\"2.0.3-20170207.105043-2\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-1\")));",
          "73:         assertTrue(new VersionNumber(\"2.0.3-20170207.105042-2\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-1\")));",
          "74:         assertTrue(new VersionNumber(\"2.0.3-20170207.105042-13\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-2\")));",
          "",
          "[Added Lines]",
          "76:         assertEquals(",
          "77:                 new VersionNumber(\"2.0.3-20170207.105042-1\"),",
          "78:                 new VersionNumber(\"2.0.3-SNAPSHOT (private-08/24/2008 12:13-hudson)\"));",
          "79:         assertTrue(",
          "80:                 new VersionNumber(\"2.0.3-20170207.105043-2\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-1\")));",
          "81:         assertTrue(",
          "82:                 new VersionNumber(\"2.0.3-20170207.105042-2\").isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-1\")));",
          "83:         assertTrue(new VersionNumber(\"2.0.3-20170207.105042-13\")",
          "84:                 .isNewerThan(new VersionNumber(\"2.0.3-20170207.105042-2\")));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f9e939397a09a8089518eb94ed607b135295701d",
      "candidate_info": {
        "commit_hash": "f9e939397a09a8089518eb94ed607b135295701d",
        "repo": "jenkinsci/remoting",
        "commit_url": "https://github.com/jenkinsci/remoting/commit/f9e939397a09a8089518eb94ed607b135295701d",
        "files": [
          "src/main/java/hudson/remoting/Channel.java",
          "src/main/java/hudson/remoting/JarURLValidator.java",
          "src/main/java/hudson/remoting/PreloadJarTask.java",
          "src/main/java/hudson/remoting/PreloadJarTask2.java",
          "src/main/java/hudson/remoting/RemoteClassLoader.java"
        ],
        "message": "[SECURITY-3430]",
        "before_after_code_files": [
          "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
          "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java",
          "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
          "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java",
          "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
            "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java",
            "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
            "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java",
            "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
          ],
          "candidate": [
            "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java",
            "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java",
            "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java",
            "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java",
            "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/hudson/remoting/Channel.java||src/main/java/hudson/remoting/Channel.java": [
          "File: src/main/java/hudson/remoting/Channel.java -> src/main/java/hudson/remoting/Channel.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: import java.net.URL;",
          "44: import java.nio.channels.ClosedChannelException;",
          "45: import java.nio.charset.StandardCharsets;",
          "46: import java.util.Collections;",
          "47: import java.util.Date;",
          "48: import java.util.List;",
          "49: import java.util.Locale;",
          "50: import java.util.Map;",
          "51: import java.util.WeakHashMap;",
          "52: import java.util.concurrent.ConcurrentHashMap;",
          "53: import java.util.concurrent.CopyOnWriteArrayList;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: import java.util.Arrays;",
          "49: import java.util.HashSet;",
          "53: import java.util.Set;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "993:         return preloadJar(UserRequest.getClassLoader(classLoaderRef), classesInJar);",
          "994:     }",
          "996:     public boolean preloadJar(ClassLoader local, Class<?>... classesInJar) throws IOException, InterruptedException {",
          "1000:         }",
          "1002:     }",
          "1004:     public boolean preloadJar(ClassLoader local, URL... jars) throws IOException, InterruptedException {",
          "1006:     }",
          "",
          "[Removed Lines]",
          "997:         URL[] jars = new URL[classesInJar.length];",
          "998:         for (int i = 0; i < classesInJar.length; i++) {",
          "999:             jars[i] = Which.jarFile(classesInJar[i]).toURI().toURL();",
          "1001:         return call(new PreloadJarTask(jars, local));",
          "1005:         return call(new PreloadJarTask(jars, local));",
          "",
          "[Added Lines]",
          "999:     @SuppressFBWarnings(",
          "1000:             value = \"DMI_COLLECTION_OF_URLS\",",
          "1001:             justification = \"All URLs point to local files, so no DNS lookup.\")",
          "1003:         Set<URL> jarSet = new HashSet<>();",
          "1004:         for (Class<?> clazz : classesInJar) {",
          "1005:             jarSet.add(Which.jarFile(clazz).toURI().toURL());",
          "1007:         URL[] jars = jarSet.toArray(new URL[0]);",
          "1008:         return preloadJar(local, jars);",
          "1011:     @SuppressFBWarnings(value = \"URLCONNECTION_SSRF_FD\", justification = \"Callers are privileged controller-side code.\")",
          "1013:         byte[][] contents = new byte[jars.length][0];",
          "1015:         List<URL> jarList = Arrays.asList(jars);",
          "1016:         for (int i = 0; i < jarList.size(); i++) {",
          "1017:             final URL url = jarList.get(i);",
          "1018:             jars[i] = url;",
          "1019:             contents[i] = Util.readFully(url.openStream());",
          "1020:         }",
          "1021:         try {",
          "1022:             return call(new PreloadJarTask2(jars, contents, local));",
          "1023:         } catch (IOException ex) {",
          "1024:             if (ex.getCause() instanceof IllegalAccessError) {",
          "1025:                 logger.log(",
          "1026:                         Level.FINE,",
          "1027:                         ex,",
          "1028:                         () -> \"Failed to call PreloadJarTask2 on \" + this + \", retrying with PreloadJarTask\");",
          "1040:                 return call(new PreloadJarTask(jars, local));",
          "1041:             }",
          "1042:             throw ex;",
          "1043:         }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/JarURLValidator.java||src/main/java/hudson/remoting/JarURLValidator.java": [
          "File: src/main/java/hudson/remoting/JarURLValidator.java -> src/main/java/hudson/remoting/JarURLValidator.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package hudson.remoting;",
          "3: import java.io.IOException;",
          "4: import java.net.URL;",
          "12: @Deprecated",
          "13: public interface JarURLValidator {",
          "14:     void validate(URL url) throws IOException;",
          "15: }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PreloadJarTask.java||src/main/java/hudson/remoting/PreloadJarTask.java": [
          "File: src/main/java/hudson/remoting/PreloadJarTask.java -> src/main/java/hudson/remoting/PreloadJarTask.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: final class PreloadJarTask implements DelegatingCallable<Boolean, IOException> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: @Deprecated",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/PreloadJarTask2.java||src/main/java/hudson/remoting/PreloadJarTask2.java": [
          "File: src/main/java/hudson/remoting/PreloadJarTask2.java -> src/main/java/hudson/remoting/PreloadJarTask2.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: package hudson.remoting;",
          "26: import edu.umd.cs.findbugs.annotations.CheckForNull;",
          "27: import java.io.IOException;",
          "28: import java.net.URL;",
          "29: import org.jenkinsci.remoting.Role;",
          "30: import org.jenkinsci.remoting.RoleChecker;",
          "40: final class PreloadJarTask2 implements DelegatingCallable<Boolean, IOException> {",
          "44:     private final URL[] jars;",
          "46:     private final byte[][] contents;",
          "52:     @CheckForNull",
          "53:     private transient ClassLoader target = null;",
          "55:     PreloadJarTask2(URL[] jars, byte[][] contents, @CheckForNull ClassLoader target) {",
          "56:         if (jars.length != contents.length) {",
          "57:             throw new IllegalArgumentException(\"Got \" + jars.length + \" jars and \" + contents.length + \" contents\");",
          "58:         }",
          "59:         this.jars = jars;",
          "60:         this.contents = contents;",
          "61:         this.target = target;",
          "62:     }",
          "64:     @Override",
          "65:     public ClassLoader getClassLoader() {",
          "66:         return target;",
          "67:     }",
          "69:     @Override",
          "70:     public Boolean call() throws IOException {",
          "71:         ClassLoader cl = Thread.currentThread().getContextClassLoader();",
          "73:         try {",
          "74:             if (!(cl instanceof RemoteClassLoader)) {",
          "75:                 return false;",
          "76:             }",
          "77:             final RemoteClassLoader rcl = (RemoteClassLoader) cl;",
          "79:             boolean r = false;",
          "80:             for (int i = 0; i < jars.length; i++) {",
          "81:                 r |= rcl.prefetch(jars[i], contents[i]);",
          "82:             }",
          "83:             return r;",
          "84:         } catch (IllegalAccessError iae) {",
          "86:             throw new IOException(iae);",
          "87:         }",
          "88:     }",
          "94:     @Override",
          "95:     public void checkRoles(RoleChecker checker) throws SecurityException {",
          "96:         checker.check(this, Role.UNKNOWN);",
          "97:     }",
          "99:     private static final long serialVersionUID = -773448303394727271L;",
          "100: }",
          "",
          "---------------"
        ],
        "src/main/java/hudson/remoting/RemoteClassLoader.java||src/main/java/hudson/remoting/RemoteClassLoader.java": [
          "File: src/main/java/hudson/remoting/RemoteClassLoader.java -> src/main/java/hudson/remoting/RemoteClassLoader.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "687:         synchronized (prefetchedJars) {",
          "688:             if (prefetchedJars.contains(jar)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "689:     @Deprecated",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "698:         }",
          "699:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "716:         synchronized (prefetchedJars) {",
          "717:             if (prefetchedJars.contains(jar)) {",
          "718:                 return false;",
          "719:             }",
          "721:             String p = jar.getPath().replace('\\\\', '/');",
          "722:             p = Util.getBaseName(p);",
          "723:             File localJar = Util.makeResource(p, content);",
          "724:             addURL(localJar.toURI().toURL());",
          "725:             prefetchedJars.add(jar);",
          "726:             return true;",
          "727:         }",
          "728:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "846:     public interface IClassLoader {",
          "847:         byte[] fetchJar(URL url) throws IOException;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "876:         @Deprecated",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "971:         @Override",
          "972:         @SuppressFBWarnings(",
          "973:                 value = \"URLCONNECTION_SSRF_FD\",",
          "975:         public byte[] fetchJar(URL url) throws IOException {",
          "976:             return Util.readFully(url.openStream());",
          "977:         }",
          "",
          "[Removed Lines]",
          "974:                 justification = \"This is only used for managing the jar cache as files.\")",
          "",
          "[Added Lines]",
          "1004:                 justification = \"URL validation is being done through JarURLValidator\")",
          "1006:             final Object o = channel.getProperty(JarURLValidator.class);",
          "1007:             if (o == null) {",
          "1008:                 final boolean disabled = Boolean.getBoolean(Channel.class.getName() + \".DISABLE_JAR_URL_VALIDATOR\");",
          "1009:                 LOGGER.log(Level.FINE, \"Default behavior for URL: \" + url + \" with disabled flag: \" + disabled);",
          "1010:                 if (!disabled) {",
          "1011:                     throw new IOException(",
          "1012:                             \"No hudson.remoting.JarURLValidator has been set for this channel, so all #fetchJar calls are rejected.\"",
          "1013:                                     + \" This is likely a bug in Jenkins.\"",
          "1014:                                     + \" As a workaround, try updating the agent.jar file.\");",
          "1015:                 }",
          "1016:             } else {",
          "1017:                 if (o instanceof JarURLValidator) {",
          "1018:                     ((JarURLValidator) o).validate(url);",
          "1019:                 } else {",
          "1020:                     throw new IOException(\"Unexpected channel property hudson.remoting.JarURLValidator value: \" + o);",
          "1021:                 }",
          "1022:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
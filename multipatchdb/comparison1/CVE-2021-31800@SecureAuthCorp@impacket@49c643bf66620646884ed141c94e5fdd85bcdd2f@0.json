{
  "cve_id": "CVE-2021-31800",
  "cve_desc": "Multiple path traversal vulnerabilities exist in smbserver.py in Impacket through 0.9.22. An attacker that connects to a running smbserver instance can list and write to arbitrary files via ../ directory traversal. This could potentially be abused to achieve arbitrary code execution by replacing /etc/shadow or an SSH authorized key.",
  "repo": "SecureAuthCorp/impacket",
  "patch_hash": "49c643bf66620646884ed141c94e5fdd85bcdd2f",
  "patch_info": {
    "commit_hash": "49c643bf66620646884ed141c94e5fdd85bcdd2f",
    "repo": "SecureAuthCorp/impacket",
    "commit_url": "https://github.com/SecureAuthCorp/impacket/commit/49c643bf66620646884ed141c94e5fdd85bcdd2f",
    "files": [
      "impacket/smbserver.py"
    ],
    "message": "Merge pull request #1066 from omriinbar/master\n\nFix Path Traversal vulnerabilities by checking path prefix against in\u2026",
    "before_after_code_files": [
      "impacket/smbserver.py||impacket/smbserver.py"
    ]
  },
  "patch_diff": {
    "impacket/smbserver.py||impacket/smbserver.py": [
      "File: impacket/smbserver.py -> impacket/smbserver.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: # For signing",
      "47: from impacket import smb, nmb, ntlm, uuid",
      "48: from impacket import smb3structs as smb2",
      "50: from impacket.nt_errors import STATUS_NO_MORE_FILES, STATUS_NETWORK_NAME_DELETED, STATUS_INVALID_PARAMETER, \\",
      "51:     STATUS_FILE_CLOSED, STATUS_MORE_PROCESSING_REQUIRED, STATUS_OBJECT_PATH_NOT_FOUND, STATUS_DIRECTORY_NOT_EMPTY, \\",
      "52:     STATUS_FILE_IS_A_DIRECTORY, STATUS_NOT_IMPLEMENTED, STATUS_INVALID_HANDLE, STATUS_OBJECT_NAME_COLLISION, \\",
      "53:     STATUS_NO_SUCH_FILE, STATUS_CANCELLED, STATUS_OBJECT_NAME_NOT_FOUND, STATUS_SUCCESS, STATUS_ACCESS_DENIED, \\",
      "54:     STATUS_NOT_SUPPORTED, STATUS_INVALID_DEVICE_REQUEST, STATUS_FS_DRIVER_REQUIRED, STATUS_INVALID_INFO_CLASS, \\",
      "57: # Setting LOG to current's module name",
      "58: LOG = logging.getLogger(__name__)",
      "",
      "[Removed Lines]",
      "49: from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, ASN1_SUPPORTED_MECH",
      "55:     STATUS_LOGON_FAILURE",
      "",
      "[Added Lines]",
      "49: from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, \\",
      "50:     ASN1_SUPPORTED_MECH",
      "56:     STATUS_LOGON_FAILURE, STATUS_OBJECT_PATH_SYNTAX_BAD",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "61: STATUS_SMB_BAD_UID = 0x005B0002",
      "62: STATUS_SMB_BAD_TID = 0x00050002",
      "64: # Utility functions",
      "67: # command (or either TRANSACTION). That's why I'm putting them here",
      "68: # TODO: Return NT ERROR Codes",
      "70: def computeNTLMv2(identity, lmhash, nthash, serverChallenge, authenticateMessage, ntlmChallenge, type1):",
      "71:     # Let's calculate the NTLMv2 Response",
      "74:     responseKeyNT = ntlm.NTOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), nthash)",
      "75:     responseKeyLM = ntlm.LMOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), lmhash)",
      "",
      "[Removed Lines]",
      "65: # and general functions.",
      "66: # There are some common functions that can be accessed from more than one SMB",
      "",
      "[Added Lines]",
      "67: # and general functions.",
      "68: # There are some common functions that can be accessed from more than one SMB",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "103:         responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN",
      "105:     keyExchangeKey = ntlm.KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmChallengeResponse,",
      "109:     # If we set up key exchange, let's fill the right variables",
      "110:     if ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
      "",
      "[Removed Lines]",
      "106:                            ntlmChallenge['challenge'], '',",
      "107:                            lmhash, nthash, True)",
      "",
      "[Added Lines]",
      "107:                                 ntlmChallenge['challenge'], '',",
      "108:                                 lmhash, nthash, True)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "126: def outputToJohnFormat(challenge, username, domain, lmresponse, ntresponse):",
      "130:     ret_value = ''",
      "131:     if type(challenge) is not bytes:",
      "132:         challenge = challenge.decode('latin-1')",
      "",
      "[Removed Lines]",
      "127: # We don't want to add a possible failure here, since this is an",
      "128: # extra bonus. We try, if it fails, returns nothing",
      "129: # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called",
      "",
      "[Added Lines]",
      "128:     # We don't want to add a possible failure here, since this is an",
      "129:     # extra bonus. We try, if it fails, returns nothing",
      "130:     # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "137:             ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (",
      "138:                 username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(challenge).decode('latin-1'),",
      "139:                 hexlify(ntresponse).decode('latin-1')[:32],",
      "141:         else:",
      "142:             # NTLMv1",
      "143:             ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (",
      "144:                 username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(lmresponse).decode('latin-1'),",
      "145:                 hexlify(ntresponse).decode('latin-1'),",
      "147:     except:",
      "148:         # Let's try w/o decoding Unicode",
      "149:         try:",
      "",
      "[Removed Lines]",
      "140:             hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}",
      "146:             hexlify(challenge).decode()), 'hash_version': 'ntlm'}",
      "",
      "[Added Lines]",
      "141:                 hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}",
      "147:                 hexlify(challenge).decode()), 'hash_version': 'ntlm'}",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "173:     else:",
      "174:         output_filename = fn_data[0] + \"_ntlm\" + fn_data[1]",
      "182:     if flags & smb.SMB.FLAGS2_UNICODE:",
      "183:         return text.decode('utf-16le')",
      "184:     else:",
      "185:         return text",
      "188:     if flags & smb.SMB.FLAGS2_UNICODE:",
      "189:         return (text).encode('utf-16le')",
      "190:     else:",
      "191:         return text.encode('ascii')",
      "193: def getFileTime(t):",
      "194:     t *= 10000000",
      "195:     t += 116444736000000000",
      "196:     return t",
      "198: def getUnixTime(t):",
      "199:     t -= 116444736000000000",
      "200:     t //= 10000000",
      "201:     return t",
      "203: def getSMBDate(t):",
      "204:     # TODO: Fix this :P",
      "205:     d = datetime.date.fromtimestamp(t)",
      "",
      "[Removed Lines]",
      "176:     with open(output_filename,\"a\") as f:",
      "177:             f.write(hash_string)",
      "178:             f.write('\\n')",
      "181: def decodeSMBString( flags, text ):",
      "187: def encodeSMBString( flags, text ):",
      "",
      "[Added Lines]",
      "178:     with open(output_filename, \"a\") as f:",
      "179:         f.write(hash_string)",
      "180:         f.write('\\n')",
      "183: def decodeSMBString(flags, text):",
      "190: def encodeSMBString(flags, text):",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "207:     ret = (year << 8) + (d.month << 4) + d.day",
      "208:     return ret",
      "210: def getSMBTime(t):",
      "211:     # TODO: Fix this :P",
      "212:     d = datetime.datetime.fromtimestamp(t)",
      "215: def getShares(connId, smbServer):",
      "216:     config = smbServer.getServerConfig()",
      "217:     sections = config.sections()",
      "218:     # Remove the global one",
      "220:     shares = {}",
      "221:     for i in sections:",
      "222:         shares[i] = dict(config.items(i))",
      "223:     return shares",
      "225: def searchShare(connId, share, smbServer):",
      "226:     config = smbServer.getServerConfig()",
      "227:     if config.has_section(share):",
      "229:     else:",
      "234:     errorCode = 0",
      "235:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "239:     mode = 0",
      "240:     # Check the Open Mode",
      "241:     if openMode & 0x10:",
      "",
      "[Removed Lines]",
      "213:     return (d.hour << 8) + (d.minute << 4) + d.second",
      "219:     del(sections[sections.index('global')])",
      "228:        return dict(config.items(share))",
      "230:        return None",
      "232: def openFile(path,fileName, accessMode, fileAttributes, openMode):",
      "233:     fileName = os.path.normpath(fileName.replace('\\\\','/'))",
      "236:        # strip leading '/'",
      "237:        fileName = fileName[1:]",
      "238:     pathName = os.path.join(path,fileName)",
      "",
      "[Added Lines]",
      "220:     return (d.hour << 8) + (d.minute << 4) + d.second",
      "227:     del (sections[sections.index('global')])",
      "237:         return dict(config.items(share))",
      "239:         return None",
      "242: def openFile(path, fileName, accessMode, fileAttributes, openMode):",
      "243:     fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
      "246:         # strip leading '/'",
      "247:         fileName = fileName[1:]",
      "248:     pathName = os.path.join(path, fileName)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "245:         # If file does not exist, return an error",
      "246:         if os.path.exists(pathName) is not True:",
      "247:             errorCode = STATUS_NO_SUCH_FILE",
      "250:     if os.path.isdir(pathName) and (fileAttributes & smb.ATTR_DIRECTORY) == 0:",
      "251:         # Request to open a normal file and this is actually a directory",
      "254:     # Check the Access Mode",
      "255:     if accessMode & 0x7 == 1:",
      "257:     elif accessMode & 0x7 == 2:",
      "259:     else:",
      "262:     try:",
      "263:         if sys.platform == 'win32':",
      "264:             mode |= os.O_BINARY",
      "265:         fid = os.open(pathName, mode)",
      "266:     except Exception as e:",
      "268:         fid = 0",
      "269:         errorCode = STATUS_ACCESS_DENIED",
      "271:     return fid, mode, pathName, errorCode",
      "275:     if pktFlags & smb.SMB.FLAGS2_UNICODE:",
      "277:     else:",
      "281:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "285:     fileSize = os.path.getsize(pathName)",
      "286:     (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
      "287:     if level == smb.SMB_QUERY_FS_ATTRIBUTE_INFO or level == smb2.SMB2_FILESYSTEM_ATTRIBUTE_INFO:",
      "288:         data = smb.SMBQueryFsAttributeInfo()",
      "290:         data['MaxFilenNameLengthInBytes'] = 255",
      "293:         return data.getData()",
      "294:     elif level == smb.SMB_INFO_VOLUME:",
      "297:         return data.getData()",
      "298:     elif level == smb.SMB_QUERY_FS_VOLUME_INFO or level == smb2.SMB2_FILESYSTEM_VOLUME_INFO:",
      "299:         data = smb.SMBQueryFsVolumeInfo()",
      "303:     elif level == smb.SMB_QUERY_FS_SIZE_INFO:",
      "304:         data = smb.SMBQueryFsSizeInfo()",
      "305:         return data.getData()",
      "",
      "[Removed Lines]",
      "248:             return 0,mode, pathName, errorCode",
      "252:             errorCode = STATUS_FILE_IS_A_DIRECTORY",
      "253:             return 0, mode, pathName, errorCode",
      "256:        mode |= os.O_WRONLY",
      "258:        mode |= os.O_RDWR",
      "260:        mode = os.O_RDONLY",
      "267:         LOG.error(\"openFile: %s,%s\" % (pathName, mode) ,e)",
      "273: def queryFsInformation(path, filename, level=0, pktFlags = smb.SMB.FLAGS2_UNICODE):",
      "276:          encoding = 'utf-16le'",
      "278:          encoding = 'ascii'",
      "280:     fileName = os.path.normpath(filename.replace('\\\\','/'))",
      "282:        # strip leading '/'",
      "283:        fileName = fileName[1:]",
      "284:     pathName = os.path.join(path,fileName)",
      "289:         data['FileSystemAttributes']      = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES",
      "291:         data['LengthOfFileSystemName']    = len('XTFS')*2",
      "292:         data['FileSystemName']            = 'XTFS'.encode('utf-16le')",
      "295:         data = smb.SMBQueryFsInfoVolume( flags = pktFlags )",
      "296:         data['VolumeLabel']               = 'SHARE'.encode(encoding)",
      "300:         data['VolumeLabel']               = ''",
      "301:         data['VolumeCreationTime']        = getFileTime(ctime)",
      "302:         return data.getData()",
      "",
      "[Added Lines]",
      "258:             return 0, mode, pathName, errorCode",
      "262:         errorCode = STATUS_FILE_IS_A_DIRECTORY",
      "263:         return 0, mode, pathName, errorCode",
      "266:         mode |= os.O_WRONLY",
      "268:         mode |= os.O_RDWR",
      "270:         mode = os.O_RDONLY",
      "277:         LOG.error(\"openFile: %s,%s\" % (pathName, mode), e)",
      "284: def queryFsInformation(path, filename, level=0, pktFlags=smb.SMB.FLAGS2_UNICODE):",
      "286:         encoding = 'utf-16le'",
      "288:         encoding = 'ascii'",
      "290:     fileName = os.path.normpath(filename.replace('\\\\', '/'))",
      "292:         # strip leading '/'",
      "293:         fileName = fileName[1:]",
      "294:     pathName = os.path.join(path, fileName)",
      "299:         data['FileSystemAttributes'] = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES",
      "301:         data['LengthOfFileSystemName'] = len('XTFS') * 2",
      "302:         data['FileSystemName'] = 'XTFS'.encode('utf-16le')",
      "305:         data = smb.SMBQueryFsInfoVolume(flags=pktFlags)",
      "306:         data['VolumeLabel'] = 'SHARE'.encode(encoding)",
      "310:         data['VolumeLabel'] = ''",
      "311:         data['VolumeCreationTime'] = getFileTime(ctime)",
      "312:         return data.getData()",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "319:         fileAttributes = attribs",
      "320:         return fileSize, lastWriteTime, fileAttributes",
      "334:         # strip leading '/'",
      "335:         fileName = fileName[1:]",
      "356:                 entry = os.path.join(dirName, file)",
      "357:                 if os.path.isdir(entry):",
      "358:                     if searchAttributes & smb.ATTR_DIRECTORY:",
      "359:                         files.append(entry)",
      "360:                 else:",
      "361:                     files.append(entry)",
      "371:         if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:",
      "373:         elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:",
      "375:         elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:",
      "377:         elif level == smb.SMB_FIND_INFO_STANDARD:",
      "379:         elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:",
      "381:         elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:",
      "383:         elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:",
      "385:         else:",
      "386:             LOG.error(\"Wrong level %d!\" % level)",
      "389:         (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)",
      "390:         if os.path.isdir(i):",
      "392:         else:",
      "395:         item['FileName'] = os.path.basename(i).encode(encoding)",
      "397:         if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:",
      "409:         elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO:",
      "419:         elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:",
      "429:         elif level == smb.SMB_FIND_INFO_STANDARD:",
      "437:         searchResult.append(item)",
      "445: def queryFileInformation(path, filename, level):",
      "449: def queryPathInformation(path, filename, level):",
      "450:     # TODO: Depending on the level, this could be done much simpler",
      "506:             else:",
      "512:         else:",
      "525: def queryDiskInformation(path):",
      "532: # Here we implement the NT transaction handlers",
      "533: class NTTRANSCommands:",
      "535:         pass",
      "537: # Here we implement the NT transaction handlers",
      "538: class TRANSCommands:",
      "539:     @staticmethod",
      "541:         # Minimal [MS-RAP] implementation, just to return the shares",
      "542:         connData = smbServer.getConnectionData(connId)",
      "",
      "[Removed Lines]",
      "322: def findFirst2(path, fileName, level, searchAttributes, pktFlags = smb.SMB.FLAGS2_UNICODE, isSMB2 = False):",
      "323:      # TODO: Depending on the level, this could be done much simpler",
      "325:      #print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)",
      "326:      fileName = os.path.normpath(fileName.replace('\\\\','/'))",
      "327:      # Let's choose the right encoding depending on the request",
      "328:      if pktFlags & smb.SMB.FLAGS2_UNICODE:",
      "329:          encoding = 'utf-16le'",
      "330:      else:",
      "331:          encoding = 'ascii'",
      "333:      if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "337:      pathName = os.path.join(path,fileName)",
      "338:      files = []",
      "340:      if pathName.find('*') == -1 and pathName.find('?') == -1:",
      "341:          # No search patterns",
      "342:          pattern = ''",
      "343:      else:",
      "344:          pattern = os.path.basename(pathName)",
      "345:          dirName = os.path.dirname(pathName)",
      "347:      # Always add . and .. Not that important for Windows, but Samba whines if",
      "348:      # not present (for * search only)",
      "349:      if pattern == '*':",
      "350:          files.append(os.path.join(dirName,'.'))",
      "351:          files.append(os.path.join(dirName,'..'))",
      "353:      if pattern != '':",
      "354:          for file in os.listdir(dirName):",
      "355:              if fnmatch.fnmatch(file.lower(),pattern.lower()):",
      "362:      else:",
      "363:          if os.path.exists(pathName):",
      "364:              files.append(pathName)",
      "366:      searchResult = []",
      "367:      searchCount = len(files)",
      "368:      errorCode = STATUS_SUCCESS",
      "370:      for i in files:",
      "372:             item = smb.SMBFindFileBothDirectoryInfo( flags = pktFlags )",
      "374:             item = smb.SMBFindFileDirectoryInfo( flags = pktFlags )",
      "376:             item = smb.SMBFindFileFullDirectoryInfo( flags = pktFlags )",
      "378:             item = smb.SMBFindInfoStandard( flags = pktFlags )",
      "380:             item = smb.SMBFindFileIdFullDirectoryInfo( flags = pktFlags )",
      "382:             item = smb.SMBFindFileIdBothDirectoryInfo( flags = pktFlags )",
      "384:             item = smb.SMBFindFileNamesInfo( flags = pktFlags )",
      "387:             return  searchResult, searchCount, STATUS_NOT_SUPPORTED",
      "391:            item['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "393:            item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "398:            item['EaSize']            = 0",
      "399:            item['EndOfFile']         = size",
      "400:            item['AllocationSize']    = size",
      "401:            item['CreationTime']      = getFileTime(ctime)",
      "402:            item['LastAccessTime']    = getFileTime(atime)",
      "403:            item['LastWriteTime']     = getFileTime(mtime)",
      "404:            item['LastChangeTime']    = getFileTime(mtime)",
      "405:            item['ShortName']         = '\\x00'*24",
      "406:            item['FileName']          = os.path.basename(i).encode(encoding)",
      "407:            padLen = (8-(len(item) % 8)) % 8",
      "408:            item['NextEntryOffset']   = len(item) + padLen",
      "410:            item['EndOfFile']         = size",
      "411:            item['AllocationSize']    = size",
      "412:            item['CreationTime']      = getFileTime(ctime)",
      "413:            item['LastAccessTime']    = getFileTime(atime)",
      "414:            item['LastWriteTime']     = getFileTime(mtime)",
      "415:            item['LastChangeTime']    = getFileTime(mtime)",
      "416:            item['FileName']          = os.path.basename(i).encode(encoding)",
      "417:            padLen = (8-(len(item) % 8)) % 8",
      "418:            item['NextEntryOffset']   = len(item) + padLen",
      "420:            item['EaSize']            = 0",
      "421:            item['EndOfFile']         = size",
      "422:            item['AllocationSize']    = size",
      "423:            item['CreationTime']      = getFileTime(ctime)",
      "424:            item['LastAccessTime']    = getFileTime(atime)",
      "425:            item['LastWriteTime']     = getFileTime(mtime)",
      "426:            item['LastChangeTime']    = getFileTime(mtime)",
      "427:            padLen = (8-(len(item) % 8)) % 8",
      "428:            item['NextEntryOffset']   = len(item) + padLen",
      "430:            item['EaSize']            = size",
      "431:            item['CreationDate']      = getSMBDate(ctime)",
      "432:            item['CreationTime']      = getSMBTime(ctime)",
      "433:            item['LastAccessDate']    = getSMBDate(atime)",
      "434:            item['LastAccessTime']    = getSMBTime(atime)",
      "435:            item['LastWriteDate']     = getSMBDate(mtime)",
      "436:            item['LastWriteTime']     = getSMBTime(mtime)",
      "439:      # No more files",
      "440:      if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:",
      "441:          searchResult[-1]['NextEntryOffset'] = 0",
      "443:      return searchResult, searchCount, errorCode",
      "446:     #print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)",
      "447:     return queryPathInformation(path,filename, level)",
      "451:   #print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))",
      "452:   try:",
      "453:     errorCode = 0",
      "454:     fileName = os.path.normpath(filename.replace('\\\\','/'))",
      "455:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
      "456:        # strip leading '/'",
      "457:        fileName = fileName[1:]",
      "458:     pathName = os.path.join(path,fileName)",
      "459:     if os.path.exists(pathName):",
      "460:         (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
      "461:         if level == smb.SMB_QUERY_FILE_BASIC_INFO:",
      "462:             infoRecord = smb.SMBQueryFileBasicInfo()",
      "463:             infoRecord['CreationTime']         = getFileTime(ctime)",
      "464:             infoRecord['LastAccessTime']       = getFileTime(atime)",
      "465:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
      "466:             infoRecord['LastChangeTime']       = getFileTime(mtime)",
      "467:             if os.path.isdir(pathName):",
      "468:                infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "469:             else:",
      "470:                infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "471:         elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:",
      "472:             infoRecord = smb.SMBQueryFileStandardInfo()",
      "473:             infoRecord['AllocationSize']       = size",
      "474:             infoRecord['EndOfFile']            = size",
      "475:             if os.path.isdir(pathName):",
      "476:                infoRecord['Directory']         = 1",
      "477:             else:",
      "478:                infoRecord['Directory']         = 0",
      "479:         elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:",
      "480:             infoRecord = smb.SMBQueryFileAllInfo()",
      "481:             infoRecord['CreationTime']         = getFileTime(ctime)",
      "482:             infoRecord['LastAccessTime']       = getFileTime(atime)",
      "483:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
      "484:             infoRecord['LastChangeTime']       = getFileTime(mtime)",
      "485:             if os.path.isdir(pathName):",
      "486:                infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "487:             else:",
      "488:                infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "489:             infoRecord['AllocationSize']       = size",
      "490:             infoRecord['EndOfFile']            = size",
      "491:             if os.path.isdir(pathName):",
      "492:                infoRecord['Directory']         = 1",
      "493:             else:",
      "494:                infoRecord['Directory']         = 0",
      "495:             infoRecord['FileName']             = filename.encode('utf-16le')",
      "496:         elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:",
      "497:             infoRecord = smb.SMBFileNetworkOpenInfo()",
      "498:             infoRecord['CreationTime']         = getFileTime(ctime)",
      "499:             infoRecord['LastAccessTime']       = getFileTime(atime)",
      "500:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
      "501:             infoRecord['ChangeTime']           = getFileTime(mtime)",
      "502:             infoRecord['AllocationSize']       = size",
      "503:             infoRecord['EndOfFile']            = size",
      "504:             if os.path.isdir(pathName):",
      "505:                infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY",
      "507:                infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "508:         elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:",
      "509:             infoRecord = smb.SMBQueryFileEaInfo()",
      "510:         elif level == smb2.SMB2_FILE_STREAM_INFO:",
      "511:             infoRecord = smb.SMBFileStreamInformation()",
      "513:             LOG.error('Unknown level for query path info! 0x%x' % level)",
      "514:             # UNSUPPORTED",
      "515:             return None, STATUS_NOT_SUPPORTED",
      "517:         return infoRecord, errorCode",
      "518:     else:",
      "519:         # NOT FOUND",
      "520:         return None, STATUS_OBJECT_NAME_NOT_FOUND",
      "521:   except Exception as e:",
      "522:       LOG.error('queryPathInfo: %s' % e)",
      "523:       raise",
      "526: # TODO: Do something useful here :)",
      "527: # For now we just return fake values",
      "528:    totalUnits = 65535",
      "529:    freeUnits = 65535",
      "530:    return totalUnits, freeUnits",
      "534:     def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "540:     def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "",
      "[Added Lines]",
      "333: def findFirst2(path, fileName, level, searchAttributes, pktFlags=smb.SMB.FLAGS2_UNICODE, isSMB2=False):",
      "334:     # TODO: Depending on the level, this could be done much simpler",
      "336:     # print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)",
      "337:     fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
      "338:     # Let's choose the right encoding depending on the request",
      "339:     if pktFlags & smb.SMB.FLAGS2_UNICODE:",
      "340:         encoding = 'utf-16le'",
      "341:     else:",
      "342:         encoding = 'ascii'",
      "344:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "348:     if not isInFileJail(path, fileName):",
      "349:         LOG.error(\"Path not in current working directory\")",
      "350:         return [], 0, STATUS_OBJECT_PATH_SYNTAX_BAD",
      "352:     pathName = os.path.join(path, fileName)",
      "353:     files = []",
      "355:     if pathName.find('*') == -1 and pathName.find('?') == -1:",
      "356:         # No search patterns",
      "357:         pattern = ''",
      "358:     else:",
      "359:         pattern = os.path.basename(pathName)",
      "360:         dirName = os.path.dirname(pathName)",
      "362:     # Always add . and .. Not that important for Windows, but Samba whines if",
      "363:     # not present (for * search only)",
      "364:     if pattern == '*':",
      "365:         files.append(os.path.join(dirName, '.'))",
      "366:         files.append(os.path.join(dirName, '..'))",
      "368:     if pattern != '':",
      "369:         for file in os.listdir(dirName):",
      "370:             if fnmatch.fnmatch(file.lower(), pattern.lower()):",
      "377:     else:",
      "378:         if os.path.exists(pathName):",
      "379:             files.append(pathName)",
      "381:     searchResult = []",
      "382:     searchCount = len(files)",
      "383:     errorCode = STATUS_SUCCESS",
      "385:     for i in files:",
      "387:             item = smb.SMBFindFileBothDirectoryInfo(flags=pktFlags)",
      "389:             item = smb.SMBFindFileDirectoryInfo(flags=pktFlags)",
      "391:             item = smb.SMBFindFileFullDirectoryInfo(flags=pktFlags)",
      "393:             item = smb.SMBFindInfoStandard(flags=pktFlags)",
      "395:             item = smb.SMBFindFileIdFullDirectoryInfo(flags=pktFlags)",
      "397:             item = smb.SMBFindFileIdBothDirectoryInfo(flags=pktFlags)",
      "399:             item = smb.SMBFindFileNamesInfo(flags=pktFlags)",
      "402:             return searchResult, searchCount, STATUS_NOT_SUPPORTED",
      "406:             item['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "408:             item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "413:             item['EaSize'] = 0",
      "414:             item['EndOfFile'] = size",
      "415:             item['AllocationSize'] = size",
      "416:             item['CreationTime'] = getFileTime(ctime)",
      "417:             item['LastAccessTime'] = getFileTime(atime)",
      "418:             item['LastWriteTime'] = getFileTime(mtime)",
      "419:             item['LastChangeTime'] = getFileTime(mtime)",
      "420:             item['ShortName'] = '\\x00' * 24",
      "421:             item['FileName'] = os.path.basename(i).encode(encoding)",
      "422:             padLen = (8 - (len(item) % 8)) % 8",
      "423:             item['NextEntryOffset'] = len(item) + padLen",
      "425:             item['EndOfFile'] = size",
      "426:             item['AllocationSize'] = size",
      "427:             item['CreationTime'] = getFileTime(ctime)",
      "428:             item['LastAccessTime'] = getFileTime(atime)",
      "429:             item['LastWriteTime'] = getFileTime(mtime)",
      "430:             item['LastChangeTime'] = getFileTime(mtime)",
      "431:             item['FileName'] = os.path.basename(i).encode(encoding)",
      "432:             padLen = (8 - (len(item) % 8)) % 8",
      "433:             item['NextEntryOffset'] = len(item) + padLen",
      "435:             item['EaSize'] = 0",
      "436:             item['EndOfFile'] = size",
      "437:             item['AllocationSize'] = size",
      "438:             item['CreationTime'] = getFileTime(ctime)",
      "439:             item['LastAccessTime'] = getFileTime(atime)",
      "440:             item['LastWriteTime'] = getFileTime(mtime)",
      "441:             item['LastChangeTime'] = getFileTime(mtime)",
      "442:             padLen = (8 - (len(item) % 8)) % 8",
      "443:             item['NextEntryOffset'] = len(item) + padLen",
      "445:             item['EaSize'] = size",
      "446:             item['CreationDate'] = getSMBDate(ctime)",
      "447:             item['CreationTime'] = getSMBTime(ctime)",
      "448:             item['LastAccessDate'] = getSMBDate(atime)",
      "449:             item['LastAccessTime'] = getSMBTime(atime)",
      "450:             item['LastWriteDate'] = getSMBDate(mtime)",
      "451:             item['LastWriteTime'] = getSMBTime(mtime)",
      "454:     # No more files",
      "455:     if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:",
      "456:         searchResult[-1]['NextEntryOffset'] = 0",
      "458:     return searchResult, searchCount, errorCode",
      "462:     # print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)",
      "463:     return queryPathInformation(path, filename, level)",
      "468:     # print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))",
      "469:     try:",
      "470:         errorCode = 0",
      "471:         fileName = os.path.normpath(filename.replace('\\\\', '/'))",
      "472:         if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
      "473:             # strip leading '/'",
      "474:             fileName = fileName[1:]",
      "475:         pathName = os.path.join(path, fileName)",
      "476:         if os.path.exists(pathName):",
      "477:             (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
      "478:             if level == smb.SMB_QUERY_FILE_BASIC_INFO:",
      "479:                 infoRecord = smb.SMBQueryFileBasicInfo()",
      "480:                 infoRecord['CreationTime'] = getFileTime(ctime)",
      "481:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
      "482:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
      "483:                 infoRecord['LastChangeTime'] = getFileTime(mtime)",
      "484:                 if os.path.isdir(pathName):",
      "485:                     infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "486:                 else:",
      "487:                     infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "488:             elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:",
      "489:                 infoRecord = smb.SMBQueryFileStandardInfo()",
      "490:                 infoRecord['AllocationSize'] = size",
      "491:                 infoRecord['EndOfFile'] = size",
      "492:                 if os.path.isdir(pathName):",
      "493:                     infoRecord['Directory'] = 1",
      "494:                 else:",
      "495:                     infoRecord['Directory'] = 0",
      "496:             elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:",
      "497:                 infoRecord = smb.SMBQueryFileAllInfo()",
      "498:                 infoRecord['CreationTime'] = getFileTime(ctime)",
      "499:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
      "500:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
      "501:                 infoRecord['LastChangeTime'] = getFileTime(mtime)",
      "502:                 if os.path.isdir(pathName):",
      "503:                     infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
      "504:                 else:",
      "505:                     infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "506:                 infoRecord['AllocationSize'] = size",
      "507:                 infoRecord['EndOfFile'] = size",
      "508:                 if os.path.isdir(pathName):",
      "509:                     infoRecord['Directory'] = 1",
      "510:                 else:",
      "511:                     infoRecord['Directory'] = 0",
      "512:                 infoRecord['FileName'] = filename.encode('utf-16le')",
      "513:             elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:",
      "514:                 infoRecord = smb.SMBFileNetworkOpenInfo()",
      "515:                 infoRecord['CreationTime'] = getFileTime(ctime)",
      "516:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
      "517:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
      "518:                 infoRecord['ChangeTime'] = getFileTime(mtime)",
      "519:                 infoRecord['AllocationSize'] = size",
      "520:                 infoRecord['EndOfFile'] = size",
      "521:                 if os.path.isdir(pathName):",
      "522:                     infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY",
      "523:                 else:",
      "524:                     infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
      "525:             elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:",
      "526:                 infoRecord = smb.SMBQueryFileEaInfo()",
      "527:             elif level == smb2.SMB2_FILE_STREAM_INFO:",
      "528:                 infoRecord = smb.SMBFileStreamInformation()",
      "530:                 LOG.error('Unknown level for query path info! 0x%x' % level)",
      "531:                 # UNSUPPORTED",
      "532:                 return None, STATUS_NOT_SUPPORTED",
      "534:             return infoRecord, errorCode",
      "536:             # NOT FOUND",
      "537:             return None, STATUS_OBJECT_NAME_NOT_FOUND",
      "538:     except Exception as e:",
      "539:         LOG.error('queryPathInfo: %s' % e)",
      "540:         raise",
      "544:     # TODO: Do something useful here :)",
      "545:     # For now we just return fake values",
      "546:     totalUnits = 65535",
      "547:     freeUnits = 65535",
      "548:     return totalUnits, freeUnits",
      "551: def isInFileJail(path, fileName):",
      "552:     pathName = os.path.join(path, fileName)",
      "553:     share_real_path = os.path.realpath(path)",
      "554:     return os.path.commonprefix((os.path.realpath(pathName), share_real_path)) == share_real_path",
      "559:     def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "566:     def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "545:         respParameters = b''",
      "546:         respData = b''",
      "547:         errorCode = STATUS_SUCCESS",
      "549:             # NetShareEnum Request",
      "550:             netShareEnum = smb.SMBNetShareEnum(parameters)",
      "551:             if netShareEnum['InfoLevel'] == 1:",
      "552:                 shares = getShares(connId, smbServer)",
      "553:                 respParameters = smb.SMBNetShareEnumResponse()",
      "555:                 respParameters['EntriesAvailable'] = len(shares)",
      "556:                 tailData = ''",
      "557:                 for i in shares:",
      "558:                     # NetShareInfo1 len == 20",
      "559:                     entry = smb.NetShareInfo1()",
      "562:                     # (beto) If offset == 0 it crashes explorer.exe on windows 7",
      "563:                     entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)",
      "564:                     respData += entry.getData()",
      "",
      "[Removed Lines]",
      "548:         if struct.unpack('<H',parameters[:2])[0] == 0:",
      "554:                 respParameters['EntriesReturned']  = len(shares)",
      "560:                     entry['NetworkName'] = i + '\\x00'*(13-len(i))",
      "561:                     entry['Type']        = int(shares[i]['share type'])",
      "",
      "[Added Lines]",
      "574:         if struct.unpack('<H', parameters[:2])[0] == 0:",
      "580:                 respParameters['EntriesReturned'] = len(shares)",
      "586:                     entry['NetworkName'] = i + '\\x00' * (13 - len(i))",
      "587:                     entry['Type'] = int(shares[i]['share type'])",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "570:             else:",
      "571:                 # We don't support other info levels",
      "572:                 errorCode = STATUS_NOT_SUPPORTED",
      "574:             # NetrServerGetInfo Request",
      "575:             respParameters = smb.SMBNetServerGetInfoResponse()",
      "576:             netServerInfo = smb.SMBNetServerInfo1()",
      "577:             netServerInfo['ServerName'] = smbServer.getServerName()",
      "578:             respData = netServerInfo.getData()",
      "579:             respParameters['TotalBytesAvailable'] = len(respData)",
      "581:             # NetrShareGetInfo Request",
      "582:             request = smb.SMBNetShareGetInfo(parameters)",
      "583:             respParameters = smb.SMBNetShareGetInfoResponse()",
      "584:             shares = getShares(connId, smbServer)",
      "585:             share = shares[request['ShareName'].upper()]",
      "587:             shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'",
      "589:             respData = shareInfo.getData()",
      "590:             if 'comment' in share:",
      "591:                 shareInfo['RemarkOffsetLow'] = len(respData)",
      "592:                 respData += share['comment'] + '\\x00'",
      "593:             respParameters['TotalBytesAvailable'] = len(respData)",
      "595:         else:",
      "596:             # We don't know how to handle anything else",
      "597:             errorCode = STATUS_NOT_SUPPORTED",
      "",
      "[Removed Lines]",
      "573:         elif struct.unpack('<H',parameters[:2])[0] == 13:",
      "580:         elif struct.unpack('<H',parameters[:2])[0] == 1:",
      "586:             shareInfo = smb.NetShareInfo1()",
      "588:             shareInfo['Type']        = int(share['share type'])",
      "",
      "[Added Lines]",
      "599:         elif struct.unpack('<H', parameters[:2])[0] == 13:",
      "606:         elif struct.unpack('<H', parameters[:2])[0] == 1:",
      "612:             shareInfo = smb.NetShareInfo1()",
      "614:             shareInfo['Type'] = int(share['share type'])",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "601:         return respSetup, respParameters, respData, errorCode",
      "603:     @staticmethod",
      "605:         connData = smbServer.getConnectionData(connId)",
      "607:         respSetup = b''",
      "608:         respParameters = b''",
      "609:         respData = b''",
      "610:         errorCode = STATUS_SUCCESS",
      "614:         # Extract the FID",
      "615:         fid = struct.unpack('<H', transParameters['Setup'][2:])[0]",
      "",
      "[Removed Lines]",
      "604:     def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "611:         SMBCommand  = smb.SMBCommand(recvPacket['Data'][0])",
      "612:         transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
      "",
      "[Added Lines]",
      "630:     def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "637:         SMBCommand = smb.SMBCommand(recvPacket['Data'][0])",
      "638:         transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "617:         if fid in connData['OpenedFiles']:",
      "618:             fileHandle = connData['OpenedFiles'][fid]['FileHandle']",
      "619:             if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "622:             else:",
      "623:                 sock = connData['OpenedFiles'][fid]['Socket']",
      "624:                 sock.send(data)",
      "",
      "[Removed Lines]",
      "620:                 os.write(fileHandle,data)",
      "621:                 respData = os.read(fileHandle,data)",
      "",
      "[Added Lines]",
      "646:                 os.write(fileHandle, data)",
      "647:                 respData = os.read(fileHandle, data)",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "631:         return respSetup, respParameters, respData, errorCode",
      "633: # Here we implement the transaction2 handlers",
      "634: class TRANS2Commands:",
      "635:     # All these commands return setup, parameters, data, errorCode",
      "636:     @staticmethod",
      "638:         connData = smbServer.getConnectionData(connId)",
      "640:         respSetup = b''",
      "641:         respParameters = b''",
      "642:         respData = b''",
      "643:         errorCode = STATUS_SUCCESS",
      "645:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "647:             fileName = decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName'])",
      "649:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
      "653:             if os.path.exists(pathName):",
      "654:                 informationLevel = setPathInfoParameters['InformationLevel']",
      "655:                 if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:",
      "",
      "[Removed Lines]",
      "637:     def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "644:         setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)",
      "646:             path     = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "648:             fileName = os.path.normpath(fileName.replace('\\\\','/'))",
      "650:                # strip leading '/'",
      "651:                fileName = fileName[1:]",
      "652:             pathName = os.path.join(path,fileName)",
      "",
      "[Added Lines]",
      "664:     def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "671:         setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)",
      "673:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "675:             fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
      "677:                 # strip leading '/'",
      "678:                 fileName = fileName[1:]",
      "679:             pathName = os.path.join(path, fileName)",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "666:                     else:",
      "667:                         mtime = getUnixTime(mtime)",
      "668:                     if mtime != -1 or atime != -1:",
      "670:                 else:",
      "672:                     # UNSUPPORTED",
      "674:             else:",
      "675:                 errorCode = STATUS_OBJECT_NAME_NOT_FOUND",
      "",
      "[Removed Lines]",
      "669:                         os.utime(pathName,(atime,mtime))",
      "671:                     smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'], logging.ERROR)",
      "673:                     errorCode =  STATUS_NOT_SUPPORTED",
      "",
      "[Added Lines]",
      "696:                         os.utime(pathName, (atime, mtime))",
      "698:                     smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'],",
      "699:                                   logging.ERROR)",
      "701:                     errorCode = STATUS_NOT_SUPPORTED",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "685:         return respSetup, respParameters, respData, errorCode",
      "688:     @staticmethod",
      "690:         connData = smbServer.getConnectionData(connId)",
      "692:         respSetup = b''",
      "",
      "[Removed Lines]",
      "689:     def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "",
      "[Added Lines]",
      "716:     def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "702:                 if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:",
      "703:                     infoRecord = smb.SMBSetFileDispositionInfo(parameters)",
      "704:                     if infoRecord['DeletePending'] > 0:",
      "708:                 elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:",
      "709:                     infoRecord = smb.SMBSetFileBasicInfo(data)",
      "710:                     # Creation time won't be set,  the other ones we play with.",
      "",
      "[Removed Lines]",
      "705:                        # Mark this file for removal after closed",
      "706:                        connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True",
      "707:                        respParameters = smb.SMBSetFileInformationResponse_Parameters()",
      "",
      "[Added Lines]",
      "732:                         # Mark this file for removal after closed",
      "733:                         connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True",
      "734:                         respParameters = smb.SMBSetFileInformationResponse_Parameters()",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "718:                         mtime = -1",
      "719:                     else:",
      "720:                         mtime = getUnixTime(mtime)",
      "722:                 elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:",
      "723:                     fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']",
      "724:                     infoRecord = smb.SMBSetFileEndOfFileInfo(data)",
      "725:                     if infoRecord['EndOfFile'] > 0:",
      "727:                         os.write(fileHandle, b'\\x00')",
      "728:                 else:",
      "730:                     # UNSUPPORTED",
      "732:             else:",
      "733:                 errorCode = STATUS_NO_SUCH_FILE",
      "",
      "[Removed Lines]",
      "721:                     os.utime(fileName,(atime,mtime))",
      "726:                         os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)",
      "729:                     smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'], logging.ERROR)",
      "731:                     errorCode =  STATUS_NOT_SUPPORTED",
      "",
      "[Added Lines]",
      "748:                     os.utime(fileName, (atime, mtime))",
      "753:                         os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)",
      "756:                     smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'],",
      "757:                                   logging.ERROR)",
      "759:                     errorCode = STATUS_NOT_SUPPORTED",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "742:         return respSetup, respParameters, respData, errorCode",
      "744:     @staticmethod",
      "746:         connData = smbServer.getConnectionData(connId)",
      "748:         respSetup = b''",
      "",
      "[Removed Lines]",
      "745:     def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "",
      "[Added Lines]",
      "773:     def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "770:         return respSetup, respParameters, respData, errorCode",
      "772:     @staticmethod",
      "774:         connData = smbServer.getConnectionData(connId)",
      "776:         respSetup = b''",
      "",
      "[Removed Lines]",
      "773:     def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "",
      "[Added Lines]",
      "801:     def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "778:         respData = b''",
      "779:         errorCode = 0",
      "783:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "784:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "",
      "[Removed Lines]",
      "781:         queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)",
      "",
      "[Added Lines]",
      "809:         queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "787:                                                                                    queryPathInfoParameters['FileName']),",
      "788:                                                              queryPathInfoParameters['InformationLevel'])",
      "789:             except Exception as e:",
      "792:             if infoRecord is not None:",
      "793:                 respParameters = smb.SMBQueryPathInformationResponse_Parameters()",
      "794:                 respData = infoRecord",
      "795:         else:",
      "796:             errorCode = STATUS_SMB_BAD_TID",
      "798:         smbServer.setConnectionData(connId, connData)",
      "800:         return respSetup, respParameters, respData, errorCode",
      "802:     @staticmethod",
      "804:         connData = smbServer.getConnectionData(connId)",
      "805:         errorCode = 0",
      "806:         # Get the Tid associated",
      "807:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "808:             data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',",
      "811:         smbServer.setConnectionData(connId, connData)",
      "815:     @staticmethod",
      "816:     def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):",
      "",
      "[Removed Lines]",
      "790:                smbServer.log(\"queryPathInformation: %s\" % e,logging.ERROR)",
      "803:     def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
      "809:                                       struct.unpack('<H',parameters)[0], pktFlags = recvPacket['Flags2'])",
      "813:         return b'',b'', data, errorCode",
      "",
      "[Added Lines]",
      "818:                 smbServer.log(\"queryPathInformation: %s\" % e, logging.ERROR)",
      "831:     def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
      "837:                                       struct.unpack('<H', parameters)[0], pktFlags=recvPacket['Flags2'])",
      "841:         return b'', b'', data, errorCode",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "820:         respParameters = b''",
      "821:         respData = b''",
      "822:         errorCode = STATUS_SUCCESS",
      "825:         sid = findNext2Parameters['SID']",
      "826:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "",
      "[Removed Lines]",
      "823:         findNext2Parameters = smb.SMBFindNext2_Parameters(flags = recvPacket['Flags2'], data = parameters)",
      "",
      "[Added Lines]",
      "851:         findNext2Parameters = smb.SMBFindNext2_Parameters(flags=recvPacket['Flags2'], data=parameters)",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "833:                 for i in enumerate(searchResult):",
      "834:                     data = i[1].getData()",
      "835:                     lenData = len(data)",
      "837:                         # We gotta stop here and continue on a find_next2",
      "838:                         endOfSearch = 0",
      "839:                         connData['SIDs'][sid] = searchResult[i[0]:]",
      "840:                         respParameters['LastNameOffset'] = totalData",
      "841:                         break",
      "842:                     else:",
      "844:                         respData += data",
      "845:                         totalData += lenData",
      "847:                 # Have we reached the end of the search or still stuff to send?",
      "848:                 if endOfSearch > 0:",
      "849:                     # Let's remove the SID from our ConnData",
      "852:                 respParameters['EndOfSearch'] = endOfSearch",
      "853:                 respParameters['SearchCount'] = searchCount",
      "855:                 errorCode = STATUS_INVALID_HANDLE",
      "856:         else:",
      "859:         smbServer.setConnectionData(connId, connData)",
      "",
      "[Removed Lines]",
      "836:                     if (totalData+lenData) >= maxDataCount or (i[0]+1) >= findNext2Parameters['SearchCount']:",
      "843:                         searchCount +=1",
      "850:                     del(connData['SIDs'][sid])",
      "854:             else:",
      "857:             errorCode = STATUS_SMB_BAD_TID",
      "",
      "[Added Lines]",
      "864:                     if (totalData + lenData) >= maxDataCount or (i[0] + 1) >= findNext2Parameters['SearchCount']:",
      "871:                         searchCount += 1",
      "878:                     del (connData['SIDs'][sid])",
      "882:             else:",
      "885:             errorCode = STATUS_SMB_BAD_TID",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "867:         respSetup = b''",
      "868:         respParameters = b''",
      "869:         respData = b''",
      "872:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "873:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "880:             respParameters = smb.SMBFindFirst2Response_Parameters()",
      "881:             endOfSearch = 1",
      "883:             searchCount = 0",
      "884:             totalData = 0",
      "885:             for i in enumerate(searchResult):",
      "887:                 data = i[1].getData()",
      "888:                 lenData = len(data)",
      "890:                     # We gotta stop here and continue on a find_next2",
      "891:                     endOfSearch = 0",
      "892:                     # Simple way to generate a fid",
      "893:                     if len(connData['SIDs']) == 0:",
      "895:                     else:",
      "897:                     # Store the remaining search results in the ConnData SID",
      "898:                     connData['SIDs'][sid] = searchResult[i[0]:]",
      "899:                     respParameters['LastNameOffset'] = totalData",
      "900:                     break",
      "901:                 else:",
      "903:                     respData += data",
      "907:                     totalData += lenData + padLen",
      "909:             respParameters['SID'] = sid",
      "910:             respParameters['EndOfSearch'] = endOfSearch",
      "911:             respParameters['SearchCount'] = searchCount",
      "912:         else:",
      "915:         smbServer.setConnectionData(connId, connData)",
      "917:         return respSetup, respParameters, respData, errorCode",
      "919: # Here we implement the commands handlers",
      "920: class SMBCommands:",
      "",
      "[Removed Lines]",
      "870:         findFirst2Parameters = smb.SMBFindFirst2_Parameters( recvPacket['Flags2'], data = parameters)",
      "875:             searchResult, searchCount, errorCode = findFirst2(path,",
      "876:                           decodeSMBString( recvPacket['Flags2'], findFirst2Parameters['FileName'] ),",
      "877:                           findFirst2Parameters['InformationLevel'],",
      "878:                           findFirst2Parameters['SearchAttributes'] , pktFlags = recvPacket['Flags2'])",
      "882:             sid = 0x80 # default SID",
      "886:                 #i[1].dump()",
      "889:                 if (totalData+lenData) >= maxDataCount or (i[0]+1) > findFirst2Parameters['SearchCount']:",
      "894:                        sid = 1",
      "896:                        sid = list(connData['SIDs'].keys())[-1] + 1",
      "902:                     searchCount +=1",
      "905:                     padLen = (8-(lenData % 8)) %8",
      "906:                     respData += b'\\xaa'*padLen",
      "913:             errorCode = STATUS_SMB_BAD_TID",
      "",
      "[Added Lines]",
      "898:         findFirst2Parameters = smb.SMBFindFirst2_Parameters(recvPacket['Flags2'], data=parameters)",
      "903:             searchResult, searchCount, errorCode = findFirst2(path,",
      "904:                                                               decodeSMBString(recvPacket['Flags2'],",
      "905:                                                                               findFirst2Parameters['FileName']),",
      "906:                                                               findFirst2Parameters['InformationLevel'],",
      "907:                                                               findFirst2Parameters['SearchAttributes'],",
      "908:                                                               pktFlags=recvPacket['Flags2'])",
      "912:             sid = 0x80  # default SID",
      "916:                 # i[1].dump()",
      "919:                 if (totalData + lenData) >= maxDataCount or (i[0] + 1) > findFirst2Parameters['SearchCount']:",
      "924:                         sid = 1",
      "926:                         sid = list(connData['SIDs'].keys())[-1] + 1",
      "932:                     searchCount += 1",
      "935:                     padLen = (8 - (lenData % 8)) % 8",
      "936:                     respData += b'\\xaa' * padLen",
      "943:             errorCode = STATUS_SMB_BAD_TID",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "926:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "930:         # Do the stuff",
      "931:         if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:",
      "933:             raise Exception(\"Unsupported partial parameters in TRANSACT2!\")",
      "934:         else:",
      "939:             paramCount = transParameters['ParameterCount']",
      "940:             transData['Trans_ParametersLength'] = paramCount",
      "",
      "[Removed Lines]",
      "928:         transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
      "932:             # TODO: Handle partial parameters",
      "935:             transData = smb.SMBTransaction_SData(flags = recvPacket['Flags2'])",
      "936:             # Standard says servers shouldn't trust Parameters and Data comes",
      "937:             # in order, so we have to parse the offsets, ugly",
      "",
      "[Added Lines]",
      "959:         transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
      "963:             # TODO: Handle partial parameters",
      "966:             transData = smb.SMBTransaction_SData(flags=recvPacket['Flags2'])",
      "967:             # Standard says servers shouldn't trust Parameters and Data comes",
      "968:             # in order, so we have to parse the offsets, ugly",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "943:             transData.fromString(SMBCommand['Data'])",
      "944:             if transParameters['ParameterOffset'] > 0:",
      "945:                 paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']",
      "947:             else:",
      "948:                 transData['Trans_Parameters'] = b''",
      "950:             if transParameters['DataOffset'] > 0:",
      "951:                 dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']",
      "952:                 transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
      "954:                 transData['Trans_Data'] = b''",
      "956:             # Call the handler for this TRANSACTION",
      "957:             if transParameters['SetupCount'] == 0:",
      "958:                 # No subcommand, let's play with the Name",
      "960:             else:",
      "961:                 command = struct.unpack('<H', transParameters['Setup'][:2])[0]",
      "963:             if command in transCommands:",
      "1054:             else:",
      "1062:         smbServer.setConnectionData(connId, connData)",
      "1064:         return [respSMBCommand], None, errorCode",
      "1067:     @staticmethod",
      "1068:     def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):",
      "1069:         connData = smbServer.getConnectionData(connId)",
      "1071:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1074:         # Do the stuff",
      "1075:         if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:",
      "1077:             raise Exception(\"Unsupported partial parameters in NTTrans!\")",
      "1078:         else:",
      "1079:             NTTransData = smb.SMBNTTransaction_Data()",
      "1083:             paramCount = NTTransParameters['ParameterCount']",
      "1084:             NTTransData['NT_Trans_ParametersLength'] = paramCount",
      "",
      "[Removed Lines]",
      "946:                 transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
      "953:             else:",
      "959:                 command = decodeSMBString(recvPacket['Flags2'],transData['Name'])",
      "964:                # Call the TRANS subcommand",
      "965:                setup = b''",
      "966:                parameters = b''",
      "967:                data = b''",
      "968:                try:",
      "969:                    setup, parameters, data, errorCode = transCommands[command](connId,",
      "970:                                 smbServer,",
      "971:                                 recvPacket,",
      "972:                                 transData['Trans_Parameters'],",
      "973:                                 transData['Trans_Data'],",
      "974:                                 transParameters['MaxDataCount'])",
      "975:                except Exception as e:",
      "976:                    #print 'Transaction: %s' % e,e",
      "977:                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)",
      "978:                    errorCode = STATUS_ACCESS_DENIED",
      "979:                    #raise",
      "981:                if setup == b'' and parameters == b'' and data == b'':",
      "982:                    # Something wen't wrong",
      "983:                    respParameters = b''",
      "984:                    respData = b''",
      "985:                else:",
      "986:                    # Build the answer",
      "987:                    if hasattr(data, 'getData'):",
      "988:                        data = data.getData()",
      "989:                    remainingData = len(data)",
      "990:                    if hasattr(parameters, 'getData'):",
      "991:                        parameters = parameters.getData()",
      "992:                    remainingParameters = len(parameters)",
      "993:                    commands = []",
      "994:                    dataDisplacement = 0",
      "995:                    while remainingData > 0 or remainingParameters > 0:",
      "996:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "997:                        respParameters = smb.SMBTransactionResponse_Parameters()",
      "998:                        respData       = smb.SMBTransaction2Response_Data()",
      "1000:                        respParameters['TotalParameterCount'] = len(parameters)",
      "1001:                        respParameters['ParameterCount']      = len(parameters)",
      "1002:                        respData['Trans_ParametersLength']    = len(parameters)",
      "1003:                        respParameters['TotalDataCount']      = len(data)",
      "1004:                        respParameters['DataDisplacement']    = dataDisplacement",
      "1006:                        # TODO: Do the same for parameters",
      "1007:                        if len(data) >  transParameters['MaxDataCount']:",
      "1008:                            # Answer doesn't fit in this packet",
      "1009:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),transParameters['MaxDataCount']) )",
      "1010:                            respParameters['DataCount'] = transParameters['MaxDataCount']",
      "1011:                        else:",
      "1012:                            respParameters['DataCount'] = len(data)",
      "1014:                        respData['Trans_DataLength']          = respParameters['DataCount']",
      "1015:                        respParameters['SetupCount']          = len(setup)",
      "1016:                        respParameters['Setup']               = setup",
      "1017:                        # TODO: Make sure we're calculating the pad right",
      "1018:                        if len(parameters) > 0:",
      "1019:                            #padLen = 4 - (55 + len(setup)) % 4",
      "1020:                            padLen = (4 - (55 + len(setup)) % 4 ) % 4",
      "1021:                            padBytes = b'\\xFF' * padLen",
      "1022:                            respData['Pad1'] = padBytes",
      "1023:                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
      "1024:                        else:",
      "1025:                            padLen = 0",
      "1026:                            respParameters['ParameterOffset'] = 0",
      "1027:                            respData['Pad1']                  = b''",
      "1029:                        if len(data) > 0:",
      "1030:                            #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
      "1031:                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1032:                            respData['Pad2'] = b'\\xFF' * pad2Len",
      "1033:                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
      "1034:                        else:",
      "1035:                            respParameters['DataOffset'] = 0",
      "1036:                            respData['Pad2']             = b''",
      "1038:                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1039:                        respData['Trans_Data']       = data[:respParameters['DataCount']]",
      "1040:                        respSMBCommand['Parameters'] = respParameters",
      "1041:                        respSMBCommand['Data']       = respData",
      "1043:                        data = data[respParameters['DataCount']:]",
      "1044:                        remainingData -= respParameters['DataCount']",
      "1045:                        dataDisplacement += respParameters['DataCount'] + 1",
      "1047:                        parameters = parameters[respParameters['ParameterCount']:]",
      "1048:                        remainingParameters -= respParameters['ParameterCount']",
      "1049:                        commands.append(respSMBCommand)",
      "1051:                    smbServer.setConnectionData(connId, connData)",
      "1052:                    return commands, None, errorCode",
      "1055:                smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)",
      "1056:                respParameters = b''",
      "1057:                respData = b''",
      "1058:                errorCode = STATUS_NOT_IMPLEMENTED",
      "1060:         respSMBCommand['Parameters']             = respParameters",
      "1061:         respSMBCommand['Data']                   = respData",
      "1073:         NTTransParameters= smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])",
      "1076:             # TODO: Handle partial parameters",
      "1080:             # Standard says servers shouldn't trust Parameters and Data comes",
      "1081:             # in order, so we have to parse the offsets, ugly",
      "",
      "[Added Lines]",
      "977:                 transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
      "984:             else:",
      "990:                 command = decodeSMBString(recvPacket['Flags2'], transData['Name'])",
      "995:                 # Call the TRANS subcommand",
      "996:                 setup = b''",
      "997:                 parameters = b''",
      "998:                 data = b''",
      "999:                 try:",
      "1000:                     setup, parameters, data, errorCode = transCommands[command](connId,",
      "1001:                                                                                 smbServer,",
      "1002:                                                                                 recvPacket,",
      "1003:                                                                                 transData['Trans_Parameters'],",
      "1004:                                                                                 transData['Trans_Data'],",
      "1005:                                                                                 transParameters['MaxDataCount'])",
      "1006:                 except Exception as e:",
      "1007:                     # print 'Transaction: %s' % e,e",
      "1008:                     smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)",
      "1009:                     errorCode = STATUS_ACCESS_DENIED",
      "1010:                     # raise",
      "1012:                 if setup == b'' and parameters == b'' and data == b'':",
      "1013:                     # Something wen't wrong",
      "1014:                     respParameters = b''",
      "1015:                     respData = b''",
      "1016:                 else:",
      "1017:                     # Build the answer",
      "1018:                     if hasattr(data, 'getData'):",
      "1019:                         data = data.getData()",
      "1020:                     remainingData = len(data)",
      "1021:                     if hasattr(parameters, 'getData'):",
      "1022:                         parameters = parameters.getData()",
      "1023:                     remainingParameters = len(parameters)",
      "1024:                     commands = []",
      "1025:                     dataDisplacement = 0",
      "1026:                     while remainingData > 0 or remainingParameters > 0:",
      "1027:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1028:                         respParameters = smb.SMBTransactionResponse_Parameters()",
      "1029:                         respData = smb.SMBTransaction2Response_Data()",
      "1031:                         respParameters['TotalParameterCount'] = len(parameters)",
      "1032:                         respParameters['ParameterCount'] = len(parameters)",
      "1033:                         respData['Trans_ParametersLength'] = len(parameters)",
      "1034:                         respParameters['TotalDataCount'] = len(data)",
      "1035:                         respParameters['DataDisplacement'] = dataDisplacement",
      "1037:                         # TODO: Do the same for parameters",
      "1038:                         if len(data) > transParameters['MaxDataCount']:",
      "1039:                             # Answer doesn't fit in this packet",
      "1040:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), transParameters['MaxDataCount']))",
      "1041:                             respParameters['DataCount'] = transParameters['MaxDataCount']",
      "1042:                         else:",
      "1043:                             respParameters['DataCount'] = len(data)",
      "1045:                         respData['Trans_DataLength'] = respParameters['DataCount']",
      "1046:                         respParameters['SetupCount'] = len(setup)",
      "1047:                         respParameters['Setup'] = setup",
      "1048:                         # TODO: Make sure we're calculating the pad right",
      "1049:                         if len(parameters) > 0:",
      "1050:                             # padLen = 4 - (55 + len(setup)) % 4",
      "1051:                             padLen = (4 - (55 + len(setup)) % 4) % 4",
      "1052:                             padBytes = b'\\xFF' * padLen",
      "1053:                             respData['Pad1'] = padBytes",
      "1054:                             respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
      "1055:                         else:",
      "1056:                             padLen = 0",
      "1057:                             respParameters['ParameterOffset'] = 0",
      "1058:                             respData['Pad1'] = b''",
      "1060:                         if len(data) > 0:",
      "1061:                             # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
      "1062:                             pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1063:                             respData['Pad2'] = b'\\xFF' * pad2Len",
      "1064:                             respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
      "1065:                         else:",
      "1066:                             respParameters['DataOffset'] = 0",
      "1067:                             respData['Pad2'] = b''",
      "1069:                         respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1070:                         respData['Trans_Data'] = data[:respParameters['DataCount']]",
      "1071:                         respSMBCommand['Parameters'] = respParameters",
      "1072:                         respSMBCommand['Data'] = respData",
      "1074:                         data = data[respParameters['DataCount']:]",
      "1075:                         remainingData -= respParameters['DataCount']",
      "1076:                         dataDisplacement += respParameters['DataCount'] + 1",
      "1078:                         parameters = parameters[respParameters['ParameterCount']:]",
      "1079:                         remainingParameters -= respParameters['ParameterCount']",
      "1080:                         commands.append(respSMBCommand)",
      "1082:                     smbServer.setConnectionData(connId, connData)",
      "1083:                     return commands, None, errorCode",
      "1086:                 smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)",
      "1087:                 respParameters = b''",
      "1088:                 respData = b''",
      "1089:                 errorCode = STATUS_NOT_IMPLEMENTED",
      "1091:         respSMBCommand['Parameters'] = respParameters",
      "1092:         respSMBCommand['Data'] = respData",
      "1103:         NTTransParameters = smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])",
      "1106:             # TODO: Handle partial parameters",
      "1110:             # Standard says servers shouldn't trust Parameters and Data comes",
      "1111:             # in order, so we have to parse the offsets, ugly",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1088:             if NTTransParameters['ParameterOffset'] > 0:",
      "1089:                 paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']",
      "1091:             else:",
      "1092:                 NTTransData['NT_Trans_Parameters'] = b''",
      "1094:             if NTTransParameters['DataOffset'] > 0:",
      "1095:                 dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']",
      "1096:                 NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
      "1098:                 NTTransData['NT_Trans_Data'] = b''",
      "1100:             # Call the handler for this TRANSACTION",
      "1101:             command = NTTransParameters['Function']",
      "1102:             if command in transCommands:",
      "1193:             else:",
      "1202:         smbServer.setConnectionData(connId, connData)",
      "1203:         return [respSMBCommand], None, errorCode",
      "1206:     @staticmethod",
      "1207:     def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):",
      "1208:         connData = smbServer.getConnectionData(connId)",
      "1210:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1214:         # Do the stuff",
      "1215:         if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:",
      "1218:             raise Exception(\"Unsupported partial parameters in TRANSACT2!\")",
      "1219:         else:",
      "1220:             trans2Data = smb.SMBTransaction2_Data()",
      "1224:             paramCount = trans2Parameters['ParameterCount']",
      "1225:             trans2Data['Trans_ParametersLength'] = paramCount",
      "",
      "[Removed Lines]",
      "1090:                 NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
      "1097:             else:",
      "1103:                # Call the NT TRANS subcommand",
      "1104:                setup = b''",
      "1105:                parameters = b''",
      "1106:                data = b''",
      "1107:                try:",
      "1108:                    setup, parameters, data, errorCode = transCommands[command](connId,",
      "1109:                                 smbServer,",
      "1110:                                 recvPacket,",
      "1111:                                 NTTransData['NT_Trans_Parameters'],",
      "1112:                                 NTTransData['NT_Trans_Data'],",
      "1113:                                 NTTransParameters['MaxDataCount'])",
      "1114:                except Exception as e:",
      "1115:                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)",
      "1116:                    errorCode = STATUS_ACCESS_DENIED",
      "1117:                    #raise",
      "1119:                if setup == b'' and parameters == b'' and data == b'':",
      "1120:                    # Something wen't wrong",
      "1121:                    respParameters = b''",
      "1122:                    respData = b''",
      "1123:                    if errorCode == STATUS_SUCCESS:",
      "1124:                        errorCode = STATUS_ACCESS_DENIED",
      "1125:                else:",
      "1126:                    # Build the answer",
      "1127:                    if hasattr(data, 'getData'):",
      "1128:                        data = data.getData()",
      "1129:                    remainingData = len(data)",
      "1130:                    if hasattr(parameters, 'getData'):",
      "1131:                        parameters = parameters.getData()",
      "1132:                    remainingParameters = len(parameters)",
      "1133:                    commands = []",
      "1134:                    dataDisplacement = 0",
      "1135:                    while remainingData > 0 or remainingParameters > 0:",
      "1136:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1137:                        respParameters = smb.SMBNTTransactionResponse_Parameters()",
      "1138:                        respData       = smb.SMBNTTransactionResponse_Data()",
      "1140:                        respParameters['TotalParameterCount'] = len(parameters)",
      "1141:                        respParameters['ParameterCount']      = len(parameters)",
      "1142:                        respData['Trans_ParametersLength']    = len(parameters)",
      "1143:                        respParameters['TotalDataCount']      = len(data)",
      "1144:                        respParameters['DataDisplacement']    = dataDisplacement",
      "1145:                        # TODO: Do the same for parameters",
      "1146:                        if len(data) >  NTTransParameters['MaxDataCount']:",
      "1147:                            # Answer doesn't fit in this packet",
      "1148:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),NTTransParameters['MaxDataCount']) )",
      "1149:                            respParameters['DataCount'] = NTTransParameters['MaxDataCount']",
      "1150:                        else:",
      "1151:                            respParameters['DataCount'] = len(data)",
      "1153:                        respData['NT_Trans_DataLength']          = respParameters['DataCount']",
      "1154:                        respParameters['SetupCount']          = len(setup)",
      "1155:                        respParameters['Setup']               = setup",
      "1156:                        # TODO: Make sure we're calculating the pad right",
      "1157:                        if len(parameters) > 0:",
      "1158:                            #padLen = 4 - (71 + len(setup)) % 4",
      "1159:                            padLen = (4 - (73 + len(setup)) % 4 ) % 4",
      "1160:                            padBytes = b'\\xFF' * padLen",
      "1161:                            respData['Pad1'] = padBytes",
      "1162:                            respParameters['ParameterOffset'] = 73 + len(setup) + padLen",
      "1163:                        else:",
      "1164:                            padLen = 0",
      "1165:                            respParameters['ParameterOffset'] = 0",
      "1166:                            respData['Pad1']                  = b''",
      "1168:                        if len(data) > 0:",
      "1169:                            #pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4",
      "1170:                            pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1171:                            respData['Pad2'] = b'\\xFF' * pad2Len",
      "1172:                            respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len",
      "1173:                        else:",
      "1174:                            respParameters['DataOffset'] = 0",
      "1175:                            respData['Pad2']             = b''",
      "1177:                        respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1178:                        respData['NT_Trans_Data']       = data[:respParameters['DataCount']]",
      "1179:                        respSMBCommand['Parameters'] = respParameters",
      "1180:                        respSMBCommand['Data']       = respData",
      "1182:                        data = data[respParameters['DataCount']:]",
      "1183:                        remainingData -= respParameters['DataCount']",
      "1184:                        dataDisplacement += respParameters['DataCount'] + 1",
      "1186:                        parameters = parameters[respParameters['ParameterCount']:]",
      "1187:                        remainingParameters -= respParameters['ParameterCount']",
      "1188:                        commands.append(respSMBCommand)",
      "1190:                    smbServer.setConnectionData(connId, connData)",
      "1191:                    return commands, None, errorCode",
      "1194:                #smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)",
      "1195:                respParameters = b''",
      "1196:                respData = b''",
      "1197:                errorCode = STATUS_NOT_IMPLEMENTED",
      "1199:         respSMBCommand['Parameters']             = respParameters",
      "1200:         respSMBCommand['Data']                   = respData",
      "1212:         trans2Parameters= smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])",
      "1216:             # TODO: Handle partial parameters",
      "1217:             #print \"Unsupported partial parameters in TRANSACT2!\"",
      "1221:             # Standard says servers shouldn't trust Parameters and Data comes",
      "1222:             # in order, so we have to parse the offsets, ugly",
      "",
      "[Added Lines]",
      "1120:                 NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
      "1127:             else:",
      "1133:                 # Call the NT TRANS subcommand",
      "1134:                 setup = b''",
      "1135:                 parameters = b''",
      "1136:                 data = b''",
      "1137:                 try:",
      "1138:                     setup, parameters, data, errorCode = transCommands[command](connId,",
      "1139:                                                                                 smbServer,",
      "1140:                                                                                 recvPacket,",
      "1141:                                                                                 NTTransData['NT_Trans_Parameters'],",
      "1142:                                                                                 NTTransData['NT_Trans_Data'],",
      "1143:                                                                                 NTTransParameters['MaxDataCount'])",
      "1144:                 except Exception as e:",
      "1145:                     smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)",
      "1146:                     errorCode = STATUS_ACCESS_DENIED",
      "1147:                     # raise",
      "1149:                 if setup == b'' and parameters == b'' and data == b'':",
      "1150:                     # Something wen't wrong",
      "1151:                     respParameters = b''",
      "1152:                     respData = b''",
      "1153:                     if errorCode == STATUS_SUCCESS:",
      "1154:                         errorCode = STATUS_ACCESS_DENIED",
      "1155:                 else:",
      "1156:                     # Build the answer",
      "1157:                     if hasattr(data, 'getData'):",
      "1158:                         data = data.getData()",
      "1159:                     remainingData = len(data)",
      "1160:                     if hasattr(parameters, 'getData'):",
      "1161:                         parameters = parameters.getData()",
      "1162:                     remainingParameters = len(parameters)",
      "1163:                     commands = []",
      "1164:                     dataDisplacement = 0",
      "1165:                     while remainingData > 0 or remainingParameters > 0:",
      "1166:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1167:                         respParameters = smb.SMBNTTransactionResponse_Parameters()",
      "1168:                         respData = smb.SMBNTTransactionResponse_Data()",
      "1170:                         respParameters['TotalParameterCount'] = len(parameters)",
      "1171:                         respParameters['ParameterCount'] = len(parameters)",
      "1172:                         respData['Trans_ParametersLength'] = len(parameters)",
      "1173:                         respParameters['TotalDataCount'] = len(data)",
      "1174:                         respParameters['DataDisplacement'] = dataDisplacement",
      "1175:                         # TODO: Do the same for parameters",
      "1176:                         if len(data) > NTTransParameters['MaxDataCount']:",
      "1177:                             # Answer doesn't fit in this packet",
      "1178:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), NTTransParameters['MaxDataCount']))",
      "1179:                             respParameters['DataCount'] = NTTransParameters['MaxDataCount']",
      "1180:                         else:",
      "1181:                             respParameters['DataCount'] = len(data)",
      "1183:                         respData['NT_Trans_DataLength'] = respParameters['DataCount']",
      "1184:                         respParameters['SetupCount'] = len(setup)",
      "1185:                         respParameters['Setup'] = setup",
      "1186:                         # TODO: Make sure we're calculating the pad right",
      "1187:                         if len(parameters) > 0:",
      "1188:                             # padLen = 4 - (71 + len(setup)) % 4",
      "1189:                             padLen = (4 - (73 + len(setup)) % 4) % 4",
      "1190:                             padBytes = b'\\xFF' * padLen",
      "1191:                             respData['Pad1'] = padBytes",
      "1192:                             respParameters['ParameterOffset'] = 73 + len(setup) + padLen",
      "1193:                         else:",
      "1194:                             padLen = 0",
      "1195:                             respParameters['ParameterOffset'] = 0",
      "1196:                             respData['Pad1'] = b''",
      "1198:                         if len(data) > 0:",
      "1199:                             # pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4",
      "1200:                             pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1201:                             respData['Pad2'] = b'\\xFF' * pad2Len",
      "1202:                             respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len",
      "1203:                         else:",
      "1204:                             respParameters['DataOffset'] = 0",
      "1205:                             respData['Pad2'] = b''",
      "1207:                         respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1208:                         respData['NT_Trans_Data'] = data[:respParameters['DataCount']]",
      "1209:                         respSMBCommand['Parameters'] = respParameters",
      "1210:                         respSMBCommand['Data'] = respData",
      "1212:                         data = data[respParameters['DataCount']:]",
      "1213:                         remainingData -= respParameters['DataCount']",
      "1214:                         dataDisplacement += respParameters['DataCount'] + 1",
      "1216:                         parameters = parameters[respParameters['ParameterCount']:]",
      "1217:                         remainingParameters -= respParameters['ParameterCount']",
      "1218:                         commands.append(respSMBCommand)",
      "1220:                     smbServer.setConnectionData(connId, connData)",
      "1221:                     return commands, None, errorCode",
      "1224:                 # smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)",
      "1225:                 respParameters = b''",
      "1226:                 respData = b''",
      "1227:                 errorCode = STATUS_NOT_IMPLEMENTED",
      "1229:         respSMBCommand['Parameters'] = respParameters",
      "1230:         respSMBCommand['Data'] = respData",
      "1241:         trans2Parameters = smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])",
      "1245:             # TODO: Handle partial parameters",
      "1246:             # print \"Unsupported partial parameters in TRANSACT2!\"",
      "1250:             # Standard says servers shouldn't trust Parameters and Data comes",
      "1251:             # in order, so we have to parse the offsets, ugly",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1229:             if trans2Parameters['ParameterOffset'] > 0:",
      "1230:                 paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']",
      "1232:             else:",
      "1233:                 trans2Data['Trans_Parameters'] = b''",
      "1235:             if trans2Parameters['DataOffset'] > 0:",
      "1236:                 dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']",
      "1237:                 trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
      "1239:                 trans2Data['Trans_Data'] = b''",
      "1241:             # Call the handler for this TRANSACTION",
      "1242:             command = struct.unpack('<H', trans2Parameters['Setup'])[0]",
      "1243:             if command in transCommands:",
      "1330:             else:",
      "1339:         smbServer.setConnectionData(connId, connData)",
      "1340:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1231:                 trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
      "1238:             else:",
      "1244:                # Call the TRANS2 subcommand",
      "1245:                try:",
      "1246:                    setup, parameters, data, errorCode = transCommands[command](connId,",
      "1247:                                 smbServer,",
      "1248:                                 recvPacket,",
      "1249:                                 trans2Data['Trans_Parameters'],",
      "1250:                                 trans2Data['Trans_Data'],",
      "1251:                                 trans2Parameters['MaxDataCount'])",
      "1252:                except Exception as e:",
      "1253:                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)",
      "1254:                    #import traceback",
      "1255:                    #traceback.print_exc()",
      "1256:                    raise",
      "1258:                if setup == b'' and parameters == b'' and data == b'':",
      "1259:                    # Something wen't wrong",
      "1260:                    respParameters = b''",
      "1261:                    respData = b''",
      "1262:                else:",
      "1263:                    # Build the answer",
      "1264:                    if hasattr(data, 'getData'):",
      "1265:                        data = data.getData()",
      "1266:                    remainingData = len(data)",
      "1267:                    if hasattr(parameters, 'getData'):",
      "1268:                        parameters = parameters.getData()",
      "1269:                    remainingParameters = len(parameters)",
      "1270:                    commands = []",
      "1271:                    dataDisplacement = 0",
      "1272:                    while remainingData > 0 or remainingParameters > 0:",
      "1273:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1274:                        respParameters = smb.SMBTransaction2Response_Parameters()",
      "1275:                        respData       = smb.SMBTransaction2Response_Data()",
      "1277:                        respParameters['TotalParameterCount'] = len(parameters)",
      "1278:                        respParameters['ParameterCount']      = len(parameters)",
      "1279:                        respData['Trans_ParametersLength']    = len(parameters)",
      "1280:                        respParameters['TotalDataCount']      = len(data)",
      "1281:                        respParameters['DataDisplacement']    = dataDisplacement",
      "1282:                        # TODO: Do the same for parameters",
      "1283:                        if len(data) >  trans2Parameters['MaxDataCount']:",
      "1284:                            # Answer doesn't fit in this packet",
      "1285:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),trans2Parameters['MaxDataCount']) )",
      "1286:                            respParameters['DataCount'] = trans2Parameters['MaxDataCount']",
      "1287:                        else:",
      "1288:                            respParameters['DataCount'] = len(data)",
      "1290:                        respData['Trans_DataLength']          = respParameters['DataCount']",
      "1291:                        respParameters['SetupCount']          = len(setup)",
      "1292:                        respParameters['Setup']               = setup",
      "1293:                        # TODO: Make sure we're calculating the pad right",
      "1294:                        if len(parameters) > 0:",
      "1295:                            #padLen = 4 - (55 + len(setup)) % 4",
      "1296:                            padLen = (4 - (55 + len(setup)) % 4 ) % 4",
      "1297:                            padBytes = b'\\xFF' * padLen",
      "1298:                            respData['Pad1'] = padBytes",
      "1299:                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
      "1300:                        else:",
      "1301:                            padLen = 0",
      "1302:                            respParameters['ParameterOffset'] = 0",
      "1303:                            respData['Pad1']                  = b''",
      "1305:                        if len(data) > 0:",
      "1306:                            #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
      "1307:                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1308:                            respData['Pad2'] = b'\\xFF' * pad2Len",
      "1309:                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
      "1310:                        else:",
      "1311:                            respParameters['DataOffset'] = 0",
      "1312:                            respData['Pad2']             = b''",
      "1314:                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1315:                        respData['Trans_Data']       = data[:respParameters['DataCount']]",
      "1316:                        respSMBCommand['Parameters'] = respParameters",
      "1317:                        respSMBCommand['Data']       = respData",
      "1319:                        data = data[respParameters['DataCount']:]",
      "1320:                        remainingData -= respParameters['DataCount']",
      "1321:                        dataDisplacement += respParameters['DataCount'] + 1",
      "1323:                        parameters = parameters[respParameters['ParameterCount']:]",
      "1324:                        remainingParameters -= respParameters['ParameterCount']",
      "1325:                        commands.append(respSMBCommand)",
      "1327:                    smbServer.setConnectionData(connId, connData)",
      "1328:                    return commands, None, errorCode",
      "1331:                smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)",
      "1332:                respParameters = b''",
      "1333:                respData = b''",
      "1334:                errorCode = STATUS_NOT_IMPLEMENTED",
      "1336:         respSMBCommand['Parameters']             = respParameters",
      "1337:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1260:                 trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
      "1267:             else:",
      "1273:                 # Call the TRANS2 subcommand",
      "1274:                 try:",
      "1275:                     setup, parameters, data, errorCode = transCommands[command](connId,",
      "1276:                                                                                 smbServer,",
      "1277:                                                                                 recvPacket,",
      "1278:                                                                                 trans2Data['Trans_Parameters'],",
      "1279:                                                                                 trans2Data['Trans_Data'],",
      "1280:                                                                                 trans2Parameters['MaxDataCount'])",
      "1281:                 except Exception as e:",
      "1282:                     smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)",
      "1283:                     # import traceback",
      "1284:                     # traceback.print_exc()",
      "1285:                     raise",
      "1287:                 if setup == b'' and parameters == b'' and data == b'':",
      "1288:                     # Something wen't wrong",
      "1289:                     respParameters = b''",
      "1290:                     respData = b''",
      "1291:                 else:",
      "1292:                     # Build the answer",
      "1293:                     if hasattr(data, 'getData'):",
      "1294:                         data = data.getData()",
      "1295:                     remainingData = len(data)",
      "1296:                     if hasattr(parameters, 'getData'):",
      "1297:                         parameters = parameters.getData()",
      "1298:                     remainingParameters = len(parameters)",
      "1299:                     commands = []",
      "1300:                     dataDisplacement = 0",
      "1301:                     while remainingData > 0 or remainingParameters > 0:",
      "1302:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
      "1303:                         respParameters = smb.SMBTransaction2Response_Parameters()",
      "1304:                         respData = smb.SMBTransaction2Response_Data()",
      "1306:                         respParameters['TotalParameterCount'] = len(parameters)",
      "1307:                         respParameters['ParameterCount'] = len(parameters)",
      "1308:                         respData['Trans_ParametersLength'] = len(parameters)",
      "1309:                         respParameters['TotalDataCount'] = len(data)",
      "1310:                         respParameters['DataDisplacement'] = dataDisplacement",
      "1311:                         # TODO: Do the same for parameters",
      "1312:                         if len(data) > trans2Parameters['MaxDataCount']:",
      "1313:                             # Answer doesn't fit in this packet",
      "1314:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), trans2Parameters['MaxDataCount']))",
      "1315:                             respParameters['DataCount'] = trans2Parameters['MaxDataCount']",
      "1316:                         else:",
      "1317:                             respParameters['DataCount'] = len(data)",
      "1319:                         respData['Trans_DataLength'] = respParameters['DataCount']",
      "1320:                         respParameters['SetupCount'] = len(setup)",
      "1321:                         respParameters['Setup'] = setup",
      "1322:                         # TODO: Make sure we're calculating the pad right",
      "1323:                         if len(parameters) > 0:",
      "1324:                             # padLen = 4 - (55 + len(setup)) % 4",
      "1325:                             padLen = (4 - (55 + len(setup)) % 4) % 4",
      "1326:                             padBytes = b'\\xFF' * padLen",
      "1327:                             respData['Pad1'] = padBytes",
      "1328:                             respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
      "1329:                         else:",
      "1330:                             padLen = 0",
      "1331:                             respParameters['ParameterOffset'] = 0",
      "1332:                             respData['Pad1'] = b''",
      "1334:                         if len(data) > 0:",
      "1335:                             # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
      "1336:                             pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
      "1337:                             respData['Pad2'] = b'\\xFF' * pad2Len",
      "1338:                             respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
      "1339:                         else:",
      "1340:                             respParameters['DataOffset'] = 0",
      "1341:                             respData['Pad2'] = b''",
      "1343:                         respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
      "1344:                         respData['Trans_Data'] = data[:respParameters['DataCount']]",
      "1345:                         respSMBCommand['Parameters'] = respParameters",
      "1346:                         respSMBCommand['Data'] = respData",
      "1348:                         data = data[respParameters['DataCount']:]",
      "1349:                         remainingData -= respParameters['DataCount']",
      "1350:                         dataDisplacement += respParameters['DataCount'] + 1",
      "1352:                         parameters = parameters[respParameters['ParameterCount']:]",
      "1353:                         remainingParameters -= respParameters['ParameterCount']",
      "1354:                         commands.append(respSMBCommand)",
      "1356:                     smbServer.setConnectionData(connId, connData)",
      "1357:                     return commands, None, errorCode",
      "1360:                 smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)",
      "1361:                 respParameters = b''",
      "1362:                 respData = b''",
      "1363:                 errorCode = STATUS_NOT_IMPLEMENTED",
      "1365:         respSMBCommand['Parameters'] = respParameters",
      "1366:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1343:     def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):",
      "1344:         connData = smbServer.getConnectionData(connId)",
      "1350:         # I'm actually doing nothing.. just make MacOS happy ;)",
      "1351:         errorCode = STATUS_SUCCESS",
      "1355:         smbServer.setConnectionData(connId, connData)",
      "1357:         return [respSMBCommand], None, errorCode",
      "1360:     @staticmethod",
      "1361:     def smbComClose(connId, smbServer, SMBCommand, recvPacket):",
      "1362:         connData = smbServer.getConnectionData(connId)",
      "1370:         if comClose['FID'] in connData['OpenedFiles']:",
      "1390:         else:",
      "1391:             errorCode = STATUS_INVALID_HANDLE",
      "1393:         if errorCode > 0:",
      "1394:             respParameters = b''",
      "1399:         smbServer.setConnectionData(connId, connData)",
      "1401:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1346:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)",
      "1347:         respParameters        = b''",
      "1348:         respData              = b''",
      "1353:         respSMBCommand['Parameters']             = respParameters",
      "1354:         respSMBCommand['Data']                   = respData",
      "1364:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)",
      "1365:         respParameters        = b''",
      "1366:         respData              = b''",
      "1368:         comClose =  smb.SMBClose_Parameters(SMBCommand['Parameters'])",
      "1371:              errorCode = STATUS_SUCCESS",
      "1372:              fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']",
      "1373:              try:",
      "1374:                  if fileHandle == PIPE_FILE_DESCRIPTOR:",
      "1375:                      connData['OpenedFiles'][comClose['FID']]['Socket'].close()",
      "1376:                  elif fileHandle != VOID_FILE_DESCRIPTOR:",
      "1377:                      os.close(fileHandle)",
      "1378:              except Exception as e:",
      "1379:                  smbServer.log(\"comClose %s\" % e, logging.ERROR)",
      "1380:                  errorCode = STATUS_ACCESS_DENIED",
      "1381:              else:",
      "1382:                  # Check if the file was marked for removal",
      "1383:                  if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:",
      "1384:                      try:",
      "1385:                          os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])",
      "1386:                      except Exception as e:",
      "1387:                          smbServer.log(\"comClose %s\" % e, logging.ERROR)",
      "1388:                          errorCode = STATUS_ACCESS_DENIED",
      "1389:                  del(connData['OpenedFiles'][comClose['FID']])",
      "1395:             respData       = b''",
      "1397:         respSMBCommand['Parameters']             = respParameters",
      "1398:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1375:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)",
      "1376:         respParameters = b''",
      "1377:         respData = b''",
      "1382:         respSMBCommand['Parameters'] = respParameters",
      "1383:         respSMBCommand['Data'] = respData",
      "1392:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)",
      "1393:         respParameters = b''",
      "1394:         respData = b''",
      "1396:         comClose = smb.SMBClose_Parameters(SMBCommand['Parameters'])",
      "1399:             errorCode = STATUS_SUCCESS",
      "1400:             fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']",
      "1401:             try:",
      "1402:                 if fileHandle == PIPE_FILE_DESCRIPTOR:",
      "1403:                     connData['OpenedFiles'][comClose['FID']]['Socket'].close()",
      "1404:                 elif fileHandle != VOID_FILE_DESCRIPTOR:",
      "1405:                     os.close(fileHandle)",
      "1406:             except Exception as e:",
      "1407:                 smbServer.log(\"comClose %s\" % e, logging.ERROR)",
      "1408:                 errorCode = STATUS_ACCESS_DENIED",
      "1409:             else:",
      "1410:                 # Check if the file was marked for removal",
      "1411:                 if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:",
      "1412:                     try:",
      "1413:                         os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])",
      "1414:                     except Exception as e:",
      "1415:                         smbServer.log(\"comClose %s\" % e, logging.ERROR)",
      "1416:                         errorCode = STATUS_ACCESS_DENIED",
      "1417:                 del (connData['OpenedFiles'][comClose['FID']])",
      "1423:             respData = b''",
      "1425:         respSMBCommand['Parameters'] = respParameters",
      "1426:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1404:     def smbComWrite(connId, smbServer, SMBCommand, recvPacket):",
      "1405:         connData = smbServer.getConnectionData(connId)",
      "1412:         comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])",
      "1414:         if comWriteParameters['Fid'] in connData['OpenedFiles']:",
      "1431:         else:",
      "1432:             errorCode = STATUS_INVALID_HANDLE",
      "1435:         if errorCode > 0:",
      "1436:             respParameters = b''",
      "1441:         smbServer.setConnectionData(connId, connData)",
      "1443:         return [respSMBCommand], None, errorCode",
      "1445:     @staticmethod",
      "1447:         connData = smbServer.getConnectionData(connId)",
      "1455:         if comFlush['FID'] in connData['OpenedFiles']:",
      "1463:         else:",
      "1464:             errorCode = STATUS_INVALID_HANDLE",
      "1466:         if errorCode > 0:",
      "1467:             respParameters = b''",
      "1472:         smbServer.setConnectionData(connId, connData)",
      "1474:         return [respSMBCommand], None, errorCode",
      "1477:     @staticmethod",
      "1479:         connData = smbServer.getConnectionData(connId)",
      "1487:         # Get the Tid associated",
      "1488:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1493:                 if fileName[0] == '/' or fileName[0] == '\\\\':",
      "1494:                     # strip leading '/'",
      "1495:                     fileName = fileName[1:]",
      "1498:                 errorCode = STATUS_OBJECT_NAME_COLLISION",
      "1508:         else:",
      "1509:             errorCode = STATUS_SMB_BAD_TID",
      "1512:         if errorCode > 0:",
      "1513:             respParameters = b''",
      "1518:         smbServer.setConnectionData(connId, connData)",
      "1520:         return [respSMBCommand], None, errorCode",
      "1522:     @staticmethod",
      "1524:         connData = smbServer.getConnectionData(connId)",
      "1531:         # Get the Tid associated",
      "1532:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1538:                 # strip leading '/'",
      "1539:                 oldFileName = oldFileName[1:]",
      "1542:                 # strip leading '/'",
      "1543:                 newFileName = newFileName[1:]",
      "1547:                 errorCode = STATUS_NO_SUCH_FILE",
      "1557:         else:",
      "1558:             errorCode = STATUS_SMB_BAD_TID",
      "1561:         if errorCode > 0:",
      "1562:             respParameters = b''",
      "1567:         smbServer.setConnectionData(connId, connData)",
      "1569:         return [respSMBCommand], None, errorCode",
      "1571:     @staticmethod",
      "1573:         connData = smbServer.getConnectionData(connId)",
      "1581:         # Get the Tid associated",
      "1582:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1587:                 # strip leading '/'",
      "1588:                 fileName = fileName[1:]",
      "1591:                 errorCode = STATUS_NO_SUCH_FILE",
      "1601:         else:",
      "1602:             errorCode = STATUS_SMB_BAD_TID",
      "1604:         if errorCode > 0:",
      "1605:             respParameters = b''",
      "1610:         smbServer.setConnectionData(connId, connData)",
      "1612:         return [respSMBCommand], None, errorCode",
      "1615:     @staticmethod",
      "1617:         connData = smbServer.getConnectionData(connId)",
      "1625:         # Get the Tid associated",
      "1626:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1631:                 # strip leading '/'",
      "1632:                 fileName = fileName[1:]",
      "1635:                 errorCode = STATUS_NO_SUCH_FILE",
      "1648:         else:",
      "1649:             errorCode = STATUS_SMB_BAD_TID",
      "1651:         if errorCode > 0:",
      "1652:             respParameters = b''",
      "1657:         smbServer.setConnectionData(connId, connData)",
      "1659:         return [respSMBCommand], None, errorCode",
      "1662:     @staticmethod",
      "1663:     def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):",
      "1664:         connData = smbServer.getConnectionData(connId)",
      "1670:         if SMBCommand['WordCount'] == 0x0C:",
      "1672:             writeAndXData = smb.SMBWriteAndX_Data_Short()",
      "1673:         else:",
      "1675:             writeAndXData = smb.SMBWriteAndX_Data()",
      "1676:         writeAndXData['DataLength'] = writeAndX['DataLength']",
      "1677:         writeAndXData['DataOffset'] = writeAndX['DataOffset']",
      "1678:         writeAndXData.fromString(SMBCommand['Data'])",
      "1681:         if writeAndX['Fid'] in connData['OpenedFiles']:",
      "1702:         else:",
      "1703:             errorCode = STATUS_INVALID_HANDLE",
      "1705:         if errorCode > 0:",
      "1706:             respParameters = b''",
      "1711:         smbServer.setConnectionData(connId, connData)",
      "1713:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1407:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)",
      "1408:         respParameters        = smb.SMBWriteResponse_Parameters()",
      "1409:         respData              = b''",
      "1411:         comWriteParameters =  smb.SMBWrite_Parameters(SMBCommand['Parameters'])",
      "1415:              fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']",
      "1416:              errorCode = STATUS_SUCCESS",
      "1417:              try:",
      "1418:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1419:                      # TODO: Handle big size files",
      "1420:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "1421:                      if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:",
      "1422:                          os.lseek(fileHandle,comWriteParameters['Offset'],0)",
      "1423:                          os.write(fileHandle,comWriteData['Data'])",
      "1424:                  else:",
      "1425:                      sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']",
      "1426:                      sock.send(comWriteData['Data'])",
      "1427:                  respParameters['Count']    = comWriteParameters['Count']",
      "1428:              except Exception as e:",
      "1429:                  smbServer.log('smbComWrite: %s' % e, logging.ERROR)",
      "1430:                  errorCode = STATUS_ACCESS_DENIED",
      "1437:             respData       = b''",
      "1439:         respSMBCommand['Parameters']             = respParameters",
      "1440:         respSMBCommand['Data']                   = respData",
      "1446:     def smbComFlush(connId, smbServer, SMBCommand,recvPacket ):",
      "1449:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)",
      "1450:         respParameters        = b''",
      "1451:         respData              = b''",
      "1453:         comFlush =  smb.SMBFlush_Parameters(SMBCommand['Parameters'])",
      "1456:              errorCode = STATUS_SUCCESS",
      "1457:              fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']",
      "1458:              try:",
      "1459:                  os.fsync(fileHandle)",
      "1460:              except Exception as e:",
      "1461:                  smbServer.log(\"comFlush %s\" % e, logging.ERROR)",
      "1462:                  errorCode = STATUS_ACCESS_DENIED",
      "1468:             respData       = b''",
      "1470:         respSMBCommand['Parameters']             = respParameters",
      "1471:         respSMBCommand['Data']                   = respData",
      "1478:     def smbComCreateDirectory(connId, smbServer, SMBCommand,recvPacket ):",
      "1481:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)",
      "1482:         respParameters        = b''",
      "1483:         respData              = b''",
      "1485:         comCreateDirectoryData=  smb.SMBCreateDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1489:              errorCode = STATUS_SUCCESS",
      "1490:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1491:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comCreateDirectoryData['DirectoryName']).replace('\\\\','/'))",
      "1492:              if len(fileName) > 0:",
      "1496:              pathName = os.path.join(path,fileName)",
      "1497:              if os.path.exists(pathName):",
      "1500:              # TODO: More checks here in the future.. Specially when we support",
      "1501:              # user access",
      "1502:              else:",
      "1503:                  try:",
      "1504:                      os.mkdir(pathName)",
      "1505:                  except Exception as e:",
      "1506:                      smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)",
      "1507:                      errorCode = STATUS_ACCESS_DENIED",
      "1514:             respData       = b''",
      "1516:         respSMBCommand['Parameters']             = respParameters",
      "1517:         respSMBCommand['Data']                   = respData",
      "1523:     def smbComRename(connId, smbServer, SMBCommand, recvPacket ):",
      "1526:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)",
      "1527:         respParameters        = b''",
      "1528:         respData              = b''",
      "1530:         comRenameData      =  smb.SMBRename_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1533:              errorCode = STATUS_SUCCESS",
      "1534:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1535:              oldFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['OldFileName']).replace('\\\\','/'))",
      "1536:              newFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['NewFileName']).replace('\\\\','/'))",
      "1537:              if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):",
      "1540:              oldPathName = os.path.join(path,oldFileName)",
      "1541:              if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):",
      "1544:              newPathName = os.path.join(path,newFileName)",
      "1546:              if os.path.exists(oldPathName) is not True:",
      "1549:              # TODO: More checks here in the future.. Specially when we support",
      "1550:              # user access",
      "1551:              else:",
      "1552:                  try:",
      "1553:                      os.rename(oldPathName,newPathName)",
      "1554:                  except OSError as e:",
      "1555:                      smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)",
      "1556:                      errorCode = STATUS_ACCESS_DENIED",
      "1563:             respData       = b''",
      "1565:         respSMBCommand['Parameters']             = respParameters",
      "1566:         respSMBCommand['Data']                   = respData",
      "1572:     def smbComDelete(connId, smbServer, SMBCommand, recvPacket ):",
      "1575:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)",
      "1576:         respParameters        = b''",
      "1577:         respData              = b''",
      "1579:         comDeleteData         =  smb.SMBDelete_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1583:              errorCode = STATUS_SUCCESS",
      "1584:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1585:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteData['FileName']).replace('\\\\','/'))",
      "1586:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "1589:              pathName = os.path.join(path,fileName)",
      "1590:              if os.path.exists(pathName) is not True:",
      "1593:              # TODO: More checks here in the future.. Specially when we support",
      "1594:              # user access",
      "1595:              else:",
      "1596:                  try:",
      "1597:                      os.remove(pathName)",
      "1598:                  except OSError as e:",
      "1599:                      smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)",
      "1600:                      errorCode = STATUS_ACCESS_DENIED",
      "1606:             respData       = b''",
      "1608:         respSMBCommand['Parameters']             = respParameters",
      "1609:         respSMBCommand['Data']                   = respData",
      "1616:     def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket ):",
      "1619:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)",
      "1620:         respParameters        = b''",
      "1621:         respData              = b''",
      "1623:         comDeleteDirectoryData=  smb.SMBDeleteDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1627:              errorCode = STATUS_SUCCESS",
      "1628:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1629:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteDirectoryData['DirectoryName']).replace('\\\\','/'))",
      "1630:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "1633:              pathName = os.path.join(path,fileName)",
      "1634:              if os.path.exists(pathName) is not True:",
      "1637:              # TODO: More checks here in the future.. Specially when we support",
      "1638:              # user access",
      "1639:              else:",
      "1640:                  try:",
      "1641:                      os.rmdir(pathName)",
      "1642:                  except OSError as e:",
      "1643:                      smbServer.log(\"smbComDeleteDirectory: %s\" % e,logging.ERROR)",
      "1644:                      if e.errno == errno.ENOTEMPTY:",
      "1645:                          errorCode = STATUS_DIRECTORY_NOT_EMPTY",
      "1646:                      else:",
      "1647:                          errorCode = STATUS_ACCESS_DENIED",
      "1653:             respData       = b''",
      "1655:         respSMBCommand['Parameters']             = respParameters",
      "1656:         respSMBCommand['Data']                   = respData",
      "1666:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)",
      "1667:         respParameters        = smb.SMBWriteAndXResponse_Parameters()",
      "1668:         respData              = b''",
      "1671:             writeAndX =  smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])",
      "1674:             writeAndX =  smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])",
      "1682:              fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']",
      "1683:              errorCode = STATUS_SUCCESS",
      "1684:              try:",
      "1685:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1686:                      offset = writeAndX['Offset']",
      "1687:                      if 'HighOffset' in writeAndX.fields:",
      "1688:                          offset += (writeAndX['HighOffset'] << 32)",
      "1689:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "1690:                      if os.lseek(fileHandle, 0, 2) >= offset:",
      "1691:                          os.lseek(fileHandle,offset,0)",
      "1692:                          os.write(fileHandle,writeAndXData['Data'])",
      "1693:                  else:",
      "1694:                      sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']",
      "1695:                      sock.send(writeAndXData['Data'])",
      "1697:                  respParameters['Count']    = writeAndX['DataLength']",
      "1698:                  respParameters['Available']= 0xff",
      "1699:              except Exception as e:",
      "1700:                  smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)",
      "1701:                  errorCode = STATUS_ACCESS_DENIED",
      "1707:             respData       = b''",
      "1709:         respSMBCommand['Parameters']             = respParameters",
      "1710:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1435:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)",
      "1436:         respParameters = smb.SMBWriteResponse_Parameters()",
      "1437:         respData = b''",
      "1439:         comWriteParameters = smb.SMBWrite_Parameters(SMBCommand['Parameters'])",
      "1443:             fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']",
      "1444:             errorCode = STATUS_SUCCESS",
      "1445:             try:",
      "1446:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1447:                     # TODO: Handle big size files",
      "1448:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "1449:                     if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:",
      "1450:                         os.lseek(fileHandle, comWriteParameters['Offset'], 0)",
      "1451:                         os.write(fileHandle, comWriteData['Data'])",
      "1452:                 else:",
      "1453:                     sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']",
      "1454:                     sock.send(comWriteData['Data'])",
      "1455:                 respParameters['Count'] = comWriteParameters['Count']",
      "1456:             except Exception as e:",
      "1457:                 smbServer.log('smbComWrite: %s' % e, logging.ERROR)",
      "1458:                 errorCode = STATUS_ACCESS_DENIED",
      "1464:             respData = b''",
      "1466:         respSMBCommand['Parameters'] = respParameters",
      "1467:         respSMBCommand['Data'] = respData",
      "1473:     def smbComFlush(connId, smbServer, SMBCommand, recvPacket):",
      "1476:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)",
      "1477:         respParameters = b''",
      "1478:         respData = b''",
      "1480:         comFlush = smb.SMBFlush_Parameters(SMBCommand['Parameters'])",
      "1483:             errorCode = STATUS_SUCCESS",
      "1484:             fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']",
      "1485:             try:",
      "1486:                 os.fsync(fileHandle)",
      "1487:             except Exception as e:",
      "1488:                 smbServer.log(\"comFlush %s\" % e, logging.ERROR)",
      "1489:                 errorCode = STATUS_ACCESS_DENIED",
      "1495:             respData = b''",
      "1497:         respSMBCommand['Parameters'] = respParameters",
      "1498:         respSMBCommand['Data'] = respData",
      "1504:     def smbComCreateDirectory(connId, smbServer, SMBCommand, recvPacket):",
      "1507:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)",
      "1508:         respParameters = b''",
      "1509:         respData = b''",
      "1511:         comCreateDirectoryData = smb.SMBCreateDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "1515:             errorCode = STATUS_SUCCESS",
      "1516:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1517:             fileName = os.path.normpath(",
      "1518:                 decodeSMBString(recvPacket['Flags2'], comCreateDirectoryData['DirectoryName']).replace('\\\\', '/'))",
      "1519:             if len(fileName) > 0:",
      "1523:             pathName = os.path.join(path, fileName)",
      "1524:             if os.path.exists(pathName):",
      "1527:             # TODO: More checks here in the future.. Specially when we support",
      "1528:             # user access",
      "1529:             else:",
      "1530:                 try:",
      "1531:                     os.mkdir(pathName)",
      "1532:                 except Exception as e:",
      "1533:                     smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)",
      "1534:                     errorCode = STATUS_ACCESS_DENIED",
      "1540:             respData = b''",
      "1542:         respSMBCommand['Parameters'] = respParameters",
      "1543:         respSMBCommand['Data'] = respData",
      "1549:     def smbComRename(connId, smbServer, SMBCommand, recvPacket):",
      "1552:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)",
      "1553:         respParameters = b''",
      "1554:         respData = b''",
      "1556:         comRenameData = smb.SMBRename_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "1559:             errorCode = STATUS_SUCCESS",
      "1560:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1561:             oldFileName = os.path.normpath(",
      "1562:                 decodeSMBString(recvPacket['Flags2'], comRenameData['OldFileName']).replace('\\\\', '/'))",
      "1563:             newFileName = os.path.normpath(",
      "1564:                 decodeSMBString(recvPacket['Flags2'], comRenameData['NewFileName']).replace('\\\\', '/'))",
      "1565:             if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):",
      "1568:             oldPathName = os.path.join(path, oldFileName)",
      "1569:             if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):",
      "1572:             newPathName = os.path.join(path, newFileName)",
      "1574:             if os.path.exists(oldPathName) is not True:",
      "1577:             # TODO: More checks here in the future.. Specially when we support",
      "1578:             # user access",
      "1579:             else:",
      "1580:                 try:",
      "1581:                     os.rename(oldPathName, newPathName)",
      "1582:                 except OSError as e:",
      "1583:                     smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)",
      "1584:                     errorCode = STATUS_ACCESS_DENIED",
      "1590:             respData = b''",
      "1592:         respSMBCommand['Parameters'] = respParameters",
      "1593:         respSMBCommand['Data'] = respData",
      "1599:     def smbComDelete(connId, smbServer, SMBCommand, recvPacket):",
      "1602:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)",
      "1603:         respParameters = b''",
      "1604:         respData = b''",
      "1606:         comDeleteData = smb.SMBDelete_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "1610:             errorCode = STATUS_SUCCESS",
      "1611:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1612:             fileName = os.path.normpath(",
      "1613:                 decodeSMBString(recvPacket['Flags2'], comDeleteData['FileName']).replace('\\\\', '/'))",
      "1614:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "1617:             pathName = os.path.join(path, fileName)",
      "1618:             if os.path.exists(pathName) is not True:",
      "1621:             # TODO: More checks here in the future.. Specially when we support",
      "1622:             # user access",
      "1623:             else:",
      "1624:                 try:",
      "1625:                     os.remove(pathName)",
      "1626:                 except OSError as e:",
      "1627:                     smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)",
      "1628:                     errorCode = STATUS_ACCESS_DENIED",
      "1634:             respData = b''",
      "1636:         respSMBCommand['Parameters'] = respParameters",
      "1637:         respSMBCommand['Data'] = respData",
      "1643:     def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket):",
      "1646:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)",
      "1647:         respParameters = b''",
      "1648:         respData = b''",
      "1650:         comDeleteDirectoryData = smb.SMBDeleteDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "1654:             errorCode = STATUS_SUCCESS",
      "1655:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "1656:             fileName = os.path.normpath(",
      "1657:                 decodeSMBString(recvPacket['Flags2'], comDeleteDirectoryData['DirectoryName']).replace('\\\\', '/'))",
      "1658:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "1661:             pathName = os.path.join(path, fileName)",
      "1662:             if os.path.exists(pathName) is not True:",
      "1665:             # TODO: More checks here in the future.. Specially when we support",
      "1666:             # user access",
      "1667:             else:",
      "1668:                 try:",
      "1669:                     os.rmdir(pathName)",
      "1670:                 except OSError as e:",
      "1671:                     smbServer.log(\"smbComDeleteDirectory: %s\" % e, logging.ERROR)",
      "1672:                     if e.errno == errno.ENOTEMPTY:",
      "1673:                         errorCode = STATUS_DIRECTORY_NOT_EMPTY",
      "1674:                     else:",
      "1675:                         errorCode = STATUS_ACCESS_DENIED",
      "1681:             respData = b''",
      "1683:         respSMBCommand['Parameters'] = respParameters",
      "1684:         respSMBCommand['Data'] = respData",
      "1693:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)",
      "1694:         respParameters = smb.SMBWriteAndXResponse_Parameters()",
      "1695:         respData = b''",
      "1698:             writeAndX = smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])",
      "1701:             writeAndX = smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])",
      "1708:             fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']",
      "1709:             errorCode = STATUS_SUCCESS",
      "1710:             try:",
      "1711:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1712:                     offset = writeAndX['Offset']",
      "1713:                     if 'HighOffset' in writeAndX.fields:",
      "1714:                         offset += (writeAndX['HighOffset'] << 32)",
      "1715:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "1716:                     if os.lseek(fileHandle, 0, 2) >= offset:",
      "1717:                         os.lseek(fileHandle, offset, 0)",
      "1718:                         os.write(fileHandle, writeAndXData['Data'])",
      "1719:                 else:",
      "1720:                     sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']",
      "1721:                     sock.send(writeAndXData['Data'])",
      "1723:                 respParameters['Count'] = writeAndX['DataLength']",
      "1724:                 respParameters['Available'] = 0xff",
      "1725:             except Exception as e:",
      "1726:                 smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)",
      "1727:                 errorCode = STATUS_ACCESS_DENIED",
      "1733:             respData = b''",
      "1735:         respSMBCommand['Parameters'] = respParameters",
      "1736:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1716:     def smbComRead(connId, smbServer, SMBCommand, recvPacket):",
      "1717:         connData = smbServer.getConnectionData(connId)",
      "1725:         if comReadParameters['Fid'] in connData['OpenedFiles']:",
      "1742:         else:",
      "1743:             errorCode = STATUS_INVALID_HANDLE",
      "1745:         if errorCode > 0:",
      "1746:             respParameters = b''",
      "1751:         smbServer.setConnectionData(connId, connData)",
      "1753:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1719:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ)",
      "1720:         respParameters        = smb.SMBReadResponse_Parameters()",
      "1721:         respData              = smb.SMBReadResponse_Data()",
      "1723:         comReadParameters =  smb.SMBRead_Parameters(SMBCommand['Parameters'])",
      "1726:              fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']",
      "1727:              errorCode = STATUS_SUCCESS",
      "1728:              try:",
      "1729:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1730:                      # TODO: Handle big size files",
      "1731:                      os.lseek(fileHandle,comReadParameters['Offset'],0)",
      "1732:                      content = os.read(fileHandle,comReadParameters['Count'])",
      "1733:                  else:",
      "1734:                      sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']",
      "1735:                      content = sock.recv(comReadParameters['Count'])",
      "1736:                  respParameters['Count']    = len(content)",
      "1737:                  respData['DataLength']     = len(content)",
      "1738:                  respData['Data']           = content",
      "1739:              except Exception as e:",
      "1740:                  smbServer.log('smbComRead: %s ' % e, logging.ERROR)",
      "1741:                  errorCode = STATUS_ACCESS_DENIED",
      "1747:             respData       = b''",
      "1749:         respSMBCommand['Parameters']             = respParameters",
      "1750:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1745:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ)",
      "1746:         respParameters = smb.SMBReadResponse_Parameters()",
      "1747:         respData = smb.SMBReadResponse_Data()",
      "1749:         comReadParameters = smb.SMBRead_Parameters(SMBCommand['Parameters'])",
      "1752:             fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']",
      "1753:             errorCode = STATUS_SUCCESS",
      "1754:             try:",
      "1755:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1756:                     # TODO: Handle big size files",
      "1757:                     os.lseek(fileHandle, comReadParameters['Offset'], 0)",
      "1758:                     content = os.read(fileHandle, comReadParameters['Count'])",
      "1759:                 else:",
      "1760:                     sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']",
      "1761:                     content = sock.recv(comReadParameters['Count'])",
      "1762:                 respParameters['Count'] = len(content)",
      "1763:                 respData['DataLength'] = len(content)",
      "1764:                 respData['Data'] = content",
      "1765:             except Exception as e:",
      "1766:                 smbServer.log('smbComRead: %s ' % e, logging.ERROR)",
      "1767:                 errorCode = STATUS_ACCESS_DENIED",
      "1773:             respData = b''",
      "1775:         respSMBCommand['Parameters'] = respParameters",
      "1776:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "1756:     def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):",
      "1757:         connData = smbServer.getConnectionData(connId)",
      "1763:         if SMBCommand['WordCount'] == 0x0A:",
      "1765:         else:",
      "1768:         if readAndX['Fid'] in connData['OpenedFiles']:",
      "1789:         else:",
      "1790:             errorCode = STATUS_INVALID_HANDLE",
      "1792:         if errorCode > 0:",
      "1793:             respParameters = b''",
      "1798:         smbServer.setConnectionData(connId, connData)",
      "1800:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1759:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)",
      "1760:         respParameters        = smb.SMBReadAndXResponse_Parameters()",
      "1761:         respData              = b''",
      "1764:             readAndX =  smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])",
      "1766:             readAndX =  smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])",
      "1769:              fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']",
      "1770:              errorCode = 0",
      "1771:              try:",
      "1772:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1773:                      offset = readAndX['Offset']",
      "1774:                      if 'HighOffset' in readAndX.fields:",
      "1775:                          offset += (readAndX['HighOffset'] << 32)",
      "1776:                      os.lseek(fileHandle,offset,0)",
      "1777:                      content = os.read(fileHandle,readAndX['MaxCount'])",
      "1778:                  else:",
      "1779:                      sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']",
      "1780:                      content = sock.recv(readAndX['MaxCount'])",
      "1781:                  respParameters['Remaining']    = 0xffff",
      "1782:                  respParameters['DataCount']    = len(content)",
      "1783:                  respParameters['DataOffset']   = 59",
      "1784:                  respParameters['DataCount_Hi'] = 0",
      "1785:                  respData = content",
      "1786:              except Exception as e:",
      "1787:                  smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)",
      "1788:                  errorCode = STATUS_ACCESS_DENIED",
      "1794:             respData       = b''",
      "1796:         respSMBCommand['Parameters']             = respParameters",
      "1797:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1785:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)",
      "1786:         respParameters = smb.SMBReadAndXResponse_Parameters()",
      "1787:         respData = b''",
      "1790:             readAndX = smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])",
      "1792:             readAndX = smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])",
      "1795:             fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']",
      "1796:             errorCode = 0",
      "1797:             try:",
      "1798:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "1799:                     offset = readAndX['Offset']",
      "1800:                     if 'HighOffset' in readAndX.fields:",
      "1801:                         offset += (readAndX['HighOffset'] << 32)",
      "1802:                     os.lseek(fileHandle, offset, 0)",
      "1803:                     content = os.read(fileHandle, readAndX['MaxCount'])",
      "1804:                 else:",
      "1805:                     sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']",
      "1806:                     content = sock.recv(readAndX['MaxCount'])",
      "1807:                 respParameters['Remaining'] = 0xffff",
      "1808:                 respParameters['DataCount'] = len(content)",
      "1809:                 respParameters['DataOffset'] = 59",
      "1810:                 respParameters['DataCount_Hi'] = 0",
      "1811:                 respData = content",
      "1812:             except Exception as e:",
      "1813:                 smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)",
      "1814:                 errorCode = STATUS_ACCESS_DENIED",
      "1820:             respData = b''",
      "1822:         respSMBCommand['Parameters'] = respParameters",
      "1823:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1806:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)",
      "1807:         respParameters = smb.SMBQueryInformationResponse_Parameters()",
      "1812:         # Get the Tid associated",
      "1813:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1814:             fileSize, lastWriteTime, fileAttributes = queryFsInformation(",
      "1820:             respParameters['FileAttributes'] = fileAttributes",
      "1821:             errorCode = STATUS_SUCCESS",
      "1822:         else:",
      "1823:             # STATUS_SMB_BAD_TID",
      "1824:             errorCode = STATUS_SMB_BAD_TID",
      "1831:         smbServer.setConnectionData(connId, connData)",
      "1832:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1808:         respData       = b''",
      "1810:         queryInformation= smb.SMBQueryInformation_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1815:                 connData['ConnectedShares'][recvPacket['Tid']]['path'],",
      "1816:                 decodeSMBString(recvPacket['Flags2'],queryInformation['FileName']), pktFlags = recvPacket['Flags2'])",
      "1818:             respParameters['FileSize']       = fileSize",
      "1819:             respParameters['LastWriteTime']  = lastWriteTime",
      "1825:             respParameters  = b''",
      "1826:             respData        = b''",
      "1828:         respSMBCommand['Parameters']             = respParameters",
      "1829:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1834:         respData = b''",
      "1836:         queryInformation = smb.SMBQueryInformation_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "1841:                 connData['ConnectedShares'][recvPacket['Tid']]['path'],",
      "1842:                 decodeSMBString(recvPacket['Flags2'], queryInformation['FileName']), pktFlags=recvPacket['Flags2'])",
      "1844:             respParameters['FileSize'] = fileSize",
      "1845:             respParameters['LastWriteTime'] = lastWriteTime",
      "1851:             respParameters = b''",
      "1852:             respData = b''",
      "1854:         respSMBCommand['Parameters'] = respParameters",
      "1855:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1838:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)",
      "1839:         respParameters = smb.SMBQueryInformationDiskResponse_Parameters()",
      "1842:         # Get the Tid associated",
      "1843:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1844:             totalUnits, freeUnits = queryDiskInformation(",
      "1848:             respParameters['BlocksPerUnit'] = 1",
      "1851:             errorCode = STATUS_SUCCESS",
      "1852:         else:",
      "1853:             # STATUS_SMB_BAD_TID",
      "1855:             respParameters = b''",
      "1856:             errorCode = STATUS_SMB_BAD_TID",
      "1862:         smbServer.setConnectionData(connId, connData)",
      "1863:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1840:         respData       = b''",
      "1845:                         connData['ConnectedShares'][recvPacket['Tid']]['path'])",
      "1847:             respParameters['TotalUnits']    = totalUnits",
      "1849:             respParameters['BlockSize']     = 1",
      "1850:             respParameters['FreeUnits']     = freeUnits",
      "1854:             respData  = b''",
      "1859:         respSMBCommand['Parameters']             = respParameters",
      "1860:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1866:         respData = b''",
      "1871:                 connData['ConnectedShares'][recvPacket['Tid']]['path'])",
      "1873:             respParameters['TotalUnits'] = totalUnits",
      "1875:             respParameters['BlockSize'] = 1",
      "1876:             respParameters['FreeUnits'] = freeUnits",
      "1880:             respData = b''",
      "1884:         respSMBCommand['Parameters'] = respParameters",
      "1885:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 36 ---",
      "[Context before]",
      "1869:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)",
      "1870:         respParameters = smb.SMBEchoResponse_Parameters()",
      "1875:         respParameters['SequenceNumber'] = 1",
      "1881:         errorCode = STATUS_SUCCESS",
      "1882:         smbServer.setConnectionData(connId, connData)",
      "",
      "[Removed Lines]",
      "1871:         respData       = smb.SMBEchoResponse_Data()",
      "1873:         echoData       = smb.SMBEcho_Data(SMBCommand['Data'])",
      "1876:         respData['Data']                 = echoData['Data']",
      "1878:         respSMBCommand['Parameters']     = respParameters",
      "1879:         respSMBCommand['Data']           = respData",
      "",
      "[Added Lines]",
      "1896:         respData = smb.SMBEchoResponse_Data()",
      "1898:         echoData = smb.SMBEcho_Data(SMBCommand['Data'])",
      "1901:         respData['Data'] = echoData['Data']",
      "1903:         respSMBCommand['Parameters'] = respParameters",
      "1904:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 37 ---",
      "[Context before]",
      "1893:         respData = b''",
      "1895:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "1898:             errorCode = STATUS_SUCCESS",
      "1899:         else:",
      "1900:             # STATUS_SMB_BAD_TID",
      "1901:             errorCode = STATUS_SMB_BAD_TID",
      "1903:         respSMBCommand['Parameters'] = respParameters",
      "1906:         smbServer.setConnectionData(connId, connData)",
      "1907:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1896:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (recvPacket['Tid'],connData['ConnectedShares'][recvPacket['Tid']]['shareName']))",
      "1897:             del(connData['ConnectedShares'][recvPacket['Tid']])",
      "1904:         respSMBCommand['Data']       = respData",
      "",
      "[Added Lines]",
      "1921:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (",
      "1922:             recvPacket['Tid'], connData['ConnectedShares'][recvPacket['Tid']]['shareName']))",
      "1923:             del (connData['ConnectedShares'][recvPacket['Tid']])",
      "1930:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 38 ---",
      "[Context before]",
      "1910:     def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):",
      "1911:         connData = smbServer.getConnectionData(connId)",
      "1915:         # Check if the Uid matches the user trying to logoff",
      "1916:         respParameters = b''",
      "",
      "[Removed Lines]",
      "1913:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)",
      "",
      "[Added Lines]",
      "1939:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)",
      "",
      "---------------",
      "--- Hunk 39 ---",
      "[Context before]",
      "1921:         else:",
      "1922:             errorCode = STATUS_SUCCESS",
      "1926:         connData['Uid'] = 0",
      "1927:         connData['Authenticated'] = False",
      "",
      "[Removed Lines]",
      "1924:         respSMBCommand['Parameters']   = respParameters",
      "1925:         respSMBCommand['Data']         = respData",
      "",
      "[Added Lines]",
      "1950:         respSMBCommand['Parameters'] = respParameters",
      "1951:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 40 ---",
      "[Context before]",
      "1934:     def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):",
      "1935:         connData = smbServer.getConnectionData(connId)",
      "1941:         queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])",
      "1942:         errorCode = 0xFF",
      "1943:         if queryInformation2['Fid'] in connData['OpenedFiles']:",
      "1966:         if errorCode > 0:",
      "1967:             respParameters = b''",
      "1972:         smbServer.setConnectionData(connId, connData)",
      "1974:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "1937:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)",
      "1938:         respParameters        = smb.SMBQueryInformation2Response_Parameters()",
      "1939:         respData              = b''",
      "1944:              errorCode = STATUS_SUCCESS",
      "1945:              pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']",
      "1946:              try:",
      "1947:                  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
      "1948:                  respParameters['CreateDate']         = getSMBDate(ctime)",
      "1949:                  respParameters['CreationTime']       = getSMBTime(ctime)",
      "1950:                  respParameters['LastAccessDate']     = getSMBDate(atime)",
      "1951:                  respParameters['LastAccessTime']     = getSMBTime(atime)",
      "1952:                  respParameters['LastWriteDate']      = getSMBDate(mtime)",
      "1953:                  respParameters['LastWriteTime']      = getSMBTime(mtime)",
      "1954:                  respParameters['FileDataSize']       = size",
      "1955:                  respParameters['FileAllocationSize'] = size",
      "1956:                  attribs = 0",
      "1957:                  if os.path.isdir(pathName):",
      "1958:                      attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
      "1959:                  if os.path.isfile(pathName):",
      "1960:                      attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL",
      "1961:                  respParameters['FileAttributes'] = attribs",
      "1962:              except Exception as e:",
      "1963:                  smbServer.log('smbComQueryInformation2 %s' % e,logging.ERROR)",
      "1964:                  errorCode = STATUS_ACCESS_DENIED",
      "1968:             respData       = b''",
      "1970:         respSMBCommand['Parameters']             = respParameters",
      "1971:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "1963:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)",
      "1964:         respParameters = smb.SMBQueryInformation2Response_Parameters()",
      "1965:         respData = b''",
      "1970:             errorCode = STATUS_SUCCESS",
      "1971:             pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']",
      "1972:             try:",
      "1973:                 (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
      "1974:                 respParameters['CreateDate'] = getSMBDate(ctime)",
      "1975:                 respParameters['CreationTime'] = getSMBTime(ctime)",
      "1976:                 respParameters['LastAccessDate'] = getSMBDate(atime)",
      "1977:                 respParameters['LastAccessTime'] = getSMBTime(atime)",
      "1978:                 respParameters['LastWriteDate'] = getSMBDate(mtime)",
      "1979:                 respParameters['LastWriteTime'] = getSMBTime(mtime)",
      "1980:                 respParameters['FileDataSize'] = size",
      "1981:                 respParameters['FileAllocationSize'] = size",
      "1982:                 attribs = 0",
      "1983:                 if os.path.isdir(pathName):",
      "1984:                     attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
      "1985:                 if os.path.isfile(pathName):",
      "1986:                     attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL",
      "1987:                 respParameters['FileAttributes'] = attribs",
      "1988:             except Exception as e:",
      "1989:                 smbServer.log('smbComQueryInformation2 %s' % e, logging.ERROR)",
      "1990:                 errorCode = STATUS_ACCESS_DENIED",
      "1994:             respData = b''",
      "1996:         respSMBCommand['Parameters'] = respParameters",
      "1997:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 41 ---",
      "[Context before]",
      "1978:         # TODO: Fully implement this",
      "1979:         connData = smbServer.getConnectionData(connId)",
      "1985:         ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])",
      "1989:         #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()",
      "1990:         #    respParameters['VolumeGUID'] = '\\x00'",
      "1992:         # Get the Tid associated",
      "1993:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "2010:                 # strip leading '/'",
      "2011:                 fileName = fileName[1:]",
      "2066:                         errorCode = STATUS_FILE_IS_A_DIRECTORY",
      "2074:                             fid = VOID_FILE_DESCRIPTOR",
      "2076:                             if sys.platform == 'win32':",
      "2078:                             if str(pathName) in smbServer.getRegisteredNamedPipes():",
      "2079:                                 fid = PIPE_FILE_DESCRIPTOR",
      "2080:                                 sock = socket.socket()",
      "2081:                                 sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])",
      "2082:                             else:",
      "2083:                                 fid = os.open(pathName, mode)",
      "2089:         else:",
      "2090:             errorCode = STATUS_SMB_BAD_TID",
      "2092:         if errorCode == STATUS_SUCCESS:",
      "2093:             # Simple way to generate a fid",
      "2094:             if len(connData['OpenedFiles']) == 0:",
      "2096:             else:",
      "2098:             respParameters['Fid'] = fakefid",
      "2099:             respParameters['CreateAction'] = createDisposition",
      "2100:             if fid == PIPE_FILE_DESCRIPTOR:",
      "2101:                 respParameters['FileAttributes'] = 0x80",
      "2102:                 respParameters['IsDirectory'] = 0",
      "2104:                 respParameters['LastAccessTime'] = 0",
      "2106:                 respParameters['LastChangeTime'] = 0",
      "2107:                 respParameters['AllocationSize'] = 4096",
      "2111:             else:",
      "2112:                 if os.path.isdir(pathName):",
      "2113:                     respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
      "",
      "[Removed Lines]",
      "1981:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)",
      "1982:         respParameters        = smb.SMBNtCreateAndXResponse_Parameters()",
      "1983:         respData              = b''",
      "1986:         ntCreateAndXData       = smb.SMBNtCreateAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "1988:         #if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE",
      "1994:              # If we have a rootFid, the path is relative to that fid",
      "1995:              errorCode = STATUS_SUCCESS",
      "1996:              if ntCreateAndXParameters['RootFid'] > 0:",
      "1997:                  path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']",
      "1998:                  LOG.debug(\"RootFid present %s!\" % path)",
      "1999:              else:",
      "2000:                  if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:",
      "2001:                      path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "2002:                  else:",
      "2003:                      path = 'NONE'",
      "2004:                      errorCode = STATUS_ACCESS_DENIED",
      "2006:              deleteOnClose = False",
      "2008:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],ntCreateAndXData['FileName']).replace('\\\\','/'))",
      "2009:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "2012:              pathName = os.path.join(path,fileName)",
      "2013:              createDisposition = ntCreateAndXParameters['Disposition']",
      "2014:              mode = 0",
      "2016:              if createDisposition == smb.FILE_SUPERSEDE:",
      "2017:                  mode |= os.O_TRUNC | os.O_CREAT",
      "2018:              elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:",
      "2019:                  mode |= os.O_TRUNC | os.O_CREAT",
      "2020:              elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:",
      "2021:                  if os.path.exists(pathName) is True:",
      "2022:                      mode |= os.O_TRUNC",
      "2023:                  else:",
      "2024:                      errorCode = STATUS_NO_SUCH_FILE",
      "2025:              elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:",
      "2026:                  if os.path.exists(pathName) is True:",
      "2027:                      mode |= os.O_TRUNC",
      "2028:                  else:",
      "2029:                      mode |= os.O_TRUNC | os.O_CREAT",
      "2030:              elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:",
      "2031:                  if os.path.exists(pathName) is True:",
      "2032:                      errorCode = STATUS_OBJECT_NAME_COLLISION",
      "2033:                  else:",
      "2034:                      mode |= os.O_CREAT",
      "2035:              elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:",
      "2036:                  if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
      "2037:                      errorCode = STATUS_NO_SUCH_FILE",
      "2039:              if errorCode == STATUS_SUCCESS:",
      "2040:                  desiredAccess = ntCreateAndXParameters['AccessMask']",
      "2041:                  if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
      "2042:                      mode |= os.O_RDONLY",
      "2043:                  if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):",
      "2044:                      if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
      "2045:                          mode |= os.O_RDWR #| os.O_APPEND",
      "2046:                      else:",
      "2047:                          mode |= os.O_WRONLY #| os.O_APPEND",
      "2048:                  if desiredAccess & smb.GENERIC_ALL:",
      "2049:                      mode |= os.O_RDWR #| os.O_APPEND",
      "2051:                  createOptions =  ntCreateAndXParameters['CreateOptions']",
      "2052:                  if mode & os.O_CREAT == os.O_CREAT:",
      "2053:                      if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:",
      "2054:                          try:",
      "2055:                              # Let's create the directory",
      "2056:                              os.mkdir(pathName)",
      "2057:                              mode = os.O_RDONLY",
      "2058:                          except Exception as e:",
      "2059:                              smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
      "2060:                              errorCode = STATUS_ACCESS_DENIED",
      "2061:                  if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:",
      "2062:                      # If the file being opened is a directory, the server MUST fail the request with",
      "2063:                      # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
      "2064:                      # response.",
      "2065:                      if os.path.isdir(pathName) is True:",
      "2068:                  if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:",
      "2069:                      deleteOnClose = True",
      "2071:                  if errorCode == STATUS_SUCCESS:",
      "2072:                      try:",
      "2073:                          if os.path.isdir(pathName) and sys.platform == 'win32':",
      "2075:                          else:",
      "2077:                                mode |= os.O_BINARY",
      "2084:                      except Exception as e:",
      "2085:                          smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
      "2086:                          #print e",
      "2087:                          fid = 0",
      "2088:                          errorCode = STATUS_ACCESS_DENIED",
      "2095:                fakefid = 1",
      "2097:                fakefid = list(connData['OpenedFiles'].keys())[-1] + 1",
      "2103:                 respParameters['CreateTime']     = 0",
      "2105:                 respParameters['LastWriteTime']  = 0",
      "2108:                 respParameters['EndOfFile']      = 0",
      "2109:                 respParameters['FileType']       = 2",
      "2110:                 respParameters['IPCState']       = 0x5ff",
      "",
      "[Added Lines]",
      "2007:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)",
      "2008:         respParameters = smb.SMBNtCreateAndXResponse_Parameters()",
      "2009:         respData = b''",
      "2012:         ntCreateAndXData = smb.SMBNtCreateAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "2014:         # if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE",
      "2020:             # If we have a rootFid, the path is relative to that fid",
      "2021:             errorCode = STATUS_SUCCESS",
      "2022:             if ntCreateAndXParameters['RootFid'] > 0:",
      "2023:                 path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']",
      "2024:                 LOG.debug(\"RootFid present %s!\" % path)",
      "2025:             else:",
      "2026:                 if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:",
      "2027:                     path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "2028:                 else:",
      "2029:                     path = 'NONE'",
      "2030:                     errorCode = STATUS_ACCESS_DENIED",
      "2032:             deleteOnClose = False",
      "2034:             fileName = os.path.normpath(",
      "2035:                 decodeSMBString(recvPacket['Flags2'], ntCreateAndXData['FileName']).replace('\\\\', '/'))",
      "2036:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "2040:             if not isInFileJail(path, fileName):",
      "2041:                 LOG.error(\"Path not in current working directory\")",
      "2042:                 respSMBCommand['Parameters'] = b''",
      "2043:                 respSMBCommand['Data'] = b''",
      "2044:                 return [respSMBCommand], None, STATUS_OBJECT_PATH_SYNTAX_BAD",
      "2046:             pathName = os.path.join(path, fileName)",
      "2047:             createDisposition = ntCreateAndXParameters['Disposition']",
      "2048:             mode = 0",
      "2050:             if createDisposition == smb.FILE_SUPERSEDE:",
      "2051:                 mode |= os.O_TRUNC | os.O_CREAT",
      "2052:             elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:",
      "2053:                 mode |= os.O_TRUNC | os.O_CREAT",
      "2054:             elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:",
      "2055:                 if os.path.exists(pathName) is True:",
      "2056:                     mode |= os.O_TRUNC",
      "2057:                 else:",
      "2058:                     errorCode = STATUS_NO_SUCH_FILE",
      "2059:             elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:",
      "2060:                 if os.path.exists(pathName) is True:",
      "2061:                     mode |= os.O_TRUNC",
      "2062:                 else:",
      "2063:                     mode |= os.O_TRUNC | os.O_CREAT",
      "2064:             elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:",
      "2065:                 if os.path.exists(pathName) is True:",
      "2066:                     errorCode = STATUS_OBJECT_NAME_COLLISION",
      "2067:                 else:",
      "2068:                     mode |= os.O_CREAT",
      "2069:             elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:",
      "2070:                 if os.path.exists(pathName) is not True and (",
      "2071:                         str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
      "2072:                     errorCode = STATUS_NO_SUCH_FILE",
      "2074:             if errorCode == STATUS_SUCCESS:",
      "2075:                 desiredAccess = ntCreateAndXParameters['AccessMask']",
      "2076:                 if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
      "2077:                     mode |= os.O_RDONLY",
      "2078:                 if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):",
      "2079:                     if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
      "2080:                         mode |= os.O_RDWR  # | os.O_APPEND",
      "2081:                     else:",
      "2082:                         mode |= os.O_WRONLY  # | os.O_APPEND",
      "2083:                 if desiredAccess & smb.GENERIC_ALL:",
      "2084:                     mode |= os.O_RDWR  # | os.O_APPEND",
      "2086:                 createOptions = ntCreateAndXParameters['CreateOptions']",
      "2087:                 if mode & os.O_CREAT == os.O_CREAT:",
      "2088:                     if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:",
      "2089:                         try:",
      "2090:                             # Let's create the directory",
      "2091:                             os.mkdir(pathName)",
      "2092:                             mode = os.O_RDONLY",
      "2093:                         except Exception as e:",
      "2094:                             smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
      "2095:                             errorCode = STATUS_ACCESS_DENIED",
      "2096:                 if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:",
      "2097:                     # If the file being opened is a directory, the server MUST fail the request with",
      "2098:                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
      "2099:                     # response.",
      "2100:                     if os.path.isdir(pathName) is True:",
      "2103:                 if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:",
      "2104:                     deleteOnClose = True",
      "2106:                 if errorCode == STATUS_SUCCESS:",
      "2107:                     try:",
      "2108:                         if os.path.isdir(pathName) and sys.platform == 'win32':",
      "2110:                         else:",
      "2112:                                 mode |= os.O_BINARY",
      "2119:                     except Exception as e:",
      "2120:                         smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
      "2121:                         # print e",
      "2122:                         fid = 0",
      "2123:                         errorCode = STATUS_ACCESS_DENIED",
      "2130:                 fakefid = 1",
      "2132:                 fakefid = list(connData['OpenedFiles'].keys())[-1] + 1",
      "2138:                 respParameters['CreateTime'] = 0",
      "2140:                 respParameters['LastWriteTime'] = 0",
      "2143:                 respParameters['EndOfFile'] = 0",
      "2144:                 respParameters['FileType'] = 2",
      "2145:                 respParameters['IPCState'] = 0x5ff",
      "",
      "---------------",
      "--- Hunk 42 ---",
      "[Context before]",
      "2116:                     respParameters['IsDirectory'] = 0",
      "2117:                     respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']",
      "2118:                 # Let's get this file's information",
      "2120:                 if errorCode == STATUS_SUCCESS:",
      "2122:                     respParameters['LastAccessTime'] = respInfo['LastAccessTime']",
      "2124:                     respParameters['LastChangeTime'] = respInfo['LastChangeTime']",
      "2125:                     respParameters['FileAttributes'] = respInfo['ExtFileAttributes']",
      "2126:                     respParameters['AllocationSize'] = respInfo['AllocationSize']",
      "2128:                 else:",
      "2129:                     respParameters = b''",
      "2132:             if errorCode == STATUS_SUCCESS:",
      "2133:                 # Let's store the fid for the connection",
      "",
      "[Removed Lines]",
      "2119:                 respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)",
      "2121:                     respParameters['CreateTime']     = respInfo['CreationTime']",
      "2123:                     respParameters['LastWriteTime']  = respInfo['LastWriteTime']",
      "2127:                     respParameters['EndOfFile']      = respInfo['EndOfFile']",
      "2130:                     respData       = b''",
      "",
      "[Added Lines]",
      "2154:                 respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)",
      "2156:                     respParameters['CreateTime'] = respInfo['CreationTime']",
      "2158:                     respParameters['LastWriteTime'] = respInfo['LastWriteTime']",
      "2162:                     respParameters['EndOfFile'] = respInfo['EndOfFile']",
      "2165:                     respData = b''",
      "",
      "---------------",
      "--- Hunk 43 ---",
      "[Context before]",
      "2135:                 connData['OpenedFiles'][fakefid] = {}",
      "2136:                 connData['OpenedFiles'][fakefid]['FileHandle'] = fid",
      "2137:                 connData['OpenedFiles'][fakefid]['FileName'] = pathName",
      "2139:                 if fid == PIPE_FILE_DESCRIPTOR:",
      "2140:                     connData['OpenedFiles'][fakefid]['Socket'] = sock",
      "2141:         else:",
      "2142:             respParameters = b''",
      "2147:         smbServer.setConnectionData(connId, connData)",
      "2149:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "2138:                 connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose",
      "2143:             respData       = b''",
      "2145:         respSMBCommand['Parameters']             = respParameters",
      "2146:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "2173:                 connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose",
      "2178:             respData = b''",
      "2180:         respSMBCommand['Parameters'] = respParameters",
      "2181:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 44 ---",
      "[Context before]",
      "2152:     def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):",
      "2153:         connData = smbServer.getConnectionData(connId)",
      "2159:         openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])",
      "2162:         # Get the Tid associated",
      "2163:         if recvPacket['Tid'] in connData['ConnectedShares']:",
      "2170:         else:",
      "2173:         if errorCode == STATUS_SUCCESS:",
      "2174:             # Simple way to generate a fid",
      "2176:             if len(connData['OpenedFiles']) == 0:",
      "2178:             else:",
      "2180:             respParameters['Fid'] = fid",
      "2181:             if mode & os.O_CREAT:",
      "2182:                 # File did not exist and was created",
      "",
      "[Removed Lines]",
      "2155:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)",
      "2156:         respParameters        = smb.SMBOpenAndXResponse_Parameters()",
      "2157:         respData              = b''",
      "2160:         openAndXData       = smb.SMBOpenAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
      "2164:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "2165:              openedFile, mode, pathName, errorCode = openFile(path,",
      "2166:                      decodeSMBString(recvPacket['Flags2'],openAndXData['FileName']),",
      "2167:                      openAndXParameters['DesiredAccess'],",
      "2168:                      openAndXParameters['FileAttributes'],",
      "2169:                      openAndXParameters['OpenMode'])",
      "2171:            errorCode = STATUS_SMB_BAD_TID",
      "2175:             fid = len(connData['OpenedFiles']) + 1",
      "2177:                fid = 1",
      "2179:                fid = list(connData['OpenedFiles'].keys())[-1] + 1",
      "",
      "[Added Lines]",
      "2190:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)",
      "2191:         respParameters = smb.SMBOpenAndXResponse_Parameters()",
      "2192:         respData = b''",
      "2195:         openAndXData = smb.SMBOpenAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
      "2199:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
      "2200:             openedFile, mode, pathName, errorCode = openFile(path,",
      "2201:                                                              decodeSMBString(recvPacket['Flags2'],",
      "2202:                                                                              openAndXData['FileName']),",
      "2203:                                                              openAndXParameters['DesiredAccess'],",
      "2204:                                                              openAndXParameters['FileAttributes'],",
      "2205:                                                              openAndXParameters['OpenMode'])",
      "2207:             errorCode = STATUS_SMB_BAD_TID",
      "2211:             fid = len(connData['OpenedFiles']) + 1",
      "2213:                 fid = 1",
      "2215:                 fid = list(connData['OpenedFiles'].keys())[-1] + 1",
      "",
      "---------------",
      "--- Hunk 45 ---",
      "[Context before]",
      "2190:             else:",
      "2191:                 # File existed and was truncated",
      "2192:                 respParameters['Action'] = 0x3",
      "2194:             # Let's store the fid for the connection",
      "2196:             connData['OpenedFiles'][fid] = {}",
      "2197:             connData['OpenedFiles'][fid]['FileHandle'] = openedFile",
      "2198:             connData['OpenedFiles'][fid]['FileName'] = pathName",
      "2200:         else:",
      "2201:             respParameters = b''",
      "2206:         smbServer.setConnectionData(connId, connData)",
      "2208:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "2195:             #smbServer.log('Opening file %s' % pathName)",
      "2199:             connData['OpenedFiles'][fid]['DeleteOnClose']  = False",
      "2202:             respData       = b''",
      "2204:         respSMBCommand['Parameters']             = respParameters",
      "2205:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "2231:             # smbServer.log('Opening file %s' % pathName)",
      "2235:             connData['OpenedFiles'][fid]['DeleteOnClose'] = False",
      "2238:             respData = b''",
      "2240:         respSMBCommand['Parameters'] = respParameters",
      "2241:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 46 ---",
      "[Context before]",
      "2214:         resp = smb.NewSMBPacket()",
      "2215:         resp['Flags1'] = smb.SMB.FLAGS1_REPLY",
      "2218:         resp['Tid'] = recvPacket['Tid']",
      "2219:         resp['Mid'] = recvPacket['Mid']",
      "2220:         resp['Pid'] = connData['Pid']",
      "2226:         treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])",
      "2228:         if treeConnectAndXParameters['Flags'] & 0x8:",
      "2232:         treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']",
      "2233:         treeConnectAndXData.fromString(SMBCommand['Data'])",
      "",
      "[Removed Lines]",
      "2216:         resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE",
      "2222:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)",
      "2223:         respParameters        = smb.SMBTreeConnectAndXResponse_Parameters()",
      "2224:         respData              = smb.SMBTreeConnectAndXResponse_Data()",
      "2229:             respParameters        = smb.SMBTreeConnectAndXExtendedResponse_Parameters()",
      "2231:         treeConnectAndXData                    = smb.SMBTreeConnectAndX_Data( flags = recvPacket['Flags2'] )",
      "",
      "[Added Lines]",
      "2252:         resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\",
      "2253:                          recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE",
      "2259:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)",
      "2260:         respParameters = smb.SMBTreeConnectAndXResponse_Parameters()",
      "2261:         respData = smb.SMBTreeConnectAndXResponse_Data()",
      "2266:             respParameters = smb.SMBTreeConnectAndXExtendedResponse_Parameters()",
      "2268:         treeConnectAndXData = smb.SMBTreeConnectAndX_Data(flags=recvPacket['Flags2'])",
      "",
      "---------------",
      "--- Hunk 47 ---",
      "[Context before]",
      "2243:         else:",
      "2244:             path = ntpath.basename(UNCOrShare)",
      "2247:         if share is not None:",
      "2248:             # Simple way to generate a Tid",
      "2249:             if len(connData['ConnectedShares']) == 0:",
      "2251:             else:",
      "2253:             connData['ConnectedShares'][tid] = share",
      "2254:             connData['ConnectedShares'][tid]['shareName'] = path",
      "2255:             resp['Tid'] = tid",
      "2257:         else:",
      "2258:             smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)",
      "2259:             errorCode = STATUS_OBJECT_PATH_NOT_FOUND",
      "2262:         ##",
      "2263:         respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS",
      "2265:         if path == 'IPC$':",
      "2267:         else:",
      "2275:         resp['Uid'] = connData['Uid']",
      "2276:         resp.addCommand(respSMBCommand)",
      "",
      "[Removed Lines]",
      "2246:         share = searchShare(connId, path, smbServer)",
      "2250:                tid = 1",
      "2252:                tid = list(connData['ConnectedShares'].keys())[-1] + 1",
      "2256:             #smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
      "2260:             resp['ErrorCode']   = errorCode >> 16",
      "2261:             resp['ErrorClass']  = errorCode & 0xff",
      "2266:             respData['Service']               = 'IPC'",
      "2268:             respData['Service']               = path",
      "2269:         respData['PadLen']                = 0",
      "2270:         respData['NativeFileSystem']      = encodeSMBString(recvPacket['Flags2'], 'NTFS' ).decode()",
      "2272:         respSMBCommand['Parameters']             = respParameters",
      "2273:         respSMBCommand['Data']                   = respData",
      "",
      "[Added Lines]",
      "2283:         share = searchShare(connId, path, smbServer)",
      "2287:                 tid = 1",
      "2289:                 tid = list(connData['ConnectedShares'].keys())[-1] + 1",
      "2293:             # smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
      "2297:             resp['ErrorCode'] = errorCode >> 16",
      "2298:             resp['ErrorClass'] = errorCode & 0xff",
      "2303:             respData['Service'] = 'IPC'",
      "2305:             respData['Service'] = path",
      "2306:         respData['PadLen'] = 0",
      "2307:         respData['NativeFileSystem'] = encodeSMBString(recvPacket['Flags2'], 'NTFS').decode()",
      "2309:         respSMBCommand['Parameters'] = respParameters",
      "2310:         respSMBCommand['Data'] = respData",
      "",
      "---------------",
      "--- Hunk 48 ---",
      "[Context before]",
      "2285:     @staticmethod",
      "2286:     def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):",
      "2289:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)",
      "2291:         # From [MS-SMB]",
      "2293:         # request MUST take the following form",
      "2294:         # [..]",
      "2295:         # WordCount (1 byte): The value of this field MUST be 0x0C.",
      "2296:         if SMBCommand['WordCount'] == 12:",
      "2297:             # Extended security. Here we deal with all SPNEGO stuff",
      "2298:             respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()",
      "2300:             sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])",
      "2301:             sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()",
      "2302:             sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']",
      "",
      "[Removed Lines]",
      "2287:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
      "2292:         # When extended security is being used (see section 3.2.4.2.4), the",
      "2299:             respData       = smb.SMBSessionSetupAndX_Extended_Response_Data(flags = recvPacket['Flags2'])",
      "",
      "[Added Lines]",
      "2324:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
      "2329:         # When extended security is being used (see section 3.2.4.2.4), the",
      "2336:             respData = smb.SMBSessionSetupAndX_Extended_Response_Data(flags=recvPacket['Flags2'])",
      "",
      "---------------",
      "--- Hunk 49 ---",
      "[Context before]",
      "2304:             connData['Capabilities'] = sessionSetupParameters['Capabilities']",
      "2306:             rawNTLM = False",
      "2338:             else:",
      "2344:             # authentication we are, we act on it",
      "2347:             if messageType == 0x01:",
      "2348:                 # NEGOTIATE_MESSAGE",
      "",
      "[Removed Lines]",
      "2307:             if struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:",
      "2308:                # NEGOTIATE packet",
      "2309:                blob =  SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])",
      "2310:                token = blob['MechToken']",
      "2311:                if len(blob['MechTypes'][0]) > 0:",
      "2312:                    # Is this GSSAPI NTLM or something else we don't support?",
      "2313:                    mechType = blob['MechTypes'][0]",
      "2314:                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
      "2315:                        # Nope, do we know it?",
      "2316:                        if mechType in MechTypes:",
      "2317:                            mechStr = MechTypes[mechType]",
      "2318:                        else:",
      "2319:                            mechStr = hexlify(mechType)",
      "2320:                        smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
      "2321:                        # We don't know the token, we answer back again saying",
      "2322:                        # we just support NTLM.",
      "2323:                        # ToDo: Build this into a SPNEGO_NegTokenResp()",
      "2324:                        respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
      "2325:                        respParameters['SecurityBlobLength'] = len(respToken)",
      "2326:                        respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
      "2327:                        respData['SecurityBlob']       = respToken",
      "2328:                        respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2329:                        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2330:                        respSMBCommand['Parameters'] = respParameters",
      "2331:                        respSMBCommand['Data']       = respData",
      "2332:                        return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
      "2334:             elif struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:",
      "2335:                # AUTH packet",
      "2336:                blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])",
      "2337:                token = blob['ResponseToken']",
      "2339:                # No GSSAPI stuff, raw NTLMSSP",
      "2340:                rawNTLM = True",
      "2341:                token = sessionSetupData['SecurityBlob']",
      "2343:             # Here we only handle NTLMSSP, depending on what stage of the",
      "2345:             messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]",
      "",
      "[Added Lines]",
      "2344:             if struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:",
      "2345:                 # NEGOTIATE packet",
      "2346:                 blob = SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])",
      "2347:                 token = blob['MechToken']",
      "2348:                 if len(blob['MechTypes'][0]) > 0:",
      "2349:                     # Is this GSSAPI NTLM or something else we don't support?",
      "2350:                     mechType = blob['MechTypes'][0]",
      "2351:                     if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
      "2352:                         # Nope, do we know it?",
      "2353:                         if mechType in MechTypes:",
      "2354:                             mechStr = MechTypes[mechType]",
      "2355:                         else:",
      "2356:                             mechStr = hexlify(mechType)",
      "2357:                         smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
      "2358:                         # We don't know the token, we answer back again saying",
      "2359:                         # we just support NTLM.",
      "2360:                         # ToDo: Build this into a SPNEGO_NegTokenResp()",
      "2361:                         respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
      "2362:                         respParameters['SecurityBlobLength'] = len(respToken)",
      "2363:                         respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
      "2364:                         respData['SecurityBlob'] = respToken",
      "2365:                         respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2366:                         respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2367:                         respSMBCommand['Parameters'] = respParameters",
      "2368:                         respSMBCommand['Data'] = respData",
      "2369:                         return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
      "2371:             elif struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:",
      "2372:                 # AUTH packet",
      "2373:                 blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])",
      "2374:                 token = blob['ResponseToken']",
      "2376:                 # No GSSAPI stuff, raw NTLMSSP",
      "2377:                 rawNTLM = True",
      "2378:                 token = sessionSetupData['SecurityBlob']",
      "2380:             # Here we only handle NTLMSSP, depending on what stage of the",
      "2382:             messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]",
      "",
      "---------------",
      "--- Hunk 50 ---",
      "[Context before]",
      "2351:                 # Let's store it in the connection data",
      "2352:                 connData['NEGOTIATE_MESSAGE'] = negotiateMessage",
      "2353:                 # Let's build the answer flags",
      "2356:                 ansFlags = 0",
      "2358:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:",
      "2360:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:",
      "2362:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
      "2364:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:",
      "2366:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:",
      "2368:                 if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:",
      "2371:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET",
      "2373:                 # Generate the AV_PAIRS",
      "2374:                 av_pairs = ntlm.AV_PAIRS()",
      "2375:                 # TODO: Put the proper data from SMBSERVER config",
      "2380:                 challengeMessage = ntlm.NTLMAuthChallenge()",
      "2388:                 challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)",
      "2389:                 challengeMessage['TargetInfoFields'] = av_pairs",
      "2394:                 if rawNTLM is False:",
      "2395:                     respToken = SPNEGO_NegTokenResp()",
      "",
      "[Removed Lines]",
      "2354:                 # TODO: Parse all the flags. With this we're leaving some clients out",
      "2359:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
      "2361:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
      "2363:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
      "2365:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
      "2367:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
      "2369:                    ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
      "2376:                 av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
      "2377:                 av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
      "2378:                 av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )",
      "2381:                 challengeMessage['flags']            = ansFlags",
      "2382:                 challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))",
      "2383:                 challengeMessage['domain_max_len']   = challengeMessage['domain_len']",
      "2384:                 challengeMessage['domain_offset']    = 40 + 16",
      "2385:                 challengeMessage['challenge']        = smbServer.getSMBChallenge()",
      "2386:                 challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')",
      "2387:                 challengeMessage['TargetInfoFields_len']     = len(av_pairs)",
      "2390:                 challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])",
      "2391:                 challengeMessage['Version']          = b'\\xff'*8",
      "2392:                 challengeMessage['VersionLen']       = 8",
      "",
      "[Added Lines]",
      "2391:                 # TODO: Parse all the flags. With this we're leaving some clients out",
      "2396:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
      "2398:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
      "2400:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
      "2402:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
      "2404:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
      "2406:                     ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
      "2413:                 av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[",
      "2414:                     ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
      "2415:                 av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[",
      "2416:                     ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
      "2417:                 av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (",
      "2418:                             116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))",
      "2421:                 challengeMessage['flags'] = ansFlags",
      "2422:                 challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))",
      "2423:                 challengeMessage['domain_max_len'] = challengeMessage['domain_len']",
      "2424:                 challengeMessage['domain_offset'] = 40 + 16",
      "2425:                 challengeMessage['challenge'] = smbServer.getSMBChallenge()",
      "2426:                 challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')",
      "2427:                 challengeMessage['TargetInfoFields_len'] = len(av_pairs)",
      "2430:                 challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])",
      "2431:                 challengeMessage['Version'] = b'\\xff' * 8",
      "2432:                 challengeMessage['VersionLen'] = 8",
      "",
      "---------------",
      "--- Hunk 51 ---",
      "[Context before]",
      "2404:                 # Setting the packet to STATUS_MORE_PROCESSING",
      "2405:                 errorCode = STATUS_MORE_PROCESSING_REQUIRED",
      "2407:                 # in the connection's data",
      "2408:                 # Picking a fixed value",
      "2409:                 # TODO: Manage more UIDs for the same session",
      "",
      "[Removed Lines]",
      "2406:                 # Let's set up an UID for this connection and store it",
      "",
      "[Added Lines]",
      "2446:                 # Let's set up an UID for this connection and store it",
      "",
      "---------------",
      "--- Hunk 52 ---",
      "[Context before]",
      "2419:                 authenticateMessage = ntlm.NTLMAuthChallengeResponse()",
      "2420:                 authenticateMessage.fromString(token)",
      "2421:                 smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (",
      "2425:                 # Do we have credentials to check?",
      "2426:                 if len(smbServer.getCredentials()) > 0:",
      "2427:                     identity = authenticateMessage['user_name'].decode('utf-16le').lower()",
      "",
      "[Removed Lines]",
      "2422:                 authenticateMessage['domain_name'].decode('utf-16le'),",
      "2423:                 authenticateMessage['user_name'].decode('utf-16le'),",
      "2424:                 authenticateMessage['host_name'].decode('utf-16le')))",
      "",
      "[Added Lines]",
      "2462:                     authenticateMessage['domain_name'].decode('utf-16le'),",
      "2463:                     authenticateMessage['user_name'].decode('utf-16le'),",
      "2464:                     authenticateMessage['host_name'].decode('utf-16le')))",
      "",
      "---------------",
      "--- Hunk 53 ---",
      "[Context before]",
      "2432:                         uid, lmhash, nthash = smbServer.getCredentials()[identity]",
      "2434:                         errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),",
      "2437:                         if sessionKey is not None:",
      "2438:                             connData['SignatureEnabled'] = False",
      "",
      "[Removed Lines]",
      "2435:                                              authenticateMessage, connData['CHALLENGE_MESSAGE'], connData['NEGOTIATE_MESSAGE'])",
      "",
      "[Added Lines]",
      "2475:                                                               authenticateMessage, connData['CHALLENGE_MESSAGE'],",
      "2476:                                                               connData['NEGOTIATE_MESSAGE'])",
      "",
      "---------------",
      "--- Hunk 54 ---",
      "[Context before]",
      "2450:                     # accept-completed",
      "2451:                     respToken['NegState'] = b'\\x00'",
      "2455:                     # Let's store it in the connection data",
      "2456:                     connData['AUTHENTICATE_MESSAGE'] = authenticateMessage",
      "2457:                     try:",
      "",
      "[Removed Lines]",
      "2453:                     smbServer.log('User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),",
      "2454:                                                                               authenticateMessage['user_name'].decode('utf-16le')))",
      "",
      "[Added Lines]",
      "2494:                     smbServer.log(",
      "2495:                         'User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),",
      "2496:                                                                     authenticateMessage['user_name'].decode(",
      "2497:                                                                         'utf-16le')))",
      "",
      "---------------",
      "--- Hunk 55 ---",
      "[Context before]",
      "2462:                                                             authenticateMessage['lanman'], authenticateMessage['ntlm'])",
      "2463:                         smbServer.log(ntlm_hash_data['hash_string'])",
      "2464:                         if jtr_dump_path != '':",
      "2466:                     except:",
      "2467:                         smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)",
      "2468:                 else:",
      "",
      "[Removed Lines]",
      "2465:                             writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)",
      "",
      "[Added Lines]",
      "2508:                             writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],",
      "2509:                                                   jtr_dump_path)",
      "",
      "---------------",
      "--- Hunk 56 ---",
      "[Context before]",
      "2473:                 raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)",
      "2475:             respParameters['SecurityBlobLength'] = len(respToken)",
      "2479:         else:",
      "2480:             # Process Standard Security",
      "2481:             respParameters = smb.SMBSessionSetupAndXResponse_Parameters()",
      "2483:             sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])",
      "2484:             sessionSetupData = smb.SMBSessionSetupAndX_Data()",
      "2485:             sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']",
      "",
      "[Removed Lines]",
      "2476:             respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
      "2477:             respData['SecurityBlob']       = respToken.getData()",
      "2482:             respData       = smb.SMBSessionSetupAndXResponse_Data()",
      "",
      "[Added Lines]",
      "2520:             respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
      "2521:             respData['SecurityBlob'] = respToken.getData()",
      "2526:             respData = smb.SMBSessionSetupAndXResponse_Data()",
      "",
      "---------------",
      "--- Hunk 57 ---",
      "[Context before]",
      "2492:             connData['Uid'] = 10",
      "2493:             connData['Authenticated'] = True",
      "2494:             respParameters['Action'] = 0",
      "2496:             try:",
      "2497:                 jtr_dump_path = smbServer.getJTRdumpPath()",
      "2499:                 smbServer.log(ntlm_hash_data['hash_string'])",
      "2500:                 if jtr_dump_path != '':",
      "2501:                     writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)",
      "2502:             except:",
      "2503:                 smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)",
      "2506:         respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2507:         respSMBCommand['Parameters'] = respParameters",
      "2510:         # From now on, the client can ask for other commands",
      "2511:         connData['Authenticated'] = True",
      "2512:         # For now, just switching to nobody",
      "2515:         smbServer.setConnectionData(connId, connData)",
      "2517:         return [respSMBCommand], None, errorCode",
      "2519:     @staticmethod",
      "2522:         connData['Pid'] = recvPacket['Pid']",
      "2524:         SMBCommand = smb.SMBCommand(recvPacket['Data'][0])",
      "2525:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)",
      "2527:         resp = smb.NewSMBPacket()",
      "2528:         resp['Flags1'] = smb.SMB.FLAGS1_REPLY",
      "2529:         resp['Pid'] = connData['Pid']",
      "",
      "[Removed Lines]",
      "2495:             smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))",
      "2498:                 ntlm_hash_data = outputToJohnFormat( b'', b(sessionSetupData['Account']), b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'], sessionSetupData['UnicodePwd'] )",
      "2505:         respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2508:         respSMBCommand['Data']       = respData",
      "2513:         #os.setregid(65534,65534)",
      "2514:         #os.setreuid(65534,65534)",
      "2520:     def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket ):",
      "2521:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
      "",
      "[Added Lines]",
      "2539:             smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (",
      "2540:             sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))",
      "2543:                 ntlm_hash_data = outputToJohnFormat(b'', b(sessionSetupData['Account']),",
      "2544:                                                     b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'],",
      "2545:                                                     sessionSetupData['UnicodePwd'])",
      "2552:         respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
      "2555:         respSMBCommand['Data'] = respData",
      "2560:         # os.setregid(65534,65534)",
      "2561:         # os.setreuid(65534,65534)",
      "2567:     def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket):",
      "2568:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
      "",
      "---------------",
      "--- Hunk 58 ---",
      "[Context before]",
      "2533:         # TODO: We support more dialects, and parse them accordingly",
      "2534:         dialects = SMBCommand['Data'].split(b'\\x02')",
      "2589:         except Exception as e:",
      "2595:         smbServer.setConnectionData(connId, connData)",
      "2597:         resp.addCommand(respSMBCommand)",
      "2599:         return None, [resp], STATUS_SUCCESS",
      "2601:     @staticmethod",
      "2602:     def default(connId, smbServer, SMBCommand, recvPacket):",
      "2603:         # By default we return an SMB Packet with error not implemented",
      "2605:         packet = smb.NewSMBPacket()",
      "2608:         packet['Command'] = recvPacket['Command']",
      "2614:         errorCode = STATUS_NOT_IMPLEMENTED",
      "2618:         return None, [packet], errorCode",
      "2620: class SMB2Commands:",
      "2621:     @staticmethod",
      "2625:         respPacket = smb2.SMB2Packet()",
      "2628:         respPacket['CreditRequestResponse'] = 1",
      "2630:         respPacket['SessionID'] = 0",
      "2631:         if isSMB1 is False:",
      "2632:             respPacket['MessageID'] = recvPacket['MessageID']",
      "2633:         else:",
      "2634:             respPacket['MessageID'] = 0",
      "2638:         respSMBCommand = smb2.SMB2Negotiate_Response()",
      "",
      "[Removed Lines]",
      "2535:         try:",
      "2536:            index = dialects.index(b'NT LM 0.12\\x00') - 1",
      "2537:            # Let's fill the data for NTLM",
      "2538:            if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:",
      "2539:                     resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
      "2540:                     #resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS",
      "2541:                     _dialects_data = smb.SMBExtended_Security_Data()",
      "2542:                     _dialects_data['ServerGUID'] = b'A'*16",
      "2543:                     blob = SPNEGO_NegTokenInit()",
      "2544:                     blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]",
      "2545:                     _dialects_data['SecurityBlob'] = blob.getData()",
      "2547:                     _dialects_parameters = smb.SMBExtended_Security_Parameters()",
      "2548:                     _dialects_parameters['Capabilities']    = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE",
      "2549:                     _dialects_parameters['ChallengeLength'] = 0",
      "2551:            else:",
      "2552:                     resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
      "2553:                     _dialects_parameters = smb.SMBNTLMDialect_Parameters()",
      "2554:                     _dialects_data= smb.SMBNTLMDialect_Data()",
      "2555:                     _dialects_data['Payload'] = ''",
      "2556:                     if 'EncryptionKey' in connData:",
      "2557:                         _dialects_data['Challenge'] = connData['EncryptionKey']",
      "2558:                         _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())",
      "2559:                     else:",
      "2560:                         # TODO: Handle random challenges, now one that can be used with rainbow tables",
      "2561:                         _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'",
      "2562:                         _dialects_parameters['ChallengeLength'] = 8",
      "2563:                     _dialects_parameters['Capabilities']    = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS",
      "2565:            # Let's see if we need to support RPC_REMOTE_APIS",
      "2566:            config = smbServer.getServerConfig()",
      "2567:            if config.has_option('global','rpc_apis'):",
      "2568:                if config.getboolean('global', 'rpc_apis') is True:",
      "2569:                   _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS",
      "2571:            _dialects_parameters['DialectIndex']    = index",
      "2572:            #_dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED",
      "2573:            _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER",
      "2574:            _dialects_parameters['MaxMpxCount']     = 1",
      "2575:            _dialects_parameters['MaxNumberVcs']    = 1",
      "2576:            _dialects_parameters['MaxBufferSize']   = 64000",
      "2577:            _dialects_parameters['MaxRawSize']      = 65536",
      "2578:            _dialects_parameters['SessionKey']      = 0",
      "2579:            _dialects_parameters['LowDateTime']     = 0",
      "2580:            _dialects_parameters['HighDateTime']    = 0",
      "2581:            _dialects_parameters['ServerTimeZone']  = 0",
      "2584:            respSMBCommand['Data']           = _dialects_data",
      "2585:            respSMBCommand['Parameters']     = _dialects_parameters",
      "2586:            connData['_dialects_data']       = _dialects_data",
      "2587:            connData['_dialects_parameters'] = _dialects_parameters",
      "2590:            # No NTLM throw an error",
      "2591:            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)",
      "2592:            respSMBCommand['Data'] = struct.pack('<H',0xffff)",
      "2604:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)",
      "2606:         packet['Flags1']  = smb.SMB.FLAGS1_REPLY",
      "2607:         packet['Flags2']  = smb.SMB.FLAGS2_NT_STATUS",
      "2609:         packet['Pid']     = recvPacket['Pid']",
      "2610:         packet['Tid']     = recvPacket['Tid']",
      "2611:         packet['Mid']     = recvPacket['Mid']",
      "2612:         packet['Uid']     = recvPacket['Uid']",
      "2613:         packet['Data']    = b'\\x00\\x00\\x00'",
      "2615:         packet['ErrorCode']   = errorCode >> 16",
      "2616:         packet['ErrorClass']  = errorCode & 0xff",
      "2622:     def smb2Negotiate(connId, smbServer, recvPacket, isSMB1 = False):",
      "2623:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
      "2626:         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "2627:         respPacket['Status']    = STATUS_SUCCESS",
      "2629:         respPacket['Command']   = smb2.SMB2_NEGOTIATE",
      "2635:         respPacket['TreeID']    = 0",
      "",
      "[Added Lines]",
      "2582:         try:",
      "2583:             index = dialects.index(b'NT LM 0.12\\x00') - 1",
      "2584:             # Let's fill the data for NTLM",
      "2585:             if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:",
      "2586:                 resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
      "2587:                 # resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS",
      "2588:                 _dialects_data = smb.SMBExtended_Security_Data()",
      "2589:                 _dialects_data['ServerGUID'] = b'A' * 16",
      "2590:                 blob = SPNEGO_NegTokenInit()",
      "2591:                 blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]",
      "2592:                 _dialects_data['SecurityBlob'] = blob.getData()",
      "2594:                 _dialects_parameters = smb.SMBExtended_Security_Parameters()",
      "2595:                 _dialects_parameters[",
      "2596:                     'Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE",
      "2597:                 _dialects_parameters['ChallengeLength'] = 0",
      "2599:             else:",
      "2600:                 resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
      "2601:                 _dialects_parameters = smb.SMBNTLMDialect_Parameters()",
      "2602:                 _dialects_data = smb.SMBNTLMDialect_Data()",
      "2603:                 _dialects_data['Payload'] = ''",
      "2604:                 if 'EncryptionKey' in connData:",
      "2605:                     _dialects_data['Challenge'] = connData['EncryptionKey']",
      "2606:                     _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())",
      "2607:                 else:",
      "2608:                     # TODO: Handle random challenges, now one that can be used with rainbow tables",
      "2609:                     _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'",
      "2610:                     _dialects_parameters['ChallengeLength'] = 8",
      "2611:                 _dialects_parameters['Capabilities'] = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS",
      "2613:                 # Let's see if we need to support RPC_REMOTE_APIS",
      "2614:             config = smbServer.getServerConfig()",
      "2615:             if config.has_option('global', 'rpc_apis'):",
      "2616:                 if config.getboolean('global', 'rpc_apis') is True:",
      "2617:                     _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS",
      "2619:             _dialects_parameters['DialectIndex'] = index",
      "2620:             # _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED",
      "2621:             _dialects_parameters['SecurityMode'] = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER",
      "2622:             _dialects_parameters['MaxMpxCount'] = 1",
      "2623:             _dialects_parameters['MaxNumberVcs'] = 1",
      "2624:             _dialects_parameters['MaxBufferSize'] = 64000",
      "2625:             _dialects_parameters['MaxRawSize'] = 65536",
      "2626:             _dialects_parameters['SessionKey'] = 0",
      "2627:             _dialects_parameters['LowDateTime'] = 0",
      "2628:             _dialects_parameters['HighDateTime'] = 0",
      "2629:             _dialects_parameters['ServerTimeZone'] = 0",
      "2631:             respSMBCommand['Data'] = _dialects_data",
      "2632:             respSMBCommand['Parameters'] = _dialects_parameters",
      "2633:             connData['_dialects_data'] = _dialects_data",
      "2634:             connData['_dialects_parameters'] = _dialects_parameters",
      "2637:             # No NTLM throw an error",
      "2638:             smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)",
      "2639:             respSMBCommand['Data'] = struct.pack('<H', 0xffff)",
      "2650:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)",
      "2652:         packet['Flags1'] = smb.SMB.FLAGS1_REPLY",
      "2653:         packet['Flags2'] = smb.SMB.FLAGS2_NT_STATUS",
      "2655:         packet['Pid'] = recvPacket['Pid']",
      "2656:         packet['Tid'] = recvPacket['Tid']",
      "2657:         packet['Mid'] = recvPacket['Mid']",
      "2658:         packet['Uid'] = recvPacket['Uid']",
      "2659:         packet['Data'] = b'\\x00\\x00\\x00'",
      "2661:         packet['ErrorCode'] = errorCode >> 16",
      "2662:         packet['ErrorClass'] = errorCode & 0xff",
      "2669:     def smb2Negotiate(connId, smbServer, recvPacket, isSMB1=False):",
      "2670:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
      "2673:         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "2674:         respPacket['Status'] = STATUS_SUCCESS",
      "2676:         respPacket['Command'] = smb2.SMB2_NEGOTIATE",
      "2682:         respPacket['TreeID'] = 0",
      "",
      "---------------",
      "--- Hunk 59 ---",
      "[Context before]",
      "2650:                 raise Exception('SMB2 not supported, fallbacking')",
      "2651:         else:",
      "2652:             respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002",
      "2654:         respSMBCommand['Capabilities'] = 0",
      "2655:         respSMBCommand['MaxTransactSize'] = 65536",
      "2656:         respSMBCommand['MaxReadSize'] = 65536",
      "",
      "[Removed Lines]",
      "2653:         respSMBCommand['ServerGuid'] = b'A'*16",
      "",
      "[Added Lines]",
      "2699:         respSMBCommand['ServerGuid'] = b'A' * 16",
      "",
      "---------------",
      "--- Hunk 60 ---",
      "[Context before]",
      "2665:         respSMBCommand['Buffer'] = blob.getData()",
      "2666:         respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])",
      "2670:         smbServer.setConnectionData(connId, connData)",
      "",
      "[Removed Lines]",
      "2668:         respPacket['Data']      = respSMBCommand",
      "",
      "[Added Lines]",
      "2714:         respPacket['Data'] = respSMBCommand",
      "",
      "---------------",
      "--- Hunk 61 ---",
      "[Context before]",
      "2674:     @staticmethod",
      "2675:     def smb2SessionSetup(connId, smbServer, recvPacket):",
      "2678:         respSMBCommand = smb2.SMB2SessionSetup_Response()",
      "",
      "[Removed Lines]",
      "2676:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
      "",
      "[Added Lines]",
      "2722:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
      "",
      "---------------",
      "--- Hunk 62 ---",
      "[Context before]",
      "2684:         securityBlob = sessionSetupData['Buffer']",
      "2686:         rawNTLM = False",
      "2714:         else:",
      "2720:         # authentication we are, we act on it",
      "2723:         if messageType == 0x01:",
      "2724:             # NEGOTIATE_MESSAGE",
      "",
      "[Removed Lines]",
      "2687:         if struct.unpack('B',securityBlob[0:1])[0] == ASN1_AID:",
      "2688:            # NEGOTIATE packet",
      "2689:            blob =  SPNEGO_NegTokenInit(securityBlob)",
      "2690:            token = blob['MechToken']",
      "2691:            if len(blob['MechTypes'][0]) > 0:",
      "2692:                # Is this GSSAPI NTLM or something else we don't support?",
      "2693:                mechType = blob['MechTypes'][0]",
      "2694:                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
      "2695:                    # Nope, do we know it?",
      "2696:                    if mechType in MechTypes:",
      "2697:                        mechStr = MechTypes[mechType]",
      "2698:                    else:",
      "2699:                        mechStr = hexlify(mechType)",
      "2700:                    smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
      "2701:                    # We don't know the token, we answer back again saying",
      "2702:                    # we just support NTLM.",
      "2703:                    # ToDo: Build this into a SPNEGO_NegTokenResp()",
      "2704:                    respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
      "2705:                    respSMBCommand['SecurityBufferOffset'] = 0x48",
      "2706:                    respSMBCommand['SecurityBufferLength'] = len(respToken)",
      "2707:                    respSMBCommand['Buffer'] = respToken",
      "2709:                    return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
      "2710:         elif struct.unpack('B',securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:",
      "2711:            # AUTH packet",
      "2712:            blob = SPNEGO_NegTokenResp(securityBlob)",
      "2713:            token = blob['ResponseToken']",
      "2715:            # No GSSAPI stuff, raw NTLMSSP",
      "2716:            rawNTLM = True",
      "2717:            token = securityBlob",
      "2719:         # Here we only handle NTLMSSP, depending on what stage of the",
      "2721:         messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]",
      "",
      "[Added Lines]",
      "2733:         if struct.unpack('B', securityBlob[0:1])[0] == ASN1_AID:",
      "2734:             # NEGOTIATE packet",
      "2735:             blob = SPNEGO_NegTokenInit(securityBlob)",
      "2736:             token = blob['MechToken']",
      "2737:             if len(blob['MechTypes'][0]) > 0:",
      "2738:                 # Is this GSSAPI NTLM or something else we don't support?",
      "2739:                 mechType = blob['MechTypes'][0]",
      "2740:                 if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
      "2741:                     # Nope, do we know it?",
      "2742:                     if mechType in MechTypes:",
      "2743:                         mechStr = MechTypes[mechType]",
      "2744:                     else:",
      "2745:                         mechStr = hexlify(mechType)",
      "2746:                     smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
      "2747:                     # We don't know the token, we answer back again saying",
      "2748:                     # we just support NTLM.",
      "2749:                     # ToDo: Build this into a SPNEGO_NegTokenResp()",
      "2750:                     respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
      "2751:                     respSMBCommand['SecurityBufferOffset'] = 0x48",
      "2752:                     respSMBCommand['SecurityBufferLength'] = len(respToken)",
      "2753:                     respSMBCommand['Buffer'] = respToken",
      "2755:                     return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
      "2756:         elif struct.unpack('B', securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:",
      "2757:             # AUTH packet",
      "2758:             blob = SPNEGO_NegTokenResp(securityBlob)",
      "2759:             token = blob['ResponseToken']",
      "2761:             # No GSSAPI stuff, raw NTLMSSP",
      "2762:             rawNTLM = True",
      "2763:             token = securityBlob",
      "2765:         # Here we only handle NTLMSSP, depending on what stage of the",
      "2767:         messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]",
      "",
      "---------------",
      "--- Hunk 63 ---",
      "[Context before]",
      "2727:             # Let's store it in the connection data",
      "2728:             connData['NEGOTIATE_MESSAGE'] = negotiateMessage",
      "2729:             # Let's build the answer flags",
      "2732:             ansFlags = 0",
      "2734:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:",
      "2736:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:",
      "2738:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
      "2740:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:",
      "2742:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:",
      "2744:             if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:",
      "2747:             ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET",
      "2749:             # Generate the AV_PAIRS",
      "2750:             av_pairs = ntlm.AV_PAIRS()",
      "2751:             # TODO: Put the proper data from SMBSERVER config",
      "2756:             challengeMessage = ntlm.NTLMAuthChallenge()",
      "2764:             challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)",
      "2765:             challengeMessage['TargetInfoFields'] = av_pairs",
      "2770:             if rawNTLM is False:",
      "2771:                 respToken = SPNEGO_NegTokenResp()",
      "",
      "[Removed Lines]",
      "2730:             # TODO: Parse all the flags. With this we're leaving some clients out",
      "2735:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
      "2737:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
      "2739:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
      "2741:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
      "2743:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
      "2745:                ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
      "2752:             av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
      "2753:             av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
      "2754:             av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )",
      "2757:             challengeMessage['flags']            = ansFlags",
      "2758:             challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))",
      "2759:             challengeMessage['domain_max_len']   = challengeMessage['domain_len']",
      "2760:             challengeMessage['domain_offset']    = 40 + 16",
      "2761:             challengeMessage['challenge']        = smbServer.getSMBChallenge()",
      "2762:             challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')",
      "2763:             challengeMessage['TargetInfoFields_len']     = len(av_pairs)",
      "2766:             challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])",
      "2767:             challengeMessage['Version']          = b'\\xff'*8",
      "2768:             challengeMessage['VersionLen']       = 8",
      "",
      "[Added Lines]",
      "2776:             # TODO: Parse all the flags. With this we're leaving some clients out",
      "2781:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
      "2783:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
      "2785:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
      "2787:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
      "2789:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
      "2791:                 ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
      "2798:             av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[",
      "2799:                 ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
      "2800:             av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[",
      "2801:                 ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
      "2802:             av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (",
      "2803:                         116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))",
      "2806:             challengeMessage['flags'] = ansFlags",
      "2807:             challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))",
      "2808:             challengeMessage['domain_max_len'] = challengeMessage['domain_len']",
      "2809:             challengeMessage['domain_offset'] = 40 + 16",
      "2810:             challengeMessage['challenge'] = smbServer.getSMBChallenge()",
      "2811:             challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')",
      "2812:             challengeMessage['TargetInfoFields_len'] = len(av_pairs)",
      "2815:             challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])",
      "2816:             challengeMessage['Version'] = b'\\xff' * 8",
      "2817:             challengeMessage['VersionLen'] = 8",
      "",
      "---------------",
      "--- Hunk 64 ---",
      "[Context before]",
      "2780:             # Setting the packet to STATUS_MORE_PROCESSING",
      "2781:             errorCode = STATUS_MORE_PROCESSING_REQUIRED",
      "2783:             # in the connection's data",
      "2784:             # Picking a fixed value",
      "2785:             # TODO: Manage more UIDs for the same session",
      "2787:             # Let's store it in the connection data",
      "2788:             connData['CHALLENGE_MESSAGE'] = challengeMessage",
      "",
      "[Removed Lines]",
      "2782:             # Let's set up an UID for this connection and store it",
      "2786:             connData['Uid'] = random.randint(1,0xffffffff)",
      "",
      "[Added Lines]",
      "2831:             # Let's set up an UID for this connection and store it",
      "2835:             connData['Uid'] = random.randint(1, 0xffffffff)",
      "",
      "---------------",
      "--- Hunk 65 ---",
      "[Context before]",
      "2795:             authenticateMessage = ntlm.NTLMAuthChallengeResponse()",
      "2796:             authenticateMessage.fromString(token)",
      "2797:             smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (",
      "2800:             # TODO: Check the credentials! Now granting permissions",
      "2801:             # Do we have credentials to check?",
      "2802:             if len(smbServer.getCredentials()) > 0:",
      "",
      "[Removed Lines]",
      "2798:             authenticateMessage['domain_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le'),",
      "2799:             authenticateMessage['host_name'].decode('utf-16le')))",
      "",
      "[Added Lines]",
      "2847:                 authenticateMessage['domain_name'].decode('utf-16le'),",
      "2848:                 authenticateMessage['user_name'].decode('utf-16le'),",
      "2849:                 authenticateMessage['host_name'].decode('utf-16le')))",
      "",
      "---------------",
      "--- Hunk 66 ---",
      "[Context before]",
      "2829:                 # accept-completed",
      "2830:                 respToken['NegState'] = b'\\x00'",
      "2831:                 smbServer.log('User %s\\\\%s authenticated successfully' % (",
      "2833:                 # Let's store it in the connection data",
      "2834:                 connData['AUTHENTICATE_MESSAGE'] = authenticateMessage",
      "2835:                 try:",
      "",
      "[Removed Lines]",
      "2832:                 authenticateMessage['host_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le')))",
      "",
      "[Added Lines]",
      "2882:                     authenticateMessage['host_name'].decode('utf-16le'),",
      "2883:                     authenticateMessage['user_name'].decode('utf-16le')))",
      "",
      "---------------",
      "--- Hunk 67 ---",
      "[Context before]",
      "2862:         # From now on, the client can ask for other commands",
      "2863:         connData['Authenticated'] = True",
      "2864:         # For now, just switching to nobody",
      "2867:         smbServer.setConnectionData(connId, connData)",
      "2869:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "2865:         #os.setregid(65534,65534)",
      "2866:         #os.setreuid(65534,65534)",
      "",
      "[Added Lines]",
      "2916:         # os.setregid(65534,65534)",
      "2917:         # os.setreuid(65534,65534)",
      "",
      "---------------",
      "--- Hunk 68 ---",
      "[Context before]",
      "2873:         connData = smbServer.getConnectionData(connId)",
      "2875:         respPacket = smb2.SMB2Packet()",
      "2878:         respPacket['CreditRequestResponse'] = 1",
      "2880:         respPacket['SessionID'] = connData['Uid']",
      "2882:         respPacket['MessageID'] = recvPacket['MessageID']",
      "2887:         treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])",
      "",
      "[Removed Lines]",
      "2876:         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "2877:         respPacket['Status']    = STATUS_SUCCESS",
      "2879:         respPacket['Command']   = recvPacket['Command']",
      "2881:         respPacket['Reserved']  = recvPacket['Reserved']",
      "2883:         respPacket['TreeID']    = recvPacket['TreeID']",
      "2885:         respSMBCommand        = smb2.SMB2TreeConnect_Response()",
      "",
      "[Added Lines]",
      "2927:         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "2928:         respPacket['Status'] = STATUS_SUCCESS",
      "2930:         respPacket['Command'] = recvPacket['Command']",
      "2932:         respPacket['Reserved'] = recvPacket['Reserved']",
      "2934:         respPacket['TreeID'] = recvPacket['TreeID']",
      "2936:         respSMBCommand = smb2.SMB2TreeConnect_Response()",
      "",
      "---------------",
      "--- Hunk 69 ---",
      "[Context before]",
      "2902:         if share is not None:",
      "2903:             # Simple way to generate a Tid",
      "2904:             if len(connData['ConnectedShares']) == 0:",
      "2906:             else:",
      "2908:             connData['ConnectedShares'][tid] = share",
      "2909:             connData['ConnectedShares'][tid]['shareName'] = path",
      "2912:         else:",
      "2913:             smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)",
      "2914:             errorCode = STATUS_OBJECT_PATH_NOT_FOUND",
      "",
      "[Removed Lines]",
      "2905:                tid = 1",
      "2907:                tid = list(connData['ConnectedShares'].keys())[-1] + 1",
      "2910:             respPacket['TreeID']    = tid",
      "2911:             smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
      "",
      "[Added Lines]",
      "2956:                 tid = 1",
      "2958:                 tid = list(connData['ConnectedShares'].keys())[-1] + 1",
      "2961:             respPacket['TreeID'] = tid",
      "2962:             smbServer.log(\"Connecting Share(%d:%s)\" % (tid, path))",
      "",
      "---------------",
      "--- Hunk 70 ---",
      "[Context before]",
      "2938:     def smb2Create(connId, smbServer, recvPacket):",
      "2939:         connData = smbServer.getConnectionData(connId)",
      "2945:         respSMBCommand['Buffer'] = b'\\x00'",
      "2946:         # Get the Tid associated",
      "2947:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
      "2960:                 # strip leading '/'",
      "2961:                 fileName = fileName[1:]",
      "3016:                         errorCode = STATUS_FILE_IS_A_DIRECTORY",
      "3024:                             fid = VOID_FILE_DESCRIPTOR",
      "3026:                             if sys.platform == 'win32':",
      "3028:                             if str(pathName) in smbServer.getRegisteredNamedPipes():",
      "3029:                                 fid = PIPE_FILE_DESCRIPTOR",
      "3030:                                 sock = socket.socket()",
      "3031:                                 sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])",
      "3032:                             else:",
      "3033:                                 fid = os.open(pathName, mode)",
      "3039:         else:",
      "3040:             errorCode = STATUS_SMB_BAD_TID",
      "",
      "[Removed Lines]",
      "2941:         respSMBCommand        = smb2.SMB2Create_Response()",
      "2943:         ntCreateRequest       = smb2.SMB2Create(recvPacket['Data'])",
      "2948:              # If we have a rootFid, the path is relative to that fid",
      "2949:              errorCode = STATUS_SUCCESS",
      "2950:              if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:",
      "2951:                  path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
      "2952:              else:",
      "2953:                  path = 'NONE'",
      "2954:                  errorCode = STATUS_ACCESS_DENIED",
      "2956:              deleteOnClose = False",
      "2958:              fileName = os.path.normpath(ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\','/'))",
      "2959:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "2962:              pathName = os.path.join(path,fileName)",
      "2963:              createDisposition = ntCreateRequest['CreateDisposition']",
      "2964:              mode = 0",
      "2966:              if createDisposition == smb2.FILE_SUPERSEDE:",
      "2967:                  mode |= os.O_TRUNC | os.O_CREAT",
      "2968:              elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:",
      "2969:                  mode |= os.O_TRUNC | os.O_CREAT",
      "2970:              elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:",
      "2971:                  if os.path.exists(pathName) is True:",
      "2972:                      mode |= os.O_TRUNC",
      "2973:                  else:",
      "2974:                      errorCode = STATUS_NO_SUCH_FILE",
      "2975:              elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:",
      "2976:                  if os.path.exists(pathName) is True:",
      "2977:                      mode |= os.O_TRUNC",
      "2978:                  else:",
      "2979:                      mode |= os.O_TRUNC | os.O_CREAT",
      "2980:              elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:",
      "2981:                  if os.path.exists(pathName) is True:",
      "2982:                      errorCode = STATUS_OBJECT_NAME_COLLISION",
      "2983:                  else:",
      "2984:                      mode |= os.O_CREAT",
      "2985:              elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:",
      "2986:                  if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
      "2987:                      errorCode = STATUS_NO_SUCH_FILE",
      "2989:              if errorCode == STATUS_SUCCESS:",
      "2990:                  desiredAccess = ntCreateRequest['DesiredAccess']",
      "2991:                  if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
      "2992:                      mode |= os.O_RDONLY",
      "2993:                  if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):",
      "2994:                      if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
      "2995:                          mode |= os.O_RDWR #| os.O_APPEND",
      "2996:                      else:",
      "2997:                          mode |= os.O_WRONLY #| os.O_APPEND",
      "2998:                  if desiredAccess & smb2.GENERIC_ALL:",
      "2999:                      mode |= os.O_RDWR #| os.O_APPEND",
      "3001:                  createOptions =  ntCreateRequest['CreateOptions']",
      "3002:                  if mode & os.O_CREAT == os.O_CREAT:",
      "3003:                      if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:",
      "3004:                          try:",
      "3005:                              # Let's create the directory",
      "3006:                              os.mkdir(pathName)",
      "3007:                              mode = os.O_RDONLY",
      "3008:                          except Exception as e:",
      "3009:                              smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
      "3010:                              errorCode = STATUS_ACCESS_DENIED",
      "3011:                  if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:",
      "3012:                      # If the file being opened is a directory, the server MUST fail the request with",
      "3013:                      # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
      "3014:                      # response.",
      "3015:                      if os.path.isdir(pathName) is True:",
      "3018:                  if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:",
      "3019:                      deleteOnClose = True",
      "3021:                  if errorCode == STATUS_SUCCESS:",
      "3022:                      try:",
      "3023:                          if os.path.isdir(pathName) and sys.platform == 'win32':",
      "3025:                          else:",
      "3027:                                mode |= os.O_BINARY",
      "3034:                      except Exception as e:",
      "3035:                          smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
      "3036:                          #print e",
      "3037:                          fid = 0",
      "3038:                          errorCode = STATUS_ACCESS_DENIED",
      "",
      "[Added Lines]",
      "2992:         respSMBCommand = smb2.SMB2Create_Response()",
      "2994:         ntCreateRequest = smb2.SMB2Create(recvPacket['Data'])",
      "2999:             # If we have a rootFid, the path is relative to that fid",
      "3000:             errorCode = STATUS_SUCCESS",
      "3001:             if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:",
      "3002:                 path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
      "3003:             else:",
      "3004:                 path = 'NONE'",
      "3005:                 errorCode = STATUS_ACCESS_DENIED",
      "3007:             deleteOnClose = False",
      "3009:             fileName = os.path.normpath(",
      "3010:                 ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\', '/'))",
      "3011:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
      "3015:             if not isInFileJail(path, fileName):",
      "3016:                 LOG.error(\"Path not in current working directory\")",
      "3017:                 return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD",
      "3019:             pathName = os.path.join(path, fileName)",
      "3020:             createDisposition = ntCreateRequest['CreateDisposition']",
      "3021:             mode = 0",
      "3023:             if createDisposition == smb2.FILE_SUPERSEDE:",
      "3024:                 mode |= os.O_TRUNC | os.O_CREAT",
      "3025:             elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:",
      "3026:                 mode |= os.O_TRUNC | os.O_CREAT",
      "3027:             elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:",
      "3028:                 if os.path.exists(pathName) is True:",
      "3029:                     mode |= os.O_TRUNC",
      "3030:                 else:",
      "3031:                     errorCode = STATUS_NO_SUCH_FILE",
      "3032:             elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:",
      "3033:                 if os.path.exists(pathName) is True:",
      "3034:                     mode |= os.O_TRUNC",
      "3035:                 else:",
      "3036:                     mode |= os.O_TRUNC | os.O_CREAT",
      "3037:             elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:",
      "3038:                 if os.path.exists(pathName) is True:",
      "3039:                     errorCode = STATUS_OBJECT_NAME_COLLISION",
      "3040:                 else:",
      "3041:                     mode |= os.O_CREAT",
      "3042:             elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:",
      "3043:                 if os.path.exists(pathName) is not True and (",
      "3044:                         str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
      "3045:                     errorCode = STATUS_NO_SUCH_FILE",
      "3047:             if errorCode == STATUS_SUCCESS:",
      "3048:                 desiredAccess = ntCreateRequest['DesiredAccess']",
      "3049:                 if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
      "3050:                     mode |= os.O_RDONLY",
      "3051:                 if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):",
      "3052:                     if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
      "3053:                         mode |= os.O_RDWR  # | os.O_APPEND",
      "3054:                     else:",
      "3055:                         mode |= os.O_WRONLY  # | os.O_APPEND",
      "3056:                 if desiredAccess & smb2.GENERIC_ALL:",
      "3057:                     mode |= os.O_RDWR  # | os.O_APPEND",
      "3059:                 createOptions = ntCreateRequest['CreateOptions']",
      "3060:                 if mode & os.O_CREAT == os.O_CREAT:",
      "3061:                     if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:",
      "3062:                         try:",
      "3063:                             # Let's create the directory",
      "3064:                             os.mkdir(pathName)",
      "3065:                             mode = os.O_RDONLY",
      "3066:                         except Exception as e:",
      "3067:                             smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
      "3068:                             errorCode = STATUS_ACCESS_DENIED",
      "3069:                 if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:",
      "3070:                     # If the file being opened is a directory, the server MUST fail the request with",
      "3071:                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
      "3072:                     # response.",
      "3073:                     if os.path.isdir(pathName) is True:",
      "3076:                 if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:",
      "3077:                     deleteOnClose = True",
      "3079:                 if errorCode == STATUS_SUCCESS:",
      "3080:                     try:",
      "3081:                         if os.path.isdir(pathName) and sys.platform == 'win32':",
      "3083:                         else:",
      "3085:                                 mode |= os.O_BINARY",
      "3092:                     except Exception as e:",
      "3093:                         smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
      "3094:                         # print e",
      "3095:                         fid = 0",
      "3096:                         errorCode = STATUS_ACCESS_DENIED",
      "",
      "---------------",
      "--- Hunk 71 ---",
      "[Context before]",
      "3047:             respSMBCommand['CreateAction'] = createDisposition",
      "3049:             if fid == PIPE_FILE_DESCRIPTOR:",
      "3051:                 respSMBCommand['LastAccessTime'] = 0",
      "3054:                 respSMBCommand['AllocationSize'] = 4096",
      "3056:                 respSMBCommand['FileAttributes'] = 0x80",
      "3058:             else:",
      "",
      "[Removed Lines]",
      "3050:                 respSMBCommand['CreationTime']   = 0",
      "3052:                 respSMBCommand['LastWriteTime']  = 0",
      "3053:                 respSMBCommand['ChangeTime']     = 0",
      "3055:                 respSMBCommand['EndOfFile']      = 0",
      "",
      "[Added Lines]",
      "3108:                 respSMBCommand['CreationTime'] = 0",
      "3110:                 respSMBCommand['LastWriteTime'] = 0",
      "3111:                 respSMBCommand['ChangeTime'] = 0",
      "3113:                 respSMBCommand['EndOfFile'] = 0",
      "",
      "---------------",
      "--- Hunk 72 ---",
      "[Context before]",
      "3061:                 else:",
      "3062:                     respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']",
      "3063:                 # Let's get this file's information",
      "3065:                 if errorCode == STATUS_SUCCESS:",
      "3067:                     respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']",
      "3069:                     respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']",
      "3070:                     respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']",
      "3071:                     respSMBCommand['AllocationSize'] = respInfo['AllocationSize']",
      "3074:             if errorCode == STATUS_SUCCESS:",
      "3075:                 # Let's store the fid for the connection",
      "",
      "[Removed Lines]",
      "3064:                 respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)",
      "3066:                     respSMBCommand['CreationTime']   = respInfo['CreationTime']",
      "3068:                     respSMBCommand['LastWriteTime']  = respInfo['LastWriteTime']",
      "3072:                     respSMBCommand['EndOfFile']      = respInfo['EndOfFile']",
      "",
      "[Added Lines]",
      "3122:                 respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)",
      "3124:                     respSMBCommand['CreationTime'] = respInfo['CreationTime']",
      "3126:                     respSMBCommand['LastWriteTime'] = respInfo['LastWriteTime']",
      "3130:                     respSMBCommand['EndOfFile'] = respInfo['EndOfFile']",
      "",
      "---------------",
      "--- Hunk 73 ---",
      "[Context before]",
      "3077:                 connData['OpenedFiles'][fakefid] = {}",
      "3078:                 connData['OpenedFiles'][fakefid]['FileHandle'] = fid",
      "3079:                 connData['OpenedFiles'][fakefid]['FileName'] = pathName",
      "3082:                 connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0",
      "3083:                 connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''",
      "3084:                 if fid == PIPE_FILE_DESCRIPTOR:",
      "3085:                     connData['OpenedFiles'][fakefid]['Socket'] = sock",
      "3086:         else:",
      "3087:             respSMBCommand = smb2.SMB2Error()",
      "3089:         if errorCode == STATUS_SUCCESS:",
      "3090:             connData['LastRequest']['SMB2_CREATE'] = respSMBCommand",
      "3091:         smbServer.setConnectionData(connId, connData)",
      "",
      "[Removed Lines]",
      "3080:                 connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose",
      "3081:                 connData['OpenedFiles'][fakefid]['Open']  = {}",
      "",
      "[Added Lines]",
      "3138:                 connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose",
      "3139:                 connData['OpenedFiles'][fakefid]['Open'] = {}",
      "",
      "---------------",
      "--- Hunk 74 ---",
      "[Context before]",
      "3096:     def smb2Close(connId, smbServer, recvPacket):",
      "3097:         connData = smbServer.getConnectionData(connId)",
      "3101:         closeRequest = smb2.SMB2Close(recvPacket['Data'])",
      "3104:             # Let's take the data from the lastRequest",
      "3106:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3107:             else:",
      "3108:                 fileID = closeRequest['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3099:         respSMBCommand        = smb2.SMB2Close_Response()",
      "3103:         if closeRequest['FileID'].getData() == b'\\xff'*16:",
      "3105:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3157:         respSMBCommand = smb2.SMB2Close_Response()",
      "3161:         if closeRequest['FileID'].getData() == b'\\xff' * 16:",
      "3163:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 75 ---",
      "[Context before]",
      "3110:             fileID = closeRequest['FileID'].getData()",
      "3112:         if fileID in connData['OpenedFiles']:",
      "3149:         else:",
      "3150:             errorCode = STATUS_INVALID_HANDLE",
      "",
      "[Removed Lines]",
      "3113:              errorCode = STATUS_SUCCESS",
      "3114:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3115:              pathName = connData['OpenedFiles'][fileID]['FileName']",
      "3116:              infoRecord = None",
      "3117:              try:",
      "3118:                  if fileHandle == PIPE_FILE_DESCRIPTOR:",
      "3119:                      connData['OpenedFiles'][fileID]['Socket'].close()",
      "3120:                  elif fileHandle != VOID_FILE_DESCRIPTOR:",
      "3121:                      os.close(fileHandle)",
      "3122:                      infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName), smb2.SMB2_FILE_NETWORK_OPEN_INFO)",
      "3123:              except Exception as e:",
      "3124:                  smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
      "3125:                  errorCode = STATUS_INVALID_HANDLE",
      "3126:              else:",
      "3127:                  # Check if the file was marked for removal",
      "3128:                  if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:",
      "3129:                      try:",
      "3130:                          if os.path.isdir(pathName):",
      "3131:                              shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])",
      "3132:                          else:",
      "3133:                              os.remove(connData['OpenedFiles'][fileID]['FileName'])",
      "3134:                      except Exception as e:",
      "3135:                          smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
      "3136:                          errorCode = STATUS_ACCESS_DENIED",
      "3138:                  # Now fill out the response",
      "3139:                  if infoRecord is not None:",
      "3140:                      respSMBCommand['CreationTime']   = infoRecord['CreationTime']",
      "3141:                      respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']",
      "3142:                      respSMBCommand['LastWriteTime']  = infoRecord['LastWriteTime']",
      "3143:                      respSMBCommand['ChangeTime']     = infoRecord['ChangeTime']",
      "3144:                      respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']",
      "3145:                      respSMBCommand['EndofFile']      = infoRecord['EndOfFile']",
      "3146:                      respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']",
      "3147:                  if errorCode == STATUS_SUCCESS:",
      "3148:                      del(connData['OpenedFiles'][fileID])",
      "",
      "[Added Lines]",
      "3171:             errorCode = STATUS_SUCCESS",
      "3172:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3173:             pathName = connData['OpenedFiles'][fileID]['FileName']",
      "3174:             infoRecord = None",
      "3175:             try:",
      "3176:                 if fileHandle == PIPE_FILE_DESCRIPTOR:",
      "3177:                     connData['OpenedFiles'][fileID]['Socket'].close()",
      "3178:                 elif fileHandle != VOID_FILE_DESCRIPTOR:",
      "3179:                     os.close(fileHandle)",
      "3180:                     infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),",
      "3181:                                                                  smb2.SMB2_FILE_NETWORK_OPEN_INFO)",
      "3182:             except Exception as e:",
      "3183:                 smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
      "3184:                 errorCode = STATUS_INVALID_HANDLE",
      "3185:             else:",
      "3186:                 # Check if the file was marked for removal",
      "3187:                 if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:",
      "3188:                     try:",
      "3189:                         if os.path.isdir(pathName):",
      "3190:                             shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])",
      "3191:                         else:",
      "3192:                             os.remove(connData['OpenedFiles'][fileID]['FileName'])",
      "3193:                     except Exception as e:",
      "3194:                         smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
      "3195:                         errorCode = STATUS_ACCESS_DENIED",
      "3197:                 # Now fill out the response",
      "3198:                 if infoRecord is not None:",
      "3199:                     respSMBCommand['CreationTime'] = infoRecord['CreationTime']",
      "3200:                     respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']",
      "3201:                     respSMBCommand['LastWriteTime'] = infoRecord['LastWriteTime']",
      "3202:                     respSMBCommand['ChangeTime'] = infoRecord['ChangeTime']",
      "3203:                     respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']",
      "3204:                     respSMBCommand['EndofFile'] = infoRecord['EndOfFile']",
      "3205:                     respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']",
      "3206:                 if errorCode == STATUS_SUCCESS:",
      "3207:                     del (connData['OpenedFiles'][fileID])",
      "",
      "---------------",
      "--- Hunk 76 ---",
      "[Context before]",
      "3156:     def smb2QueryInfo(connId, smbServer, recvPacket):",
      "3157:         connData = smbServer.getConnectionData(connId)",
      "3161:         queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])",
      "3165:         respSMBCommand['OutputBufferOffset'] = 0x48",
      "3166:         respSMBCommand['Buffer'] = b'\\x00'",
      "3169:             # Let's take the data from the lastRequest",
      "3171:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3172:             else:",
      "3173:                 fileID = queryInfo['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3159:         respSMBCommand        = smb2.SMB2QueryInfo_Response()",
      "3163:         errorCode = STATUS_SUCCESS",
      "3168:         if queryInfo['FileID'].getData() == b'\\xff'*16:",
      "3170:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3218:         respSMBCommand = smb2.SMB2QueryInfo_Response()",
      "3222:         errorCode = STATUS_SUCCESS",
      "3227:         if queryInfo['FileID'].getData() == b'\\xff' * 16:",
      "3229:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 77 ---",
      "[Context before]",
      "3189:                                                                      queryInfo['FileInfoClass'])",
      "3190:                 elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
      "3191:                     if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:",
      "3193:                     else:",
      "3195:                 elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
      "3196:                     # Failing for now, until we support it",
      "3197:                     infoRecord = None",
      "3198:                     errorCode = STATUS_ACCESS_DENIED",
      "3199:                 else:",
      "3202:                 if infoRecord is not None:",
      "3203:                     respSMBCommand['OutputBufferLength'] = len(infoRecord)",
      "",
      "[Removed Lines]",
      "3192:                         infoRecord = b'\\x00'*4",
      "3194:                         infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName), queryInfo['FileInfoClass'])",
      "3200:                     smbServer.log(\"queryInfo not supported (%x)\" %  queryInfo['InfoType'], logging.ERROR)",
      "",
      "[Added Lines]",
      "3251:                         infoRecord = b'\\x00' * 4",
      "3253:                         infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName),",
      "3254:                                                         queryInfo['FileInfoClass'])",
      "3260:                     smbServer.log(\"queryInfo not supported (%x)\" % queryInfo['InfoType'], logging.ERROR)",
      "",
      "---------------",
      "--- Hunk 78 ---",
      "[Context before]",
      "3215:     def smb2SetInfo(connId, smbServer, recvPacket):",
      "3216:         connData = smbServer.getConnectionData(connId)",
      "3220:         setInfo = smb2.SMB2SetInfo(recvPacket['Data'])",
      "3225:             # Let's take the data from the lastRequest",
      "3227:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3228:             else:",
      "3229:                 fileID = setInfo['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3218:         respSMBCommand        = smb2.SMB2SetInfo_Response()",
      "3222:         errorCode = STATUS_SUCCESS",
      "3224:         if setInfo['FileID'].getData() == b'\\xff'*16:",
      "3226:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3277:         respSMBCommand = smb2.SMB2SetInfo_Response()",
      "3281:         errorCode = STATUS_SUCCESS",
      "3283:         if setInfo['FileID'].getData() == b'\\xff' * 16:",
      "3285:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 79 ---",
      "[Context before]",
      "3231:             fileID = setInfo['FileID'].getData()",
      "3233:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
      "3235:             if fileID in connData['OpenedFiles']:",
      "3236:                 pathName = connData['OpenedFiles'][fileID]['FileName']",
      "",
      "[Removed Lines]",
      "3234:             path     = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
      "",
      "[Added Lines]",
      "3293:             path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
      "",
      "---------------",
      "--- Hunk 80 ---",
      "[Context before]",
      "3241:                     if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:",
      "3242:                         infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])",
      "3243:                         if infoRecord['DeletePending'] > 0:",
      "3246:                     elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:",
      "3247:                         infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])",
      "3248:                         # Creation time won't be set,  the other ones we play with.",
      "",
      "[Removed Lines]",
      "3244:                            # Mark this file for removal after closed",
      "3245:                            connData['OpenedFiles'][fileID]['DeleteOnClose'] = True",
      "",
      "[Added Lines]",
      "3303:                             # Mark this file for removal after closed",
      "3304:                             connData['OpenedFiles'][fileID]['DeleteOnClose'] = True",
      "",
      "---------------",
      "--- Hunk 81 ---",
      "[Context before]",
      "3257:                         else:",
      "3258:                             mtime = getUnixTime(mtime)",
      "3259:                         if atime > 0 and mtime > 0:",
      "3261:                     elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:",
      "3262:                         fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3263:                         infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])",
      "3264:                         if infoRecord['EndOfFile'] > 0:",
      "3266:                             os.write(fileHandle, b'\\x00')",
      "3267:                     elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:",
      "3268:                         renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])",
      "3270:                         if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):",
      "3271:                             return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION",
      "3272:                         try:",
      "3275:                         except Exception as e:",
      "3278:                     else:",
      "3279:                         smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)",
      "3280:                         # UNSUPPORTED",
      "3283:                 #    # The underlying object store information is being set.",
      "3284:                 #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])",
      "3286:                 #    # The security information is being set.",
      "3287:                 #    # Failing for now, until we support it",
      "3288:                 #    infoRecord = None",
      "3289:                 #    errorCode = STATUS_ACCESS_DENIED",
      "3291:                 #    # The underlying object store quota information is being set.",
      "3292:                 #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])",
      "3293:                 else:",
      "3296:             else:",
      "3297:                 errorCode = STATUS_INVALID_HANDLE",
      "3298:         else:",
      "3299:             errorCode = STATUS_SMB_BAD_TID",
      "3302:         smbServer.setConnectionData(connId, connData)",
      "3303:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "3260:                             os.utime(pathName,(atime,mtime))",
      "3265:                             os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)",
      "3269:                         newPathName = os.path.join(path,renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/'))",
      "3273:                              os.rename(pathName,newPathName)",
      "3274:                              connData['OpenedFiles'][fileID]['FileName'] = newPathName",
      "3276:                              smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)",
      "3277:                              errorCode = STATUS_ACCESS_DENIED",
      "3281:                         errorCode =  STATUS_NOT_SUPPORTED",
      "3282:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
      "3285:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
      "3290:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:",
      "3294:                     smbServer.log(\"setInfo not supported (%x)\" %  setInfo['InfoType'], logging.ERROR)",
      "",
      "[Added Lines]",
      "3319:                             os.utime(pathName, (atime, mtime))",
      "3324:                             os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)",
      "3328:                         newPathName = os.path.join(path, renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/'))",
      "3332:                             os.rename(pathName, newPathName)",
      "3333:                             connData['OpenedFiles'][fileID]['FileName'] = newPathName",
      "3335:                             smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)",
      "3336:                             errorCode = STATUS_ACCESS_DENIED",
      "3340:                         errorCode = STATUS_NOT_SUPPORTED",
      "3341:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
      "3344:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
      "3349:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:",
      "3353:                     smbServer.log(\"setInfo not supported (%x)\" % setInfo['InfoType'], logging.ERROR)",
      "",
      "---------------",
      "--- Hunk 82 ---",
      "[Context before]",
      "3307:         connData = smbServer.getConnectionData(connId)",
      "3309:         respSMBCommand = smb2.SMB2Write_Response()",
      "3312:         respSMBCommand['Buffer'] = b'\\x00'",
      "3315:             # Let's take the data from the lastRequest",
      "3317:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3318:             else:",
      "3319:                 fileID = writeRequest['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3310:         writeRequest   = smb2.SMB2Write(recvPacket['Data'])",
      "3314:         if writeRequest['FileID'].getData() == b'\\xff'*16:",
      "3316:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3368:         writeRequest = smb2.SMB2Write(recvPacket['Data'])",
      "3372:         if writeRequest['FileID'].getData() == b'\\xff' * 16:",
      "3374:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 83 ---",
      "[Context before]",
      "3321:             fileID = writeRequest['FileID'].getData()",
      "3323:         if fileID in connData['OpenedFiles']:",
      "3342:         else:",
      "3343:             errorCode = STATUS_INVALID_HANDLE",
      "",
      "[Removed Lines]",
      "3324:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3325:              errorCode = STATUS_SUCCESS",
      "3326:              try:",
      "3327:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3328:                      offset = writeRequest['Offset']",
      "3329:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "3330:                      if os.lseek(fileHandle, 0, 2) >= offset:",
      "3331:                          os.lseek(fileHandle,offset,0)",
      "3332:                          os.write(fileHandle,writeRequest['Buffer'])",
      "3333:                  else:",
      "3334:                      sock = connData['OpenedFiles'][fileID]['Socket']",
      "3335:                      sock.send(writeRequest['Buffer'])",
      "3337:                  respSMBCommand['Count']    = writeRequest['Length']",
      "3338:                  respSMBCommand['Remaining']= 0xff",
      "3339:              except Exception as e:",
      "3340:                  smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)",
      "3341:                  errorCode = STATUS_ACCESS_DENIED",
      "",
      "[Added Lines]",
      "3382:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3383:             errorCode = STATUS_SUCCESS",
      "3384:             try:",
      "3385:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3386:                     offset = writeRequest['Offset']",
      "3387:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
      "3388:                     if os.lseek(fileHandle, 0, 2) >= offset:",
      "3389:                         os.lseek(fileHandle, offset, 0)",
      "3390:                         os.write(fileHandle, writeRequest['Buffer'])",
      "3391:                 else:",
      "3392:                     sock = connData['OpenedFiles'][fileID]['Socket']",
      "3393:                     sock.send(writeRequest['Buffer'])",
      "3395:                 respSMBCommand['Count'] = writeRequest['Length']",
      "3396:                 respSMBCommand['Remaining'] = 0xff",
      "3397:             except Exception as e:",
      "3398:                 smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)",
      "3399:                 errorCode = STATUS_ACCESS_DENIED",
      "",
      "---------------",
      "--- Hunk 84 ---",
      "[Context before]",
      "3350:         connData = smbServer.getConnectionData(connId)",
      "3352:         respSMBCommand = smb2.SMB2Read_Response()",
      "3355:         respSMBCommand['Buffer'] = b'\\x00'",
      "3358:             # Let's take the data from the lastRequest",
      "3360:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3361:             else:",
      "3362:                 fileID = readRequest['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3353:         readRequest   = smb2.SMB2Read(recvPacket['Data'])",
      "3357:         if readRequest['FileID'].getData() == b'\\xff'*16:",
      "3359:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3411:         readRequest = smb2.SMB2Read(recvPacket['Data'])",
      "3415:         if readRequest['FileID'].getData() == b'\\xff' * 16:",
      "3417:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 85 ---",
      "[Context before]",
      "3364:             fileID = readRequest['FileID'].getData()",
      "3366:         if fileID in connData['OpenedFiles']:",
      "3385:         else:",
      "3386:             errorCode = STATUS_INVALID_HANDLE",
      "",
      "[Removed Lines]",
      "3367:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3368:              errorCode = 0",
      "3369:              try:",
      "3370:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3371:                      offset = readRequest['Offset']",
      "3372:                      os.lseek(fileHandle,offset,0)",
      "3373:                      content = os.read(fileHandle,readRequest['Length'])",
      "3374:                  else:",
      "3375:                      sock = connData['OpenedFiles'][fileID]['Socket']",
      "3376:                      content = sock.recv(readRequest['Length'])",
      "3378:                  respSMBCommand['DataOffset']   = 0x50",
      "3379:                  respSMBCommand['DataLength']   = len(content)",
      "3380:                  respSMBCommand['DataRemaining']= 0",
      "3381:                  respSMBCommand['Buffer']       = content",
      "3382:              except Exception as e:",
      "3383:                  smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)",
      "3384:                  errorCode = STATUS_ACCESS_DENIED",
      "",
      "[Added Lines]",
      "3425:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
      "3426:             errorCode = 0",
      "3427:             try:",
      "3428:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3429:                     offset = readRequest['Offset']",
      "3430:                     os.lseek(fileHandle, offset, 0)",
      "3431:                     content = os.read(fileHandle, readRequest['Length'])",
      "3432:                 else:",
      "3433:                     sock = connData['OpenedFiles'][fileID]['Socket']",
      "3434:                     content = sock.recv(readRequest['Length'])",
      "3436:                 respSMBCommand['DataOffset'] = 0x50",
      "3437:                 respSMBCommand['DataLength'] = len(content)",
      "3438:                 respSMBCommand['DataRemaining'] = 0",
      "3439:                 respSMBCommand['Buffer'] = content",
      "3440:             except Exception as e:",
      "3441:                 smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)",
      "3442:                 errorCode = STATUS_ACCESS_DENIED",
      "",
      "---------------",
      "--- Hunk 86 ---",
      "[Context before]",
      "3393:         connData = smbServer.getConnectionData(connId)",
      "3395:         respSMBCommand = smb2.SMB2Flush_Response()",
      "3398:         if flushRequest['FileID'].getData() in connData['OpenedFiles']:",
      "3406:         else:",
      "3407:             errorCode = STATUS_INVALID_HANDLE",
      "3409:         smbServer.setConnectionData(connId, connData)",
      "3410:         return [respSMBCommand], None, errorCode",
      "3413:     @staticmethod",
      "3414:     def smb2QueryDirectory(connId, smbServer, recvPacket):",
      "3415:         connData = smbServer.getConnectionData(connId)",
      "3416:         respSMBCommand = smb2.SMB2QueryDirectory_Response()",
      "3419:         respSMBCommand['Buffer'] = b'\\x00'",
      "3421:         # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.",
      "3422:         if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:",
      "3423:             return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED",
      "3426:         # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED",
      "3428:             # Let's take the data from the lastRequest",
      "3430:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
      "3431:             else:",
      "3432:                 fileID = queryDirectoryRequest['FileID'].getData()",
      "",
      "[Removed Lines]",
      "3396:         flushRequest   = smb2.SMB2Flush(recvPacket['Data'])",
      "3399:              fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']",
      "3400:              errorCode = STATUS_SUCCESS",
      "3401:              try:",
      "3402:                  os.fsync(fileHandle)",
      "3403:              except Exception as e:",
      "3404:                  smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)",
      "3405:                  errorCode = STATUS_ACCESS_DENIED",
      "3417:         queryDirectoryRequest   = smb2.SMB2QueryDirectory(recvPacket['Data'])",
      "3425:         # Next, the server MUST locate the open for the directory to be queried",
      "3427:         if queryDirectoryRequest['FileID'].getData() == b'\\xff'*16:",
      "3429:             if  'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "[Added Lines]",
      "3454:         flushRequest = smb2.SMB2Flush(recvPacket['Data'])",
      "3457:             fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']",
      "3458:             errorCode = STATUS_SUCCESS",
      "3459:             try:",
      "3460:                 os.fsync(fileHandle)",
      "3461:             except Exception as e:",
      "3462:                 smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)",
      "3463:                 errorCode = STATUS_ACCESS_DENIED",
      "3474:         queryDirectoryRequest = smb2.SMB2QueryDirectory(recvPacket['Data'])",
      "3482:         # Next, the server MUST locate the open for the directory to be queried",
      "3484:         if queryDirectoryRequest['FileID'].getData() == b'\\xff' * 16:",
      "3486:             if 'SMB2_CREATE' in connData['LastRequest']:",
      "",
      "---------------",
      "--- Hunk 87 ---",
      "[Context before]",
      "3436:         if (fileID in connData['OpenedFiles']) is False:",
      "3437:             return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED",
      "3440:         # with STATUS_INVALID_PARAMETER.",
      "3441:         if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:",
      "3442:             return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER",
      "3447:         if queryDirectoryRequest['FileInformationClass'] not in (",
      "3450:             return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS",
      "3454:         # and Open.EnumerationSearchPattern to an empty string.",
      "3455:         if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:",
      "3456:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0",
      "3457:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''",
      "3461:         # Open.EnumerationLocation to 0.",
      "3462:         if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:",
      "3463:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0",
      "3469:         # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.",
      "3471:         pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')",
      "3474:             if pattern == '':",
      "3475:                 pattern = '*'",
      "3476:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern",
      "3480:         # specified in the request by FileNameOffset and FileNameLength.",
      "3481:         if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\",
      "3483:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern",
      "3486:         searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),",
      "3491:         if errorCode != STATUS_SUCCESS:",
      "3492:             return [smb2.SMB2Error()], None, errorCode",
      "",
      "[Removed Lines]",
      "3439:         # If the open is not an open to a directory, the request MUST be failed",
      "3444:         # If any other information class is specified in the FileInformationClass",
      "3445:         # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the",
      "3446:         # operation with STATUS_INVALID_INFO_CLASS.",
      "3448:         smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION, smb2.FILEID_FULL_DIRECTORY_INFORMATION,",
      "3449:         smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION, smb2.FILENAMES_INFORMATION):",
      "3452:         # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY",
      "3453:         # Request, the server SHOULD<326> set Open.EnumerationLocation to 0",
      "3459:         # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2",
      "3460:         # QUERY_DIRECTORY Request, the server MUST set",
      "3465:         # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern",
      "3466:         # is an empty string, then Open.EnumerationSearchPattern MUST be set",
      "3467:         # to the search pattern specified in the SMB2 QUERY_DIRECTORY by",
      "3468:         # FileNameOffset and FileNameLength. If FileNameLength is 0, the server",
      "3472:         if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\",
      "3473:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':",
      "3478:         # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,",
      "3479:         # the server MUST set Open.EnumerationSearchPattern to the search pattern",
      "3482:            queryDirectoryRequest['FileNameLength'] > 0:",
      "3485:         pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']),pattern)",
      "3487:                   os.path.basename(pathName),",
      "3488:                   queryDirectoryRequest['FileInformationClass'],",
      "3489:                   smb.ATTR_DIRECTORY, isSMB2 = True )",
      "",
      "[Added Lines]",
      "3496:         # If the open is not an open to a directory, the request MUST be failed",
      "3501:         # If any other information class is specified in the FileInformationClass",
      "3502:         # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the",
      "3503:         # operation with STATUS_INVALID_INFO_CLASS.",
      "3505:                 smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION,",
      "3506:                 smb2.FILEID_FULL_DIRECTORY_INFORMATION,",
      "3507:                 smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION,",
      "3508:                 smb2.FILENAMES_INFORMATION):",
      "3511:         # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY",
      "3512:         # Request, the server SHOULD<326> set Open.EnumerationLocation to 0",
      "3518:         # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2",
      "3519:         # QUERY_DIRECTORY Request, the server MUST set",
      "3524:         # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern",
      "3525:         # is an empty string, then Open.EnumerationSearchPattern MUST be set",
      "3526:         # to the search pattern specified in the SMB2 QUERY_DIRECTORY by",
      "3527:         # FileNameOffset and FileNameLength. If FileNameLength is 0, the server",
      "3531:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\",
      "3532:                 connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':",
      "3537:         # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,",
      "3538:         # the server MUST set Open.EnumerationSearchPattern to the search pattern",
      "3541:                 queryDirectoryRequest['FileNameLength'] > 0:",
      "3544:         pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']), pattern)",
      "3546:                                                           os.path.basename(pathName),",
      "3547:                                                           queryDirectoryRequest['FileInformationClass'],",
      "3548:                                                           smb.ATTR_DIRECTORY, isSMB2=True)",
      "",
      "---------------",
      "--- Hunk 88 ---",
      "[Context before]",
      "3499:         if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:",
      "3500:             return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE",
      "3503:             return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES",
      "3505:         totalData = 0",
      "",
      "[Removed Lines]",
      "3502:         if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:",
      "",
      "[Added Lines]",
      "3561:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:",
      "",
      "---------------",
      "--- Hunk 89 ---",
      "[Context before]",
      "3511:                 searchResult[nItem]['NextEntryOffset'] = 0",
      "3512:             data = searchResult[nItem].getData()",
      "3513:             lenData = len(data)",
      "3517:                 connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1",
      "3518:                 break",
      "3519:             else:",
      "3521:                 totalData += lenData + padLen",
      "3523:             if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:",
      "3524:                 break",
      "3526:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:",
      "3529:         respSMBCommand['OutputBufferOffset'] = 0x48",
      "3530:         respSMBCommand['OutputBufferLength'] = totalData",
      "",
      "[Removed Lines]",
      "3514:             padLen = (8-(lenData % 8)) %8",
      "3516:             if (totalData+lenData) >= queryDirectoryRequest['OutputBufferLength']:",
      "3520:                 respData += data + b'\\x00'*padLen",
      "3527:              connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1",
      "",
      "[Added Lines]",
      "3573:             padLen = (8 - (lenData % 8)) % 8",
      "3575:             if (totalData + lenData) >= queryDirectoryRequest['OutputBufferLength']:",
      "3579:                 respData += data + b'\\x00' * padLen",
      "3586:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1",
      "",
      "---------------",
      "--- Hunk 90 ---",
      "[Context before]",
      "3554:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
      "3555:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (",
      "3558:             errorCode = STATUS_SUCCESS",
      "3559:         else:",
      "3560:             # STATUS_SMB_BAD_TID",
      "3561:             errorCode = STATUS_SMB_BAD_TID",
      "3564:         smbServer.setConnectionData(connId, connData)",
      "3565:         return [respSMBCommand], None, errorCode",
      "",
      "[Removed Lines]",
      "3556:             recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))",
      "3557:             del(connData['ConnectedShares'][recvPacket['TreeID']])",
      "",
      "[Added Lines]",
      "3615:                 recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))",
      "3616:             del (connData['ConnectedShares'][recvPacket['TreeID']])",
      "",
      "---------------",
      "--- Hunk 91 ---",
      "[Context before]",
      "3587:         connData = smbServer.getConnectionData(connId)",
      "3589:         respSMBCommand = smb2.SMB2Ioctl_Response()",
      "3592:         ioctls = smbServer.getIoctls()",
      "3593:         if ioctlRequest['CtlCode'] in ioctls:",
      "3594:             outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)",
      "3595:             if errorCode == STATUS_SUCCESS:",
      "3600:                 respSMBCommand['OutputOffset'] = 0x70",
      "3604:             else:",
      "3605:                 respSMBCommand = outputData",
      "3606:         else:",
      "3608:             errorCode = STATUS_INVALID_DEVICE_REQUEST",
      "3609:             respSMBCommand = smb2.SMB2Error()",
      "",
      "[Removed Lines]",
      "3590:         ioctlRequest   = smb2.SMB2Ioctl(recvPacket['Data'])",
      "3596:                 respSMBCommand['CtlCode']      = ioctlRequest['CtlCode']",
      "3597:                 respSMBCommand['FileID']       = ioctlRequest['FileID']",
      "3598:                 respSMBCommand['InputOffset']  = 0",
      "3599:                 respSMBCommand['InputCount']   = 0",
      "3601:                 respSMBCommand['OutputCount']  = len(outputData)",
      "3602:                 respSMBCommand['Flags']        = 0",
      "3603:                 respSMBCommand['Buffer']       = outputData",
      "3607:             smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'],logging.DEBUG)",
      "",
      "[Added Lines]",
      "3648:         ioctlRequest = smb2.SMB2Ioctl(recvPacket['Data'])",
      "3654:                 respSMBCommand['CtlCode'] = ioctlRequest['CtlCode']",
      "3655:                 respSMBCommand['FileID'] = ioctlRequest['FileID']",
      "3656:                 respSMBCommand['InputOffset'] = 0",
      "3657:                 respSMBCommand['InputCount'] = 0",
      "3659:                 respSMBCommand['OutputCount'] = len(outputData)",
      "3660:                 respSMBCommand['Flags'] = 0",
      "3661:                 respSMBCommand['Buffer'] = outputData",
      "3665:             smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'], logging.DEBUG)",
      "",
      "---------------",
      "--- Hunk 92 ---",
      "[Context before]",
      "3631:     @staticmethod",
      "3632:     def default(connId, smbServer, recvPacket):",
      "3633:         # By default we return an SMB Packet with error not implemented",
      "3635:         return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED",
      "3637: class Ioctls:",
      "3640:         return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED",
      "3644:         connData = smbServer.getConnectionData(connId)",
      "3646:         ioctlResponse = ''",
      "3648:         if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:",
      "3661:         else:",
      "3662:             errorCode = STATUS_INVALID_DEVICE_REQUEST",
      "3664:         smbServer.setConnectionData(connId, connData)",
      "3665:         return ioctlResponse, errorCode",
      "3669:         connData = smbServer.getConnectionData(connId)",
      "3671:         errorCode = STATUS_SUCCESS",
      "3673:         validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])",
      "3674:         validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()",
      "3675:         validateNegotiateInfoResponse['Capabilities'] = 0",
      "3677:         validateNegotiateInfoResponse['SecurityMode'] = 1",
      "3678:         validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002",
      "",
      "[Removed Lines]",
      "3634:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)",
      "3638:    @staticmethod",
      "3639:    def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):",
      "3642:    @staticmethod",
      "3643:    def fsctlPipeTransceive(connId, smbServer, ioctlRequest):",
      "3649:              fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']",
      "3650:              errorCode = STATUS_SUCCESS",
      "3651:              try:",
      "3652:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3653:                      errorCode = STATUS_INVALID_DEVICE_REQUEST",
      "3654:                  else:",
      "3655:                      sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']",
      "3656:                      sock.sendall(ioctlRequest['Buffer'])",
      "3657:                      ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])",
      "3658:              except Exception as e:",
      "3659:                  smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)",
      "3660:                  errorCode = STATUS_ACCESS_DENIED",
      "3667:    @staticmethod",
      "3668:    def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):",
      "3676:         validateNegotiateInfoResponse['Guid'] = b'A'*16",
      "",
      "[Added Lines]",
      "3692:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)",
      "3697:     @staticmethod",
      "3698:     def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):",
      "3701:     @staticmethod",
      "3702:     def fsctlPipeTransceive(connId, smbServer, ioctlRequest):",
      "3708:             fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']",
      "3709:             errorCode = STATUS_SUCCESS",
      "3710:             try:",
      "3711:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
      "3712:                     errorCode = STATUS_INVALID_DEVICE_REQUEST",
      "3713:                 else:",
      "3714:                     sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']",
      "3715:                     sock.sendall(ioctlRequest['Buffer'])",
      "3716:                     ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])",
      "3717:             except Exception as e:",
      "3718:                 smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)",
      "3719:                 errorCode = STATUS_ACCESS_DENIED",
      "3726:     @staticmethod",
      "3727:     def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):",
      "3735:         validateNegotiateInfoResponse['Guid'] = b'A' * 16",
      "",
      "---------------",
      "--- Hunk 93 ---",
      "[Context before]",
      "3684: class SMBSERVERHandler(socketserver.BaseRequestHandler):",
      "3686:         self.__SMB = server",
      "3687:         # In case of AF_INET6 the client_address contains 4 items, ignore the last 2",
      "3688:         self.__ip, self.__port = client_address[:2]",
      "3689:         self.__request = request",
      "3690:         self.__connId = threading.currentThread().getName()",
      "3692:         self.__select_poll = select_poll",
      "3694:         socketserver.BaseRequestHandler.__init__(self, request, client_address, server)",
      "3696:     def handle(self):",
      "",
      "[Removed Lines]",
      "3685:     def __init__(self, request, client_address, server, select_poll = False):",
      "3691:         self.__timeOut = 60*5",
      "3693:         #self.__connId = os.getpid()",
      "",
      "[Added Lines]",
      "3744:     def __init__(self, request, client_address, server, select_poll=False):",
      "3750:         self.__timeOut = 60 * 5",
      "3752:         # self.__connId = os.getpid()",
      "",
      "---------------",
      "--- Hunk 94 ---",
      "[Context before]",
      "3706:                 except nmb.NetBIOSTimeout:",
      "3707:                     raise",
      "3708:                 except nmb.NetBIOSError:",
      "3711:                 if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:",
      "3721:                 else:",
      "3730:             except Exception as e:",
      "3731:                 self.__SMB.log(\"Handle: %s\" % e)",
      "3734:                 break",
      "3736:     def finish(self):",
      "",
      "[Removed Lines]",
      "3709:                     break",
      "3712:                    # Someone is requesting a session, we're gonna accept them all :)",
      "3713:                    _, rn, my = p.get_trailer().split(b' ')",
      "3714:                    remote_name = nmb.decode_name(b'\\x20'+rn)",
      "3715:                    myname = nmb.decode_name(b'\\x20'+my)",
      "3716:                    self.__SMB.log(\"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))",
      "3717:                    r = nmb.NetBIOSSessionPacket()",
      "3718:                    r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)",
      "3719:                    r.set_trailer(p.get_trailer())",
      "3720:                    self.__request.send(r.rawData())",
      "3722:                    resp = self.__SMB.processRequest(self.__connId, p.get_trailer())",
      "3723:                    # Send all the packets received. Except for big transactions this should be",
      "3724:                    # a single packet",
      "3725:                    for i in resp:",
      "3726:                        if hasattr(i, 'getData'):",
      "3727:                            session.send_packet(i.getData())",
      "3728:                        else:",
      "3729:                            session.send_packet(i)",
      "3732:                 #import traceback",
      "3733:                 #traceback.print_exc()",
      "",
      "[Added Lines]",
      "3768:                     break",
      "3771:                     # Someone is requesting a session, we're gonna accept them all :)",
      "3772:                     _, rn, my = p.get_trailer().split(b' ')",
      "3773:                     remote_name = nmb.decode_name(b'\\x20' + rn)",
      "3774:                     myname = nmb.decode_name(b'\\x20' + my)",
      "3775:                     self.__SMB.log(",
      "3776:                         \"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))",
      "3777:                     r = nmb.NetBIOSSessionPacket()",
      "3778:                     r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)",
      "3779:                     r.set_trailer(p.get_trailer())",
      "3780:                     self.__request.send(r.rawData())",
      "3782:                     resp = self.__SMB.processRequest(self.__connId, p.get_trailer())",
      "3783:                     # Send all the packets received. Except for big transactions this should be",
      "3784:                     # a single packet",
      "3785:                     for i in resp:",
      "3786:                         if hasattr(i, 'getData'):",
      "3787:                             session.send_packet(i.getData())",
      "3788:                         else:",
      "3789:                             session.send_packet(i)",
      "3792:                 # import traceback",
      "3793:                 # traceback.print_exc()",
      "",
      "---------------",
      "--- Hunk 95 ---",
      "[Context before]",
      "3739:         self.__SMB.removeConnection(self.__connId)",
      "3740:         return socketserver.BaseRequestHandler.finish(self)",
      "3742: class SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):",
      "3745:         socketserver.TCPServer.allow_reuse_address = True",
      "3746:         socketserver.TCPServer.__init__(self, server_address, handler_class)",
      "3748:         # Server name and OS to be presented whenever is necessary",
      "3751:         self.__serverDomain = ''",
      "3755:         # Our ConfigParser data",
      "3756:         self.__serverConfig = config_parser",
      "",
      "[Removed Lines]",
      "3743: #class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):",
      "3744:     def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser = None):",
      "3749:         self.__serverName   = ''",
      "3750:         self.__serverOS     = ''",
      "3752:         self.__challenge    = ''",
      "3753:         self.__log          = None",
      "",
      "[Added Lines]",
      "3804:     # class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):",
      "3805:     def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser=None):",
      "3810:         self.__serverName = ''",
      "3811:         self.__serverOS = ''",
      "3813:         self.__challenge = ''",
      "3814:         self.__log = None",
      "",
      "---------------",
      "--- Hunk 96 ---",
      "[Context before]",
      "3770:         # SMB2 Support flag = default not active",
      "3771:         self.__SMB2Support = False",
      "3773:         # Our list of commands we will answer, by default the NOT IMPLEMENTED one",
      "3774:         self.__smbCommandsHandler = SMBCommands()",
      "3778:         self.__smb2CommandsHandler = SMB2Commands()",
      "3781:         self.__smbNTTransCommands = {",
      "3784:         }",
      "3789:         }",
      "3790:         self.__smbTrans2Commands = {",
      "3798:         }",
      "3871:         # List of active connections",
      "3872:         self.__activeConnections = {}",
      "3874:     def getIoctls(self):",
      "3875:         return self.__smb2Ioctls",
      "",
      "[Removed Lines]",
      "3775:         self.__smbTrans2Handler   = TRANS2Commands()",
      "3776:         self.__smbTransHandler    = TRANSCommands()",
      "3777:         self.__smbNTTransHandler  = NTTRANSCommands()",
      "3779:         self.__IoctlHandler       = Ioctls()",
      "3782:         # NT IOCTL, can't find doc for this",
      "3783:         0xff                               :self.__smbNTTransHandler.default",
      "3786:         self.__smbTransCommands  = {",
      "3787: '\\\\PIPE\\\\LANMAN'                       :self.__smbTransHandler.lanMan,",
      "3788: smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTransHandler.transactNamedPipe,",
      "3791:  smb.SMB.TRANS2_FIND_FIRST2            :self.__smbTrans2Handler.findFirst2,",
      "3792:  smb.SMB.TRANS2_FIND_NEXT2             :self.__smbTrans2Handler.findNext2,",
      "3793:  smb.SMB.TRANS2_QUERY_FS_INFORMATION   :self.__smbTrans2Handler.queryFsInformation,",
      "3794:  smb.SMB.TRANS2_QUERY_PATH_INFORMATION :self.__smbTrans2Handler.queryPathInformation,",
      "3795:  smb.SMB.TRANS2_QUERY_FILE_INFORMATION :self.__smbTrans2Handler.queryFileInformation,",
      "3796:  smb.SMB.TRANS2_SET_FILE_INFORMATION   :self.__smbTrans2Handler.setFileInformation,",
      "3797:  smb.SMB.TRANS2_SET_PATH_INFORMATION   :self.__smbTrans2Handler.setPathInformation",
      "3800:         self.__smbCommands = {",
      "3801:  #smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush,",
      "3802:  smb.SMB.SMB_COM_CREATE_DIRECTORY:   self.__smbCommandsHandler.smbComCreateDirectory,",
      "3803:  smb.SMB.SMB_COM_DELETE_DIRECTORY:   self.__smbCommandsHandler.smbComDeleteDirectory,",
      "3804:  smb.SMB.SMB_COM_RENAME:             self.__smbCommandsHandler.smbComRename,",
      "3805:  smb.SMB.SMB_COM_DELETE:             self.__smbCommandsHandler.smbComDelete,",
      "3806:  smb.SMB.SMB_COM_NEGOTIATE:          self.__smbCommandsHandler.smbComNegotiate,",
      "3807:  smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,",
      "3808:  smb.SMB.SMB_COM_LOGOFF_ANDX:        self.__smbCommandsHandler.smbComLogOffAndX,",
      "3809:  smb.SMB.SMB_COM_TREE_CONNECT_ANDX:  self.__smbCommandsHandler.smbComTreeConnectAndX,",
      "3810:  smb.SMB.SMB_COM_TREE_DISCONNECT:    self.__smbCommandsHandler.smbComTreeDisconnect,",
      "3811:  smb.SMB.SMB_COM_ECHO:               self.__smbCommandsHandler.smbComEcho,",
      "3812:  smb.SMB.SMB_COM_QUERY_INFORMATION:  self.__smbCommandsHandler.smbQueryInformation,",
      "3813:  smb.SMB.SMB_COM_TRANSACTION2:       self.__smbCommandsHandler.smbTransaction2,",
      "3814:  smb.SMB.SMB_COM_TRANSACTION:        self.__smbCommandsHandler.smbTransaction,",
      "3815:  # Not needed for now",
      "3816:  smb.SMB.SMB_COM_NT_TRANSACT:        self.__smbCommandsHandler.smbNTTransact,",
      "3817:  smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,",
      "3818:  smb.SMB.SMB_COM_OPEN_ANDX:          self.__smbCommandsHandler.smbComOpenAndX,",
      "3819:  smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,",
      "3820:  smb.SMB.SMB_COM_READ_ANDX:          self.__smbCommandsHandler.smbComReadAndX,",
      "3821:  smb.SMB.SMB_COM_READ:               self.__smbCommandsHandler.smbComRead,",
      "3822:  smb.SMB.SMB_COM_WRITE_ANDX:         self.__smbCommandsHandler.smbComWriteAndX,",
      "3823:  smb.SMB.SMB_COM_WRITE:              self.__smbCommandsHandler.smbComWrite,",
      "3824:  smb.SMB.SMB_COM_CLOSE:              self.__smbCommandsHandler.smbComClose,",
      "3825:  smb.SMB.SMB_COM_LOCKING_ANDX:       self.__smbCommandsHandler.smbComLockingAndX,",
      "3826:  smb.SMB.SMB_COM_NT_CREATE_ANDX:     self.__smbCommandsHandler.smbComNtCreateAndX,",
      "3827:  0xFF:                               self.__smbCommandsHandler.default",
      "3828: }",
      "3830:         self.__smb2Ioctls = {",
      "3831:  smb2.FSCTL_DFS_GET_REFERRALS:            self.__IoctlHandler.fsctlDfsGetReferrals,",
      "3832: # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,",
      "3833: # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,",
      "3834:  smb2.FSCTL_PIPE_TRANSCEIVE:              self.__IoctlHandler.fsctlPipeTransceive,",
      "3835: # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,",
      "3836: # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,",
      "3837: # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,",
      "3838: # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,",
      "3839: # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,",
      "3840: # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,",
      "3841: # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,",
      "3842: # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,",
      "3843: # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,",
      "3844: # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,",
      "3845:  smb2.FSCTL_VALIDATE_NEGOTIATE_INFO:      self.__IoctlHandler.fsctlValidateNegotiateInfo,",
      "3846: }",
      "3848:         self.__smb2Commands = {",
      "3849:  smb2.SMB2_NEGOTIATE:       self.__smb2CommandsHandler.smb2Negotiate,",
      "3850:  smb2.SMB2_SESSION_SETUP:   self.__smb2CommandsHandler.smb2SessionSetup,",
      "3851:  smb2.SMB2_LOGOFF:          self.__smb2CommandsHandler.smb2Logoff,",
      "3852:  smb2.SMB2_TREE_CONNECT:    self.__smb2CommandsHandler.smb2TreeConnect,",
      "3853:  smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,",
      "3854:  smb2.SMB2_CREATE:          self.__smb2CommandsHandler.smb2Create,",
      "3855:  smb2.SMB2_CLOSE:           self.__smb2CommandsHandler.smb2Close,",
      "3856:  smb2.SMB2_FLUSH:           self.__smb2CommandsHandler.smb2Flush,",
      "3857:  smb2.SMB2_READ:            self.__smb2CommandsHandler.smb2Read,",
      "3858:  smb2.SMB2_WRITE:           self.__smb2CommandsHandler.smb2Write,",
      "3859:  smb2.SMB2_LOCK:            self.__smb2CommandsHandler.smb2Lock,",
      "3860:  smb2.SMB2_IOCTL:           self.__smb2CommandsHandler.smb2Ioctl,",
      "3861:  smb2.SMB2_CANCEL:          self.__smb2CommandsHandler.smb2Cancel,",
      "3862:  smb2.SMB2_ECHO:            self.__smb2CommandsHandler.smb2Echo,",
      "3863:  smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,",
      "3864:  smb2.SMB2_CHANGE_NOTIFY:   self.__smb2CommandsHandler.smb2ChangeNotify,",
      "3865:  smb2.SMB2_QUERY_INFO:      self.__smb2CommandsHandler.smb2QueryInfo,",
      "3866:  smb2.SMB2_SET_INFO:        self.__smb2CommandsHandler.smb2SetInfo,",
      "3867: # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,",
      "3868:  0xFF:                      self.__smb2CommandsHandler.default",
      "3869: }",
      "",
      "[Added Lines]",
      "3836:         self.__smbTrans2Handler = TRANS2Commands()",
      "3837:         self.__smbTransHandler = TRANSCommands()",
      "3838:         self.__smbNTTransHandler = NTTRANSCommands()",
      "3840:         self.__IoctlHandler = Ioctls()",
      "3843:             # NT IOCTL, can't find doc for this",
      "3844:             0xff: self.__smbNTTransHandler.default",
      "3847:         self.__smbTransCommands = {",
      "3848:             '\\\\PIPE\\\\LANMAN': self.__smbTransHandler.lanMan,",
      "3849:             smb.SMB.TRANS_TRANSACT_NMPIPE: self.__smbTransHandler.transactNamedPipe,",
      "3852:             smb.SMB.TRANS2_FIND_FIRST2: self.__smbTrans2Handler.findFirst2,",
      "3853:             smb.SMB.TRANS2_FIND_NEXT2: self.__smbTrans2Handler.findNext2,",
      "3854:             smb.SMB.TRANS2_QUERY_FS_INFORMATION: self.__smbTrans2Handler.queryFsInformation,",
      "3855:             smb.SMB.TRANS2_QUERY_PATH_INFORMATION: self.__smbTrans2Handler.queryPathInformation,",
      "3856:             smb.SMB.TRANS2_QUERY_FILE_INFORMATION: self.__smbTrans2Handler.queryFileInformation,",
      "3857:             smb.SMB.TRANS2_SET_FILE_INFORMATION: self.__smbTrans2Handler.setFileInformation,",
      "3858:             smb.SMB.TRANS2_SET_PATH_INFORMATION: self.__smbTrans2Handler.setPathInformation",
      "3861:         self.__smbCommands = {",
      "3862:             # smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush,",
      "3863:             smb.SMB.SMB_COM_CREATE_DIRECTORY: self.__smbCommandsHandler.smbComCreateDirectory,",
      "3864:             smb.SMB.SMB_COM_DELETE_DIRECTORY: self.__smbCommandsHandler.smbComDeleteDirectory,",
      "3865:             smb.SMB.SMB_COM_RENAME: self.__smbCommandsHandler.smbComRename,",
      "3866:             smb.SMB.SMB_COM_DELETE: self.__smbCommandsHandler.smbComDelete,",
      "3867:             smb.SMB.SMB_COM_NEGOTIATE: self.__smbCommandsHandler.smbComNegotiate,",
      "3868:             smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,",
      "3869:             smb.SMB.SMB_COM_LOGOFF_ANDX: self.__smbCommandsHandler.smbComLogOffAndX,",
      "3870:             smb.SMB.SMB_COM_TREE_CONNECT_ANDX: self.__smbCommandsHandler.smbComTreeConnectAndX,",
      "3871:             smb.SMB.SMB_COM_TREE_DISCONNECT: self.__smbCommandsHandler.smbComTreeDisconnect,",
      "3872:             smb.SMB.SMB_COM_ECHO: self.__smbCommandsHandler.smbComEcho,",
      "3873:             smb.SMB.SMB_COM_QUERY_INFORMATION: self.__smbCommandsHandler.smbQueryInformation,",
      "3874:             smb.SMB.SMB_COM_TRANSACTION2: self.__smbCommandsHandler.smbTransaction2,",
      "3875:             smb.SMB.SMB_COM_TRANSACTION: self.__smbCommandsHandler.smbTransaction,",
      "3876:             # Not needed for now",
      "3877:             smb.SMB.SMB_COM_NT_TRANSACT: self.__smbCommandsHandler.smbNTTransact,",
      "3878:             smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,",
      "3879:             smb.SMB.SMB_COM_OPEN_ANDX: self.__smbCommandsHandler.smbComOpenAndX,",
      "3880:             smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,",
      "3881:             smb.SMB.SMB_COM_READ_ANDX: self.__smbCommandsHandler.smbComReadAndX,",
      "3882:             smb.SMB.SMB_COM_READ: self.__smbCommandsHandler.smbComRead,",
      "3883:             smb.SMB.SMB_COM_WRITE_ANDX: self.__smbCommandsHandler.smbComWriteAndX,",
      "3884:             smb.SMB.SMB_COM_WRITE: self.__smbCommandsHandler.smbComWrite,",
      "3885:             smb.SMB.SMB_COM_CLOSE: self.__smbCommandsHandler.smbComClose,",
      "3886:             smb.SMB.SMB_COM_LOCKING_ANDX: self.__smbCommandsHandler.smbComLockingAndX,",
      "3887:             smb.SMB.SMB_COM_NT_CREATE_ANDX: self.__smbCommandsHandler.smbComNtCreateAndX,",
      "3888:             0xFF: self.__smbCommandsHandler.default",
      "3889:         }",
      "3891:         self.__smb2Ioctls = {",
      "3892:             smb2.FSCTL_DFS_GET_REFERRALS: self.__IoctlHandler.fsctlDfsGetReferrals,",
      "3893:             # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,",
      "3894:             # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,",
      "3895:             smb2.FSCTL_PIPE_TRANSCEIVE: self.__IoctlHandler.fsctlPipeTransceive,",
      "3896:             # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,",
      "3897:             # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,",
      "3898:             # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,",
      "3899:             # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,",
      "3900:             # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,",
      "3901:             # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,",
      "3902:             # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,",
      "3903:             # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,",
      "3904:             # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,",
      "3905:             # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,",
      "3906:             smb2.FSCTL_VALIDATE_NEGOTIATE_INFO: self.__IoctlHandler.fsctlValidateNegotiateInfo,",
      "3907:         }",
      "3909:         self.__smb2Commands = {",
      "3910:             smb2.SMB2_NEGOTIATE: self.__smb2CommandsHandler.smb2Negotiate,",
      "3911:             smb2.SMB2_SESSION_SETUP: self.__smb2CommandsHandler.smb2SessionSetup,",
      "3912:             smb2.SMB2_LOGOFF: self.__smb2CommandsHandler.smb2Logoff,",
      "3913:             smb2.SMB2_TREE_CONNECT: self.__smb2CommandsHandler.smb2TreeConnect,",
      "3914:             smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,",
      "3915:             smb2.SMB2_CREATE: self.__smb2CommandsHandler.smb2Create,",
      "3916:             smb2.SMB2_CLOSE: self.__smb2CommandsHandler.smb2Close,",
      "3917:             smb2.SMB2_FLUSH: self.__smb2CommandsHandler.smb2Flush,",
      "3918:             smb2.SMB2_READ: self.__smb2CommandsHandler.smb2Read,",
      "3919:             smb2.SMB2_WRITE: self.__smb2CommandsHandler.smb2Write,",
      "3920:             smb2.SMB2_LOCK: self.__smb2CommandsHandler.smb2Lock,",
      "3921:             smb2.SMB2_IOCTL: self.__smb2CommandsHandler.smb2Ioctl,",
      "3922:             smb2.SMB2_CANCEL: self.__smb2CommandsHandler.smb2Cancel,",
      "3923:             smb2.SMB2_ECHO: self.__smb2CommandsHandler.smb2Echo,",
      "3924:             smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,",
      "3925:             smb2.SMB2_CHANGE_NOTIFY: self.__smb2CommandsHandler.smb2ChangeNotify,",
      "3926:             smb2.SMB2_QUERY_INFO: self.__smb2CommandsHandler.smb2QueryInfo,",
      "3927:             smb2.SMB2_SET_INFO: self.__smb2CommandsHandler.smb2SetInfo,",
      "3928:             # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,",
      "3929:             0xFF: self.__smb2CommandsHandler.default",
      "3930:         }",
      "",
      "---------------",
      "--- Hunk 97 ---",
      "[Context before]",
      "3880:     def removeConnection(self, name):",
      "3881:         try:",
      "3883:         except:",
      "3885:         self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))",
      "3887:     def addConnection(self, name, ip, port):",
      "3888:         self.__activeConnections[name] = {}",
      "3889:         # Let's init with some know stuff we will need to have",
      "3890:         # TODO: Document what's in there",
      "3896:         self.__activeConnections[name]['ConnectedShares'] = {}",
      "3898:         # SID results for findfirst2",
      "3906:     def getActiveConnections(self):",
      "3907:         return self.__activeConnections",
      "3909:     def setConnectionData(self, connId, data):",
      "3910:         self.__activeConnections[connId] = data",
      "3915:         conn = self.__activeConnections[connId]",
      "3916:         if checkStatus is True:",
      "3917:             if ('Authenticated' in conn) is not True:",
      "",
      "[Removed Lines]",
      "3882:            del(self.__activeConnections[name])",
      "3884:            pass",
      "3891:         #print \"Current Connections\", self.__activeConnections.keys()",
      "3892:         self.__activeConnections[name]['PacketNum']       = 0",
      "3893:         self.__activeConnections[name]['ClientIP']        = ip",
      "3894:         self.__activeConnections[name]['ClientPort']      = port",
      "3895:         self.__activeConnections[name]['Uid']             = 0",
      "3897:         self.__activeConnections[name]['OpenedFiles']     = {}",
      "3899:         self.__activeConnections[name]['SIDs']            = {}",
      "3900:         self.__activeConnections[name]['LastRequest']     = {}",
      "3901:         self.__activeConnections[name]['SignatureEnabled']= False",
      "3902:         self.__activeConnections[name]['SigningChallengeResponse']= ''",
      "3903:         self.__activeConnections[name]['SigningSessionKey']= b''",
      "3904:         self.__activeConnections[name]['Authenticated']= False",
      "3911:         #print \"setConnectionData\"",
      "3912:         #print self.__activeConnections",
      "3914:     def getConnectionData(self, connId, checkStatus = True):",
      "",
      "[Added Lines]",
      "3943:             del (self.__activeConnections[name])",
      "3945:             pass",
      "3952:         # print \"Current Connections\", self.__activeConnections.keys()",
      "3953:         self.__activeConnections[name]['PacketNum'] = 0",
      "3954:         self.__activeConnections[name]['ClientIP'] = ip",
      "3955:         self.__activeConnections[name]['ClientPort'] = port",
      "3956:         self.__activeConnections[name]['Uid'] = 0",
      "3958:         self.__activeConnections[name]['OpenedFiles'] = {}",
      "3960:         self.__activeConnections[name]['SIDs'] = {}",
      "3961:         self.__activeConnections[name]['LastRequest'] = {}",
      "3962:         self.__activeConnections[name]['SignatureEnabled'] = False",
      "3963:         self.__activeConnections[name]['SigningChallengeResponse'] = ''",
      "3964:         self.__activeConnections[name]['SigningSessionKey'] = b''",
      "3965:         self.__activeConnections[name]['Authenticated'] = False",
      "3972:         # print \"setConnectionData\"",
      "3973:         # print self.__activeConnections",
      "3975:     def getConnectionData(self, connId, checkStatus=True):",
      "",
      "---------------",
      "--- Hunk 98 ---",
      "[Context before]",
      "3929:     def unregisterNamedPipe(self, pipeName):",
      "3930:         if pipeName in self.__registeredNamedPipes:",
      "3932:             return True",
      "3933:         return False",
      "3935:     def unregisterTransaction(self, transCommand):",
      "3936:         if transCommand in self.__smbTransCommands:",
      "3939:     def hookTransaction(self, transCommand, callback):",
      "3941:         # the current Transaction sub command.",
      "3942:         # (don't get confused with the Transaction smbCommand)",
      "3943:         # If the transaction sub command doesn't not exist, it is added",
      "",
      "[Removed Lines]",
      "3931:             del(self.__registeredNamedPipes[str(pipeName)])",
      "3937:            del(self.__smbTransCommands[transCommand])",
      "3940:         # If you call this function, callback will replace",
      "",
      "[Added Lines]",
      "3992:             del (self.__registeredNamedPipes[str(pipeName)])",
      "3998:             del (self.__smbTransCommands[transCommand])",
      "4001:         # If you call this function, callback will replace",
      "",
      "---------------",
      "--- Hunk 99 ---",
      "[Context before]",
      "3948:         #",
      "3949:         # WHERE:",
      "3950:         #",
      "3952:         #               the current connection",
      "3954:         #               configuration data",
      "3955:         # recvPacket  : the full SMBPacket that triggered this command",
      "3956:         # parameters  : the transaction parameters",
      "3957:         # data        : the transaction data",
      "3959:         #               with the client",
      "3960:         #",
      "3961:         # and MUST return:",
      "",
      "[Removed Lines]",
      "3951:         # connId      : the connection Id, used to grab/update information about",
      "3953:         # smbServer   : the SMBServer instance available for you to ask",
      "3958:         # maxDataCount: the max amount of data that can be transferred agreed",
      "",
      "[Added Lines]",
      "4012:         # connId      : the connection Id, used to grab/update information about",
      "4014:         # smbServer   : the SMBServer instance available for you to ask",
      "4019:         # maxDataCount: the max amount of data that can be transferred agreed",
      "",
      "---------------",
      "--- Hunk 100 ---",
      "[Context before]",
      "3966:         # respSetup: the setup response of the transaction",
      "3967:         # respParameters: the parameters response of the transaction",
      "3968:         # respData: the data response of the transaction",
      "3971:         if transCommand in self.__smbTransCommands:",
      "3973:         else:",
      "3976:         self.__smbTransCommands[transCommand] = callback",
      "3977:         return originalCommand",
      "3979:     def unregisterTransaction2(self, transCommand):",
      "3980:         if transCommand in self.__smbTrans2Commands:",
      "3983:     def hookTransaction2(self, transCommand, callback):",
      "3984:         # Here we should add to __smbTrans2Commands",
      "3985:         # Same description as Transaction",
      "3986:         if transCommand in self.__smbTrans2Commands:",
      "3988:         else:",
      "3991:         self.__smbTrans2Commands[transCommand] = callback",
      "3992:         return originalCommand",
      "3994:     def unregisterNTTransaction(self, transCommand):",
      "3995:         if transCommand in self.__smbNTTransCommands:",
      "3998:     def hookNTTransaction(self, transCommand, callback):",
      "3999:         # Here we should add to __smbNTTransCommands",
      "4000:         # Same description as Transaction",
      "4001:         if transCommand in self.__smbNTTransCommands:",
      "4003:         else:",
      "4006:         self.__smbNTTransCommands[transCommand] = callback",
      "4007:         return originalCommand",
      "4009:     def unregisterSmbCommand(self, smbCommand):",
      "4010:         if smbCommand in self.__smbCommands:",
      "4013:     def hookSmbCommand(self, smbCommand, callback):",
      "4014:         # Here we should add to self.__smbCommands",
      "4016:         # the current smbCommand.",
      "4017:         # If smbCommand doesn't not exist, it is added",
      "4018:         # If SMB command exists, it returns the original function replaced",
      "",
      "[Removed Lines]",
      "3969:         # errorCode: the NT error code",
      "3972:            originalCommand = self.__smbTransCommands[transCommand]",
      "3974:            originalCommand = None",
      "3981:            del(self.__smbTrans2Commands[transCommand])",
      "3987:            originalCommand = self.__smbTrans2Commands[transCommand]",
      "3989:            originalCommand = None",
      "3996:            del(self.__smbNTTransCommands[transCommand])",
      "4002:            originalCommand = self.__smbNTTransCommands[transCommand]",
      "4004:            originalCommand = None",
      "4011:            del(self.__smbCommands[smbCommand])",
      "4015:         # If you call this function, callback will replace",
      "",
      "[Added Lines]",
      "4030:         # errorCode: the NT error code",
      "4033:             originalCommand = self.__smbTransCommands[transCommand]",
      "4035:             originalCommand = None",
      "4042:             del (self.__smbTrans2Commands[transCommand])",
      "4048:             originalCommand = self.__smbTrans2Commands[transCommand]",
      "4050:             originalCommand = None",
      "4057:             del (self.__smbNTTransCommands[transCommand])",
      "4063:             originalCommand = self.__smbNTTransCommands[transCommand]",
      "4065:             originalCommand = None",
      "4072:             del (self.__smbCommands[smbCommand])",
      "4076:         # If you call this function, callback will replace",
      "",
      "---------------",
      "--- Hunk 101 ---",
      "[Context before]",
      "4022:         #",
      "4023:         # WHERE:",
      "4024:         #",
      "4026:         #             the current connection",
      "4028:         #             configuration data",
      "4030:         #             Check smb.py:SMBCommand() for a reference",
      "4031:         # recvPacket: the full SMBPacket that triggered this command",
      "4032:         #",
      "4033:         # and MUST return:",
      "4034:         # <list of respSMBCommands>, <list of packets>, errorCode",
      "4038:         #",
      "4039:         # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT",
      "4040:         # the callback function is slightly different:",
      "",
      "[Removed Lines]",
      "4025:         # connId    : the connection Id, used to grab/update information about",
      "4027:         # smbServer : the SMBServer instance available for you to ask",
      "4029:         # SMBCommand: the SMBCommand itself, with its data and parameters.",
      "4035:         # <list of packets> has higher preference over commands, in case you",
      "4036:         # want to change the whole packet",
      "4037:         # errorCode: the NT error code",
      "",
      "[Added Lines]",
      "4086:         # connId    : the connection Id, used to grab/update information about",
      "4088:         # smbServer : the SMBServer instance available for you to ask",
      "4090:         # SMBCommand: the SMBCommand itself, with its data and parameters.",
      "4096:         # <list of packets> has higher preference over commands, in case you",
      "4097:         # want to change the whole packet",
      "4098:         # errorCode: the NT error code",
      "",
      "---------------",
      "--- Hunk 102 ---",
      "[Context before]",
      "4042:         # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)",
      "4043:         #",
      "4044:         # WHERE:",
      "4046:         # transCommands: a list of transaction subcommands already registered",
      "4047:         #",
      "4049:         if smbCommand in self.__smbCommands:",
      "4051:         else:",
      "4054:         self.__smbCommands[smbCommand] = callback",
      "4055:         return originalCommand",
      "4057:     def unregisterSmb2Command(self, smb2Command):",
      "4058:         if smb2Command in self.__smb2Commands:",
      "4061:     def hookSmb2Command(self, smb2Command, callback):",
      "4062:         if smb2Command in self.__smb2Commands:",
      "4064:         else:",
      "4067:         self.__smb2Commands[smb2Command] = callback",
      "4068:         return originalCommand",
      "4070:     def log(self, msg, level=logging.INFO):",
      "4073:     def getServerName(self):",
      "4074:         return self.__serverName",
      "4076:     def getServerOS(self):",
      "4077:         return self.__serverOS",
      "4079:     def getServerDomain(self):",
      "4080:         return self.__serverDomain",
      "4082:     def getSMBChallenge(self):",
      "4083:         return self.__challenge",
      "4085:     def getServerConfig(self):",
      "4086:         return self.__serverConfig",
      "",
      "[Removed Lines]",
      "4045:         #",
      "4050:            originalCommand = self.__smbCommands[smbCommand]",
      "4052:            originalCommand = None",
      "4059:            del(self.__smb2Commands[smb2Command])",
      "4063:            originalCommand = self.__smb2Commands[smb2Command]",
      "4065:            originalCommand = None",
      "4071:         self.__log.log(level,msg)",
      "",
      "[Added Lines]",
      "4106:         #",
      "4111:             originalCommand = self.__smbCommands[smbCommand]",
      "4113:             originalCommand = None",
      "4120:             del (self.__smb2Commands[smb2Command])",
      "4124:             originalCommand = self.__smb2Commands[smb2Command]",
      "4126:             originalCommand = None",
      "4132:         self.__log.log(level, msg)",
      "",
      "---------------",
      "--- Hunk 103 ---",
      "[Context before]",
      "4116:         # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,",
      "4117:         # after which the message can be transmitted.",
      "4121:         # Sign with the sequence",
      "4122:         m = hashlib.md5()",
      "4125:         if hasattr(packet, 'getData'):",
      "4127:         else:",
      "4129:         # Replace sequence with acual hash",
      "4130:         packet['SecurityFeatures'] = m.digest()[:8]",
      "4133:     def signSMBv2(self, packet, signingSessionKey):",
      "4135:         packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED",
      "4136:         signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()",
      "4137:         packet['Signature'] = signature[:16]",
      "4140:     def processRequest(self, connId, data):",
      "4142:         # TODO: Process batched commands.",
      "4145:         try:",
      "4148:         except:",
      "4149:             # Maybe a SMB2 packet?",
      "4151:             connData = self.getConnectionData(connId, False)",
      "4152:             self.signSMBv2(packet, connData['SigningSessionKey'])",
      "4153:             isSMB2 = True",
      "4157:         # We might have compound requests",
      "4158:         compoundedPacketsResponse = []",
      "4160:         try:",
      "4161:             # Search out list of implemented commands",
      "4162:             # We provide them with:",
      "",
      "[Removed Lines]",
      "4119:         #print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)",
      "4120:         packet['SecurityFeatures'] = struct.pack('<q',connData['SignSequenceNumber'])",
      "4123:         m.update( signingSessionKey )",
      "4124:         m.update( signingChallengeResponse )",
      "4126:             m.update( packet.getData() )",
      "4128:             m.update( packet )",
      "4131:         connData['SignSequenceNumber'] +=2",
      "4134:         packet['Signature'] = b'\\x00'*16",
      "4138:         #print \"%s\" % packet['Signature'].encode('hex')",
      "4143:         isSMB2      = False",
      "4144:         SMBCommand  = None",
      "4146:             packet = smb.NewSMBPacket(data = data)",
      "4147:             SMBCommand  = smb.SMBCommand(packet['Data'][0])",
      "4150:             packet = smb2.SMB2Packet(data = data)",
      "4155:         connData    = self.getConnectionData(connId, False)",
      "4159:         compoundedPackets         = []",
      "",
      "[Added Lines]",
      "4180:         # print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)",
      "4181:         packet['SecurityFeatures'] = struct.pack('<q', connData['SignSequenceNumber'])",
      "4184:         m.update(signingSessionKey)",
      "4185:         m.update(signingChallengeResponse)",
      "4187:             m.update(packet.getData())",
      "4189:             m.update(packet)",
      "4192:         connData['SignSequenceNumber'] += 2",
      "4195:         packet['Signature'] = b'\\x00' * 16",
      "4199:         # print \"%s\" % packet['Signature'].encode('hex')",
      "4204:         isSMB2 = False",
      "4205:         SMBCommand = None",
      "4207:             packet = smb.NewSMBPacket(data=data)",
      "4208:             SMBCommand = smb.SMBCommand(packet['Data'][0])",
      "4211:             packet = smb2.SMB2Packet(data=data)",
      "4216:         connData = self.getConnectionData(connId, False)",
      "4220:         compoundedPackets = []",
      "",
      "---------------",
      "--- Hunk 104 ---",
      "[Context before]",
      "4173:             # errorCode   : self explanatory",
      "4174:             if isSMB2 is False:",
      "4175:                 # Is the client authenticated already?",
      "4177:                     # Nope.. in that case he should only ask for a few commands, if not throw him out.",
      "4178:                     errorCode = STATUS_ACCESS_DENIED",
      "4179:                     respPackets = None",
      "",
      "[Removed Lines]",
      "4176:                 if connData['Authenticated'] is False and packet['Command'] not in (smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):",
      "",
      "[Added Lines]",
      "4237:                 if connData['Authenticated'] is False and packet['Command'] not in (",
      "4238:                 smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):",
      "",
      "---------------",
      "--- Hunk 105 ---",
      "[Context before]",
      "4181:                 else:",
      "4182:                     if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:",
      "4183:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4189:                     elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:",
      "4190:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4196:                     elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:",
      "4197:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4203:                     else:",
      "4204:                         if packet['Command'] in self.__smbCommands:",
      "4234:                         else:",
      "4237:                 compoundedPacketsResponse.append((respCommands, respPackets, errorCode))",
      "4238:                 compoundedPackets.append(packet)",
      "4240:             else:",
      "4241:                 # Is the client authenticated already?",
      "4243:                     # Nope.. in that case he should only ask for a few commands, if not throw him out.",
      "4244:                     errorCode = STATUS_ACCESS_DENIED",
      "4245:                     respPackets = None",
      "",
      "[Removed Lines]",
      "4184:                                       connId,",
      "4185:                                       self,",
      "4186:                                       SMBCommand,",
      "4187:                                       packet,",
      "4188:                                       self.__smbTrans2Commands)",
      "4191:                                       connId,",
      "4192:                                       self,",
      "4193:                                       SMBCommand,",
      "4194:                                       packet,",
      "4195:                                       self.__smbNTTransCommands)",
      "4198:                                       connId,",
      "4199:                                       self,",
      "4200:                                       SMBCommand,",
      "4201:                                       packet,",
      "4202:                                       self.__smbTransCommands)",
      "4205:                            if self.__SMB2Support is True:",
      "4206:                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:",
      "4207:                                    try:",
      "4208:                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](connId, self, packet, True)",
      "4209:                                        isSMB2 = True",
      "4210:                                    except Exception as e:",
      "4211:                                        import traceback",
      "4212:                                        traceback.print_exc()",
      "4213:                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)",
      "4214:                                        # If something went wrong, let's fallback to SMB1",
      "4215:                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4216:                                            connId,",
      "4217:                                            self,",
      "4218:                                            SMBCommand,",
      "4219:                                            packet)",
      "4220:                                        #self.__SMB2Support = False",
      "4221:                                        pass",
      "4222:                                else:",
      "4223:                                    respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4224:                                            connId,",
      "4225:                                            self,",
      "4226:                                            SMBCommand,",
      "4227:                                            packet)",
      "4228:                            else:",
      "4229:                                respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4230:                                            connId,",
      "4231:                                            self,",
      "4232:                                            SMBCommand,",
      "4233:                                            packet)",
      "4235:                            respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand, packet)",
      "4242:                 if connData['Authenticated'] is False and packet['Command'] not in (smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):",
      "",
      "[Added Lines]",
      "4246:                             connId,",
      "4247:                             self,",
      "4248:                             SMBCommand,",
      "4249:                             packet,",
      "4250:                             self.__smbTrans2Commands)",
      "4253:                             connId,",
      "4254:                             self,",
      "4255:                             SMBCommand,",
      "4256:                             packet,",
      "4257:                             self.__smbNTTransCommands)",
      "4260:                             connId,",
      "4261:                             self,",
      "4262:                             SMBCommand,",
      "4263:                             packet,",
      "4264:                             self.__smbTransCommands)",
      "4267:                             if self.__SMB2Support is True:",
      "4268:                                 if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:",
      "4269:                                     try:",
      "4270:                                         respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](",
      "4271:                                             connId, self, packet, True)",
      "4272:                                         isSMB2 = True",
      "4273:                                     except Exception as e:",
      "4274:                                         import traceback",
      "4275:                                         traceback.print_exc()",
      "4276:                                         self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)",
      "4277:                                         # If something went wrong, let's fallback to SMB1",
      "4278:                                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4279:                                             connId,",
      "4280:                                             self,",
      "4281:                                             SMBCommand,",
      "4282:                                             packet)",
      "4283:                                         # self.__SMB2Support = False",
      "4284:                                         pass",
      "4285:                                 else:",
      "4286:                                     respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4287:                                         connId,",
      "4288:                                         self,",
      "4289:                                         SMBCommand,",
      "4290:                                         packet)",
      "4291:                             else:",
      "4292:                                 respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
      "4293:                                     connId,",
      "4294:                                     self,",
      "4295:                                     SMBCommand,",
      "4296:                                     packet)",
      "4298:                             respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand,",
      "4299:                                                                                            packet)",
      "4306:                 if connData['Authenticated'] is False and packet['Command'] not in (",
      "4307:                 smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):",
      "",
      "---------------",
      "--- Hunk 106 ---",
      "[Context before]",
      "4250:                     done = False",
      "4251:                     while not done:",
      "4252:                         if packet['Command'] in self.__smb2Commands:",
      "4260:                         else:",
      "4262:                         # Let's store the result for this compounded packet",
      "4263:                         compoundedPacketsResponse.append((respCommands, respPackets, errorCode))",
      "4264:                         compoundedPackets.append(packet)",
      "4265:                         if packet['NextCommand'] != 0:",
      "4266:                             data = data[packet['NextCommand']:]",
      "4268:                         else:",
      "4269:                             done = True",
      "4271:         except Exception as e:",
      "4274:             # Something wen't wrong, defaulting to Bad user ID",
      "4276:             raise",
      "4278:         # We prepare the response packet to commands don't need to bother about that.",
      "4281:         # Force reconnection loop.. This is just a test.. client will send me back credentials :)",
      "4284:         #    connData['PacketNum'] = 0",
      "4285:         #    # Something wen't wrong, defaulting to Bad user ID",
      "4286:         #    self.log('Sending BAD USER ID!', logging.ERROR)",
      "",
      "[Removed Lines]",
      "4253:                            if self.__SMB2Support is True:",
      "4254:                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](",
      "4255:                                        connId,",
      "4256:                                        self,",
      "4257:                                        packet)",
      "4258:                            else:",
      "4259:                                respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
      "4261:                            respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
      "4267:                             packet = smb2.SMB2Packet(data = data)",
      "4272:             #import traceback",
      "4273:             #traceback.print_exc()",
      "4275:             self.log('processRequest (0x%x,%s)' % (packet['Command'],e), logging.ERROR)",
      "4279:         connData    = self.getConnectionData(connId, False)",
      "4282:         #connData['PacketNum'] += 1",
      "4283:         #if connData['PacketNum'] == 15:",
      "",
      "[Added Lines]",
      "4318:                             if self.__SMB2Support is True:",
      "4319:                                 respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](",
      "4320:                                     connId,",
      "4321:                                     self,",
      "4322:                                     packet)",
      "4323:                             else:",
      "4324:                                 respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
      "4326:                             respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
      "4332:                             packet = smb2.SMB2Packet(data=data)",
      "4337:             # import traceback",
      "4338:             # traceback.print_exc()",
      "4340:             self.log('processRequest (0x%x,%s)' % (packet['Command'], e), logging.ERROR)",
      "4344:         connData = self.getConnectionData(connId, False)",
      "4347:         # connData['PacketNum'] += 1",
      "4348:         # if connData['PacketNum'] == 15:",
      "",
      "---------------",
      "--- Hunk 107 ---",
      "[Context before]",
      "4292:         #    packet['ErrorClass']  = errorCode & 0xff",
      "4293:         #    return [packet]",
      "4297:         packetsToSend = []",
      "4298:         for packetNum in range(len(compoundedPacketsResponse)):",
      "",
      "[Removed Lines]",
      "4295:         self.setConnectionData(connId, connData)",
      "",
      "[Added Lines]",
      "4360:         self.setConnectionData(connId, connData)",
      "",
      "---------------",
      "--- Hunk 108 ---",
      "[Context before]",
      "4301:             if respPackets is None:",
      "4302:                 for respCommand in respCommands:",
      "4303:                     if isSMB2 is False:",
      "4305:                         respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY",
      "4307:                         # TODO this should come from a per session configuration",
      "4322:                         respPacket.addCommand(respCommand)",
      "4324:                         if connData['SignatureEnabled']:",
      "4325:                             respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE",
      "4328:                         packetsToSend.append(respPacket)",
      "4329:                     else:",
      "4330:                         respPacket = smb2.SMB2Packet()",
      "4332:                         if packetNum > 0:",
      "4333:                             respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS",
      "4335:                         respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']",
      "4337:                         respPacket['CreditCharge'] = packet['CreditCharge']",
      "4340:                         respPacket['SessionID'] = connData['Uid']",
      "4341:                         respPacket['MessageID'] = packet['MessageID']",
      "4343:                         if hasattr(respCommand, 'getData'):",
      "4345:                         else:",
      "4348:                         if connData['SignatureEnabled']:",
      "4349:                             self.signSMBv2(respPacket, connData['SigningSessionKey'])",
      "",
      "[Removed Lines]",
      "4304:                         respPacket           = smb.NewSMBPacket()",
      "4308:                         respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | packet['Flags2'] & smb.SMB.FLAGS2_UNICODE",
      "4309:                         #respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES",
      "4310:                         #respPacket['Flags1'] = 0x98",
      "4311:                         #respPacket['Flags2'] = 0xc807",
      "4314:                         respPacket['Tid']    = packet['Tid']",
      "4315:                         respPacket['Mid']    = packet['Mid']",
      "4316:                         respPacket['Pid']    = packet['Pid']",
      "4317:                         respPacket['Uid']    = connData['Uid']",
      "4319:                         respPacket['ErrorCode']   = errorCode >> 16",
      "4320:                         respPacket['_reserved']   = errorCode >> 8 & 0xff",
      "4321:                         respPacket['ErrorClass']  = errorCode & 0xff",
      "4326:                             self.signSMBv1(connData, respPacket, connData['SigningSessionKey'], connData['SigningChallengeResponse'])",
      "4331:                         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "4334:                         respPacket['Status']    = errorCode",
      "4336:                         respPacket['Command']   = packet['Command']",
      "4338:                         #respPacket['CreditCharge'] = 0",
      "4339:                         respPacket['Reserved']  = packet['Reserved']",
      "4342:                         respPacket['TreeID']    = packet['TreeID']",
      "4344:                             respPacket['Data']      = respCommand.getData()",
      "4346:                             respPacket['Data']      = str(respCommand)",
      "",
      "[Added Lines]",
      "4369:                         respPacket = smb.NewSMBPacket()",
      "4373:                         respPacket[",
      "4374:                             'Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\",
      "4375:                                         packet['Flags2'] & smb.SMB.FLAGS2_UNICODE",
      "4376:                         # respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES",
      "4377:                         # respPacket['Flags1'] = 0x98",
      "4378:                         # respPacket['Flags2'] = 0xc807",
      "4380:                         respPacket['Tid'] = packet['Tid']",
      "4381:                         respPacket['Mid'] = packet['Mid']",
      "4382:                         respPacket['Pid'] = packet['Pid']",
      "4383:                         respPacket['Uid'] = connData['Uid']",
      "4385:                         respPacket['ErrorCode'] = errorCode >> 16",
      "4386:                         respPacket['_reserved'] = errorCode >> 8 & 0xff",
      "4387:                         respPacket['ErrorClass'] = errorCode & 0xff",
      "4392:                             self.signSMBv1(connData, respPacket, connData['SigningSessionKey'],",
      "4393:                                            connData['SigningChallengeResponse'])",
      "4398:                         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
      "4401:                         respPacket['Status'] = errorCode",
      "4403:                         respPacket['Command'] = packet['Command']",
      "4405:                         # respPacket['CreditCharge'] = 0",
      "4406:                         respPacket['Reserved'] = packet['Reserved']",
      "4409:                         respPacket['TreeID'] = packet['TreeID']",
      "4411:                             respPacket['Data'] = respCommand.getData()",
      "4413:                             respPacket['Data'] = str(respCommand)",
      "",
      "---------------",
      "--- Hunk 109 ---",
      "[Context before]",
      "4357:             # Let's build a compound answer",
      "4358:             finalData = b''",
      "4359:             i = 0",
      "4361:                 packet = packetsToSend[i]",
      "4362:                 # Align to 8-bytes",
      "4364:                 packet['NextCommand'] = len(packet) + padLen",
      "4365:                 if hasattr(packet, 'getData'):",
      "4367:                 else:",
      "4370:             # Last one",
      "4373:             else:",
      "4375:             packetsToSend = [finalData]",
      "4377:         # We clear the compound requests",
      "",
      "[Removed Lines]",
      "4360:             for i in range(len(packetsToSend)-1):",
      "4363:                 padLen = (8 - (len(packet) % 8) ) % 8",
      "4366:                     finalData += packet.getData() + padLen*b'\\x00'",
      "4368:                     finalData += packet + padLen*b'\\x00'",
      "4371:             if hasattr(packetsToSend[len(packetsToSend)-1], 'getData'):",
      "4372:                 finalData += packetsToSend[len(packetsToSend)-1].getData()",
      "4374:                 finalData += packetsToSend[len(packetsToSend)-1]",
      "",
      "[Added Lines]",
      "4427:             for i in range(len(packetsToSend) - 1):",
      "4430:                 padLen = (8 - (len(packet) % 8)) % 8",
      "4433:                     finalData += packet.getData() + padLen * b'\\x00'",
      "4435:                     finalData += packet + padLen * b'\\x00'",
      "4438:             if hasattr(packetsToSend[len(packetsToSend) - 1], 'getData'):",
      "4439:                 finalData += packetsToSend[len(packetsToSend) - 1].getData()",
      "4441:                 finalData += packetsToSend[len(packetsToSend) - 1]",
      "",
      "---------------",
      "--- Hunk 110 ---",
      "[Context before]",
      "4380:         return packetsToSend",
      "4383:         # TODO: Do a real config parser",
      "4384:         if self.__serverConfig is None:",
      "4385:             if configFile is None:",
      "",
      "[Removed Lines]",
      "4382:     def processConfigFile(self, configFile = None):",
      "",
      "[Added Lines]",
      "4449:     def processConfigFile(self, configFile=None):",
      "",
      "---------------",
      "--- Hunk 111 ---",
      "[Context before]",
      "4387:             self.__serverConfig = configparser.ConfigParser()",
      "4388:             self.__serverConfig.read(configFile)",
      "4394:         if self.__serverConfig.has_option('global', 'challenge'):",
      "4396:         else:",
      "4399:         if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):",
      "4400:             self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")",
      "4402:         if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):",
      "4404:         else:",
      "4405:             self.__SMB2Support = False",
      "4407:         if self.__logFile != 'None':",
      "4414:         # Process the credentials",
      "4416:         if credentials_fname != \"\":",
      "4417:             cred = open(credentials_fname)",
      "4418:             line = cred.readline()",
      "",
      "[Removed Lines]",
      "4390:         self.__serverName   = self.__serverConfig.get('global','server_name')",
      "4391:         self.__serverOS     = self.__serverConfig.get('global','server_os')",
      "4392:         self.__serverDomain = self.__serverConfig.get('global','server_domain')",
      "4393:         self.__logFile      = self.__serverConfig.get('global','log_file')",
      "4395:             self.__challenge    = unhexlify(self.__serverConfig.get('global', 'challenge'))",
      "4397:             self.__challenge    = b'A'*16",
      "4403:             self.__SMB2Support = self.__serverConfig.getboolean(\"global\",\"SMB2Support\")",
      "4408:             logging.basicConfig(filename = self.__logFile,",
      "4409:                              level = logging.DEBUG,",
      "4410:                              format=\"%(asctime)s: %(levelname)s: %(message)s\",",
      "4411:                              datefmt = '%m/%d/%Y %I:%M:%S %p')",
      "4412:         self.__log        = LOG",
      "4415:         credentials_fname = self.__serverConfig.get('global','credentials_file')",
      "",
      "[Added Lines]",
      "4457:         self.__serverName = self.__serverConfig.get('global', 'server_name')",
      "4458:         self.__serverOS = self.__serverConfig.get('global', 'server_os')",
      "4459:         self.__serverDomain = self.__serverConfig.get('global', 'server_domain')",
      "4460:         self.__logFile = self.__serverConfig.get('global', 'log_file')",
      "4462:             self.__challenge = unhexlify(self.__serverConfig.get('global', 'challenge'))",
      "4464:             self.__challenge = b'A' * 16",
      "4470:             self.__SMB2Support = self.__serverConfig.getboolean(\"global\", \"SMB2Support\")",
      "4475:             logging.basicConfig(filename=self.__logFile,",
      "4476:                                 level=logging.DEBUG,",
      "4477:                                 format=\"%(asctime)s: %(levelname)s: %(message)s\",",
      "4478:                                 datefmt='%m/%d/%Y %I:%M:%S %p')",
      "4479:         self.__log = LOG",
      "4482:         credentials_fname = self.__serverConfig.get('global', 'credentials_file')",
      "",
      "---------------",
      "--- Hunk 112 ---",
      "[Context before]",
      "4430:                 lmhash = '0%s' % lmhash",
      "4431:             if len(nthash) % 2:",
      "4432:                 nthash = '0%s' % nthash",
      "4434:                 lmhash = a2b_hex(lmhash)",
      "4435:                 nthash = a2b_hex(nthash)",
      "4436:             except:",
      "4437:                 pass",
      "4438:         self.__credentials[name.lower()] = (uid, lmhash, nthash)",
      "4440: # For windows platforms, opening a directory is not an option, so we set a void FD",
      "4441: VOID_FILE_DESCRIPTOR = -1",
      "4442: PIPE_FILE_DESCRIPTOR = -2",
      "",
      "[Removed Lines]",
      "4433:             try: # just in case they were converted already",
      "",
      "[Added Lines]",
      "4500:             try:  # just in case they were converted already",
      "",
      "---------------",
      "--- Hunk 113 ---",
      "[Context before]",
      "4448: from impacket.dcerpc.v5.rpcrt import DCERPCServer",
      "4449: from impacket.dcerpc.v5.dtypes import NULL",
      "4451: from impacket.dcerpc.v5.wkst import NetrWkstaGetInfo, NetrWkstaGetInfoResponse",
      "4452: from impacket.system_errors import ERROR_INVALID_LEVEL",
      "4454: class WKSTServer(DCERPCServer):",
      "4455:     def __init__(self):",
      "4456:         DCERPCServer.__init__(self)",
      "4457:         self.wkssvcCallBacks = {",
      "4458:             0: self.NetrWkstaGetInfo,",
      "4459:         }",
      "4463:         request = NetrWkstaGetInfo(data)",
      "4464:         self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])",
      "",
      "[Removed Lines]",
      "4450: from impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse",
      "4460:         self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'),'\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)",
      "4462:     def NetrWkstaGetInfo(self,data):",
      "",
      "[Added Lines]",
      "4518: from impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, \\",
      "4519:     NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse",
      "4530:         self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'), '\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)",
      "4532:     def NetrWkstaGetInfo(self, data):",
      "",
      "---------------",
      "--- Hunk 114 ---",
      "[Context before]",
      "4503:             21: self.NetrServerGetInfo,",
      "4504:         }",
      "4508:     def setServerConfig(self, config):",
      "4509:         self.__serverConfig = config",
      "4511:     def processConfigFile(self, configFile=None):",
      "4568:     def NetrShareEnum(self, data):",
      "4587: class SimpleSMBServer:",
      "4588:     \"\"\"",
      "",
      "[Removed Lines]",
      "4506:         self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'),'\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)",
      "4512:        if configFile is not None:",
      "4513:            self.__serverConfig = configparser.ConfigParser()",
      "4514:            self.__serverConfig.read(configFile)",
      "4515:        sections = self.__serverConfig.sections()",
      "4516:        # Let's check the log file",
      "4517:        self.__logFile      = self.__serverConfig.get('global','log_file')",
      "4518:        if self.__logFile != 'None':",
      "4519:             logging.basicConfig(filename = self.__logFile,",
      "4520:                              level = logging.DEBUG,",
      "4521:                              format=\"%(asctime)s: %(levelname)s: %(message)s\",",
      "4522:                              datefmt = '%m/%d/%Y %I:%M:%S %p')",
      "4524:        # Remove the global one",
      "4525:        del(sections[sections.index('global')])",
      "4526:        self._shares = {}",
      "4527:        for i in sections:",
      "4528:            self._shares[i] = dict(self.__serverConfig.items(i))",
      "4530:     def NetrShareGetInfo(self,data):",
      "4531:        request = NetrShareGetInfo(data)",
      "4532:        self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])",
      "4534:        s = request['NetName'][:-1].upper()",
      "4535:        answer = NetrShareGetInfoResponse()",
      "4536:        if s in self._shares:",
      "4537:            share  = self._shares[s]",
      "4539:            answer['InfoStruct']['tag'] = 1",
      "4540:            answer['InfoStruct']['ShareInfo1']['shi1_netname']= s+'\\x00'",
      "4541:            answer['InfoStruct']['ShareInfo1']['shi1_type']   = share['share type']",
      "4542:            answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment']+'\\x00'",
      "4543:            answer['ErrorCode'] = 0",
      "4544:        else:",
      "4545:            answer['InfoStruct']['tag'] = 1",
      "4546:            answer['InfoStruct']['ShareInfo1']= NULL",
      "4547:            answer['ErrorCode'] = 0x0906 #WERR_NET_NAME_NOT_FOUND",
      "4549:        return answer",
      "4551:     def NetrServerGetInfo(self,data):",
      "4552:        request = NetrServerGetInfo(data)",
      "4553:        self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])",
      "4554:        answer = NetrServerGetInfoResponse()",
      "4555:        answer['InfoStruct']['tag'] = 101",
      "4556:        # PLATFORM_ID_NT = 500",
      "4557:        answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500",
      "4558:        answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']",
      "4559:        # Windows 7 = 6.1",
      "4560:        answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6",
      "4561:        answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1",
      "4562:        # Workstation = 1",
      "4563:        answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1",
      "4564:        answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL",
      "4565:        answer['ErrorCode'] = 0",
      "4566:        return answer",
      "4569:        request = NetrShareEnum(data)",
      "4570:        self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])",
      "4571:        shareEnum = NetrShareEnumResponse()",
      "4572:        shareEnum['InfoStruct']['Level'] = 1",
      "4573:        shareEnum['InfoStruct']['ShareInfo']['tag'] = 1",
      "4574:        shareEnum['TotalEntries'] = len(self._shares)",
      "4575:        shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)",
      "4576:        shareEnum['ErrorCode'] = 0",
      "4578:        for i in self._shares:",
      "4579:            shareInfo = SHARE_INFO_1()",
      "4580:            shareInfo['shi1_netname'] = i+'\\x00'",
      "4581:            shareInfo['shi1_type'] = self._shares[i]['share type']",
      "4582:            shareInfo['shi1_remark'] = self._shares[i]['comment']+'\\x00'",
      "4583:            shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)",
      "4585:        return shareEnum",
      "",
      "[Added Lines]",
      "4577:         self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'), '\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)",
      "4583:         if configFile is not None:",
      "4584:             self.__serverConfig = configparser.ConfigParser()",
      "4585:             self.__serverConfig.read(configFile)",
      "4586:         sections = self.__serverConfig.sections()",
      "4587:         # Let's check the log file",
      "4588:         self.__logFile = self.__serverConfig.get('global', 'log_file')",
      "4589:         if self.__logFile != 'None':",
      "4590:             logging.basicConfig(filename=self.__logFile,",
      "4591:                                 level=logging.DEBUG,",
      "4592:                                 format=\"%(asctime)s: %(levelname)s: %(message)s\",",
      "4593:                                 datefmt='%m/%d/%Y %I:%M:%S %p')",
      "4595:         # Remove the global one",
      "4596:         del (sections[sections.index('global')])",
      "4597:         self._shares = {}",
      "4598:         for i in sections:",
      "4599:             self._shares[i] = dict(self.__serverConfig.items(i))",
      "4601:     def NetrShareGetInfo(self, data):",
      "4602:         request = NetrShareGetInfo(data)",
      "4603:         self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])",
      "4605:         s = request['NetName'][:-1].upper()",
      "4606:         answer = NetrShareGetInfoResponse()",
      "4607:         if s in self._shares:",
      "4608:             share = self._shares[s]",
      "4610:             answer['InfoStruct']['tag'] = 1",
      "4611:             answer['InfoStruct']['ShareInfo1']['shi1_netname'] = s + '\\x00'",
      "4612:             answer['InfoStruct']['ShareInfo1']['shi1_type'] = share['share type']",
      "4613:             answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment'] + '\\x00'",
      "4614:             answer['ErrorCode'] = 0",
      "4615:         else:",
      "4616:             answer['InfoStruct']['tag'] = 1",
      "4617:             answer['InfoStruct']['ShareInfo1'] = NULL",
      "4618:             answer['ErrorCode'] = 0x0906  # WERR_NET_NAME_NOT_FOUND",
      "4620:         return answer",
      "4622:     def NetrServerGetInfo(self, data):",
      "4623:         request = NetrServerGetInfo(data)",
      "4624:         self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])",
      "4625:         answer = NetrServerGetInfoResponse()",
      "4626:         answer['InfoStruct']['tag'] = 101",
      "4627:         # PLATFORM_ID_NT = 500",
      "4628:         answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500",
      "4629:         answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']",
      "4630:         # Windows 7 = 6.1",
      "4631:         answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6",
      "4632:         answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1",
      "4633:         # Workstation = 1",
      "4634:         answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1",
      "4635:         answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL",
      "4636:         answer['ErrorCode'] = 0",
      "4637:         return answer",
      "4640:         request = NetrShareEnum(data)",
      "4641:         self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])",
      "4642:         shareEnum = NetrShareEnumResponse()",
      "4643:         shareEnum['InfoStruct']['Level'] = 1",
      "4644:         shareEnum['InfoStruct']['ShareInfo']['tag'] = 1",
      "4645:         shareEnum['TotalEntries'] = len(self._shares)",
      "4646:         shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)",
      "4647:         shareEnum['ErrorCode'] = 0",
      "4649:         for i in self._shares:",
      "4650:             shareInfo = SHARE_INFO_1()",
      "4651:             shareInfo['shi1_netname'] = i + '\\x00'",
      "4652:             shareInfo['shi1_type'] = self._shares[i]['share type']",
      "4653:             shareInfo['shi1_remark'] = self._shares[i]['comment'] + '\\x00'",
      "4654:             shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)",
      "4656:         return shareEnum",
      "",
      "---------------",
      "--- Hunk 115 ---",
      "[Context before]",
      "4592:     :param integer listenPort: the port number you want the server to listen on",
      "4593:     :param string configFile: a file with all the servers' configuration. If no file specified, this class will create the basic parameters needed to run. You will need to add your shares manually tho. See addShare() method",
      "4594:     \"\"\"",
      "4596:         if configFile != '':",
      "4598:             self.__server.processConfigFile(configFile)",
      "4599:             self.__smbConfig = None",
      "4600:         else:",
      "4601:             # Here we write a mini config for the server",
      "4602:             self.__smbConfig = configparser.ConfigParser()",
      "4603:             self.__smbConfig.add_section('global')",
      "4614:             # IPC always needed",
      "4615:             self.__smbConfig.add_section('IPC$')",
      "4621:             self.__server.processConfigFile()",
      "4625:         # ask for shares using MS-RAP.",
      "4627:         self.__srvsServer = SRVSServer()",
      "4628:         self.__srvsServer.daemon = True",
      "4629:         self.__wkstServer = WKSTServer()",
      "4630:         self.__wkstServer.daemon = True",
      "4634:     def start(self):",
      "4635:         self.__srvsServer.start()",
      "",
      "[Removed Lines]",
      "4595:     def __init__(self, listenAddress = '0.0.0.0', listenPort=445, configFile=''):",
      "4597:             self.__server = SMBSERVER((listenAddress,listenPort))",
      "4604:             self.__smbConfig.set('global','server_name',''.join([random.choice(string.ascii_letters) for _ in range(8)]))",
      "4605:             self.__smbConfig.set('global','server_os',''.join([random.choice(string.ascii_letters) for _ in range(8)])",
      "4606: )",
      "4607:             self.__smbConfig.set('global','server_domain',''.join([random.choice(string.ascii_letters) for _ in range(8)])",
      "4608: )",
      "4609:             self.__smbConfig.set('global','log_file','None')",
      "4610:             self.__smbConfig.set('global','rpc_apis','yes')",
      "4611:             self.__smbConfig.set('global','credentials_file','')",
      "4612:             self.__smbConfig.set('global', 'challenge', \"A\"*16)",
      "4616:             self.__smbConfig.set('IPC$','comment','')",
      "4617:             self.__smbConfig.set('IPC$','read only','yes')",
      "4618:             self.__smbConfig.set('IPC$','share type','3')",
      "4619:             self.__smbConfig.set('IPC$','path','')",
      "4620:             self.__server = SMBSERVER((listenAddress,listenPort), config_parser = self.__smbConfig)",
      "4623:         # Now we have to register the MS-SRVS server. This specially important for",
      "4624:         # Windows 7+ and Mavericks clients since they WON'T (specially OSX)",
      "4631:         self.__server.registerNamedPipe('srvsvc',('127.0.0.1',self.__srvsServer.getListenPort()))",
      "4632:         self.__server.registerNamedPipe('wkssvc',('127.0.0.1',self.__wkstServer.getListenPort()))",
      "",
      "[Added Lines]",
      "4668:     def __init__(self, listenAddress='0.0.0.0', listenPort=445, configFile=''):",
      "4670:             self.__server = SMBSERVER((listenAddress, listenPort))",
      "4677:             self.__smbConfig.set('global', 'server_name',",
      "4678:                                  ''.join([random.choice(string.ascii_letters) for _ in range(8)]))",
      "4679:             self.__smbConfig.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)])",
      "4680:                                  )",
      "4681:             self.__smbConfig.set('global', 'server_domain',",
      "4682:                                  ''.join([random.choice(string.ascii_letters) for _ in range(8)])",
      "4683:                                  )",
      "4684:             self.__smbConfig.set('global', 'log_file', 'None')",
      "4685:             self.__smbConfig.set('global', 'rpc_apis', 'yes')",
      "4686:             self.__smbConfig.set('global', 'credentials_file', '')",
      "4687:             self.__smbConfig.set('global', 'challenge', \"A\" * 16)",
      "4691:             self.__smbConfig.set('IPC$', 'comment', '')",
      "4692:             self.__smbConfig.set('IPC$', 'read only', 'yes')",
      "4693:             self.__smbConfig.set('IPC$', 'share type', '3')",
      "4694:             self.__smbConfig.set('IPC$', 'path', '')",
      "4695:             self.__server = SMBSERVER((listenAddress, listenPort), config_parser=self.__smbConfig)",
      "4698:         # Now we have to register the MS-SRVS server. This specially important for",
      "4699:         # Windows 7+ and Mavericks clients since they WON'T (specially OSX)",
      "4706:         self.__server.registerNamedPipe('srvsvc', ('127.0.0.1', self.__srvsServer.getListenPort()))",
      "4707:         self.__server.registerNamedPipe('wkssvc', ('127.0.0.1', self.__wkstServer.getListenPort()))",
      "",
      "---------------",
      "--- Hunk 116 ---",
      "[Context before]",
      "4645:     def getRegisteredNamedPipes(self):",
      "4646:         return self.__server.getRegisteredNamedPipes()",
      "4649:         share = shareName.upper()",
      "4650:         self.__smbConfig.add_section(share)",
      "4651:         self.__smbConfig.set(share, 'comment', shareComment)",
      "",
      "[Removed Lines]",
      "4648:     def addShare(self, shareName, sharePath, shareComment='', shareType = '0', readOnly = 'no'):",
      "",
      "[Added Lines]",
      "4723:     def addShare(self, shareName, sharePath, shareComment='', shareType='0', readOnly='no'):",
      "",
      "---------------",
      "--- Hunk 117 ---",
      "[Context before]",
      "4669:             self.__smbConfig.set('global', 'challenge', challenge)",
      "4670:             self.__server.setServerConfig(self.__smbConfig)",
      "4671:             self.__server.processConfigFile()",
      "4673:     def setLogFile(self, logFile):",
      "4675:         self.__server.setServerConfig(self.__smbConfig)",
      "4676:         self.__server.processConfigFile()",
      "4678:     def setCredentialsFile(self, logFile):",
      "4680:         self.__server.setServerConfig(self.__smbConfig)",
      "4681:         self.__server.processConfigFile()",
      "",
      "[Removed Lines]",
      "4674:         self.__smbConfig.set('global','log_file',logFile)",
      "4679:         self.__smbConfig.set('global','credentials_file',logFile)",
      "",
      "[Added Lines]",
      "4749:         self.__smbConfig.set('global', 'log_file', logFile)",
      "4754:         self.__smbConfig.set('global', 'credentials_file', logFile)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6688da5d97592269aae72b3a00dc1ab186c0b33d",
      "candidate_info": {
        "commit_hash": "6688da5d97592269aae72b3a00dc1ab186c0b33d",
        "repo": "SecureAuthCorp/impacket",
        "commit_url": "https://github.com/SecureAuthCorp/impacket/commit/6688da5d97592269aae72b3a00dc1ab186c0b33d",
        "files": [
          "impacket/smbserver.py"
        ],
        "message": "Changed STATUS_ACCESS_DENIED and STATUS_NOT_SUPPORTED to STATUS_OBJECT_PATH_SYNTAX_BAD",
        "before_after_code_files": [
          "impacket/smbserver.py||impacket/smbserver.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/fortra/impacket/pull/1066"
        ],
        "olp_code_files": {
          "patch": [
            "impacket/smbserver.py||impacket/smbserver.py"
          ],
          "candidate": [
            "impacket/smbserver.py||impacket/smbserver.py"
          ]
        }
      },
      "candidate_diff": {
        "impacket/smbserver.py||impacket/smbserver.py": [
          "File: impacket/smbserver.py -> impacket/smbserver.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:     STATUS_FILE_IS_A_DIRECTORY, STATUS_NOT_IMPLEMENTED, STATUS_INVALID_HANDLE, STATUS_OBJECT_NAME_COLLISION, \\",
          "54:     STATUS_NO_SUCH_FILE, STATUS_CANCELLED, STATUS_OBJECT_NAME_NOT_FOUND, STATUS_SUCCESS, STATUS_ACCESS_DENIED, \\",
          "55:     STATUS_NOT_SUPPORTED, STATUS_INVALID_DEVICE_REQUEST, STATUS_FS_DRIVER_REQUIRED, STATUS_INVALID_INFO_CLASS, \\",
          "58: # Setting LOG to current's module name",
          "59: LOG = logging.getLogger(__name__)",
          "",
          "[Removed Lines]",
          "56:     STATUS_LOGON_FAILURE",
          "",
          "[Added Lines]",
          "56:     STATUS_LOGON_FAILURE, STATUS_OBJECT_PATH_SYNTAX_BAD",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "348:     if not isInFileJail(path, fileName):",
          "349:         LOG.error(\"Path not in current working directory\")",
          "352:     pathName = os.path.join(path, fileName)",
          "353:     files = []",
          "",
          "[Removed Lines]",
          "350:         return [], 0, STATUS_NOT_SUPPORTED",
          "",
          "[Added Lines]",
          "350:         return [], 0, STATUS_OBJECT_PATH_SYNTAX_BAD",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2041:                 LOG.error(\"Path not in current working directory\")",
          "2042:                 respSMBCommand['Parameters'] = b''",
          "2043:                 respSMBCommand['Data'] = b''",
          "2046:             pathName = os.path.join(path, fileName)",
          "2047:             createDisposition = ntCreateAndXParameters['Disposition']",
          "",
          "[Removed Lines]",
          "2044:                 return [respSMBCommand], None, STATUS_ACCESS_DENIED",
          "",
          "[Added Lines]",
          "2044:                 return [respSMBCommand], None, STATUS_OBJECT_PATH_SYNTAX_BAD",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3015:             if not isInFileJail(path, fileName):",
          "3016:                 LOG.error(\"Path not in current working directory\")",
          "3019:             pathName = os.path.join(path, fileName)",
          "3020:             createDisposition = ntCreateRequest['CreateDisposition']",
          "",
          "[Removed Lines]",
          "3017:                 return [smb2.SMB2Error()], None, STATUS_ACCESS_DENIED",
          "",
          "[Added Lines]",
          "3017:                 return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99bd29e3995c254e2d6f6c2e3454e4271665955a",
      "candidate_info": {
        "commit_hash": "99bd29e3995c254e2d6f6c2e3454e4271665955a",
        "repo": "SecureAuthCorp/impacket",
        "commit_url": "https://github.com/SecureAuthCorp/impacket/commit/99bd29e3995c254e2d6f6c2e3454e4271665955a",
        "files": [
          "impacket/smbserver.py"
        ],
        "message": "Fix Path Traversal vulnerabilities by checking path prefix against incoming filename",
        "before_after_code_files": [
          "impacket/smbserver.py||impacket/smbserver.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/fortra/impacket/pull/1066"
        ],
        "olp_code_files": {
          "patch": [
            "impacket/smbserver.py||impacket/smbserver.py"
          ],
          "candidate": [
            "impacket/smbserver.py||impacket/smbserver.py"
          ]
        }
      },
      "candidate_diff": {
        "impacket/smbserver.py||impacket/smbserver.py": [
          "File: impacket/smbserver.py -> impacket/smbserver.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: # For signing",
          "47: from impacket import smb, nmb, ntlm, uuid",
          "48: from impacket import smb3structs as smb2",
          "50: from impacket.nt_errors import STATUS_NO_MORE_FILES, STATUS_NETWORK_NAME_DELETED, STATUS_INVALID_PARAMETER, \\",
          "51:     STATUS_FILE_CLOSED, STATUS_MORE_PROCESSING_REQUIRED, STATUS_OBJECT_PATH_NOT_FOUND, STATUS_DIRECTORY_NOT_EMPTY, \\",
          "52:     STATUS_FILE_IS_A_DIRECTORY, STATUS_NOT_IMPLEMENTED, STATUS_INVALID_HANDLE, STATUS_OBJECT_NAME_COLLISION, \\",
          "",
          "[Removed Lines]",
          "49: from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, ASN1_SUPPORTED_MECH",
          "",
          "[Added Lines]",
          "49: from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, MechTypes, SPNEGO_NegTokenResp, ASN1_AID, \\",
          "50:     ASN1_SUPPORTED_MECH",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61: STATUS_SMB_BAD_UID = 0x005B0002",
          "62: STATUS_SMB_BAD_TID = 0x00050002",
          "64: # Utility functions",
          "67: # command (or either TRANSACTION). That's why I'm putting them here",
          "68: # TODO: Return NT ERROR Codes",
          "70: def computeNTLMv2(identity, lmhash, nthash, serverChallenge, authenticateMessage, ntlmChallenge, type1):",
          "71:     # Let's calculate the NTLMv2 Response",
          "74:     responseKeyNT = ntlm.NTOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), nthash)",
          "75:     responseKeyLM = ntlm.LMOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), lmhash)",
          "",
          "[Removed Lines]",
          "65: # and general functions.",
          "66: # There are some common functions that can be accessed from more than one SMB",
          "",
          "[Added Lines]",
          "67: # and general functions.",
          "68: # There are some common functions that can be accessed from more than one SMB",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:         responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN",
          "105:     keyExchangeKey = ntlm.KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmChallengeResponse,",
          "109:     # If we set up key exchange, let's fill the right variables",
          "110:     if ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
          "",
          "[Removed Lines]",
          "106:                            ntlmChallenge['challenge'], '',",
          "107:                            lmhash, nthash, True)",
          "",
          "[Added Lines]",
          "107:                                 ntlmChallenge['challenge'], '',",
          "108:                                 lmhash, nthash, True)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "126: def outputToJohnFormat(challenge, username, domain, lmresponse, ntresponse):",
          "130:     ret_value = ''",
          "131:     if type(challenge) is not bytes:",
          "132:         challenge = challenge.decode('latin-1')",
          "",
          "[Removed Lines]",
          "127: # We don't want to add a possible failure here, since this is an",
          "128: # extra bonus. We try, if it fails, returns nothing",
          "129: # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called",
          "",
          "[Added Lines]",
          "128:     # We don't want to add a possible failure here, since this is an",
          "129:     # extra bonus. We try, if it fails, returns nothing",
          "130:     # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "137:             ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (",
          "138:                 username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(challenge).decode('latin-1'),",
          "139:                 hexlify(ntresponse).decode('latin-1')[:32],",
          "141:         else:",
          "142:             # NTLMv1",
          "143:             ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (",
          "144:                 username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(lmresponse).decode('latin-1'),",
          "145:                 hexlify(ntresponse).decode('latin-1'),",
          "147:     except:",
          "148:         # Let's try w/o decoding Unicode",
          "149:         try:",
          "",
          "[Removed Lines]",
          "140:             hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}",
          "146:             hexlify(challenge).decode()), 'hash_version': 'ntlm'}",
          "",
          "[Added Lines]",
          "141:                 hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}",
          "147:                 hexlify(challenge).decode()), 'hash_version': 'ntlm'}",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "173:     else:",
          "174:         output_filename = fn_data[0] + \"_ntlm\" + fn_data[1]",
          "182:     if flags & smb.SMB.FLAGS2_UNICODE:",
          "183:         return text.decode('utf-16le')",
          "184:     else:",
          "185:         return text",
          "188:     if flags & smb.SMB.FLAGS2_UNICODE:",
          "189:         return (text).encode('utf-16le')",
          "190:     else:",
          "191:         return text.encode('ascii')",
          "193: def getFileTime(t):",
          "194:     t *= 10000000",
          "195:     t += 116444736000000000",
          "196:     return t",
          "198: def getUnixTime(t):",
          "199:     t -= 116444736000000000",
          "200:     t //= 10000000",
          "201:     return t",
          "203: def getSMBDate(t):",
          "204:     # TODO: Fix this :P",
          "205:     d = datetime.date.fromtimestamp(t)",
          "",
          "[Removed Lines]",
          "176:     with open(output_filename,\"a\") as f:",
          "177:             f.write(hash_string)",
          "178:             f.write('\\n')",
          "181: def decodeSMBString( flags, text ):",
          "187: def encodeSMBString( flags, text ):",
          "",
          "[Added Lines]",
          "178:     with open(output_filename, \"a\") as f:",
          "179:         f.write(hash_string)",
          "180:         f.write('\\n')",
          "183: def decodeSMBString(flags, text):",
          "190: def encodeSMBString(flags, text):",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "207:     ret = (year << 8) + (d.month << 4) + d.day",
          "208:     return ret",
          "210: def getSMBTime(t):",
          "211:     # TODO: Fix this :P",
          "212:     d = datetime.datetime.fromtimestamp(t)",
          "215: def getShares(connId, smbServer):",
          "216:     config = smbServer.getServerConfig()",
          "217:     sections = config.sections()",
          "218:     # Remove the global one",
          "220:     shares = {}",
          "221:     for i in sections:",
          "222:         shares[i] = dict(config.items(i))",
          "223:     return shares",
          "225: def searchShare(connId, share, smbServer):",
          "226:     config = smbServer.getServerConfig()",
          "227:     if config.has_section(share):",
          "229:     else:",
          "234:     errorCode = 0",
          "235:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "239:     mode = 0",
          "240:     # Check the Open Mode",
          "241:     if openMode & 0x10:",
          "",
          "[Removed Lines]",
          "213:     return (d.hour << 8) + (d.minute << 4) + d.second",
          "219:     del(sections[sections.index('global')])",
          "228:        return dict(config.items(share))",
          "230:        return None",
          "232: def openFile(path,fileName, accessMode, fileAttributes, openMode):",
          "233:     fileName = os.path.normpath(fileName.replace('\\\\','/'))",
          "236:        # strip leading '/'",
          "237:        fileName = fileName[1:]",
          "238:     pathName = os.path.join(path,fileName)",
          "",
          "[Added Lines]",
          "220:     return (d.hour << 8) + (d.minute << 4) + d.second",
          "227:     del (sections[sections.index('global')])",
          "237:         return dict(config.items(share))",
          "239:         return None",
          "242: def openFile(path, fileName, accessMode, fileAttributes, openMode):",
          "243:     fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
          "246:         # strip leading '/'",
          "247:         fileName = fileName[1:]",
          "248:     pathName = os.path.join(path, fileName)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "245:         # If file does not exist, return an error",
          "246:         if os.path.exists(pathName) is not True:",
          "247:             errorCode = STATUS_NO_SUCH_FILE",
          "250:     if os.path.isdir(pathName) and (fileAttributes & smb.ATTR_DIRECTORY) == 0:",
          "251:         # Request to open a normal file and this is actually a directory",
          "254:     # Check the Access Mode",
          "255:     if accessMode & 0x7 == 1:",
          "257:     elif accessMode & 0x7 == 2:",
          "259:     else:",
          "262:     try:",
          "263:         if sys.platform == 'win32':",
          "264:             mode |= os.O_BINARY",
          "265:         fid = os.open(pathName, mode)",
          "266:     except Exception as e:",
          "268:         fid = 0",
          "269:         errorCode = STATUS_ACCESS_DENIED",
          "271:     return fid, mode, pathName, errorCode",
          "275:     if pktFlags & smb.SMB.FLAGS2_UNICODE:",
          "277:     else:",
          "281:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "285:     fileSize = os.path.getsize(pathName)",
          "286:     (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
          "287:     if level == smb.SMB_QUERY_FS_ATTRIBUTE_INFO or level == smb2.SMB2_FILESYSTEM_ATTRIBUTE_INFO:",
          "288:         data = smb.SMBQueryFsAttributeInfo()",
          "290:         data['MaxFilenNameLengthInBytes'] = 255",
          "293:         return data.getData()",
          "294:     elif level == smb.SMB_INFO_VOLUME:",
          "297:         return data.getData()",
          "298:     elif level == smb.SMB_QUERY_FS_VOLUME_INFO or level == smb2.SMB2_FILESYSTEM_VOLUME_INFO:",
          "299:         data = smb.SMBQueryFsVolumeInfo()",
          "303:     elif level == smb.SMB_QUERY_FS_SIZE_INFO:",
          "304:         data = smb.SMBQueryFsSizeInfo()",
          "305:         return data.getData()",
          "",
          "[Removed Lines]",
          "248:             return 0,mode, pathName, errorCode",
          "252:             errorCode = STATUS_FILE_IS_A_DIRECTORY",
          "253:             return 0, mode, pathName, errorCode",
          "256:        mode |= os.O_WRONLY",
          "258:        mode |= os.O_RDWR",
          "260:        mode = os.O_RDONLY",
          "267:         LOG.error(\"openFile: %s,%s\" % (pathName, mode) ,e)",
          "273: def queryFsInformation(path, filename, level=0, pktFlags = smb.SMB.FLAGS2_UNICODE):",
          "276:          encoding = 'utf-16le'",
          "278:          encoding = 'ascii'",
          "280:     fileName = os.path.normpath(filename.replace('\\\\','/'))",
          "282:        # strip leading '/'",
          "283:        fileName = fileName[1:]",
          "284:     pathName = os.path.join(path,fileName)",
          "289:         data['FileSystemAttributes']      = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES",
          "291:         data['LengthOfFileSystemName']    = len('XTFS')*2",
          "292:         data['FileSystemName']            = 'XTFS'.encode('utf-16le')",
          "295:         data = smb.SMBQueryFsInfoVolume( flags = pktFlags )",
          "296:         data['VolumeLabel']               = 'SHARE'.encode(encoding)",
          "300:         data['VolumeLabel']               = ''",
          "301:         data['VolumeCreationTime']        = getFileTime(ctime)",
          "302:         return data.getData()",
          "",
          "[Added Lines]",
          "258:             return 0, mode, pathName, errorCode",
          "262:         errorCode = STATUS_FILE_IS_A_DIRECTORY",
          "263:         return 0, mode, pathName, errorCode",
          "266:         mode |= os.O_WRONLY",
          "268:         mode |= os.O_RDWR",
          "270:         mode = os.O_RDONLY",
          "277:         LOG.error(\"openFile: %s,%s\" % (pathName, mode), e)",
          "284: def queryFsInformation(path, filename, level=0, pktFlags=smb.SMB.FLAGS2_UNICODE):",
          "286:         encoding = 'utf-16le'",
          "288:         encoding = 'ascii'",
          "290:     fileName = os.path.normpath(filename.replace('\\\\', '/'))",
          "292:         # strip leading '/'",
          "293:         fileName = fileName[1:]",
          "294:     pathName = os.path.join(path, fileName)",
          "299:         data['FileSystemAttributes'] = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES",
          "301:         data['LengthOfFileSystemName'] = len('XTFS') * 2",
          "302:         data['FileSystemName'] = 'XTFS'.encode('utf-16le')",
          "305:         data = smb.SMBQueryFsInfoVolume(flags=pktFlags)",
          "306:         data['VolumeLabel'] = 'SHARE'.encode(encoding)",
          "310:         data['VolumeLabel'] = ''",
          "311:         data['VolumeCreationTime'] = getFileTime(ctime)",
          "312:         return data.getData()",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "319:         fileAttributes = attribs",
          "320:         return fileSize, lastWriteTime, fileAttributes",
          "334:         # strip leading '/'",
          "335:         fileName = fileName[1:]",
          "356:                 entry = os.path.join(dirName, file)",
          "357:                 if os.path.isdir(entry):",
          "358:                     if searchAttributes & smb.ATTR_DIRECTORY:",
          "359:                         files.append(entry)",
          "360:                 else:",
          "361:                     files.append(entry)",
          "371:         if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:",
          "373:         elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:",
          "375:         elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:",
          "377:         elif level == smb.SMB_FIND_INFO_STANDARD:",
          "379:         elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:",
          "381:         elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:",
          "383:         elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:",
          "385:         else:",
          "386:             LOG.error(\"Wrong level %d!\" % level)",
          "389:         (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)",
          "390:         if os.path.isdir(i):",
          "392:         else:",
          "395:         item['FileName'] = os.path.basename(i).encode(encoding)",
          "397:         if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:",
          "409:         elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO:",
          "419:         elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:",
          "429:         elif level == smb.SMB_FIND_INFO_STANDARD:",
          "437:         searchResult.append(item)",
          "445: def queryFileInformation(path, filename, level):",
          "449: def queryPathInformation(path, filename, level):",
          "450:     # TODO: Depending on the level, this could be done much simpler",
          "506:             else:",
          "512:         else:",
          "525: def queryDiskInformation(path):",
          "532: # Here we implement the NT transaction handlers",
          "533: class NTTRANSCommands:",
          "535:         pass",
          "537: # Here we implement the NT transaction handlers",
          "538: class TRANSCommands:",
          "539:     @staticmethod",
          "541:         # Minimal [MS-RAP] implementation, just to return the shares",
          "542:         connData = smbServer.getConnectionData(connId)",
          "",
          "[Removed Lines]",
          "322: def findFirst2(path, fileName, level, searchAttributes, pktFlags = smb.SMB.FLAGS2_UNICODE, isSMB2 = False):",
          "323:      # TODO: Depending on the level, this could be done much simpler",
          "325:      #print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)",
          "326:      fileName = os.path.normpath(fileName.replace('\\\\','/'))",
          "327:      # Let's choose the right encoding depending on the request",
          "328:      if pktFlags & smb.SMB.FLAGS2_UNICODE:",
          "329:          encoding = 'utf-16le'",
          "330:      else:",
          "331:          encoding = 'ascii'",
          "333:      if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "337:      pathName = os.path.join(path,fileName)",
          "338:      files = []",
          "340:      if pathName.find('*') == -1 and pathName.find('?') == -1:",
          "341:          # No search patterns",
          "342:          pattern = ''",
          "343:      else:",
          "344:          pattern = os.path.basename(pathName)",
          "345:          dirName = os.path.dirname(pathName)",
          "347:      # Always add . and .. Not that important for Windows, but Samba whines if",
          "348:      # not present (for * search only)",
          "349:      if pattern == '*':",
          "350:          files.append(os.path.join(dirName,'.'))",
          "351:          files.append(os.path.join(dirName,'..'))",
          "353:      if pattern != '':",
          "354:          for file in os.listdir(dirName):",
          "355:              if fnmatch.fnmatch(file.lower(),pattern.lower()):",
          "362:      else:",
          "363:          if os.path.exists(pathName):",
          "364:              files.append(pathName)",
          "366:      searchResult = []",
          "367:      searchCount = len(files)",
          "368:      errorCode = STATUS_SUCCESS",
          "370:      for i in files:",
          "372:             item = smb.SMBFindFileBothDirectoryInfo( flags = pktFlags )",
          "374:             item = smb.SMBFindFileDirectoryInfo( flags = pktFlags )",
          "376:             item = smb.SMBFindFileFullDirectoryInfo( flags = pktFlags )",
          "378:             item = smb.SMBFindInfoStandard( flags = pktFlags )",
          "380:             item = smb.SMBFindFileIdFullDirectoryInfo( flags = pktFlags )",
          "382:             item = smb.SMBFindFileIdBothDirectoryInfo( flags = pktFlags )",
          "384:             item = smb.SMBFindFileNamesInfo( flags = pktFlags )",
          "387:             return  searchResult, searchCount, STATUS_NOT_SUPPORTED",
          "391:            item['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "393:            item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "398:            item['EaSize']            = 0",
          "399:            item['EndOfFile']         = size",
          "400:            item['AllocationSize']    = size",
          "401:            item['CreationTime']      = getFileTime(ctime)",
          "402:            item['LastAccessTime']    = getFileTime(atime)",
          "403:            item['LastWriteTime']     = getFileTime(mtime)",
          "404:            item['LastChangeTime']    = getFileTime(mtime)",
          "405:            item['ShortName']         = '\\x00'*24",
          "406:            item['FileName']          = os.path.basename(i).encode(encoding)",
          "407:            padLen = (8-(len(item) % 8)) % 8",
          "408:            item['NextEntryOffset']   = len(item) + padLen",
          "410:            item['EndOfFile']         = size",
          "411:            item['AllocationSize']    = size",
          "412:            item['CreationTime']      = getFileTime(ctime)",
          "413:            item['LastAccessTime']    = getFileTime(atime)",
          "414:            item['LastWriteTime']     = getFileTime(mtime)",
          "415:            item['LastChangeTime']    = getFileTime(mtime)",
          "416:            item['FileName']          = os.path.basename(i).encode(encoding)",
          "417:            padLen = (8-(len(item) % 8)) % 8",
          "418:            item['NextEntryOffset']   = len(item) + padLen",
          "420:            item['EaSize']            = 0",
          "421:            item['EndOfFile']         = size",
          "422:            item['AllocationSize']    = size",
          "423:            item['CreationTime']      = getFileTime(ctime)",
          "424:            item['LastAccessTime']    = getFileTime(atime)",
          "425:            item['LastWriteTime']     = getFileTime(mtime)",
          "426:            item['LastChangeTime']    = getFileTime(mtime)",
          "427:            padLen = (8-(len(item) % 8)) % 8",
          "428:            item['NextEntryOffset']   = len(item) + padLen",
          "430:            item['EaSize']            = size",
          "431:            item['CreationDate']      = getSMBDate(ctime)",
          "432:            item['CreationTime']      = getSMBTime(ctime)",
          "433:            item['LastAccessDate']    = getSMBDate(atime)",
          "434:            item['LastAccessTime']    = getSMBTime(atime)",
          "435:            item['LastWriteDate']     = getSMBDate(mtime)",
          "436:            item['LastWriteTime']     = getSMBTime(mtime)",
          "439:      # No more files",
          "440:      if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:",
          "441:          searchResult[-1]['NextEntryOffset'] = 0",
          "443:      return searchResult, searchCount, errorCode",
          "446:     #print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)",
          "447:     return queryPathInformation(path,filename, level)",
          "451:   #print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))",
          "452:   try:",
          "453:     errorCode = 0",
          "454:     fileName = os.path.normpath(filename.replace('\\\\','/'))",
          "455:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
          "456:        # strip leading '/'",
          "457:        fileName = fileName[1:]",
          "458:     pathName = os.path.join(path,fileName)",
          "459:     if os.path.exists(pathName):",
          "460:         (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
          "461:         if level == smb.SMB_QUERY_FILE_BASIC_INFO:",
          "462:             infoRecord = smb.SMBQueryFileBasicInfo()",
          "463:             infoRecord['CreationTime']         = getFileTime(ctime)",
          "464:             infoRecord['LastAccessTime']       = getFileTime(atime)",
          "465:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
          "466:             infoRecord['LastChangeTime']       = getFileTime(mtime)",
          "467:             if os.path.isdir(pathName):",
          "468:                infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "469:             else:",
          "470:                infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "471:         elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:",
          "472:             infoRecord = smb.SMBQueryFileStandardInfo()",
          "473:             infoRecord['AllocationSize']       = size",
          "474:             infoRecord['EndOfFile']            = size",
          "475:             if os.path.isdir(pathName):",
          "476:                infoRecord['Directory']         = 1",
          "477:             else:",
          "478:                infoRecord['Directory']         = 0",
          "479:         elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:",
          "480:             infoRecord = smb.SMBQueryFileAllInfo()",
          "481:             infoRecord['CreationTime']         = getFileTime(ctime)",
          "482:             infoRecord['LastAccessTime']       = getFileTime(atime)",
          "483:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
          "484:             infoRecord['LastChangeTime']       = getFileTime(mtime)",
          "485:             if os.path.isdir(pathName):",
          "486:                infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "487:             else:",
          "488:                infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "489:             infoRecord['AllocationSize']       = size",
          "490:             infoRecord['EndOfFile']            = size",
          "491:             if os.path.isdir(pathName):",
          "492:                infoRecord['Directory']         = 1",
          "493:             else:",
          "494:                infoRecord['Directory']         = 0",
          "495:             infoRecord['FileName']             = filename.encode('utf-16le')",
          "496:         elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:",
          "497:             infoRecord = smb.SMBFileNetworkOpenInfo()",
          "498:             infoRecord['CreationTime']         = getFileTime(ctime)",
          "499:             infoRecord['LastAccessTime']       = getFileTime(atime)",
          "500:             infoRecord['LastWriteTime']        = getFileTime(mtime)",
          "501:             infoRecord['ChangeTime']           = getFileTime(mtime)",
          "502:             infoRecord['AllocationSize']       = size",
          "503:             infoRecord['EndOfFile']            = size",
          "504:             if os.path.isdir(pathName):",
          "505:                infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY",
          "507:                infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "508:         elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:",
          "509:             infoRecord = smb.SMBQueryFileEaInfo()",
          "510:         elif level == smb2.SMB2_FILE_STREAM_INFO:",
          "511:             infoRecord = smb.SMBFileStreamInformation()",
          "513:             LOG.error('Unknown level for query path info! 0x%x' % level)",
          "514:             # UNSUPPORTED",
          "515:             return None, STATUS_NOT_SUPPORTED",
          "517:         return infoRecord, errorCode",
          "518:     else:",
          "519:         # NOT FOUND",
          "520:         return None, STATUS_OBJECT_NAME_NOT_FOUND",
          "521:   except Exception as e:",
          "522:       LOG.error('queryPathInfo: %s' % e)",
          "523:       raise",
          "526: # TODO: Do something useful here :)",
          "527: # For now we just return fake values",
          "528:    totalUnits = 65535",
          "529:    freeUnits = 65535",
          "530:    return totalUnits, freeUnits",
          "534:     def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "540:     def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "",
          "[Added Lines]",
          "333: def findFirst2(path, fileName, level, searchAttributes, pktFlags=smb.SMB.FLAGS2_UNICODE, isSMB2=False):",
          "334:     # TODO: Depending on the level, this could be done much simpler",
          "336:     # print \"FindFirs2 path:%s, filename:%s\" % (path, fileName)",
          "337:     fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
          "338:     # Let's choose the right encoding depending on the request",
          "339:     if pktFlags & smb.SMB.FLAGS2_UNICODE:",
          "340:         encoding = 'utf-16le'",
          "341:     else:",
          "342:         encoding = 'ascii'",
          "344:     if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "348:     if not isInFileJail(path, fileName):",
          "349:         LOG.error(\"Path not in current working directory\")",
          "350:         return [], 0, STATUS_NOT_SUPPORTED",
          "352:     pathName = os.path.join(path, fileName)",
          "353:     files = []",
          "355:     if pathName.find('*') == -1 and pathName.find('?') == -1:",
          "356:         # No search patterns",
          "357:         pattern = ''",
          "358:     else:",
          "359:         pattern = os.path.basename(pathName)",
          "360:         dirName = os.path.dirname(pathName)",
          "362:     # Always add . and .. Not that important for Windows, but Samba whines if",
          "363:     # not present (for * search only)",
          "364:     if pattern == '*':",
          "365:         files.append(os.path.join(dirName, '.'))",
          "366:         files.append(os.path.join(dirName, '..'))",
          "368:     if pattern != '':",
          "369:         for file in os.listdir(dirName):",
          "370:             if fnmatch.fnmatch(file.lower(), pattern.lower()):",
          "377:     else:",
          "378:         if os.path.exists(pathName):",
          "379:             files.append(pathName)",
          "381:     searchResult = []",
          "382:     searchCount = len(files)",
          "383:     errorCode = STATUS_SUCCESS",
          "385:     for i in files:",
          "387:             item = smb.SMBFindFileBothDirectoryInfo(flags=pktFlags)",
          "389:             item = smb.SMBFindFileDirectoryInfo(flags=pktFlags)",
          "391:             item = smb.SMBFindFileFullDirectoryInfo(flags=pktFlags)",
          "393:             item = smb.SMBFindInfoStandard(flags=pktFlags)",
          "395:             item = smb.SMBFindFileIdFullDirectoryInfo(flags=pktFlags)",
          "397:             item = smb.SMBFindFileIdBothDirectoryInfo(flags=pktFlags)",
          "399:             item = smb.SMBFindFileNamesInfo(flags=pktFlags)",
          "402:             return searchResult, searchCount, STATUS_NOT_SUPPORTED",
          "406:             item['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "408:             item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "413:             item['EaSize'] = 0",
          "414:             item['EndOfFile'] = size",
          "415:             item['AllocationSize'] = size",
          "416:             item['CreationTime'] = getFileTime(ctime)",
          "417:             item['LastAccessTime'] = getFileTime(atime)",
          "418:             item['LastWriteTime'] = getFileTime(mtime)",
          "419:             item['LastChangeTime'] = getFileTime(mtime)",
          "420:             item['ShortName'] = '\\x00' * 24",
          "421:             item['FileName'] = os.path.basename(i).encode(encoding)",
          "422:             padLen = (8 - (len(item) % 8)) % 8",
          "423:             item['NextEntryOffset'] = len(item) + padLen",
          "425:             item['EndOfFile'] = size",
          "426:             item['AllocationSize'] = size",
          "427:             item['CreationTime'] = getFileTime(ctime)",
          "428:             item['LastAccessTime'] = getFileTime(atime)",
          "429:             item['LastWriteTime'] = getFileTime(mtime)",
          "430:             item['LastChangeTime'] = getFileTime(mtime)",
          "431:             item['FileName'] = os.path.basename(i).encode(encoding)",
          "432:             padLen = (8 - (len(item) % 8)) % 8",
          "433:             item['NextEntryOffset'] = len(item) + padLen",
          "435:             item['EaSize'] = 0",
          "436:             item['EndOfFile'] = size",
          "437:             item['AllocationSize'] = size",
          "438:             item['CreationTime'] = getFileTime(ctime)",
          "439:             item['LastAccessTime'] = getFileTime(atime)",
          "440:             item['LastWriteTime'] = getFileTime(mtime)",
          "441:             item['LastChangeTime'] = getFileTime(mtime)",
          "442:             padLen = (8 - (len(item) % 8)) % 8",
          "443:             item['NextEntryOffset'] = len(item) + padLen",
          "445:             item['EaSize'] = size",
          "446:             item['CreationDate'] = getSMBDate(ctime)",
          "447:             item['CreationTime'] = getSMBTime(ctime)",
          "448:             item['LastAccessDate'] = getSMBDate(atime)",
          "449:             item['LastAccessTime'] = getSMBTime(atime)",
          "450:             item['LastWriteDate'] = getSMBDate(mtime)",
          "451:             item['LastWriteTime'] = getSMBTime(mtime)",
          "454:     # No more files",
          "455:     if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:",
          "456:         searchResult[-1]['NextEntryOffset'] = 0",
          "458:     return searchResult, searchCount, errorCode",
          "462:     # print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)",
          "463:     return queryPathInformation(path, filename, level)",
          "468:     # print(\"queryPathInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level))",
          "469:     try:",
          "470:         errorCode = 0",
          "471:         fileName = os.path.normpath(filename.replace('\\\\', '/'))",
          "472:         if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
          "473:             # strip leading '/'",
          "474:             fileName = fileName[1:]",
          "475:         pathName = os.path.join(path, fileName)",
          "476:         if os.path.exists(pathName):",
          "477:             (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
          "478:             if level == smb.SMB_QUERY_FILE_BASIC_INFO:",
          "479:                 infoRecord = smb.SMBQueryFileBasicInfo()",
          "480:                 infoRecord['CreationTime'] = getFileTime(ctime)",
          "481:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
          "482:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
          "483:                 infoRecord['LastChangeTime'] = getFileTime(mtime)",
          "484:                 if os.path.isdir(pathName):",
          "485:                     infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "486:                 else:",
          "487:                     infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "488:             elif level == smb.SMB_QUERY_FILE_STANDARD_INFO:",
          "489:                 infoRecord = smb.SMBQueryFileStandardInfo()",
          "490:                 infoRecord['AllocationSize'] = size",
          "491:                 infoRecord['EndOfFile'] = size",
          "492:                 if os.path.isdir(pathName):",
          "493:                     infoRecord['Directory'] = 1",
          "494:                 else:",
          "495:                     infoRecord['Directory'] = 0",
          "496:             elif level == smb.SMB_QUERY_FILE_ALL_INFO or level == smb2.SMB2_FILE_ALL_INFO:",
          "497:                 infoRecord = smb.SMBQueryFileAllInfo()",
          "498:                 infoRecord['CreationTime'] = getFileTime(ctime)",
          "499:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
          "500:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
          "501:                 infoRecord['LastChangeTime'] = getFileTime(mtime)",
          "502:                 if os.path.isdir(pathName):",
          "503:                     infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY",
          "504:                 else:",
          "505:                     infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "506:                 infoRecord['AllocationSize'] = size",
          "507:                 infoRecord['EndOfFile'] = size",
          "508:                 if os.path.isdir(pathName):",
          "509:                     infoRecord['Directory'] = 1",
          "510:                 else:",
          "511:                     infoRecord['Directory'] = 0",
          "512:                 infoRecord['FileName'] = filename.encode('utf-16le')",
          "513:             elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:",
          "514:                 infoRecord = smb.SMBFileNetworkOpenInfo()",
          "515:                 infoRecord['CreationTime'] = getFileTime(ctime)",
          "516:                 infoRecord['LastAccessTime'] = getFileTime(atime)",
          "517:                 infoRecord['LastWriteTime'] = getFileTime(mtime)",
          "518:                 infoRecord['ChangeTime'] = getFileTime(mtime)",
          "519:                 infoRecord['AllocationSize'] = size",
          "520:                 infoRecord['EndOfFile'] = size",
          "521:                 if os.path.isdir(pathName):",
          "522:                     infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY",
          "523:                 else:",
          "524:                     infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE",
          "525:             elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:",
          "526:                 infoRecord = smb.SMBQueryFileEaInfo()",
          "527:             elif level == smb2.SMB2_FILE_STREAM_INFO:",
          "528:                 infoRecord = smb.SMBFileStreamInformation()",
          "530:                 LOG.error('Unknown level for query path info! 0x%x' % level)",
          "531:                 # UNSUPPORTED",
          "532:                 return None, STATUS_NOT_SUPPORTED",
          "534:             return infoRecord, errorCode",
          "536:             # NOT FOUND",
          "537:             return None, STATUS_OBJECT_NAME_NOT_FOUND",
          "538:     except Exception as e:",
          "539:         LOG.error('queryPathInfo: %s' % e)",
          "540:         raise",
          "544:     # TODO: Do something useful here :)",
          "545:     # For now we just return fake values",
          "546:     totalUnits = 65535",
          "547:     freeUnits = 65535",
          "548:     return totalUnits, freeUnits",
          "551: def isInFileJail(path, fileName):",
          "552:     pathName = os.path.join(path, fileName)",
          "553:     share_real_path = os.path.realpath(path)",
          "554:     return os.path.commonprefix((os.path.realpath(pathName), share_real_path)) == share_real_path",
          "559:     def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "566:     def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "545:         respParameters = b''",
          "546:         respData = b''",
          "547:         errorCode = STATUS_SUCCESS",
          "549:             # NetShareEnum Request",
          "550:             netShareEnum = smb.SMBNetShareEnum(parameters)",
          "551:             if netShareEnum['InfoLevel'] == 1:",
          "552:                 shares = getShares(connId, smbServer)",
          "553:                 respParameters = smb.SMBNetShareEnumResponse()",
          "555:                 respParameters['EntriesAvailable'] = len(shares)",
          "556:                 tailData = ''",
          "557:                 for i in shares:",
          "558:                     # NetShareInfo1 len == 20",
          "559:                     entry = smb.NetShareInfo1()",
          "562:                     # (beto) If offset == 0 it crashes explorer.exe on windows 7",
          "563:                     entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)",
          "564:                     respData += entry.getData()",
          "",
          "[Removed Lines]",
          "548:         if struct.unpack('<H',parameters[:2])[0] == 0:",
          "554:                 respParameters['EntriesReturned']  = len(shares)",
          "560:                     entry['NetworkName'] = i + '\\x00'*(13-len(i))",
          "561:                     entry['Type']        = int(shares[i]['share type'])",
          "",
          "[Added Lines]",
          "574:         if struct.unpack('<H', parameters[:2])[0] == 0:",
          "580:                 respParameters['EntriesReturned'] = len(shares)",
          "586:                     entry['NetworkName'] = i + '\\x00' * (13 - len(i))",
          "587:                     entry['Type'] = int(shares[i]['share type'])",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "570:             else:",
          "571:                 # We don't support other info levels",
          "572:                 errorCode = STATUS_NOT_SUPPORTED",
          "574:             # NetrServerGetInfo Request",
          "575:             respParameters = smb.SMBNetServerGetInfoResponse()",
          "576:             netServerInfo = smb.SMBNetServerInfo1()",
          "577:             netServerInfo['ServerName'] = smbServer.getServerName()",
          "578:             respData = netServerInfo.getData()",
          "579:             respParameters['TotalBytesAvailable'] = len(respData)",
          "581:             # NetrShareGetInfo Request",
          "582:             request = smb.SMBNetShareGetInfo(parameters)",
          "583:             respParameters = smb.SMBNetShareGetInfoResponse()",
          "584:             shares = getShares(connId, smbServer)",
          "585:             share = shares[request['ShareName'].upper()]",
          "587:             shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'",
          "589:             respData = shareInfo.getData()",
          "590:             if 'comment' in share:",
          "591:                 shareInfo['RemarkOffsetLow'] = len(respData)",
          "592:                 respData += share['comment'] + '\\x00'",
          "593:             respParameters['TotalBytesAvailable'] = len(respData)",
          "595:         else:",
          "596:             # We don't know how to handle anything else",
          "597:             errorCode = STATUS_NOT_SUPPORTED",
          "",
          "[Removed Lines]",
          "573:         elif struct.unpack('<H',parameters[:2])[0] == 13:",
          "580:         elif struct.unpack('<H',parameters[:2])[0] == 1:",
          "586:             shareInfo = smb.NetShareInfo1()",
          "588:             shareInfo['Type']        = int(share['share type'])",
          "",
          "[Added Lines]",
          "599:         elif struct.unpack('<H', parameters[:2])[0] == 13:",
          "606:         elif struct.unpack('<H', parameters[:2])[0] == 1:",
          "612:             shareInfo = smb.NetShareInfo1()",
          "614:             shareInfo['Type'] = int(share['share type'])",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "601:         return respSetup, respParameters, respData, errorCode",
          "603:     @staticmethod",
          "605:         connData = smbServer.getConnectionData(connId)",
          "607:         respSetup = b''",
          "608:         respParameters = b''",
          "609:         respData = b''",
          "610:         errorCode = STATUS_SUCCESS",
          "614:         # Extract the FID",
          "615:         fid = struct.unpack('<H', transParameters['Setup'][2:])[0]",
          "",
          "[Removed Lines]",
          "604:     def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "611:         SMBCommand  = smb.SMBCommand(recvPacket['Data'][0])",
          "612:         transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
          "",
          "[Added Lines]",
          "630:     def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "637:         SMBCommand = smb.SMBCommand(recvPacket['Data'][0])",
          "638:         transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "617:         if fid in connData['OpenedFiles']:",
          "618:             fileHandle = connData['OpenedFiles'][fid]['FileHandle']",
          "619:             if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "622:             else:",
          "623:                 sock = connData['OpenedFiles'][fid]['Socket']",
          "624:                 sock.send(data)",
          "",
          "[Removed Lines]",
          "620:                 os.write(fileHandle,data)",
          "621:                 respData = os.read(fileHandle,data)",
          "",
          "[Added Lines]",
          "646:                 os.write(fileHandle, data)",
          "647:                 respData = os.read(fileHandle, data)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "631:         return respSetup, respParameters, respData, errorCode",
          "633: # Here we implement the transaction2 handlers",
          "634: class TRANS2Commands:",
          "635:     # All these commands return setup, parameters, data, errorCode",
          "636:     @staticmethod",
          "638:         connData = smbServer.getConnectionData(connId)",
          "640:         respSetup = b''",
          "641:         respParameters = b''",
          "642:         respData = b''",
          "643:         errorCode = STATUS_SUCCESS",
          "645:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "647:             fileName = decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName'])",
          "649:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\') and path != '':",
          "653:             if os.path.exists(pathName):",
          "654:                 informationLevel = setPathInfoParameters['InformationLevel']",
          "655:                 if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:",
          "",
          "[Removed Lines]",
          "637:     def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "644:         setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)",
          "646:             path     = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "648:             fileName = os.path.normpath(fileName.replace('\\\\','/'))",
          "650:                # strip leading '/'",
          "651:                fileName = fileName[1:]",
          "652:             pathName = os.path.join(path,fileName)",
          "",
          "[Added Lines]",
          "664:     def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "671:         setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)",
          "673:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "675:             fileName = os.path.normpath(fileName.replace('\\\\', '/'))",
          "677:                 # strip leading '/'",
          "678:                 fileName = fileName[1:]",
          "679:             pathName = os.path.join(path, fileName)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "666:                     else:",
          "667:                         mtime = getUnixTime(mtime)",
          "668:                     if mtime != -1 or atime != -1:",
          "670:                 else:",
          "672:                     # UNSUPPORTED",
          "674:             else:",
          "675:                 errorCode = STATUS_OBJECT_NAME_NOT_FOUND",
          "",
          "[Removed Lines]",
          "669:                         os.utime(pathName,(atime,mtime))",
          "671:                     smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'], logging.ERROR)",
          "673:                     errorCode =  STATUS_NOT_SUPPORTED",
          "",
          "[Added Lines]",
          "696:                         os.utime(pathName, (atime, mtime))",
          "698:                     smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'],",
          "699:                                   logging.ERROR)",
          "701:                     errorCode = STATUS_NOT_SUPPORTED",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "685:         return respSetup, respParameters, respData, errorCode",
          "688:     @staticmethod",
          "690:         connData = smbServer.getConnectionData(connId)",
          "692:         respSetup = b''",
          "",
          "[Removed Lines]",
          "689:     def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "",
          "[Added Lines]",
          "716:     def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "702:                 if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:",
          "703:                     infoRecord = smb.SMBSetFileDispositionInfo(parameters)",
          "704:                     if infoRecord['DeletePending'] > 0:",
          "708:                 elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:",
          "709:                     infoRecord = smb.SMBSetFileBasicInfo(data)",
          "710:                     # Creation time won't be set,  the other ones we play with.",
          "",
          "[Removed Lines]",
          "705:                        # Mark this file for removal after closed",
          "706:                        connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True",
          "707:                        respParameters = smb.SMBSetFileInformationResponse_Parameters()",
          "",
          "[Added Lines]",
          "732:                         # Mark this file for removal after closed",
          "733:                         connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True",
          "734:                         respParameters = smb.SMBSetFileInformationResponse_Parameters()",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "718:                         mtime = -1",
          "719:                     else:",
          "720:                         mtime = getUnixTime(mtime)",
          "722:                 elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:",
          "723:                     fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']",
          "724:                     infoRecord = smb.SMBSetFileEndOfFileInfo(data)",
          "725:                     if infoRecord['EndOfFile'] > 0:",
          "727:                         os.write(fileHandle, b'\\x00')",
          "728:                 else:",
          "730:                     # UNSUPPORTED",
          "732:             else:",
          "733:                 errorCode = STATUS_NO_SUCH_FILE",
          "",
          "[Removed Lines]",
          "721:                     os.utime(fileName,(atime,mtime))",
          "726:                         os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)",
          "729:                     smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'], logging.ERROR)",
          "731:                     errorCode =  STATUS_NOT_SUPPORTED",
          "",
          "[Added Lines]",
          "748:                     os.utime(fileName, (atime, mtime))",
          "753:                         os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)",
          "756:                     smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'],",
          "757:                                   logging.ERROR)",
          "759:                     errorCode = STATUS_NOT_SUPPORTED",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "742:         return respSetup, respParameters, respData, errorCode",
          "744:     @staticmethod",
          "746:         connData = smbServer.getConnectionData(connId)",
          "748:         respSetup = b''",
          "",
          "[Removed Lines]",
          "745:     def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "",
          "[Added Lines]",
          "773:     def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "770:         return respSetup, respParameters, respData, errorCode",
          "772:     @staticmethod",
          "774:         connData = smbServer.getConnectionData(connId)",
          "776:         respSetup = b''",
          "",
          "[Removed Lines]",
          "773:     def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "",
          "[Added Lines]",
          "801:     def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "778:         respData = b''",
          "779:         errorCode = 0",
          "783:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "784:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "",
          "[Removed Lines]",
          "781:         queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)",
          "",
          "[Added Lines]",
          "809:         queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "787:                                                                                    queryPathInfoParameters['FileName']),",
          "788:                                                              queryPathInfoParameters['InformationLevel'])",
          "789:             except Exception as e:",
          "792:             if infoRecord is not None:",
          "793:                 respParameters = smb.SMBQueryPathInformationResponse_Parameters()",
          "794:                 respData = infoRecord",
          "795:         else:",
          "796:             errorCode = STATUS_SMB_BAD_TID",
          "798:         smbServer.setConnectionData(connId, connData)",
          "800:         return respSetup, respParameters, respData, errorCode",
          "802:     @staticmethod",
          "804:         connData = smbServer.getConnectionData(connId)",
          "805:         errorCode = 0",
          "806:         # Get the Tid associated",
          "807:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "808:             data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',",
          "811:         smbServer.setConnectionData(connId, connData)",
          "815:     @staticmethod",
          "816:     def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):",
          "",
          "[Removed Lines]",
          "790:                smbServer.log(\"queryPathInformation: %s\" % e,logging.ERROR)",
          "803:     def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount = 0):",
          "809:                                       struct.unpack('<H',parameters)[0], pktFlags = recvPacket['Flags2'])",
          "813:         return b'',b'', data, errorCode",
          "",
          "[Added Lines]",
          "818:                 smbServer.log(\"queryPathInformation: %s\" % e, logging.ERROR)",
          "831:     def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):",
          "837:                                       struct.unpack('<H', parameters)[0], pktFlags=recvPacket['Flags2'])",
          "841:         return b'', b'', data, errorCode",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "820:         respParameters = b''",
          "821:         respData = b''",
          "822:         errorCode = STATUS_SUCCESS",
          "825:         sid = findNext2Parameters['SID']",
          "826:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "",
          "[Removed Lines]",
          "823:         findNext2Parameters = smb.SMBFindNext2_Parameters(flags = recvPacket['Flags2'], data = parameters)",
          "",
          "[Added Lines]",
          "851:         findNext2Parameters = smb.SMBFindNext2_Parameters(flags=recvPacket['Flags2'], data=parameters)",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "833:                 for i in enumerate(searchResult):",
          "834:                     data = i[1].getData()",
          "835:                     lenData = len(data)",
          "837:                         # We gotta stop here and continue on a find_next2",
          "838:                         endOfSearch = 0",
          "839:                         connData['SIDs'][sid] = searchResult[i[0]:]",
          "840:                         respParameters['LastNameOffset'] = totalData",
          "841:                         break",
          "842:                     else:",
          "844:                         respData += data",
          "845:                         totalData += lenData",
          "847:                 # Have we reached the end of the search or still stuff to send?",
          "848:                 if endOfSearch > 0:",
          "849:                     # Let's remove the SID from our ConnData",
          "852:                 respParameters['EndOfSearch'] = endOfSearch",
          "853:                 respParameters['SearchCount'] = searchCount",
          "855:                 errorCode = STATUS_INVALID_HANDLE",
          "856:         else:",
          "859:         smbServer.setConnectionData(connId, connData)",
          "",
          "[Removed Lines]",
          "836:                     if (totalData+lenData) >= maxDataCount or (i[0]+1) >= findNext2Parameters['SearchCount']:",
          "843:                         searchCount +=1",
          "850:                     del(connData['SIDs'][sid])",
          "854:             else:",
          "857:             errorCode = STATUS_SMB_BAD_TID",
          "",
          "[Added Lines]",
          "864:                     if (totalData + lenData) >= maxDataCount or (i[0] + 1) >= findNext2Parameters['SearchCount']:",
          "871:                         searchCount += 1",
          "878:                     del (connData['SIDs'][sid])",
          "882:             else:",
          "885:             errorCode = STATUS_SMB_BAD_TID",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "867:         respSetup = b''",
          "868:         respParameters = b''",
          "869:         respData = b''",
          "872:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "873:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "880:             respParameters = smb.SMBFindFirst2Response_Parameters()",
          "881:             endOfSearch = 1",
          "883:             searchCount = 0",
          "884:             totalData = 0",
          "885:             for i in enumerate(searchResult):",
          "887:                 data = i[1].getData()",
          "888:                 lenData = len(data)",
          "890:                     # We gotta stop here and continue on a find_next2",
          "891:                     endOfSearch = 0",
          "892:                     # Simple way to generate a fid",
          "893:                     if len(connData['SIDs']) == 0:",
          "895:                     else:",
          "897:                     # Store the remaining search results in the ConnData SID",
          "898:                     connData['SIDs'][sid] = searchResult[i[0]:]",
          "899:                     respParameters['LastNameOffset'] = totalData",
          "900:                     break",
          "901:                 else:",
          "903:                     respData += data",
          "907:                     totalData += lenData + padLen",
          "909:             respParameters['SID'] = sid",
          "910:             respParameters['EndOfSearch'] = endOfSearch",
          "911:             respParameters['SearchCount'] = searchCount",
          "912:         else:",
          "915:         smbServer.setConnectionData(connId, connData)",
          "917:         return respSetup, respParameters, respData, errorCode",
          "919: # Here we implement the commands handlers",
          "920: class SMBCommands:",
          "",
          "[Removed Lines]",
          "870:         findFirst2Parameters = smb.SMBFindFirst2_Parameters( recvPacket['Flags2'], data = parameters)",
          "875:             searchResult, searchCount, errorCode = findFirst2(path,",
          "876:                           decodeSMBString( recvPacket['Flags2'], findFirst2Parameters['FileName'] ),",
          "877:                           findFirst2Parameters['InformationLevel'],",
          "878:                           findFirst2Parameters['SearchAttributes'] , pktFlags = recvPacket['Flags2'])",
          "882:             sid = 0x80 # default SID",
          "886:                 #i[1].dump()",
          "889:                 if (totalData+lenData) >= maxDataCount or (i[0]+1) > findFirst2Parameters['SearchCount']:",
          "894:                        sid = 1",
          "896:                        sid = list(connData['SIDs'].keys())[-1] + 1",
          "902:                     searchCount +=1",
          "905:                     padLen = (8-(lenData % 8)) %8",
          "906:                     respData += b'\\xaa'*padLen",
          "913:             errorCode = STATUS_SMB_BAD_TID",
          "",
          "[Added Lines]",
          "898:         findFirst2Parameters = smb.SMBFindFirst2_Parameters(recvPacket['Flags2'], data=parameters)",
          "903:             searchResult, searchCount, errorCode = findFirst2(path,",
          "904:                                                               decodeSMBString(recvPacket['Flags2'],",
          "905:                                                                               findFirst2Parameters['FileName']),",
          "906:                                                               findFirst2Parameters['InformationLevel'],",
          "907:                                                               findFirst2Parameters['SearchAttributes'],",
          "908:                                                               pktFlags=recvPacket['Flags2'])",
          "912:             sid = 0x80  # default SID",
          "916:                 # i[1].dump()",
          "919:                 if (totalData + lenData) >= maxDataCount or (i[0] + 1) > findFirst2Parameters['SearchCount']:",
          "924:                         sid = 1",
          "926:                         sid = list(connData['SIDs'].keys())[-1] + 1",
          "932:                     searchCount += 1",
          "935:                     padLen = (8 - (lenData % 8)) % 8",
          "936:                     respData += b'\\xaa' * padLen",
          "943:             errorCode = STATUS_SMB_BAD_TID",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "926:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "930:         # Do the stuff",
          "931:         if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:",
          "933:             raise Exception(\"Unsupported partial parameters in TRANSACT2!\")",
          "934:         else:",
          "939:             paramCount = transParameters['ParameterCount']",
          "940:             transData['Trans_ParametersLength'] = paramCount",
          "",
          "[Removed Lines]",
          "928:         transParameters= smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
          "932:             # TODO: Handle partial parameters",
          "935:             transData = smb.SMBTransaction_SData(flags = recvPacket['Flags2'])",
          "936:             # Standard says servers shouldn't trust Parameters and Data comes",
          "937:             # in order, so we have to parse the offsets, ugly",
          "",
          "[Added Lines]",
          "959:         transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])",
          "963:             # TODO: Handle partial parameters",
          "966:             transData = smb.SMBTransaction_SData(flags=recvPacket['Flags2'])",
          "967:             # Standard says servers shouldn't trust Parameters and Data comes",
          "968:             # in order, so we have to parse the offsets, ugly",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "943:             transData.fromString(SMBCommand['Data'])",
          "944:             if transParameters['ParameterOffset'] > 0:",
          "945:                 paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']",
          "947:             else:",
          "948:                 transData['Trans_Parameters'] = b''",
          "950:             if transParameters['DataOffset'] > 0:",
          "951:                 dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']",
          "952:                 transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
          "954:                 transData['Trans_Data'] = b''",
          "956:             # Call the handler for this TRANSACTION",
          "957:             if transParameters['SetupCount'] == 0:",
          "958:                 # No subcommand, let's play with the Name",
          "960:             else:",
          "961:                 command = struct.unpack('<H', transParameters['Setup'][:2])[0]",
          "963:             if command in transCommands:",
          "1054:             else:",
          "1062:         smbServer.setConnectionData(connId, connData)",
          "1064:         return [respSMBCommand], None, errorCode",
          "1067:     @staticmethod",
          "1068:     def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):",
          "1069:         connData = smbServer.getConnectionData(connId)",
          "1071:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1074:         # Do the stuff",
          "1075:         if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:",
          "1077:             raise Exception(\"Unsupported partial parameters in NTTrans!\")",
          "1078:         else:",
          "1079:             NTTransData = smb.SMBNTTransaction_Data()",
          "1083:             paramCount = NTTransParameters['ParameterCount']",
          "1084:             NTTransData['NT_Trans_ParametersLength'] = paramCount",
          "",
          "[Removed Lines]",
          "946:                 transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
          "953:             else:",
          "959:                 command = decodeSMBString(recvPacket['Flags2'],transData['Name'])",
          "964:                # Call the TRANS subcommand",
          "965:                setup = b''",
          "966:                parameters = b''",
          "967:                data = b''",
          "968:                try:",
          "969:                    setup, parameters, data, errorCode = transCommands[command](connId,",
          "970:                                 smbServer,",
          "971:                                 recvPacket,",
          "972:                                 transData['Trans_Parameters'],",
          "973:                                 transData['Trans_Data'],",
          "974:                                 transParameters['MaxDataCount'])",
          "975:                except Exception as e:",
          "976:                    #print 'Transaction: %s' % e,e",
          "977:                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)",
          "978:                    errorCode = STATUS_ACCESS_DENIED",
          "979:                    #raise",
          "981:                if setup == b'' and parameters == b'' and data == b'':",
          "982:                    # Something wen't wrong",
          "983:                    respParameters = b''",
          "984:                    respData = b''",
          "985:                else:",
          "986:                    # Build the answer",
          "987:                    if hasattr(data, 'getData'):",
          "988:                        data = data.getData()",
          "989:                    remainingData = len(data)",
          "990:                    if hasattr(parameters, 'getData'):",
          "991:                        parameters = parameters.getData()",
          "992:                    remainingParameters = len(parameters)",
          "993:                    commands = []",
          "994:                    dataDisplacement = 0",
          "995:                    while remainingData > 0 or remainingParameters > 0:",
          "996:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "997:                        respParameters = smb.SMBTransactionResponse_Parameters()",
          "998:                        respData       = smb.SMBTransaction2Response_Data()",
          "1000:                        respParameters['TotalParameterCount'] = len(parameters)",
          "1001:                        respParameters['ParameterCount']      = len(parameters)",
          "1002:                        respData['Trans_ParametersLength']    = len(parameters)",
          "1003:                        respParameters['TotalDataCount']      = len(data)",
          "1004:                        respParameters['DataDisplacement']    = dataDisplacement",
          "1006:                        # TODO: Do the same for parameters",
          "1007:                        if len(data) >  transParameters['MaxDataCount']:",
          "1008:                            # Answer doesn't fit in this packet",
          "1009:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),transParameters['MaxDataCount']) )",
          "1010:                            respParameters['DataCount'] = transParameters['MaxDataCount']",
          "1011:                        else:",
          "1012:                            respParameters['DataCount'] = len(data)",
          "1014:                        respData['Trans_DataLength']          = respParameters['DataCount']",
          "1015:                        respParameters['SetupCount']          = len(setup)",
          "1016:                        respParameters['Setup']               = setup",
          "1017:                        # TODO: Make sure we're calculating the pad right",
          "1018:                        if len(parameters) > 0:",
          "1019:                            #padLen = 4 - (55 + len(setup)) % 4",
          "1020:                            padLen = (4 - (55 + len(setup)) % 4 ) % 4",
          "1021:                            padBytes = b'\\xFF' * padLen",
          "1022:                            respData['Pad1'] = padBytes",
          "1023:                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
          "1024:                        else:",
          "1025:                            padLen = 0",
          "1026:                            respParameters['ParameterOffset'] = 0",
          "1027:                            respData['Pad1']                  = b''",
          "1029:                        if len(data) > 0:",
          "1030:                            #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
          "1031:                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1032:                            respData['Pad2'] = b'\\xFF' * pad2Len",
          "1033:                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
          "1034:                        else:",
          "1035:                            respParameters['DataOffset'] = 0",
          "1036:                            respData['Pad2']             = b''",
          "1038:                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1039:                        respData['Trans_Data']       = data[:respParameters['DataCount']]",
          "1040:                        respSMBCommand['Parameters'] = respParameters",
          "1041:                        respSMBCommand['Data']       = respData",
          "1043:                        data = data[respParameters['DataCount']:]",
          "1044:                        remainingData -= respParameters['DataCount']",
          "1045:                        dataDisplacement += respParameters['DataCount'] + 1",
          "1047:                        parameters = parameters[respParameters['ParameterCount']:]",
          "1048:                        remainingParameters -= respParameters['ParameterCount']",
          "1049:                        commands.append(respSMBCommand)",
          "1051:                    smbServer.setConnectionData(connId, connData)",
          "1052:                    return commands, None, errorCode",
          "1055:                smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)",
          "1056:                respParameters = b''",
          "1057:                respData = b''",
          "1058:                errorCode = STATUS_NOT_IMPLEMENTED",
          "1060:         respSMBCommand['Parameters']             = respParameters",
          "1061:         respSMBCommand['Data']                   = respData",
          "1073:         NTTransParameters= smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])",
          "1076:             # TODO: Handle partial parameters",
          "1080:             # Standard says servers shouldn't trust Parameters and Data comes",
          "1081:             # in order, so we have to parse the offsets, ugly",
          "",
          "[Added Lines]",
          "977:                 transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
          "984:             else:",
          "990:                 command = decodeSMBString(recvPacket['Flags2'], transData['Name'])",
          "995:                 # Call the TRANS subcommand",
          "996:                 setup = b''",
          "997:                 parameters = b''",
          "998:                 data = b''",
          "999:                 try:",
          "1000:                     setup, parameters, data, errorCode = transCommands[command](connId,",
          "1001:                                                                                 smbServer,",
          "1002:                                                                                 recvPacket,",
          "1003:                                                                                 transData['Trans_Parameters'],",
          "1004:                                                                                 transData['Trans_Data'],",
          "1005:                                                                                 transParameters['MaxDataCount'])",
          "1006:                 except Exception as e:",
          "1007:                     # print 'Transaction: %s' % e,e",
          "1008:                     smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)",
          "1009:                     errorCode = STATUS_ACCESS_DENIED",
          "1010:                     # raise",
          "1012:                 if setup == b'' and parameters == b'' and data == b'':",
          "1013:                     # Something wen't wrong",
          "1014:                     respParameters = b''",
          "1015:                     respData = b''",
          "1016:                 else:",
          "1017:                     # Build the answer",
          "1018:                     if hasattr(data, 'getData'):",
          "1019:                         data = data.getData()",
          "1020:                     remainingData = len(data)",
          "1021:                     if hasattr(parameters, 'getData'):",
          "1022:                         parameters = parameters.getData()",
          "1023:                     remainingParameters = len(parameters)",
          "1024:                     commands = []",
          "1025:                     dataDisplacement = 0",
          "1026:                     while remainingData > 0 or remainingParameters > 0:",
          "1027:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1028:                         respParameters = smb.SMBTransactionResponse_Parameters()",
          "1029:                         respData = smb.SMBTransaction2Response_Data()",
          "1031:                         respParameters['TotalParameterCount'] = len(parameters)",
          "1032:                         respParameters['ParameterCount'] = len(parameters)",
          "1033:                         respData['Trans_ParametersLength'] = len(parameters)",
          "1034:                         respParameters['TotalDataCount'] = len(data)",
          "1035:                         respParameters['DataDisplacement'] = dataDisplacement",
          "1037:                         # TODO: Do the same for parameters",
          "1038:                         if len(data) > transParameters['MaxDataCount']:",
          "1039:                             # Answer doesn't fit in this packet",
          "1040:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), transParameters['MaxDataCount']))",
          "1041:                             respParameters['DataCount'] = transParameters['MaxDataCount']",
          "1042:                         else:",
          "1043:                             respParameters['DataCount'] = len(data)",
          "1045:                         respData['Trans_DataLength'] = respParameters['DataCount']",
          "1046:                         respParameters['SetupCount'] = len(setup)",
          "1047:                         respParameters['Setup'] = setup",
          "1048:                         # TODO: Make sure we're calculating the pad right",
          "1049:                         if len(parameters) > 0:",
          "1050:                             # padLen = 4 - (55 + len(setup)) % 4",
          "1051:                             padLen = (4 - (55 + len(setup)) % 4) % 4",
          "1052:                             padBytes = b'\\xFF' * padLen",
          "1053:                             respData['Pad1'] = padBytes",
          "1054:                             respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
          "1055:                         else:",
          "1056:                             padLen = 0",
          "1057:                             respParameters['ParameterOffset'] = 0",
          "1058:                             respData['Pad1'] = b''",
          "1060:                         if len(data) > 0:",
          "1061:                             # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
          "1062:                             pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1063:                             respData['Pad2'] = b'\\xFF' * pad2Len",
          "1064:                             respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
          "1065:                         else:",
          "1066:                             respParameters['DataOffset'] = 0",
          "1067:                             respData['Pad2'] = b''",
          "1069:                         respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1070:                         respData['Trans_Data'] = data[:respParameters['DataCount']]",
          "1071:                         respSMBCommand['Parameters'] = respParameters",
          "1072:                         respSMBCommand['Data'] = respData",
          "1074:                         data = data[respParameters['DataCount']:]",
          "1075:                         remainingData -= respParameters['DataCount']",
          "1076:                         dataDisplacement += respParameters['DataCount'] + 1",
          "1078:                         parameters = parameters[respParameters['ParameterCount']:]",
          "1079:                         remainingParameters -= respParameters['ParameterCount']",
          "1080:                         commands.append(respSMBCommand)",
          "1082:                     smbServer.setConnectionData(connId, connData)",
          "1083:                     return commands, None, errorCode",
          "1086:                 smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)",
          "1087:                 respParameters = b''",
          "1088:                 respData = b''",
          "1089:                 errorCode = STATUS_NOT_IMPLEMENTED",
          "1091:         respSMBCommand['Parameters'] = respParameters",
          "1092:         respSMBCommand['Data'] = respData",
          "1103:         NTTransParameters = smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])",
          "1106:             # TODO: Handle partial parameters",
          "1110:             # Standard says servers shouldn't trust Parameters and Data comes",
          "1111:             # in order, so we have to parse the offsets, ugly",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1088:             if NTTransParameters['ParameterOffset'] > 0:",
          "1089:                 paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']",
          "1091:             else:",
          "1092:                 NTTransData['NT_Trans_Parameters'] = b''",
          "1094:             if NTTransParameters['DataOffset'] > 0:",
          "1095:                 dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']",
          "1096:                 NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
          "1098:                 NTTransData['NT_Trans_Data'] = b''",
          "1100:             # Call the handler for this TRANSACTION",
          "1101:             command = NTTransParameters['Function']",
          "1102:             if command in transCommands:",
          "1193:             else:",
          "1202:         smbServer.setConnectionData(connId, connData)",
          "1203:         return [respSMBCommand], None, errorCode",
          "1206:     @staticmethod",
          "1207:     def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):",
          "1208:         connData = smbServer.getConnectionData(connId)",
          "1210:         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1214:         # Do the stuff",
          "1215:         if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:",
          "1218:             raise Exception(\"Unsupported partial parameters in TRANSACT2!\")",
          "1219:         else:",
          "1220:             trans2Data = smb.SMBTransaction2_Data()",
          "1224:             paramCount = trans2Parameters['ParameterCount']",
          "1225:             trans2Data['Trans_ParametersLength'] = paramCount",
          "",
          "[Removed Lines]",
          "1090:                 NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
          "1097:             else:",
          "1103:                # Call the NT TRANS subcommand",
          "1104:                setup = b''",
          "1105:                parameters = b''",
          "1106:                data = b''",
          "1107:                try:",
          "1108:                    setup, parameters, data, errorCode = transCommands[command](connId,",
          "1109:                                 smbServer,",
          "1110:                                 recvPacket,",
          "1111:                                 NTTransData['NT_Trans_Parameters'],",
          "1112:                                 NTTransData['NT_Trans_Data'],",
          "1113:                                 NTTransParameters['MaxDataCount'])",
          "1114:                except Exception as e:",
          "1115:                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)",
          "1116:                    errorCode = STATUS_ACCESS_DENIED",
          "1117:                    #raise",
          "1119:                if setup == b'' and parameters == b'' and data == b'':",
          "1120:                    # Something wen't wrong",
          "1121:                    respParameters = b''",
          "1122:                    respData = b''",
          "1123:                    if errorCode == STATUS_SUCCESS:",
          "1124:                        errorCode = STATUS_ACCESS_DENIED",
          "1125:                else:",
          "1126:                    # Build the answer",
          "1127:                    if hasattr(data, 'getData'):",
          "1128:                        data = data.getData()",
          "1129:                    remainingData = len(data)",
          "1130:                    if hasattr(parameters, 'getData'):",
          "1131:                        parameters = parameters.getData()",
          "1132:                    remainingParameters = len(parameters)",
          "1133:                    commands = []",
          "1134:                    dataDisplacement = 0",
          "1135:                    while remainingData > 0 or remainingParameters > 0:",
          "1136:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1137:                        respParameters = smb.SMBNTTransactionResponse_Parameters()",
          "1138:                        respData       = smb.SMBNTTransactionResponse_Data()",
          "1140:                        respParameters['TotalParameterCount'] = len(parameters)",
          "1141:                        respParameters['ParameterCount']      = len(parameters)",
          "1142:                        respData['Trans_ParametersLength']    = len(parameters)",
          "1143:                        respParameters['TotalDataCount']      = len(data)",
          "1144:                        respParameters['DataDisplacement']    = dataDisplacement",
          "1145:                        # TODO: Do the same for parameters",
          "1146:                        if len(data) >  NTTransParameters['MaxDataCount']:",
          "1147:                            # Answer doesn't fit in this packet",
          "1148:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),NTTransParameters['MaxDataCount']) )",
          "1149:                            respParameters['DataCount'] = NTTransParameters['MaxDataCount']",
          "1150:                        else:",
          "1151:                            respParameters['DataCount'] = len(data)",
          "1153:                        respData['NT_Trans_DataLength']          = respParameters['DataCount']",
          "1154:                        respParameters['SetupCount']          = len(setup)",
          "1155:                        respParameters['Setup']               = setup",
          "1156:                        # TODO: Make sure we're calculating the pad right",
          "1157:                        if len(parameters) > 0:",
          "1158:                            #padLen = 4 - (71 + len(setup)) % 4",
          "1159:                            padLen = (4 - (73 + len(setup)) % 4 ) % 4",
          "1160:                            padBytes = b'\\xFF' * padLen",
          "1161:                            respData['Pad1'] = padBytes",
          "1162:                            respParameters['ParameterOffset'] = 73 + len(setup) + padLen",
          "1163:                        else:",
          "1164:                            padLen = 0",
          "1165:                            respParameters['ParameterOffset'] = 0",
          "1166:                            respData['Pad1']                  = b''",
          "1168:                        if len(data) > 0:",
          "1169:                            #pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4",
          "1170:                            pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1171:                            respData['Pad2'] = b'\\xFF' * pad2Len",
          "1172:                            respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len",
          "1173:                        else:",
          "1174:                            respParameters['DataOffset'] = 0",
          "1175:                            respData['Pad2']             = b''",
          "1177:                        respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1178:                        respData['NT_Trans_Data']       = data[:respParameters['DataCount']]",
          "1179:                        respSMBCommand['Parameters'] = respParameters",
          "1180:                        respSMBCommand['Data']       = respData",
          "1182:                        data = data[respParameters['DataCount']:]",
          "1183:                        remainingData -= respParameters['DataCount']",
          "1184:                        dataDisplacement += respParameters['DataCount'] + 1",
          "1186:                        parameters = parameters[respParameters['ParameterCount']:]",
          "1187:                        remainingParameters -= respParameters['ParameterCount']",
          "1188:                        commands.append(respSMBCommand)",
          "1190:                    smbServer.setConnectionData(connId, connData)",
          "1191:                    return commands, None, errorCode",
          "1194:                #smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)",
          "1195:                respParameters = b''",
          "1196:                respData = b''",
          "1197:                errorCode = STATUS_NOT_IMPLEMENTED",
          "1199:         respSMBCommand['Parameters']             = respParameters",
          "1200:         respSMBCommand['Data']                   = respData",
          "1212:         trans2Parameters= smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])",
          "1216:             # TODO: Handle partial parameters",
          "1217:             #print \"Unsupported partial parameters in TRANSACT2!\"",
          "1221:             # Standard says servers shouldn't trust Parameters and Data comes",
          "1222:             # in order, so we have to parse the offsets, ugly",
          "",
          "[Added Lines]",
          "1120:                 NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
          "1127:             else:",
          "1133:                 # Call the NT TRANS subcommand",
          "1134:                 setup = b''",
          "1135:                 parameters = b''",
          "1136:                 data = b''",
          "1137:                 try:",
          "1138:                     setup, parameters, data, errorCode = transCommands[command](connId,",
          "1139:                                                                                 smbServer,",
          "1140:                                                                                 recvPacket,",
          "1141:                                                                                 NTTransData['NT_Trans_Parameters'],",
          "1142:                                                                                 NTTransData['NT_Trans_Data'],",
          "1143:                                                                                 NTTransParameters['MaxDataCount'])",
          "1144:                 except Exception as e:",
          "1145:                     smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)",
          "1146:                     errorCode = STATUS_ACCESS_DENIED",
          "1147:                     # raise",
          "1149:                 if setup == b'' and parameters == b'' and data == b'':",
          "1150:                     # Something wen't wrong",
          "1151:                     respParameters = b''",
          "1152:                     respData = b''",
          "1153:                     if errorCode == STATUS_SUCCESS:",
          "1154:                         errorCode = STATUS_ACCESS_DENIED",
          "1155:                 else:",
          "1156:                     # Build the answer",
          "1157:                     if hasattr(data, 'getData'):",
          "1158:                         data = data.getData()",
          "1159:                     remainingData = len(data)",
          "1160:                     if hasattr(parameters, 'getData'):",
          "1161:                         parameters = parameters.getData()",
          "1162:                     remainingParameters = len(parameters)",
          "1163:                     commands = []",
          "1164:                     dataDisplacement = 0",
          "1165:                     while remainingData > 0 or remainingParameters > 0:",
          "1166:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1167:                         respParameters = smb.SMBNTTransactionResponse_Parameters()",
          "1168:                         respData = smb.SMBNTTransactionResponse_Data()",
          "1170:                         respParameters['TotalParameterCount'] = len(parameters)",
          "1171:                         respParameters['ParameterCount'] = len(parameters)",
          "1172:                         respData['Trans_ParametersLength'] = len(parameters)",
          "1173:                         respParameters['TotalDataCount'] = len(data)",
          "1174:                         respParameters['DataDisplacement'] = dataDisplacement",
          "1175:                         # TODO: Do the same for parameters",
          "1176:                         if len(data) > NTTransParameters['MaxDataCount']:",
          "1177:                             # Answer doesn't fit in this packet",
          "1178:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), NTTransParameters['MaxDataCount']))",
          "1179:                             respParameters['DataCount'] = NTTransParameters['MaxDataCount']",
          "1180:                         else:",
          "1181:                             respParameters['DataCount'] = len(data)",
          "1183:                         respData['NT_Trans_DataLength'] = respParameters['DataCount']",
          "1184:                         respParameters['SetupCount'] = len(setup)",
          "1185:                         respParameters['Setup'] = setup",
          "1186:                         # TODO: Make sure we're calculating the pad right",
          "1187:                         if len(parameters) > 0:",
          "1188:                             # padLen = 4 - (71 + len(setup)) % 4",
          "1189:                             padLen = (4 - (73 + len(setup)) % 4) % 4",
          "1190:                             padBytes = b'\\xFF' * padLen",
          "1191:                             respData['Pad1'] = padBytes",
          "1192:                             respParameters['ParameterOffset'] = 73 + len(setup) + padLen",
          "1193:                         else:",
          "1194:                             padLen = 0",
          "1195:                             respParameters['ParameterOffset'] = 0",
          "1196:                             respData['Pad1'] = b''",
          "1198:                         if len(data) > 0:",
          "1199:                             # pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4",
          "1200:                             pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1201:                             respData['Pad2'] = b'\\xFF' * pad2Len",
          "1202:                             respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len",
          "1203:                         else:",
          "1204:                             respParameters['DataOffset'] = 0",
          "1205:                             respData['Pad2'] = b''",
          "1207:                         respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1208:                         respData['NT_Trans_Data'] = data[:respParameters['DataCount']]",
          "1209:                         respSMBCommand['Parameters'] = respParameters",
          "1210:                         respSMBCommand['Data'] = respData",
          "1212:                         data = data[respParameters['DataCount']:]",
          "1213:                         remainingData -= respParameters['DataCount']",
          "1214:                         dataDisplacement += respParameters['DataCount'] + 1",
          "1216:                         parameters = parameters[respParameters['ParameterCount']:]",
          "1217:                         remainingParameters -= respParameters['ParameterCount']",
          "1218:                         commands.append(respSMBCommand)",
          "1220:                     smbServer.setConnectionData(connId, connData)",
          "1221:                     return commands, None, errorCode",
          "1224:                 # smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)",
          "1225:                 respParameters = b''",
          "1226:                 respData = b''",
          "1227:                 errorCode = STATUS_NOT_IMPLEMENTED",
          "1229:         respSMBCommand['Parameters'] = respParameters",
          "1230:         respSMBCommand['Data'] = respData",
          "1241:         trans2Parameters = smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])",
          "1245:             # TODO: Handle partial parameters",
          "1246:             # print \"Unsupported partial parameters in TRANSACT2!\"",
          "1250:             # Standard says servers shouldn't trust Parameters and Data comes",
          "1251:             # in order, so we have to parse the offsets, ugly",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1229:             if trans2Parameters['ParameterOffset'] > 0:",
          "1230:                 paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']",
          "1232:             else:",
          "1233:                 trans2Data['Trans_Parameters'] = b''",
          "1235:             if trans2Parameters['DataOffset'] > 0:",
          "1236:                 dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']",
          "1237:                 trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]",
          "1239:                 trans2Data['Trans_Data'] = b''",
          "1241:             # Call the handler for this TRANSACTION",
          "1242:             command = struct.unpack('<H', trans2Parameters['Setup'])[0]",
          "1243:             if command in transCommands:",
          "1330:             else:",
          "1339:         smbServer.setConnectionData(connId, connData)",
          "1340:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1231:                 trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset+paramCount]",
          "1238:             else:",
          "1244:                # Call the TRANS2 subcommand",
          "1245:                try:",
          "1246:                    setup, parameters, data, errorCode = transCommands[command](connId,",
          "1247:                                 smbServer,",
          "1248:                                 recvPacket,",
          "1249:                                 trans2Data['Trans_Parameters'],",
          "1250:                                 trans2Data['Trans_Data'],",
          "1251:                                 trans2Parameters['MaxDataCount'])",
          "1252:                except Exception as e:",
          "1253:                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)",
          "1254:                    #import traceback",
          "1255:                    #traceback.print_exc()",
          "1256:                    raise",
          "1258:                if setup == b'' and parameters == b'' and data == b'':",
          "1259:                    # Something wen't wrong",
          "1260:                    respParameters = b''",
          "1261:                    respData = b''",
          "1262:                else:",
          "1263:                    # Build the answer",
          "1264:                    if hasattr(data, 'getData'):",
          "1265:                        data = data.getData()",
          "1266:                    remainingData = len(data)",
          "1267:                    if hasattr(parameters, 'getData'):",
          "1268:                        parameters = parameters.getData()",
          "1269:                    remainingParameters = len(parameters)",
          "1270:                    commands = []",
          "1271:                    dataDisplacement = 0",
          "1272:                    while remainingData > 0 or remainingParameters > 0:",
          "1273:                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1274:                        respParameters = smb.SMBTransaction2Response_Parameters()",
          "1275:                        respData       = smb.SMBTransaction2Response_Data()",
          "1277:                        respParameters['TotalParameterCount'] = len(parameters)",
          "1278:                        respParameters['ParameterCount']      = len(parameters)",
          "1279:                        respData['Trans_ParametersLength']    = len(parameters)",
          "1280:                        respParameters['TotalDataCount']      = len(data)",
          "1281:                        respParameters['DataDisplacement']    = dataDisplacement",
          "1282:                        # TODO: Do the same for parameters",
          "1283:                        if len(data) >  trans2Parameters['MaxDataCount']:",
          "1284:                            # Answer doesn't fit in this packet",
          "1285:                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data),trans2Parameters['MaxDataCount']) )",
          "1286:                            respParameters['DataCount'] = trans2Parameters['MaxDataCount']",
          "1287:                        else:",
          "1288:                            respParameters['DataCount'] = len(data)",
          "1290:                        respData['Trans_DataLength']          = respParameters['DataCount']",
          "1291:                        respParameters['SetupCount']          = len(setup)",
          "1292:                        respParameters['Setup']               = setup",
          "1293:                        # TODO: Make sure we're calculating the pad right",
          "1294:                        if len(parameters) > 0:",
          "1295:                            #padLen = 4 - (55 + len(setup)) % 4",
          "1296:                            padLen = (4 - (55 + len(setup)) % 4 ) % 4",
          "1297:                            padBytes = b'\\xFF' * padLen",
          "1298:                            respData['Pad1'] = padBytes",
          "1299:                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
          "1300:                        else:",
          "1301:                            padLen = 0",
          "1302:                            respParameters['ParameterOffset'] = 0",
          "1303:                            respData['Pad1']                  = b''",
          "1305:                        if len(data) > 0:",
          "1306:                            #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
          "1307:                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1308:                            respData['Pad2'] = b'\\xFF' * pad2Len",
          "1309:                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
          "1310:                        else:",
          "1311:                            respParameters['DataOffset'] = 0",
          "1312:                            respData['Pad2']             = b''",
          "1314:                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1315:                        respData['Trans_Data']       = data[:respParameters['DataCount']]",
          "1316:                        respSMBCommand['Parameters'] = respParameters",
          "1317:                        respSMBCommand['Data']       = respData",
          "1319:                        data = data[respParameters['DataCount']:]",
          "1320:                        remainingData -= respParameters['DataCount']",
          "1321:                        dataDisplacement += respParameters['DataCount'] + 1",
          "1323:                        parameters = parameters[respParameters['ParameterCount']:]",
          "1324:                        remainingParameters -= respParameters['ParameterCount']",
          "1325:                        commands.append(respSMBCommand)",
          "1327:                    smbServer.setConnectionData(connId, connData)",
          "1328:                    return commands, None, errorCode",
          "1331:                smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)",
          "1332:                respParameters = b''",
          "1333:                respData = b''",
          "1334:                errorCode = STATUS_NOT_IMPLEMENTED",
          "1336:         respSMBCommand['Parameters']             = respParameters",
          "1337:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1260:                 trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]",
          "1267:             else:",
          "1273:                 # Call the TRANS2 subcommand",
          "1274:                 try:",
          "1275:                     setup, parameters, data, errorCode = transCommands[command](connId,",
          "1276:                                                                                 smbServer,",
          "1277:                                                                                 recvPacket,",
          "1278:                                                                                 trans2Data['Trans_Parameters'],",
          "1279:                                                                                 trans2Data['Trans_Data'],",
          "1280:                                                                                 trans2Parameters['MaxDataCount'])",
          "1281:                 except Exception as e:",
          "1282:                     smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)",
          "1283:                     # import traceback",
          "1284:                     # traceback.print_exc()",
          "1285:                     raise",
          "1287:                 if setup == b'' and parameters == b'' and data == b'':",
          "1288:                     # Something wen't wrong",
          "1289:                     respParameters = b''",
          "1290:                     respData = b''",
          "1291:                 else:",
          "1292:                     # Build the answer",
          "1293:                     if hasattr(data, 'getData'):",
          "1294:                         data = data.getData()",
          "1295:                     remainingData = len(data)",
          "1296:                     if hasattr(parameters, 'getData'):",
          "1297:                         parameters = parameters.getData()",
          "1298:                     remainingParameters = len(parameters)",
          "1299:                     commands = []",
          "1300:                     dataDisplacement = 0",
          "1301:                     while remainingData > 0 or remainingParameters > 0:",
          "1302:                         respSMBCommand = smb.SMBCommand(recvPacket['Command'])",
          "1303:                         respParameters = smb.SMBTransaction2Response_Parameters()",
          "1304:                         respData = smb.SMBTransaction2Response_Data()",
          "1306:                         respParameters['TotalParameterCount'] = len(parameters)",
          "1307:                         respParameters['ParameterCount'] = len(parameters)",
          "1308:                         respData['Trans_ParametersLength'] = len(parameters)",
          "1309:                         respParameters['TotalDataCount'] = len(data)",
          "1310:                         respParameters['DataDisplacement'] = dataDisplacement",
          "1311:                         # TODO: Do the same for parameters",
          "1312:                         if len(data) > trans2Parameters['MaxDataCount']:",
          "1313:                             # Answer doesn't fit in this packet",
          "1314:                             LOG.debug(\"Lowering answer from %d to %d\" % (len(data), trans2Parameters['MaxDataCount']))",
          "1315:                             respParameters['DataCount'] = trans2Parameters['MaxDataCount']",
          "1316:                         else:",
          "1317:                             respParameters['DataCount'] = len(data)",
          "1319:                         respData['Trans_DataLength'] = respParameters['DataCount']",
          "1320:                         respParameters['SetupCount'] = len(setup)",
          "1321:                         respParameters['Setup'] = setup",
          "1322:                         # TODO: Make sure we're calculating the pad right",
          "1323:                         if len(parameters) > 0:",
          "1324:                             # padLen = 4 - (55 + len(setup)) % 4",
          "1325:                             padLen = (4 - (55 + len(setup)) % 4) % 4",
          "1326:                             padBytes = b'\\xFF' * padLen",
          "1327:                             respData['Pad1'] = padBytes",
          "1328:                             respParameters['ParameterOffset'] = 55 + len(setup) + padLen",
          "1329:                         else:",
          "1330:                             padLen = 0",
          "1331:                             respParameters['ParameterOffset'] = 0",
          "1332:                             respData['Pad1'] = b''",
          "1334:                         if len(data) > 0:",
          "1335:                             # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4",
          "1336:                             pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4",
          "1337:                             respData['Pad2'] = b'\\xFF' * pad2Len",
          "1338:                             respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len",
          "1339:                         else:",
          "1340:                             respParameters['DataOffset'] = 0",
          "1341:                             respData['Pad2'] = b''",
          "1343:                         respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]",
          "1344:                         respData['Trans_Data'] = data[:respParameters['DataCount']]",
          "1345:                         respSMBCommand['Parameters'] = respParameters",
          "1346:                         respSMBCommand['Data'] = respData",
          "1348:                         data = data[respParameters['DataCount']:]",
          "1349:                         remainingData -= respParameters['DataCount']",
          "1350:                         dataDisplacement += respParameters['DataCount'] + 1",
          "1352:                         parameters = parameters[respParameters['ParameterCount']:]",
          "1353:                         remainingParameters -= respParameters['ParameterCount']",
          "1354:                         commands.append(respSMBCommand)",
          "1356:                     smbServer.setConnectionData(connId, connData)",
          "1357:                     return commands, None, errorCode",
          "1360:                 smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)",
          "1361:                 respParameters = b''",
          "1362:                 respData = b''",
          "1363:                 errorCode = STATUS_NOT_IMPLEMENTED",
          "1365:         respSMBCommand['Parameters'] = respParameters",
          "1366:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1343:     def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):",
          "1344:         connData = smbServer.getConnectionData(connId)",
          "1350:         # I'm actually doing nothing.. just make MacOS happy ;)",
          "1351:         errorCode = STATUS_SUCCESS",
          "1355:         smbServer.setConnectionData(connId, connData)",
          "1357:         return [respSMBCommand], None, errorCode",
          "1360:     @staticmethod",
          "1361:     def smbComClose(connId, smbServer, SMBCommand, recvPacket):",
          "1362:         connData = smbServer.getConnectionData(connId)",
          "1370:         if comClose['FID'] in connData['OpenedFiles']:",
          "1390:         else:",
          "1391:             errorCode = STATUS_INVALID_HANDLE",
          "1393:         if errorCode > 0:",
          "1394:             respParameters = b''",
          "1399:         smbServer.setConnectionData(connId, connData)",
          "1401:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1346:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)",
          "1347:         respParameters        = b''",
          "1348:         respData              = b''",
          "1353:         respSMBCommand['Parameters']             = respParameters",
          "1354:         respSMBCommand['Data']                   = respData",
          "1364:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)",
          "1365:         respParameters        = b''",
          "1366:         respData              = b''",
          "1368:         comClose =  smb.SMBClose_Parameters(SMBCommand['Parameters'])",
          "1371:              errorCode = STATUS_SUCCESS",
          "1372:              fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']",
          "1373:              try:",
          "1374:                  if fileHandle == PIPE_FILE_DESCRIPTOR:",
          "1375:                      connData['OpenedFiles'][comClose['FID']]['Socket'].close()",
          "1376:                  elif fileHandle != VOID_FILE_DESCRIPTOR:",
          "1377:                      os.close(fileHandle)",
          "1378:              except Exception as e:",
          "1379:                  smbServer.log(\"comClose %s\" % e, logging.ERROR)",
          "1380:                  errorCode = STATUS_ACCESS_DENIED",
          "1381:              else:",
          "1382:                  # Check if the file was marked for removal",
          "1383:                  if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:",
          "1384:                      try:",
          "1385:                          os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])",
          "1386:                      except Exception as e:",
          "1387:                          smbServer.log(\"comClose %s\" % e, logging.ERROR)",
          "1388:                          errorCode = STATUS_ACCESS_DENIED",
          "1389:                  del(connData['OpenedFiles'][comClose['FID']])",
          "1395:             respData       = b''",
          "1397:         respSMBCommand['Parameters']             = respParameters",
          "1398:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1375:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)",
          "1376:         respParameters = b''",
          "1377:         respData = b''",
          "1382:         respSMBCommand['Parameters'] = respParameters",
          "1383:         respSMBCommand['Data'] = respData",
          "1392:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)",
          "1393:         respParameters = b''",
          "1394:         respData = b''",
          "1396:         comClose = smb.SMBClose_Parameters(SMBCommand['Parameters'])",
          "1399:             errorCode = STATUS_SUCCESS",
          "1400:             fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']",
          "1401:             try:",
          "1402:                 if fileHandle == PIPE_FILE_DESCRIPTOR:",
          "1403:                     connData['OpenedFiles'][comClose['FID']]['Socket'].close()",
          "1404:                 elif fileHandle != VOID_FILE_DESCRIPTOR:",
          "1405:                     os.close(fileHandle)",
          "1406:             except Exception as e:",
          "1407:                 smbServer.log(\"comClose %s\" % e, logging.ERROR)",
          "1408:                 errorCode = STATUS_ACCESS_DENIED",
          "1409:             else:",
          "1410:                 # Check if the file was marked for removal",
          "1411:                 if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:",
          "1412:                     try:",
          "1413:                         os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])",
          "1414:                     except Exception as e:",
          "1415:                         smbServer.log(\"comClose %s\" % e, logging.ERROR)",
          "1416:                         errorCode = STATUS_ACCESS_DENIED",
          "1417:                 del (connData['OpenedFiles'][comClose['FID']])",
          "1423:             respData = b''",
          "1425:         respSMBCommand['Parameters'] = respParameters",
          "1426:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1404:     def smbComWrite(connId, smbServer, SMBCommand, recvPacket):",
          "1405:         connData = smbServer.getConnectionData(connId)",
          "1412:         comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])",
          "1414:         if comWriteParameters['Fid'] in connData['OpenedFiles']:",
          "1431:         else:",
          "1432:             errorCode = STATUS_INVALID_HANDLE",
          "1435:         if errorCode > 0:",
          "1436:             respParameters = b''",
          "1441:         smbServer.setConnectionData(connId, connData)",
          "1443:         return [respSMBCommand], None, errorCode",
          "1445:     @staticmethod",
          "1447:         connData = smbServer.getConnectionData(connId)",
          "1455:         if comFlush['FID'] in connData['OpenedFiles']:",
          "1463:         else:",
          "1464:             errorCode = STATUS_INVALID_HANDLE",
          "1466:         if errorCode > 0:",
          "1467:             respParameters = b''",
          "1472:         smbServer.setConnectionData(connId, connData)",
          "1474:         return [respSMBCommand], None, errorCode",
          "1477:     @staticmethod",
          "1479:         connData = smbServer.getConnectionData(connId)",
          "1487:         # Get the Tid associated",
          "1488:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1493:                 if fileName[0] == '/' or fileName[0] == '\\\\':",
          "1494:                     # strip leading '/'",
          "1495:                     fileName = fileName[1:]",
          "1498:                 errorCode = STATUS_OBJECT_NAME_COLLISION",
          "1508:         else:",
          "1509:             errorCode = STATUS_SMB_BAD_TID",
          "1512:         if errorCode > 0:",
          "1513:             respParameters = b''",
          "1518:         smbServer.setConnectionData(connId, connData)",
          "1520:         return [respSMBCommand], None, errorCode",
          "1522:     @staticmethod",
          "1524:         connData = smbServer.getConnectionData(connId)",
          "1531:         # Get the Tid associated",
          "1532:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1538:                 # strip leading '/'",
          "1539:                 oldFileName = oldFileName[1:]",
          "1542:                 # strip leading '/'",
          "1543:                 newFileName = newFileName[1:]",
          "1547:                 errorCode = STATUS_NO_SUCH_FILE",
          "1557:         else:",
          "1558:             errorCode = STATUS_SMB_BAD_TID",
          "1561:         if errorCode > 0:",
          "1562:             respParameters = b''",
          "1567:         smbServer.setConnectionData(connId, connData)",
          "1569:         return [respSMBCommand], None, errorCode",
          "1571:     @staticmethod",
          "1573:         connData = smbServer.getConnectionData(connId)",
          "1581:         # Get the Tid associated",
          "1582:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1587:                 # strip leading '/'",
          "1588:                 fileName = fileName[1:]",
          "1591:                 errorCode = STATUS_NO_SUCH_FILE",
          "1601:         else:",
          "1602:             errorCode = STATUS_SMB_BAD_TID",
          "1604:         if errorCode > 0:",
          "1605:             respParameters = b''",
          "1610:         smbServer.setConnectionData(connId, connData)",
          "1612:         return [respSMBCommand], None, errorCode",
          "1615:     @staticmethod",
          "1617:         connData = smbServer.getConnectionData(connId)",
          "1625:         # Get the Tid associated",
          "1626:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1631:                 # strip leading '/'",
          "1632:                 fileName = fileName[1:]",
          "1635:                 errorCode = STATUS_NO_SUCH_FILE",
          "1648:         else:",
          "1649:             errorCode = STATUS_SMB_BAD_TID",
          "1651:         if errorCode > 0:",
          "1652:             respParameters = b''",
          "1657:         smbServer.setConnectionData(connId, connData)",
          "1659:         return [respSMBCommand], None, errorCode",
          "1662:     @staticmethod",
          "1663:     def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):",
          "1664:         connData = smbServer.getConnectionData(connId)",
          "1670:         if SMBCommand['WordCount'] == 0x0C:",
          "1672:             writeAndXData = smb.SMBWriteAndX_Data_Short()",
          "1673:         else:",
          "1675:             writeAndXData = smb.SMBWriteAndX_Data()",
          "1676:         writeAndXData['DataLength'] = writeAndX['DataLength']",
          "1677:         writeAndXData['DataOffset'] = writeAndX['DataOffset']",
          "1678:         writeAndXData.fromString(SMBCommand['Data'])",
          "1681:         if writeAndX['Fid'] in connData['OpenedFiles']:",
          "1702:         else:",
          "1703:             errorCode = STATUS_INVALID_HANDLE",
          "1705:         if errorCode > 0:",
          "1706:             respParameters = b''",
          "1711:         smbServer.setConnectionData(connId, connData)",
          "1713:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1407:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)",
          "1408:         respParameters        = smb.SMBWriteResponse_Parameters()",
          "1409:         respData              = b''",
          "1411:         comWriteParameters =  smb.SMBWrite_Parameters(SMBCommand['Parameters'])",
          "1415:              fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']",
          "1416:              errorCode = STATUS_SUCCESS",
          "1417:              try:",
          "1418:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1419:                      # TODO: Handle big size files",
          "1420:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "1421:                      if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:",
          "1422:                          os.lseek(fileHandle,comWriteParameters['Offset'],0)",
          "1423:                          os.write(fileHandle,comWriteData['Data'])",
          "1424:                  else:",
          "1425:                      sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']",
          "1426:                      sock.send(comWriteData['Data'])",
          "1427:                  respParameters['Count']    = comWriteParameters['Count']",
          "1428:              except Exception as e:",
          "1429:                  smbServer.log('smbComWrite: %s' % e, logging.ERROR)",
          "1430:                  errorCode = STATUS_ACCESS_DENIED",
          "1437:             respData       = b''",
          "1439:         respSMBCommand['Parameters']             = respParameters",
          "1440:         respSMBCommand['Data']                   = respData",
          "1446:     def smbComFlush(connId, smbServer, SMBCommand,recvPacket ):",
          "1449:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)",
          "1450:         respParameters        = b''",
          "1451:         respData              = b''",
          "1453:         comFlush =  smb.SMBFlush_Parameters(SMBCommand['Parameters'])",
          "1456:              errorCode = STATUS_SUCCESS",
          "1457:              fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']",
          "1458:              try:",
          "1459:                  os.fsync(fileHandle)",
          "1460:              except Exception as e:",
          "1461:                  smbServer.log(\"comFlush %s\" % e, logging.ERROR)",
          "1462:                  errorCode = STATUS_ACCESS_DENIED",
          "1468:             respData       = b''",
          "1470:         respSMBCommand['Parameters']             = respParameters",
          "1471:         respSMBCommand['Data']                   = respData",
          "1478:     def smbComCreateDirectory(connId, smbServer, SMBCommand,recvPacket ):",
          "1481:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)",
          "1482:         respParameters        = b''",
          "1483:         respData              = b''",
          "1485:         comCreateDirectoryData=  smb.SMBCreateDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1489:              errorCode = STATUS_SUCCESS",
          "1490:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1491:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comCreateDirectoryData['DirectoryName']).replace('\\\\','/'))",
          "1492:              if len(fileName) > 0:",
          "1496:              pathName = os.path.join(path,fileName)",
          "1497:              if os.path.exists(pathName):",
          "1500:              # TODO: More checks here in the future.. Specially when we support",
          "1501:              # user access",
          "1502:              else:",
          "1503:                  try:",
          "1504:                      os.mkdir(pathName)",
          "1505:                  except Exception as e:",
          "1506:                      smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)",
          "1507:                      errorCode = STATUS_ACCESS_DENIED",
          "1514:             respData       = b''",
          "1516:         respSMBCommand['Parameters']             = respParameters",
          "1517:         respSMBCommand['Data']                   = respData",
          "1523:     def smbComRename(connId, smbServer, SMBCommand, recvPacket ):",
          "1526:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)",
          "1527:         respParameters        = b''",
          "1528:         respData              = b''",
          "1530:         comRenameData      =  smb.SMBRename_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1533:              errorCode = STATUS_SUCCESS",
          "1534:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1535:              oldFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['OldFileName']).replace('\\\\','/'))",
          "1536:              newFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['NewFileName']).replace('\\\\','/'))",
          "1537:              if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):",
          "1540:              oldPathName = os.path.join(path,oldFileName)",
          "1541:              if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):",
          "1544:              newPathName = os.path.join(path,newFileName)",
          "1546:              if os.path.exists(oldPathName) is not True:",
          "1549:              # TODO: More checks here in the future.. Specially when we support",
          "1550:              # user access",
          "1551:              else:",
          "1552:                  try:",
          "1553:                      os.rename(oldPathName,newPathName)",
          "1554:                  except OSError as e:",
          "1555:                      smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)",
          "1556:                      errorCode = STATUS_ACCESS_DENIED",
          "1563:             respData       = b''",
          "1565:         respSMBCommand['Parameters']             = respParameters",
          "1566:         respSMBCommand['Data']                   = respData",
          "1572:     def smbComDelete(connId, smbServer, SMBCommand, recvPacket ):",
          "1575:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)",
          "1576:         respParameters        = b''",
          "1577:         respData              = b''",
          "1579:         comDeleteData         =  smb.SMBDelete_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1583:              errorCode = STATUS_SUCCESS",
          "1584:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1585:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteData['FileName']).replace('\\\\','/'))",
          "1586:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "1589:              pathName = os.path.join(path,fileName)",
          "1590:              if os.path.exists(pathName) is not True:",
          "1593:              # TODO: More checks here in the future.. Specially when we support",
          "1594:              # user access",
          "1595:              else:",
          "1596:                  try:",
          "1597:                      os.remove(pathName)",
          "1598:                  except OSError as e:",
          "1599:                      smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)",
          "1600:                      errorCode = STATUS_ACCESS_DENIED",
          "1606:             respData       = b''",
          "1608:         respSMBCommand['Parameters']             = respParameters",
          "1609:         respSMBCommand['Data']                   = respData",
          "1616:     def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket ):",
          "1619:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)",
          "1620:         respParameters        = b''",
          "1621:         respData              = b''",
          "1623:         comDeleteDirectoryData=  smb.SMBDeleteDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1627:              errorCode = STATUS_SUCCESS",
          "1628:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1629:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteDirectoryData['DirectoryName']).replace('\\\\','/'))",
          "1630:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "1633:              pathName = os.path.join(path,fileName)",
          "1634:              if os.path.exists(pathName) is not True:",
          "1637:              # TODO: More checks here in the future.. Specially when we support",
          "1638:              # user access",
          "1639:              else:",
          "1640:                  try:",
          "1641:                      os.rmdir(pathName)",
          "1642:                  except OSError as e:",
          "1643:                      smbServer.log(\"smbComDeleteDirectory: %s\" % e,logging.ERROR)",
          "1644:                      if e.errno == errno.ENOTEMPTY:",
          "1645:                          errorCode = STATUS_DIRECTORY_NOT_EMPTY",
          "1646:                      else:",
          "1647:                          errorCode = STATUS_ACCESS_DENIED",
          "1653:             respData       = b''",
          "1655:         respSMBCommand['Parameters']             = respParameters",
          "1656:         respSMBCommand['Data']                   = respData",
          "1666:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)",
          "1667:         respParameters        = smb.SMBWriteAndXResponse_Parameters()",
          "1668:         respData              = b''",
          "1671:             writeAndX =  smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])",
          "1674:             writeAndX =  smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])",
          "1682:              fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']",
          "1683:              errorCode = STATUS_SUCCESS",
          "1684:              try:",
          "1685:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1686:                      offset = writeAndX['Offset']",
          "1687:                      if 'HighOffset' in writeAndX.fields:",
          "1688:                          offset += (writeAndX['HighOffset'] << 32)",
          "1689:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "1690:                      if os.lseek(fileHandle, 0, 2) >= offset:",
          "1691:                          os.lseek(fileHandle,offset,0)",
          "1692:                          os.write(fileHandle,writeAndXData['Data'])",
          "1693:                  else:",
          "1694:                      sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']",
          "1695:                      sock.send(writeAndXData['Data'])",
          "1697:                  respParameters['Count']    = writeAndX['DataLength']",
          "1698:                  respParameters['Available']= 0xff",
          "1699:              except Exception as e:",
          "1700:                  smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)",
          "1701:                  errorCode = STATUS_ACCESS_DENIED",
          "1707:             respData       = b''",
          "1709:         respSMBCommand['Parameters']             = respParameters",
          "1710:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1435:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)",
          "1436:         respParameters = smb.SMBWriteResponse_Parameters()",
          "1437:         respData = b''",
          "1439:         comWriteParameters = smb.SMBWrite_Parameters(SMBCommand['Parameters'])",
          "1443:             fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']",
          "1444:             errorCode = STATUS_SUCCESS",
          "1445:             try:",
          "1446:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1447:                     # TODO: Handle big size files",
          "1448:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "1449:                     if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:",
          "1450:                         os.lseek(fileHandle, comWriteParameters['Offset'], 0)",
          "1451:                         os.write(fileHandle, comWriteData['Data'])",
          "1452:                 else:",
          "1453:                     sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']",
          "1454:                     sock.send(comWriteData['Data'])",
          "1455:                 respParameters['Count'] = comWriteParameters['Count']",
          "1456:             except Exception as e:",
          "1457:                 smbServer.log('smbComWrite: %s' % e, logging.ERROR)",
          "1458:                 errorCode = STATUS_ACCESS_DENIED",
          "1464:             respData = b''",
          "1466:         respSMBCommand['Parameters'] = respParameters",
          "1467:         respSMBCommand['Data'] = respData",
          "1473:     def smbComFlush(connId, smbServer, SMBCommand, recvPacket):",
          "1476:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)",
          "1477:         respParameters = b''",
          "1478:         respData = b''",
          "1480:         comFlush = smb.SMBFlush_Parameters(SMBCommand['Parameters'])",
          "1483:             errorCode = STATUS_SUCCESS",
          "1484:             fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']",
          "1485:             try:",
          "1486:                 os.fsync(fileHandle)",
          "1487:             except Exception as e:",
          "1488:                 smbServer.log(\"comFlush %s\" % e, logging.ERROR)",
          "1489:                 errorCode = STATUS_ACCESS_DENIED",
          "1495:             respData = b''",
          "1497:         respSMBCommand['Parameters'] = respParameters",
          "1498:         respSMBCommand['Data'] = respData",
          "1504:     def smbComCreateDirectory(connId, smbServer, SMBCommand, recvPacket):",
          "1507:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)",
          "1508:         respParameters = b''",
          "1509:         respData = b''",
          "1511:         comCreateDirectoryData = smb.SMBCreateDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "1515:             errorCode = STATUS_SUCCESS",
          "1516:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1517:             fileName = os.path.normpath(",
          "1518:                 decodeSMBString(recvPacket['Flags2'], comCreateDirectoryData['DirectoryName']).replace('\\\\', '/'))",
          "1519:             if len(fileName) > 0:",
          "1523:             pathName = os.path.join(path, fileName)",
          "1524:             if os.path.exists(pathName):",
          "1527:             # TODO: More checks here in the future.. Specially when we support",
          "1528:             # user access",
          "1529:             else:",
          "1530:                 try:",
          "1531:                     os.mkdir(pathName)",
          "1532:                 except Exception as e:",
          "1533:                     smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)",
          "1534:                     errorCode = STATUS_ACCESS_DENIED",
          "1540:             respData = b''",
          "1542:         respSMBCommand['Parameters'] = respParameters",
          "1543:         respSMBCommand['Data'] = respData",
          "1549:     def smbComRename(connId, smbServer, SMBCommand, recvPacket):",
          "1552:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)",
          "1553:         respParameters = b''",
          "1554:         respData = b''",
          "1556:         comRenameData = smb.SMBRename_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "1559:             errorCode = STATUS_SUCCESS",
          "1560:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1561:             oldFileName = os.path.normpath(",
          "1562:                 decodeSMBString(recvPacket['Flags2'], comRenameData['OldFileName']).replace('\\\\', '/'))",
          "1563:             newFileName = os.path.normpath(",
          "1564:                 decodeSMBString(recvPacket['Flags2'], comRenameData['NewFileName']).replace('\\\\', '/'))",
          "1565:             if len(oldFileName) > 0 and (oldFileName[0] == '/' or oldFileName[0] == '\\\\'):",
          "1568:             oldPathName = os.path.join(path, oldFileName)",
          "1569:             if len(newFileName) > 0 and (newFileName[0] == '/' or newFileName[0] == '\\\\'):",
          "1572:             newPathName = os.path.join(path, newFileName)",
          "1574:             if os.path.exists(oldPathName) is not True:",
          "1577:             # TODO: More checks here in the future.. Specially when we support",
          "1578:             # user access",
          "1579:             else:",
          "1580:                 try:",
          "1581:                     os.rename(oldPathName, newPathName)",
          "1582:                 except OSError as e:",
          "1583:                     smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)",
          "1584:                     errorCode = STATUS_ACCESS_DENIED",
          "1590:             respData = b''",
          "1592:         respSMBCommand['Parameters'] = respParameters",
          "1593:         respSMBCommand['Data'] = respData",
          "1599:     def smbComDelete(connId, smbServer, SMBCommand, recvPacket):",
          "1602:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)",
          "1603:         respParameters = b''",
          "1604:         respData = b''",
          "1606:         comDeleteData = smb.SMBDelete_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "1610:             errorCode = STATUS_SUCCESS",
          "1611:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1612:             fileName = os.path.normpath(",
          "1613:                 decodeSMBString(recvPacket['Flags2'], comDeleteData['FileName']).replace('\\\\', '/'))",
          "1614:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "1617:             pathName = os.path.join(path, fileName)",
          "1618:             if os.path.exists(pathName) is not True:",
          "1621:             # TODO: More checks here in the future.. Specially when we support",
          "1622:             # user access",
          "1623:             else:",
          "1624:                 try:",
          "1625:                     os.remove(pathName)",
          "1626:                 except OSError as e:",
          "1627:                     smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)",
          "1628:                     errorCode = STATUS_ACCESS_DENIED",
          "1634:             respData = b''",
          "1636:         respSMBCommand['Parameters'] = respParameters",
          "1637:         respSMBCommand['Data'] = respData",
          "1643:     def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket):",
          "1646:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)",
          "1647:         respParameters = b''",
          "1648:         respData = b''",
          "1650:         comDeleteDirectoryData = smb.SMBDeleteDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "1654:             errorCode = STATUS_SUCCESS",
          "1655:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "1656:             fileName = os.path.normpath(",
          "1657:                 decodeSMBString(recvPacket['Flags2'], comDeleteDirectoryData['DirectoryName']).replace('\\\\', '/'))",
          "1658:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "1661:             pathName = os.path.join(path, fileName)",
          "1662:             if os.path.exists(pathName) is not True:",
          "1665:             # TODO: More checks here in the future.. Specially when we support",
          "1666:             # user access",
          "1667:             else:",
          "1668:                 try:",
          "1669:                     os.rmdir(pathName)",
          "1670:                 except OSError as e:",
          "1671:                     smbServer.log(\"smbComDeleteDirectory: %s\" % e, logging.ERROR)",
          "1672:                     if e.errno == errno.ENOTEMPTY:",
          "1673:                         errorCode = STATUS_DIRECTORY_NOT_EMPTY",
          "1674:                     else:",
          "1675:                         errorCode = STATUS_ACCESS_DENIED",
          "1681:             respData = b''",
          "1683:         respSMBCommand['Parameters'] = respParameters",
          "1684:         respSMBCommand['Data'] = respData",
          "1693:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)",
          "1694:         respParameters = smb.SMBWriteAndXResponse_Parameters()",
          "1695:         respData = b''",
          "1698:             writeAndX = smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])",
          "1701:             writeAndX = smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])",
          "1708:             fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']",
          "1709:             errorCode = STATUS_SUCCESS",
          "1710:             try:",
          "1711:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1712:                     offset = writeAndX['Offset']",
          "1713:                     if 'HighOffset' in writeAndX.fields:",
          "1714:                         offset += (writeAndX['HighOffset'] << 32)",
          "1715:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "1716:                     if os.lseek(fileHandle, 0, 2) >= offset:",
          "1717:                         os.lseek(fileHandle, offset, 0)",
          "1718:                         os.write(fileHandle, writeAndXData['Data'])",
          "1719:                 else:",
          "1720:                     sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']",
          "1721:                     sock.send(writeAndXData['Data'])",
          "1723:                 respParameters['Count'] = writeAndX['DataLength']",
          "1724:                 respParameters['Available'] = 0xff",
          "1725:             except Exception as e:",
          "1726:                 smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)",
          "1727:                 errorCode = STATUS_ACCESS_DENIED",
          "1733:             respData = b''",
          "1735:         respSMBCommand['Parameters'] = respParameters",
          "1736:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1716:     def smbComRead(connId, smbServer, SMBCommand, recvPacket):",
          "1717:         connData = smbServer.getConnectionData(connId)",
          "1725:         if comReadParameters['Fid'] in connData['OpenedFiles']:",
          "1742:         else:",
          "1743:             errorCode = STATUS_INVALID_HANDLE",
          "1745:         if errorCode > 0:",
          "1746:             respParameters = b''",
          "1751:         smbServer.setConnectionData(connId, connData)",
          "1753:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1719:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ)",
          "1720:         respParameters        = smb.SMBReadResponse_Parameters()",
          "1721:         respData              = smb.SMBReadResponse_Data()",
          "1723:         comReadParameters =  smb.SMBRead_Parameters(SMBCommand['Parameters'])",
          "1726:              fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']",
          "1727:              errorCode = STATUS_SUCCESS",
          "1728:              try:",
          "1729:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1730:                      # TODO: Handle big size files",
          "1731:                      os.lseek(fileHandle,comReadParameters['Offset'],0)",
          "1732:                      content = os.read(fileHandle,comReadParameters['Count'])",
          "1733:                  else:",
          "1734:                      sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']",
          "1735:                      content = sock.recv(comReadParameters['Count'])",
          "1736:                  respParameters['Count']    = len(content)",
          "1737:                  respData['DataLength']     = len(content)",
          "1738:                  respData['Data']           = content",
          "1739:              except Exception as e:",
          "1740:                  smbServer.log('smbComRead: %s ' % e, logging.ERROR)",
          "1741:                  errorCode = STATUS_ACCESS_DENIED",
          "1747:             respData       = b''",
          "1749:         respSMBCommand['Parameters']             = respParameters",
          "1750:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1745:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ)",
          "1746:         respParameters = smb.SMBReadResponse_Parameters()",
          "1747:         respData = smb.SMBReadResponse_Data()",
          "1749:         comReadParameters = smb.SMBRead_Parameters(SMBCommand['Parameters'])",
          "1752:             fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']",
          "1753:             errorCode = STATUS_SUCCESS",
          "1754:             try:",
          "1755:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1756:                     # TODO: Handle big size files",
          "1757:                     os.lseek(fileHandle, comReadParameters['Offset'], 0)",
          "1758:                     content = os.read(fileHandle, comReadParameters['Count'])",
          "1759:                 else:",
          "1760:                     sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']",
          "1761:                     content = sock.recv(comReadParameters['Count'])",
          "1762:                 respParameters['Count'] = len(content)",
          "1763:                 respData['DataLength'] = len(content)",
          "1764:                 respData['Data'] = content",
          "1765:             except Exception as e:",
          "1766:                 smbServer.log('smbComRead: %s ' % e, logging.ERROR)",
          "1767:                 errorCode = STATUS_ACCESS_DENIED",
          "1773:             respData = b''",
          "1775:         respSMBCommand['Parameters'] = respParameters",
          "1776:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1756:     def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):",
          "1757:         connData = smbServer.getConnectionData(connId)",
          "1763:         if SMBCommand['WordCount'] == 0x0A:",
          "1765:         else:",
          "1768:         if readAndX['Fid'] in connData['OpenedFiles']:",
          "1789:         else:",
          "1790:             errorCode = STATUS_INVALID_HANDLE",
          "1792:         if errorCode > 0:",
          "1793:             respParameters = b''",
          "1798:         smbServer.setConnectionData(connId, connData)",
          "1800:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1759:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)",
          "1760:         respParameters        = smb.SMBReadAndXResponse_Parameters()",
          "1761:         respData              = b''",
          "1764:             readAndX =  smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])",
          "1766:             readAndX =  smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])",
          "1769:              fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']",
          "1770:              errorCode = 0",
          "1771:              try:",
          "1772:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1773:                      offset = readAndX['Offset']",
          "1774:                      if 'HighOffset' in readAndX.fields:",
          "1775:                          offset += (readAndX['HighOffset'] << 32)",
          "1776:                      os.lseek(fileHandle,offset,0)",
          "1777:                      content = os.read(fileHandle,readAndX['MaxCount'])",
          "1778:                  else:",
          "1779:                      sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']",
          "1780:                      content = sock.recv(readAndX['MaxCount'])",
          "1781:                  respParameters['Remaining']    = 0xffff",
          "1782:                  respParameters['DataCount']    = len(content)",
          "1783:                  respParameters['DataOffset']   = 59",
          "1784:                  respParameters['DataCount_Hi'] = 0",
          "1785:                  respData = content",
          "1786:              except Exception as e:",
          "1787:                  smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)",
          "1788:                  errorCode = STATUS_ACCESS_DENIED",
          "1794:             respData       = b''",
          "1796:         respSMBCommand['Parameters']             = respParameters",
          "1797:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1785:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)",
          "1786:         respParameters = smb.SMBReadAndXResponse_Parameters()",
          "1787:         respData = b''",
          "1790:             readAndX = smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])",
          "1792:             readAndX = smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])",
          "1795:             fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']",
          "1796:             errorCode = 0",
          "1797:             try:",
          "1798:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "1799:                     offset = readAndX['Offset']",
          "1800:                     if 'HighOffset' in readAndX.fields:",
          "1801:                         offset += (readAndX['HighOffset'] << 32)",
          "1802:                     os.lseek(fileHandle, offset, 0)",
          "1803:                     content = os.read(fileHandle, readAndX['MaxCount'])",
          "1804:                 else:",
          "1805:                     sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']",
          "1806:                     content = sock.recv(readAndX['MaxCount'])",
          "1807:                 respParameters['Remaining'] = 0xffff",
          "1808:                 respParameters['DataCount'] = len(content)",
          "1809:                 respParameters['DataOffset'] = 59",
          "1810:                 respParameters['DataCount_Hi'] = 0",
          "1811:                 respData = content",
          "1812:             except Exception as e:",
          "1813:                 smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)",
          "1814:                 errorCode = STATUS_ACCESS_DENIED",
          "1820:             respData = b''",
          "1822:         respSMBCommand['Parameters'] = respParameters",
          "1823:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1806:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)",
          "1807:         respParameters = smb.SMBQueryInformationResponse_Parameters()",
          "1812:         # Get the Tid associated",
          "1813:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1814:             fileSize, lastWriteTime, fileAttributes = queryFsInformation(",
          "1820:             respParameters['FileAttributes'] = fileAttributes",
          "1821:             errorCode = STATUS_SUCCESS",
          "1822:         else:",
          "1823:             # STATUS_SMB_BAD_TID",
          "1824:             errorCode = STATUS_SMB_BAD_TID",
          "1831:         smbServer.setConnectionData(connId, connData)",
          "1832:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1808:         respData       = b''",
          "1810:         queryInformation= smb.SMBQueryInformation_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1815:                 connData['ConnectedShares'][recvPacket['Tid']]['path'],",
          "1816:                 decodeSMBString(recvPacket['Flags2'],queryInformation['FileName']), pktFlags = recvPacket['Flags2'])",
          "1818:             respParameters['FileSize']       = fileSize",
          "1819:             respParameters['LastWriteTime']  = lastWriteTime",
          "1825:             respParameters  = b''",
          "1826:             respData        = b''",
          "1828:         respSMBCommand['Parameters']             = respParameters",
          "1829:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1834:         respData = b''",
          "1836:         queryInformation = smb.SMBQueryInformation_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "1841:                 connData['ConnectedShares'][recvPacket['Tid']]['path'],",
          "1842:                 decodeSMBString(recvPacket['Flags2'], queryInformation['FileName']), pktFlags=recvPacket['Flags2'])",
          "1844:             respParameters['FileSize'] = fileSize",
          "1845:             respParameters['LastWriteTime'] = lastWriteTime",
          "1851:             respParameters = b''",
          "1852:             respData = b''",
          "1854:         respSMBCommand['Parameters'] = respParameters",
          "1855:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1838:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)",
          "1839:         respParameters = smb.SMBQueryInformationDiskResponse_Parameters()",
          "1842:         # Get the Tid associated",
          "1843:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1844:             totalUnits, freeUnits = queryDiskInformation(",
          "1848:             respParameters['BlocksPerUnit'] = 1",
          "1851:             errorCode = STATUS_SUCCESS",
          "1852:         else:",
          "1853:             # STATUS_SMB_BAD_TID",
          "1855:             respParameters = b''",
          "1856:             errorCode = STATUS_SMB_BAD_TID",
          "1862:         smbServer.setConnectionData(connId, connData)",
          "1863:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1840:         respData       = b''",
          "1845:                         connData['ConnectedShares'][recvPacket['Tid']]['path'])",
          "1847:             respParameters['TotalUnits']    = totalUnits",
          "1849:             respParameters['BlockSize']     = 1",
          "1850:             respParameters['FreeUnits']     = freeUnits",
          "1854:             respData  = b''",
          "1859:         respSMBCommand['Parameters']             = respParameters",
          "1860:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1866:         respData = b''",
          "1871:                 connData['ConnectedShares'][recvPacket['Tid']]['path'])",
          "1873:             respParameters['TotalUnits'] = totalUnits",
          "1875:             respParameters['BlockSize'] = 1",
          "1876:             respParameters['FreeUnits'] = freeUnits",
          "1880:             respData = b''",
          "1884:         respSMBCommand['Parameters'] = respParameters",
          "1885:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1869:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)",
          "1870:         respParameters = smb.SMBEchoResponse_Parameters()",
          "1875:         respParameters['SequenceNumber'] = 1",
          "1881:         errorCode = STATUS_SUCCESS",
          "1882:         smbServer.setConnectionData(connId, connData)",
          "",
          "[Removed Lines]",
          "1871:         respData       = smb.SMBEchoResponse_Data()",
          "1873:         echoData       = smb.SMBEcho_Data(SMBCommand['Data'])",
          "1876:         respData['Data']                 = echoData['Data']",
          "1878:         respSMBCommand['Parameters']     = respParameters",
          "1879:         respSMBCommand['Data']           = respData",
          "",
          "[Added Lines]",
          "1896:         respData = smb.SMBEchoResponse_Data()",
          "1898:         echoData = smb.SMBEcho_Data(SMBCommand['Data'])",
          "1901:         respData['Data'] = echoData['Data']",
          "1903:         respSMBCommand['Parameters'] = respParameters",
          "1904:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1893:         respData = b''",
          "1895:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "1898:             errorCode = STATUS_SUCCESS",
          "1899:         else:",
          "1900:             # STATUS_SMB_BAD_TID",
          "1901:             errorCode = STATUS_SMB_BAD_TID",
          "1903:         respSMBCommand['Parameters'] = respParameters",
          "1906:         smbServer.setConnectionData(connId, connData)",
          "1907:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1896:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (recvPacket['Tid'],connData['ConnectedShares'][recvPacket['Tid']]['shareName']))",
          "1897:             del(connData['ConnectedShares'][recvPacket['Tid']])",
          "1904:         respSMBCommand['Data']       = respData",
          "",
          "[Added Lines]",
          "1921:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (",
          "1922:             recvPacket['Tid'], connData['ConnectedShares'][recvPacket['Tid']]['shareName']))",
          "1923:             del (connData['ConnectedShares'][recvPacket['Tid']])",
          "1930:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1910:     def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):",
          "1911:         connData = smbServer.getConnectionData(connId)",
          "1915:         # Check if the Uid matches the user trying to logoff",
          "1916:         respParameters = b''",
          "",
          "[Removed Lines]",
          "1913:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)",
          "",
          "[Added Lines]",
          "1939:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1921:         else:",
          "1922:             errorCode = STATUS_SUCCESS",
          "1926:         connData['Uid'] = 0",
          "1927:         connData['Authenticated'] = False",
          "",
          "[Removed Lines]",
          "1924:         respSMBCommand['Parameters']   = respParameters",
          "1925:         respSMBCommand['Data']         = respData",
          "",
          "[Added Lines]",
          "1950:         respSMBCommand['Parameters'] = respParameters",
          "1951:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1934:     def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):",
          "1935:         connData = smbServer.getConnectionData(connId)",
          "1941:         queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])",
          "1942:         errorCode = 0xFF",
          "1943:         if queryInformation2['Fid'] in connData['OpenedFiles']:",
          "1966:         if errorCode > 0:",
          "1967:             respParameters = b''",
          "1972:         smbServer.setConnectionData(connId, connData)",
          "1974:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "1937:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)",
          "1938:         respParameters        = smb.SMBQueryInformation2Response_Parameters()",
          "1939:         respData              = b''",
          "1944:              errorCode = STATUS_SUCCESS",
          "1945:              pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']",
          "1946:              try:",
          "1947:                  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
          "1948:                  respParameters['CreateDate']         = getSMBDate(ctime)",
          "1949:                  respParameters['CreationTime']       = getSMBTime(ctime)",
          "1950:                  respParameters['LastAccessDate']     = getSMBDate(atime)",
          "1951:                  respParameters['LastAccessTime']     = getSMBTime(atime)",
          "1952:                  respParameters['LastWriteDate']      = getSMBDate(mtime)",
          "1953:                  respParameters['LastWriteTime']      = getSMBTime(mtime)",
          "1954:                  respParameters['FileDataSize']       = size",
          "1955:                  respParameters['FileAllocationSize'] = size",
          "1956:                  attribs = 0",
          "1957:                  if os.path.isdir(pathName):",
          "1958:                      attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
          "1959:                  if os.path.isfile(pathName):",
          "1960:                      attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL",
          "1961:                  respParameters['FileAttributes'] = attribs",
          "1962:              except Exception as e:",
          "1963:                  smbServer.log('smbComQueryInformation2 %s' % e,logging.ERROR)",
          "1964:                  errorCode = STATUS_ACCESS_DENIED",
          "1968:             respData       = b''",
          "1970:         respSMBCommand['Parameters']             = respParameters",
          "1971:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "1963:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)",
          "1964:         respParameters = smb.SMBQueryInformation2Response_Parameters()",
          "1965:         respData = b''",
          "1970:             errorCode = STATUS_SUCCESS",
          "1971:             pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']",
          "1972:             try:",
          "1973:                 (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)",
          "1974:                 respParameters['CreateDate'] = getSMBDate(ctime)",
          "1975:                 respParameters['CreationTime'] = getSMBTime(ctime)",
          "1976:                 respParameters['LastAccessDate'] = getSMBDate(atime)",
          "1977:                 respParameters['LastAccessTime'] = getSMBTime(atime)",
          "1978:                 respParameters['LastWriteDate'] = getSMBDate(mtime)",
          "1979:                 respParameters['LastWriteTime'] = getSMBTime(mtime)",
          "1980:                 respParameters['FileDataSize'] = size",
          "1981:                 respParameters['FileAllocationSize'] = size",
          "1982:                 attribs = 0",
          "1983:                 if os.path.isdir(pathName):",
          "1984:                     attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
          "1985:                 if os.path.isfile(pathName):",
          "1986:                     attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL",
          "1987:                 respParameters['FileAttributes'] = attribs",
          "1988:             except Exception as e:",
          "1989:                 smbServer.log('smbComQueryInformation2 %s' % e, logging.ERROR)",
          "1990:                 errorCode = STATUS_ACCESS_DENIED",
          "1994:             respData = b''",
          "1996:         respSMBCommand['Parameters'] = respParameters",
          "1997:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1978:         # TODO: Fully implement this",
          "1979:         connData = smbServer.getConnectionData(connId)",
          "1985:         ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])",
          "1989:         #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()",
          "1990:         #    respParameters['VolumeGUID'] = '\\x00'",
          "1992:         # Get the Tid associated",
          "1993:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "2010:                 # strip leading '/'",
          "2011:                 fileName = fileName[1:]",
          "2066:                         errorCode = STATUS_FILE_IS_A_DIRECTORY",
          "2074:                             fid = VOID_FILE_DESCRIPTOR",
          "2076:                             if sys.platform == 'win32':",
          "2078:                             if str(pathName) in smbServer.getRegisteredNamedPipes():",
          "2079:                                 fid = PIPE_FILE_DESCRIPTOR",
          "2080:                                 sock = socket.socket()",
          "2081:                                 sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])",
          "2082:                             else:",
          "2083:                                 fid = os.open(pathName, mode)",
          "2089:         else:",
          "2090:             errorCode = STATUS_SMB_BAD_TID",
          "2092:         if errorCode == STATUS_SUCCESS:",
          "2093:             # Simple way to generate a fid",
          "2094:             if len(connData['OpenedFiles']) == 0:",
          "2096:             else:",
          "2098:             respParameters['Fid'] = fakefid",
          "2099:             respParameters['CreateAction'] = createDisposition",
          "2100:             if fid == PIPE_FILE_DESCRIPTOR:",
          "2101:                 respParameters['FileAttributes'] = 0x80",
          "2102:                 respParameters['IsDirectory'] = 0",
          "2104:                 respParameters['LastAccessTime'] = 0",
          "2106:                 respParameters['LastChangeTime'] = 0",
          "2107:                 respParameters['AllocationSize'] = 4096",
          "2111:             else:",
          "2112:                 if os.path.isdir(pathName):",
          "2113:                     respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY",
          "",
          "[Removed Lines]",
          "1981:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)",
          "1982:         respParameters        = smb.SMBNtCreateAndXResponse_Parameters()",
          "1983:         respData              = b''",
          "1986:         ntCreateAndXData       = smb.SMBNtCreateAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "1988:         #if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE",
          "1994:              # If we have a rootFid, the path is relative to that fid",
          "1995:              errorCode = STATUS_SUCCESS",
          "1996:              if ntCreateAndXParameters['RootFid'] > 0:",
          "1997:                  path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']",
          "1998:                  LOG.debug(\"RootFid present %s!\" % path)",
          "1999:              else:",
          "2000:                  if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:",
          "2001:                      path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "2002:                  else:",
          "2003:                      path = 'NONE'",
          "2004:                      errorCode = STATUS_ACCESS_DENIED",
          "2006:              deleteOnClose = False",
          "2008:              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],ntCreateAndXData['FileName']).replace('\\\\','/'))",
          "2009:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "2012:              pathName = os.path.join(path,fileName)",
          "2013:              createDisposition = ntCreateAndXParameters['Disposition']",
          "2014:              mode = 0",
          "2016:              if createDisposition == smb.FILE_SUPERSEDE:",
          "2017:                  mode |= os.O_TRUNC | os.O_CREAT",
          "2018:              elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:",
          "2019:                  mode |= os.O_TRUNC | os.O_CREAT",
          "2020:              elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:",
          "2021:                  if os.path.exists(pathName) is True:",
          "2022:                      mode |= os.O_TRUNC",
          "2023:                  else:",
          "2024:                      errorCode = STATUS_NO_SUCH_FILE",
          "2025:              elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:",
          "2026:                  if os.path.exists(pathName) is True:",
          "2027:                      mode |= os.O_TRUNC",
          "2028:                  else:",
          "2029:                      mode |= os.O_TRUNC | os.O_CREAT",
          "2030:              elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:",
          "2031:                  if os.path.exists(pathName) is True:",
          "2032:                      errorCode = STATUS_OBJECT_NAME_COLLISION",
          "2033:                  else:",
          "2034:                      mode |= os.O_CREAT",
          "2035:              elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:",
          "2036:                  if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
          "2037:                      errorCode = STATUS_NO_SUCH_FILE",
          "2039:              if errorCode == STATUS_SUCCESS:",
          "2040:                  desiredAccess = ntCreateAndXParameters['AccessMask']",
          "2041:                  if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
          "2042:                      mode |= os.O_RDONLY",
          "2043:                  if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):",
          "2044:                      if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
          "2045:                          mode |= os.O_RDWR #| os.O_APPEND",
          "2046:                      else:",
          "2047:                          mode |= os.O_WRONLY #| os.O_APPEND",
          "2048:                  if desiredAccess & smb.GENERIC_ALL:",
          "2049:                      mode |= os.O_RDWR #| os.O_APPEND",
          "2051:                  createOptions =  ntCreateAndXParameters['CreateOptions']",
          "2052:                  if mode & os.O_CREAT == os.O_CREAT:",
          "2053:                      if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:",
          "2054:                          try:",
          "2055:                              # Let's create the directory",
          "2056:                              os.mkdir(pathName)",
          "2057:                              mode = os.O_RDONLY",
          "2058:                          except Exception as e:",
          "2059:                              smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
          "2060:                              errorCode = STATUS_ACCESS_DENIED",
          "2061:                  if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:",
          "2062:                      # If the file being opened is a directory, the server MUST fail the request with",
          "2063:                      # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
          "2064:                      # response.",
          "2065:                      if os.path.isdir(pathName) is True:",
          "2068:                  if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:",
          "2069:                      deleteOnClose = True",
          "2071:                  if errorCode == STATUS_SUCCESS:",
          "2072:                      try:",
          "2073:                          if os.path.isdir(pathName) and sys.platform == 'win32':",
          "2075:                          else:",
          "2077:                                mode |= os.O_BINARY",
          "2084:                      except Exception as e:",
          "2085:                          smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
          "2086:                          #print e",
          "2087:                          fid = 0",
          "2088:                          errorCode = STATUS_ACCESS_DENIED",
          "2095:                fakefid = 1",
          "2097:                fakefid = list(connData['OpenedFiles'].keys())[-1] + 1",
          "2103:                 respParameters['CreateTime']     = 0",
          "2105:                 respParameters['LastWriteTime']  = 0",
          "2108:                 respParameters['EndOfFile']      = 0",
          "2109:                 respParameters['FileType']       = 2",
          "2110:                 respParameters['IPCState']       = 0x5ff",
          "",
          "[Added Lines]",
          "2007:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)",
          "2008:         respParameters = smb.SMBNtCreateAndXResponse_Parameters()",
          "2009:         respData = b''",
          "2012:         ntCreateAndXData = smb.SMBNtCreateAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "2014:         # if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE",
          "2020:             # If we have a rootFid, the path is relative to that fid",
          "2021:             errorCode = STATUS_SUCCESS",
          "2022:             if ntCreateAndXParameters['RootFid'] > 0:",
          "2023:                 path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']",
          "2024:                 LOG.debug(\"RootFid present %s!\" % path)",
          "2025:             else:",
          "2026:                 if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:",
          "2027:                     path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "2028:                 else:",
          "2029:                     path = 'NONE'",
          "2030:                     errorCode = STATUS_ACCESS_DENIED",
          "2032:             deleteOnClose = False",
          "2034:             fileName = os.path.normpath(",
          "2035:                 decodeSMBString(recvPacket['Flags2'], ntCreateAndXData['FileName']).replace('\\\\', '/'))",
          "2036:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "2040:             if not isInFileJail(path, fileName):",
          "2041:                 LOG.error(\"Path not in current working directory\")",
          "2042:                 respSMBCommand['Parameters'] = b''",
          "2043:                 respSMBCommand['Data'] = b''",
          "2044:                 return [respSMBCommand], None, STATUS_ACCESS_DENIED",
          "2046:             pathName = os.path.join(path, fileName)",
          "2047:             createDisposition = ntCreateAndXParameters['Disposition']",
          "2048:             mode = 0",
          "2050:             if createDisposition == smb.FILE_SUPERSEDE:",
          "2051:                 mode |= os.O_TRUNC | os.O_CREAT",
          "2052:             elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:",
          "2053:                 mode |= os.O_TRUNC | os.O_CREAT",
          "2054:             elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:",
          "2055:                 if os.path.exists(pathName) is True:",
          "2056:                     mode |= os.O_TRUNC",
          "2057:                 else:",
          "2058:                     errorCode = STATUS_NO_SUCH_FILE",
          "2059:             elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:",
          "2060:                 if os.path.exists(pathName) is True:",
          "2061:                     mode |= os.O_TRUNC",
          "2062:                 else:",
          "2063:                     mode |= os.O_TRUNC | os.O_CREAT",
          "2064:             elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:",
          "2065:                 if os.path.exists(pathName) is True:",
          "2066:                     errorCode = STATUS_OBJECT_NAME_COLLISION",
          "2067:                 else:",
          "2068:                     mode |= os.O_CREAT",
          "2069:             elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:",
          "2070:                 if os.path.exists(pathName) is not True and (",
          "2071:                         str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
          "2072:                     errorCode = STATUS_NO_SUCH_FILE",
          "2074:             if errorCode == STATUS_SUCCESS:",
          "2075:                 desiredAccess = ntCreateAndXParameters['AccessMask']",
          "2076:                 if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
          "2077:                     mode |= os.O_RDONLY",
          "2078:                 if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):",
          "2079:                     if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):",
          "2080:                         mode |= os.O_RDWR  # | os.O_APPEND",
          "2081:                     else:",
          "2082:                         mode |= os.O_WRONLY  # | os.O_APPEND",
          "2083:                 if desiredAccess & smb.GENERIC_ALL:",
          "2084:                     mode |= os.O_RDWR  # | os.O_APPEND",
          "2086:                 createOptions = ntCreateAndXParameters['CreateOptions']",
          "2087:                 if mode & os.O_CREAT == os.O_CREAT:",
          "2088:                     if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:",
          "2089:                         try:",
          "2090:                             # Let's create the directory",
          "2091:                             os.mkdir(pathName)",
          "2092:                             mode = os.O_RDONLY",
          "2093:                         except Exception as e:",
          "2094:                             smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
          "2095:                             errorCode = STATUS_ACCESS_DENIED",
          "2096:                 if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:",
          "2097:                     # If the file being opened is a directory, the server MUST fail the request with",
          "2098:                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
          "2099:                     # response.",
          "2100:                     if os.path.isdir(pathName) is True:",
          "2103:                 if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:",
          "2104:                     deleteOnClose = True",
          "2106:                 if errorCode == STATUS_SUCCESS:",
          "2107:                     try:",
          "2108:                         if os.path.isdir(pathName) and sys.platform == 'win32':",
          "2110:                         else:",
          "2112:                                 mode |= os.O_BINARY",
          "2119:                     except Exception as e:",
          "2120:                         smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
          "2121:                         # print e",
          "2122:                         fid = 0",
          "2123:                         errorCode = STATUS_ACCESS_DENIED",
          "2130:                 fakefid = 1",
          "2132:                 fakefid = list(connData['OpenedFiles'].keys())[-1] + 1",
          "2138:                 respParameters['CreateTime'] = 0",
          "2140:                 respParameters['LastWriteTime'] = 0",
          "2143:                 respParameters['EndOfFile'] = 0",
          "2144:                 respParameters['FileType'] = 2",
          "2145:                 respParameters['IPCState'] = 0x5ff",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2116:                     respParameters['IsDirectory'] = 0",
          "2117:                     respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']",
          "2118:                 # Let's get this file's information",
          "2120:                 if errorCode == STATUS_SUCCESS:",
          "2122:                     respParameters['LastAccessTime'] = respInfo['LastAccessTime']",
          "2124:                     respParameters['LastChangeTime'] = respInfo['LastChangeTime']",
          "2125:                     respParameters['FileAttributes'] = respInfo['ExtFileAttributes']",
          "2126:                     respParameters['AllocationSize'] = respInfo['AllocationSize']",
          "2128:                 else:",
          "2129:                     respParameters = b''",
          "2132:             if errorCode == STATUS_SUCCESS:",
          "2133:                 # Let's store the fid for the connection",
          "",
          "[Removed Lines]",
          "2119:                 respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)",
          "2121:                     respParameters['CreateTime']     = respInfo['CreationTime']",
          "2123:                     respParameters['LastWriteTime']  = respInfo['LastWriteTime']",
          "2127:                     respParameters['EndOfFile']      = respInfo['EndOfFile']",
          "2130:                     respData       = b''",
          "",
          "[Added Lines]",
          "2154:                 respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)",
          "2156:                     respParameters['CreateTime'] = respInfo['CreationTime']",
          "2158:                     respParameters['LastWriteTime'] = respInfo['LastWriteTime']",
          "2162:                     respParameters['EndOfFile'] = respInfo['EndOfFile']",
          "2165:                     respData = b''",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2135:                 connData['OpenedFiles'][fakefid] = {}",
          "2136:                 connData['OpenedFiles'][fakefid]['FileHandle'] = fid",
          "2137:                 connData['OpenedFiles'][fakefid]['FileName'] = pathName",
          "2139:                 if fid == PIPE_FILE_DESCRIPTOR:",
          "2140:                     connData['OpenedFiles'][fakefid]['Socket'] = sock",
          "2141:         else:",
          "2142:             respParameters = b''",
          "2147:         smbServer.setConnectionData(connId, connData)",
          "2149:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "2138:                 connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose",
          "2143:             respData       = b''",
          "2145:         respSMBCommand['Parameters']             = respParameters",
          "2146:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "2173:                 connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose",
          "2178:             respData = b''",
          "2180:         respSMBCommand['Parameters'] = respParameters",
          "2181:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2152:     def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):",
          "2153:         connData = smbServer.getConnectionData(connId)",
          "2159:         openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])",
          "2162:         # Get the Tid associated",
          "2163:         if recvPacket['Tid'] in connData['ConnectedShares']:",
          "2170:         else:",
          "2173:         if errorCode == STATUS_SUCCESS:",
          "2174:             # Simple way to generate a fid",
          "2176:             if len(connData['OpenedFiles']) == 0:",
          "2178:             else:",
          "2180:             respParameters['Fid'] = fid",
          "2181:             if mode & os.O_CREAT:",
          "2182:                 # File did not exist and was created",
          "",
          "[Removed Lines]",
          "2155:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)",
          "2156:         respParameters        = smb.SMBOpenAndXResponse_Parameters()",
          "2157:         respData              = b''",
          "2160:         openAndXData       = smb.SMBOpenAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])",
          "2164:              path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "2165:              openedFile, mode, pathName, errorCode = openFile(path,",
          "2166:                      decodeSMBString(recvPacket['Flags2'],openAndXData['FileName']),",
          "2167:                      openAndXParameters['DesiredAccess'],",
          "2168:                      openAndXParameters['FileAttributes'],",
          "2169:                      openAndXParameters['OpenMode'])",
          "2171:            errorCode = STATUS_SMB_BAD_TID",
          "2175:             fid = len(connData['OpenedFiles']) + 1",
          "2177:                fid = 1",
          "2179:                fid = list(connData['OpenedFiles'].keys())[-1] + 1",
          "",
          "[Added Lines]",
          "2190:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)",
          "2191:         respParameters = smb.SMBOpenAndXResponse_Parameters()",
          "2192:         respData = b''",
          "2195:         openAndXData = smb.SMBOpenAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])",
          "2199:             path = connData['ConnectedShares'][recvPacket['Tid']]['path']",
          "2200:             openedFile, mode, pathName, errorCode = openFile(path,",
          "2201:                                                              decodeSMBString(recvPacket['Flags2'],",
          "2202:                                                                              openAndXData['FileName']),",
          "2203:                                                              openAndXParameters['DesiredAccess'],",
          "2204:                                                              openAndXParameters['FileAttributes'],",
          "2205:                                                              openAndXParameters['OpenMode'])",
          "2207:             errorCode = STATUS_SMB_BAD_TID",
          "2211:             fid = len(connData['OpenedFiles']) + 1",
          "2213:                 fid = 1",
          "2215:                 fid = list(connData['OpenedFiles'].keys())[-1] + 1",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2190:             else:",
          "2191:                 # File existed and was truncated",
          "2192:                 respParameters['Action'] = 0x3",
          "2194:             # Let's store the fid for the connection",
          "2196:             connData['OpenedFiles'][fid] = {}",
          "2197:             connData['OpenedFiles'][fid]['FileHandle'] = openedFile",
          "2198:             connData['OpenedFiles'][fid]['FileName'] = pathName",
          "2200:         else:",
          "2201:             respParameters = b''",
          "2206:         smbServer.setConnectionData(connId, connData)",
          "2208:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "2195:             #smbServer.log('Opening file %s' % pathName)",
          "2199:             connData['OpenedFiles'][fid]['DeleteOnClose']  = False",
          "2202:             respData       = b''",
          "2204:         respSMBCommand['Parameters']             = respParameters",
          "2205:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "2231:             # smbServer.log('Opening file %s' % pathName)",
          "2235:             connData['OpenedFiles'][fid]['DeleteOnClose'] = False",
          "2238:             respData = b''",
          "2240:         respSMBCommand['Parameters'] = respParameters",
          "2241:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2214:         resp = smb.NewSMBPacket()",
          "2215:         resp['Flags1'] = smb.SMB.FLAGS1_REPLY",
          "2218:         resp['Tid'] = recvPacket['Tid']",
          "2219:         resp['Mid'] = recvPacket['Mid']",
          "2220:         resp['Pid'] = connData['Pid']",
          "2226:         treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])",
          "2228:         if treeConnectAndXParameters['Flags'] & 0x8:",
          "2232:         treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']",
          "2233:         treeConnectAndXData.fromString(SMBCommand['Data'])",
          "",
          "[Removed Lines]",
          "2216:         resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE",
          "2222:         respSMBCommand        = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)",
          "2223:         respParameters        = smb.SMBTreeConnectAndXResponse_Parameters()",
          "2224:         respData              = smb.SMBTreeConnectAndXResponse_Data()",
          "2229:             respParameters        = smb.SMBTreeConnectAndXExtendedResponse_Parameters()",
          "2231:         treeConnectAndXData                    = smb.SMBTreeConnectAndX_Data( flags = recvPacket['Flags2'] )",
          "",
          "[Added Lines]",
          "2252:         resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\",
          "2253:                          recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE",
          "2259:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)",
          "2260:         respParameters = smb.SMBTreeConnectAndXResponse_Parameters()",
          "2261:         respData = smb.SMBTreeConnectAndXResponse_Data()",
          "2266:             respParameters = smb.SMBTreeConnectAndXExtendedResponse_Parameters()",
          "2268:         treeConnectAndXData = smb.SMBTreeConnectAndX_Data(flags=recvPacket['Flags2'])",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2243:         else:",
          "2244:             path = ntpath.basename(UNCOrShare)",
          "2247:         if share is not None:",
          "2248:             # Simple way to generate a Tid",
          "2249:             if len(connData['ConnectedShares']) == 0:",
          "2251:             else:",
          "2253:             connData['ConnectedShares'][tid] = share",
          "2254:             connData['ConnectedShares'][tid]['shareName'] = path",
          "2255:             resp['Tid'] = tid",
          "2257:         else:",
          "2258:             smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)",
          "2259:             errorCode = STATUS_OBJECT_PATH_NOT_FOUND",
          "2262:         ##",
          "2263:         respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS",
          "2265:         if path == 'IPC$':",
          "2267:         else:",
          "2275:         resp['Uid'] = connData['Uid']",
          "2276:         resp.addCommand(respSMBCommand)",
          "",
          "[Removed Lines]",
          "2246:         share = searchShare(connId, path, smbServer)",
          "2250:                tid = 1",
          "2252:                tid = list(connData['ConnectedShares'].keys())[-1] + 1",
          "2256:             #smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
          "2260:             resp['ErrorCode']   = errorCode >> 16",
          "2261:             resp['ErrorClass']  = errorCode & 0xff",
          "2266:             respData['Service']               = 'IPC'",
          "2268:             respData['Service']               = path",
          "2269:         respData['PadLen']                = 0",
          "2270:         respData['NativeFileSystem']      = encodeSMBString(recvPacket['Flags2'], 'NTFS' ).decode()",
          "2272:         respSMBCommand['Parameters']             = respParameters",
          "2273:         respSMBCommand['Data']                   = respData",
          "",
          "[Added Lines]",
          "2283:         share = searchShare(connId, path, smbServer)",
          "2287:                 tid = 1",
          "2289:                 tid = list(connData['ConnectedShares'].keys())[-1] + 1",
          "2293:             # smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
          "2297:             resp['ErrorCode'] = errorCode >> 16",
          "2298:             resp['ErrorClass'] = errorCode & 0xff",
          "2303:             respData['Service'] = 'IPC'",
          "2305:             respData['Service'] = path",
          "2306:         respData['PadLen'] = 0",
          "2307:         respData['NativeFileSystem'] = encodeSMBString(recvPacket['Flags2'], 'NTFS').decode()",
          "2309:         respSMBCommand['Parameters'] = respParameters",
          "2310:         respSMBCommand['Data'] = respData",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2285:     @staticmethod",
          "2286:     def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):",
          "2289:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)",
          "2291:         # From [MS-SMB]",
          "2293:         # request MUST take the following form",
          "2294:         # [..]",
          "2295:         # WordCount (1 byte): The value of this field MUST be 0x0C.",
          "2296:         if SMBCommand['WordCount'] == 12:",
          "2297:             # Extended security. Here we deal with all SPNEGO stuff",
          "2298:             respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()",
          "2300:             sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])",
          "2301:             sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()",
          "2302:             sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']",
          "",
          "[Removed Lines]",
          "2287:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
          "2292:         # When extended security is being used (see section 3.2.4.2.4), the",
          "2299:             respData       = smb.SMBSessionSetupAndX_Extended_Response_Data(flags = recvPacket['Flags2'])",
          "",
          "[Added Lines]",
          "2324:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
          "2329:         # When extended security is being used (see section 3.2.4.2.4), the",
          "2336:             respData = smb.SMBSessionSetupAndX_Extended_Response_Data(flags=recvPacket['Flags2'])",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2304:             connData['Capabilities'] = sessionSetupParameters['Capabilities']",
          "2306:             rawNTLM = False",
          "2338:             else:",
          "2344:             # authentication we are, we act on it",
          "2347:             if messageType == 0x01:",
          "2348:                 # NEGOTIATE_MESSAGE",
          "",
          "[Removed Lines]",
          "2307:             if struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:",
          "2308:                # NEGOTIATE packet",
          "2309:                blob =  SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])",
          "2310:                token = blob['MechToken']",
          "2311:                if len(blob['MechTypes'][0]) > 0:",
          "2312:                    # Is this GSSAPI NTLM or something else we don't support?",
          "2313:                    mechType = blob['MechTypes'][0]",
          "2314:                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
          "2315:                        # Nope, do we know it?",
          "2316:                        if mechType in MechTypes:",
          "2317:                            mechStr = MechTypes[mechType]",
          "2318:                        else:",
          "2319:                            mechStr = hexlify(mechType)",
          "2320:                        smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
          "2321:                        # We don't know the token, we answer back again saying",
          "2322:                        # we just support NTLM.",
          "2323:                        # ToDo: Build this into a SPNEGO_NegTokenResp()",
          "2324:                        respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
          "2325:                        respParameters['SecurityBlobLength'] = len(respToken)",
          "2326:                        respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
          "2327:                        respData['SecurityBlob']       = respToken",
          "2328:                        respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2329:                        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2330:                        respSMBCommand['Parameters'] = respParameters",
          "2331:                        respSMBCommand['Data']       = respData",
          "2332:                        return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
          "2334:             elif struct.unpack('B',sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:",
          "2335:                # AUTH packet",
          "2336:                blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])",
          "2337:                token = blob['ResponseToken']",
          "2339:                # No GSSAPI stuff, raw NTLMSSP",
          "2340:                rawNTLM = True",
          "2341:                token = sessionSetupData['SecurityBlob']",
          "2343:             # Here we only handle NTLMSSP, depending on what stage of the",
          "2345:             messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]",
          "",
          "[Added Lines]",
          "2344:             if struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:",
          "2345:                 # NEGOTIATE packet",
          "2346:                 blob = SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])",
          "2347:                 token = blob['MechToken']",
          "2348:                 if len(blob['MechTypes'][0]) > 0:",
          "2349:                     # Is this GSSAPI NTLM or something else we don't support?",
          "2350:                     mechType = blob['MechTypes'][0]",
          "2351:                     if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
          "2352:                         # Nope, do we know it?",
          "2353:                         if mechType in MechTypes:",
          "2354:                             mechStr = MechTypes[mechType]",
          "2355:                         else:",
          "2356:                             mechStr = hexlify(mechType)",
          "2357:                         smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
          "2358:                         # We don't know the token, we answer back again saying",
          "2359:                         # we just support NTLM.",
          "2360:                         # ToDo: Build this into a SPNEGO_NegTokenResp()",
          "2361:                         respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
          "2362:                         respParameters['SecurityBlobLength'] = len(respToken)",
          "2363:                         respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
          "2364:                         respData['SecurityBlob'] = respToken",
          "2365:                         respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2366:                         respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2367:                         respSMBCommand['Parameters'] = respParameters",
          "2368:                         respSMBCommand['Data'] = respData",
          "2369:                         return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
          "2371:             elif struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:",
          "2372:                 # AUTH packet",
          "2373:                 blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])",
          "2374:                 token = blob['ResponseToken']",
          "2376:                 # No GSSAPI stuff, raw NTLMSSP",
          "2377:                 rawNTLM = True",
          "2378:                 token = sessionSetupData['SecurityBlob']",
          "2380:             # Here we only handle NTLMSSP, depending on what stage of the",
          "2382:             messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2351:                 # Let's store it in the connection data",
          "2352:                 connData['NEGOTIATE_MESSAGE'] = negotiateMessage",
          "2353:                 # Let's build the answer flags",
          "2356:                 ansFlags = 0",
          "2358:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:",
          "2360:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:",
          "2362:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
          "2364:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:",
          "2366:                 if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:",
          "2368:                 if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:",
          "2371:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET",
          "2373:                 # Generate the AV_PAIRS",
          "2374:                 av_pairs = ntlm.AV_PAIRS()",
          "2375:                 # TODO: Put the proper data from SMBSERVER config",
          "2380:                 challengeMessage = ntlm.NTLMAuthChallenge()",
          "2388:                 challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)",
          "2389:                 challengeMessage['TargetInfoFields'] = av_pairs",
          "2394:                 if rawNTLM is False:",
          "2395:                     respToken = SPNEGO_NegTokenResp()",
          "",
          "[Removed Lines]",
          "2354:                 # TODO: Parse all the flags. With this we're leaving some clients out",
          "2359:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
          "2361:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
          "2363:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
          "2365:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
          "2367:                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
          "2369:                    ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
          "2376:                 av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
          "2377:                 av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
          "2378:                 av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )",
          "2381:                 challengeMessage['flags']            = ansFlags",
          "2382:                 challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))",
          "2383:                 challengeMessage['domain_max_len']   = challengeMessage['domain_len']",
          "2384:                 challengeMessage['domain_offset']    = 40 + 16",
          "2385:                 challengeMessage['challenge']        = smbServer.getSMBChallenge()",
          "2386:                 challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')",
          "2387:                 challengeMessage['TargetInfoFields_len']     = len(av_pairs)",
          "2390:                 challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])",
          "2391:                 challengeMessage['Version']          = b'\\xff'*8",
          "2392:                 challengeMessage['VersionLen']       = 8",
          "",
          "[Added Lines]",
          "2391:                 # TODO: Parse all the flags. With this we're leaving some clients out",
          "2396:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
          "2398:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
          "2400:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
          "2402:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
          "2404:                     ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
          "2406:                     ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
          "2413:                 av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[",
          "2414:                     ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
          "2415:                 av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[",
          "2416:                     ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
          "2417:                 av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (",
          "2418:                             116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))",
          "2421:                 challengeMessage['flags'] = ansFlags",
          "2422:                 challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))",
          "2423:                 challengeMessage['domain_max_len'] = challengeMessage['domain_len']",
          "2424:                 challengeMessage['domain_offset'] = 40 + 16",
          "2425:                 challengeMessage['challenge'] = smbServer.getSMBChallenge()",
          "2426:                 challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')",
          "2427:                 challengeMessage['TargetInfoFields_len'] = len(av_pairs)",
          "2430:                 challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])",
          "2431:                 challengeMessage['Version'] = b'\\xff' * 8",
          "2432:                 challengeMessage['VersionLen'] = 8",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2404:                 # Setting the packet to STATUS_MORE_PROCESSING",
          "2405:                 errorCode = STATUS_MORE_PROCESSING_REQUIRED",
          "2407:                 # in the connection's data",
          "2408:                 # Picking a fixed value",
          "2409:                 # TODO: Manage more UIDs for the same session",
          "",
          "[Removed Lines]",
          "2406:                 # Let's set up an UID for this connection and store it",
          "",
          "[Added Lines]",
          "2446:                 # Let's set up an UID for this connection and store it",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2419:                 authenticateMessage = ntlm.NTLMAuthChallengeResponse()",
          "2420:                 authenticateMessage.fromString(token)",
          "2421:                 smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (",
          "2425:                 # Do we have credentials to check?",
          "2426:                 if len(smbServer.getCredentials()) > 0:",
          "2427:                     identity = authenticateMessage['user_name'].decode('utf-16le').lower()",
          "",
          "[Removed Lines]",
          "2422:                 authenticateMessage['domain_name'].decode('utf-16le'),",
          "2423:                 authenticateMessage['user_name'].decode('utf-16le'),",
          "2424:                 authenticateMessage['host_name'].decode('utf-16le')))",
          "",
          "[Added Lines]",
          "2462:                     authenticateMessage['domain_name'].decode('utf-16le'),",
          "2463:                     authenticateMessage['user_name'].decode('utf-16le'),",
          "2464:                     authenticateMessage['host_name'].decode('utf-16le')))",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2432:                         uid, lmhash, nthash = smbServer.getCredentials()[identity]",
          "2434:                         errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),",
          "2437:                         if sessionKey is not None:",
          "2438:                             connData['SignatureEnabled'] = False",
          "",
          "[Removed Lines]",
          "2435:                                              authenticateMessage, connData['CHALLENGE_MESSAGE'], connData['NEGOTIATE_MESSAGE'])",
          "",
          "[Added Lines]",
          "2475:                                                               authenticateMessage, connData['CHALLENGE_MESSAGE'],",
          "2476:                                                               connData['NEGOTIATE_MESSAGE'])",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2450:                     # accept-completed",
          "2451:                     respToken['NegState'] = b'\\x00'",
          "2455:                     # Let's store it in the connection data",
          "2456:                     connData['AUTHENTICATE_MESSAGE'] = authenticateMessage",
          "2457:                     try:",
          "",
          "[Removed Lines]",
          "2453:                     smbServer.log('User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),",
          "2454:                                                                               authenticateMessage['user_name'].decode('utf-16le')))",
          "",
          "[Added Lines]",
          "2494:                     smbServer.log(",
          "2495:                         'User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),",
          "2496:                                                                     authenticateMessage['user_name'].decode(",
          "2497:                                                                         'utf-16le')))",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2462:                                                             authenticateMessage['lanman'], authenticateMessage['ntlm'])",
          "2463:                         smbServer.log(ntlm_hash_data['hash_string'])",
          "2464:                         if jtr_dump_path != '':",
          "2466:                     except:",
          "2467:                         smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)",
          "2468:                 else:",
          "",
          "[Removed Lines]",
          "2465:                             writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)",
          "",
          "[Added Lines]",
          "2508:                             writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],",
          "2509:                                                   jtr_dump_path)",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2473:                 raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)",
          "2475:             respParameters['SecurityBlobLength'] = len(respToken)",
          "2479:         else:",
          "2480:             # Process Standard Security",
          "2481:             respParameters = smb.SMBSessionSetupAndXResponse_Parameters()",
          "2483:             sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])",
          "2484:             sessionSetupData = smb.SMBSessionSetupAndX_Data()",
          "2485:             sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']",
          "",
          "[Removed Lines]",
          "2476:             respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
          "2477:             respData['SecurityBlob']       = respToken.getData()",
          "2482:             respData       = smb.SMBSessionSetupAndXResponse_Data()",
          "",
          "[Added Lines]",
          "2520:             respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']",
          "2521:             respData['SecurityBlob'] = respToken.getData()",
          "2526:             respData = smb.SMBSessionSetupAndXResponse_Data()",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2492:             connData['Uid'] = 10",
          "2493:             connData['Authenticated'] = True",
          "2494:             respParameters['Action'] = 0",
          "2496:             try:",
          "2497:                 jtr_dump_path = smbServer.getJTRdumpPath()",
          "2499:                 smbServer.log(ntlm_hash_data['hash_string'])",
          "2500:                 if jtr_dump_path != '':",
          "2501:                     writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)",
          "2502:             except:",
          "2503:                 smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)",
          "2506:         respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2507:         respSMBCommand['Parameters'] = respParameters",
          "2510:         # From now on, the client can ask for other commands",
          "2511:         connData['Authenticated'] = True",
          "2512:         # For now, just switching to nobody",
          "2515:         smbServer.setConnectionData(connId, connData)",
          "2517:         return [respSMBCommand], None, errorCode",
          "2519:     @staticmethod",
          "2522:         connData['Pid'] = recvPacket['Pid']",
          "2524:         SMBCommand = smb.SMBCommand(recvPacket['Data'][0])",
          "2525:         respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)",
          "2527:         resp = smb.NewSMBPacket()",
          "2528:         resp['Flags1'] = smb.SMB.FLAGS1_REPLY",
          "2529:         resp['Pid'] = connData['Pid']",
          "",
          "[Removed Lines]",
          "2495:             smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))",
          "2498:                 ntlm_hash_data = outputToJohnFormat( b'', b(sessionSetupData['Account']), b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'], sessionSetupData['UnicodePwd'] )",
          "2505:         respData['NativeOS']     = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2508:         respSMBCommand['Data']       = respData",
          "2513:         #os.setregid(65534,65534)",
          "2514:         #os.setreuid(65534,65534)",
          "2520:     def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket ):",
          "2521:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
          "",
          "[Added Lines]",
          "2539:             smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (",
          "2540:             sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))",
          "2543:                 ntlm_hash_data = outputToJohnFormat(b'', b(sessionSetupData['Account']),",
          "2544:                                                     b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'],",
          "2545:                                                     sessionSetupData['UnicodePwd'])",
          "2552:         respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())",
          "2555:         respSMBCommand['Data'] = respData",
          "2560:         # os.setregid(65534,65534)",
          "2561:         # os.setreuid(65534,65534)",
          "2567:     def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket):",
          "2568:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2533:         # TODO: We support more dialects, and parse them accordingly",
          "2534:         dialects = SMBCommand['Data'].split(b'\\x02')",
          "2589:         except Exception as e:",
          "2595:         smbServer.setConnectionData(connId, connData)",
          "2597:         resp.addCommand(respSMBCommand)",
          "2599:         return None, [resp], STATUS_SUCCESS",
          "2601:     @staticmethod",
          "2602:     def default(connId, smbServer, SMBCommand, recvPacket):",
          "2603:         # By default we return an SMB Packet with error not implemented",
          "2605:         packet = smb.NewSMBPacket()",
          "2608:         packet['Command'] = recvPacket['Command']",
          "2614:         errorCode = STATUS_NOT_IMPLEMENTED",
          "2618:         return None, [packet], errorCode",
          "2620: class SMB2Commands:",
          "2621:     @staticmethod",
          "2625:         respPacket = smb2.SMB2Packet()",
          "2628:         respPacket['CreditRequestResponse'] = 1",
          "2630:         respPacket['SessionID'] = 0",
          "2631:         if isSMB1 is False:",
          "2632:             respPacket['MessageID'] = recvPacket['MessageID']",
          "2633:         else:",
          "2634:             respPacket['MessageID'] = 0",
          "2638:         respSMBCommand = smb2.SMB2Negotiate_Response()",
          "",
          "[Removed Lines]",
          "2535:         try:",
          "2536:            index = dialects.index(b'NT LM 0.12\\x00') - 1",
          "2537:            # Let's fill the data for NTLM",
          "2538:            if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:",
          "2539:                     resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
          "2540:                     #resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS",
          "2541:                     _dialects_data = smb.SMBExtended_Security_Data()",
          "2542:                     _dialects_data['ServerGUID'] = b'A'*16",
          "2543:                     blob = SPNEGO_NegTokenInit()",
          "2544:                     blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]",
          "2545:                     _dialects_data['SecurityBlob'] = blob.getData()",
          "2547:                     _dialects_parameters = smb.SMBExtended_Security_Parameters()",
          "2548:                     _dialects_parameters['Capabilities']    = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE",
          "2549:                     _dialects_parameters['ChallengeLength'] = 0",
          "2551:            else:",
          "2552:                     resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
          "2553:                     _dialects_parameters = smb.SMBNTLMDialect_Parameters()",
          "2554:                     _dialects_data= smb.SMBNTLMDialect_Data()",
          "2555:                     _dialects_data['Payload'] = ''",
          "2556:                     if 'EncryptionKey' in connData:",
          "2557:                         _dialects_data['Challenge'] = connData['EncryptionKey']",
          "2558:                         _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())",
          "2559:                     else:",
          "2560:                         # TODO: Handle random challenges, now one that can be used with rainbow tables",
          "2561:                         _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'",
          "2562:                         _dialects_parameters['ChallengeLength'] = 8",
          "2563:                     _dialects_parameters['Capabilities']    = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS",
          "2565:            # Let's see if we need to support RPC_REMOTE_APIS",
          "2566:            config = smbServer.getServerConfig()",
          "2567:            if config.has_option('global','rpc_apis'):",
          "2568:                if config.getboolean('global', 'rpc_apis') is True:",
          "2569:                   _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS",
          "2571:            _dialects_parameters['DialectIndex']    = index",
          "2572:            #_dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED",
          "2573:            _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER",
          "2574:            _dialects_parameters['MaxMpxCount']     = 1",
          "2575:            _dialects_parameters['MaxNumberVcs']    = 1",
          "2576:            _dialects_parameters['MaxBufferSize']   = 64000",
          "2577:            _dialects_parameters['MaxRawSize']      = 65536",
          "2578:            _dialects_parameters['SessionKey']      = 0",
          "2579:            _dialects_parameters['LowDateTime']     = 0",
          "2580:            _dialects_parameters['HighDateTime']    = 0",
          "2581:            _dialects_parameters['ServerTimeZone']  = 0",
          "2584:            respSMBCommand['Data']           = _dialects_data",
          "2585:            respSMBCommand['Parameters']     = _dialects_parameters",
          "2586:            connData['_dialects_data']       = _dialects_data",
          "2587:            connData['_dialects_parameters'] = _dialects_parameters",
          "2590:            # No NTLM throw an error",
          "2591:            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)",
          "2592:            respSMBCommand['Data'] = struct.pack('<H',0xffff)",
          "2604:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)",
          "2606:         packet['Flags1']  = smb.SMB.FLAGS1_REPLY",
          "2607:         packet['Flags2']  = smb.SMB.FLAGS2_NT_STATUS",
          "2609:         packet['Pid']     = recvPacket['Pid']",
          "2610:         packet['Tid']     = recvPacket['Tid']",
          "2611:         packet['Mid']     = recvPacket['Mid']",
          "2612:         packet['Uid']     = recvPacket['Uid']",
          "2613:         packet['Data']    = b'\\x00\\x00\\x00'",
          "2615:         packet['ErrorCode']   = errorCode >> 16",
          "2616:         packet['ErrorClass']  = errorCode & 0xff",
          "2622:     def smb2Negotiate(connId, smbServer, recvPacket, isSMB1 = False):",
          "2623:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
          "2626:         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "2627:         respPacket['Status']    = STATUS_SUCCESS",
          "2629:         respPacket['Command']   = smb2.SMB2_NEGOTIATE",
          "2635:         respPacket['TreeID']    = 0",
          "",
          "[Added Lines]",
          "2582:         try:",
          "2583:             index = dialects.index(b'NT LM 0.12\\x00') - 1",
          "2584:             # Let's fill the data for NTLM",
          "2585:             if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:",
          "2586:                 resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
          "2587:                 # resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS",
          "2588:                 _dialects_data = smb.SMBExtended_Security_Data()",
          "2589:                 _dialects_data['ServerGUID'] = b'A' * 16",
          "2590:                 blob = SPNEGO_NegTokenInit()",
          "2591:                 blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]",
          "2592:                 _dialects_data['SecurityBlob'] = blob.getData()",
          "2594:                 _dialects_parameters = smb.SMBExtended_Security_Parameters()",
          "2595:                 _dialects_parameters[",
          "2596:                     'Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE",
          "2597:                 _dialects_parameters['ChallengeLength'] = 0",
          "2599:             else:",
          "2600:                 resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE",
          "2601:                 _dialects_parameters = smb.SMBNTLMDialect_Parameters()",
          "2602:                 _dialects_data = smb.SMBNTLMDialect_Data()",
          "2603:                 _dialects_data['Payload'] = ''",
          "2604:                 if 'EncryptionKey' in connData:",
          "2605:                     _dialects_data['Challenge'] = connData['EncryptionKey']",
          "2606:                     _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())",
          "2607:                 else:",
          "2608:                     # TODO: Handle random challenges, now one that can be used with rainbow tables",
          "2609:                     _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'",
          "2610:                     _dialects_parameters['ChallengeLength'] = 8",
          "2611:                 _dialects_parameters['Capabilities'] = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS",
          "2613:                 # Let's see if we need to support RPC_REMOTE_APIS",
          "2614:             config = smbServer.getServerConfig()",
          "2615:             if config.has_option('global', 'rpc_apis'):",
          "2616:                 if config.getboolean('global', 'rpc_apis') is True:",
          "2617:                     _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS",
          "2619:             _dialects_parameters['DialectIndex'] = index",
          "2620:             # _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED",
          "2621:             _dialects_parameters['SecurityMode'] = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER",
          "2622:             _dialects_parameters['MaxMpxCount'] = 1",
          "2623:             _dialects_parameters['MaxNumberVcs'] = 1",
          "2624:             _dialects_parameters['MaxBufferSize'] = 64000",
          "2625:             _dialects_parameters['MaxRawSize'] = 65536",
          "2626:             _dialects_parameters['SessionKey'] = 0",
          "2627:             _dialects_parameters['LowDateTime'] = 0",
          "2628:             _dialects_parameters['HighDateTime'] = 0",
          "2629:             _dialects_parameters['ServerTimeZone'] = 0",
          "2631:             respSMBCommand['Data'] = _dialects_data",
          "2632:             respSMBCommand['Parameters'] = _dialects_parameters",
          "2633:             connData['_dialects_data'] = _dialects_data",
          "2634:             connData['_dialects_parameters'] = _dialects_parameters",
          "2637:             # No NTLM throw an error",
          "2638:             smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)",
          "2639:             respSMBCommand['Data'] = struct.pack('<H', 0xffff)",
          "2650:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)",
          "2652:         packet['Flags1'] = smb.SMB.FLAGS1_REPLY",
          "2653:         packet['Flags2'] = smb.SMB.FLAGS2_NT_STATUS",
          "2655:         packet['Pid'] = recvPacket['Pid']",
          "2656:         packet['Tid'] = recvPacket['Tid']",
          "2657:         packet['Mid'] = recvPacket['Mid']",
          "2658:         packet['Uid'] = recvPacket['Uid']",
          "2659:         packet['Data'] = b'\\x00\\x00\\x00'",
          "2661:         packet['ErrorCode'] = errorCode >> 16",
          "2662:         packet['ErrorClass'] = errorCode & 0xff",
          "2669:     def smb2Negotiate(connId, smbServer, recvPacket, isSMB1=False):",
          "2670:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
          "2673:         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "2674:         respPacket['Status'] = STATUS_SUCCESS",
          "2676:         respPacket['Command'] = smb2.SMB2_NEGOTIATE",
          "2682:         respPacket['TreeID'] = 0",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2650:                 raise Exception('SMB2 not supported, fallbacking')",
          "2651:         else:",
          "2652:             respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002",
          "2654:         respSMBCommand['Capabilities'] = 0",
          "2655:         respSMBCommand['MaxTransactSize'] = 65536",
          "2656:         respSMBCommand['MaxReadSize'] = 65536",
          "",
          "[Removed Lines]",
          "2653:         respSMBCommand['ServerGuid'] = b'A'*16",
          "",
          "[Added Lines]",
          "2699:         respSMBCommand['ServerGuid'] = b'A' * 16",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2665:         respSMBCommand['Buffer'] = blob.getData()",
          "2666:         respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])",
          "2670:         smbServer.setConnectionData(connId, connData)",
          "",
          "[Removed Lines]",
          "2668:         respPacket['Data']      = respSMBCommand",
          "",
          "[Added Lines]",
          "2714:         respPacket['Data'] = respSMBCommand",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2674:     @staticmethod",
          "2675:     def smb2SessionSetup(connId, smbServer, recvPacket):",
          "2678:         respSMBCommand = smb2.SMB2SessionSetup_Response()",
          "",
          "[Removed Lines]",
          "2676:         connData = smbServer.getConnectionData(connId, checkStatus = False)",
          "",
          "[Added Lines]",
          "2722:         connData = smbServer.getConnectionData(connId, checkStatus=False)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2684:         securityBlob = sessionSetupData['Buffer']",
          "2686:         rawNTLM = False",
          "2714:         else:",
          "2720:         # authentication we are, we act on it",
          "2723:         if messageType == 0x01:",
          "2724:             # NEGOTIATE_MESSAGE",
          "",
          "[Removed Lines]",
          "2687:         if struct.unpack('B',securityBlob[0:1])[0] == ASN1_AID:",
          "2688:            # NEGOTIATE packet",
          "2689:            blob =  SPNEGO_NegTokenInit(securityBlob)",
          "2690:            token = blob['MechToken']",
          "2691:            if len(blob['MechTypes'][0]) > 0:",
          "2692:                # Is this GSSAPI NTLM or something else we don't support?",
          "2693:                mechType = blob['MechTypes'][0]",
          "2694:                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
          "2695:                    # Nope, do we know it?",
          "2696:                    if mechType in MechTypes:",
          "2697:                        mechStr = MechTypes[mechType]",
          "2698:                    else:",
          "2699:                        mechStr = hexlify(mechType)",
          "2700:                    smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
          "2701:                    # We don't know the token, we answer back again saying",
          "2702:                    # we just support NTLM.",
          "2703:                    # ToDo: Build this into a SPNEGO_NegTokenResp()",
          "2704:                    respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
          "2705:                    respSMBCommand['SecurityBufferOffset'] = 0x48",
          "2706:                    respSMBCommand['SecurityBufferLength'] = len(respToken)",
          "2707:                    respSMBCommand['Buffer'] = respToken",
          "2709:                    return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
          "2710:         elif struct.unpack('B',securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:",
          "2711:            # AUTH packet",
          "2712:            blob = SPNEGO_NegTokenResp(securityBlob)",
          "2713:            token = blob['ResponseToken']",
          "2715:            # No GSSAPI stuff, raw NTLMSSP",
          "2716:            rawNTLM = True",
          "2717:            token = securityBlob",
          "2719:         # Here we only handle NTLMSSP, depending on what stage of the",
          "2721:         messageType = struct.unpack('<L',token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00')+4])[0]",
          "",
          "[Added Lines]",
          "2733:         if struct.unpack('B', securityBlob[0:1])[0] == ASN1_AID:",
          "2734:             # NEGOTIATE packet",
          "2735:             blob = SPNEGO_NegTokenInit(securityBlob)",
          "2736:             token = blob['MechToken']",
          "2737:             if len(blob['MechTypes'][0]) > 0:",
          "2738:                 # Is this GSSAPI NTLM or something else we don't support?",
          "2739:                 mechType = blob['MechTypes'][0]",
          "2740:                 if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:",
          "2741:                     # Nope, do we know it?",
          "2742:                     if mechType in MechTypes:",
          "2743:                         mechStr = MechTypes[mechType]",
          "2744:                     else:",
          "2745:                         mechStr = hexlify(mechType)",
          "2746:                     smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)",
          "2747:                     # We don't know the token, we answer back again saying",
          "2748:                     # we just support NTLM.",
          "2749:                     # ToDo: Build this into a SPNEGO_NegTokenResp()",
          "2750:                     respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'",
          "2751:                     respSMBCommand['SecurityBufferOffset'] = 0x48",
          "2752:                     respSMBCommand['SecurityBufferLength'] = len(respToken)",
          "2753:                     respSMBCommand['Buffer'] = respToken",
          "2755:                     return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED",
          "2756:         elif struct.unpack('B', securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:",
          "2757:             # AUTH packet",
          "2758:             blob = SPNEGO_NegTokenResp(securityBlob)",
          "2759:             token = blob['ResponseToken']",
          "2761:             # No GSSAPI stuff, raw NTLMSSP",
          "2762:             rawNTLM = True",
          "2763:             token = securityBlob",
          "2765:         # Here we only handle NTLMSSP, depending on what stage of the",
          "2767:         messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2727:             # Let's store it in the connection data",
          "2728:             connData['NEGOTIATE_MESSAGE'] = negotiateMessage",
          "2729:             # Let's build the answer flags",
          "2732:             ansFlags = 0",
          "2734:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:",
          "2736:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:",
          "2738:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:",
          "2740:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:",
          "2742:             if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:",
          "2744:             if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:",
          "2747:             ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET",
          "2749:             # Generate the AV_PAIRS",
          "2750:             av_pairs = ntlm.AV_PAIRS()",
          "2751:             # TODO: Put the proper data from SMBSERVER config",
          "2756:             challengeMessage = ntlm.NTLMAuthChallenge()",
          "2764:             challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)",
          "2765:             challengeMessage['TargetInfoFields'] = av_pairs",
          "2770:             if rawNTLM is False:",
          "2771:                 respToken = SPNEGO_NegTokenResp()",
          "",
          "[Removed Lines]",
          "2730:             # TODO: Parse all the flags. With this we're leaving some clients out",
          "2735:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
          "2737:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
          "2739:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
          "2741:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
          "2743:                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
          "2745:                ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
          "2752:             av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
          "2753:             av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
          "2754:             av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )",
          "2757:             challengeMessage['flags']            = ansFlags",
          "2758:             challengeMessage['domain_len']       = len(smbServer.getServerDomain().encode('utf-16le'))",
          "2759:             challengeMessage['domain_max_len']   = challengeMessage['domain_len']",
          "2760:             challengeMessage['domain_offset']    = 40 + 16",
          "2761:             challengeMessage['challenge']        = smbServer.getSMBChallenge()",
          "2762:             challengeMessage['domain_name']      = smbServer.getServerDomain().encode('utf-16le')",
          "2763:             challengeMessage['TargetInfoFields_len']     = len(av_pairs)",
          "2766:             challengeMessage['TargetInfoFields_offset']  = 40 + 16 + len(challengeMessage['domain_name'])",
          "2767:             challengeMessage['Version']          = b'\\xff'*8",
          "2768:             challengeMessage['VersionLen']       = 8",
          "",
          "[Added Lines]",
          "2776:             # TODO: Parse all the flags. With this we're leaving some clients out",
          "2781:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56",
          "2783:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128",
          "2785:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH",
          "2787:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",
          "2789:                 ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE",
          "2791:                 ansFlags |= ntlm.NTLM_NEGOTIATE_OEM",
          "2798:             av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[",
          "2799:                 ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')",
          "2800:             av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[",
          "2801:                 ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')",
          "2802:             av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (",
          "2803:                         116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))",
          "2806:             challengeMessage['flags'] = ansFlags",
          "2807:             challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))",
          "2808:             challengeMessage['domain_max_len'] = challengeMessage['domain_len']",
          "2809:             challengeMessage['domain_offset'] = 40 + 16",
          "2810:             challengeMessage['challenge'] = smbServer.getSMBChallenge()",
          "2811:             challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')",
          "2812:             challengeMessage['TargetInfoFields_len'] = len(av_pairs)",
          "2815:             challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])",
          "2816:             challengeMessage['Version'] = b'\\xff' * 8",
          "2817:             challengeMessage['VersionLen'] = 8",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2780:             # Setting the packet to STATUS_MORE_PROCESSING",
          "2781:             errorCode = STATUS_MORE_PROCESSING_REQUIRED",
          "2783:             # in the connection's data",
          "2784:             # Picking a fixed value",
          "2785:             # TODO: Manage more UIDs for the same session",
          "2787:             # Let's store it in the connection data",
          "2788:             connData['CHALLENGE_MESSAGE'] = challengeMessage",
          "",
          "[Removed Lines]",
          "2782:             # Let's set up an UID for this connection and store it",
          "2786:             connData['Uid'] = random.randint(1,0xffffffff)",
          "",
          "[Added Lines]",
          "2831:             # Let's set up an UID for this connection and store it",
          "2835:             connData['Uid'] = random.randint(1, 0xffffffff)",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2795:             authenticateMessage = ntlm.NTLMAuthChallengeResponse()",
          "2796:             authenticateMessage.fromString(token)",
          "2797:             smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (",
          "2800:             # TODO: Check the credentials! Now granting permissions",
          "2801:             # Do we have credentials to check?",
          "2802:             if len(smbServer.getCredentials()) > 0:",
          "",
          "[Removed Lines]",
          "2798:             authenticateMessage['domain_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le'),",
          "2799:             authenticateMessage['host_name'].decode('utf-16le')))",
          "",
          "[Added Lines]",
          "2847:                 authenticateMessage['domain_name'].decode('utf-16le'),",
          "2848:                 authenticateMessage['user_name'].decode('utf-16le'),",
          "2849:                 authenticateMessage['host_name'].decode('utf-16le')))",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2829:                 # accept-completed",
          "2830:                 respToken['NegState'] = b'\\x00'",
          "2831:                 smbServer.log('User %s\\\\%s authenticated successfully' % (",
          "2833:                 # Let's store it in the connection data",
          "2834:                 connData['AUTHENTICATE_MESSAGE'] = authenticateMessage",
          "2835:                 try:",
          "",
          "[Removed Lines]",
          "2832:                 authenticateMessage['host_name'].decode('utf-16le'), authenticateMessage['user_name'].decode('utf-16le')))",
          "",
          "[Added Lines]",
          "2882:                     authenticateMessage['host_name'].decode('utf-16le'),",
          "2883:                     authenticateMessage['user_name'].decode('utf-16le')))",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2862:         # From now on, the client can ask for other commands",
          "2863:         connData['Authenticated'] = True",
          "2864:         # For now, just switching to nobody",
          "2867:         smbServer.setConnectionData(connId, connData)",
          "2869:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "2865:         #os.setregid(65534,65534)",
          "2866:         #os.setreuid(65534,65534)",
          "",
          "[Added Lines]",
          "2916:         # os.setregid(65534,65534)",
          "2917:         # os.setreuid(65534,65534)",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2873:         connData = smbServer.getConnectionData(connId)",
          "2875:         respPacket = smb2.SMB2Packet()",
          "2878:         respPacket['CreditRequestResponse'] = 1",
          "2880:         respPacket['SessionID'] = connData['Uid']",
          "2882:         respPacket['MessageID'] = recvPacket['MessageID']",
          "2887:         treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])",
          "",
          "[Removed Lines]",
          "2876:         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "2877:         respPacket['Status']    = STATUS_SUCCESS",
          "2879:         respPacket['Command']   = recvPacket['Command']",
          "2881:         respPacket['Reserved']  = recvPacket['Reserved']",
          "2883:         respPacket['TreeID']    = recvPacket['TreeID']",
          "2885:         respSMBCommand        = smb2.SMB2TreeConnect_Response()",
          "",
          "[Added Lines]",
          "2927:         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "2928:         respPacket['Status'] = STATUS_SUCCESS",
          "2930:         respPacket['Command'] = recvPacket['Command']",
          "2932:         respPacket['Reserved'] = recvPacket['Reserved']",
          "2934:         respPacket['TreeID'] = recvPacket['TreeID']",
          "2936:         respSMBCommand = smb2.SMB2TreeConnect_Response()",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2902:         if share is not None:",
          "2903:             # Simple way to generate a Tid",
          "2904:             if len(connData['ConnectedShares']) == 0:",
          "2906:             else:",
          "2908:             connData['ConnectedShares'][tid] = share",
          "2909:             connData['ConnectedShares'][tid]['shareName'] = path",
          "2912:         else:",
          "2913:             smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)",
          "2914:             errorCode = STATUS_OBJECT_PATH_NOT_FOUND",
          "",
          "[Removed Lines]",
          "2905:                tid = 1",
          "2907:                tid = list(connData['ConnectedShares'].keys())[-1] + 1",
          "2910:             respPacket['TreeID']    = tid",
          "2911:             smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))",
          "",
          "[Added Lines]",
          "2956:                 tid = 1",
          "2958:                 tid = list(connData['ConnectedShares'].keys())[-1] + 1",
          "2961:             respPacket['TreeID'] = tid",
          "2962:             smbServer.log(\"Connecting Share(%d:%s)\" % (tid, path))",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2938:     def smb2Create(connId, smbServer, recvPacket):",
          "2939:         connData = smbServer.getConnectionData(connId)",
          "2945:         respSMBCommand['Buffer'] = b'\\x00'",
          "2946:         # Get the Tid associated",
          "2947:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
          "2960:                 # strip leading '/'",
          "2961:                 fileName = fileName[1:]",
          "3016:                         errorCode = STATUS_FILE_IS_A_DIRECTORY",
          "3024:                             fid = VOID_FILE_DESCRIPTOR",
          "3026:                             if sys.platform == 'win32':",
          "3028:                             if str(pathName) in smbServer.getRegisteredNamedPipes():",
          "3029:                                 fid = PIPE_FILE_DESCRIPTOR",
          "3030:                                 sock = socket.socket()",
          "3031:                                 sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])",
          "3032:                             else:",
          "3033:                                 fid = os.open(pathName, mode)",
          "3039:         else:",
          "3040:             errorCode = STATUS_SMB_BAD_TID",
          "",
          "[Removed Lines]",
          "2941:         respSMBCommand        = smb2.SMB2Create_Response()",
          "2943:         ntCreateRequest       = smb2.SMB2Create(recvPacket['Data'])",
          "2948:              # If we have a rootFid, the path is relative to that fid",
          "2949:              errorCode = STATUS_SUCCESS",
          "2950:              if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:",
          "2951:                  path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
          "2952:              else:",
          "2953:                  path = 'NONE'",
          "2954:                  errorCode = STATUS_ACCESS_DENIED",
          "2956:              deleteOnClose = False",
          "2958:              fileName = os.path.normpath(ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\','/'))",
          "2959:              if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "2962:              pathName = os.path.join(path,fileName)",
          "2963:              createDisposition = ntCreateRequest['CreateDisposition']",
          "2964:              mode = 0",
          "2966:              if createDisposition == smb2.FILE_SUPERSEDE:",
          "2967:                  mode |= os.O_TRUNC | os.O_CREAT",
          "2968:              elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:",
          "2969:                  mode |= os.O_TRUNC | os.O_CREAT",
          "2970:              elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:",
          "2971:                  if os.path.exists(pathName) is True:",
          "2972:                      mode |= os.O_TRUNC",
          "2973:                  else:",
          "2974:                      errorCode = STATUS_NO_SUCH_FILE",
          "2975:              elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:",
          "2976:                  if os.path.exists(pathName) is True:",
          "2977:                      mode |= os.O_TRUNC",
          "2978:                  else:",
          "2979:                      mode |= os.O_TRUNC | os.O_CREAT",
          "2980:              elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:",
          "2981:                  if os.path.exists(pathName) is True:",
          "2982:                      errorCode = STATUS_OBJECT_NAME_COLLISION",
          "2983:                  else:",
          "2984:                      mode |= os.O_CREAT",
          "2985:              elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:",
          "2986:                  if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
          "2987:                      errorCode = STATUS_NO_SUCH_FILE",
          "2989:              if errorCode == STATUS_SUCCESS:",
          "2990:                  desiredAccess = ntCreateRequest['DesiredAccess']",
          "2991:                  if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
          "2992:                      mode |= os.O_RDONLY",
          "2993:                  if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):",
          "2994:                      if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
          "2995:                          mode |= os.O_RDWR #| os.O_APPEND",
          "2996:                      else:",
          "2997:                          mode |= os.O_WRONLY #| os.O_APPEND",
          "2998:                  if desiredAccess & smb2.GENERIC_ALL:",
          "2999:                      mode |= os.O_RDWR #| os.O_APPEND",
          "3001:                  createOptions =  ntCreateRequest['CreateOptions']",
          "3002:                  if mode & os.O_CREAT == os.O_CREAT:",
          "3003:                      if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:",
          "3004:                          try:",
          "3005:                              # Let's create the directory",
          "3006:                              os.mkdir(pathName)",
          "3007:                              mode = os.O_RDONLY",
          "3008:                          except Exception as e:",
          "3009:                              smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
          "3010:                              errorCode = STATUS_ACCESS_DENIED",
          "3011:                  if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:",
          "3012:                      # If the file being opened is a directory, the server MUST fail the request with",
          "3013:                      # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
          "3014:                      # response.",
          "3015:                      if os.path.isdir(pathName) is True:",
          "3018:                  if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:",
          "3019:                      deleteOnClose = True",
          "3021:                  if errorCode == STATUS_SUCCESS:",
          "3022:                      try:",
          "3023:                          if os.path.isdir(pathName) and sys.platform == 'win32':",
          "3025:                          else:",
          "3027:                                mode |= os.O_BINARY",
          "3034:                      except Exception as e:",
          "3035:                          smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName,mode,e),logging.ERROR)",
          "3036:                          #print e",
          "3037:                          fid = 0",
          "3038:                          errorCode = STATUS_ACCESS_DENIED",
          "",
          "[Added Lines]",
          "2992:         respSMBCommand = smb2.SMB2Create_Response()",
          "2994:         ntCreateRequest = smb2.SMB2Create(recvPacket['Data'])",
          "2999:             # If we have a rootFid, the path is relative to that fid",
          "3000:             errorCode = STATUS_SUCCESS",
          "3001:             if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:",
          "3002:                 path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
          "3003:             else:",
          "3004:                 path = 'NONE'",
          "3005:                 errorCode = STATUS_ACCESS_DENIED",
          "3007:             deleteOnClose = False",
          "3009:             fileName = os.path.normpath(",
          "3010:                 ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le').replace('\\\\', '/'))",
          "3011:             if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\\\'):",
          "3015:             if not isInFileJail(path, fileName):",
          "3016:                 LOG.error(\"Path not in current working directory\")",
          "3017:                 return [smb2.SMB2Error()], None, STATUS_ACCESS_DENIED",
          "3019:             pathName = os.path.join(path, fileName)",
          "3020:             createDisposition = ntCreateRequest['CreateDisposition']",
          "3021:             mode = 0",
          "3023:             if createDisposition == smb2.FILE_SUPERSEDE:",
          "3024:                 mode |= os.O_TRUNC | os.O_CREAT",
          "3025:             elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:",
          "3026:                 mode |= os.O_TRUNC | os.O_CREAT",
          "3027:             elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:",
          "3028:                 if os.path.exists(pathName) is True:",
          "3029:                     mode |= os.O_TRUNC",
          "3030:                 else:",
          "3031:                     errorCode = STATUS_NO_SUCH_FILE",
          "3032:             elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:",
          "3033:                 if os.path.exists(pathName) is True:",
          "3034:                     mode |= os.O_TRUNC",
          "3035:                 else:",
          "3036:                     mode |= os.O_TRUNC | os.O_CREAT",
          "3037:             elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:",
          "3038:                 if os.path.exists(pathName) is True:",
          "3039:                     errorCode = STATUS_OBJECT_NAME_COLLISION",
          "3040:                 else:",
          "3041:                     mode |= os.O_CREAT",
          "3042:             elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:",
          "3043:                 if os.path.exists(pathName) is not True and (",
          "3044:                         str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:",
          "3045:                     errorCode = STATUS_NO_SUCH_FILE",
          "3047:             if errorCode == STATUS_SUCCESS:",
          "3048:                 desiredAccess = ntCreateRequest['DesiredAccess']",
          "3049:                 if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
          "3050:                     mode |= os.O_RDONLY",
          "3051:                 if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):",
          "3052:                     if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):",
          "3053:                         mode |= os.O_RDWR  # | os.O_APPEND",
          "3054:                     else:",
          "3055:                         mode |= os.O_WRONLY  # | os.O_APPEND",
          "3056:                 if desiredAccess & smb2.GENERIC_ALL:",
          "3057:                     mode |= os.O_RDWR  # | os.O_APPEND",
          "3059:                 createOptions = ntCreateRequest['CreateOptions']",
          "3060:                 if mode & os.O_CREAT == os.O_CREAT:",
          "3061:                     if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:",
          "3062:                         try:",
          "3063:                             # Let's create the directory",
          "3064:                             os.mkdir(pathName)",
          "3065:                             mode = os.O_RDONLY",
          "3066:                         except Exception as e:",
          "3067:                             smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
          "3068:                             errorCode = STATUS_ACCESS_DENIED",
          "3069:                 if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:",
          "3070:                     # If the file being opened is a directory, the server MUST fail the request with",
          "3071:                     # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server",
          "3072:                     # response.",
          "3073:                     if os.path.isdir(pathName) is True:",
          "3076:                 if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:",
          "3077:                     deleteOnClose = True",
          "3079:                 if errorCode == STATUS_SUCCESS:",
          "3080:                     try:",
          "3081:                         if os.path.isdir(pathName) and sys.platform == 'win32':",
          "3083:                         else:",
          "3085:                                 mode |= os.O_BINARY",
          "3092:                     except Exception as e:",
          "3093:                         smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)",
          "3094:                         # print e",
          "3095:                         fid = 0",
          "3096:                         errorCode = STATUS_ACCESS_DENIED",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "3047:             respSMBCommand['CreateAction'] = createDisposition",
          "3049:             if fid == PIPE_FILE_DESCRIPTOR:",
          "3051:                 respSMBCommand['LastAccessTime'] = 0",
          "3054:                 respSMBCommand['AllocationSize'] = 4096",
          "3056:                 respSMBCommand['FileAttributes'] = 0x80",
          "3058:             else:",
          "",
          "[Removed Lines]",
          "3050:                 respSMBCommand['CreationTime']   = 0",
          "3052:                 respSMBCommand['LastWriteTime']  = 0",
          "3053:                 respSMBCommand['ChangeTime']     = 0",
          "3055:                 respSMBCommand['EndOfFile']      = 0",
          "",
          "[Added Lines]",
          "3108:                 respSMBCommand['CreationTime'] = 0",
          "3110:                 respSMBCommand['LastWriteTime'] = 0",
          "3111:                 respSMBCommand['ChangeTime'] = 0",
          "3113:                 respSMBCommand['EndOfFile'] = 0",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "3061:                 else:",
          "3062:                     respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']",
          "3063:                 # Let's get this file's information",
          "3065:                 if errorCode == STATUS_SUCCESS:",
          "3067:                     respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']",
          "3069:                     respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']",
          "3070:                     respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']",
          "3071:                     respSMBCommand['AllocationSize'] = respInfo['AllocationSize']",
          "3074:             if errorCode == STATUS_SUCCESS:",
          "3075:                 # Let's store the fid for the connection",
          "",
          "[Removed Lines]",
          "3064:                 respInfo, errorCode = queryPathInformation('',pathName,level= smb.SMB_QUERY_FILE_ALL_INFO)",
          "3066:                     respSMBCommand['CreationTime']   = respInfo['CreationTime']",
          "3068:                     respSMBCommand['LastWriteTime']  = respInfo['LastWriteTime']",
          "3072:                     respSMBCommand['EndOfFile']      = respInfo['EndOfFile']",
          "",
          "[Added Lines]",
          "3122:                 respInfo, errorCode = queryPathInformation('', pathName, level=smb.SMB_QUERY_FILE_ALL_INFO)",
          "3124:                     respSMBCommand['CreationTime'] = respInfo['CreationTime']",
          "3126:                     respSMBCommand['LastWriteTime'] = respInfo['LastWriteTime']",
          "3130:                     respSMBCommand['EndOfFile'] = respInfo['EndOfFile']",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "3077:                 connData['OpenedFiles'][fakefid] = {}",
          "3078:                 connData['OpenedFiles'][fakefid]['FileHandle'] = fid",
          "3079:                 connData['OpenedFiles'][fakefid]['FileName'] = pathName",
          "3082:                 connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0",
          "3083:                 connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''",
          "3084:                 if fid == PIPE_FILE_DESCRIPTOR:",
          "3085:                     connData['OpenedFiles'][fakefid]['Socket'] = sock",
          "3086:         else:",
          "3087:             respSMBCommand = smb2.SMB2Error()",
          "3089:         if errorCode == STATUS_SUCCESS:",
          "3090:             connData['LastRequest']['SMB2_CREATE'] = respSMBCommand",
          "3091:         smbServer.setConnectionData(connId, connData)",
          "",
          "[Removed Lines]",
          "3080:                 connData['OpenedFiles'][fakefid]['DeleteOnClose']  = deleteOnClose",
          "3081:                 connData['OpenedFiles'][fakefid]['Open']  = {}",
          "",
          "[Added Lines]",
          "3138:                 connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose",
          "3139:                 connData['OpenedFiles'][fakefid]['Open'] = {}",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "3096:     def smb2Close(connId, smbServer, recvPacket):",
          "3097:         connData = smbServer.getConnectionData(connId)",
          "3101:         closeRequest = smb2.SMB2Close(recvPacket['Data'])",
          "3104:             # Let's take the data from the lastRequest",
          "3106:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3107:             else:",
          "3108:                 fileID = closeRequest['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3099:         respSMBCommand        = smb2.SMB2Close_Response()",
          "3103:         if closeRequest['FileID'].getData() == b'\\xff'*16:",
          "3105:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3157:         respSMBCommand = smb2.SMB2Close_Response()",
          "3161:         if closeRequest['FileID'].getData() == b'\\xff' * 16:",
          "3163:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "3110:             fileID = closeRequest['FileID'].getData()",
          "3112:         if fileID in connData['OpenedFiles']:",
          "3149:         else:",
          "3150:             errorCode = STATUS_INVALID_HANDLE",
          "",
          "[Removed Lines]",
          "3113:              errorCode = STATUS_SUCCESS",
          "3114:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3115:              pathName = connData['OpenedFiles'][fileID]['FileName']",
          "3116:              infoRecord = None",
          "3117:              try:",
          "3118:                  if fileHandle == PIPE_FILE_DESCRIPTOR:",
          "3119:                      connData['OpenedFiles'][fileID]['Socket'].close()",
          "3120:                  elif fileHandle != VOID_FILE_DESCRIPTOR:",
          "3121:                      os.close(fileHandle)",
          "3122:                      infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName), smb2.SMB2_FILE_NETWORK_OPEN_INFO)",
          "3123:              except Exception as e:",
          "3124:                  smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
          "3125:                  errorCode = STATUS_INVALID_HANDLE",
          "3126:              else:",
          "3127:                  # Check if the file was marked for removal",
          "3128:                  if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:",
          "3129:                      try:",
          "3130:                          if os.path.isdir(pathName):",
          "3131:                              shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])",
          "3132:                          else:",
          "3133:                              os.remove(connData['OpenedFiles'][fileID]['FileName'])",
          "3134:                      except Exception as e:",
          "3135:                          smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
          "3136:                          errorCode = STATUS_ACCESS_DENIED",
          "3138:                  # Now fill out the response",
          "3139:                  if infoRecord is not None:",
          "3140:                      respSMBCommand['CreationTime']   = infoRecord['CreationTime']",
          "3141:                      respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']",
          "3142:                      respSMBCommand['LastWriteTime']  = infoRecord['LastWriteTime']",
          "3143:                      respSMBCommand['ChangeTime']     = infoRecord['ChangeTime']",
          "3144:                      respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']",
          "3145:                      respSMBCommand['EndofFile']      = infoRecord['EndOfFile']",
          "3146:                      respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']",
          "3147:                  if errorCode == STATUS_SUCCESS:",
          "3148:                      del(connData['OpenedFiles'][fileID])",
          "",
          "[Added Lines]",
          "3171:             errorCode = STATUS_SUCCESS",
          "3172:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3173:             pathName = connData['OpenedFiles'][fileID]['FileName']",
          "3174:             infoRecord = None",
          "3175:             try:",
          "3176:                 if fileHandle == PIPE_FILE_DESCRIPTOR:",
          "3177:                     connData['OpenedFiles'][fileID]['Socket'].close()",
          "3178:                 elif fileHandle != VOID_FILE_DESCRIPTOR:",
          "3179:                     os.close(fileHandle)",
          "3180:                     infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),",
          "3181:                                                                  smb2.SMB2_FILE_NETWORK_OPEN_INFO)",
          "3182:             except Exception as e:",
          "3183:                 smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
          "3184:                 errorCode = STATUS_INVALID_HANDLE",
          "3185:             else:",
          "3186:                 # Check if the file was marked for removal",
          "3187:                 if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:",
          "3188:                     try:",
          "3189:                         if os.path.isdir(pathName):",
          "3190:                             shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])",
          "3191:                         else:",
          "3192:                             os.remove(connData['OpenedFiles'][fileID]['FileName'])",
          "3193:                     except Exception as e:",
          "3194:                         smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)",
          "3195:                         errorCode = STATUS_ACCESS_DENIED",
          "3197:                 # Now fill out the response",
          "3198:                 if infoRecord is not None:",
          "3199:                     respSMBCommand['CreationTime'] = infoRecord['CreationTime']",
          "3200:                     respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']",
          "3201:                     respSMBCommand['LastWriteTime'] = infoRecord['LastWriteTime']",
          "3202:                     respSMBCommand['ChangeTime'] = infoRecord['ChangeTime']",
          "3203:                     respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']",
          "3204:                     respSMBCommand['EndofFile'] = infoRecord['EndOfFile']",
          "3205:                     respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']",
          "3206:                 if errorCode == STATUS_SUCCESS:",
          "3207:                     del (connData['OpenedFiles'][fileID])",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "3156:     def smb2QueryInfo(connId, smbServer, recvPacket):",
          "3157:         connData = smbServer.getConnectionData(connId)",
          "3161:         queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])",
          "3165:         respSMBCommand['OutputBufferOffset'] = 0x48",
          "3166:         respSMBCommand['Buffer'] = b'\\x00'",
          "3169:             # Let's take the data from the lastRequest",
          "3171:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3172:             else:",
          "3173:                 fileID = queryInfo['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3159:         respSMBCommand        = smb2.SMB2QueryInfo_Response()",
          "3163:         errorCode = STATUS_SUCCESS",
          "3168:         if queryInfo['FileID'].getData() == b'\\xff'*16:",
          "3170:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3218:         respSMBCommand = smb2.SMB2QueryInfo_Response()",
          "3222:         errorCode = STATUS_SUCCESS",
          "3227:         if queryInfo['FileID'].getData() == b'\\xff' * 16:",
          "3229:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "3189:                                                                      queryInfo['FileInfoClass'])",
          "3190:                 elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
          "3191:                     if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:",
          "3193:                     else:",
          "3195:                 elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
          "3196:                     # Failing for now, until we support it",
          "3197:                     infoRecord = None",
          "3198:                     errorCode = STATUS_ACCESS_DENIED",
          "3199:                 else:",
          "3202:                 if infoRecord is not None:",
          "3203:                     respSMBCommand['OutputBufferLength'] = len(infoRecord)",
          "",
          "[Removed Lines]",
          "3192:                         infoRecord = b'\\x00'*4",
          "3194:                         infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName), queryInfo['FileInfoClass'])",
          "3200:                     smbServer.log(\"queryInfo not supported (%x)\" %  queryInfo['InfoType'], logging.ERROR)",
          "",
          "[Added Lines]",
          "3251:                         infoRecord = b'\\x00' * 4",
          "3253:                         infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName),",
          "3254:                                                         queryInfo['FileInfoClass'])",
          "3260:                     smbServer.log(\"queryInfo not supported (%x)\" % queryInfo['InfoType'], logging.ERROR)",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "3215:     def smb2SetInfo(connId, smbServer, recvPacket):",
          "3216:         connData = smbServer.getConnectionData(connId)",
          "3220:         setInfo = smb2.SMB2SetInfo(recvPacket['Data'])",
          "3225:             # Let's take the data from the lastRequest",
          "3227:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3228:             else:",
          "3229:                 fileID = setInfo['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3218:         respSMBCommand        = smb2.SMB2SetInfo_Response()",
          "3222:         errorCode = STATUS_SUCCESS",
          "3224:         if setInfo['FileID'].getData() == b'\\xff'*16:",
          "3226:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3277:         respSMBCommand = smb2.SMB2SetInfo_Response()",
          "3281:         errorCode = STATUS_SUCCESS",
          "3283:         if setInfo['FileID'].getData() == b'\\xff' * 16:",
          "3285:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "3231:             fileID = setInfo['FileID'].getData()",
          "3233:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
          "3235:             if fileID in connData['OpenedFiles']:",
          "3236:                 pathName = connData['OpenedFiles'][fileID]['FileName']",
          "",
          "[Removed Lines]",
          "3234:             path     = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
          "",
          "[Added Lines]",
          "3293:             path = connData['ConnectedShares'][recvPacket['TreeID']]['path']",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "3241:                     if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:",
          "3242:                         infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])",
          "3243:                         if infoRecord['DeletePending'] > 0:",
          "3246:                     elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:",
          "3247:                         infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])",
          "3248:                         # Creation time won't be set,  the other ones we play with.",
          "",
          "[Removed Lines]",
          "3244:                            # Mark this file for removal after closed",
          "3245:                            connData['OpenedFiles'][fileID]['DeleteOnClose'] = True",
          "",
          "[Added Lines]",
          "3303:                             # Mark this file for removal after closed",
          "3304:                             connData['OpenedFiles'][fileID]['DeleteOnClose'] = True",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "3257:                         else:",
          "3258:                             mtime = getUnixTime(mtime)",
          "3259:                         if atime > 0 and mtime > 0:",
          "3261:                     elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:",
          "3262:                         fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3263:                         infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])",
          "3264:                         if infoRecord['EndOfFile'] > 0:",
          "3266:                             os.write(fileHandle, b'\\x00')",
          "3267:                     elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:",
          "3268:                         renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])",
          "3270:                         if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):",
          "3271:                             return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION",
          "3272:                         try:",
          "3275:                         except Exception as e:",
          "3278:                     else:",
          "3279:                         smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)",
          "3280:                         # UNSUPPORTED",
          "3283:                 #    # The underlying object store information is being set.",
          "3284:                 #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])",
          "3286:                 #    # The security information is being set.",
          "3287:                 #    # Failing for now, until we support it",
          "3288:                 #    infoRecord = None",
          "3289:                 #    errorCode = STATUS_ACCESS_DENIED",
          "3291:                 #    # The underlying object store quota information is being set.",
          "3292:                 #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])",
          "3293:                 else:",
          "3296:             else:",
          "3297:                 errorCode = STATUS_INVALID_HANDLE",
          "3298:         else:",
          "3299:             errorCode = STATUS_SMB_BAD_TID",
          "3302:         smbServer.setConnectionData(connId, connData)",
          "3303:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "3260:                             os.utime(pathName,(atime,mtime))",
          "3265:                             os.lseek(fileHandle, infoRecord['EndOfFile']-1, 0)",
          "3269:                         newPathName = os.path.join(path,renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/'))",
          "3273:                              os.rename(pathName,newPathName)",
          "3274:                              connData['OpenedFiles'][fileID]['FileName'] = newPathName",
          "3276:                              smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)",
          "3277:                              errorCode = STATUS_ACCESS_DENIED",
          "3281:                         errorCode =  STATUS_NOT_SUPPORTED",
          "3282:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
          "3285:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
          "3290:                 #elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:",
          "3294:                     smbServer.log(\"setInfo not supported (%x)\" %  setInfo['InfoType'], logging.ERROR)",
          "",
          "[Added Lines]",
          "3319:                             os.utime(pathName, (atime, mtime))",
          "3324:                             os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)",
          "3328:                         newPathName = os.path.join(path, renameInfo['FileName'].decode('utf-16le').replace('\\\\', '/'))",
          "3332:                             os.rename(pathName, newPathName)",
          "3333:                             connData['OpenedFiles'][fileID]['FileName'] = newPathName",
          "3335:                             smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)",
          "3336:                             errorCode = STATUS_ACCESS_DENIED",
          "3340:                         errorCode = STATUS_NOT_SUPPORTED",
          "3341:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:",
          "3344:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:",
          "3349:                 # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:",
          "3353:                     smbServer.log(\"setInfo not supported (%x)\" % setInfo['InfoType'], logging.ERROR)",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "3307:         connData = smbServer.getConnectionData(connId)",
          "3309:         respSMBCommand = smb2.SMB2Write_Response()",
          "3312:         respSMBCommand['Buffer'] = b'\\x00'",
          "3315:             # Let's take the data from the lastRequest",
          "3317:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3318:             else:",
          "3319:                 fileID = writeRequest['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3310:         writeRequest   = smb2.SMB2Write(recvPacket['Data'])",
          "3314:         if writeRequest['FileID'].getData() == b'\\xff'*16:",
          "3316:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3368:         writeRequest = smb2.SMB2Write(recvPacket['Data'])",
          "3372:         if writeRequest['FileID'].getData() == b'\\xff' * 16:",
          "3374:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "3321:             fileID = writeRequest['FileID'].getData()",
          "3323:         if fileID in connData['OpenedFiles']:",
          "3342:         else:",
          "3343:             errorCode = STATUS_INVALID_HANDLE",
          "",
          "[Removed Lines]",
          "3324:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3325:              errorCode = STATUS_SUCCESS",
          "3326:              try:",
          "3327:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3328:                      offset = writeRequest['Offset']",
          "3329:                      # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "3330:                      if os.lseek(fileHandle, 0, 2) >= offset:",
          "3331:                          os.lseek(fileHandle,offset,0)",
          "3332:                          os.write(fileHandle,writeRequest['Buffer'])",
          "3333:                  else:",
          "3334:                      sock = connData['OpenedFiles'][fileID]['Socket']",
          "3335:                      sock.send(writeRequest['Buffer'])",
          "3337:                  respSMBCommand['Count']    = writeRequest['Length']",
          "3338:                  respSMBCommand['Remaining']= 0xff",
          "3339:              except Exception as e:",
          "3340:                  smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)",
          "3341:                  errorCode = STATUS_ACCESS_DENIED",
          "",
          "[Added Lines]",
          "3382:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3383:             errorCode = STATUS_SUCCESS",
          "3384:             try:",
          "3385:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3386:                     offset = writeRequest['Offset']",
          "3387:                     # If we're trying to write past the file end we just skip the write call (Vista does this)",
          "3388:                     if os.lseek(fileHandle, 0, 2) >= offset:",
          "3389:                         os.lseek(fileHandle, offset, 0)",
          "3390:                         os.write(fileHandle, writeRequest['Buffer'])",
          "3391:                 else:",
          "3392:                     sock = connData['OpenedFiles'][fileID]['Socket']",
          "3393:                     sock.send(writeRequest['Buffer'])",
          "3395:                 respSMBCommand['Count'] = writeRequest['Length']",
          "3396:                 respSMBCommand['Remaining'] = 0xff",
          "3397:             except Exception as e:",
          "3398:                 smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)",
          "3399:                 errorCode = STATUS_ACCESS_DENIED",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "3350:         connData = smbServer.getConnectionData(connId)",
          "3352:         respSMBCommand = smb2.SMB2Read_Response()",
          "3355:         respSMBCommand['Buffer'] = b'\\x00'",
          "3358:             # Let's take the data from the lastRequest",
          "3360:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3361:             else:",
          "3362:                 fileID = readRequest['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3353:         readRequest   = smb2.SMB2Read(recvPacket['Data'])",
          "3357:         if readRequest['FileID'].getData() == b'\\xff'*16:",
          "3359:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3411:         readRequest = smb2.SMB2Read(recvPacket['Data'])",
          "3415:         if readRequest['FileID'].getData() == b'\\xff' * 16:",
          "3417:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "3364:             fileID = readRequest['FileID'].getData()",
          "3366:         if fileID in connData['OpenedFiles']:",
          "3385:         else:",
          "3386:             errorCode = STATUS_INVALID_HANDLE",
          "",
          "[Removed Lines]",
          "3367:              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3368:              errorCode = 0",
          "3369:              try:",
          "3370:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3371:                      offset = readRequest['Offset']",
          "3372:                      os.lseek(fileHandle,offset,0)",
          "3373:                      content = os.read(fileHandle,readRequest['Length'])",
          "3374:                  else:",
          "3375:                      sock = connData['OpenedFiles'][fileID]['Socket']",
          "3376:                      content = sock.recv(readRequest['Length'])",
          "3378:                  respSMBCommand['DataOffset']   = 0x50",
          "3379:                  respSMBCommand['DataLength']   = len(content)",
          "3380:                  respSMBCommand['DataRemaining']= 0",
          "3381:                  respSMBCommand['Buffer']       = content",
          "3382:              except Exception as e:",
          "3383:                  smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)",
          "3384:                  errorCode = STATUS_ACCESS_DENIED",
          "",
          "[Added Lines]",
          "3425:             fileHandle = connData['OpenedFiles'][fileID]['FileHandle']",
          "3426:             errorCode = 0",
          "3427:             try:",
          "3428:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3429:                     offset = readRequest['Offset']",
          "3430:                     os.lseek(fileHandle, offset, 0)",
          "3431:                     content = os.read(fileHandle, readRequest['Length'])",
          "3432:                 else:",
          "3433:                     sock = connData['OpenedFiles'][fileID]['Socket']",
          "3434:                     content = sock.recv(readRequest['Length'])",
          "3436:                 respSMBCommand['DataOffset'] = 0x50",
          "3437:                 respSMBCommand['DataLength'] = len(content)",
          "3438:                 respSMBCommand['DataRemaining'] = 0",
          "3439:                 respSMBCommand['Buffer'] = content",
          "3440:             except Exception as e:",
          "3441:                 smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)",
          "3442:                 errorCode = STATUS_ACCESS_DENIED",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "3393:         connData = smbServer.getConnectionData(connId)",
          "3395:         respSMBCommand = smb2.SMB2Flush_Response()",
          "3398:         if flushRequest['FileID'].getData() in connData['OpenedFiles']:",
          "3406:         else:",
          "3407:             errorCode = STATUS_INVALID_HANDLE",
          "3409:         smbServer.setConnectionData(connId, connData)",
          "3410:         return [respSMBCommand], None, errorCode",
          "3413:     @staticmethod",
          "3414:     def smb2QueryDirectory(connId, smbServer, recvPacket):",
          "3415:         connData = smbServer.getConnectionData(connId)",
          "3416:         respSMBCommand = smb2.SMB2QueryDirectory_Response()",
          "3419:         respSMBCommand['Buffer'] = b'\\x00'",
          "3421:         # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.",
          "3422:         if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:",
          "3423:             return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED",
          "3426:         # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED",
          "3428:             # Let's take the data from the lastRequest",
          "3430:                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']",
          "3431:             else:",
          "3432:                 fileID = queryDirectoryRequest['FileID'].getData()",
          "",
          "[Removed Lines]",
          "3396:         flushRequest   = smb2.SMB2Flush(recvPacket['Data'])",
          "3399:              fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']",
          "3400:              errorCode = STATUS_SUCCESS",
          "3401:              try:",
          "3402:                  os.fsync(fileHandle)",
          "3403:              except Exception as e:",
          "3404:                  smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)",
          "3405:                  errorCode = STATUS_ACCESS_DENIED",
          "3417:         queryDirectoryRequest   = smb2.SMB2QueryDirectory(recvPacket['Data'])",
          "3425:         # Next, the server MUST locate the open for the directory to be queried",
          "3427:         if queryDirectoryRequest['FileID'].getData() == b'\\xff'*16:",
          "3429:             if  'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "[Added Lines]",
          "3454:         flushRequest = smb2.SMB2Flush(recvPacket['Data'])",
          "3457:             fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']",
          "3458:             errorCode = STATUS_SUCCESS",
          "3459:             try:",
          "3460:                 os.fsync(fileHandle)",
          "3461:             except Exception as e:",
          "3462:                 smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)",
          "3463:                 errorCode = STATUS_ACCESS_DENIED",
          "3474:         queryDirectoryRequest = smb2.SMB2QueryDirectory(recvPacket['Data'])",
          "3482:         # Next, the server MUST locate the open for the directory to be queried",
          "3484:         if queryDirectoryRequest['FileID'].getData() == b'\\xff' * 16:",
          "3486:             if 'SMB2_CREATE' in connData['LastRequest']:",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "3436:         if (fileID in connData['OpenedFiles']) is False:",
          "3437:             return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED",
          "3440:         # with STATUS_INVALID_PARAMETER.",
          "3441:         if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:",
          "3442:             return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER",
          "3447:         if queryDirectoryRequest['FileInformationClass'] not in (",
          "3450:             return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS",
          "3454:         # and Open.EnumerationSearchPattern to an empty string.",
          "3455:         if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:",
          "3456:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0",
          "3457:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''",
          "3461:         # Open.EnumerationLocation to 0.",
          "3462:         if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:",
          "3463:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0",
          "3469:         # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.",
          "3471:         pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')",
          "3474:             if pattern == '':",
          "3475:                 pattern = '*'",
          "3476:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern",
          "3480:         # specified in the request by FileNameOffset and FileNameLength.",
          "3481:         if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\",
          "3483:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern",
          "3486:         searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),",
          "3491:         if errorCode != STATUS_SUCCESS:",
          "3492:             return [smb2.SMB2Error()], None, errorCode",
          "",
          "[Removed Lines]",
          "3439:         # If the open is not an open to a directory, the request MUST be failed",
          "3444:         # If any other information class is specified in the FileInformationClass",
          "3445:         # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the",
          "3446:         # operation with STATUS_INVALID_INFO_CLASS.",
          "3448:         smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION, smb2.FILEID_FULL_DIRECTORY_INFORMATION,",
          "3449:         smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION, smb2.FILENAMES_INFORMATION):",
          "3452:         # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY",
          "3453:         # Request, the server SHOULD<326> set Open.EnumerationLocation to 0",
          "3459:         # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2",
          "3460:         # QUERY_DIRECTORY Request, the server MUST set",
          "3465:         # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern",
          "3466:         # is an empty string, then Open.EnumerationSearchPattern MUST be set",
          "3467:         # to the search pattern specified in the SMB2 QUERY_DIRECTORY by",
          "3468:         # FileNameOffset and FileNameLength. If FileNameLength is 0, the server",
          "3472:         if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\",
          "3473:             connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':",
          "3478:         # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,",
          "3479:         # the server MUST set Open.EnumerationSearchPattern to the search pattern",
          "3482:            queryDirectoryRequest['FileNameLength'] > 0:",
          "3485:         pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']),pattern)",
          "3487:                   os.path.basename(pathName),",
          "3488:                   queryDirectoryRequest['FileInformationClass'],",
          "3489:                   smb.ATTR_DIRECTORY, isSMB2 = True )",
          "",
          "[Added Lines]",
          "3496:         # If the open is not an open to a directory, the request MUST be failed",
          "3501:         # If any other information class is specified in the FileInformationClass",
          "3502:         # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the",
          "3503:         # operation with STATUS_INVALID_INFO_CLASS.",
          "3505:                 smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION,",
          "3506:                 smb2.FILEID_FULL_DIRECTORY_INFORMATION,",
          "3507:                 smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION,",
          "3508:                 smb2.FILENAMES_INFORMATION):",
          "3511:         # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY",
          "3512:         # Request, the server SHOULD<326> set Open.EnumerationLocation to 0",
          "3518:         # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2",
          "3519:         # QUERY_DIRECTORY Request, the server MUST set",
          "3524:         # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern",
          "3525:         # is an empty string, then Open.EnumerationSearchPattern MUST be set",
          "3526:         # to the search pattern specified in the SMB2 QUERY_DIRECTORY by",
          "3527:         # FileNameOffset and FileNameLength. If FileNameLength is 0, the server",
          "3531:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\",
          "3532:                 connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':",
          "3537:         # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,",
          "3538:         # the server MUST set Open.EnumerationSearchPattern to the search pattern",
          "3541:                 queryDirectoryRequest['FileNameLength'] > 0:",
          "3544:         pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']), pattern)",
          "3546:                                                           os.path.basename(pathName),",
          "3547:                                                           queryDirectoryRequest['FileInformationClass'],",
          "3548:                                                           smb.ATTR_DIRECTORY, isSMB2=True)",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "3499:         if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:",
          "3500:             return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE",
          "3503:             return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES",
          "3505:         totalData = 0",
          "",
          "[Removed Lines]",
          "3502:         if  connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:",
          "",
          "[Added Lines]",
          "3561:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "3511:                 searchResult[nItem]['NextEntryOffset'] = 0",
          "3512:             data = searchResult[nItem].getData()",
          "3513:             lenData = len(data)",
          "3517:                 connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1",
          "3518:                 break",
          "3519:             else:",
          "3521:                 totalData += lenData + padLen",
          "3523:             if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:",
          "3524:                 break",
          "3526:         if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:",
          "3529:         respSMBCommand['OutputBufferOffset'] = 0x48",
          "3530:         respSMBCommand['OutputBufferLength'] = totalData",
          "",
          "[Removed Lines]",
          "3514:             padLen = (8-(lenData % 8)) %8",
          "3516:             if (totalData+lenData) >= queryDirectoryRequest['OutputBufferLength']:",
          "3520:                 respData += data + b'\\x00'*padLen",
          "3527:              connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1",
          "",
          "[Added Lines]",
          "3573:             padLen = (8 - (lenData % 8)) % 8",
          "3575:             if (totalData + lenData) >= queryDirectoryRequest['OutputBufferLength']:",
          "3579:                 respData += data + b'\\x00' * padLen",
          "3586:             connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "3554:         if recvPacket['TreeID'] in connData['ConnectedShares']:",
          "3555:             smbServer.log(\"Disconnecting Share(%d:%s)\" % (",
          "3558:             errorCode = STATUS_SUCCESS",
          "3559:         else:",
          "3560:             # STATUS_SMB_BAD_TID",
          "3561:             errorCode = STATUS_SMB_BAD_TID",
          "3564:         smbServer.setConnectionData(connId, connData)",
          "3565:         return [respSMBCommand], None, errorCode",
          "",
          "[Removed Lines]",
          "3556:             recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))",
          "3557:             del(connData['ConnectedShares'][recvPacket['TreeID']])",
          "",
          "[Added Lines]",
          "3615:                 recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))",
          "3616:             del (connData['ConnectedShares'][recvPacket['TreeID']])",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "3587:         connData = smbServer.getConnectionData(connId)",
          "3589:         respSMBCommand = smb2.SMB2Ioctl_Response()",
          "3592:         ioctls = smbServer.getIoctls()",
          "3593:         if ioctlRequest['CtlCode'] in ioctls:",
          "3594:             outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)",
          "3595:             if errorCode == STATUS_SUCCESS:",
          "3600:                 respSMBCommand['OutputOffset'] = 0x70",
          "3604:             else:",
          "3605:                 respSMBCommand = outputData",
          "3606:         else:",
          "3608:             errorCode = STATUS_INVALID_DEVICE_REQUEST",
          "3609:             respSMBCommand = smb2.SMB2Error()",
          "",
          "[Removed Lines]",
          "3590:         ioctlRequest   = smb2.SMB2Ioctl(recvPacket['Data'])",
          "3596:                 respSMBCommand['CtlCode']      = ioctlRequest['CtlCode']",
          "3597:                 respSMBCommand['FileID']       = ioctlRequest['FileID']",
          "3598:                 respSMBCommand['InputOffset']  = 0",
          "3599:                 respSMBCommand['InputCount']   = 0",
          "3601:                 respSMBCommand['OutputCount']  = len(outputData)",
          "3602:                 respSMBCommand['Flags']        = 0",
          "3603:                 respSMBCommand['Buffer']       = outputData",
          "3607:             smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'],logging.DEBUG)",
          "",
          "[Added Lines]",
          "3648:         ioctlRequest = smb2.SMB2Ioctl(recvPacket['Data'])",
          "3654:                 respSMBCommand['CtlCode'] = ioctlRequest['CtlCode']",
          "3655:                 respSMBCommand['FileID'] = ioctlRequest['FileID']",
          "3656:                 respSMBCommand['InputOffset'] = 0",
          "3657:                 respSMBCommand['InputCount'] = 0",
          "3659:                 respSMBCommand['OutputCount'] = len(outputData)",
          "3660:                 respSMBCommand['Flags'] = 0",
          "3661:                 respSMBCommand['Buffer'] = outputData",
          "3665:             smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'], logging.DEBUG)",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "3631:     @staticmethod",
          "3632:     def default(connId, smbServer, recvPacket):",
          "3633:         # By default we return an SMB Packet with error not implemented",
          "3635:         return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED",
          "3637: class Ioctls:",
          "3640:         return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED",
          "3644:         connData = smbServer.getConnectionData(connId)",
          "3646:         ioctlResponse = ''",
          "3648:         if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:",
          "3661:         else:",
          "3662:             errorCode = STATUS_INVALID_DEVICE_REQUEST",
          "3664:         smbServer.setConnectionData(connId, connData)",
          "3665:         return ioctlResponse, errorCode",
          "3669:         connData = smbServer.getConnectionData(connId)",
          "3671:         errorCode = STATUS_SUCCESS",
          "3673:         validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])",
          "3674:         validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()",
          "3675:         validateNegotiateInfoResponse['Capabilities'] = 0",
          "3677:         validateNegotiateInfoResponse['SecurityMode'] = 1",
          "3678:         validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002",
          "",
          "[Removed Lines]",
          "3634:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'],logging.DEBUG)",
          "3638:    @staticmethod",
          "3639:    def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):",
          "3642:    @staticmethod",
          "3643:    def fsctlPipeTransceive(connId, smbServer, ioctlRequest):",
          "3649:              fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']",
          "3650:              errorCode = STATUS_SUCCESS",
          "3651:              try:",
          "3652:                  if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3653:                      errorCode = STATUS_INVALID_DEVICE_REQUEST",
          "3654:                  else:",
          "3655:                      sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']",
          "3656:                      sock.sendall(ioctlRequest['Buffer'])",
          "3657:                      ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])",
          "3658:              except Exception as e:",
          "3659:                  smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)",
          "3660:                  errorCode = STATUS_ACCESS_DENIED",
          "3667:    @staticmethod",
          "3668:    def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):",
          "3676:         validateNegotiateInfoResponse['Guid'] = b'A'*16",
          "",
          "[Added Lines]",
          "3692:         smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)",
          "3697:     @staticmethod",
          "3698:     def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):",
          "3701:     @staticmethod",
          "3702:     def fsctlPipeTransceive(connId, smbServer, ioctlRequest):",
          "3708:             fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']",
          "3709:             errorCode = STATUS_SUCCESS",
          "3710:             try:",
          "3711:                 if fileHandle != PIPE_FILE_DESCRIPTOR:",
          "3712:                     errorCode = STATUS_INVALID_DEVICE_REQUEST",
          "3713:                 else:",
          "3714:                     sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']",
          "3715:                     sock.sendall(ioctlRequest['Buffer'])",
          "3716:                     ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])",
          "3717:             except Exception as e:",
          "3718:                 smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)",
          "3719:                 errorCode = STATUS_ACCESS_DENIED",
          "3726:     @staticmethod",
          "3727:     def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):",
          "3735:         validateNegotiateInfoResponse['Guid'] = b'A' * 16",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "3684: class SMBSERVERHandler(socketserver.BaseRequestHandler):",
          "3686:         self.__SMB = server",
          "3687:         # In case of AF_INET6 the client_address contains 4 items, ignore the last 2",
          "3688:         self.__ip, self.__port = client_address[:2]",
          "3689:         self.__request = request",
          "3690:         self.__connId = threading.currentThread().getName()",
          "3692:         self.__select_poll = select_poll",
          "3694:         socketserver.BaseRequestHandler.__init__(self, request, client_address, server)",
          "3696:     def handle(self):",
          "",
          "[Removed Lines]",
          "3685:     def __init__(self, request, client_address, server, select_poll = False):",
          "3691:         self.__timeOut = 60*5",
          "3693:         #self.__connId = os.getpid()",
          "",
          "[Added Lines]",
          "3744:     def __init__(self, request, client_address, server, select_poll=False):",
          "3750:         self.__timeOut = 60 * 5",
          "3752:         # self.__connId = os.getpid()",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "3706:                 except nmb.NetBIOSTimeout:",
          "3707:                     raise",
          "3708:                 except nmb.NetBIOSError:",
          "3711:                 if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:",
          "3721:                 else:",
          "3730:             except Exception as e:",
          "3731:                 self.__SMB.log(\"Handle: %s\" % e)",
          "3734:                 break",
          "3736:     def finish(self):",
          "",
          "[Removed Lines]",
          "3709:                     break",
          "3712:                    # Someone is requesting a session, we're gonna accept them all :)",
          "3713:                    _, rn, my = p.get_trailer().split(b' ')",
          "3714:                    remote_name = nmb.decode_name(b'\\x20'+rn)",
          "3715:                    myname = nmb.decode_name(b'\\x20'+my)",
          "3716:                    self.__SMB.log(\"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))",
          "3717:                    r = nmb.NetBIOSSessionPacket()",
          "3718:                    r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)",
          "3719:                    r.set_trailer(p.get_trailer())",
          "3720:                    self.__request.send(r.rawData())",
          "3722:                    resp = self.__SMB.processRequest(self.__connId, p.get_trailer())",
          "3723:                    # Send all the packets received. Except for big transactions this should be",
          "3724:                    # a single packet",
          "3725:                    for i in resp:",
          "3726:                        if hasattr(i, 'getData'):",
          "3727:                            session.send_packet(i.getData())",
          "3728:                        else:",
          "3729:                            session.send_packet(i)",
          "3732:                 #import traceback",
          "3733:                 #traceback.print_exc()",
          "",
          "[Added Lines]",
          "3768:                     break",
          "3771:                     # Someone is requesting a session, we're gonna accept them all :)",
          "3772:                     _, rn, my = p.get_trailer().split(b' ')",
          "3773:                     remote_name = nmb.decode_name(b'\\x20' + rn)",
          "3774:                     myname = nmb.decode_name(b'\\x20' + my)",
          "3775:                     self.__SMB.log(",
          "3776:                         \"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))",
          "3777:                     r = nmb.NetBIOSSessionPacket()",
          "3778:                     r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)",
          "3779:                     r.set_trailer(p.get_trailer())",
          "3780:                     self.__request.send(r.rawData())",
          "3782:                     resp = self.__SMB.processRequest(self.__connId, p.get_trailer())",
          "3783:                     # Send all the packets received. Except for big transactions this should be",
          "3784:                     # a single packet",
          "3785:                     for i in resp:",
          "3786:                         if hasattr(i, 'getData'):",
          "3787:                             session.send_packet(i.getData())",
          "3788:                         else:",
          "3789:                             session.send_packet(i)",
          "3792:                 # import traceback",
          "3793:                 # traceback.print_exc()",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "3739:         self.__SMB.removeConnection(self.__connId)",
          "3740:         return socketserver.BaseRequestHandler.finish(self)",
          "3742: class SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):",
          "3745:         socketserver.TCPServer.allow_reuse_address = True",
          "3746:         socketserver.TCPServer.__init__(self, server_address, handler_class)",
          "3748:         # Server name and OS to be presented whenever is necessary",
          "3751:         self.__serverDomain = ''",
          "3755:         # Our ConfigParser data",
          "3756:         self.__serverConfig = config_parser",
          "",
          "[Removed Lines]",
          "3743: #class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):",
          "3744:     def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser = None):",
          "3749:         self.__serverName   = ''",
          "3750:         self.__serverOS     = ''",
          "3752:         self.__challenge    = ''",
          "3753:         self.__log          = None",
          "",
          "[Added Lines]",
          "3804:     # class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):",
          "3805:     def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser=None):",
          "3810:         self.__serverName = ''",
          "3811:         self.__serverOS = ''",
          "3813:         self.__challenge = ''",
          "3814:         self.__log = None",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3770:         # SMB2 Support flag = default not active",
          "3771:         self.__SMB2Support = False",
          "3773:         # Our list of commands we will answer, by default the NOT IMPLEMENTED one",
          "3774:         self.__smbCommandsHandler = SMBCommands()",
          "3778:         self.__smb2CommandsHandler = SMB2Commands()",
          "3781:         self.__smbNTTransCommands = {",
          "3784:         }",
          "3789:         }",
          "3790:         self.__smbTrans2Commands = {",
          "3798:         }",
          "3871:         # List of active connections",
          "3872:         self.__activeConnections = {}",
          "3874:     def getIoctls(self):",
          "3875:         return self.__smb2Ioctls",
          "",
          "[Removed Lines]",
          "3775:         self.__smbTrans2Handler   = TRANS2Commands()",
          "3776:         self.__smbTransHandler    = TRANSCommands()",
          "3777:         self.__smbNTTransHandler  = NTTRANSCommands()",
          "3779:         self.__IoctlHandler       = Ioctls()",
          "3782:         # NT IOCTL, can't find doc for this",
          "3783:         0xff                               :self.__smbNTTransHandler.default",
          "3786:         self.__smbTransCommands  = {",
          "3787: '\\\\PIPE\\\\LANMAN'                       :self.__smbTransHandler.lanMan,",
          "3788: smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTransHandler.transactNamedPipe,",
          "3791:  smb.SMB.TRANS2_FIND_FIRST2            :self.__smbTrans2Handler.findFirst2,",
          "3792:  smb.SMB.TRANS2_FIND_NEXT2             :self.__smbTrans2Handler.findNext2,",
          "3793:  smb.SMB.TRANS2_QUERY_FS_INFORMATION   :self.__smbTrans2Handler.queryFsInformation,",
          "3794:  smb.SMB.TRANS2_QUERY_PATH_INFORMATION :self.__smbTrans2Handler.queryPathInformation,",
          "3795:  smb.SMB.TRANS2_QUERY_FILE_INFORMATION :self.__smbTrans2Handler.queryFileInformation,",
          "3796:  smb.SMB.TRANS2_SET_FILE_INFORMATION   :self.__smbTrans2Handler.setFileInformation,",
          "3797:  smb.SMB.TRANS2_SET_PATH_INFORMATION   :self.__smbTrans2Handler.setPathInformation",
          "3800:         self.__smbCommands = {",
          "3801:  #smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush,",
          "3802:  smb.SMB.SMB_COM_CREATE_DIRECTORY:   self.__smbCommandsHandler.smbComCreateDirectory,",
          "3803:  smb.SMB.SMB_COM_DELETE_DIRECTORY:   self.__smbCommandsHandler.smbComDeleteDirectory,",
          "3804:  smb.SMB.SMB_COM_RENAME:             self.__smbCommandsHandler.smbComRename,",
          "3805:  smb.SMB.SMB_COM_DELETE:             self.__smbCommandsHandler.smbComDelete,",
          "3806:  smb.SMB.SMB_COM_NEGOTIATE:          self.__smbCommandsHandler.smbComNegotiate,",
          "3807:  smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,",
          "3808:  smb.SMB.SMB_COM_LOGOFF_ANDX:        self.__smbCommandsHandler.smbComLogOffAndX,",
          "3809:  smb.SMB.SMB_COM_TREE_CONNECT_ANDX:  self.__smbCommandsHandler.smbComTreeConnectAndX,",
          "3810:  smb.SMB.SMB_COM_TREE_DISCONNECT:    self.__smbCommandsHandler.smbComTreeDisconnect,",
          "3811:  smb.SMB.SMB_COM_ECHO:               self.__smbCommandsHandler.smbComEcho,",
          "3812:  smb.SMB.SMB_COM_QUERY_INFORMATION:  self.__smbCommandsHandler.smbQueryInformation,",
          "3813:  smb.SMB.SMB_COM_TRANSACTION2:       self.__smbCommandsHandler.smbTransaction2,",
          "3814:  smb.SMB.SMB_COM_TRANSACTION:        self.__smbCommandsHandler.smbTransaction,",
          "3815:  # Not needed for now",
          "3816:  smb.SMB.SMB_COM_NT_TRANSACT:        self.__smbCommandsHandler.smbNTTransact,",
          "3817:  smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,",
          "3818:  smb.SMB.SMB_COM_OPEN_ANDX:          self.__smbCommandsHandler.smbComOpenAndX,",
          "3819:  smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,",
          "3820:  smb.SMB.SMB_COM_READ_ANDX:          self.__smbCommandsHandler.smbComReadAndX,",
          "3821:  smb.SMB.SMB_COM_READ:               self.__smbCommandsHandler.smbComRead,",
          "3822:  smb.SMB.SMB_COM_WRITE_ANDX:         self.__smbCommandsHandler.smbComWriteAndX,",
          "3823:  smb.SMB.SMB_COM_WRITE:              self.__smbCommandsHandler.smbComWrite,",
          "3824:  smb.SMB.SMB_COM_CLOSE:              self.__smbCommandsHandler.smbComClose,",
          "3825:  smb.SMB.SMB_COM_LOCKING_ANDX:       self.__smbCommandsHandler.smbComLockingAndX,",
          "3826:  smb.SMB.SMB_COM_NT_CREATE_ANDX:     self.__smbCommandsHandler.smbComNtCreateAndX,",
          "3827:  0xFF:                               self.__smbCommandsHandler.default",
          "3828: }",
          "3830:         self.__smb2Ioctls = {",
          "3831:  smb2.FSCTL_DFS_GET_REFERRALS:            self.__IoctlHandler.fsctlDfsGetReferrals,",
          "3832: # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,",
          "3833: # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,",
          "3834:  smb2.FSCTL_PIPE_TRANSCEIVE:              self.__IoctlHandler.fsctlPipeTransceive,",
          "3835: # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,",
          "3836: # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,",
          "3837: # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,",
          "3838: # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,",
          "3839: # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,",
          "3840: # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,",
          "3841: # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,",
          "3842: # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,",
          "3843: # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,",
          "3844: # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,",
          "3845:  smb2.FSCTL_VALIDATE_NEGOTIATE_INFO:      self.__IoctlHandler.fsctlValidateNegotiateInfo,",
          "3846: }",
          "3848:         self.__smb2Commands = {",
          "3849:  smb2.SMB2_NEGOTIATE:       self.__smb2CommandsHandler.smb2Negotiate,",
          "3850:  smb2.SMB2_SESSION_SETUP:   self.__smb2CommandsHandler.smb2SessionSetup,",
          "3851:  smb2.SMB2_LOGOFF:          self.__smb2CommandsHandler.smb2Logoff,",
          "3852:  smb2.SMB2_TREE_CONNECT:    self.__smb2CommandsHandler.smb2TreeConnect,",
          "3853:  smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,",
          "3854:  smb2.SMB2_CREATE:          self.__smb2CommandsHandler.smb2Create,",
          "3855:  smb2.SMB2_CLOSE:           self.__smb2CommandsHandler.smb2Close,",
          "3856:  smb2.SMB2_FLUSH:           self.__smb2CommandsHandler.smb2Flush,",
          "3857:  smb2.SMB2_READ:            self.__smb2CommandsHandler.smb2Read,",
          "3858:  smb2.SMB2_WRITE:           self.__smb2CommandsHandler.smb2Write,",
          "3859:  smb2.SMB2_LOCK:            self.__smb2CommandsHandler.smb2Lock,",
          "3860:  smb2.SMB2_IOCTL:           self.__smb2CommandsHandler.smb2Ioctl,",
          "3861:  smb2.SMB2_CANCEL:          self.__smb2CommandsHandler.smb2Cancel,",
          "3862:  smb2.SMB2_ECHO:            self.__smb2CommandsHandler.smb2Echo,",
          "3863:  smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,",
          "3864:  smb2.SMB2_CHANGE_NOTIFY:   self.__smb2CommandsHandler.smb2ChangeNotify,",
          "3865:  smb2.SMB2_QUERY_INFO:      self.__smb2CommandsHandler.smb2QueryInfo,",
          "3866:  smb2.SMB2_SET_INFO:        self.__smb2CommandsHandler.smb2SetInfo,",
          "3867: # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,",
          "3868:  0xFF:                      self.__smb2CommandsHandler.default",
          "3869: }",
          "",
          "[Added Lines]",
          "3836:         self.__smbTrans2Handler = TRANS2Commands()",
          "3837:         self.__smbTransHandler = TRANSCommands()",
          "3838:         self.__smbNTTransHandler = NTTRANSCommands()",
          "3840:         self.__IoctlHandler = Ioctls()",
          "3843:             # NT IOCTL, can't find doc for this",
          "3844:             0xff: self.__smbNTTransHandler.default",
          "3847:         self.__smbTransCommands = {",
          "3848:             '\\\\PIPE\\\\LANMAN': self.__smbTransHandler.lanMan,",
          "3849:             smb.SMB.TRANS_TRANSACT_NMPIPE: self.__smbTransHandler.transactNamedPipe,",
          "3852:             smb.SMB.TRANS2_FIND_FIRST2: self.__smbTrans2Handler.findFirst2,",
          "3853:             smb.SMB.TRANS2_FIND_NEXT2: self.__smbTrans2Handler.findNext2,",
          "3854:             smb.SMB.TRANS2_QUERY_FS_INFORMATION: self.__smbTrans2Handler.queryFsInformation,",
          "3855:             smb.SMB.TRANS2_QUERY_PATH_INFORMATION: self.__smbTrans2Handler.queryPathInformation,",
          "3856:             smb.SMB.TRANS2_QUERY_FILE_INFORMATION: self.__smbTrans2Handler.queryFileInformation,",
          "3857:             smb.SMB.TRANS2_SET_FILE_INFORMATION: self.__smbTrans2Handler.setFileInformation,",
          "3858:             smb.SMB.TRANS2_SET_PATH_INFORMATION: self.__smbTrans2Handler.setPathInformation",
          "3861:         self.__smbCommands = {",
          "3862:             # smb.SMB.SMB_COM_FLUSH:              self.__smbCommandsHandler.smbComFlush,",
          "3863:             smb.SMB.SMB_COM_CREATE_DIRECTORY: self.__smbCommandsHandler.smbComCreateDirectory,",
          "3864:             smb.SMB.SMB_COM_DELETE_DIRECTORY: self.__smbCommandsHandler.smbComDeleteDirectory,",
          "3865:             smb.SMB.SMB_COM_RENAME: self.__smbCommandsHandler.smbComRename,",
          "3866:             smb.SMB.SMB_COM_DELETE: self.__smbCommandsHandler.smbComDelete,",
          "3867:             smb.SMB.SMB_COM_NEGOTIATE: self.__smbCommandsHandler.smbComNegotiate,",
          "3868:             smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,",
          "3869:             smb.SMB.SMB_COM_LOGOFF_ANDX: self.__smbCommandsHandler.smbComLogOffAndX,",
          "3870:             smb.SMB.SMB_COM_TREE_CONNECT_ANDX: self.__smbCommandsHandler.smbComTreeConnectAndX,",
          "3871:             smb.SMB.SMB_COM_TREE_DISCONNECT: self.__smbCommandsHandler.smbComTreeDisconnect,",
          "3872:             smb.SMB.SMB_COM_ECHO: self.__smbCommandsHandler.smbComEcho,",
          "3873:             smb.SMB.SMB_COM_QUERY_INFORMATION: self.__smbCommandsHandler.smbQueryInformation,",
          "3874:             smb.SMB.SMB_COM_TRANSACTION2: self.__smbCommandsHandler.smbTransaction2,",
          "3875:             smb.SMB.SMB_COM_TRANSACTION: self.__smbCommandsHandler.smbTransaction,",
          "3876:             # Not needed for now",
          "3877:             smb.SMB.SMB_COM_NT_TRANSACT: self.__smbCommandsHandler.smbNTTransact,",
          "3878:             smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,",
          "3879:             smb.SMB.SMB_COM_OPEN_ANDX: self.__smbCommandsHandler.smbComOpenAndX,",
          "3880:             smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,",
          "3881:             smb.SMB.SMB_COM_READ_ANDX: self.__smbCommandsHandler.smbComReadAndX,",
          "3882:             smb.SMB.SMB_COM_READ: self.__smbCommandsHandler.smbComRead,",
          "3883:             smb.SMB.SMB_COM_WRITE_ANDX: self.__smbCommandsHandler.smbComWriteAndX,",
          "3884:             smb.SMB.SMB_COM_WRITE: self.__smbCommandsHandler.smbComWrite,",
          "3885:             smb.SMB.SMB_COM_CLOSE: self.__smbCommandsHandler.smbComClose,",
          "3886:             smb.SMB.SMB_COM_LOCKING_ANDX: self.__smbCommandsHandler.smbComLockingAndX,",
          "3887:             smb.SMB.SMB_COM_NT_CREATE_ANDX: self.__smbCommandsHandler.smbComNtCreateAndX,",
          "3888:             0xFF: self.__smbCommandsHandler.default",
          "3889:         }",
          "3891:         self.__smb2Ioctls = {",
          "3892:             smb2.FSCTL_DFS_GET_REFERRALS: self.__IoctlHandler.fsctlDfsGetReferrals,",
          "3893:             # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,",
          "3894:             # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,",
          "3895:             smb2.FSCTL_PIPE_TRANSCEIVE: self.__IoctlHandler.fsctlPipeTransceive,",
          "3896:             # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,",
          "3897:             # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,",
          "3898:             # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,",
          "3899:             # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,",
          "3900:             # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,",
          "3901:             # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,",
          "3902:             # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,",
          "3903:             # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,",
          "3904:             # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,",
          "3905:             # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,",
          "3906:             smb2.FSCTL_VALIDATE_NEGOTIATE_INFO: self.__IoctlHandler.fsctlValidateNegotiateInfo,",
          "3907:         }",
          "3909:         self.__smb2Commands = {",
          "3910:             smb2.SMB2_NEGOTIATE: self.__smb2CommandsHandler.smb2Negotiate,",
          "3911:             smb2.SMB2_SESSION_SETUP: self.__smb2CommandsHandler.smb2SessionSetup,",
          "3912:             smb2.SMB2_LOGOFF: self.__smb2CommandsHandler.smb2Logoff,",
          "3913:             smb2.SMB2_TREE_CONNECT: self.__smb2CommandsHandler.smb2TreeConnect,",
          "3914:             smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,",
          "3915:             smb2.SMB2_CREATE: self.__smb2CommandsHandler.smb2Create,",
          "3916:             smb2.SMB2_CLOSE: self.__smb2CommandsHandler.smb2Close,",
          "3917:             smb2.SMB2_FLUSH: self.__smb2CommandsHandler.smb2Flush,",
          "3918:             smb2.SMB2_READ: self.__smb2CommandsHandler.smb2Read,",
          "3919:             smb2.SMB2_WRITE: self.__smb2CommandsHandler.smb2Write,",
          "3920:             smb2.SMB2_LOCK: self.__smb2CommandsHandler.smb2Lock,",
          "3921:             smb2.SMB2_IOCTL: self.__smb2CommandsHandler.smb2Ioctl,",
          "3922:             smb2.SMB2_CANCEL: self.__smb2CommandsHandler.smb2Cancel,",
          "3923:             smb2.SMB2_ECHO: self.__smb2CommandsHandler.smb2Echo,",
          "3924:             smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,",
          "3925:             smb2.SMB2_CHANGE_NOTIFY: self.__smb2CommandsHandler.smb2ChangeNotify,",
          "3926:             smb2.SMB2_QUERY_INFO: self.__smb2CommandsHandler.smb2QueryInfo,",
          "3927:             smb2.SMB2_SET_INFO: self.__smb2CommandsHandler.smb2SetInfo,",
          "3928:             # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,",
          "3929:             0xFF: self.__smb2CommandsHandler.default",
          "3930:         }",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3880:     def removeConnection(self, name):",
          "3881:         try:",
          "3883:         except:",
          "3885:         self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))",
          "3887:     def addConnection(self, name, ip, port):",
          "3888:         self.__activeConnections[name] = {}",
          "3889:         # Let's init with some know stuff we will need to have",
          "3890:         # TODO: Document what's in there",
          "3896:         self.__activeConnections[name]['ConnectedShares'] = {}",
          "3898:         # SID results for findfirst2",
          "3906:     def getActiveConnections(self):",
          "3907:         return self.__activeConnections",
          "3909:     def setConnectionData(self, connId, data):",
          "3910:         self.__activeConnections[connId] = data",
          "3915:         conn = self.__activeConnections[connId]",
          "3916:         if checkStatus is True:",
          "3917:             if ('Authenticated' in conn) is not True:",
          "",
          "[Removed Lines]",
          "3882:            del(self.__activeConnections[name])",
          "3884:            pass",
          "3891:         #print \"Current Connections\", self.__activeConnections.keys()",
          "3892:         self.__activeConnections[name]['PacketNum']       = 0",
          "3893:         self.__activeConnections[name]['ClientIP']        = ip",
          "3894:         self.__activeConnections[name]['ClientPort']      = port",
          "3895:         self.__activeConnections[name]['Uid']             = 0",
          "3897:         self.__activeConnections[name]['OpenedFiles']     = {}",
          "3899:         self.__activeConnections[name]['SIDs']            = {}",
          "3900:         self.__activeConnections[name]['LastRequest']     = {}",
          "3901:         self.__activeConnections[name]['SignatureEnabled']= False",
          "3902:         self.__activeConnections[name]['SigningChallengeResponse']= ''",
          "3903:         self.__activeConnections[name]['SigningSessionKey']= b''",
          "3904:         self.__activeConnections[name]['Authenticated']= False",
          "3911:         #print \"setConnectionData\"",
          "3912:         #print self.__activeConnections",
          "3914:     def getConnectionData(self, connId, checkStatus = True):",
          "",
          "[Added Lines]",
          "3943:             del (self.__activeConnections[name])",
          "3945:             pass",
          "3952:         # print \"Current Connections\", self.__activeConnections.keys()",
          "3953:         self.__activeConnections[name]['PacketNum'] = 0",
          "3954:         self.__activeConnections[name]['ClientIP'] = ip",
          "3955:         self.__activeConnections[name]['ClientPort'] = port",
          "3956:         self.__activeConnections[name]['Uid'] = 0",
          "3958:         self.__activeConnections[name]['OpenedFiles'] = {}",
          "3960:         self.__activeConnections[name]['SIDs'] = {}",
          "3961:         self.__activeConnections[name]['LastRequest'] = {}",
          "3962:         self.__activeConnections[name]['SignatureEnabled'] = False",
          "3963:         self.__activeConnections[name]['SigningChallengeResponse'] = ''",
          "3964:         self.__activeConnections[name]['SigningSessionKey'] = b''",
          "3965:         self.__activeConnections[name]['Authenticated'] = False",
          "3972:         # print \"setConnectionData\"",
          "3973:         # print self.__activeConnections",
          "3975:     def getConnectionData(self, connId, checkStatus=True):",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3929:     def unregisterNamedPipe(self, pipeName):",
          "3930:         if pipeName in self.__registeredNamedPipes:",
          "3932:             return True",
          "3933:         return False",
          "3935:     def unregisterTransaction(self, transCommand):",
          "3936:         if transCommand in self.__smbTransCommands:",
          "3939:     def hookTransaction(self, transCommand, callback):",
          "3941:         # the current Transaction sub command.",
          "3942:         # (don't get confused with the Transaction smbCommand)",
          "3943:         # If the transaction sub command doesn't not exist, it is added",
          "",
          "[Removed Lines]",
          "3931:             del(self.__registeredNamedPipes[str(pipeName)])",
          "3937:            del(self.__smbTransCommands[transCommand])",
          "3940:         # If you call this function, callback will replace",
          "",
          "[Added Lines]",
          "3992:             del (self.__registeredNamedPipes[str(pipeName)])",
          "3998:             del (self.__smbTransCommands[transCommand])",
          "4001:         # If you call this function, callback will replace",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3948:         #",
          "3949:         # WHERE:",
          "3950:         #",
          "3952:         #               the current connection",
          "3954:         #               configuration data",
          "3955:         # recvPacket  : the full SMBPacket that triggered this command",
          "3956:         # parameters  : the transaction parameters",
          "3957:         # data        : the transaction data",
          "3959:         #               with the client",
          "3960:         #",
          "3961:         # and MUST return:",
          "",
          "[Removed Lines]",
          "3951:         # connId      : the connection Id, used to grab/update information about",
          "3953:         # smbServer   : the SMBServer instance available for you to ask",
          "3958:         # maxDataCount: the max amount of data that can be transferred agreed",
          "",
          "[Added Lines]",
          "4012:         # connId      : the connection Id, used to grab/update information about",
          "4014:         # smbServer   : the SMBServer instance available for you to ask",
          "4019:         # maxDataCount: the max amount of data that can be transferred agreed",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3966:         # respSetup: the setup response of the transaction",
          "3967:         # respParameters: the parameters response of the transaction",
          "3968:         # respData: the data response of the transaction",
          "3971:         if transCommand in self.__smbTransCommands:",
          "3973:         else:",
          "3976:         self.__smbTransCommands[transCommand] = callback",
          "3977:         return originalCommand",
          "3979:     def unregisterTransaction2(self, transCommand):",
          "3980:         if transCommand in self.__smbTrans2Commands:",
          "3983:     def hookTransaction2(self, transCommand, callback):",
          "3984:         # Here we should add to __smbTrans2Commands",
          "3985:         # Same description as Transaction",
          "3986:         if transCommand in self.__smbTrans2Commands:",
          "3988:         else:",
          "3991:         self.__smbTrans2Commands[transCommand] = callback",
          "3992:         return originalCommand",
          "3994:     def unregisterNTTransaction(self, transCommand):",
          "3995:         if transCommand in self.__smbNTTransCommands:",
          "3998:     def hookNTTransaction(self, transCommand, callback):",
          "3999:         # Here we should add to __smbNTTransCommands",
          "4000:         # Same description as Transaction",
          "4001:         if transCommand in self.__smbNTTransCommands:",
          "4003:         else:",
          "4006:         self.__smbNTTransCommands[transCommand] = callback",
          "4007:         return originalCommand",
          "4009:     def unregisterSmbCommand(self, smbCommand):",
          "4010:         if smbCommand in self.__smbCommands:",
          "4013:     def hookSmbCommand(self, smbCommand, callback):",
          "4014:         # Here we should add to self.__smbCommands",
          "4016:         # the current smbCommand.",
          "4017:         # If smbCommand doesn't not exist, it is added",
          "4018:         # If SMB command exists, it returns the original function replaced",
          "",
          "[Removed Lines]",
          "3969:         # errorCode: the NT error code",
          "3972:            originalCommand = self.__smbTransCommands[transCommand]",
          "3974:            originalCommand = None",
          "3981:            del(self.__smbTrans2Commands[transCommand])",
          "3987:            originalCommand = self.__smbTrans2Commands[transCommand]",
          "3989:            originalCommand = None",
          "3996:            del(self.__smbNTTransCommands[transCommand])",
          "4002:            originalCommand = self.__smbNTTransCommands[transCommand]",
          "4004:            originalCommand = None",
          "4011:            del(self.__smbCommands[smbCommand])",
          "4015:         # If you call this function, callback will replace",
          "",
          "[Added Lines]",
          "4030:         # errorCode: the NT error code",
          "4033:             originalCommand = self.__smbTransCommands[transCommand]",
          "4035:             originalCommand = None",
          "4042:             del (self.__smbTrans2Commands[transCommand])",
          "4048:             originalCommand = self.__smbTrans2Commands[transCommand]",
          "4050:             originalCommand = None",
          "4057:             del (self.__smbNTTransCommands[transCommand])",
          "4063:             originalCommand = self.__smbNTTransCommands[transCommand]",
          "4065:             originalCommand = None",
          "4072:             del (self.__smbCommands[smbCommand])",
          "4076:         # If you call this function, callback will replace",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "4022:         #",
          "4023:         # WHERE:",
          "4024:         #",
          "4026:         #             the current connection",
          "4028:         #             configuration data",
          "4030:         #             Check smb.py:SMBCommand() for a reference",
          "4031:         # recvPacket: the full SMBPacket that triggered this command",
          "4032:         #",
          "4033:         # and MUST return:",
          "4034:         # <list of respSMBCommands>, <list of packets>, errorCode",
          "4038:         #",
          "4039:         # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT",
          "4040:         # the callback function is slightly different:",
          "",
          "[Removed Lines]",
          "4025:         # connId    : the connection Id, used to grab/update information about",
          "4027:         # smbServer : the SMBServer instance available for you to ask",
          "4029:         # SMBCommand: the SMBCommand itself, with its data and parameters.",
          "4035:         # <list of packets> has higher preference over commands, in case you",
          "4036:         # want to change the whole packet",
          "4037:         # errorCode: the NT error code",
          "",
          "[Added Lines]",
          "4086:         # connId    : the connection Id, used to grab/update information about",
          "4088:         # smbServer : the SMBServer instance available for you to ask",
          "4090:         # SMBCommand: the SMBCommand itself, with its data and parameters.",
          "4096:         # <list of packets> has higher preference over commands, in case you",
          "4097:         # want to change the whole packet",
          "4098:         # errorCode: the NT error code",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "4042:         # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)",
          "4043:         #",
          "4044:         # WHERE:",
          "4046:         # transCommands: a list of transaction subcommands already registered",
          "4047:         #",
          "4049:         if smbCommand in self.__smbCommands:",
          "4051:         else:",
          "4054:         self.__smbCommands[smbCommand] = callback",
          "4055:         return originalCommand",
          "4057:     def unregisterSmb2Command(self, smb2Command):",
          "4058:         if smb2Command in self.__smb2Commands:",
          "4061:     def hookSmb2Command(self, smb2Command, callback):",
          "4062:         if smb2Command in self.__smb2Commands:",
          "4064:         else:",
          "4067:         self.__smb2Commands[smb2Command] = callback",
          "4068:         return originalCommand",
          "4070:     def log(self, msg, level=logging.INFO):",
          "4073:     def getServerName(self):",
          "4074:         return self.__serverName",
          "4076:     def getServerOS(self):",
          "4077:         return self.__serverOS",
          "4079:     def getServerDomain(self):",
          "4080:         return self.__serverDomain",
          "4082:     def getSMBChallenge(self):",
          "4083:         return self.__challenge",
          "4085:     def getServerConfig(self):",
          "4086:         return self.__serverConfig",
          "",
          "[Removed Lines]",
          "4045:         #",
          "4050:            originalCommand = self.__smbCommands[smbCommand]",
          "4052:            originalCommand = None",
          "4059:            del(self.__smb2Commands[smb2Command])",
          "4063:            originalCommand = self.__smb2Commands[smb2Command]",
          "4065:            originalCommand = None",
          "4071:         self.__log.log(level,msg)",
          "",
          "[Added Lines]",
          "4106:         #",
          "4111:             originalCommand = self.__smbCommands[smbCommand]",
          "4113:             originalCommand = None",
          "4120:             del (self.__smb2Commands[smb2Command])",
          "4124:             originalCommand = self.__smb2Commands[smb2Command]",
          "4126:             originalCommand = None",
          "4132:         self.__log.log(level, msg)",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "4116:         # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,",
          "4117:         # after which the message can be transmitted.",
          "4121:         # Sign with the sequence",
          "4122:         m = hashlib.md5()",
          "4125:         if hasattr(packet, 'getData'):",
          "4127:         else:",
          "4129:         # Replace sequence with acual hash",
          "4130:         packet['SecurityFeatures'] = m.digest()[:8]",
          "4133:     def signSMBv2(self, packet, signingSessionKey):",
          "4135:         packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED",
          "4136:         signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()",
          "4137:         packet['Signature'] = signature[:16]",
          "4140:     def processRequest(self, connId, data):",
          "4142:         # TODO: Process batched commands.",
          "4145:         try:",
          "4148:         except:",
          "4149:             # Maybe a SMB2 packet?",
          "4151:             connData = self.getConnectionData(connId, False)",
          "4152:             self.signSMBv2(packet, connData['SigningSessionKey'])",
          "4153:             isSMB2 = True",
          "4157:         # We might have compound requests",
          "4158:         compoundedPacketsResponse = []",
          "4160:         try:",
          "4161:             # Search out list of implemented commands",
          "4162:             # We provide them with:",
          "",
          "[Removed Lines]",
          "4119:         #print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)",
          "4120:         packet['SecurityFeatures'] = struct.pack('<q',connData['SignSequenceNumber'])",
          "4123:         m.update( signingSessionKey )",
          "4124:         m.update( signingChallengeResponse )",
          "4126:             m.update( packet.getData() )",
          "4128:             m.update( packet )",
          "4131:         connData['SignSequenceNumber'] +=2",
          "4134:         packet['Signature'] = b'\\x00'*16",
          "4138:         #print \"%s\" % packet['Signature'].encode('hex')",
          "4143:         isSMB2      = False",
          "4144:         SMBCommand  = None",
          "4146:             packet = smb.NewSMBPacket(data = data)",
          "4147:             SMBCommand  = smb.SMBCommand(packet['Data'][0])",
          "4150:             packet = smb2.SMB2Packet(data = data)",
          "4155:         connData    = self.getConnectionData(connId, False)",
          "4159:         compoundedPackets         = []",
          "",
          "[Added Lines]",
          "4180:         # print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)",
          "4181:         packet['SecurityFeatures'] = struct.pack('<q', connData['SignSequenceNumber'])",
          "4184:         m.update(signingSessionKey)",
          "4185:         m.update(signingChallengeResponse)",
          "4187:             m.update(packet.getData())",
          "4189:             m.update(packet)",
          "4192:         connData['SignSequenceNumber'] += 2",
          "4195:         packet['Signature'] = b'\\x00' * 16",
          "4199:         # print \"%s\" % packet['Signature'].encode('hex')",
          "4204:         isSMB2 = False",
          "4205:         SMBCommand = None",
          "4207:             packet = smb.NewSMBPacket(data=data)",
          "4208:             SMBCommand = smb.SMBCommand(packet['Data'][0])",
          "4211:             packet = smb2.SMB2Packet(data=data)",
          "4216:         connData = self.getConnectionData(connId, False)",
          "4220:         compoundedPackets = []",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "4173:             # errorCode   : self explanatory",
          "4174:             if isSMB2 is False:",
          "4175:                 # Is the client authenticated already?",
          "4177:                     # Nope.. in that case he should only ask for a few commands, if not throw him out.",
          "4178:                     errorCode = STATUS_ACCESS_DENIED",
          "4179:                     respPackets = None",
          "",
          "[Removed Lines]",
          "4176:                 if connData['Authenticated'] is False and packet['Command'] not in (smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):",
          "",
          "[Added Lines]",
          "4237:                 if connData['Authenticated'] is False and packet['Command'] not in (",
          "4238:                 smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "4181:                 else:",
          "4182:                     if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:",
          "4183:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4189:                     elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:",
          "4190:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4196:                     elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:",
          "4197:                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4203:                     else:",
          "4204:                         if packet['Command'] in self.__smbCommands:",
          "4234:                         else:",
          "4237:                 compoundedPacketsResponse.append((respCommands, respPackets, errorCode))",
          "4238:                 compoundedPackets.append(packet)",
          "4240:             else:",
          "4241:                 # Is the client authenticated already?",
          "4243:                     # Nope.. in that case he should only ask for a few commands, if not throw him out.",
          "4244:                     errorCode = STATUS_ACCESS_DENIED",
          "4245:                     respPackets = None",
          "",
          "[Removed Lines]",
          "4184:                                       connId,",
          "4185:                                       self,",
          "4186:                                       SMBCommand,",
          "4187:                                       packet,",
          "4188:                                       self.__smbTrans2Commands)",
          "4191:                                       connId,",
          "4192:                                       self,",
          "4193:                                       SMBCommand,",
          "4194:                                       packet,",
          "4195:                                       self.__smbNTTransCommands)",
          "4198:                                       connId,",
          "4199:                                       self,",
          "4200:                                       SMBCommand,",
          "4201:                                       packet,",
          "4202:                                       self.__smbTransCommands)",
          "4205:                            if self.__SMB2Support is True:",
          "4206:                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:",
          "4207:                                    try:",
          "4208:                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](connId, self, packet, True)",
          "4209:                                        isSMB2 = True",
          "4210:                                    except Exception as e:",
          "4211:                                        import traceback",
          "4212:                                        traceback.print_exc()",
          "4213:                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)",
          "4214:                                        # If something went wrong, let's fallback to SMB1",
          "4215:                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4216:                                            connId,",
          "4217:                                            self,",
          "4218:                                            SMBCommand,",
          "4219:                                            packet)",
          "4220:                                        #self.__SMB2Support = False",
          "4221:                                        pass",
          "4222:                                else:",
          "4223:                                    respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4224:                                            connId,",
          "4225:                                            self,",
          "4226:                                            SMBCommand,",
          "4227:                                            packet)",
          "4228:                            else:",
          "4229:                                respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4230:                                            connId,",
          "4231:                                            self,",
          "4232:                                            SMBCommand,",
          "4233:                                            packet)",
          "4235:                            respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand, packet)",
          "4242:                 if connData['Authenticated'] is False and packet['Command'] not in (smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):",
          "",
          "[Added Lines]",
          "4246:                             connId,",
          "4247:                             self,",
          "4248:                             SMBCommand,",
          "4249:                             packet,",
          "4250:                             self.__smbTrans2Commands)",
          "4253:                             connId,",
          "4254:                             self,",
          "4255:                             SMBCommand,",
          "4256:                             packet,",
          "4257:                             self.__smbNTTransCommands)",
          "4260:                             connId,",
          "4261:                             self,",
          "4262:                             SMBCommand,",
          "4263:                             packet,",
          "4264:                             self.__smbTransCommands)",
          "4267:                             if self.__SMB2Support is True:",
          "4268:                                 if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:",
          "4269:                                     try:",
          "4270:                                         respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](",
          "4271:                                             connId, self, packet, True)",
          "4272:                                         isSMB2 = True",
          "4273:                                     except Exception as e:",
          "4274:                                         import traceback",
          "4275:                                         traceback.print_exc()",
          "4276:                                         self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)",
          "4277:                                         # If something went wrong, let's fallback to SMB1",
          "4278:                                         respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4279:                                             connId,",
          "4280:                                             self,",
          "4281:                                             SMBCommand,",
          "4282:                                             packet)",
          "4283:                                         # self.__SMB2Support = False",
          "4284:                                         pass",
          "4285:                                 else:",
          "4286:                                     respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4287:                                         connId,",
          "4288:                                         self,",
          "4289:                                         SMBCommand,",
          "4290:                                         packet)",
          "4291:                             else:",
          "4292:                                 respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](",
          "4293:                                     connId,",
          "4294:                                     self,",
          "4295:                                     SMBCommand,",
          "4296:                                     packet)",
          "4298:                             respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand,",
          "4299:                                                                                            packet)",
          "4306:                 if connData['Authenticated'] is False and packet['Command'] not in (",
          "4307:                 smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "4250:                     done = False",
          "4251:                     while not done:",
          "4252:                         if packet['Command'] in self.__smb2Commands:",
          "4260:                         else:",
          "4262:                         # Let's store the result for this compounded packet",
          "4263:                         compoundedPacketsResponse.append((respCommands, respPackets, errorCode))",
          "4264:                         compoundedPackets.append(packet)",
          "4265:                         if packet['NextCommand'] != 0:",
          "4266:                             data = data[packet['NextCommand']:]",
          "4268:                         else:",
          "4269:                             done = True",
          "4271:         except Exception as e:",
          "4274:             # Something wen't wrong, defaulting to Bad user ID",
          "4276:             raise",
          "4278:         # We prepare the response packet to commands don't need to bother about that.",
          "4281:         # Force reconnection loop.. This is just a test.. client will send me back credentials :)",
          "4284:         #    connData['PacketNum'] = 0",
          "4285:         #    # Something wen't wrong, defaulting to Bad user ID",
          "4286:         #    self.log('Sending BAD USER ID!', logging.ERROR)",
          "",
          "[Removed Lines]",
          "4253:                            if self.__SMB2Support is True:",
          "4254:                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](",
          "4255:                                        connId,",
          "4256:                                        self,",
          "4257:                                        packet)",
          "4258:                            else:",
          "4259:                                respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
          "4261:                            respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
          "4267:                             packet = smb2.SMB2Packet(data = data)",
          "4272:             #import traceback",
          "4273:             #traceback.print_exc()",
          "4275:             self.log('processRequest (0x%x,%s)' % (packet['Command'],e), logging.ERROR)",
          "4279:         connData    = self.getConnectionData(connId, False)",
          "4282:         #connData['PacketNum'] += 1",
          "4283:         #if connData['PacketNum'] == 15:",
          "",
          "[Added Lines]",
          "4318:                             if self.__SMB2Support is True:",
          "4319:                                 respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](",
          "4320:                                     connId,",
          "4321:                                     self,",
          "4322:                                     packet)",
          "4323:                             else:",
          "4324:                                 respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
          "4326:                             respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)",
          "4332:                             packet = smb2.SMB2Packet(data=data)",
          "4337:             # import traceback",
          "4338:             # traceback.print_exc()",
          "4340:             self.log('processRequest (0x%x,%s)' % (packet['Command'], e), logging.ERROR)",
          "4344:         connData = self.getConnectionData(connId, False)",
          "4347:         # connData['PacketNum'] += 1",
          "4348:         # if connData['PacketNum'] == 15:",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "4292:         #    packet['ErrorClass']  = errorCode & 0xff",
          "4293:         #    return [packet]",
          "4297:         packetsToSend = []",
          "4298:         for packetNum in range(len(compoundedPacketsResponse)):",
          "",
          "[Removed Lines]",
          "4295:         self.setConnectionData(connId, connData)",
          "",
          "[Added Lines]",
          "4360:         self.setConnectionData(connId, connData)",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "4301:             if respPackets is None:",
          "4302:                 for respCommand in respCommands:",
          "4303:                     if isSMB2 is False:",
          "4305:                         respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY",
          "4307:                         # TODO this should come from a per session configuration",
          "4322:                         respPacket.addCommand(respCommand)",
          "4324:                         if connData['SignatureEnabled']:",
          "4325:                             respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE",
          "4328:                         packetsToSend.append(respPacket)",
          "4329:                     else:",
          "4330:                         respPacket = smb2.SMB2Packet()",
          "4332:                         if packetNum > 0:",
          "4333:                             respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS",
          "4335:                         respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']",
          "4337:                         respPacket['CreditCharge'] = packet['CreditCharge']",
          "4340:                         respPacket['SessionID'] = connData['Uid']",
          "4341:                         respPacket['MessageID'] = packet['MessageID']",
          "4343:                         if hasattr(respCommand, 'getData'):",
          "4345:                         else:",
          "4348:                         if connData['SignatureEnabled']:",
          "4349:                             self.signSMBv2(respPacket, connData['SigningSessionKey'])",
          "",
          "[Removed Lines]",
          "4304:                         respPacket           = smb.NewSMBPacket()",
          "4308:                         respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | packet['Flags2'] & smb.SMB.FLAGS2_UNICODE",
          "4309:                         #respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES",
          "4310:                         #respPacket['Flags1'] = 0x98",
          "4311:                         #respPacket['Flags2'] = 0xc807",
          "4314:                         respPacket['Tid']    = packet['Tid']",
          "4315:                         respPacket['Mid']    = packet['Mid']",
          "4316:                         respPacket['Pid']    = packet['Pid']",
          "4317:                         respPacket['Uid']    = connData['Uid']",
          "4319:                         respPacket['ErrorCode']   = errorCode >> 16",
          "4320:                         respPacket['_reserved']   = errorCode >> 8 & 0xff",
          "4321:                         respPacket['ErrorClass']  = errorCode & 0xff",
          "4326:                             self.signSMBv1(connData, respPacket, connData['SigningSessionKey'], connData['SigningChallengeResponse'])",
          "4331:                         respPacket['Flags']     = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "4334:                         respPacket['Status']    = errorCode",
          "4336:                         respPacket['Command']   = packet['Command']",
          "4338:                         #respPacket['CreditCharge'] = 0",
          "4339:                         respPacket['Reserved']  = packet['Reserved']",
          "4342:                         respPacket['TreeID']    = packet['TreeID']",
          "4344:                             respPacket['Data']      = respCommand.getData()",
          "4346:                             respPacket['Data']      = str(respCommand)",
          "",
          "[Added Lines]",
          "4369:                         respPacket = smb.NewSMBPacket()",
          "4373:                         respPacket[",
          "4374:                             'Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\",
          "4375:                                         packet['Flags2'] & smb.SMB.FLAGS2_UNICODE",
          "4376:                         # respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES",
          "4377:                         # respPacket['Flags1'] = 0x98",
          "4378:                         # respPacket['Flags2'] = 0xc807",
          "4380:                         respPacket['Tid'] = packet['Tid']",
          "4381:                         respPacket['Mid'] = packet['Mid']",
          "4382:                         respPacket['Pid'] = packet['Pid']",
          "4383:                         respPacket['Uid'] = connData['Uid']",
          "4385:                         respPacket['ErrorCode'] = errorCode >> 16",
          "4386:                         respPacket['_reserved'] = errorCode >> 8 & 0xff",
          "4387:                         respPacket['ErrorClass'] = errorCode & 0xff",
          "4392:                             self.signSMBv1(connData, respPacket, connData['SigningSessionKey'],",
          "4393:                                            connData['SigningChallengeResponse'])",
          "4398:                         respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR",
          "4401:                         respPacket['Status'] = errorCode",
          "4403:                         respPacket['Command'] = packet['Command']",
          "4405:                         # respPacket['CreditCharge'] = 0",
          "4406:                         respPacket['Reserved'] = packet['Reserved']",
          "4409:                         respPacket['TreeID'] = packet['TreeID']",
          "4411:                             respPacket['Data'] = respCommand.getData()",
          "4413:                             respPacket['Data'] = str(respCommand)",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "4357:             # Let's build a compound answer",
          "4358:             finalData = b''",
          "4359:             i = 0",
          "4361:                 packet = packetsToSend[i]",
          "4362:                 # Align to 8-bytes",
          "4364:                 packet['NextCommand'] = len(packet) + padLen",
          "4365:                 if hasattr(packet, 'getData'):",
          "4367:                 else:",
          "4370:             # Last one",
          "4373:             else:",
          "4375:             packetsToSend = [finalData]",
          "4377:         # We clear the compound requests",
          "",
          "[Removed Lines]",
          "4360:             for i in range(len(packetsToSend)-1):",
          "4363:                 padLen = (8 - (len(packet) % 8) ) % 8",
          "4366:                     finalData += packet.getData() + padLen*b'\\x00'",
          "4368:                     finalData += packet + padLen*b'\\x00'",
          "4371:             if hasattr(packetsToSend[len(packetsToSend)-1], 'getData'):",
          "4372:                 finalData += packetsToSend[len(packetsToSend)-1].getData()",
          "4374:                 finalData += packetsToSend[len(packetsToSend)-1]",
          "",
          "[Added Lines]",
          "4427:             for i in range(len(packetsToSend) - 1):",
          "4430:                 padLen = (8 - (len(packet) % 8)) % 8",
          "4433:                     finalData += packet.getData() + padLen * b'\\x00'",
          "4435:                     finalData += packet + padLen * b'\\x00'",
          "4438:             if hasattr(packetsToSend[len(packetsToSend) - 1], 'getData'):",
          "4439:                 finalData += packetsToSend[len(packetsToSend) - 1].getData()",
          "4441:                 finalData += packetsToSend[len(packetsToSend) - 1]",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "4380:         return packetsToSend",
          "4383:         # TODO: Do a real config parser",
          "4384:         if self.__serverConfig is None:",
          "4385:             if configFile is None:",
          "",
          "[Removed Lines]",
          "4382:     def processConfigFile(self, configFile = None):",
          "",
          "[Added Lines]",
          "4449:     def processConfigFile(self, configFile=None):",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "4387:             self.__serverConfig = configparser.ConfigParser()",
          "4388:             self.__serverConfig.read(configFile)",
          "4394:         if self.__serverConfig.has_option('global', 'challenge'):",
          "4396:         else:",
          "4399:         if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):",
          "4400:             self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")",
          "4402:         if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):",
          "4404:         else:",
          "4405:             self.__SMB2Support = False",
          "4407:         if self.__logFile != 'None':",
          "4414:         # Process the credentials",
          "4416:         if credentials_fname != \"\":",
          "4417:             cred = open(credentials_fname)",
          "4418:             line = cred.readline()",
          "",
          "[Removed Lines]",
          "4390:         self.__serverName   = self.__serverConfig.get('global','server_name')",
          "4391:         self.__serverOS     = self.__serverConfig.get('global','server_os')",
          "4392:         self.__serverDomain = self.__serverConfig.get('global','server_domain')",
          "4393:         self.__logFile      = self.__serverConfig.get('global','log_file')",
          "4395:             self.__challenge    = unhexlify(self.__serverConfig.get('global', 'challenge'))",
          "4397:             self.__challenge    = b'A'*16",
          "4403:             self.__SMB2Support = self.__serverConfig.getboolean(\"global\",\"SMB2Support\")",
          "4408:             logging.basicConfig(filename = self.__logFile,",
          "4409:                              level = logging.DEBUG,",
          "4410:                              format=\"%(asctime)s: %(levelname)s: %(message)s\",",
          "4411:                              datefmt = '%m/%d/%Y %I:%M:%S %p')",
          "4412:         self.__log        = LOG",
          "4415:         credentials_fname = self.__serverConfig.get('global','credentials_file')",
          "",
          "[Added Lines]",
          "4457:         self.__serverName = self.__serverConfig.get('global', 'server_name')",
          "4458:         self.__serverOS = self.__serverConfig.get('global', 'server_os')",
          "4459:         self.__serverDomain = self.__serverConfig.get('global', 'server_domain')",
          "4460:         self.__logFile = self.__serverConfig.get('global', 'log_file')",
          "4462:             self.__challenge = unhexlify(self.__serverConfig.get('global', 'challenge'))",
          "4464:             self.__challenge = b'A' * 16",
          "4470:             self.__SMB2Support = self.__serverConfig.getboolean(\"global\", \"SMB2Support\")",
          "4475:             logging.basicConfig(filename=self.__logFile,",
          "4476:                                 level=logging.DEBUG,",
          "4477:                                 format=\"%(asctime)s: %(levelname)s: %(message)s\",",
          "4478:                                 datefmt='%m/%d/%Y %I:%M:%S %p')",
          "4479:         self.__log = LOG",
          "4482:         credentials_fname = self.__serverConfig.get('global', 'credentials_file')",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "4430:                 lmhash = '0%s' % lmhash",
          "4431:             if len(nthash) % 2:",
          "4432:                 nthash = '0%s' % nthash",
          "4434:                 lmhash = a2b_hex(lmhash)",
          "4435:                 nthash = a2b_hex(nthash)",
          "4436:             except:",
          "4437:                 pass",
          "4438:         self.__credentials[name.lower()] = (uid, lmhash, nthash)",
          "4440: # For windows platforms, opening a directory is not an option, so we set a void FD",
          "4441: VOID_FILE_DESCRIPTOR = -1",
          "4442: PIPE_FILE_DESCRIPTOR = -2",
          "",
          "[Removed Lines]",
          "4433:             try: # just in case they were converted already",
          "",
          "[Added Lines]",
          "4500:             try:  # just in case they were converted already",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "4448: from impacket.dcerpc.v5.rpcrt import DCERPCServer",
          "4449: from impacket.dcerpc.v5.dtypes import NULL",
          "4451: from impacket.dcerpc.v5.wkst import NetrWkstaGetInfo, NetrWkstaGetInfoResponse",
          "4452: from impacket.system_errors import ERROR_INVALID_LEVEL",
          "4454: class WKSTServer(DCERPCServer):",
          "4455:     def __init__(self):",
          "4456:         DCERPCServer.__init__(self)",
          "4457:         self.wkssvcCallBacks = {",
          "4458:             0: self.NetrWkstaGetInfo,",
          "4459:         }",
          "4463:         request = NetrWkstaGetInfo(data)",
          "4464:         self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])",
          "",
          "[Removed Lines]",
          "4450: from impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse",
          "4460:         self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'),'\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)",
          "4462:     def NetrWkstaGetInfo(self,data):",
          "",
          "[Added Lines]",
          "4518: from impacket.dcerpc.v5.srvs import NetrShareEnum, NetrShareEnumResponse, SHARE_INFO_1, NetrServerGetInfo, \\",
          "4519:     NetrServerGetInfoResponse, NetrShareGetInfo, NetrShareGetInfoResponse",
          "4530:         self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'), '\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)",
          "4532:     def NetrWkstaGetInfo(self, data):",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "4503:             21: self.NetrServerGetInfo,",
          "4504:         }",
          "4508:     def setServerConfig(self, config):",
          "4509:         self.__serverConfig = config",
          "4511:     def processConfigFile(self, configFile=None):",
          "4568:     def NetrShareEnum(self, data):",
          "4587: class SimpleSMBServer:",
          "4588:     \"\"\"",
          "",
          "[Removed Lines]",
          "4506:         self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'),'\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)",
          "4512:        if configFile is not None:",
          "4513:            self.__serverConfig = configparser.ConfigParser()",
          "4514:            self.__serverConfig.read(configFile)",
          "4515:        sections = self.__serverConfig.sections()",
          "4516:        # Let's check the log file",
          "4517:        self.__logFile      = self.__serverConfig.get('global','log_file')",
          "4518:        if self.__logFile != 'None':",
          "4519:             logging.basicConfig(filename = self.__logFile,",
          "4520:                              level = logging.DEBUG,",
          "4521:                              format=\"%(asctime)s: %(levelname)s: %(message)s\",",
          "4522:                              datefmt = '%m/%d/%Y %I:%M:%S %p')",
          "4524:        # Remove the global one",
          "4525:        del(sections[sections.index('global')])",
          "4526:        self._shares = {}",
          "4527:        for i in sections:",
          "4528:            self._shares[i] = dict(self.__serverConfig.items(i))",
          "4530:     def NetrShareGetInfo(self,data):",
          "4531:        request = NetrShareGetInfo(data)",
          "4532:        self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])",
          "4534:        s = request['NetName'][:-1].upper()",
          "4535:        answer = NetrShareGetInfoResponse()",
          "4536:        if s in self._shares:",
          "4537:            share  = self._shares[s]",
          "4539:            answer['InfoStruct']['tag'] = 1",
          "4540:            answer['InfoStruct']['ShareInfo1']['shi1_netname']= s+'\\x00'",
          "4541:            answer['InfoStruct']['ShareInfo1']['shi1_type']   = share['share type']",
          "4542:            answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment']+'\\x00'",
          "4543:            answer['ErrorCode'] = 0",
          "4544:        else:",
          "4545:            answer['InfoStruct']['tag'] = 1",
          "4546:            answer['InfoStruct']['ShareInfo1']= NULL",
          "4547:            answer['ErrorCode'] = 0x0906 #WERR_NET_NAME_NOT_FOUND",
          "4549:        return answer",
          "4551:     def NetrServerGetInfo(self,data):",
          "4552:        request = NetrServerGetInfo(data)",
          "4553:        self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])",
          "4554:        answer = NetrServerGetInfoResponse()",
          "4555:        answer['InfoStruct']['tag'] = 101",
          "4556:        # PLATFORM_ID_NT = 500",
          "4557:        answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500",
          "4558:        answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']",
          "4559:        # Windows 7 = 6.1",
          "4560:        answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6",
          "4561:        answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1",
          "4562:        # Workstation = 1",
          "4563:        answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1",
          "4564:        answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL",
          "4565:        answer['ErrorCode'] = 0",
          "4566:        return answer",
          "4569:        request = NetrShareEnum(data)",
          "4570:        self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])",
          "4571:        shareEnum = NetrShareEnumResponse()",
          "4572:        shareEnum['InfoStruct']['Level'] = 1",
          "4573:        shareEnum['InfoStruct']['ShareInfo']['tag'] = 1",
          "4574:        shareEnum['TotalEntries'] = len(self._shares)",
          "4575:        shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)",
          "4576:        shareEnum['ErrorCode'] = 0",
          "4578:        for i in self._shares:",
          "4579:            shareInfo = SHARE_INFO_1()",
          "4580:            shareInfo['shi1_netname'] = i+'\\x00'",
          "4581:            shareInfo['shi1_type'] = self._shares[i]['share type']",
          "4582:            shareInfo['shi1_remark'] = self._shares[i]['comment']+'\\x00'",
          "4583:            shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)",
          "4585:        return shareEnum",
          "",
          "[Added Lines]",
          "4577:         self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'), '\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)",
          "4583:         if configFile is not None:",
          "4584:             self.__serverConfig = configparser.ConfigParser()",
          "4585:             self.__serverConfig.read(configFile)",
          "4586:         sections = self.__serverConfig.sections()",
          "4587:         # Let's check the log file",
          "4588:         self.__logFile = self.__serverConfig.get('global', 'log_file')",
          "4589:         if self.__logFile != 'None':",
          "4590:             logging.basicConfig(filename=self.__logFile,",
          "4591:                                 level=logging.DEBUG,",
          "4592:                                 format=\"%(asctime)s: %(levelname)s: %(message)s\",",
          "4593:                                 datefmt='%m/%d/%Y %I:%M:%S %p')",
          "4595:         # Remove the global one",
          "4596:         del (sections[sections.index('global')])",
          "4597:         self._shares = {}",
          "4598:         for i in sections:",
          "4599:             self._shares[i] = dict(self.__serverConfig.items(i))",
          "4601:     def NetrShareGetInfo(self, data):",
          "4602:         request = NetrShareGetInfo(data)",
          "4603:         self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])",
          "4605:         s = request['NetName'][:-1].upper()",
          "4606:         answer = NetrShareGetInfoResponse()",
          "4607:         if s in self._shares:",
          "4608:             share = self._shares[s]",
          "4610:             answer['InfoStruct']['tag'] = 1",
          "4611:             answer['InfoStruct']['ShareInfo1']['shi1_netname'] = s + '\\x00'",
          "4612:             answer['InfoStruct']['ShareInfo1']['shi1_type'] = share['share type']",
          "4613:             answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment'] + '\\x00'",
          "4614:             answer['ErrorCode'] = 0",
          "4615:         else:",
          "4616:             answer['InfoStruct']['tag'] = 1",
          "4617:             answer['InfoStruct']['ShareInfo1'] = NULL",
          "4618:             answer['ErrorCode'] = 0x0906  # WERR_NET_NAME_NOT_FOUND",
          "4620:         return answer",
          "4622:     def NetrServerGetInfo(self, data):",
          "4623:         request = NetrServerGetInfo(data)",
          "4624:         self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])",
          "4625:         answer = NetrServerGetInfoResponse()",
          "4626:         answer['InfoStruct']['tag'] = 101",
          "4627:         # PLATFORM_ID_NT = 500",
          "4628:         answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500",
          "4629:         answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']",
          "4630:         # Windows 7 = 6.1",
          "4631:         answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6",
          "4632:         answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1",
          "4633:         # Workstation = 1",
          "4634:         answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1",
          "4635:         answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL",
          "4636:         answer['ErrorCode'] = 0",
          "4637:         return answer",
          "4640:         request = NetrShareEnum(data)",
          "4641:         self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])",
          "4642:         shareEnum = NetrShareEnumResponse()",
          "4643:         shareEnum['InfoStruct']['Level'] = 1",
          "4644:         shareEnum['InfoStruct']['ShareInfo']['tag'] = 1",
          "4645:         shareEnum['TotalEntries'] = len(self._shares)",
          "4646:         shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)",
          "4647:         shareEnum['ErrorCode'] = 0",
          "4649:         for i in self._shares:",
          "4650:             shareInfo = SHARE_INFO_1()",
          "4651:             shareInfo['shi1_netname'] = i + '\\x00'",
          "4652:             shareInfo['shi1_type'] = self._shares[i]['share type']",
          "4653:             shareInfo['shi1_remark'] = self._shares[i]['comment'] + '\\x00'",
          "4654:             shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)",
          "4656:         return shareEnum",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "4592:     :param integer listenPort: the port number you want the server to listen on",
          "4593:     :param string configFile: a file with all the servers' configuration. If no file specified, this class will create the basic parameters needed to run. You will need to add your shares manually tho. See addShare() method",
          "4594:     \"\"\"",
          "4596:         if configFile != '':",
          "4598:             self.__server.processConfigFile(configFile)",
          "4599:             self.__smbConfig = None",
          "4600:         else:",
          "4601:             # Here we write a mini config for the server",
          "4602:             self.__smbConfig = configparser.ConfigParser()",
          "4603:             self.__smbConfig.add_section('global')",
          "4614:             # IPC always needed",
          "4615:             self.__smbConfig.add_section('IPC$')",
          "4621:             self.__server.processConfigFile()",
          "4625:         # ask for shares using MS-RAP.",
          "4627:         self.__srvsServer = SRVSServer()",
          "4628:         self.__srvsServer.daemon = True",
          "4629:         self.__wkstServer = WKSTServer()",
          "4630:         self.__wkstServer.daemon = True",
          "4634:     def start(self):",
          "4635:         self.__srvsServer.start()",
          "",
          "[Removed Lines]",
          "4595:     def __init__(self, listenAddress = '0.0.0.0', listenPort=445, configFile=''):",
          "4597:             self.__server = SMBSERVER((listenAddress,listenPort))",
          "4604:             self.__smbConfig.set('global','server_name',''.join([random.choice(string.ascii_letters) for _ in range(8)]))",
          "4605:             self.__smbConfig.set('global','server_os',''.join([random.choice(string.ascii_letters) for _ in range(8)])",
          "4606: )",
          "4607:             self.__smbConfig.set('global','server_domain',''.join([random.choice(string.ascii_letters) for _ in range(8)])",
          "4608: )",
          "4609:             self.__smbConfig.set('global','log_file','None')",
          "4610:             self.__smbConfig.set('global','rpc_apis','yes')",
          "4611:             self.__smbConfig.set('global','credentials_file','')",
          "4612:             self.__smbConfig.set('global', 'challenge', \"A\"*16)",
          "4616:             self.__smbConfig.set('IPC$','comment','')",
          "4617:             self.__smbConfig.set('IPC$','read only','yes')",
          "4618:             self.__smbConfig.set('IPC$','share type','3')",
          "4619:             self.__smbConfig.set('IPC$','path','')",
          "4620:             self.__server = SMBSERVER((listenAddress,listenPort), config_parser = self.__smbConfig)",
          "4623:         # Now we have to register the MS-SRVS server. This specially important for",
          "4624:         # Windows 7+ and Mavericks clients since they WON'T (specially OSX)",
          "4631:         self.__server.registerNamedPipe('srvsvc',('127.0.0.1',self.__srvsServer.getListenPort()))",
          "4632:         self.__server.registerNamedPipe('wkssvc',('127.0.0.1',self.__wkstServer.getListenPort()))",
          "",
          "[Added Lines]",
          "4668:     def __init__(self, listenAddress='0.0.0.0', listenPort=445, configFile=''):",
          "4670:             self.__server = SMBSERVER((listenAddress, listenPort))",
          "4677:             self.__smbConfig.set('global', 'server_name',",
          "4678:                                  ''.join([random.choice(string.ascii_letters) for _ in range(8)]))",
          "4679:             self.__smbConfig.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)])",
          "4680:                                  )",
          "4681:             self.__smbConfig.set('global', 'server_domain',",
          "4682:                                  ''.join([random.choice(string.ascii_letters) for _ in range(8)])",
          "4683:                                  )",
          "4684:             self.__smbConfig.set('global', 'log_file', 'None')",
          "4685:             self.__smbConfig.set('global', 'rpc_apis', 'yes')",
          "4686:             self.__smbConfig.set('global', 'credentials_file', '')",
          "4687:             self.__smbConfig.set('global', 'challenge', \"A\" * 16)",
          "4691:             self.__smbConfig.set('IPC$', 'comment', '')",
          "4692:             self.__smbConfig.set('IPC$', 'read only', 'yes')",
          "4693:             self.__smbConfig.set('IPC$', 'share type', '3')",
          "4694:             self.__smbConfig.set('IPC$', 'path', '')",
          "4695:             self.__server = SMBSERVER((listenAddress, listenPort), config_parser=self.__smbConfig)",
          "4698:         # Now we have to register the MS-SRVS server. This specially important for",
          "4699:         # Windows 7+ and Mavericks clients since they WON'T (specially OSX)",
          "4706:         self.__server.registerNamedPipe('srvsvc', ('127.0.0.1', self.__srvsServer.getListenPort()))",
          "4707:         self.__server.registerNamedPipe('wkssvc', ('127.0.0.1', self.__wkstServer.getListenPort()))",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "4645:     def getRegisteredNamedPipes(self):",
          "4646:         return self.__server.getRegisteredNamedPipes()",
          "4649:         share = shareName.upper()",
          "4650:         self.__smbConfig.add_section(share)",
          "4651:         self.__smbConfig.set(share, 'comment', shareComment)",
          "",
          "[Removed Lines]",
          "4648:     def addShare(self, shareName, sharePath, shareComment='', shareType = '0', readOnly = 'no'):",
          "",
          "[Added Lines]",
          "4723:     def addShare(self, shareName, sharePath, shareComment='', shareType='0', readOnly='no'):",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "4669:             self.__smbConfig.set('global', 'challenge', challenge)",
          "4670:             self.__server.setServerConfig(self.__smbConfig)",
          "4671:             self.__server.processConfigFile()",
          "4673:     def setLogFile(self, logFile):",
          "4675:         self.__server.setServerConfig(self.__smbConfig)",
          "4676:         self.__server.processConfigFile()",
          "4678:     def setCredentialsFile(self, logFile):",
          "4680:         self.__server.setServerConfig(self.__smbConfig)",
          "4681:         self.__server.processConfigFile()",
          "",
          "[Removed Lines]",
          "4674:         self.__smbConfig.set('global','log_file',logFile)",
          "4679:         self.__smbConfig.set('global','credentials_file',logFile)",
          "",
          "[Added Lines]",
          "4749:         self.__smbConfig.set('global', 'log_file', logFile)",
          "4754:         self.__smbConfig.set('global', 'credentials_file', logFile)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0668f3ee691b6ec60cda4b580b17cdf97b2aa88",
      "candidate_info": {
        "commit_hash": "f0668f3ee691b6ec60cda4b580b17cdf97b2aa88",
        "repo": "SecureAuthCorp/impacket",
        "commit_url": "https://github.com/SecureAuthCorp/impacket/commit/f0668f3ee691b6ec60cda4b580b17cdf97b2aa88",
        "files": [
          "tests/SMB_RPC/test_smbserver.py",
          "tests/runall.sh"
        ],
        "message": "Added SimpleSMBServer tests (#1067)\n\nAdding some pseudo-functional tests for the `SimpleSMBServer`. This spins up a `SimpleSMBServer` instance and connects to it using our own `SMBConnection`. Includes checks for #1066.\n\nThis PR:\n- Adds basic unit tests for the path validation function introduced in #1066.\n- Adds pseudo-functional tests for `SimpleSMBServer`, checking login, list, get and put calls.",
        "before_after_code_files": [
          "tests/SMB_RPC/test_smbserver.py||tests/SMB_RPC/test_smbserver.py",
          "tests/runall.sh||tests/runall.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/SMB_RPC/test_smbserver.py||tests/SMB_RPC/test_smbserver.py": [
          "File: tests/SMB_RPC/test_smbserver.py -> tests/SMB_RPC/test_smbserver.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env python",
          "2: # SECUREAUTH LABS. Copyright 2021 SecureAuth Corporation. All rights reserved.",
          "3: #",
          "4: # This software is provided under under a slightly modified version",
          "5: # of the Apache Software License. See the accompanying LICENSE file",
          "6: # for more information.",
          "7: #",
          "8: # Basic unit tests for the SMB Server.",
          "9: #",
          "10: # Author:",
          "11: #  Martin Gallo (@martingalloar)",
          "12: #",
          "14: import unittest",
          "15: from time import sleep",
          "16: from os.path import exists, join",
          "17: from os import mkdir, rmdir, remove",
          "18: from multiprocessing import Process",
          "20: from six import StringIO, BytesIO, b",
          "22: from impacket.smbserver import isInFileJail, SimpleSMBServer",
          "23: from impacket.smbconnection import SMBConnection, SessionError, compute_lmhash, compute_nthash",
          "26: class SMBServerUnitTests(unittest.TestCase):",
          "27:     \"\"\"Unit tests for the SMBServer",
          "28:     \"\"\"",
          "30:     def test_isInFileJail(self):",
          "31:         \"\"\"Test validation of common prefix path.",
          "32:         \"\"\"",
          "33:         jail_path = \"/tmp/jail_path\"",
          "34:         self.assertTrue(isInFileJail(jail_path, \"filename\"))",
          "35:         self.assertTrue(isInFileJail(jail_path, \"./filename\"))",
          "36:         self.assertTrue(isInFileJail(jail_path, \"../jail_path/filename\"))",
          "38:         self.assertFalse(isInFileJail(jail_path, \"/filename\"))",
          "39:         self.assertFalse(isInFileJail(jail_path, \"/tmp/filename\"))",
          "40:         self.assertFalse(isInFileJail(jail_path, \"../filename\"))",
          "41:         self.assertFalse(isInFileJail(jail_path, \"../../filename\"))",
          "44: class SimpleSMBServerFuncTests(unittest.TestCase):",
          "45:     \"\"\"Pseudo functional tests for the SimpleSMBServer.",
          "47:     These are pseudo functional as we're using our own SMBConnection classes. For a complete functional test",
          "48:     we should (and can) use for example Samba's smbclient or similar.",
          "49:     \"\"\"",
          "51:     address = \"127.0.0.1\"",
          "52:     port = 1445",
          "53:     username = \"UserName\"",
          "54:     password = \"Password\"",
          "55:     domain = \"DOMAIN\"",
          "56:     lmhash = compute_lmhash(password)",
          "57:     nthash = compute_nthash(password)",
          "59:     share_name = \"share\"",
          "60:     share_path = \"jail_dir\"",
          "61:     share_file = \"jail_file\"",
          "62:     share_new_file = \"jail_new_file\"",
          "63:     share_unjailed_file = \"unjailed_new_file\"",
          "64:     share_new_content = \"some content\"",
          "66:     def setUp(self):",
          "67:         \"\"\"Creates folders and files required for testing the list, put and get functionality.",
          "68:         \"\"\"",
          "69:         if not exists(self.share_path):",
          "70:             mkdir(self.share_path)",
          "71:         for f in [self.share_file, self.share_new_file]:",
          "72:             if not exists(join(self.share_path, f)):",
          "73:                 with open(join(self.share_path, f), \"a\") as fd:",
          "74:                     fd.write(self.share_new_content)",
          "76:     def tearDown(self):",
          "77:         \"\"\"Removes folders and files used for testing.",
          "78:         \"\"\"",
          "79:         for f in [self.share_file, self.share_new_file]:",
          "80:             if exists(join(self.share_path, f)):",
          "81:                 remove(join(self.share_path, f))",
          "82:         if exists(self.share_unjailed_file):",
          "83:             remove(self.share_unjailed_file)",
          "84:         if exists(self.share_path):",
          "85:             rmdir(self.share_path)",
          "86:         self.stop_smbserver()",
          "88:     def get_smbserver(self):",
          "89:         return SimpleSMBServer(listenAddress=self.address, listenPort=int(self.port))",
          "91:     def start_smbserver(self, server):",
          "92:         \"\"\"Starts the SimpleSMBServer process.",
          "93:         \"\"\"",
          "94:         self.server_process = Process(target=server.start)",
          "95:         self.server_process.start()",
          "97:     def stop_smbserver(self):",
          "98:         \"\"\"Stops the SimpleSMBServer process and wait for insider threads to join.",
          "99:         \"\"\"",
          "100:         self.server_process.terminate()",
          "101:         sleep(0.5)",
          "103:     def test_smbserver_login(self):",
          "104:         \"\"\"Test authentication using password and LM/NTHash login.",
          "105:         \"\"\"",
          "106:         server = self.get_smbserver()",
          "107:         server.addCredential(self.username, 0, self.lmhash, self.nthash)",
          "108:         self.start_smbserver(server)",
          "110:         # Valid password login",
          "111:         client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "112:         client.login(self.username, self.password)",
          "113:         client.close()",
          "115:         # Valid hash login",
          "116:         client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "117:         client.login(self.username, '', lmhash=self.lmhash, nthash=self.nthash)",
          "118:         client.close()",
          "120:         # Invalid password login",
          "121:         with self.assertRaises(SessionError):",
          "122:             client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "123:             client.login(self.username, 'SomeInvalidPassword')",
          "124:             client.close()",
          "126:         # Invalid username login",
          "127:         with self.assertRaises(SessionError):",
          "128:             client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "129:             client.login(\"InvalidUser\", \"\", lmhash=self.lmhash, nthash=self.nthash)",
          "130:             client.close()",
          "132:         # Invalid hash login",
          "133:         with self.assertRaises(SessionError):",
          "134:             client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "135:             client.login(self.username, \"\", lmhash=self.nthash, nthash=self.lmhash)",
          "136:             client.close()",
          "138:     def test_smbserver_share_list(self):",
          "139:         \"\"\"Test listing files in a shared folder.",
          "140:         \"\"\"",
          "141:         server = SimpleSMBServer(listenAddress=self.address, listenPort=int(self.port))",
          "142:         server.addCredential(self.username, 0, self.lmhash, self.nthash)",
          "143:         server.addShare(self.share_name, self.share_path)",
          "144:         self.start_smbserver(server)",
          "146:         client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "147:         client.login(self.username, self.password)",
          "148:         client.listPath(self.share_name, \"/\")",
          "150:         # Check path traversal in list as in #1066",
          "151:         with self.assertRaises(SessionError):",
          "152:             client.listPath(self.share_name, \"../impacket/\")",
          "154:         client.close()",
          "156:     def test_smbserver_share_put(self):",
          "157:         \"\"\"Test writing files to a shared folder.",
          "158:         \"\"\"",
          "159:         server = SimpleSMBServer(listenAddress=self.address, listenPort=int(self.port))",
          "160:         server.addCredential(self.username, 0, self.lmhash, self.nthash)",
          "161:         server.addShare(self.share_name, self.share_path)",
          "162:         self.start_smbserver(server)",
          "164:         client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "165:         client.login(self.username, self.password)",
          "167:         local_file = StringIO(self.share_new_content)",
          "169:         client.putFile(self.share_name, self.share_new_file, local_file.read)",
          "170:         self.assertTrue(exists(join(self.share_path, self.share_new_file)))",
          "171:         with open(join(self.share_path, self.share_new_file), \"r\") as fd:",
          "172:             self.assertEqual(fd.read(), self.share_new_content)",
          "174:         # Check path traversal in put as in #1066",
          "175:         with self.assertRaises(SessionError):",
          "176:             client.putFile(self.share_name, join(\"..\", self.share_unjailed_file), local_file.read)",
          "177:         self.assertFalse(exists(self.share_unjailed_file))",
          "179:         client.close()",
          "181:     def test_smbserver_share_get(self):",
          "182:         \"\"\"Test reading files from a shared folder.",
          "183:         \"\"\"",
          "184:         server = SimpleSMBServer(listenAddress=self.address, listenPort=int(self.port))",
          "185:         server.addCredential(self.username, 0, self.lmhash, self.nthash)",
          "186:         server.addShare(self.share_name, self.share_path)",
          "187:         self.start_smbserver(server)",
          "189:         client = SMBConnection(self.address, self.address, sess_port=int(self.port))",
          "190:         client.login(self.username, self.password)",
          "192:         local_file = BytesIO()",
          "193:         client.getFile(self.share_name, self.share_file, local_file.write)",
          "194:         local_file.seek(0)",
          "195:         self.assertEqual(local_file.read(), b(self.share_new_content))",
          "197:         # Check unexistent file",
          "198:         with self.assertRaises(SessionError):",
          "199:             client.getFile(self.share_name, \"unexistent\", local_file.write)",
          "201:         client.close()",
          "204: if __name__ == \"__main__\":",
          "205:     loader = unittest.TestLoader()",
          "206:     suite = unittest.TestSuite()",
          "207:     suite.addTests(loader.loadTestsFromTestCase(SMBServerUnitTests))",
          "208:     suite.addTests(loader.loadTestsFromTestCase(SimpleSMBServerFuncTests))",
          "209:     unittest.TextTestRunner(verbosity=1).run(suite)",
          "",
          "---------------"
        ],
        "tests/runall.sh||tests/runall.sh": [
          "File: tests/runall.sh -> tests/runall.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: $RUN test_spnego.py 2>&1 1>/dev/null | tee -a $OUTPUTFILE",
          "43: echo test_ntlm.py",
          "44: $RUN test_ntlm.py 2>&1 1>/dev/null | tee -a $OUTPUTFILE",
          "46: if [ -z \"$NO_REMOTE\" ]; then",
          "47:     echo Testing SMB RPC/LDAP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45: echo test_smbserver.py",
          "46: $RUN test_smbserver.py 2>&1 1>/dev/null | tee -a $OUTPUTFILE",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-30624",
  "cve_desc": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 6.0.2, 7.0.1, and 8.0.1, Wasmtime's implementation of managing per-instance state, such as tables and memories, contains LLVM-level undefined behavior. This undefined behavior was found to cause runtime-level issues when compiled with LLVM 16 which causes some writes, which are critical for correctness, to be optimized away. Vulnerable versions of Wasmtime compiled with Rust 1.70, which is currently in beta, or later are known to have incorrectly compiled functions. Versions of Wasmtime compiled with the current Rust stable release, 1.69, and prior are not known at this time to have any issues, but can theoretically exhibit potential issues.\n\nThe underlying problem is that Wasmtime's runtime state for an instance involves a Rust-defined structure called `Instance` which has a trailing `VMContext` structure after it. This `VMContext` structure has a runtime-defined layout that is unique per-module. This representation cannot be expressed with safe code in Rust so `unsafe` code is required to maintain this state. The code doing this, however, has methods which take `&self` as an argument but modify data in the `VMContext` part of the allocation. This means that pointers derived from `&self` are mutated. This is typically not allowed, except in the presence of `UnsafeCell`, in Rust. When compiled to LLVM these functions have `noalias readonly` parameters which means it's UB to write through the pointers.\n\nWasmtime's internal representation and management of `VMContext` has been updated to use `&mut self` methods where appropriate. Additionally verification tools for `unsafe` code in Rust, such as `cargo miri`, are planned to be executed on the `main` branch soon to fix any Rust-level issues that may be exploited in future compiler versions.\n\nPrecomplied binaries available for Wasmtime from GitHub releases have been compiled with at most LLVM 15 so are not known to be vulnerable. As mentioned above, however, it's still recommended to update.\n\nWasmtime version 6.0.2, 7.0.1, and 8.0.1 have been issued which contain the patch necessary to work correctly on LLVM 16 and have no known UB on LLVM 15 and earlier. If Wasmtime is compiled with Rust 1.69 and prior, which use LLVM 15, then there are no known issues. There is a theoretical possibility for undefined behavior to exploited, however, so it's recommended that users upgrade to a patched version of Wasmtime. Users using beta Rust (1.70 at this time) or nightly Rust (1.71 at this time) must update to a patched version to work correctly.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
  "patch_info": {
    "commit_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e",
    "files": [
      "RELEASES.md",
      "crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs"
    ],
    "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix dates and fill out more notes",
    "before_after_code_files": [
      "crates/environ/src/module.rs||crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
    ]
  },
  "patch_diff": {
    "crates/environ/src/module.rs||crates/environ/src/module.rs": [
      "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:         }",
      "242:         let mut idx = 0;",
      "243:         let ok = self.module.memory_initialization.init_memory(",
      "244:             InitMemory::CompileTime(&self.module),",
      "",
      "[Removed Lines]",
      "245:             &mut |memory, init| {",
      "",
      "[Added Lines]",
      "244:             &mut (),",
      "246:             |(), memory, init| {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "529:         &self,",
      "532:     ) -> bool {",
      "533:         let initializers = match self {",
      "",
      "[Removed Lines]",
      "528:     pub fn init_memory(",
      "530:         state: InitMemory<'_>,",
      "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "[Added Lines]",
      "529:     pub fn init_memory<T>(",
      "531:         state: &mut T,",
      "532:         init: InitMemory<'_, T>,",
      "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "543:             MemoryInitialization::Static { map } => {",
      "544:                 for (index, init) in map {",
      "545:                     if let Some(init) = init {",
      "547:                         if !result {",
      "548:                             return result;",
      "549:                         }",
      "",
      "[Removed Lines]",
      "546:                         let result = write(index, init);",
      "",
      "[Added Lines]",
      "548:                         let result = write(state, index, init);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "569:             let base = match base {",
      "571:                     InitMemory::Runtime {",
      "572:                         get_global_as_u64, ..",
      "574:                     InitMemory::CompileTime(_) => return false,",
      "575:                 },",
      "576:                 None => 0,",
      "",
      "[Removed Lines]",
      "570:                 Some(index) => match &state {",
      "573:                     } => get_global_as_u64(index),",
      "",
      "[Added Lines]",
      "572:                 Some(index) => match &init {",
      "575:                     } => get_global_as_u64(state, index),",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "585:                 None => return false,",
      "586:             };",
      "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
      "590:                 InitMemory::Runtime {",
      "591:                     memory_size_in_pages,",
      "592:                     ..",
      "594:             };",
      "",
      "[Removed Lines]",
      "588:             let cur_size_in_pages = match &state {",
      "593:                 } => memory_size_in_pages(memory_index),",
      "",
      "[Added Lines]",
      "590:             let cur_size_in_pages = match &init {",
      "595:                 } => memory_size_in_pages(state, memory_index),",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "616:                 offset: start,",
      "617:                 data: data.clone(),",
      "618:             };",
      "620:             if !result {",
      "621:                 return result;",
      "622:             }",
      "",
      "[Removed Lines]",
      "619:             let result = write(memory_index, &init);",
      "",
      "[Added Lines]",
      "621:             let result = write(state, memory_index, &init);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "631: pub enum InitMemory<'a> {",
      "",
      "[Added Lines]",
      "633: pub enum InitMemory<'a, T> {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "641:     Runtime {",
      "647:     },",
      "648: }",
      "",
      "[Removed Lines]",
      "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
      "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
      "",
      "[Added Lines]",
      "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
      "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
      "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "",
      "[Removed Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
      "151:         (self.vmctx_ptr().cast::<u8>())",
      "",
      "[Added Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
      "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
      "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:     #[allow(dead_code)]",
      "187:         unsafe { *self.table_ptr(index) }",
      "188:     }",
      "192:         unsafe {",
      "194:         }",
      "195:     }",
      "200:     }",
      "",
      "[Removed Lines]",
      "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
      "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "[Added Lines]",
      "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
      "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:     }",
      "242:         unsafe { &*self.global_ptr(index) }",
      "243:     }",
      "248:     }",
      "",
      "[Removed Lines]",
      "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "[Added Lines]",
      "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "254:     pub(crate) fn defined_or_imported_global_ptr(",
      "256:         index: GlobalIndex,",
      "257:     ) -> *mut VMGlobalDefinition {",
      "258:         if let Some(index) = self.module().defined_global_index(index) {",
      "",
      "[Removed Lines]",
      "255:         &self,",
      "",
      "[Added Lines]",
      "261:         &mut self,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "263:     }",
      "268:     }",
      "273:     }",
      "278:     }",
      "",
      "[Removed Lines]",
      "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
      "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
      "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
      "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
      "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
      "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "[Added Lines]",
      "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
      "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
      "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
      "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
      "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
      "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "402:     }",
      "406:         let index = DefinedTableIndex::new(",
      "407:             usize::try_from(",
      "408:                 (table as *const VMTableDefinition)",
      "",
      "[Removed Lines]",
      "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "[Added Lines]",
      "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "584:             let func = &self.module().functions[index];",
      "585:             let sig = func.signature;",
      "586:             let anyfunc: *mut VMCallerCheckedFuncRef = self",
      "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
      "589:                 );",
      "590:             self.construct_anyfunc(index, sig, anyfunc);",
      "",
      "[Removed Lines]",
      "587:                 .vmctx_plus_offset::<VMCallerCheckedFuncRef>(",
      "",
      "[Added Lines]",
      "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "923:     ) {",
      "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
      "927:         self.set_callee(None);",
      "928:         self.set_store(store.as_raw());",
      "931:         let signatures = self.runtime_info.signature_ids();",
      "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
      "939:         ptr::copy_nonoverlapping(",
      "940:             imports.functions.as_ptr(),",
      "942:             imports.functions.len(),",
      "943:         );",
      "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
      "945:         ptr::copy_nonoverlapping(",
      "946:             imports.tables.as_ptr(),",
      "948:             imports.tables.len(),",
      "949:         );",
      "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
      "951:         ptr::copy_nonoverlapping(",
      "952:             imports.memories.as_ptr(),",
      "954:             imports.memories.len(),",
      "955:         );",
      "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
      "957:         ptr::copy_nonoverlapping(",
      "958:             imports.globals.as_ptr(),",
      "960:             imports.globals.len(),",
      "961:         );",
      "",
      "[Removed Lines]",
      "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
      "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
      "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
      "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
      "",
      "[Added Lines]",
      "942:             &VMBuiltinFunctionsArray::INIT;",
      "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
      "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
      "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
      "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
      "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
      "973:             ptr = ptr.add(1);",
      "",
      "[Removed Lines]",
      "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
      "",
      "[Added Lines]",
      "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
      "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
      "985:             let memory_index = module.memory_index(defined_memory_index);",
      "",
      "[Removed Lines]",
      "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
      "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
      "",
      "[Added Lines]",
      "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
      "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1068: impl Drop for Instance {",
      "1069:     fn drop(&mut self) {",
      "1073:                 Some(idx) => idx,",
      "1074:                 None => continue,",
      "1075:             };",
      "",
      "[Removed Lines]",
      "1071:         for (idx, global) in self.module().globals.iter() {",
      "1072:             let idx = match self.module().defined_global_index(idx) {",
      "",
      "[Added Lines]",
      "1078:         let module = self.module().clone();",
      "1079:         for (idx, global) in module.globals.iter() {",
      "1080:             let idx = match module.defined_global_index(idx) {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1182:     }",
      "1187:     }",
      "",
      "[Removed Lines]",
      "1185:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1186:         self.instance().table_index(table)",
      "",
      "[Added Lines]",
      "1193:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1194:         self.instance_mut().table_index(table)",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
      "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "200:     fn purge_module(&self, module: CompiledModuleId);",
      "201: }",
      "204:     match init.base {",
      "205:         Some(base) => {",
      "214:             init.offset",
      "215:                 .checked_add(val)",
      "",
      "[Removed Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
      "206:             let val = unsafe {",
      "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
      "209:                 } else {",
      "211:                 }",
      "212:             };",
      "",
      "[Added Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
      "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "256:         TableInitialization::FuncTable { segments, .. }",
      "257:         | TableInitialization::Segments { segments } => {",
      "258:             for segment in segments {",
      "259:                 instance.table_init_segment(",
      "260:                     segment.table_index,",
      "261:                     &segment.elements,",
      "263:                     0,",
      "264:                     segment.elements.len() as u32,",
      "265:                 )?;",
      "",
      "[Removed Lines]",
      "262:                     get_table_init_start(segment, instance)?,",
      "",
      "[Added Lines]",
      "253:                 let start = get_table_init_start(segment, instance)?;",
      "257:                     start,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "270:     Ok(())",
      "271: }",
      "274:     match init.base {",
      "275:         Some(base) => {",
      "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
      "277:                 .memory",
      "278:                 .memory64;",
      "279:             let val = unsafe {",
      "285:                 if mem64 {",
      "287:                 } else {",
      "289:                 }",
      "290:             };",
      "",
      "[Removed Lines]",
      "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
      "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
      "281:                     instance.global(def_index)",
      "282:                 } else {",
      "283:                     &*instance.imported_global(base).from",
      "284:                 };",
      "288:                     u64::from(*global.as_u32())",
      "",
      "[Added Lines]",
      "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
      "275:                 let global = instance.defined_or_imported_global_ptr(base);",
      "279:                     u64::from(*(*global).as_u32())",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "297:     }",
      "298: }",
      "301:     for init in initializers {",
      "302:         let memory = instance.get_memory(init.memory_index);",
      "303:         let start = get_memory_init_start(init, instance)?;",
      "",
      "[Removed Lines]",
      "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
      "",
      "[Added Lines]",
      "291: fn check_memory_init_bounds(",
      "292:     instance: &mut Instance,",
      "293:     initializers: &[MemoryInitializer],",
      "294: ) -> Result<()> {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "319: }",
      "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
      "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
      "335:         } else {",
      "337:         }",
      "338:     };",
      "",
      "[Removed Lines]",
      "322:     let memory_size_in_pages =",
      "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
      "327:     let get_global_as_u64 = &|global| unsafe {",
      "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
      "329:             instance.global(def_index)",
      "330:         } else {",
      "331:             &*instance.imported_global(global).from",
      "332:         };",
      "336:             u64::from(*def.as_u32())",
      "",
      "[Added Lines]",
      "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
      "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
      "318:     };",
      "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
      "323:         let def = instance.defined_or_imported_global_ptr(global);",
      "327:             u64::from(*(*def).as_u32())",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:     let ok = module.memory_initialization.init_memory(",
      "349:         InitMemory::Runtime {",
      "350:             memory_size_in_pages,",
      "351:             get_global_as_u64,",
      "352:         },",
      "",
      "[Removed Lines]",
      "353:         &mut |memory_index, init| {",
      "",
      "[Added Lines]",
      "340:         instance,",
      "345:         |instance, memory_index, init| {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
      "384:     check_table_init_bounds(instance, module)?;",
      "387:         MemoryInitialization::Segmented(initializers) => {",
      "388:             check_memory_init_bounds(instance, initializers)?;",
      "389:         }",
      "",
      "[Removed Lines]",
      "386:     match &instance.module().memory_initialization {",
      "",
      "[Added Lines]",
      "378:     match &module.memory_initialization {",
      "",
      "---------------"
    ],
    "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
      "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
      "414:     let index = GlobalIndex::from_u32(index);",
      "416:     let global = instance.defined_or_imported_global_ptr(index);",
      "417:     match (*global).as_externref().clone() {",
      "418:         None => ptr::null_mut(),",
      "",
      "[Removed Lines]",
      "415:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "415:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "435:     };",
      "437:     let index = GlobalIndex::from_u32(index);",
      "439:     let global = instance.defined_or_imported_global_ptr(index);",
      "",
      "[Removed Lines]",
      "438:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "438:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------"
    ],
    "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
      "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "219: where",
      "220:     F: FnMut(*mut VMContext),",
      "221: {",
      "224:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
      "225:         wasmtime_setjmp(",
      "",
      "[Removed Lines]",
      "222:     let limits = (*caller).instance().runtime_limits();",
      "",
      "[Added Lines]",
      "222:     let limits = (*caller).instance_mut().runtime_limits();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "60ce6f5d5c5b7defc6f7a8bfaa6bfb8db82b0aa1",
      "candidate_info": {
        "commit_hash": "60ce6f5d5c5b7defc6f7a8bfaa6bfb8db82b0aa1",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/60ce6f5d5c5b7defc6f7a8bfaa6bfb8db82b0aa1",
        "files": [
          "crates/runtime/src/externref.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs",
          "crates/runtime/src/traphandlers/backtrace.rs",
          "crates/wasmtime/src/profiling.rs",
          "crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trap.rs",
          "src/commands/run.rs",
          "tests/all/async_functions.rs",
          "tests/all/traps.rs"
        ],
        "message": "`wasmtime`: Fix resetting stack-walking registers when entering/exiting Wasm (#6321)\n\n* wasmtime: Fix resetting stack-walking registers when entering/exiting Wasm\n\nFixes a regression from #6262, originally reported in\nhttps://github.com/bytecodealliance/wasmtime-dotnet/pull/245\n\nThe issue was that we would enter Wasm and save the stack-walking registers but\nnever clear them after Wasm returns. Then if a host-to-host call tried to\ncapture a stack, we would mistakenly attempt to use those stale registers to\nstart the stack walk. This mistake would be caught by an assertion, triggering a\npanic.\n\nThis commit fixes the issue by managing the save/restore in the\n`CallThreadState` construction/drop, rather than in the old `set_prev`\nmethod.\n\nCo-Authored-By: Alex Crichton <alex@alexcrichton.com>\n\n* Plumb through `VMRuntimeLimits` when capturing stack traces\n\nThis way we can differentiate between the same module loaded in different stores\nand avoid leaking other stores' frames into our backtraces.\n\nCo-Authored-By: Jamey Sharp <jsharp@fastly.com>\n\n---------\n\nCo-authored-by: Alex Crichton <alex@alexcrichton.com>\nCo-authored-by: Jamey Sharp <jsharp@fastly.com>",
        "before_after_code_files": [
          "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs",
          "crates/runtime/src/traphandlers/backtrace.rs||crates/runtime/src/traphandlers/backtrace.rs",
          "crates/wasmtime/src/profiling.rs||crates/wasmtime/src/profiling.rs",
          "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs",
          "src/commands/run.rs||src/commands/run.rs",
          "tests/all/async_functions.rs||tests/all/async_functions.rs",
          "tests/all/traps.rs||tests/all/traps.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs": [
          "File: crates/runtime/src/externref.rs -> crates/runtime/src/externref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "102: use std::alloc::Layout;",
          "103: use std::any::Any;",
          "104: use std::cell::UnsafeCell;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: use crate::{Backtrace, VMRuntimeLimits};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111: use std::sync::atomic::{self, AtomicUsize, Ordering};",
          "112: use wasmtime_environ::StackMap;",
          "",
          "[Removed Lines]",
          "114: use crate::Backtrace;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "649:     #[inline]",
          "650:     pub unsafe fn insert_with_gc(",
          "651:         &mut self,",
          "652:         externref: VMExternRef,",
          "653:         module_info_lookup: &dyn ModuleInfoLookup,",
          "654:     ) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "651:         limits: *const VMRuntimeLimits,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "656:         assert!(self.gc_okay);",
          "658:         if let Err(externref) = self.try_insert(externref) {",
          "660:         }",
          "661:     }",
          "663:     #[inline(never)]",
          "664:     unsafe fn gc_and_insert_slow(",
          "665:         &mut self,",
          "666:         externref: VMExternRef,",
          "667:         module_info_lookup: &dyn ModuleInfoLookup,",
          "668:     ) {",
          "",
          "[Removed Lines]",
          "659:             self.gc_and_insert_slow(externref, module_info_lookup);",
          "669:         gc(module_info_lookup, self);",
          "",
          "[Added Lines]",
          "659:             self.gc_and_insert_slow(limits, externref, module_info_lookup);",
          "666:         limits: *const VMRuntimeLimits,",
          "670:         gc(limits, module_info_lookup, self);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "856: pub unsafe fn gc(",
          "857:     module_info_lookup: &dyn ModuleInfoLookup,",
          "858:     externref_activations_table: &mut VMExternRefActivationsTable,",
          "859: ) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "858:     limits: *const VMRuntimeLimits,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "894:     }",
          "896:     log::trace!(\"begin GC trace\");",
          "898:         let pc = frame.pc();",
          "899:         debug_assert!(pc != 0, \"we should always get a valid PC for Wasm frames\");",
          "",
          "[Removed Lines]",
          "897:     Backtrace::trace(|frame| {",
          "",
          "[Added Lines]",
          "899:     Backtrace::trace(limits, |frame| {",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "395: unsafe fn activations_table_insert_with_gc(vmctx: *mut VMContext, externref: *mut u8) {",
          "396:     let externref = VMExternRef::clone_from_raw(externref);",
          "398:     let (activations_table, module_info_lookup) = (*instance.store()).externref_activations_table();",
          "",
          "[Removed Lines]",
          "397:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "397:     let instance = (*vmctx).instance_mut();",
          "398:     let limits = *instance.runtime_limits();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "407:     activations_table.insert_without_gc(externref.clone());",
          "410: }",
          "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
          "414:     let index = GlobalIndex::from_u32(index);",
          "415:     let instance = (*vmctx).instance_mut();",
          "416:     let global = instance.defined_or_imported_global_ptr(index);",
          "417:     match (*global).as_externref().clone() {",
          "418:         None => ptr::null_mut(),",
          "",
          "[Removed Lines]",
          "409:     activations_table.insert_with_gc(externref, module_info_lookup);",
          "",
          "[Added Lines]",
          "410:     activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "417:     let limits = *instance.runtime_limits();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:             let raw = externref.as_raw();",
          "421:             let (activations_table, module_info_lookup) =",
          "422:                 (*instance.store()).externref_activations_table();",
          "424:             raw",
          "425:         }",
          "426:     }",
          "",
          "[Removed Lines]",
          "423:             activations_table.insert_with_gc(externref, module_info_lookup);",
          "",
          "[Added Lines]",
          "425:             activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "249: mod call_thread_state {",
          "250:     use super::*;",
          "",
          "[Removed Lines]",
          "251:     use std::mem;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "263:         prev: Cell<tls::Ptr>,",
          "272:         old_last_wasm_exit_fp: Cell<usize>,",
          "273:         old_last_wasm_exit_pc: Cell<usize>,",
          "274:         old_last_wasm_entry_sp: Cell<usize>,",
          "275:     }",
          "277:     impl CallThreadState {",
          "278:         #[inline]",
          "279:         pub(super) fn new(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277:     impl Drop for CallThreadState {",
          "278:         fn drop(&mut self) {",
          "279:             unsafe {",
          "283:             }",
          "284:         }",
          "285:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:                 capture_backtrace,",
          "289:                 limits,",
          "290:                 prev: Cell::new(ptr::null()),",
          "294:             }",
          "295:         }",
          "",
          "[Removed Lines]",
          "291:                 old_last_wasm_exit_fp: Cell::new(0),",
          "292:                 old_last_wasm_exit_pc: Cell::new(0),",
          "293:                 old_last_wasm_entry_sp: Cell::new(0),",
          "",
          "[Added Lines]",
          "301:                 old_last_wasm_exit_fp: Cell::new(unsafe { *(*limits).last_wasm_exit_fp.get() }),",
          "302:                 old_last_wasm_exit_pc: Cell::new(unsafe { *(*limits).last_wasm_exit_pc.get() }),",
          "303:                 old_last_wasm_entry_sp: Cell::new(unsafe { *(*limits).last_wasm_entry_sp.get() }),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "314:             self.prev.get()",
          "315:         }",
          "394:         }",
          "395:     }",
          "396: }",
          "",
          "[Removed Lines]",
          "322:         pub unsafe fn set_prev(&self, prev: tls::Ptr) -> tls::Ptr {",
          "323:             let old_prev = self.prev.get();",
          "331:             if let Some(old_prev) = old_prev.as_ref() {",
          "335:             }",
          "337:             self.prev.set(prev);",
          "339:             let mut old_last_wasm_exit_fp = 0;",
          "340:             let mut old_last_wasm_exit_pc = 0;",
          "341:             let mut old_last_wasm_entry_sp = 0;",
          "342:             if let Some(prev) = prev.as_ref() {",
          "381:                 old_last_wasm_exit_fp =",
          "382:                     mem::replace(&mut *(*prev.limits).last_wasm_exit_fp.get(), 0);",
          "383:                 old_last_wasm_exit_pc =",
          "384:                     mem::replace(&mut *(*prev.limits).last_wasm_exit_pc.get(), 0);",
          "385:                 old_last_wasm_entry_sp =",
          "386:                     mem::replace(&mut *(*prev.limits).last_wasm_entry_sp.get(), 0);",
          "387:             }",
          "389:             self.old_last_wasm_exit_fp.set(old_last_wasm_exit_fp);",
          "390:             self.old_last_wasm_exit_pc.set(old_last_wasm_exit_pc);",
          "391:             self.old_last_wasm_entry_sp.set(old_last_wasm_entry_sp);",
          "393:             old_prev",
          "",
          "[Added Lines]",
          "327:         pub(crate) unsafe fn push(&self) {",
          "328:             assert!(self.prev.get().is_null());",
          "329:             self.prev.set(tls::raw::replace(self));",
          "330:         }",
          "332:         pub(crate) unsafe fn pop(&self) {",
          "333:             let prev = self.prev.replace(ptr::null());",
          "334:             let head = tls::raw::replace(prev);",
          "335:             assert!(std::ptr::eq(head, self));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "433:                 needs_backtrace: false,",
          "434:                 ..",
          "435:             }) => None,",
          "437:         };",
          "438:         unsafe {",
          "439:             (*self.unwind.get()).as_mut_ptr().write((reason, backtrace));",
          "",
          "[Removed Lines]",
          "436:             UnwindReason::Trap(_) => self.capture_backtrace(None),",
          "",
          "[Added Lines]",
          "378:             UnwindReason::Trap(_) => self.capture_backtrace(self.limits, None),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "487:     }",
          "489:     fn set_jit_trap(&self, pc: *const u8, fp: usize, faulting_addr: Option<usize>) {",
          "491:         unsafe {",
          "492:             (*self.unwind.get()).as_mut_ptr().write((",
          "493:                 UnwindReason::Trap(TrapReason::Jit {",
          "",
          "[Removed Lines]",
          "490:         let backtrace = self.capture_backtrace(Some((pc as usize, fp)));",
          "",
          "[Added Lines]",
          "432:         let backtrace = self.capture_backtrace(self.limits, Some((pc as usize, fp)));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "499:         }",
          "500:     }",
          "503:         if !self.capture_backtrace {",
          "504:             return None;",
          "505:         }",
          "508:     }",
          "510:     pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = &Self> + 'a {",
          "",
          "[Removed Lines]",
          "502:     fn capture_backtrace(&self, pc_and_fp: Option<(usize, usize)>) -> Option<Backtrace> {",
          "507:         Some(unsafe { Backtrace::new_with_trap_state(self, pc_and_fp) })",
          "",
          "[Added Lines]",
          "444:     fn capture_backtrace(",
          "445:         &self,",
          "446:         limits: *const VMRuntimeLimits,",
          "447:         trap_pc_and_fp: Option<(usize, usize)>,",
          "448:     ) -> Option<Backtrace> {",
          "453:         Some(unsafe { Backtrace::new_with_trap_state(limits, self, trap_pc_and_fp) })",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "534: mod tls {",
          "535:     use super::CallThreadState;",
          "538:     pub use raw::Ptr;",
          "",
          "[Removed Lines]",
          "536:     use std::ptr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "555:         use super::CallThreadState;",
          "556:         use std::cell::Cell;",
          "557:         use std::ptr;",
          "",
          "[Removed Lines]",
          "554:     mod raw {",
          "",
          "[Added Lines]",
          "499:     pub(super) mod raw {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "626:             let state = raw::get();",
          "627:             if let Some(state) = state.as_ref() {",
          "630:             } else {",
          "",
          "[Removed Lines]",
          "628:                 let prev_state = state.set_prev(ptr::null());",
          "629:                 raw::replace(prev_state);",
          "",
          "[Added Lines]",
          "573:                 state.pop();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "642:         pub unsafe fn replace(self) {",
          "647:             }",
          "655:         }",
          "656:     }",
          "",
          "[Removed Lines]",
          "645:             if self.state.is_null() {",
          "646:                 return;",
          "651:             let prev = raw::get();",
          "652:             assert!((*self.state).prev().is_null());",
          "653:             (*self.state).set_prev(prev);",
          "654:             raw::replace(self.state);",
          "",
          "[Added Lines]",
          "587:             if let Some(state) = self.state.as_ref() {",
          "588:                 state.push();",
          "589:             } else {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "668:             #[inline]",
          "669:             fn drop(&mut self) {",
          "670:                 unsafe {",
          "674:                 }",
          "675:             }",
          "676:         }",
          "680:         unsafe {",
          "683:             let reset = Reset { state };",
          "684:             closure(reset.state)",
          "685:         }",
          "",
          "[Removed Lines]",
          "671:                     let prev = self.state.set_prev(ptr::null());",
          "672:                     let old_state = raw::replace(prev);",
          "673:                     debug_assert!(std::ptr::eq(old_state, self.state));",
          "678:         let prev = raw::replace(state);",
          "681:             state.set_prev(prev);",
          "",
          "[Added Lines]",
          "609:                     self.state.pop();",
          "615:             state.push();",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers/backtrace.rs||crates/runtime/src/traphandlers/backtrace.rs": [
          "File: crates/runtime/src/traphandlers/backtrace.rs -> crates/runtime/src/traphandlers/backtrace.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: use cfg_if::cfg_if;",
          "25: use std::ops::ControlFlow;",
          "",
          "[Removed Lines]",
          "23: use crate::traphandlers::{tls, CallThreadState};",
          "",
          "[Added Lines]",
          "23: use crate::{",
          "24:     traphandlers::{tls, CallThreadState},",
          "25:     VMRuntimeLimits,",
          "26: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     }",
          "84:         tls::with(|state| match state {",
          "86:             None => Backtrace(vec![]),",
          "87:         })",
          "88:     }",
          "",
          "[Removed Lines]",
          "83:     pub fn new() -> Backtrace {",
          "85:             Some(state) => unsafe { Self::new_with_trap_state(state, None) },",
          "",
          "[Added Lines]",
          "86:     pub fn new(limits: *const VMRuntimeLimits) -> Backtrace {",
          "88:             Some(state) => unsafe { Self::new_with_trap_state(limits, state, None) },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:     pub(crate) unsafe fn new_with_trap_state(",
          "96:         state: &CallThreadState,",
          "97:         trap_pc_and_fp: Option<(usize, usize)>,",
          "98:     ) -> Backtrace {",
          "99:         let mut frames = vec![];",
          "101:             frames.push(frame);",
          "102:             ControlFlow::Continue(())",
          "103:         });",
          "",
          "[Removed Lines]",
          "100:         Self::trace_with_trap_state(state, trap_pc_and_fp, |frame| {",
          "",
          "[Added Lines]",
          "99:         limits: *const VMRuntimeLimits,",
          "104:         Self::trace_with_trap_state(limits, state, trap_pc_and_fp, |frame| {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "105:     }",
          "109:         tls::with(|state| match state {",
          "111:             None => {}",
          "112:         });",
          "113:     }",
          "",
          "[Removed Lines]",
          "108:     pub fn trace(f: impl FnMut(Frame) -> ControlFlow<()>) {",
          "110:             Some(state) => unsafe { Self::trace_with_trap_state(state, None, f) },",
          "",
          "[Added Lines]",
          "112:     pub fn trace(limits: *const VMRuntimeLimits, f: impl FnMut(Frame) -> ControlFlow<()>) {",
          "114:             Some(state) => unsafe { Self::trace_with_trap_state(limits, state, None, f) },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "120:     pub(crate) unsafe fn trace_with_trap_state(",
          "121:         state: &CallThreadState,",
          "122:         trap_pc_and_fp: Option<(usize, usize)>,",
          "123:         mut f: impl FnMut(Frame) -> ControlFlow<()>,",
          "124:     ) {",
          "125:         log::trace!(\"====== Capturing Backtrace ======\");",
          "126:         let (last_wasm_exit_pc, last_wasm_exit_fp) = match trap_pc_and_fp {",
          "133:             None => {",
          "144:                 (pc, fp)",
          "145:             }",
          "146:         };",
          "151:             last_wasm_exit_pc,",
          "152:             last_wasm_exit_fp,",
          "189:             }",
          "198:                 return;",
          "199:             }",
          "200:         }",
          "203:     }",
          "",
          "[Removed Lines]",
          "130:             Some((pc, fp)) => (pc, fp),",
          "134:                 let pc = *(*state.limits).last_wasm_exit_pc.get();",
          "135:                 let fp = *(*state.limits).last_wasm_exit_fp.get();",
          "137:                 if pc == 0 {",
          "140:                     assert_eq!(fp, 0);",
          "141:                     return;",
          "142:                 }",
          "150:         if let ControlFlow::Break(()) = Self::trace_through_wasm(",
          "154:             &mut f,",
          "155:         ) {",
          "156:             log::trace!(\"====== Done Capturing Backtrace ======\");",
          "157:             return;",
          "158:         }",
          "162:         for state in state.iter() {",
          "167:             if state.prev().is_null() {",
          "168:                 debug_assert_eq!(state.old_last_wasm_exit_pc(), 0);",
          "169:                 debug_assert_eq!(state.old_last_wasm_exit_fp(), 0);",
          "170:                 debug_assert_eq!(state.old_last_wasm_entry_sp(), 0);",
          "171:                 log::trace!(\"====== Done Capturing Backtrace ======\");",
          "172:                 return;",
          "173:             }",
          "185:             if state.old_last_wasm_entry_sp() == 0 {",
          "186:                 debug_assert_eq!(state.old_last_wasm_exit_fp(), 0);",
          "187:                 debug_assert_eq!(state.old_last_wasm_exit_pc(), 0);",
          "188:                 continue;",
          "191:             if let ControlFlow::Break(()) = Self::trace_through_wasm(",
          "192:                 state.old_last_wasm_exit_pc(),",
          "193:                 state.old_last_wasm_exit_fp(),",
          "194:                 state.old_last_wasm_entry_sp(),",
          "195:                 &mut f,",
          "196:             ) {",
          "197:                 log::trace!(\"====== Done Capturing Backtrace ======\");",
          "202:         unreachable!()",
          "",
          "[Added Lines]",
          "125:         limits: *const VMRuntimeLimits,",
          "136:             Some((pc, fp)) => {",
          "137:                 assert!(std::ptr::eq(limits, state.limits));",
          "138:                 (pc, fp)",
          "139:             }",
          "143:                 let pc = *(*limits).last_wasm_exit_pc.get();",
          "144:                 let fp = *(*limits).last_wasm_exit_fp.get();",
          "149:         let activations = std::iter::once((",
          "153:         ))",
          "154:         .chain(",
          "155:             state",
          "156:                 .iter()",
          "157:                 .filter(|state| std::ptr::eq(limits, state.limits))",
          "158:                 .map(|state| {",
          "159:                     (",
          "160:                         state.old_last_wasm_exit_pc(),",
          "161:                         state.old_last_wasm_exit_fp(),",
          "162:                         state.old_last_wasm_entry_sp(),",
          "163:                     )",
          "164:                 }),",
          "165:         )",
          "166:         .take_while(|&(pc, fp, sp)| {",
          "167:             if pc == 0 {",
          "168:                 debug_assert_eq!(fp, 0);",
          "169:                 debug_assert_eq!(sp, 0);",
          "171:             pc != 0",
          "172:         });",
          "174:         for (pc, fp, sp) in activations {",
          "175:             if let ControlFlow::Break(()) = Self::trace_through_wasm(pc, fp, sp, &mut f) {",
          "176:                 log::trace!(\"====== Done Capturing Backtrace (closure break) ======\");",
          "181:         log::trace!(\"====== Done Capturing Backtrace (reached end of activations) ======\");",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/profiling.rs||crates/wasmtime/src/profiling.rs": [
          "File: crates/wasmtime/src/profiling.rs -> crates/wasmtime/src/profiling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use anyhow::Result;",
          "2: use fxprof_processed_profile::debugid::DebugId;",
          "3: use fxprof_processed_profile::{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::{AsContext, Module};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10: use wasmtime_jit::CompiledModule;",
          "11: use wasmtime_runtime::Backtrace;",
          "",
          "[Removed Lines]",
          "13: use crate::Module;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "133:         let now = Timestamp::from_nanos_since_reference(",
          "134:             self.start.elapsed().as_nanos().try_into().unwrap(),",
          "135:         );",
          "138:         let frames = backtrace",
          "139:             .frames()",
          "",
          "[Removed Lines]",
          "132:     pub fn sample(&mut self) {",
          "137:         let backtrace = Backtrace::new();",
          "",
          "[Added Lines]",
          "131:     pub fn sample(&mut self, store: impl AsContext) {",
          "136:         let backtrace = Backtrace::new(store.as_context().0.vmruntime_limits());",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs": [
          "File: crates/wasmtime/src/store.rs -> crates/wasmtime/src/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1228:     pub fn gc(&mut self) {",
          "1232:     }",
          "",
          "[Removed Lines]",
          "1231:         unsafe { wasmtime_runtime::gc(&self.modules, &mut self.externref_activations_table) }",
          "",
          "[Added Lines]",
          "1231:         unsafe {",
          "1232:             wasmtime_runtime::gc(",
          "1233:                 self.runtime_limits(),",
          "1234:                 &self.modules,",
          "1235:                 &mut self.externref_activations_table,",
          "1236:             )",
          "1237:         }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs": [
          "File: crates/wasmtime/src/trap.rs -> crates/wasmtime/src/trap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "264:     pub fn force_capture(store: impl AsContext) -> WasmBacktrace {",
          "265:         let store = store.as_context();",
          "267:     }",
          "269:     fn from_captured(",
          "",
          "[Removed Lines]",
          "266:         Self::from_captured(store.0, wasmtime_runtime::Backtrace::new(), None)",
          "",
          "[Added Lines]",
          "266:         Self::from_captured(",
          "267:             store.0,",
          "268:             wasmtime_runtime::Backtrace::new(store.0.runtime_limits()),",
          "269:             None,",
          "270:         )",
          "",
          "---------------"
        ],
        "src/commands/run.rs||src/commands/run.rs": [
          "File: src/commands/run.rs -> src/commands/run.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: use std::thread;",
          "11: use std::time::Duration;",
          "12: use wasmtime::{",
          "15: };",
          "16: use wasmtime_cli_flags::{CommonOptions, WasiModules};",
          "17: use wasmtime_wasi::maybe_exit_on_error;",
          "",
          "[Removed Lines]",
          "13:     Engine, Func, GuestProfiler, Linker, Module, Store, StoreLimits, StoreLimitsBuilder, Val,",
          "14:     ValType,",
          "",
          "[Added Lines]",
          "13:     AsContextMut, Engine, Func, GuestProfiler, Linker, Module, Store, StoreLimits,",
          "14:     StoreLimitsBuilder, Val, ValType,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "403:             store.data_mut().guest_profiler =",
          "404:                 Some(Arc::new(GuestProfiler::new(module_name, interval, modules)));",
          "406:             if let Some(timeout) = self.wasm_timeout {",
          "407:                 let mut timeout = (timeout.as_secs_f64() / interval.as_secs_f64()).ceil() as u64;",
          "408:                 assert!(timeout > 0);",
          "409:                 store.epoch_deadline_callback(move |mut store| {",
          "413:                     timeout -= 1;",
          "414:                     if timeout == 0 {",
          "415:                         bail!(\"timeout exceeded\");",
          "",
          "[Removed Lines]",
          "410:                     Arc::get_mut(store.data_mut().guest_profiler.as_mut().unwrap())",
          "411:                         .expect(\"profiling doesn't support threads yet\")",
          "412:                         .sample();",
          "",
          "[Added Lines]",
          "406:             fn sample(mut store: impl AsContextMut<Data = Host>) {",
          "407:                 let mut profiler = store",
          "408:                     .as_context_mut()",
          "409:                     .data_mut()",
          "410:                     .guest_profiler",
          "411:                     .take()",
          "412:                     .unwrap();",
          "413:                 Arc::get_mut(&mut profiler)",
          "414:                     .expect(\"profiling doesn't support threads yet\")",
          "415:                     .sample(&store);",
          "416:                 store.as_context_mut().data_mut().guest_profiler = Some(profiler);",
          "417:             }",
          "423:                     sample(&mut store);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "418:                 });",
          "419:             } else {",
          "420:                 store.epoch_deadline_callback(move |mut store| {",
          "424:                     Ok(1)",
          "425:                 });",
          "426:             }",
          "",
          "[Removed Lines]",
          "421:                     Arc::get_mut(store.data_mut().guest_profiler.as_mut().unwrap())",
          "422:                         .expect(\"profiling doesn't support threads yet\")",
          "423:                         .sample();",
          "",
          "[Added Lines]",
          "432:                     sample(&mut store);",
          "",
          "---------------"
        ],
        "tests/all/async_functions.rs||tests/all/async_functions.rs": [
          "File: tests/all/async_functions.rs -> tests/all/async_functions.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use anyhow::{anyhow, bail, Result};",
          "2: use std::future::Future;",
          "3: use std::pin::Pin;",
          "4: use std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};",
          "5: use wasmtime::*;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: use std::sync::{Arc, Mutex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "706:     const RAW: RawWaker = RawWaker::new(0 as *const (), &VTABLE);",
          "707:     unsafe { Waker::from_raw(RAW) }",
          "708: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "711: #[tokio::test]",
          "712: async fn non_stacky_async_activations() -> Result<()> {",
          "713:     let mut config = Config::new();",
          "714:     config.async_support(true);",
          "715:     let engine = Engine::new(&config)?;",
          "716:     let mut store1: Store<Option<Pin<Box<dyn Future<Output = Result<()>> + Send>>>> =",
          "717:         Store::new(&engine, None);",
          "718:     let mut linker1 = Linker::new(&engine);",
          "720:     let module1 = Module::new(",
          "721:         &engine,",
          "722:         r#\"",
          "723:             (module $m1",
          "724:                 (import \"\" \"host_capture_stack\" (func $host_capture_stack))",
          "725:                 (import \"\" \"start_async_instance\" (func $start_async_instance))",
          "726:                 (func $capture_stack (export \"capture_stack\")",
          "727:                     call $host_capture_stack",
          "728:                 )",
          "729:                 (func $run_sync (export \"run_sync\")",
          "730:                     call $start_async_instance",
          "731:                 )",
          "732:             )",
          "733:         \"#,",
          "734:     )?;",
          "736:     let module2 = Module::new(",
          "737:         &engine,",
          "738:         r#\"",
          "739:             (module $m2",
          "740:                 (import \"\" \"yield\" (func $yield))",
          "742:                 (func $run_async (export \"run_async\")",
          "743:                     call $yield",
          "744:                 )",
          "745:             )",
          "746:         \"#,",
          "747:     )?;",
          "749:     let stacks = Arc::new(Mutex::new(vec![]));",
          "750:     fn capture_stack(stacks: &Arc<Mutex<Vec<WasmBacktrace>>>, store: impl AsContext) {",
          "751:         let mut stacks = stacks.lock().unwrap();",
          "752:         stacks.push(wasmtime::WasmBacktrace::force_capture(store));",
          "753:     }",
          "755:     linker1.func_wrap0_async(\"\", \"host_capture_stack\", {",
          "756:         let stacks = stacks.clone();",
          "757:         move |caller| {",
          "758:             capture_stack(&stacks, &caller);",
          "759:             Box::new(async { Ok(()) })",
          "760:         }",
          "761:     })?;",
          "763:     linker1.func_wrap0_async(\"\", \"start_async_instance\", {",
          "764:         let stacks = stacks.clone();",
          "765:         move |mut caller| {",
          "766:             let stacks = stacks.clone();",
          "767:             capture_stack(&stacks, &caller);",
          "769:             let module2 = module2.clone();",
          "770:             let mut store2 = Store::new(caller.engine(), ());",
          "771:             let mut linker2 = Linker::new(caller.engine());",
          "772:             linker2",
          "773:                 .func_wrap0_async(\"\", \"yield\", {",
          "774:                     let stacks = stacks.clone();",
          "775:                     move |caller| {",
          "776:                         let stacks = stacks.clone();",
          "777:                         Box::new(async move {",
          "778:                             capture_stack(&stacks, &caller);",
          "779:                             tokio::task::yield_now().await;",
          "780:                             capture_stack(&stacks, &caller);",
          "781:                             Ok(())",
          "782:                         })",
          "783:                     }",
          "784:                 })",
          "785:                 .unwrap();",
          "787:             Box::new(async move {",
          "788:                 let future = PollOnce::new(Box::pin({",
          "789:                     let stacks = stacks.clone();",
          "790:                     async move {",
          "791:                         let instance2 = linker2.instantiate_async(&mut store2, &module2).await?;",
          "793:                         instance2",
          "794:                             .get_func(&mut store2, \"run_async\")",
          "795:                             .unwrap()",
          "796:                             .call_async(&mut store2, &[], &mut [])",
          "797:                             .await?;",
          "799:                         capture_stack(&stacks, &store2);",
          "800:                         Ok(())",
          "801:                     }",
          "802:                 }) as _)",
          "803:                 .await;",
          "804:                 capture_stack(&stacks, &caller);",
          "806:                 Ok(())",
          "807:             })",
          "808:         }",
          "809:     })?;",
          "811:     let instance1 = linker1.instantiate_async(&mut store1, &module1).await?;",
          "812:     instance1",
          "813:         .get_typed_func::<(), ()>(&mut store1, \"run_sync\")?",
          "814:         .call_async(&mut store1, ())",
          "815:         .await?;",
          "816:     let future = store1.data_mut().take().unwrap();",
          "817:     future.await?;",
          "819:     instance1",
          "820:         .get_typed_func::<(), ()>(&mut store1, \"capture_stack\")?",
          "821:         .call_async(&mut store1, ())",
          "822:         .await?;",
          "824:     let stacks = stacks.lock().unwrap();",
          "825:     eprintln!(\"stacks = {stacks:#?}\");",
          "827:     assert_eq!(stacks.len(), 6);",
          "828:     for (actual, expected) in stacks.iter().zip(vec![",
          "829:         vec![\"run_sync\"],",
          "830:         vec![\"run_async\"],",
          "831:         vec![\"run_sync\"],",
          "832:         vec![\"run_async\"],",
          "833:         vec![],",
          "834:         vec![\"capture_stack\"],",
          "835:     ]) {",
          "836:         eprintln!(\"expected = {expected:?}\");",
          "837:         eprintln!(\"actual = {actual:?}\");",
          "838:         assert_eq!(actual.frames().len(), expected.len());",
          "839:         for (actual, expected) in actual.frames().iter().zip(expected) {",
          "840:             assert_eq!(actual.func_name(), Some(expected));",
          "841:         }",
          "842:     }",
          "844:     Ok(())",
          "845: }",
          "",
          "---------------"
        ],
        "tests/all/traps.rs||tests/all/traps.rs": [
          "File: tests/all/traps.rs -> tests/all/traps.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use anyhow::{bail, Error, Result};",
          "2: use std::panic::{self, AssertUnwindSafe};",
          "3: use std::process::Command;",
          "4: use wasmtime::*;",
          "6: #[test]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: use std::sync::{Arc, Mutex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1469:     Ok(())",
          "1470: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1473: #[test]",
          "1474: fn dont_see_stale_stack_walking_registers() -> Result<()> {",
          "1475:     let engine = Engine::default();",
          "1477:     let module = Module::new(",
          "1478:         &engine,",
          "1479:         r#\"",
          "1480:             (module",
          "1481:                 (import \"\" \"host_start\" (func $host_start))",
          "1482:                 (import \"\" \"host_get_trap\" (func $host_get_trap))",
          "1483:                 (export \"get_trap\" (func $host_get_trap))",
          "1485:                 ;; We enter and exit Wasm, which saves registers in the",
          "1486:                 ;; `VMRuntimeLimits`. Later, when we call a re-exported host",
          "1487:                 ;; function, we should not accidentally reuse those saved",
          "1488:                 ;; registers.",
          "1489:                 (start $start)",
          "1490:                 (func $start",
          "1491:                     (call $host_start)",
          "1492:                 )",
          "1493:             )",
          "1494:         \"#,",
          "1495:     )?;",
          "1497:     let mut store = Store::new(&engine, ());",
          "1498:     let mut linker = Linker::new(&engine);",
          "1500:     let host_start = Func::new(",
          "1501:         &mut store,",
          "1502:         FuncType::new([], []),",
          "1503:         |_caller, _args, _results| Ok(()),",
          "1504:     );",
          "1505:     linker.define(&store, \"\", \"host_start\", host_start)?;",
          "1507:     let host_get_trap = Func::new(",
          "1508:         &mut store,",
          "1509:         FuncType::new([], []),",
          "1510:         |_caller, _args, _results| Err(anyhow::anyhow!(\"trap!!!\")),",
          "1511:     );",
          "1512:     linker.define(&store, \"\", \"host_get_trap\", host_get_trap)?;",
          "1514:     let instance = linker.instantiate(&mut store, &module)?;",
          "1515:     let get_trap = instance.get_func(&mut store, \"get_trap\").unwrap();",
          "1517:     let err = get_trap.call(&mut store, &[], &mut []).unwrap_err();",
          "1518:     assert!(err.to_string().contains(\"trap!!!\"));",
          "1520:     Ok(())",
          "1521: }",
          "1523: #[test]",
          "1524: fn same_module_multiple_stores() -> Result<()> {",
          "1525:     let _ = env_logger::try_init();",
          "1527:     let engine = Engine::default();",
          "1529:     let module = Module::new(",
          "1530:         &engine,",
          "1531:         r#\"",
          "1532:             (module",
          "1533:                 (import \"\" \"f\" (func $f))",
          "1534:                 (import \"\" \"call_ref\" (func $call_ref (param funcref)))",
          "1535:                 (global $g (mut i32) (i32.const 0))",
          "1536:                 (func $a (export \"a\")",
          "1537:                     call $b",
          "1538:                 )",
          "1539:                 (func $b",
          "1540:                     call $c",
          "1541:                 )",
          "1542:                 (func $c",
          "1543:                     global.get $g",
          "1544:                     if",
          "1545:                         call $f",
          "1546:                     else",
          "1547:                         i32.const 1",
          "1548:                         global.set $g",
          "1549:                         ref.func $a",
          "1550:                         call $call_ref",
          "1551:                     end",
          "1552:                 )",
          "1553:             )",
          "1554:         \"#,",
          "1555:     )?;",
          "1557:     let stacks = Arc::new(Mutex::new(vec![]));",
          "1559:     let mut store3 = Store::new(&engine, ());",
          "1560:     let f3 = Func::new(&mut store3, FuncType::new([], []), {",
          "1561:         let stacks = stacks.clone();",
          "1562:         move |caller, _params, _results| {",
          "1563:             stacks",
          "1564:                 .lock()",
          "1565:                 .unwrap()",
          "1566:                 .push(WasmBacktrace::force_capture(caller));",
          "1567:             Ok(())",
          "1568:         }",
          "1569:     });",
          "1570:     let call_ref3 = Func::wrap(&mut store3, |caller: Caller<'_, _>, f: Option<Func>| {",
          "1571:         f.unwrap().call(caller, &[], &mut [])",
          "1572:     });",
          "1573:     let instance3 = Instance::new(&mut store3, &module, &[f3.into(), call_ref3.into()])?;",
          "1575:     let mut store2 = Store::new(&engine, store3);",
          "1576:     let f2 = Func::new(&mut store2, FuncType::new([], []), {",
          "1577:         let stacks = stacks.clone();",
          "1578:         move |mut caller, _params, _results| {",
          "1579:             stacks",
          "1580:                 .lock()",
          "1581:                 .unwrap()",
          "1582:                 .push(WasmBacktrace::force_capture(&mut caller));",
          "1583:             instance3",
          "1584:                 .get_typed_func::<(), ()>(caller.data_mut(), \"a\")",
          "1585:                 .unwrap()",
          "1586:                 .call(caller.data_mut(), ())",
          "1587:                 .unwrap();",
          "1588:             Ok(())",
          "1589:         }",
          "1590:     });",
          "1591:     let call_ref2 = Func::wrap(&mut store2, |caller: Caller<'_, _>, f: Option<Func>| {",
          "1592:         f.unwrap().call(caller, &[], &mut [])",
          "1593:     });",
          "1594:     let instance2 = Instance::new(&mut store2, &module, &[f2.into(), call_ref2.into()])?;",
          "1596:     let mut store1 = Store::new(&engine, store2);",
          "1597:     let f1 = Func::new(&mut store1, FuncType::new([], []), {",
          "1598:         let stacks = stacks.clone();",
          "1599:         move |mut caller, _params, _results| {",
          "1600:             stacks",
          "1601:                 .lock()",
          "1602:                 .unwrap()",
          "1603:                 .push(WasmBacktrace::force_capture(&mut caller));",
          "1604:             instance2",
          "1605:                 .get_typed_func::<(), ()>(caller.data_mut(), \"a\")",
          "1606:                 .unwrap()",
          "1607:                 .call(caller.data_mut(), ())",
          "1608:                 .unwrap();",
          "1609:             Ok(())",
          "1610:         }",
          "1611:     });",
          "1612:     let call_ref1 = Func::wrap(&mut store1, |caller: Caller<'_, _>, f: Option<Func>| {",
          "1613:         f.unwrap().call(caller, &[], &mut [])",
          "1614:     });",
          "1615:     let instance1 = Instance::new(&mut store1, &module, &[f1.into(), call_ref1.into()])?;",
          "1617:     instance1",
          "1618:         .get_typed_func(&mut store1, \"a\")?",
          "1619:         .call(&mut store1, ())?;",
          "1621:     let expected_stacks = vec![",
          "1623:         vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],",
          "1625:         vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],",
          "1627:         vec![\"c\", \"b\", \"a\", \"c\", \"b\", \"a\"],",
          "1628:     ];",
          "1629:     eprintln!(\"expected = {expected_stacks:#?}\");",
          "1630:     let actual_stacks = stacks.lock().unwrap();",
          "1631:     eprintln!(\"actaul = {actual_stacks:#?}\");",
          "1633:     assert_eq!(actual_stacks.len(), expected_stacks.len());",
          "1634:     for (expected_stack, actual_stack) in expected_stacks.into_iter().zip(actual_stacks.iter()) {",
          "1635:         assert_eq!(expected_stack.len(), actual_stack.frames().len());",
          "1636:         for (expected_frame, actual_frame) in expected_stack.into_iter().zip(actual_stack.frames())",
          "1637:         {",
          "1638:             assert_eq!(actual_frame.func_name(), Some(expected_frame));",
          "1639:         }",
          "1640:     }",
          "1642:     Ok(())",
          "1643: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bffce37050abb22e3f07583a9a695ac790236f91",
      "candidate_info": {
        "commit_hash": "bffce37050abb22e3f07583a9a695ac790236f91",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/bffce37050abb22e3f07583a9a695ac790236f91",
        "files": [
          ".github/workflows/main.yml",
          "Cargo.lock",
          "Cargo.toml",
          "crates/c-api/Cargo.toml",
          "crates/c-api/src/trap.rs",
          "crates/cli-flags/Cargo.toml",
          "crates/cli-flags/src/lib.rs",
          "crates/fuzzing/src/generators.rs",
          "crates/runtime/Cargo.toml",
          "crates/runtime/src/externref.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs",
          "crates/wasmtime/Cargo.toml",
          "crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/func.rs",
          "crates/wasmtime/src/lib.rs",
          "crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trap.rs",
          "tests/all/traps.rs"
        ],
        "message": "make backtrace collection a Config field rather than a cargo feature (#4183)\n\n* sorta working in runtime\n\n* wasmtime-runtime: get rid of wasm-backtrace feature\n\n* wasmtime: factor to make backtraces recording optional. not configurable yet\n\n* get rid of wasm-backtrace features\n\n* trap tests: now a Trap optionally contains backtrace\n\n* eliminate wasm-backtrace feature\n\n* code review fixes\n\n* ci: no more wasm-backtrace feature\n\n* c_api: backtraces always enabled\n\n* config: unwind required by backtraces and ref types\n\n* plumbed\n\n* test that disabling backtraces works\n\n* code review comments\n\n* fuzzing generator: wasm_backtrace is a runtime config now\n\n* doc fix",
        "before_after_code_files": [
          "Cargo.lock||Cargo.lock",
          "crates/c-api/src/trap.rs||crates/c-api/src/trap.rs",
          "crates/cli-flags/src/lib.rs||crates/cli-flags/src/lib.rs",
          "crates/fuzzing/src/generators.rs||crates/fuzzing/src/generators.rs",
          "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs",
          "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/func.rs||crates/wasmtime/src/func.rs",
          "crates/wasmtime/src/lib.rs||crates/wasmtime/src/lib.rs",
          "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs",
          "tests/all/traps.rs||tests/all/traps.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "Cargo.lock||Cargo.lock": [
          "File: Cargo.lock -> Cargo.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "1872: [[package]]",
          "1873: name = \"once_cell\"",
          "1875: source = \"registry+https://github.com/rust-lang/crates.io-index\"",
          "1878: [[package]]",
          "1879: name = \"oorandom\"",
          "",
          "[Removed Lines]",
          "1874: version = \"1.10.0\"",
          "1876: checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"",
          "",
          "[Added Lines]",
          "1874: version = \"1.12.0\"",
          "1876: checksum = \"7709cef83f0c1f58f666e746a08b21e0085f7440fa6a29cc194d68aac97a4225\"",
          "",
          "---------------"
        ],
        "crates/c-api/src/trap.rs||crates/c-api/src/trap.rs": [
          "File: crates/c-api/src/trap.rs -> crates/c-api/src/trap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: #[no_mangle]",
          "66: pub extern \"C\" fn wasm_trap_origin(raw: &wasm_trap_t) -> Option<Box<wasm_frame_t>> {",
          "68:         Some(Box::new(wasm_frame_t {",
          "69:             trap: raw.trap.clone(),",
          "70:             idx: 0,",
          "",
          "[Removed Lines]",
          "67:     if raw.trap.trace().len() > 0 {",
          "",
          "[Added Lines]",
          "67:     if raw",
          "68:         .trap",
          "69:         .trace()",
          "70:         .expect(\"backtraces are always enabled\")",
          "71:         .len()",
          "72:         > 0",
          "73:     {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79: #[no_mangle]",
          "80: pub extern \"C\" fn wasm_trap_trace(raw: &wasm_trap_t, out: &mut wasm_frame_vec_t) {",
          "82:         .map(|idx| {",
          "83:             Some(Box::new(wasm_frame_t {",
          "84:                 trap: raw.trap.clone(),",
          "",
          "[Removed Lines]",
          "81:     let vec = (0..raw.trap.trace().len())",
          "",
          "[Added Lines]",
          "87:     let vec = (0..raw",
          "88:         .trap",
          "89:         .trace()",
          "90:         .expect(\"backtraces are always enabled\")",
          "91:         .len())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "129: #[no_mangle]",
          "130: pub extern \"C\" fn wasm_frame_func_index(frame: &wasm_frame_t) -> u32 {",
          "132: }",
          "134: #[no_mangle]",
          "",
          "[Removed Lines]",
          "131:     frame.trap.trace()[frame.idx].func_index()",
          "",
          "[Added Lines]",
          "141:     frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx].func_index()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:     frame",
          "137:         .func_name",
          "138:         .get_or_init(|| {",
          "140:                 .func_name()",
          "141:                 .map(|s| wasm_name_t::from(s.to_string().into_bytes()))",
          "142:         })",
          "",
          "[Removed Lines]",
          "139:             frame.trap.trace()[frame.idx]",
          "",
          "[Added Lines]",
          "149:             frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "148:     frame",
          "149:         .module_name",
          "150:         .get_or_init(|| {",
          "152:                 .module_name()",
          "153:                 .map(|s| wasm_name_t::from(s.to_string().into_bytes()))",
          "154:         })",
          "",
          "[Removed Lines]",
          "151:             frame.trap.trace()[frame.idx]",
          "",
          "[Added Lines]",
          "161:             frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "158: #[no_mangle]",
          "159: pub extern \"C\" fn wasm_frame_func_offset(frame: &wasm_frame_t) -> usize {",
          "161:         .func_offset()",
          "162:         .unwrap_or(usize::MAX)",
          "163: }",
          "",
          "[Removed Lines]",
          "160:     frame.trap.trace()[frame.idx]",
          "",
          "[Added Lines]",
          "170:     frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "170: #[no_mangle]",
          "171: pub extern \"C\" fn wasm_frame_module_offset(frame: &wasm_frame_t) -> usize {",
          "173:         .module_offset()",
          "174:         .unwrap_or(usize::MAX)",
          "175: }",
          "",
          "[Removed Lines]",
          "172:     frame.trap.trace()[frame.idx]",
          "",
          "[Added Lines]",
          "182:     frame.trap.trace().expect(\"backtraces are always enabled\")[frame.idx]",
          "",
          "---------------"
        ],
        "crates/cli-flags/src/lib.rs||crates/cli-flags/src/lib.rs": [
          "File: crates/cli-flags/src/lib.rs -> crates/cli-flags/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "346:             config.wasm_bulk_memory(enable);",
          "347:         }",
          "348:         if let Some(enable) = reference_types {",
          "350:             config.wasm_reference_types(enable);",
          "352:         }",
          "353:         if let Some(enable) = multi_value {",
          "354:             config.wasm_multi_value(enable);",
          "",
          "[Removed Lines]",
          "349:             #[cfg(feature = \"wasm-backtrace\")]",
          "351:             drop(enable); // suppress unused warnings",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/fuzzing/src/generators.rs||crates/fuzzing/src/generators.rs": [
          "File: crates/fuzzing/src/generators.rs -> crates/fuzzing/src/generators.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "213:     codegen: CodegenSettings,",
          "214:     padding_between_functions: Option<u16>,",
          "215:     generate_address_map: bool,",
          "216: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:     wasm_backtraces: bool,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:             .wasm_multi_memory(self.module_config.config.max_memories > 1)",
          "388:             .wasm_simd(self.module_config.config.simd_enabled)",
          "389:             .wasm_memory64(self.module_config.config.memory64_enabled)",
          "390:             .cranelift_nan_canonicalization(self.wasmtime.canonicalize_nans)",
          "391:             .cranelift_opt_level(self.wasmtime.opt_level.to_wasmtime())",
          "392:             .consume_fuel(self.wasmtime.consume_fuel)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391:             .wasm_backtrace(self.wasmtime.wasm_backtraces)",
          "",
          "---------------"
        ],
        "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs": [
          "File: crates/runtime/src/externref.rs -> crates/runtime/src/externref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "704:         }",
          "705:     }",
          "708:     fn insert_precise_stack_root(",
          "709:         precise_stack_roots: &mut HashSet<VMExternRefWithTraits>,",
          "710:         root: NonNull<VMExternData>,",
          "",
          "[Removed Lines]",
          "707:     #[cfg_attr(not(feature = \"wasm-backtrace\"), allow(dead_code))]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "871: pub unsafe fn gc(",
          "872:     module_info_lookup: &dyn ModuleInfoLookup,",
          "873:     externref_activations_table: &mut VMExternRefActivationsTable,",
          "",
          "[Removed Lines]",
          "870: #[cfg_attr(not(feature = \"wasm-backtrace\"), allow(unused_mut, unused_variables))]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "895:         None => {",
          "896:             if cfg!(debug_assertions) {",
          "899:                 backtrace::trace(|frame| {",
          "900:                     assert!(module_info_lookup.lookup(frame.ip() as usize).is_none());",
          "901:                     true",
          "",
          "[Removed Lines]",
          "898:                 #[cfg(feature = \"wasm-backtrace\")]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "937:         });",
          "938:     }",
          "941:     backtrace::trace(|frame| {",
          "942:         let pc = frame.ip() as usize;",
          "943:         let sp = frame.sp() as usize;",
          "",
          "[Removed Lines]",
          "940:     #[cfg(feature = \"wasm-backtrace\")]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "508:         let addr_to_check = addr.checked_add(4).unwrap();",
          "509:         validate_atomic_addr(instance, memory, addr_to_check).and_then(|()| {",
          "511:                 \"unimplemented: wasm atomics (fn memory_atomic_notify) unsupported\",",
          "512:             )))",
          "513:         })",
          "",
          "[Removed Lines]",
          "510:             Err(Trap::User(anyhow::anyhow!(",
          "",
          "[Added Lines]",
          "510:             Err(Trap::user(anyhow::anyhow!(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "535:         let addr_to_check = addr.checked_add(4).unwrap();",
          "536:         validate_atomic_addr(instance, memory, addr_to_check).and_then(|()| {",
          "538:                 \"unimplemented: wasm atomics (fn memory_atomic_wait32) unsupported\",",
          "539:             )))",
          "540:         })",
          "",
          "[Removed Lines]",
          "537:             Err(Trap::User(anyhow::anyhow!(",
          "",
          "[Added Lines]",
          "537:             Err(Trap::user(anyhow::anyhow!(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "562:         let addr_to_check = addr.checked_add(8).unwrap();",
          "563:         validate_atomic_addr(instance, memory, addr_to_check).and_then(|()| {",
          "565:                 \"unimplemented: wasm atomics (fn memory_atomic_wait64) unsupported\",",
          "566:             )))",
          "567:         })",
          "",
          "[Removed Lines]",
          "564:             Err(Trap::User(anyhow::anyhow!(",
          "",
          "[Added Lines]",
          "564:             Err(Trap::user(anyhow::anyhow!(",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: use wasmtime_environ::TrapCode;",
          "13: pub use self::tls::{tls_eager_initialize, TlsRestore};",
          "15: #[link(name = \"wasmtime-helpers\")]",
          "16: extern \"C\" {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: pub use backtrace::Backtrace;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112: #[derive(Debug)]",
          "113: pub enum Trap {",
          "118:     Jit {",
          "120:         pc: usize,",
          "123:     },",
          "",
          "[Removed Lines]",
          "115:     User(Error),",
          "122:         backtrace: Backtrace,",
          "",
          "[Added Lines]",
          "116:     User {",
          "118:         error: Error,",
          "120:         backtrace: Option<Backtrace>,",
          "121:     },",
          "128:         backtrace: Option<Backtrace>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:         trap_code: TrapCode,",
          "131:     },",
          "134:     OOM {",
          "137:     },",
          "138: }",
          "140: impl Trap {",
          "144:     pub fn wasm(trap_code: TrapCode) -> Self {",
          "145:         Trap::Wasm {",
          "146:             trap_code,",
          "148:         }",
          "149:     }",
          "157:         }",
          "158:     }",
          "179:     }",
          "187:     }",
          "188: }",
          "",
          "[Removed Lines]",
          "130:         backtrace: Backtrace,",
          "136:         backtrace: Backtrace,",
          "147:             backtrace: Backtrace::new(),",
          "154:     pub fn oom() -> Self {",
          "155:         Trap::OOM {",
          "156:             backtrace: Backtrace::new(),",
          "159: }",
          "163: #[derive(Debug)]",
          "164: pub struct Backtrace {",
          "165:     #[cfg(feature = \"wasm-backtrace\")]",
          "166:     trace: backtrace::Backtrace,",
          "167: }",
          "169: impl Backtrace {",
          "174:     pub fn new() -> Backtrace {",
          "175:         Backtrace {",
          "176:             #[cfg(feature = \"wasm-backtrace\")]",
          "177:             trace: backtrace::Backtrace::new_unresolved(),",
          "178:         }",
          "184:     #[cfg(feature = \"wasm-backtrace\")]",
          "185:     pub fn frames(&self) -> &[backtrace::BacktraceFrame] {",
          "186:         self.trace.frames()",
          "",
          "[Added Lines]",
          "136:         backtrace: Option<Backtrace>,",
          "142:         backtrace: Option<Backtrace>,",
          "154:             backtrace: None,",
          "162:     pub fn user(error: Error) -> Self {",
          "163:         Trap::User {",
          "164:             error,",
          "165:             backtrace: None,",
          "172:     pub fn oom() -> Self {",
          "173:         Trap::OOM { backtrace: None }",
          "176:     fn insert_backtrace(&mut self, bt: Backtrace) {",
          "177:         match self {",
          "178:             Trap::User { backtrace, .. } => *backtrace = Some(bt),",
          "179:             Trap::Jit { backtrace, .. } => *backtrace = Some(bt),",
          "180:             Trap::Wasm { backtrace, .. } => *backtrace = Some(bt),",
          "181:             Trap::OOM { backtrace, .. } => *backtrace = Some(bt),",
          "182:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "194: pub unsafe fn catch_traps<'a, F>(",
          "195:     signal_handler: Option<*const SignalHandler<'static>>,",
          "196:     callee: *mut VMContext,",
          "197:     mut closure: F,",
          "198: ) -> Result<(), Box<Trap>>",
          "199: where",
          "200:     F: FnMut(*mut VMContext),",
          "201: {",
          "203:         wasmtime_setjmp(",
          "204:             cx.jmp_buf.as_ptr(),",
          "205:             call_closure::<F>,",
          "",
          "[Removed Lines]",
          "202:     return CallThreadState::new(signal_handler).with(|cx| {",
          "",
          "[Added Lines]",
          "192:     capture_backtrace: bool,",
          "199:     return CallThreadState::new(signal_handler, capture_backtrace).with(|cx| {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "221: pub struct CallThreadState {",
          "223:     jmp_buf: Cell<*const u8>,",
          "224:     handling_trap: Cell<bool>,",
          "225:     signal_handler: Option<*const SignalHandler<'static>>,",
          "226:     prev: Cell<tls::Ptr>,",
          "227: }",
          "229: enum UnwindReason {",
          "230:     Panic(Box<dyn Any + Send>),",
          "231:     UserTrap(Error),",
          "232:     LibTrap(Trap),",
          "234: }",
          "236: impl CallThreadState {",
          "237:     #[inline]",
          "239:         CallThreadState {",
          "240:             unwind: UnsafeCell::new(MaybeUninit::uninit()),",
          "241:             jmp_buf: Cell::new(ptr::null()),",
          "242:             handling_trap: Cell::new(false),",
          "243:             signal_handler,",
          "244:             prev: Cell::new(ptr::null()),",
          "245:         }",
          "246:     }",
          "",
          "[Removed Lines]",
          "222:     unwind: UnsafeCell<MaybeUninit<UnwindReason>>,",
          "233:     JitTrap { backtrace: Backtrace, pc: usize },",
          "238:     fn new(signal_handler: Option<*const SignalHandler<'static>>) -> CallThreadState {",
          "",
          "[Added Lines]",
          "219:     unwind: UnsafeCell<MaybeUninit<(UnwindReason, Option<Backtrace>)>>,",
          "224:     capture_backtrace: bool,",
          "231:     JitTrap { pc: usize }, // Removed a backtrace here",
          "236:     fn new(",
          "237:         signal_handler: Option<*const SignalHandler<'static>>,",
          "238:         capture_backtrace: bool,",
          "239:     ) -> CallThreadState {",
          "246:             capture_backtrace,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "257:     #[cold]",
          "258:     unsafe fn read_trap(&self) -> Box<Trap> {",
          "259:         Box::new(match (*self.unwind.get()).as_ptr().read() {",
          "264:         })",
          "265:     }",
          "267:     fn unwind_with(&self, reason: UnwindReason) -> ! {",
          "268:         unsafe {",
          "270:             wasmtime_longjmp(self.jmp_buf.get());",
          "271:         }",
          "272:     }",
          "",
          "[Removed Lines]",
          "260:             UnwindReason::UserTrap(data) => Trap::User(data),",
          "261:             UnwindReason::LibTrap(trap) => trap,",
          "262:             UnwindReason::JitTrap { backtrace, pc } => Trap::Jit { pc, backtrace },",
          "263:             UnwindReason::Panic(panic) => std::panic::resume_unwind(panic),",
          "269:             (*self.unwind.get()).as_mut_ptr().write(reason);",
          "",
          "[Added Lines]",
          "262:             (UnwindReason::UserTrap(error), backtrace) => Trap::User { error, backtrace },",
          "263:             (UnwindReason::LibTrap(mut trap), backtrace) => {",
          "264:                 if let Some(backtrace) = backtrace {",
          "265:                     trap.insert_backtrace(backtrace);",
          "266:                 }",
          "267:                 trap",
          "268:             }",
          "269:             (UnwindReason::JitTrap { pc }, backtrace) => Trap::Jit { pc, backtrace },",
          "270:             (UnwindReason::Panic(panic), _) => std::panic::resume_unwind(panic),",
          "275:         let backtrace = if self.capture_backtrace {",
          "276:             Some(Backtrace::new())",
          "277:         } else {",
          "278:             None",
          "279:         };",
          "281:             (*self.unwind.get()).as_mut_ptr().write((reason, backtrace));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "327:     }",
          "329:     fn capture_backtrace(&self, pc: *const u8) {",
          "331:         unsafe {",
          "332:             (*self.unwind.get())",
          "333:                 .as_mut_ptr()",
          "338:         }",
          "339:     }",
          "340: }",
          "",
          "[Removed Lines]",
          "330:         let backtrace = Backtrace::new();",
          "334:                 .write(UnwindReason::JitTrap {",
          "335:                     backtrace,",
          "336:                     pc: pc as usize,",
          "337:                 });",
          "",
          "[Added Lines]",
          "342:         let backtrace = if self.capture_backtrace {",
          "343:             Some(Backtrace::new())",
          "344:         } else {",
          "345:             None",
          "346:         };",
          "350:                 .write((UnwindReason::JitTrap { pc: pc as usize }, backtrace));",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs": [
          "File: crates/wasmtime/src/config.rs -> crates/wasmtime/src/config.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:     pub(crate) allocation_strategy: InstanceAllocationStrategy,",
          "92:     pub(crate) max_wasm_stack: usize,",
          "93:     pub(crate) features: WasmFeatures,",
          "94:     pub(crate) wasm_backtrace_details_env_used: bool,",
          "95:     #[cfg(feature = \"async\")]",
          "96:     pub(crate) async_stack_size: usize,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:     pub(crate) wasm_backtrace: bool,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "126:             max_wasm_stack: 512 * 1024,",
          "127:             wasm_backtrace_details_env_used: false,",
          "128:             features: WasmFeatures::default(),",
          "129:             #[cfg(feature = \"async\")]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "128:             wasm_backtrace: true,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "140:             ret.cranelift_debug_verifier(false);",
          "141:             ret.cranelift_opt_level(OptLevel::Speed);",
          "142:         }",
          "144:         ret.wasm_reference_types(true);",
          "146:         ret.wasm_multi_value(true);",
          "147:         ret.wasm_bulk_memory(true);",
          "148:         ret.wasm_simd(true);",
          "",
          "[Removed Lines]",
          "143:         #[cfg(feature = \"wasm-backtrace\")]",
          "145:         ret.features.reference_types = cfg!(feature = \"wasm-backtrace\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "279:         self",
          "280:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "292:     pub fn wasm_backtrace(&mut self, enable: bool) -> &mut Self {",
          "293:         self.wasm_backtrace = enable;",
          "294:         #[cfg(compiler)]",
          "295:         {",
          "297:             self.compiler",
          "298:                 .set(",
          "299:                     \"unwind_info\",",
          "300:                     if enable || self.features.reference_types {",
          "301:                         \"true\"",
          "302:                     } else {",
          "303:                         \"false\"",
          "304:                     },",
          "305:                 )",
          "306:                 .unwrap();",
          "307:         }",
          "308:         self",
          "309:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "519:     pub fn wasm_reference_types(&mut self, enable: bool) -> &mut Self {",
          "520:         self.features.reference_types = enable;",
          "",
          "[Removed Lines]",
          "517:     #[cfg(feature = \"wasm-backtrace\")]",
          "518:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"wasm-backtrace\")))]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "524:             self.compiler",
          "525:                 .set(\"enable_safepoints\", if enable { \"true\" } else { \"false\" })",
          "526:                 .unwrap();",
          "527:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "552:             self.compiler",
          "553:                 .set(",
          "554:                     \"unwind_info\",",
          "555:                     if enable || self.wasm_backtrace {",
          "556:                         \"true\"",
          "557:                     } else {",
          "558:                         \"false\"",
          "559:                     },",
          "560:                 )",
          "561:                 .unwrap();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1289: #[cfg(compiler)]",
          "1290: fn compiler_builder(strategy: Strategy) -> Result<Box<dyn CompilerBuilder>> {",
          "1305: }",
          "1307: fn round_up_to_pages(val: u64) -> u64 {",
          "",
          "[Removed Lines]",
          "1291:     let mut builder = match strategy {",
          "1292:         Strategy::Auto | Strategy::Cranelift => wasmtime_cranelift::builder(),",
          "1293:     };",
          "1294:     builder",
          "1295:         .set(",
          "1296:             \"unwind_info\",",
          "1297:             if cfg!(feature = \"wasm-backtrace\") {",
          "1298:                 \"true\"",
          "1299:             } else {",
          "1300:                 \"false\"",
          "1301:             },",
          "1302:         )",
          "1303:         .unwrap();",
          "1304:     Ok(builder)",
          "",
          "[Added Lines]",
          "1326:     match strategy {",
          "1327:         Strategy::Auto | Strategy::Cranelift => Ok(wasmtime_cranelift::builder()),",
          "1328:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1331:             mem_creator: self.mem_creator.clone(),",
          "1332:             allocation_strategy: self.allocation_strategy.clone(),",
          "1333:             max_wasm_stack: self.max_wasm_stack,",
          "1334:             wasm_backtrace_details_env_used: self.wasm_backtrace_details_env_used,",
          "1335:             async_support: self.async_support,",
          "1336:             #[cfg(feature = \"async\")]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1358:             wasm_backtrace: self.wasm_backtrace,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs": [
          "File: crates/wasmtime/src/engine.rs -> crates/wasmtime/src/engine.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "305:             \"avoid_div_traps\" => *value == FlagValue::Bool(true),",
          "307:             \"libcall_call_conv\" => *value == FlagValue::Enum(\"isa_default\".into()),",
          "",
          "[Removed Lines]",
          "306:             \"unwind_info\" => *value == FlagValue::Bool(cfg!(feature = \"wasm-backtrace\")),",
          "",
          "[Added Lines]",
          "306:             \"unwind_info\" => *value == FlagValue::Bool(true),",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/func.rs||crates/wasmtime/src/func.rs": [
          "File: crates/wasmtime/src/func.rs -> crates/wasmtime/src/func.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1235:         }",
          "1236:         let result = wasmtime_runtime::catch_traps(",
          "1237:             store.0.signal_handler(),",
          "1238:             store.0.default_callee(),",
          "1239:             closure,",
          "1240:         );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1238:             store.0.engine().config().wasm_backtrace,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/lib.rs||crates/wasmtime/src/lib.rs": [
          "File: crates/wasmtime/src/lib.rs -> crates/wasmtime/src/lib.rs"
        ],
        "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs": [
          "File: crates/wasmtime/src/store.rs -> crates/wasmtime/src/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1914:     fn new_epoch(&mut self) -> Result<u64, anyhow::Error> {",
          "1915:         return match &mut self.epoch_deadline_behavior {",
          "1916:             EpochDeadline::Trap => {",
          "1922:                 Err(anyhow::Error::from(trap))",
          "1923:             }",
          "1924:             EpochDeadline::Callback(callback) => {",
          "",
          "[Removed Lines]",
          "1917:                 let trap = Trap::new_wasm(",
          "1918:                     None,",
          "1919:                     wasmtime_environ::TrapCode::Interrupt,",
          "1920:                     wasmtime_runtime::Backtrace::new(),",
          "1921:                 );",
          "",
          "[Added Lines]",
          "1917:                 let trap = Trap::new_wasm(wasmtime_environ::TrapCode::Interrupt, None);",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs": [
          "File: crates/wasmtime/src/trap.rs -> crates/wasmtime/src/trap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::module::GlobalModuleRegistry;",
          "2: use crate::FrameInfo;",
          "3: use std::fmt;",
          "4: use std::sync::Arc;",
          "5: use wasmtime_environ::TrapCode as EnvTrapCode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use once_cell::sync::OnceCell;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:     }",
          "128: }",
          "133:     wasm_trace: Vec<FrameInfo>,",
          "134:     native_trace: Backtrace,",
          "136:     hint_wasm_backtrace_details_env: bool,",
          "137: }",
          "139: fn _assert_trap_is_sync_and_send(t: &Trap) -> (&dyn Sync, &dyn Send) {",
          "140:     (t, t)",
          "141: }",
          "",
          "[Removed Lines]",
          "130: struct TrapInner {",
          "131:     reason: TrapReason,",
          "132:     #[cfg(feature = \"wasm-backtrace\")]",
          "135:     #[cfg(feature = \"wasm-backtrace\")]",
          "",
          "[Added Lines]",
          "131: #[derive(Debug)]",
          "132: pub(crate) struct TrapBacktrace {",
          "138: impl TrapBacktrace {",
          "139:     pub fn new(native_trace: Backtrace, trap_pc: Option<usize>) -> Self {",
          "140:         let mut wasm_trace = Vec::<FrameInfo>::new();",
          "141:         let mut hint_wasm_backtrace_details_env = false;",
          "143:         GlobalModuleRegistry::with(|registry| {",
          "144:             for frame in native_trace.frames() {",
          "145:                 let pc = frame.ip() as usize;",
          "146:                 if pc == 0 {",
          "147:                     continue;",
          "148:                 }",
          "159:                 let pc_to_lookup = if Some(pc) == trap_pc { pc } else { pc - 1 };",
          "160:                 if let Some((info, has_unparsed_debuginfo, wasm_backtrace_details_env_used)) =",
          "161:                     registry.lookup_frame_info(pc_to_lookup)",
          "162:                 {",
          "163:                     wasm_trace.push(info);",
          "171:                     if has_unparsed_debuginfo && wasm_backtrace_details_env_used {",
          "172:                         hint_wasm_backtrace_details_env = true;",
          "173:                     }",
          "174:                 }",
          "175:             }",
          "176:         });",
          "177:         Self {",
          "178:             wasm_trace,",
          "179:             native_trace,",
          "180:             hint_wasm_backtrace_details_env,",
          "181:         }",
          "182:     }",
          "183: }",
          "185: struct TrapInner {",
          "186:     reason: TrapReason,",
          "187:     backtrace: OnceCell<TrapBacktrace>,",
          "188: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:     #[cold] // traps are exceptional, this helps move handling off the main path",
          "151:     pub fn new<I: Into<String>>(message: I) -> Self {",
          "152:         let reason = TrapReason::Message(message.into());",
          "154:     }",
          "158:     #[cold] // see Trap::new",
          "159:     pub fn i32_exit(status: i32) -> Self {",
          "161:     }",
          "163:     #[cold] // see Trap::new",
          "",
          "[Removed Lines]",
          "153:         Trap::new_with_trace(None, reason, Backtrace::new())",
          "160:         Trap::new_with_trace(None, TrapReason::I32Exit(status), Backtrace::new())",
          "",
          "[Added Lines]",
          "204:         Trap::new_with_trace(reason, None)",
          "211:         Trap::new_with_trace(TrapReason::I32Exit(status), None)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:     #[cold] // see Trap::new",
          "169:     pub(crate) fn from_runtime(runtime_trap: wasmtime_runtime::Trap) -> Self {",
          "170:         match runtime_trap {",
          "172:             wasmtime_runtime::Trap::Jit { pc, backtrace } => {",
          "173:                 let code = GlobalModuleRegistry::with(|modules| {",
          "174:                     modules",
          "175:                         .lookup_trap_code(pc)",
          "176:                         .unwrap_or(EnvTrapCode::StackOverflow)",
          "177:                 });",
          "179:             }",
          "180:             wasmtime_runtime::Trap::Wasm {",
          "181:                 trap_code,",
          "182:                 backtrace,",
          "184:             wasmtime_runtime::Trap::OOM { backtrace } => {",
          "185:                 let reason = TrapReason::Message(\"out of memory\".to_string());",
          "187:             }",
          "188:         }",
          "189:     }",
          "191:     #[cold] // see Trap::new",
          "197:         let code = TrapCode::from_non_user(code);",
          "199:     }",
          "253:         Trap {",
          "262:         }",
          "263:     }",
          "",
          "[Removed Lines]",
          "171:             wasmtime_runtime::Trap::User(error) => Trap::from(error),",
          "178:                 Trap::new_wasm(Some(pc), code, backtrace)",
          "183:             } => Trap::new_wasm(None, trap_code, backtrace),",
          "186:                 Trap::new_with_trace(None, reason, backtrace)",
          "192:     pub(crate) fn new_wasm(",
          "193:         trap_pc: Option<usize>,",
          "194:         code: EnvTrapCode,",
          "195:         backtrace: Backtrace,",
          "196:     ) -> Self {",
          "198:         Trap::new_with_trace(trap_pc, TrapReason::InstructionTrap(code), backtrace)",
          "213:     #[cfg_attr(not(feature = \"wasm-backtrace\"), allow(unused_mut, unused_variables))]",
          "214:     fn new_with_trace(trap_pc: Option<usize>, reason: TrapReason, native_trace: Backtrace) -> Self {",
          "215:         let mut wasm_trace = Vec::<FrameInfo>::new();",
          "216:         let mut hint_wasm_backtrace_details_env = false;",
          "218:         #[cfg(feature = \"wasm-backtrace\")]",
          "219:         GlobalModuleRegistry::with(|registry| {",
          "220:             for frame in native_trace.frames() {",
          "221:                 let pc = frame.ip() as usize;",
          "222:                 if pc == 0 {",
          "223:                     continue;",
          "224:                 }",
          "235:                 let pc_to_lookup = if Some(pc) == trap_pc { pc } else { pc - 1 };",
          "236:                 if let Some((info, has_unparsed_debuginfo, wasm_backtrace_details_env_used)) =",
          "237:                     registry.lookup_frame_info(pc_to_lookup)",
          "238:                 {",
          "239:                     wasm_trace.push(info);",
          "247:                     if has_unparsed_debuginfo && wasm_backtrace_details_env_used {",
          "248:                         hint_wasm_backtrace_details_env = true;",
          "249:                     }",
          "250:                 }",
          "251:             }",
          "252:         });",
          "254:             inner: Arc::new(TrapInner {",
          "255:                 reason,",
          "256:                 native_trace,",
          "257:                 #[cfg(feature = \"wasm-backtrace\")]",
          "258:                 wasm_trace,",
          "259:                 #[cfg(feature = \"wasm-backtrace\")]",
          "260:                 hint_wasm_backtrace_details_env,",
          "261:             }),",
          "",
          "[Added Lines]",
          "222:             wasmtime_runtime::Trap::User { error, backtrace } => {",
          "223:                 let trap = Trap::from(error);",
          "224:                 if let Some(backtrace) = backtrace {",
          "225:                     trap.record_backtrace(TrapBacktrace::new(backtrace, None));",
          "226:                 }",
          "227:                 trap",
          "228:             }",
          "235:                 let backtrace = backtrace.map(|bt| TrapBacktrace::new(bt, Some(pc)));",
          "236:                 Trap::new_wasm(code, backtrace)",
          "241:             } => {",
          "242:                 let backtrace = backtrace.map(|bt| TrapBacktrace::new(bt, None));",
          "243:                 Trap::new_wasm(trap_code, backtrace)",
          "244:             }",
          "247:                 let backtrace = backtrace.map(|bt| TrapBacktrace::new(bt, None));",
          "248:                 Trap::new_with_trace(reason, backtrace)",
          "254:     pub(crate) fn new_wasm(code: EnvTrapCode, backtrace: Option<TrapBacktrace>) -> Self {",
          "256:         Trap::new_with_trace(TrapReason::InstructionTrap(code), backtrace)",
          "266:     fn new_with_trace(reason: TrapReason, backtrace: Option<TrapBacktrace>) -> Self {",
          "267:         let backtrace = if let Some(bt) = backtrace {",
          "268:             OnceCell::with_value(bt)",
          "269:         } else {",
          "270:             OnceCell::new()",
          "271:         };",
          "273:             inner: Arc::new(TrapInner { reason, backtrace }),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "290:     }",
          "",
          "[Removed Lines]",
          "286:     #[cfg(feature = \"wasm-backtrace\")]",
          "287:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"wasm-backtrace\")))]",
          "288:     pub fn trace(&self) -> &[FrameInfo] {",
          "289:         &self.inner.wasm_trace",
          "",
          "[Added Lines]",
          "298:     pub fn trace(&self) -> Option<&[FrameInfo]> {",
          "299:         self.inner",
          "300:             .backtrace",
          "301:             .get()",
          "302:             .as_ref()",
          "303:             .map(|bt| bt.wasm_trace.as_slice())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "297:             _ => None,",
          "298:         }",
          "299:     }",
          "300: }",
          "302: impl fmt::Debug for Trap {",
          "303:     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
          "304:         let mut f = f.debug_struct(\"Trap\");",
          "305:         f.field(\"reason\", &self.inner.reason);",
          "310:         }",
          "311:         f.finish()",
          "312:     }",
          "",
          "[Removed Lines]",
          "306:         #[cfg(feature = \"wasm-backtrace\")]",
          "307:         {",
          "308:             f.field(\"wasm_trace\", &self.inner.wasm_trace)",
          "309:                 .field(\"native_trace\", &self.inner.native_trace);",
          "",
          "[Added Lines]",
          "315:     fn record_backtrace(&self, backtrace: TrapBacktrace) {",
          "323:         let _ = self.inner.backtrace.try_insert(backtrace);",
          "324:     }",
          "331:         if let Some(backtrace) = self.inner.backtrace.get() {",
          "332:             f.field(\"wasm_trace\", &backtrace.wasm_trace)",
          "333:                 .field(\"native_trace\", &backtrace.native_trace);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "316:     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
          "317:         write!(f, \"{}\", self.inner.reason)?;",
          "322:             if trace.is_empty() {",
          "323:                 return Ok(());",
          "324:             }",
          "325:             writeln!(f, \"\\nwasm backtrace:\")?;",
          "328:                 let name = frame.module_name().unwrap_or(\"<unknown>\");",
          "329:                 write!(f, \"  {:>3}: \", i)?;",
          "",
          "[Removed Lines]",
          "319:         #[cfg(feature = \"wasm-backtrace\")]",
          "320:         {",
          "321:             let trace = self.trace();",
          "327:             for (i, frame) in self.trace().iter().enumerate() {",
          "",
          "[Added Lines]",
          "343:         if let Some(trace) = self.trace() {",
          "349:             for (i, frame) in trace.iter().enumerate() {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "369:                     }",
          "370:                 }",
          "371:             }",
          "373:                 writeln!(f, \"note: using the `WASMTIME_BACKTRACE_DETAILS=1` environment variable to may show more debugging information\")?;",
          "374:             }",
          "375:         }",
          "",
          "[Removed Lines]",
          "372:             if self.inner.hint_wasm_backtrace_details_env {",
          "",
          "[Added Lines]",
          "394:             if self",
          "395:                 .inner",
          "396:                 .backtrace",
          "397:                 .get()",
          "398:                 .map(|t| t.hint_wasm_backtrace_details_env)",
          "399:                 .unwrap_or(false)",
          "400:             {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "404:             trap.clone()",
          "405:         } else {",
          "406:             let reason = TrapReason::Error(e.into());",
          "408:         }",
          "409:     }",
          "410: }",
          "",
          "[Removed Lines]",
          "407:             Trap::new_with_trace(None, reason, Backtrace::new())",
          "",
          "[Added Lines]",
          "435:             Trap::new_with_trace(reason, None)",
          "",
          "---------------"
        ],
        "tests/all/traps.rs||tests/all/traps.rs": [
          "File: tests/all/traps.rs -> tests/all/traps.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:         .err()",
          "50:         .expect(\"error calling function\");",
          "53:     assert_eq!(trace.len(), 2);",
          "54:     assert_eq!(trace[0].module_name().unwrap(), \"hello_mod\");",
          "55:     assert_eq!(trace[0].func_index(), 1);",
          "",
          "[Removed Lines]",
          "52:     let trace = e.trace();",
          "",
          "[Added Lines]",
          "52:     let trace = e.trace().expect(\"backtrace is available\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:     Ok(())",
          "71: }",
          "73: #[test]",
          "74: #[cfg_attr(all(target_os = \"macos\", target_arch = \"aarch64\"), ignore)] // TODO #2808 system libunwind is broken on aarch64",
          "75: fn test_trap_trace_cb() -> Result<()> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: #[test]",
          "74: fn test_trap_backtrace_disabled() -> Result<()> {",
          "75:     let mut config = Config::default();",
          "76:     config.wasm_backtrace(false);",
          "77:     let engine = Engine::new(&config).unwrap();",
          "78:     let mut store = Store::<()>::new(&engine, ());",
          "79:     let wat = r#\"",
          "80:         (module $hello_mod",
          "81:             (func (export \"run\") (call $hello))",
          "82:             (func $hello (unreachable))",
          "83:         )",
          "84:     \"#;",
          "86:     let module = Module::new(store.engine(), wat)?;",
          "87:     let instance = Instance::new(&mut store, &module, &[])?;",
          "88:     let run_func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;",
          "90:     let e = run_func",
          "91:         .call(&mut store, ())",
          "92:         .err()",
          "93:         .expect(\"error calling function\");",
          "95:     assert!(e.trace().is_none(), \"backtraces should be disabled\");",
          "96:     Ok(())",
          "97: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:         .err()",
          "95:         .expect(\"error calling function\");",
          "98:     assert_eq!(trace.len(), 2);",
          "99:     assert_eq!(trace[0].module_name().unwrap(), \"hello_mod\");",
          "100:     assert_eq!(trace[0].func_index(), 2);",
          "",
          "[Removed Lines]",
          "97:     let trace = e.trace();",
          "",
          "[Added Lines]",
          "123:     let trace = e.trace().expect(\"backtrace is available\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "124:         .err()",
          "125:         .expect(\"error calling function\");",
          "128:     assert!(trace.len() >= 32);",
          "129:     for i in 0..trace.len() {",
          "130:         assert_eq!(trace[i].module_name().unwrap(), \"rec_mod\");",
          "",
          "[Removed Lines]",
          "127:     let trace = e.trace();",
          "",
          "[Added Lines]",
          "153:     let trace = e.trace().expect(\"backtrace is available\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "430:     fn assert_trap(t: Trap) {",
          "431:         println!(\"{}\", t);",
          "434:     }",
          "435: }",
          "",
          "[Removed Lines]",
          "432:         assert_eq!(t.trace().len(), 1);",
          "433:         assert_eq!(t.trace()[0].func_index(), 0);",
          "",
          "[Added Lines]",
          "458:         let trace = t.trace().expect(\"backtrace is available\");",
          "459:         assert_eq!(trace.len(), 1);",
          "460:         assert_eq!(trace[0].func_index(), 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "525:         .downcast::<Trap>()?;",
          "527:     let mut found = false;",
          "529:         for symbol in frame.symbols() {",
          "530:             if let Some(file) = symbol.file() {",
          "531:                 if file.ends_with(\"input.rs\") {",
          "",
          "[Removed Lines]",
          "528:     for frame in trap.trace() {",
          "",
          "[Added Lines]",
          "555:     for frame in trap.trace().expect(\"backtrace is available\") {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "661:         .err()",
          "662:         .expect(\"error calling function\");",
          "665:     assert_eq!(trace.len(), 2);",
          "666:     assert_eq!(trace[0].func_name(), Some(\"hello\"));",
          "667:     assert_eq!(trace[0].func_index(), 1);",
          "",
          "[Removed Lines]",
          "664:     let trace = e.trace();",
          "",
          "[Added Lines]",
          "691:     let trace = e.trace().expect(\"backtrace is available\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f1e6f37856b2e829a31aa4b4c5cade91abf4d97",
      "candidate_info": {
        "commit_hash": "4f1e6f37856b2e829a31aa4b4c5cade91abf4d97",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/4f1e6f37856b2e829a31aa4b4c5cade91abf4d97",
        "files": [
          "crates/fiber/src/unix.rs",
          "crates/runtime/src/component.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/memory.rs",
          "crates/runtime/src/sys/custom/mmap.rs",
          "crates/runtime/src/sys/miri/mmap.rs",
          "crates/runtime/src/sys/unix/mmap.rs",
          "tests/all/memory.rs"
        ],
        "message": "Use some new standard library methods from Rust 1.74, 1.75 (#8209)\n\n* Use some `byte_add` methods from Rust 1.75\n\nNow that we're able to, use some convenience methods from the 1.75\nrelease of Rust.\n\n* Use `Atomic*::from_ptr` from Rust 1.75\n\nHelps clean up some casts and clarify local intent.",
        "before_after_code_files": [
          "crates/fiber/src/unix.rs||crates/fiber/src/unix.rs",
          "crates/runtime/src/component.rs||crates/runtime/src/component.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs",
          "crates/runtime/src/sys/custom/mmap.rs||crates/runtime/src/sys/custom/mmap.rs",
          "crates/runtime/src/sys/miri/mmap.rs||crates/runtime/src/sys/miri/mmap.rs",
          "crates/runtime/src/sys/unix/mmap.rs||crates/runtime/src/sys/unix/mmap.rs",
          "tests/all/memory.rs||tests/all/memory.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/fiber/src/unix.rs||crates/fiber/src/unix.rs": [
          "File: crates/fiber/src/unix.rs -> crates/fiber/src/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:             )?;",
          "73:             rustix::mm::mprotect(",
          "75:                 size,",
          "76:                 rustix::mm::MprotectFlags::READ | rustix::mm::MprotectFlags::WRITE,",
          "77:             )?;",
          "79:             Ok(Self::Default {",
          "81:                 len: mmap_len,",
          "82:                 mmap: true,",
          "83:             })",
          "",
          "[Removed Lines]",
          "74:                 mmap.cast::<u8>().add(page_size).cast(),",
          "80:                 top: mmap.cast::<u8>().add(mmap_len),",
          "",
          "[Added Lines]",
          "74:                 mmap.byte_add(page_size).cast(),",
          "80:                 top: mmap.byte_add(mmap_len).cast(),",
          "",
          "---------------"
        ],
        "crates/runtime/src/component.rs||crates/runtime/src/component.rs": [
          "File: crates/runtime/src/component.rs -> crates/runtime/src/component.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:         f: impl FnOnce(&mut ComponentInstance) -> R,",
          "157:     ) -> R {",
          "158:         let ptr = vmctx",
          "161:             .cast::<ComponentInstance>();",
          "162:         f(&mut *ptr)",
          "163:     }",
          "",
          "[Removed Lines]",
          "159:             .cast::<u8>()",
          "160:             .sub(mem::size_of::<ComponentInstance>())",
          "",
          "[Added Lines]",
          "159:             .byte_sub(mem::size_of::<ComponentInstance>())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205:                 vmctx_self_reference: SendSyncPtr::new(",
          "206:                     NonNull::new(",
          "207:                         ptr.as_ptr()",
          "210:                             .cast(),",
          "211:                     )",
          "212:                     .unwrap(),",
          "",
          "[Removed Lines]",
          "208:                             .cast::<u8>()",
          "209:                             .add(mem::size_of::<ComponentInstance>())",
          "",
          "[Added Lines]",
          "207:                             .byte_add(mem::size_of::<ComponentInstance>())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "231:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
          "232:         self.vmctx()",
          "235:             .cast()",
          "236:     }",
          "238:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
          "239:         self.vmctx()",
          "242:             .cast()",
          "243:     }",
          "",
          "[Removed Lines]",
          "233:             .cast::<u8>()",
          "234:             .add(usize::try_from(offset).unwrap())",
          "240:             .cast::<u8>()",
          "241:             .add(usize::try_from(offset).unwrap())",
          "",
          "[Added Lines]",
          "231:             .byte_add(usize::try_from(offset).unwrap())",
          "237:             .byte_add(usize::try_from(offset).unwrap())",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "189:                 dropped_elements,",
          "190:                 dropped_data,",
          "191:                 host_state: req.host_state,",
          "195:                 vmctx: VMContext {",
          "196:                     _marker: std::marker::PhantomPinned,",
          "197:                 },",
          "",
          "[Removed Lines]",
          "192:                 vmctx_self_reference: SendSyncPtr::new(",
          "193:                     NonNull::new(ptr.cast::<u8>().add(mem::size_of::<Instance>()).cast()).unwrap(),",
          "194:                 ),",
          "",
          "[Added Lines]",
          "192:                 vmctx_self_reference: SendSyncPtr::new(NonNull::new(ptr.add(1).cast()).unwrap()),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236:     #[inline]",
          "237:     pub unsafe fn from_vmctx<R>(vmctx: *mut VMContext, f: impl FnOnce(&mut Instance) -> R) -> R {",
          "238:         let ptr = vmctx",
          "241:             .cast::<Instance>();",
          "242:         f(&mut *ptr)",
          "243:     }",
          "",
          "[Removed Lines]",
          "239:             .cast::<u8>()",
          "240:             .sub(mem::size_of::<Instance>())",
          "",
          "[Added Lines]",
          "237:             .byte_sub(mem::size_of::<Instance>())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "252:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
          "253:         self.vmctx()",
          "256:             .cast()",
          "257:     }",
          "260:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
          "261:         self.vmctx()",
          "264:             .cast()",
          "265:     }",
          "",
          "[Removed Lines]",
          "254:             .cast::<u8>()",
          "255:             .add(usize::try_from(offset).unwrap())",
          "262:             .cast::<u8>()",
          "263:             .add(usize::try_from(offset).unwrap())",
          "",
          "[Added Lines]",
          "251:             .byte_add(usize::try_from(offset).unwrap())",
          "258:             .byte_add(usize::try_from(offset).unwrap())",
          "",
          "---------------"
        ],
        "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs": [
          "File: crates/runtime/src/memory.rs -> crates/runtime/src/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:         assert!(std::mem::size_of::<AtomicU32>() == 4);",
          "587:         assert!(std::mem::align_of::<AtomicU32>() <= 4);",
          "590:         WAITER.with(|waiter| {",
          "591:             let mut waiter = waiter.borrow_mut();",
          "",
          "[Removed Lines]",
          "588:         let atomic = unsafe { &*(addr as *const AtomicU32) };",
          "",
          "[Added Lines]",
          "588:         let atomic = unsafe { AtomicU32::from_ptr(addr.cast()) };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "609:         assert!(std::mem::size_of::<AtomicU64>() == 8);",
          "610:         assert!(std::mem::align_of::<AtomicU64>() <= 8);",
          "613:         WAITER.with(|waiter| {",
          "614:             let mut waiter = waiter.borrow_mut();",
          "",
          "[Removed Lines]",
          "611:         let atomic = unsafe { &*(addr as *const AtomicU64) };",
          "",
          "[Added Lines]",
          "611:         let atomic = unsafe { AtomicU64::from_ptr(addr.cast()) };",
          "",
          "---------------"
        ],
        "crates/runtime/src/sys/custom/mmap.rs||crates/runtime/src/sys/custom/mmap.rs": [
          "File: crates/runtime/src/sys/custom/mmap.rs -> crates/runtime/src/sys/custom/mmap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     }",
          "44:     pub fn make_accessible(&mut self, start: usize, len: usize) -> Result<()> {",
          "46:         unsafe {",
          "47:             cvt(capi::wasmtime_mprotect(",
          "49:                 len,",
          "50:                 capi::PROT_READ | capi::PROT_WRITE,",
          "51:             ))?;",
          "",
          "[Removed Lines]",
          "45:         let ptr = self.memory.as_ptr().cast::<u8>();",
          "48:                 ptr.add(start).cast(),",
          "",
          "[Added Lines]",
          "45:         let ptr = self.memory.as_ptr();",
          "48:                 ptr.byte_add(start).cast(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         range: Range<usize>,",
          "75:         enable_branch_protection: bool,",
          "76:     ) -> Result<()> {",
          "78:         let len = range.end - range.start;",
          "",
          "[Removed Lines]",
          "77:         let base = self.memory.as_ptr().cast::<u8>().add(range.start).cast();",
          "",
          "[Added Lines]",
          "77:         let base = self.memory.as_ptr().byte_add(range.start).cast();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:     }",
          "91:     pub unsafe fn make_readonly(&self, range: Range<usize>) -> Result<()> {",
          "93:         let len = range.end - range.start;",
          "95:         cvt(capi::wasmtime_mprotect(base, len, capi::PROT_READ))?;",
          "",
          "[Removed Lines]",
          "92:         let base = self.memory.as_ptr().cast::<u8>().add(range.start).cast();",
          "",
          "[Added Lines]",
          "92:         let base = self.memory.as_ptr().byte_add(range.start).cast();",
          "",
          "---------------"
        ],
        "crates/runtime/src/sys/miri/mmap.rs||crates/runtime/src/sys/miri/mmap.rs": [
          "File: crates/runtime/src/sys/miri/mmap.rs -> crates/runtime/src/sys/miri/mmap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:         unsafe {",
          "55:         }",
          "56:         Ok(())",
          "57:     }",
          "",
          "[Removed Lines]",
          "54:             std::ptr::write_bytes(self.memory.as_ptr().cast::<u8>().add(start), 0u8, len);",
          "",
          "[Added Lines]",
          "54:             std::ptr::write_bytes(self.as_mut_ptr().add(start), 0u8, len);",
          "",
          "---------------"
        ],
        "crates/runtime/src/sys/unix/mmap.rs||crates/runtime/src/sys/unix/mmap.rs": [
          "File: crates/runtime/src/sys/unix/mmap.rs -> crates/runtime/src/sys/unix/mmap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     }",
          "74:     pub fn make_accessible(&mut self, start: usize, len: usize) -> Result<()> {",
          "76:         unsafe {",
          "77:             mprotect(",
          "79:                 len,",
          "80:                 MprotectFlags::READ | MprotectFlags::WRITE,",
          "81:             )?;",
          "",
          "[Removed Lines]",
          "75:         let ptr = self.memory.as_ptr().cast::<u8>();",
          "78:                 ptr.add(start).cast(),",
          "",
          "[Added Lines]",
          "75:         let ptr = self.memory.as_ptr();",
          "78:                 ptr.byte_add(start).cast(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:         range: Range<usize>,",
          "105:         enable_branch_protection: bool,",
          "106:     ) -> Result<()> {",
          "108:         let len = range.end - range.start;",
          "110:         let flags = MprotectFlags::READ | MprotectFlags::EXEC;",
          "",
          "[Removed Lines]",
          "107:         let base = self.memory.as_ptr().cast::<u8>().add(range.start).cast();",
          "",
          "[Added Lines]",
          "107:         let base = self.memory.as_ptr().byte_add(range.start).cast();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:     }",
          "130:     pub unsafe fn make_readonly(&self, range: Range<usize>) -> Result<()> {",
          "132:         let len = range.end - range.start;",
          "134:         mprotect(base, len, MprotectFlags::READ)?;",
          "",
          "[Removed Lines]",
          "131:         let base = self.memory.as_ptr().cast::<u8>().add(range.start).cast();",
          "",
          "[Added Lines]",
          "131:         let base = self.memory.as_ptr().byte_add(range.start).cast();",
          "",
          "---------------"
        ],
        "tests/all/memory.rs||tests/all/memory.rs": [
          "File: tests/all/memory.rs -> tests/all/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "610:     let engine = Engine::default();",
          "611:     let memory = SharedMemory::new(&engine, MemoryType::shared(1, 1))?;",
          "",
          "[Removed Lines]",
          "612:     let data = unsafe { &*(memory.data().as_ptr() as *const AtomicU32) };",
          "613:     let locked = unsafe { &*(memory.data().as_ptr().add(4) as *const AtomicU32) };",
          "",
          "[Added Lines]",
          "612:     let data = unsafe { AtomicU32::from_ptr(memory.data().as_ptr().cast_mut().cast()) };",
          "613:     let locked = unsafe { AtomicU32::from_ptr(memory.data().as_ptr().add(4).cast_mut().cast()) };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "614665688d27986014926be37a99f70dcff02910",
      "candidate_info": {
        "commit_hash": "614665688d27986014926be37a99f70dcff02910",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/614665688d27986014926be37a99f70dcff02910",
        "files": [
          "crates/runtime/src/libcalls.rs"
        ],
        "message": "Make libcalls slightly safer (#6360)\n\nBake in the `*mut VMContext` to `&mut Instance` translation into the\nmacro-generated trampolines to avoid the need to use\n`Instance::from_vmctx` with an extra level of indentation everywhere.\nAdditionally some libcalls are now entirely safe code as their one\nunsafe operation was the `VMContext` to `Instance` translation.",
        "before_after_code_files": [
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs"
          ],
          "candidate": [
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: use crate::externref::VMExternRef;",
          "58: use crate::table::{Table, TableElementType};",
          "60: use crate::{Instance, TrapReason};",
          "61: use anyhow::Result;",
          "62: use std::mem;",
          "",
          "[Removed Lines]",
          "59: use crate::vmcontext::{VMContext, VMFuncRef};",
          "",
          "[Added Lines]",
          "59: use crate::vmcontext::VMFuncRef;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: pub mod trampolines {",
          "78:     macro_rules! libcall {",
          "79:         (",
          "",
          "[Removed Lines]",
          "76:     use crate::{TrapReason, VMContext};",
          "",
          "[Added Lines]",
          "76:     use crate::{Instance, TrapReason, VMContext};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:                 #[cfg_attr(target_arch = \"s390x\", no_mangle)]",
          "113:                 unsafe extern \"C\" fn [<impl_ $name>](",
          "115:                     $( $pname : libcall!(@ty $param), )*",
          "116:                 ) $( -> libcall!(@ty $result))? {",
          "117:                     let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {",
          "119:                     }));",
          "120:                     match result {",
          "121:                         Ok(ret) => LibcallResult::convert(ret),",
          "",
          "[Removed Lines]",
          "114:                     vmctx : *mut VMContext,",
          "118:                         super::$name(vmctx, $($pname),*)",
          "",
          "[Added Lines]",
          "114:                     vmctx: *mut VMContext,",
          "118:                         Instance::from_vmctx(vmctx, |instance| {",
          "119:                             super::$name(instance, $($pname),*)",
          "120:                         })",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "181:     }",
          "182: }",
          "186:     delta: u64,",
          "187:     memory_index: u32,",
          "188: ) -> Result<*mut u8, TrapReason> {",
          "203: }",
          "209: unsafe fn table_grow(",
          "211:     table_index: u32,",
          "212:     delta: u32,",
          "",
          "[Removed Lines]",
          "184: unsafe fn memory32_grow(",
          "185:     vmctx: *mut VMContext,",
          "189:     Instance::from_vmctx(vmctx, |instance| {",
          "190:         let memory_index = MemoryIndex::from_u32(memory_index);",
          "191:         let result =",
          "192:             match instance",
          "193:                 .memory_grow(memory_index, delta)",
          "194:                 .map_err(|error| TrapReason::User {",
          "195:                     error,",
          "196:                     needs_backtrace: true,",
          "197:                 })? {",
          "198:                 Some(size_in_bytes) => size_in_bytes / (wasmtime_environ::WASM_PAGE_SIZE as usize),",
          "199:                 None => usize::max_value(),",
          "200:             };",
          "201:         Ok(result as *mut _)",
          "202:     })",
          "210:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "186: fn memory32_grow(",
          "187:     instance: &mut Instance,",
          "191:     let memory_index = MemoryIndex::from_u32(memory_index);",
          "192:     let result =",
          "193:         match instance",
          "194:             .memory_grow(memory_index, delta)",
          "195:             .map_err(|error| TrapReason::User {",
          "196:                 error,",
          "197:                 needs_backtrace: true,",
          "198:             })? {",
          "199:             Some(size_in_bytes) => size_in_bytes / (wasmtime_environ::WASM_PAGE_SIZE as usize),",
          "200:             None => usize::max_value(),",
          "201:         };",
          "202:     Ok(result as *mut _)",
          "207:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "215:     init_value: *mut u8,",
          "216: ) -> Result<u32> {",
          "217:     let table_index = TableIndex::from_u32(table_index);",
          "234:     })",
          "235: }",
          "",
          "[Removed Lines]",
          "218:     Instance::from_vmctx(vmctx, |instance| {",
          "219:         let element = match instance.table_element_type(table_index) {",
          "220:             TableElementType::Func => (init_value as *mut VMFuncRef).into(),",
          "221:             TableElementType::Extern => {",
          "222:                 let init_value = if init_value.is_null() {",
          "223:                     None",
          "224:                 } else {",
          "225:                     Some(VMExternRef::clone_from_raw(init_value))",
          "226:                 };",
          "227:                 init_value.into()",
          "228:             }",
          "229:         };",
          "230:         Ok(match instance.table_grow(table_index, delta, element)? {",
          "231:             Some(r) => r,",
          "232:             None => -1_i32 as u32,",
          "233:         })",
          "",
          "[Added Lines]",
          "215:     let element = match instance.table_element_type(table_index) {",
          "216:         TableElementType::Func => (init_value as *mut VMFuncRef).into(),",
          "217:         TableElementType::Extern => {",
          "218:             let init_value = if init_value.is_null() {",
          "219:                 None",
          "220:             } else {",
          "221:                 Some(VMExternRef::clone_from_raw(init_value))",
          "222:             };",
          "223:             init_value.into()",
          "224:         }",
          "225:     };",
          "226:     Ok(match instance.table_grow(table_index, delta, element)? {",
          "227:         Some(r) => r,",
          "228:         None => -1_i32 as u32,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "241: unsafe fn table_fill(",
          "243:     table_index: u32,",
          "244:     dst: u32,",
          "",
          "[Removed Lines]",
          "242:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "237:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "247:     val: *mut u8,",
          "248:     len: u32,",
          "249: ) -> Result<(), Trap> {",
          "266:         }",
          "268: }",
          "270: use table_fill as table_fill_func_ref;",
          "",
          "[Removed Lines]",
          "250:     Instance::from_vmctx(vmctx, |instance| {",
          "251:         let table_index = TableIndex::from_u32(table_index);",
          "252:         let table = &mut *instance.get_table(table_index);",
          "253:         match table.element_type() {",
          "254:             TableElementType::Func => {",
          "255:                 let val = val as *mut VMFuncRef;",
          "256:                 table.fill(dst, val.into(), len)",
          "257:             }",
          "258:             TableElementType::Extern => {",
          "259:                 let val = if val.is_null() {",
          "260:                     None",
          "261:                 } else {",
          "262:                     Some(VMExternRef::clone_from_raw(val))",
          "263:                 };",
          "264:                 table.fill(dst, val.into(), len)",
          "265:             }",
          "267:     })",
          "",
          "[Added Lines]",
          "245:     let table_index = TableIndex::from_u32(table_index);",
          "246:     let table = &mut *instance.get_table(table_index);",
          "247:     match table.element_type() {",
          "248:         TableElementType::Func => {",
          "249:             let val = val as *mut VMFuncRef;",
          "250:             table.fill(dst, val.into(), len)",
          "252:         TableElementType::Extern => {",
          "253:             let val = if val.is_null() {",
          "254:                 None",
          "255:             } else {",
          "256:                 Some(VMExternRef::clone_from_raw(val))",
          "257:             };",
          "258:             table.fill(dst, val.into(), len)",
          "259:         }",
          "260:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "274: unsafe fn table_copy(",
          "276:     dst_table_index: u32,",
          "277:     src_table_index: u32,",
          "278:     dst: u32,",
          "",
          "[Removed Lines]",
          "275:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "268:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "281: ) -> Result<(), Trap> {",
          "282:     let dst_table_index = TableIndex::from_u32(dst_table_index);",
          "283:     let src_table_index = TableIndex::from_u32(src_table_index);",
          "291: }",
          "296:     table_index: u32,",
          "297:     elem_index: u32,",
          "298:     dst: u32,",
          "",
          "[Removed Lines]",
          "284:     Instance::from_vmctx(vmctx, |instance| {",
          "285:         let dst_table = instance.get_table(dst_table_index);",
          "287:         let src_range = src..(src.checked_add(len).unwrap_or(u32::MAX));",
          "288:         let src_table = instance.get_table_with_lazy_init(src_table_index, src_range);",
          "289:         Table::copy(dst_table, src_table, dst, src, len)",
          "290:     })",
          "294: unsafe fn table_init(",
          "295:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "277:     let dst_table = instance.get_table(dst_table_index);",
          "279:     let src_range = src..(src.checked_add(len).unwrap_or(u32::MAX));",
          "280:     let src_table = instance.get_table_with_lazy_init(src_table_index, src_range);",
          "281:     Table::copy(dst_table, src_table, dst, src, len)",
          "285: fn table_init(",
          "286:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "301: ) -> Result<(), Trap> {",
          "302:     let table_index = TableIndex::from_u32(table_index);",
          "303:     let elem_index = ElemIndex::from_u32(elem_index);",
          "307: }",
          "311:     let elem_index = ElemIndex::from_u32(elem_index);",
          "313: }",
          "318:     dst_index: u32,",
          "319:     dst: u64,",
          "320:     src_index: u32,",
          "",
          "[Removed Lines]",
          "304:     Instance::from_vmctx(vmctx, |i| {",
          "305:         i.table_init(table_index, elem_index, dst, src, len)",
          "306:     })",
          "310: unsafe fn elem_drop(vmctx: *mut VMContext, elem_index: u32) {",
          "312:     Instance::from_vmctx(vmctx, |i| i.elem_drop(elem_index))",
          "316: unsafe fn memory_copy(",
          "317:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "295:     instance.table_init(table_index, elem_index, dst, src, len)",
          "299: fn elem_drop(instance: &mut Instance, elem_index: u32) {",
          "301:     instance.elem_drop(elem_index)",
          "305: fn memory_copy(",
          "306:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "323: ) -> Result<(), Trap> {",
          "324:     let src_index = MemoryIndex::from_u32(src_index);",
          "325:     let dst_index = MemoryIndex::from_u32(dst_index);",
          "329: }",
          "334:     memory_index: u32,",
          "335:     dst: u64,",
          "336:     val: u32,",
          "337:     len: u64,",
          "338: ) -> Result<(), Trap> {",
          "339:     let memory_index = MemoryIndex::from_u32(memory_index);",
          "341: }",
          "346:     memory_index: u32,",
          "347:     data_index: u32,",
          "348:     dst: u64,",
          "",
          "[Removed Lines]",
          "326:     Instance::from_vmctx(vmctx, |i| {",
          "327:         i.memory_copy(dst_index, dst, src_index, src, len)",
          "328:     })",
          "332: unsafe fn memory_fill(",
          "333:     vmctx: *mut VMContext,",
          "340:     Instance::from_vmctx(vmctx, |i| i.memory_fill(memory_index, dst, val as u8, len))",
          "344: unsafe fn memory_init(",
          "345:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "315:     instance.memory_copy(dst_index, dst, src_index, src, len)",
          "319: fn memory_fill(",
          "320:     instance: &mut Instance,",
          "327:     instance.memory_fill(memory_index, dst, val as u8, len)",
          "331: fn memory_init(",
          "332:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "351: ) -> Result<(), Trap> {",
          "352:     let memory_index = MemoryIndex::from_u32(memory_index);",
          "353:     let data_index = DataIndex::from_u32(data_index);",
          "357: }",
          "367: }",
          "371:     let data_index = DataIndex::from_u32(data_index);",
          "373: }",
          "376: unsafe fn table_get_lazy_init_func_ref(",
          "378:     table_index: u32,",
          "379:     index: u32,",
          "380: ) -> *mut u8 {",
          "390: }",
          "394:     let externref = externref as *mut crate::externref::VMExternData;",
          "395:     let externref = NonNull::new(externref).unwrap().into();",
          "396:     crate::externref::VMExternData::drop_and_dealloc(externref);",
          "",
          "[Removed Lines]",
          "354:     Instance::from_vmctx(vmctx, |i| {",
          "355:         i.memory_init(memory_index, data_index, dst, src, len)",
          "356:     })",
          "360: unsafe fn ref_func(vmctx: *mut VMContext, func_index: u32) -> *mut u8 {",
          "361:     Instance::from_vmctx(vmctx, |instance| {",
          "362:         instance",
          "363:             .get_func_ref(FuncIndex::from_u32(func_index))",
          "364:             .expect(\"ref_func: funcref should always be available for given func index\")",
          "365:             .cast()",
          "366:     })",
          "370: unsafe fn data_drop(vmctx: *mut VMContext, data_index: u32) {",
          "372:     Instance::from_vmctx(vmctx, |i| i.data_drop(data_index))",
          "377:     vmctx: *mut VMContext,",
          "381:     Instance::from_vmctx(vmctx, |instance| {",
          "382:         let table_index = TableIndex::from_u32(table_index);",
          "383:         let table = instance.get_table_with_lazy_init(table_index, std::iter::once(index));",
          "384:         let elem = (*table)",
          "385:             .get(index)",
          "386:             .expect(\"table access already bounds-checked\");",
          "388:         elem.into_ref_asserting_initialized()",
          "389:     })",
          "393: unsafe fn drop_externref(_vmctx: *mut VMContext, externref: *mut u8) {",
          "",
          "[Added Lines]",
          "341:     instance.memory_init(memory_index, data_index, dst, src, len)",
          "345: fn ref_func(instance: &mut Instance, func_index: u32) -> *mut u8 {",
          "346:     instance",
          "347:         .get_func_ref(FuncIndex::from_u32(func_index))",
          "348:         .expect(\"ref_func: funcref should always be available for given func index\")",
          "349:         .cast()",
          "353: fn data_drop(instance: &mut Instance, data_index: u32) {",
          "355:     instance.data_drop(data_index)",
          "360:     instance: &mut Instance,",
          "364:     let table_index = TableIndex::from_u32(table_index);",
          "365:     let table = instance.get_table_with_lazy_init(table_index, std::iter::once(index));",
          "366:     let elem = (*table)",
          "367:         .get(index)",
          "368:         .expect(\"table access already bounds-checked\");",
          "370:     elem.into_ref_asserting_initialized()",
          "374: unsafe fn drop_externref(_instance: &mut Instance, externref: *mut u8) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "402:     let externref = VMExternRef::clone_from_raw(externref);",
          "419: }",
          "423:     let index = GlobalIndex::from_u32(index);",
          "436:         }",
          "438: }",
          "442:     let externref = if externref.is_null() {",
          "443:         None",
          "444:     } else {",
          "",
          "[Removed Lines]",
          "401: unsafe fn activations_table_insert_with_gc(vmctx: *mut VMContext, externref: *mut u8) {",
          "403:     Instance::from_vmctx(vmctx, |instance| {",
          "404:         let limits = *instance.runtime_limits();",
          "405:         let (activations_table, module_info_lookup) =",
          "406:             (*instance.store()).externref_activations_table();",
          "415:         activations_table.insert_without_gc(externref.clone());",
          "417:         activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "418:     })",
          "422: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
          "424:     Instance::from_vmctx(vmctx, |instance| {",
          "425:         let limits = *instance.runtime_limits();",
          "426:         let global = instance.defined_or_imported_global_ptr(index);",
          "427:         match (*global).as_externref().clone() {",
          "428:             None => ptr::null_mut(),",
          "429:             Some(externref) => {",
          "430:                 let raw = externref.as_raw();",
          "431:                 let (activations_table, module_info_lookup) =",
          "432:                     (*instance.store()).externref_activations_table();",
          "433:                 activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "434:                 raw",
          "435:             }",
          "437:     })",
          "441: unsafe fn externref_global_set(vmctx: *mut VMContext, index: u32, externref: *mut u8) {",
          "",
          "[Added Lines]",
          "382: unsafe fn activations_table_insert_with_gc(instance: &mut Instance, externref: *mut u8) {",
          "384:     let limits = *instance.runtime_limits();",
          "385:     let (activations_table, module_info_lookup) = (*instance.store()).externref_activations_table();",
          "394:     activations_table.insert_without_gc(externref.clone());",
          "396:     activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "400: unsafe fn externref_global_get(instance: &mut Instance, index: u32) -> *mut u8 {",
          "402:     let limits = *instance.runtime_limits();",
          "403:     let global = instance.defined_or_imported_global_ptr(index);",
          "404:     match (*global).as_externref().clone() {",
          "405:         None => ptr::null_mut(),",
          "406:         Some(externref) => {",
          "407:             let raw = externref.as_raw();",
          "408:             let (activations_table, module_info_lookup) =",
          "409:                 (*instance.store()).externref_activations_table();",
          "410:             activations_table.insert_with_gc(limits, externref, module_info_lookup);",
          "411:             raw",
          "413:     }",
          "417: unsafe fn externref_global_set(instance: &mut Instance, index: u32, externref: *mut u8) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "446:     };",
          "448:     let index = GlobalIndex::from_u32(index);",
          "459: }",
          "464:     memory_index: u32,",
          "465:     addr_index: u64,",
          "466:     count: u32,",
          "467: ) -> Result<u32, Trap> {",
          "468:     let memory = MemoryIndex::from_u32(memory_index);",
          "474: }",
          "479:     memory_index: u32,",
          "480:     addr_index: u64,",
          "481:     expected: u32,",
          "",
          "[Removed Lines]",
          "449:     Instance::from_vmctx(vmctx, |instance| {",
          "450:         let global = instance.defined_or_imported_global_ptr(index);",
          "456:         let old = mem::replace((*global).as_externref_mut(), externref);",
          "457:         drop(old);",
          "458:     })",
          "462: unsafe fn memory_atomic_notify(",
          "463:     vmctx: *mut VMContext,",
          "469:     Instance::from_vmctx(vmctx, |instance| {",
          "470:         instance",
          "471:             .get_runtime_memory(memory)",
          "472:             .atomic_notify(addr_index, count)",
          "473:     })",
          "477: unsafe fn memory_atomic_wait32(",
          "478:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "425:     let global = instance.defined_or_imported_global_ptr(index);",
          "431:     let old = mem::replace((*global).as_externref_mut(), externref);",
          "432:     drop(old);",
          "436: fn memory_atomic_notify(",
          "437:     instance: &mut Instance,",
          "443:     instance",
          "444:         .get_runtime_memory(memory)",
          "445:         .atomic_notify(addr_index, count)",
          "449: fn memory_atomic_wait32(",
          "450:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "485:     let timeout = (timeout as i64 >= 0).then(|| Instant::now() + Duration::from_nanos(timeout));",
          "486:     let memory = MemoryIndex::from_u32(memory_index);",
          "492: }",
          "497:     memory_index: u32,",
          "498:     addr_index: u64,",
          "499:     expected: u64,",
          "",
          "[Removed Lines]",
          "487:     Instance::from_vmctx(vmctx, |instance| {",
          "488:         Ok(instance",
          "489:             .get_runtime_memory(memory)",
          "490:             .atomic_wait32(addr_index, expected, timeout)? as u32)",
          "491:     })",
          "495: unsafe fn memory_atomic_wait64(",
          "496:     vmctx: *mut VMContext,",
          "",
          "[Added Lines]",
          "459:     Ok(instance",
          "460:         .get_runtime_memory(memory)",
          "461:         .atomic_wait32(addr_index, expected, timeout)? as u32)",
          "465: fn memory_atomic_wait64(",
          "466:     instance: &mut Instance,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "503:     let timeout = (timeout as i64 >= 0).then(|| Instant::now() + Duration::from_nanos(timeout));",
          "504:     let memory = MemoryIndex::from_u32(memory_index);",
          "510: }",
          "515: }",
          "520: }",
          "",
          "[Removed Lines]",
          "505:     Instance::from_vmctx(vmctx, |instance| {",
          "506:         Ok(instance",
          "507:             .get_runtime_memory(memory)",
          "508:             .atomic_wait64(addr_index, expected, timeout)? as u32)",
          "509:     })",
          "513: unsafe fn out_of_gas(vmctx: *mut VMContext) -> Result<()> {",
          "514:     Instance::from_vmctx(vmctx, |i| (*i.store()).out_of_gas())",
          "518: unsafe fn new_epoch(vmctx: *mut VMContext) -> Result<u64> {",
          "519:     Instance::from_vmctx(vmctx, |i| (*i.store()).new_epoch())",
          "",
          "[Added Lines]",
          "475:     Ok(instance",
          "476:         .get_runtime_memory(memory)",
          "477:         .atomic_wait64(addr_index, expected, timeout)? as u32)",
          "481: unsafe fn out_of_gas(instance: &mut Instance) -> Result<()> {",
          "482:     (*instance.store()).out_of_gas()",
          "486: unsafe fn new_epoch(instance: &mut Instance) -> Result<u64> {",
          "487:     (*instance.store()).new_epoch()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "36fb62ca3bea7dd1456f12ead03084e2ceb48cda",
      "candidate_info": {
        "commit_hash": "36fb62ca3bea7dd1456f12ead03084e2ceb48cda",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/36fb62ca3bea7dd1456f12ead03084e2ceb48cda",
        "files": [
          "crates/environ/src/module.rs",
          "crates/environ/src/module_environ.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/table.rs",
          "crates/wast/src/spectest.rs",
          "tests/all/wast.rs",
          "tests/spec_testsuite"
        ],
        "message": "Support `global.get` in more constant expressions (#7996)\n\nThis commit updates Wasmtime to support `global.get` in constant\nexpressions when located in table initializers and element segments.\nPre-reference-types this never came up because there was no valid\n`global.get` that would typecheck. After the reference-types proposal\nlanded however this became possible but Wasmtime did not support it.\nThis was surfaced in #6705 when the spec test suite was updated and has\na new test that exercises this functionality.\n\nThis commit both updates the spec test suite and additionally adds\nsupport for this new form of element segment and table initialization\nexpression.\n\nThe fact that Wasmtime hasn't supported this until now also means that\nwe have a gap in our fuzz-testing infrastructure. The `wasm-smith`\ngenerator is being updated in bytecodealliance/wasm-tools#1426 to\ngenerate modules with this particular feature and I've tested that with\nthat PR fuzzing here eventually generates an error before this PR.\n\nCloses #6705",
        "before_after_code_files": [
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/environ/src/module_environ.rs||crates/environ/src/module_environ.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/table.rs||crates/runtime/src/table.rs",
          "crates/wast/src/spectest.rs||crates/wast/src/spectest.rs",
          "tests/all/wast.rs||tests/all/wast.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ],
          "candidate": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "463:                 Some(top) => top,",
          "464:                 None => break,",
          "465:             };",
          "",
          "[Removed Lines]",
          "462:             let top = match segment.offset.checked_add(segment.elements.len() as u32) {",
          "",
          "[Added Lines]",
          "462:             let top = match segment.offset.checked_add(segment.elements.len()) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "482:                 WasmHeapType::Extern => break,",
          "483:             }",
          "485:             let precomputed =",
          "486:                 match &mut self.module.table_initialization.initial_values[defined_index] {",
          "487:                     TableInitialValue::Null { precomputed } => precomputed,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487:             let function_elements = match &segment.elements {",
          "488:                 TableSegmentElements::Functions(indices) => indices,",
          "489:                 TableSegmentElements::Expressions(_) => break,",
          "490:             };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "496:                 };",
          "",
          "[Removed Lines]",
          "495:                     TableInitialValue::FuncRef(_) => break,",
          "",
          "[Added Lines]",
          "502:                     TableInitialValue::FuncRef(_) | TableInitialValue::GlobalGet(_) => break,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "504:                 precomputed.resize(top as usize, FuncIndex::reserved_value());",
          "505:             }",
          "506:             let dst = &mut precomputed[(segment.offset as usize)..(top as usize)];",
          "510:             let _ = segments.next();",
          "",
          "[Removed Lines]",
          "507:             dst.copy_from_slice(&segment.elements[..]);",
          "",
          "[Added Lines]",
          "514:             dst.copy_from_slice(&function_elements);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "759:     FuncRef(FuncIndex),",
          "760: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "770:     GlobalGet(GlobalIndex),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "770:     pub offset: u32,",
          "773: }",
          "",
          "[Removed Lines]",
          "772:     pub elements: Box<[FuncIndex]>,",
          "",
          "[Added Lines]",
          "783:     pub elements: TableSegmentElements,",
          "784: }",
          "788: #[derive(Clone, Debug, Serialize, Deserialize)]",
          "789: pub enum TableSegmentElements {",
          "792:     Functions(Box<[FuncIndex]>),",
          "794:     Expressions(Box<[TableElementExpression]>),",
          "795: }",
          "797: impl TableSegmentElements {",
          "799:     pub fn len(&self) -> u32 {",
          "800:         match self {",
          "801:             Self::Functions(s) => s.len() as u32,",
          "802:             Self::Expressions(s) => s.len() as u32,",
          "803:         }",
          "804:     }",
          "805: }",
          "808: #[derive(Clone, Debug, Serialize, Deserialize)]",
          "809: pub enum TableElementExpression {",
          "811:     Function(FuncIndex),",
          "813:     GlobalGet(GlobalIndex),",
          "815:     Null,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "815:     pub memory_initialization: MemoryInitialization,",
          "821:     pub passive_elements_map: BTreeMap<ElemIndex, usize>,",
          "",
          "[Removed Lines]",
          "818:     pub passive_elements: Vec<Box<[FuncIndex]>>,",
          "",
          "[Added Lines]",
          "861:     pub passive_elements: Vec<TableSegmentElements>,",
          "",
          "---------------"
        ],
        "crates/environ/src/module_environ.rs||crates/environ/src/module_environ.rs": [
          "File: crates/environ/src/module_environ.rs -> crates/environ/src/module_environ.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::module::{",
          "2:     FuncRefIndex, Initializer, MemoryInitialization, MemoryInitializer, MemoryPlan, Module,",
          "4: };",
          "5: use crate::{",
          "6:     DataIndex, DefinedFuncIndex, ElemIndex, EntityIndex, EntityType, FuncIndex, GlobalIndex,",
          "",
          "[Removed Lines]",
          "3:     ModuleType, TablePlan, TableSegment,",
          "",
          "[Added Lines]",
          "3:     ModuleType, TableElementExpression, TablePlan, TableSegment, TableSegmentElements,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8:     Tunables, TypeConvert, TypeIndex, Unsigned, WasmError, WasmHeapType, WasmResult, WasmValType,",
          "9:     WasmparserTypeConverter,",
          "10: };",
          "12: use std::borrow::Cow;",
          "13: use std::collections::HashMap;",
          "14: use std::path::PathBuf;",
          "",
          "[Removed Lines]",
          "11: use cranelift_entity::packed_option::ReservedValue;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "320:                                     self.flag_func_escaped(index);",
          "321:                                     TableInitialValue::FuncRef(index)",
          "322:                                 }",
          "323:                                 s => {",
          "324:                                     return Err(WasmError::Unsupported(format!(",
          "325:                                         \"unsupported init expr in table section: {:?}\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322:                                 Operator::GlobalGet { global_index } => {",
          "323:                                     let index = GlobalIndex::from_u32(global_index);",
          "324:                                     TableInitialValue::GlobalGet(index)",
          "325:                                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "454:                         ElementItems::Functions(funcs) => {",
          "456:                             for func in funcs {",
          "457:                                 let func = FuncIndex::from_u32(func?);",
          "458:                                 self.flag_func_escaped(func);",
          "460:                             }",
          "461:                         }",
          "467:                                     Operator::RefFunc { function_index } => {",
          "468:                                         let func = FuncIndex::from_u32(function_index);",
          "469:                                         self.flag_func_escaped(func);",
          "471:                                     }",
          "472:                                     s => {",
          "473:                                         return Err(WasmError::Unsupported(format!(",
          "",
          "[Removed Lines]",
          "452:                     let mut elements = Vec::new();",
          "453:                     match items {",
          "455:                             elements.reserve(usize::try_from(funcs.count()).unwrap());",
          "459:                                 elements.push(func);",
          "462:                         ElementItems::Expressions(_ty, funcs) => {",
          "463:                             elements.reserve(usize::try_from(funcs.count()).unwrap());",
          "464:                             for func in funcs {",
          "465:                                 let func = match func?.get_binary_reader().read_operator()? {",
          "466:                                     Operator::RefNull { .. } => FuncIndex::reserved_value(),",
          "470:                                         func",
          "",
          "[Added Lines]",
          "455:                     let elements = match items {",
          "457:                             let mut elems =",
          "458:                                 Vec::with_capacity(usize::try_from(funcs.count()).unwrap());",
          "462:                                 elems.push(func);",
          "464:                             TableSegmentElements::Functions(elems.into())",
          "466:                         ElementItems::Expressions(_ty, items) => {",
          "467:                             let mut exprs =",
          "468:                                 Vec::with_capacity(usize::try_from(items.count()).unwrap());",
          "469:                             for expr in items {",
          "470:                                 let expr = match expr?.get_binary_reader().read_operator()? {",
          "471:                                     Operator::RefNull { .. } => TableElementExpression::Null,",
          "475:                                         TableElementExpression::Function(func)",
          "476:                                     }",
          "477:                                     Operator::GlobalGet { global_index } => {",
          "478:                                         let global = GlobalIndex::from_u32(global_index);",
          "479:                                         TableElementExpression::GlobalGet(global)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "476:                                         )));",
          "477:                                     }",
          "478:                                 };",
          "480:                             }",
          "481:                         }",
          "484:                     match kind {",
          "485:                         ElementKind::Active {",
          "",
          "[Removed Lines]",
          "479:                                 elements.push(func);",
          "482:                     }",
          "",
          "[Added Lines]",
          "488:                                 exprs.push(expr);",
          "490:                             TableSegmentElements::Expressions(exprs.into())",
          "492:                     };",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: use wasmtime_environ::{",
          "30:     packed_option::ReservedValue, DataIndex, DefinedGlobalIndex, DefinedMemoryIndex,",
          "31:     DefinedTableIndex, ElemIndex, EntityIndex, EntityRef, EntitySet, FuncIndex, GlobalIndex,",
          "34: };",
          "35: #[cfg(feature = \"wmemcheck\")]",
          "36: use wasmtime_wmemcheck::Wmemcheck;",
          "",
          "[Removed Lines]",
          "32:     GlobalInit, HostPtr, MemoryIndex, MemoryPlan, Module, PrimaryMap, TableIndex,",
          "33:     TableInitialValue, Trap, VMOffsets, WasmHeapType, WasmRefType, WasmValType, VMCONTEXT_MAGIC,",
          "",
          "[Added Lines]",
          "32:     GlobalInit, HostPtr, MemoryIndex, MemoryPlan, Module, PrimaryMap, TableElementExpression,",
          "33:     TableIndex, TableInitialValue, TableSegmentElements, Trap, VMOffsets, WasmHeapType,",
          "34:     WasmRefType, WasmValType, VMCONTEXT_MAGIC,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "805:         let module = self.module().clone();",
          "807:         let elements = match module.passive_elements_map.get(&elem_index) {",
          "808:             Some(index) if !self.dropped_elements.contains(elem_index) => {",
          "810:             }",
          "812:         };",
          "813:         self.table_init_segment(table_index, elements, dst, src, len)",
          "814:     }",
          "",
          "[Removed Lines]",
          "809:                 module.passive_elements[*index].as_ref()",
          "811:             _ => &[],",
          "",
          "[Added Lines]",
          "808:         let empty = TableSegmentElements::Functions(Box::new([]));",
          "811:                 &module.passive_elements[*index]",
          "813:             _ => &empty,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "816:     pub(crate) fn table_init_segment(",
          "817:         &mut self,",
          "818:         table_index: TableIndex,",
          "820:         dst: u32,",
          "821:         src: u32,",
          "822:         len: u32,",
          "",
          "[Removed Lines]",
          "819:         elements: &[FuncIndex],",
          "",
          "[Added Lines]",
          "821:         elements: &TableSegmentElements,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "826:         let table = unsafe { &mut *self.get_table(table_index) };",
          "839:                     dst,",
          "843:                 )?;",
          "844:             }",
          "849:             }",
          "850:         }",
          "851:         Ok(())",
          "852:     }",
          "",
          "[Removed Lines]",
          "828:         let elements = match elements",
          "829:             .get(usize::try_from(src).unwrap()..)",
          "830:             .and_then(|s| s.get(..usize::try_from(len).unwrap()))",
          "831:         {",
          "832:             Some(elements) => elements,",
          "833:             None => return Err(Trap::TableOutOfBounds),",
          "834:         };",
          "836:         match table.element_type() {",
          "837:             TableElementType::Func => {",
          "838:                 table.init_funcs(",
          "840:                     elements",
          "841:                         .iter()",
          "842:                         .map(|idx| self.get_func_ref(*idx).unwrap_or(std::ptr::null_mut())),",
          "846:             TableElementType::Extern => {",
          "847:                 debug_assert!(elements.iter().all(|e| *e == FuncIndex::reserved_value()));",
          "848:                 table.fill(dst, TableElement::ExternRef(None), len)?;",
          "",
          "[Added Lines]",
          "829:         let src = usize::try_from(src).map_err(|_| Trap::TableOutOfBounds)?;",
          "830:         let len = usize::try_from(len).map_err(|_| Trap::TableOutOfBounds)?;",
          "832:         match elements {",
          "833:             TableSegmentElements::Functions(funcs) => {",
          "834:                 let elements = funcs",
          "835:                     .get(src..)",
          "836:                     .and_then(|s| s.get(..len))",
          "837:                     .ok_or(Trap::TableOutOfBounds)?;",
          "838:                 table.init(",
          "840:                     elements.iter().map(|idx| {",
          "841:                         TableElement::FuncRef(",
          "842:                             self.get_func_ref(*idx).unwrap_or(std::ptr::null_mut()),",
          "843:                         )",
          "844:                     }),",
          "847:             TableSegmentElements::Expressions(exprs) => {",
          "848:                 let ty = table.element_type();",
          "849:                 let exprs = exprs",
          "850:                     .get(src..)",
          "851:                     .and_then(|s| s.get(..len))",
          "852:                     .ok_or(Trap::TableOutOfBounds)?;",
          "853:                 table.init(",
          "854:                     dst,",
          "855:                     exprs.iter().map(|expr| match ty {",
          "856:                         TableElementType::Func => {",
          "857:                             let funcref = match expr {",
          "858:                                 TableElementExpression::Null => std::ptr::null_mut(),",
          "859:                                 TableElementExpression::Function(idx) => {",
          "860:                                     self.get_func_ref(*idx).unwrap()",
          "861:                                 }",
          "862:                                 TableElementExpression::GlobalGet(idx) => {",
          "863:                                     let global = self.defined_or_imported_global_ptr(*idx);",
          "864:                                     unsafe { (*global).as_func_ref() }",
          "865:                                 }",
          "866:                             };",
          "867:                             TableElement::FuncRef(funcref)",
          "868:                         }",
          "869:                         TableElementType::Extern => {",
          "870:                             let externref = match expr {",
          "871:                                 TableElementExpression::Null => None,",
          "872:                                 TableElementExpression::Function(_) => unreachable!(),",
          "873:                                 TableElementExpression::GlobalGet(idx) => {",
          "874:                                     let global = self.defined_or_imported_global_ptr(*idx);",
          "875:                                     unsafe { (*global).as_externref().clone() }",
          "876:                                 }",
          "877:                             };",
          "878:                             TableElement::ExternRef(externref)",
          "879:                         }",
          "880:                     }),",
          "881:                 )?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1060:                 let module = self.module();",
          "1061:                 let precomputed = match &module.table_initialization.initial_values[idx] {",
          "1062:                     TableInitialValue::Null { precomputed } => precomputed,",
          "1064:                 };",
          "1065:                 let func_index = precomputed.get(i as usize).cloned();",
          "1066:                 let func_ref = func_index",
          "",
          "[Removed Lines]",
          "1063:                     TableInitialValue::FuncRef(_) => unreachable!(),",
          "",
          "[Added Lines]",
          "1097:                     TableInitialValue::FuncRef(_) | TableInitialValue::GlobalGet(_) => {",
          "1098:                         unreachable!()",
          "1099:                     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "507:         let table = unsafe { &*instance.get_table(segment.table_index) };",
          "508:         let start = get_table_init_start(segment, instance)?;",
          "509:         let start = usize::try_from(start).unwrap();",
          "512:         match end {",
          "513:             Some(end) if end <= table.size() as usize => {",
          "",
          "[Removed Lines]",
          "510:         let end = start.checked_add(segment.elements.len());",
          "",
          "[Added Lines]",
          "510:         let end = start.checked_add(usize::try_from(segment.elements.len()).unwrap());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "533:                 let table = unsafe { &mut *instance.get_defined_table(table) };",
          "534:                 table.init_func(funcref)?;",
          "535:             }",
          "536:         }",
          "537:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "537:             TableInitialValue::GlobalGet(idx) => unsafe {",
          "538:                 let global = instance.defined_or_imported_global_ptr(*idx);",
          "539:                 let funcref = (*global).as_func_ref();",
          "540:                 let table = &mut *instance.get_defined_table(table);",
          "541:                 table.init_func(funcref)?;",
          "542:             },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "550:             &segment.elements,",
          "551:             start,",
          "552:             0,",
          "554:         )?;",
          "555:     }",
          "",
          "[Removed Lines]",
          "553:             segment.elements.len() as u32,",
          "",
          "[Added Lines]",
          "560:             segment.elements.len(),",
          "",
          "---------------"
        ],
        "crates/runtime/src/table.rs||crates/runtime/src/table.rs": [
          "File: crates/runtime/src/table.rs -> crates/runtime/src/table.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     Extern,",
          "40: }",
          "44: unsafe impl Send for TableElement where VMExternRef: Send {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: impl TableElementType {",
          "43:     fn matches(&self, val: &TableElement) -> bool {",
          "44:         match (val, self) {",
          "45:             (TableElement::FuncRef(_), TableElementType::Func) => true,",
          "46:             (TableElement::ExternRef(_), TableElementType::Extern) => true,",
          "47:             _ => false,",
          "48:         }",
          "49:     }",
          "50: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "297:         &mut self,",
          "298:         dst: u32,",
          "300:     ) -> Result<(), Trap> {",
          "303:         let elements = match self",
          "304:             .elements_mut()",
          "",
          "[Removed Lines]",
          "296:     pub fn init_funcs(",
          "299:         items: impl ExactSizeIterator<Item = *mut VMFuncRef>,",
          "301:         assert!(self.element_type() == TableElementType::Func);",
          "",
          "[Added Lines]",
          "306:     pub fn init(",
          "309:         items: impl ExactSizeIterator<Item = TableElement>,",
          "311:         let ty = self.element_type();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "310:         };",
          "312:         for (item, slot) in items.zip(elements) {",
          "313:             unsafe {",
          "315:             }",
          "316:         }",
          "317:         Ok(())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "323:             debug_assert!(ty.matches(&item));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "493:     }",
          "495:     fn type_matches(&self, val: &TableElement) -> bool {",
          "501:     }",
          "503:     fn elements(&self) -> &[TableValue] {",
          "",
          "[Removed Lines]",
          "496:         match (&val, self.element_type()) {",
          "497:             (TableElement::FuncRef(_), TableElementType::Func) => true,",
          "498:             (TableElement::ExternRef(_), TableElementType::Extern) => true,",
          "499:             _ => false,",
          "500:         }",
          "",
          "[Added Lines]",
          "507:         self.element_type().matches(val)",
          "",
          "---------------"
        ],
        "crates/wast/src/spectest.rs||crates/wast/src/spectest.rs": [
          "File: crates/wast/src/spectest.rs -> crates/wast/src/spectest.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     linker.define(&mut *store, \"spectest\", \"global_i64\", g)?;",
          "32:     let ty = GlobalType::new(ValType::F32, Mutability::Const);",
          "34:     linker.define(&mut *store, \"spectest\", \"global_f32\", g)?;",
          "36:     let ty = GlobalType::new(ValType::F64, Mutability::Const);",
          "38:     linker.define(&mut *store, \"spectest\", \"global_f64\", g)?;",
          "40:     let ty = TableType::new(RefType::FUNCREF, 10, Some(20));",
          "",
          "[Removed Lines]",
          "33:     let g = Global::new(&mut *store, ty, Val::F32(0x4426_8000))?;",
          "37:     let g = Global::new(&mut *store, ty, Val::F64(0x4084_d000_0000_0000))?;",
          "",
          "[Added Lines]",
          "33:     let g = Global::new(&mut *store, ty, Val::F32(0x4426_a666))?;",
          "37:     let g = Global::new(&mut *store, ty, Val::F64(0x4084_d4cc_cccc_cccd))?;",
          "",
          "---------------"
        ],
        "tests/all/wast.rs||tests/all/wast.rs": [
          "File: tests/all/wast.rs -> tests/all/wast.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:             .max_memory_protection_keys(2)",
          "134:             .memory_pages(805)",
          "135:             .max_memories_per_module(if multi_memory { 9 } else { 1 })",
          "",
          "[Removed Lines]",
          "136:             .max_tables_per_module(4);",
          "",
          "[Added Lines]",
          "136:             .max_tables_per_module(5);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
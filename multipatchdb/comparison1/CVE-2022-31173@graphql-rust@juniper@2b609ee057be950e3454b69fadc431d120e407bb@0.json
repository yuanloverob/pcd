{
  "cve_id": "CVE-2022-31173",
  "cve_desc": "Juniper is a GraphQL server library for Rust. Affected versions of Juniper are vulnerable to uncontrolled recursion resulting in a program crash. This issue has been addressed in version 0.15.10. Users are advised to upgrade. Users unable to upgrade should limit the recursion depth manually.",
  "repo": "graphql-rust/juniper",
  "patch_hash": "2b609ee057be950e3454b69fadc431d120e407bb",
  "patch_info": {
    "commit_hash": "2b609ee057be950e3454b69fadc431d120e407bb",
    "repo": "graphql-rust/juniper",
    "commit_url": "https://github.com/graphql-rust/juniper/commit/2b609ee057be950e3454b69fadc431d120e407bb",
    "files": [
      "juniper/src/validation/rules/no_fragment_cycles.rs",
      "juniper/src/validation/rules/no_undefined_variables.rs",
      "juniper/src/validation/rules/no_unused_fragments.rs",
      "juniper/src/validation/rules/no_unused_variables.rs",
      "juniper/src/validation/rules/overlapping_fields_can_be_merged.rs",
      "juniper/src/validation/rules/variables_in_allowed_position.rs",
      "tests/integration/Cargo.toml",
      "tests/integration/tests/cve_2022_31173.rs"
    ],
    "message": "Merge pull request from GHSA-4rx6-g5vg-5f3j\n\n* Replace recursions with heap allocations\n\n* Some corrections [skip ci]\n\n* Add recursive nested fragments test case\n\n* Docs and small corrections\n\n* Corrections\n\nCo-authored-by: Kai Ren <tyranron@gmail.com>",
    "before_after_code_files": [
      "juniper/src/validation/rules/no_fragment_cycles.rs||juniper/src/validation/rules/no_fragment_cycles.rs",
      "juniper/src/validation/rules/no_undefined_variables.rs||juniper/src/validation/rules/no_undefined_variables.rs",
      "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs",
      "juniper/src/validation/rules/no_unused_variables.rs||juniper/src/validation/rules/no_unused_variables.rs",
      "juniper/src/validation/rules/overlapping_fields_can_be_merged.rs||juniper/src/validation/rules/overlapping_fields_can_be_merged.rs",
      "juniper/src/validation/rules/variables_in_allowed_position.rs||juniper/src/validation/rules/variables_in_allowed_position.rs",
      "tests/integration/tests/cve_2022_31173.rs||tests/integration/tests/cve_2022_31173.rs"
    ]
  },
  "patch_diff": {
    "juniper/src/validation/rules/no_fragment_cycles.rs||juniper/src/validation/rules/no_fragment_cycles.rs": [
      "File: juniper/src/validation/rules/no_fragment_cycles.rs -> juniper/src/validation/rules/no_fragment_cycles.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "7:     value::ScalarValue,",
      "8: };",
      "23: pub fn factory<'a>() -> NoFragmentCycles<'a> {",
      "24:     NoFragmentCycles {",
      "25:         current_fragment: None,",
      "",
      "[Removed Lines]",
      "10: pub struct NoFragmentCycles<'a> {",
      "11:     current_fragment: Option<&'a str>,",
      "12:     spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,",
      "13:     fragment_order: Vec<&'a str>,",
      "14: }",
      "16: struct CycleDetector<'a> {",
      "17:     visited: HashSet<&'a str>,",
      "18:     spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,",
      "19:     path_indices: HashMap<&'a str, usize>,",
      "20:     errors: Vec<RuleError>,",
      "21: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28:     }",
      "29: }",
      "31: impl<'a, S> Visitor<'a, S> for NoFragmentCycles<'a>",
      "32: where",
      "33:     S: ScalarValue,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: pub struct NoFragmentCycles<'a> {",
      "19:     current_fragment: Option<&'a str>,",
      "20:     spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,",
      "21:     fragment_order: Vec<&'a str>,",
      "22: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "38:         let mut detector = CycleDetector {",
      "39:             visited: HashSet::new(),",
      "40:             spreads: &self.spreads,",
      "42:             errors: Vec::new(),",
      "43:         };",
      "45:         for frag in &self.fragment_order {",
      "46:             if !detector.visited.contains(frag) {",
      "49:             }",
      "50:         }",
      "",
      "[Removed Lines]",
      "41:             path_indices: HashMap::new(),",
      "47:                 let mut path = Vec::new();",
      "48:                 detector.detect_from(frag, &mut path);",
      "",
      "[Added Lines]",
      "39:                 detector.detect_from(frag);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "91:     }",
      "92: }",
      "94: impl<'a> CycleDetector<'a> {",
      "96:         self.visited.insert(from);",
      "98:         if !self.spreads.contains_key(from) {",
      "100:         }",
      "104:         for node in &self.spreads[from] {",
      "108:             if let Some(index) = index {",
      "109:                 let err_pos = if index < path.len() {",
      "",
      "[Removed Lines]",
      "95:     fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {",
      "99:             return;",
      "102:         self.path_indices.insert(from, path.len());",
      "105:             let name = &node.item;",
      "106:             let index = self.path_indices.get(name).cloned();",
      "",
      "[Added Lines]",
      "85: type CycleDetectorState<'a> = (&'a str, Vec<&'a Spanning<&'a str>>, HashMap<&'a str, usize>);",
      "87: struct CycleDetector<'a> {",
      "88:     visited: HashSet<&'a str>,",
      "89:     spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,",
      "90:     errors: Vec<RuleError>,",
      "91: }",
      "94:     fn detect_from(&mut self, from: &'a str) {",
      "95:         let mut to_visit = Vec::new();",
      "96:         to_visit.push((from, Vec::new(), HashMap::new()));",
      "98:         while let Some((from, path, path_indices)) = to_visit.pop() {",
      "99:             to_visit.extend(self.detect_from_inner(from, path, path_indices));",
      "100:         }",
      "101:     }",
      "107:     fn detect_from_inner(",
      "108:         &mut self,",
      "109:         from: &'a str,",
      "110:         path: Vec<&'a Spanning<&'a str>>,",
      "111:         mut path_indices: HashMap<&'a str, usize>,",
      "112:     ) -> Vec<CycleDetectorState<'a>> {",
      "116:             return Vec::new();",
      "119:         path_indices.insert(from, path.len());",
      "121:         let mut to_visit = Vec::new();",
      "123:             let name = node.item;",
      "124:             let index = path_indices.get(name).cloned();",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "115:                 self.errors",
      "116:                     .push(RuleError::new(&error_message(name), &[err_pos.start]));",
      "118:                 path.push(node);",
      "121:             }",
      "122:         }",
      "125:     }",
      "126: }",
      "",
      "[Removed Lines]",
      "117:             } else if !self.visited.contains(name) {",
      "119:                 self.detect_from(name, path);",
      "120:                 path.pop();",
      "124:         self.path_indices.remove(from);",
      "",
      "[Added Lines]",
      "135:             } else {",
      "136:                 let mut path = path.clone();",
      "138:                 to_visit.push((name, path, path_indices.clone()));",
      "142:         to_visit",
      "",
      "---------------"
    ],
    "juniper/src/validation/rules/no_undefined_variables.rs||juniper/src/validation/rules/no_undefined_variables.rs": [
      "File: juniper/src/validation/rules/no_undefined_variables.rs -> juniper/src/validation/rules/no_undefined_variables.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "12:     Fragment(&'a str),",
      "13: }",
      "22: pub fn factory<'a>() -> NoUndefinedVariables<'a> {",
      "23:     NoUndefinedVariables {",
      "24:         defined_variables: HashMap::new(),",
      "",
      "[Removed Lines]",
      "15: pub struct NoUndefinedVariables<'a> {",
      "16:     defined_variables: HashMap<Option<&'a str>, (SourcePosition, HashSet<&'a str>)>,",
      "17:     used_variables: HashMap<Scope<'a>, Vec<Spanning<&'a str>>>,",
      "18:     current_scope: Option<Scope<'a>>,",
      "19:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "20: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28:     }",
      "29: }",
      "31: impl<'a> NoUndefinedVariables<'a> {",
      "32:     fn find_undef_vars(",
      "33:         &'a self,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "24: pub struct NoUndefinedVariables<'a> {",
      "25:     defined_variables: HashMap<Option<&'a str>, (SourcePosition, HashSet<&'a str>)>,",
      "26:     used_variables: HashMap<Scope<'a>, Vec<Spanning<&'a str>>>,",
      "27:     current_scope: Option<Scope<'a>>,",
      "28:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "29: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "36:         unused: &mut Vec<&'a Spanning<&'a str>>,",
      "37:         visited: &mut HashSet<Scope<'a>>,",
      "38:     ) {",
      "39:         if visited.contains(scope) {",
      "41:         }",
      "43:         visited.insert(scope.clone());",
      "",
      "[Removed Lines]",
      "40:             return;",
      "",
      "[Added Lines]",
      "39:         let mut to_visit = Vec::new();",
      "40:         if let Some(spreads) = self.find_undef_vars_inner(scope, defined, unused, visited) {",
      "41:             to_visit.push(spreads);",
      "42:         }",
      "43:         while let Some(spreads) = to_visit.pop() {",
      "44:             for spread in spreads {",
      "45:                 if let Some(spreads) =",
      "46:                     self.find_undef_vars_inner(&Scope::Fragment(spread), defined, unused, visited)",
      "47:                 {",
      "48:                     to_visit.push(spreads);",
      "49:                 }",
      "50:             }",
      "51:         }",
      "52:     }",
      "58:     fn find_undef_vars_inner(",
      "59:         &'a self,",
      "60:         scope: &Scope<'a>,",
      "61:         defined: &HashSet<&'a str>,",
      "62:         unused: &mut Vec<&'a Spanning<&'a str>>,",
      "63:         visited: &mut HashSet<Scope<'a>>,",
      "64:     ) -> Option<&'a Vec<&'a str>> {",
      "66:             return None;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "50:             }",
      "51:         }",
      "58:     }",
      "59: }",
      "",
      "[Removed Lines]",
      "53:         if let Some(spreads) = self.spreads.get(scope) {",
      "54:             for spread in spreads {",
      "55:                 self.find_undef_vars(&Scope::Fragment(spread), defined, unused, visited);",
      "56:             }",
      "57:         }",
      "",
      "[Added Lines]",
      "79:         self.spreads.get(scope)",
      "",
      "---------------"
    ],
    "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs": [
      "File: juniper/src/validation/rules/no_unused_fragments.rs -> juniper/src/validation/rules/no_unused_fragments.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "13:     Fragment(&'a str),",
      "14: }",
      "22: pub fn factory<'a>() -> NoUnusedFragments<'a> {",
      "23:     NoUnusedFragments {",
      "24:         spreads: HashMap::new(),",
      "",
      "[Removed Lines]",
      "16: pub struct NoUnusedFragments<'a> {",
      "17:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "18:     defined_fragments: HashSet<Spanning<&'a str>>,",
      "19:     current_scope: Option<Scope<'a>>,",
      "20: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "27:     }",
      "28: }",
      "30: impl<'a> NoUnusedFragments<'a> {",
      "32:         if let Scope::Fragment(name) = *from {",
      "38:         }",
      "43:             }",
      "44:         }",
      "45:     }",
      "46: }",
      "48: impl<'a, S> Visitor<'a, S> for NoUnusedFragments<'a>",
      "",
      "[Removed Lines]",
      "31:     fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {",
      "33:             if result.contains(name) {",
      "34:                 return;",
      "35:             } else {",
      "36:                 result.insert(name);",
      "37:             }",
      "40:         if let Some(spreads) = self.spreads.get(from) {",
      "41:             for spread in spreads {",
      "42:                 self.find_reachable_fragments(&Scope::Fragment(spread), result)",
      "",
      "[Added Lines]",
      "24: pub struct NoUnusedFragments<'a> {",
      "25:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "26:     defined_fragments: HashSet<Spanning<&'a str>>,",
      "27:     current_scope: Option<Scope<'a>>,",
      "28: }",
      "31:     fn find_reachable_fragments(&'a self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {",
      "32:         let mut to_visit = Vec::new();",
      "34:             to_visit.push(name);",
      "37:         while let Some(from) = to_visit.pop() {",
      "38:             if let Some(next) = self.find_reachable_fragments_inner(from, result) {",
      "39:                 to_visit.extend(next);",
      "48:     fn find_reachable_fragments_inner(",
      "49:         &'a self,",
      "50:         from: &'a str,",
      "51:         result: &mut HashSet<&'a str>,",
      "52:     ) -> Option<&'a Vec<&'a str>> {",
      "53:         if result.contains(from) {",
      "54:             return None;",
      "55:         } else {",
      "56:             result.insert(from);",
      "57:         }",
      "59:         self.spreads.get(&Scope::Fragment(from))",
      "60:     }",
      "",
      "---------------"
    ],
    "juniper/src/validation/rules/no_unused_variables.rs||juniper/src/validation/rules/no_unused_variables.rs": [
      "File: juniper/src/validation/rules/no_unused_variables.rs -> juniper/src/validation/rules/no_unused_variables.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "12:     Fragment(&'a str),",
      "13: }",
      "22: pub fn factory<'a>() -> NoUnusedVariables<'a> {",
      "23:     NoUnusedVariables {",
      "24:         defined_variables: HashMap::new(),",
      "",
      "[Removed Lines]",
      "15: pub struct NoUnusedVariables<'a> {",
      "16:     defined_variables: HashMap<Option<&'a str>, HashSet<&'a Spanning<&'a str>>>,",
      "17:     used_variables: HashMap<Scope<'a>, Vec<&'a str>>,",
      "18:     current_scope: Option<Scope<'a>>,",
      "19:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "20: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "28:     }",
      "29: }",
      "31: impl<'a> NoUnusedVariables<'a> {",
      "32:     fn find_used_vars(",
      "34:         from: &Scope<'a>,",
      "35:         defined: &HashSet<&'a str>,",
      "36:         used: &mut HashSet<&'a str>,",
      "37:         visited: &mut HashSet<Scope<'a>>,",
      "38:     ) {",
      "39:         if visited.contains(from) {",
      "41:         }",
      "43:         visited.insert(from.clone());",
      "",
      "[Removed Lines]",
      "33:         &self,",
      "40:             return;",
      "",
      "[Added Lines]",
      "24: pub struct NoUnusedVariables<'a> {",
      "25:     defined_variables: HashMap<Option<&'a str>, HashSet<&'a Spanning<&'a str>>>,",
      "26:     used_variables: HashMap<Scope<'a>, Vec<&'a str>>,",
      "27:     current_scope: Option<Scope<'a>>,",
      "28:     spreads: HashMap<Scope<'a>, Vec<&'a str>>,",
      "29: }",
      "33:         &'a self,",
      "39:         let mut to_visit = Vec::new();",
      "40:         if let Some(spreads) = self.find_used_vars_inner(from, defined, used, visited) {",
      "41:             to_visit.push(spreads);",
      "42:         }",
      "43:         while let Some(spreads) = to_visit.pop() {",
      "44:             for spread in spreads {",
      "45:                 if let Some(spreads) =",
      "46:                     self.find_used_vars_inner(&Scope::Fragment(spread), defined, used, visited)",
      "47:                 {",
      "48:                     to_visit.push(spreads);",
      "49:                 }",
      "50:             }",
      "51:         }",
      "52:     }",
      "58:     fn find_used_vars_inner(",
      "59:         &'a self,",
      "60:         from: &Scope<'a>,",
      "61:         defined: &HashSet<&'a str>,",
      "62:         used: &mut HashSet<&'a str>,",
      "63:         visited: &mut HashSet<Scope<'a>>,",
      "64:     ) -> Option<&'a Vec<&'a str>> {",
      "66:             return None;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "50:             }",
      "51:         }",
      "58:     }",
      "59: }",
      "",
      "[Removed Lines]",
      "53:         if let Some(spreads) = self.spreads.get(from) {",
      "54:             for spread in spreads {",
      "55:                 self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);",
      "56:             }",
      "57:         }",
      "",
      "[Added Lines]",
      "79:         self.spreads.get(from)",
      "",
      "---------------"
    ],
    "juniper/src/validation/rules/overlapping_fields_can_be_merged.rs||juniper/src/validation/rules/overlapping_fields_can_be_merged.rs": [
      "File: juniper/src/validation/rules/overlapping_fields_can_be_merged.rs -> juniper/src/validation/rules/overlapping_fields_can_be_merged.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "274:     ) where",
      "275:         S: ScalarValue,",
      "276:     {",
      "282:         let (field_map2, fragment_names2) =",
      "283:             self.get_referenced_fields_and_fragment_names(fragment, ctx);",
      "285:         self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);",
      "301:     }",
      "303:     fn collect_conflicts_between(",
      "",
      "[Removed Lines]",
      "277:         let fragment = match self.named_fragments.get(fragment_name) {",
      "278:             Some(f) => f,",
      "279:             None => return,",
      "280:         };",
      "287:         for fragment_name2 in fragment_names2 {",
      "290:             if fragment_name == fragment_name2 {",
      "291:                 return;",
      "292:             }",
      "293:             self.collect_conflicts_between_fields_and_fragment(",
      "294:                 conflicts,",
      "295:                 field_map,",
      "296:                 fragment_name2,",
      "297:                 mutually_exclusive,",
      "298:                 ctx,",
      "299:             );",
      "300:         }",
      "",
      "[Added Lines]",
      "277:         let mut to_check = Vec::new();",
      "278:         if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(",
      "279:             conflicts,",
      "280:             field_map,",
      "281:             fragment_name,",
      "282:             mutually_exclusive,",
      "283:             ctx,",
      "284:         ) {",
      "285:             to_check.push((fragment_name, fragments))",
      "286:         }",
      "288:         while let Some((fragment_name, fragment_names2)) = to_check.pop() {",
      "289:             for fragment_name2 in fragment_names2 {",
      "292:                 if fragment_name == fragment_name2 {",
      "293:                     return;",
      "294:                 }",
      "295:                 if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(",
      "296:                     conflicts,",
      "297:                     field_map,",
      "298:                     fragment_name2,",
      "299:                     mutually_exclusive,",
      "300:                     ctx,",
      "301:                 ) {",
      "302:                     to_check.push((fragment_name2, fragments));",
      "303:                 };",
      "304:             }",
      "305:         }",
      "306:     }",
      "313:     fn collect_conflicts_between_fields_and_fragment_inner(",
      "314:         &self,",
      "315:         conflicts: &mut Vec<Conflict>,",
      "316:         field_map: &AstAndDefCollection<'a, S>,",
      "317:         fragment_name: &str,",
      "318:         mutually_exclusive: bool,",
      "319:         ctx: &ValidatorContext<'a, S>,",
      "320:     ) -> Option<Vec<&'a str>>",
      "321:     where",
      "322:         S: ScalarValue,",
      "323:     {",
      "324:         let fragment = self.named_fragments.get(fragment_name)?;",
      "331:         Some(fragment_names2)",
      "",
      "---------------"
    ],
    "juniper/src/validation/rules/variables_in_allowed_position.rs||juniper/src/validation/rules/variables_in_allowed_position.rs": [
      "File: juniper/src/validation/rules/variables_in_allowed_position.rs -> juniper/src/validation/rules/variables_in_allowed_position.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "17:     Fragment(&'a str),",
      "18: }",
      "28: pub fn factory<'a, S: fmt::Debug>() -> VariableInAllowedPosition<'a, S> {",
      "29:     VariableInAllowedPosition {",
      "30:         spreads: HashMap::new(),",
      "",
      "[Removed Lines]",
      "20: pub struct VariableInAllowedPosition<'a, S: fmt::Debug + 'a> {",
      "21:     spreads: HashMap<Scope<'a>, HashSet<&'a str>>,",
      "22:     variable_usages: HashMap<Scope<'a>, Vec<(Spanning<&'a String>, Type<'a>)>>,",
      "23:     #[allow(clippy::type_complexity)]",
      "24:     variable_defs: HashMap<Scope<'a>, Vec<&'a (Spanning<&'a str>, VariableDefinition<'a, S>)>>,",
      "25:     current_scope: Option<Scope<'a>>,",
      "26: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34:     }",
      "35: }",
      "37: impl<'a, S: fmt::Debug> VariableInAllowedPosition<'a, S> {",
      "40:         from: &Scope<'a>,",
      "41:         var_defs: &[&'a (Spanning<&'a str>, VariableDefinition<S>)],",
      "42:         ctx: &mut ValidatorContext<'a, S>,",
      "43:         visited: &mut HashSet<Scope<'a>>,",
      "44:     ) {",
      "45:         if visited.contains(from) {",
      "47:         }",
      "49:         visited.insert(from.clone());",
      "",
      "[Removed Lines]",
      "38:     fn collect_incorrect_usages(",
      "39:         &self,",
      "46:             return;",
      "",
      "[Added Lines]",
      "29: pub struct VariableInAllowedPosition<'a, S: fmt::Debug + 'a> {",
      "30:     spreads: HashMap<Scope<'a>, HashSet<&'a str>>,",
      "31:     variable_usages: HashMap<Scope<'a>, Vec<(Spanning<&'a String>, Type<'a>)>>,",
      "32:     #[allow(clippy::type_complexity)]",
      "33:     variable_defs: HashMap<Scope<'a>, Vec<&'a (Spanning<&'a str>, VariableDefinition<'a, S>)>>,",
      "34:     current_scope: Option<Scope<'a>>,",
      "35: }",
      "38:     fn collect_incorrect_usages<'me>(",
      "39:         &'me self,",
      "45:         let mut to_visit = Vec::new();",
      "46:         if let Some(spreads) = self.collect_incorrect_usages_inner(from, var_defs, ctx, visited) {",
      "47:             to_visit.push(spreads);",
      "48:         }",
      "50:         while let Some(spreads) = to_visit.pop() {",
      "51:             for spread in spreads {",
      "52:                 if let Some(spreads) = self.collect_incorrect_usages_inner(",
      "53:                     &Scope::Fragment(spread),",
      "54:                     var_defs,",
      "55:                     ctx,",
      "56:                     visited,",
      "57:                 ) {",
      "58:                     to_visit.push(spreads);",
      "59:                 }",
      "60:             }",
      "61:         }",
      "62:     }",
      "68:     fn collect_incorrect_usages_inner<'me>(",
      "69:         &'me self,",
      "70:         from: &Scope<'a>,",
      "71:         var_defs: &[&'a (Spanning<&'a str>, VariableDefinition<S>)],",
      "72:         ctx: &mut ValidatorContext<'a, S>,",
      "73:         visited: &mut HashSet<Scope<'a>>,",
      "74:     ) -> Option<&'me HashSet<&'a str>> {",
      "76:             return None;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "74:             }",
      "75:         }",
      "82:     }",
      "83: }",
      "",
      "[Removed Lines]",
      "77:         if let Some(spreads) = self.spreads.get(from) {",
      "78:             for spread in spreads {",
      "79:                 self.collect_incorrect_usages(&Scope::Fragment(spread), var_defs, ctx, visited);",
      "80:             }",
      "81:         }",
      "",
      "[Added Lines]",
      "107:         self.spreads.get(from)",
      "",
      "---------------"
    ],
    "tests/integration/tests/cve_2022_31173.rs||tests/integration/tests/cve_2022_31173.rs": [
      "File: tests/integration/tests/cve_2022_31173.rs -> tests/integration/tests/cve_2022_31173.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: use std::iter;",
      "20: use itertools::Itertools as _;",
      "21: use juniper::{graphql_object, graphql_vars, EmptyMutation, EmptySubscription};",
      "23: struct Query;",
      "25: #[graphql_object]",
      "26: impl Query {",
      "27:     fn dummy() -> bool {",
      "28:         false",
      "29:     }",
      "30: }",
      "32: type Schema = juniper::RootNode<'static, Query, EmptyMutation, EmptySubscription>;",
      "34: #[tokio::test]",
      "35: async fn test() {",
      "36:     const PERM: &str = \"abcefghijk\";",
      "37:     const CIRCLE_SIZE: usize = 7500;",
      "39:     let query = iter::once(format!(\"query {{ ...{PERM} }} \"))",
      "40:         .chain(",
      "41:             PERM.chars()",
      "42:                 .permutations(PERM.len())",
      "43:                 .map(|vec| vec.into_iter().collect::<String>())",
      "44:                 .take(CIRCLE_SIZE)",
      "45:                 .collect::<Vec<_>>()",
      "46:                 .into_iter()",
      "47:                 .circular_tuple_windows::<(_, _)>()",
      "48:                 .map(|(cur, next)| format!(\"fragment {cur} on Query {{ ...{next} }} \")),",
      "49:         )",
      "50:         .collect::<String>();",
      "52:     let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());",
      "53:     let _ = juniper::execute(&query, None, &schema, &graphql_vars! {}, &())",
      "54:         .await",
      "55:         .unwrap_err();",
      "56: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c843471d376a61f06013c825c7e0a190b2eaf55c",
      "candidate_info": {
        "commit_hash": "c843471d376a61f06013c825c7e0a190b2eaf55c",
        "repo": "graphql-rust/juniper",
        "commit_url": "https://github.com/graphql-rust/juniper/commit/c843471d376a61f06013c825c7e0a190b2eaf55c",
        "files": [
          "juniper/src/validation/rules/no_unused_fragments.rs"
        ],
        "message": "Fix `NoUnusedFragments` validation rule",
        "before_after_code_files": [
          "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs"
          ],
          "candidate": [
            "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs"
          ]
        }
      },
      "candidate_diff": {
        "juniper/src/validation/rules/no_unused_fragments.rs||juniper/src/validation/rules/no_unused_fragments.rs": [
          "File: juniper/src/validation/rules/no_unused_fragments.rs -> juniper/src/validation/rules/no_unused_fragments.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7:     value::ScalarValue,",
          "8: };",
          "11: pub enum Scope<'a> {",
          "12:     Operation(Option<&'a str>),",
          "13:     Fragment(&'a str),",
          "",
          "[Removed Lines]",
          "10: #[derive(Debug, Clone, PartialEq, Eq, Hash)]",
          "",
          "[Added Lines]",
          "10: #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: }",
          "30: impl<'a> NoUnusedFragments<'a> {",
          "32:         let mut to_visit = Vec::new();",
          "37:         while let Some(from) = to_visit.pop() {",
          "38:             if let Some(next) = self.find_reachable_fragments_inner(from, result) {",
          "40:             }",
          "41:         }",
          "42:     }",
          "",
          "[Removed Lines]",
          "31:     fn find_reachable_fragments(&'a self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {",
          "33:         if let Scope::Fragment(name) = *from {",
          "34:             to_visit.push(name);",
          "35:         }",
          "39:                 to_visit.extend(next);",
          "",
          "[Added Lines]",
          "31:     fn find_reachable_fragments(&'a self, from: Scope<'a>, result: &mut HashSet<&'a str>) {",
          "33:         to_visit.push(from);",
          "37:                 to_visit.extend(next.iter().map(|s| Scope::Fragment(s)));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:     fn find_reachable_fragments_inner(",
          "49:         &'a self,",
          "51:         result: &mut HashSet<&'a str>,",
          "52:     ) -> Option<&'a Vec<&'a str>> {",
          "57:         }",
          "60:     }",
          "61: }",
          "",
          "[Removed Lines]",
          "50:         from: &'a str,",
          "53:         if result.contains(from) {",
          "54:             return None;",
          "55:         } else {",
          "56:             result.insert(from);",
          "59:         self.spreads.get(&Scope::Fragment(from))",
          "",
          "[Added Lines]",
          "48:         from: Scope<'a>,",
          "51:         if let Scope::Fragment(name) = from {",
          "52:             if result.contains(name) {",
          "53:                 return None;",
          "54:             } else {",
          "55:                 result.insert(name);",
          "56:             }",
          "59:         self.spreads.get(&from)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "74:             }) = *def",
          "75:             {",
          "76:                 let op_name = name.as_ref().map(|s| s.item);",
          "78:             }",
          "79:         }",
          "",
          "[Removed Lines]",
          "77:                 self.find_reachable_fragments(&Scope::Operation(op_name), &mut reachable);",
          "",
          "[Added Lines]",
          "77:                 self.find_reachable_fragments(Scope::Operation(op_name), &mut reachable);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
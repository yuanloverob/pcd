{
  "cve_id": "CVE-2024-45409",
  "cve_desc": "The Ruby SAML library is for implementing the client side of a SAML authorization. Ruby-SAML in <= 12.2 and 1.13.0 <= 1.16.0 does not properly verify the signature of the SAML Response. An unauthenticated attacker with access to any signed saml document (by the IdP) can thus forge a SAML Response/Assertion with arbitrary contents. This would allow the attacker to log in as arbitrary user within the vulnerable system. This vulnerability is fixed in 1.17.0 and 1.12.3.",
  "repo": "SAML-Toolkits/ruby-saml",
  "patch_hash": "4865d030cae9705ee5cdb12415c654c634093ae7",
  "patch_info": {
    "commit_hash": "4865d030cae9705ee5cdb12415c654c634093ae7",
    "repo": "SAML-Toolkits/ruby-saml",
    "commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/4865d030cae9705ee5cdb12415c654c634093ae7",
    "files": [
      "lib/xml_security.rb"
    ],
    "message": "Merge commit from fork\n\n* Use correct XPaths and resolve to correct elements\n\n* Update xml_security.rb\n\n* Block references that resolve to multiple nodes to prevent signature wrapping attacks",
    "before_after_code_files": [
      "lib/xml_security.rb||lib/xml_security.rb"
    ]
  },
  "patch_diff": {
    "lib/xml_security.rb||lib/xml_security.rb": [
      "File: lib/xml_security.rb -> lib/xml_security.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "310:       canon_string = noko_signed_info_element.canonicalize(canon_algorithm)",
      "311:       noko_sig_element.remove",
      "313:       # get inclusive namespaces",
      "314:       inclusive_namespaces = extract_inclusive_namespaces",
      "316:       # check digests",
      "321:       canon_algorithm = canon_algorithm REXML::XPath.first(",
      "324:         { \"ds\" => DSIG }",
      "325:       )",
      "",
      "[Removed Lines]",
      "317:       ref = REXML::XPath.first(sig_element, \"//ds:Reference\", {\"ds\"=>DSIG})",
      "319:       hashed_element = document.at_xpath(\"//*[@ID=$id]\", nil, { 'id' => extract_signed_element_id })",
      "322:         ref,",
      "323:         '//ds:CanonicalizationMethod',",
      "",
      "[Added Lines]",
      "313:       # get signed info",
      "314:       signed_info_element = REXML::XPath.first(",
      "315:         sig_element,",
      "316:         \"./ds:SignedInfo\",",
      "317:         { \"ds\" => DSIG }",
      "318:       )",
      "323:       ref = REXML::XPath.first(signed_info_element, \"./ds:Reference\", {\"ds\"=>DSIG})",
      "325:       reference_nodes = document.xpath(\"//*[@ID=$id]\", nil, { 'id' => extract_signed_element_id })",
      "327:       if reference_nodes.length > 1 # ensures no elements with same ID to prevent signature wrapping attack.",
      "328:         return append_error(\"Digest Mismatch\", soft)",
      "329:       end",
      "331:       hashed_element = reference_nodes[0]",
      "334:         signed_info_element,",
      "335:         './ds:CanonicalizationMethod',",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "331:       digest_algorithm = algorithm(REXML::XPath.first(",
      "332:         ref,",
      "334:         { \"ds\" => DSIG }",
      "335:       ))",
      "336:       hash = digest_algorithm.digest(canon_hashed_element)",
      "337:       encoded_digest_value = REXML::XPath.first(",
      "338:         ref,",
      "340:         { \"ds\" => DSIG }",
      "341:       )",
      "342:       digest_value = Base64.decode64(OneLogin::RubySaml::Utils.element_text(encoded_digest_value))",
      "",
      "[Removed Lines]",
      "333:         \"//ds:DigestMethod\",",
      "339:         \"//ds:DigestValue\",",
      "",
      "[Added Lines]",
      "345:         \"./ds:DigestMethod\",",
      "351:         \"./ds:DigestValue\",",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "362:     def process_transforms(ref, canon_algorithm)",
      "363:       transforms = REXML::XPath.match(",
      "364:         ref,",
      "366:         { \"ds\" => DSIG }",
      "367:       )",
      "",
      "[Removed Lines]",
      "365:         \"//ds:Transforms/ds:Transform\",",
      "",
      "[Added Lines]",
      "377:         \"./ds:Transforms/ds:Transform\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7f887b4d8e6efc7ec92ea3f310ab43d006e8c99d",
      "candidate_info": {
        "commit_hash": "7f887b4d8e6efc7ec92ea3f310ab43d006e8c99d",
        "repo": "SAML-Toolkits/ruby-saml",
        "commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/7f887b4d8e6efc7ec92ea3f310ab43d006e8c99d",
        "files": [
          "lib/onelogin/ruby-saml/response.rb",
          "test/response_test.rb"
        ],
        "message": "Fix typo in SPNameQualifier error text. See #715",
        "before_after_code_files": [
          "lib/onelogin/ruby-saml/response.rb||lib/onelogin/ruby-saml/response.rb",
          "test/response_test.rb||test/response_test.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/SAML-Toolkits/ruby-saml/pull/725"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/onelogin/ruby-saml/response.rb||lib/onelogin/ruby-saml/response.rb": [
          "File: lib/onelogin/ruby-saml/response.rb -> lib/onelogin/ruby-saml/response.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "834:           unless settings.sp_entity_id.nil? || settings.sp_entity_id.empty? || name_id_spnamequalifier.nil? || name_id_spnamequalifier.empty?",
          "835:             if name_id_spnamequalifier != settings.sp_entity_id",
          "837:             end",
          "838:           end",
          "839:         end",
          "",
          "[Removed Lines]",
          "836:               return append_error(\"The SPNameQualifier value mistmatch the SP entityID value.\")",
          "",
          "[Added Lines]",
          "836:               return append_error(\"SPNameQualifier value does not match the SP entityID value.\")",
          "",
          "---------------"
        ],
        "test/response_test.rb||test/response_test.rb": [
          "File: test/response_test.rb -> test/response_test.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1027:         settings.sp_entity_id = 'sp_entity_id'",
          "1028:         response_wrong_spnamequalifier.settings = settings",
          "1029:         assert !response_wrong_spnamequalifier.send(:validate_name_id)",
          "1031:       end",
          "1033:       it \"return true when no nameid element but not required by settings\" do",
          "",
          "[Removed Lines]",
          "1030:         assert_includes response_wrong_spnamequalifier.errors, \"The SPNameQualifier value mistmatch the SP entityID value.\"",
          "",
          "[Added Lines]",
          "1030:         assert_includes response_wrong_spnamequalifier.errors, \"SPNameQualifier value does not match the SP entityID value.\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a9a3ce5d196657cdcc732f6b83f3041c8a167798",
      "candidate_info": {
        "commit_hash": "a9a3ce5d196657cdcc732f6b83f3041c8a167798",
        "repo": "SAML-Toolkits/ruby-saml",
        "commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/a9a3ce5d196657cdcc732f6b83f3041c8a167798",
        "files": [
          ".rubocop_todo.yml",
          "CHANGELOG.md",
          "README.md",
          "lib/ruby_saml/response.rb",
          "test/response_test.rb",
          "test/utils_test.rb"
        ],
        "message": "Merge 1.x branch into 2.x branch (squashed commits)",
        "before_after_code_files": [
          "lib/ruby_saml/response.rb||lib/ruby_saml/response.rb",
          "test/response_test.rb||test/response_test.rb",
          "test/utils_test.rb||test/utils_test.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/SAML-Toolkits/ruby-saml/pull/725"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/ruby_saml/response.rb||lib/ruby_saml/response.rb": [
          "File: lib/ruby_saml/response.rb -> lib/ruby_saml/response.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "825:         end",
          "827:         if !(settings.sp_entity_id.nil? || settings.sp_entity_id.empty? || name_id_spnamequalifier.nil? || name_id_spnamequalifier.empty?) && (name_id_spnamequalifier != settings.sp_entity_id)",
          "829:         end",
          "830:       end",
          "",
          "[Removed Lines]",
          "828:             return append_error('SPNameQualifier value does not match the SP entityID value.')",
          "",
          "[Added Lines]",
          "828:           return append_error('SPNameQualifier value does not match the SP entityID value.')",
          "",
          "---------------"
        ],
        "test/response_test.rb||test/response_test.rb": [
          "File: test/response_test.rb -> test/response_test.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1356:       end",
          "1357:     end",
          "1368:       end",
          "1369:     end",
          "1378:     end",
          "1380:     describe \"#success\" do",
          "",
          "[Removed Lines]",
          "1359:     # Gets the AuthnInstant from the AuthnStatement.",
          "1360:     # Could be used to require re-authentication if a long time has passed",
          "1361:     # since the last user authentication.",
          "1362:     # @return [String] AuthnInstant value",
          "1363:     #",
          "1364:     def authn_instant",
          "1365:       @authn_instant ||= begin",
          "1366:         node = xpath_first_from_signed_assertion('/a:AuthnStatement')",
          "1367:         node.nil? ? nil : node.attributes['AuthnInstant']",
          "1371:     # Gets the AuthnContextClassRef from the AuthnStatement",
          "1372:     # Could be used to require re-authentication if the assertion",
          "1373:     # did not met the requested authentication context class.",
          "1374:     # @return [String] AuthnContextClassRef value",
          "1375:     #",
          "1376:     def authn_context_class_ref",
          "1377:       @authn_context_class_ref ||= Utils.element_text(xpath_first_from_signed_assertion('/a:AuthnStatement/a:AuthnContext/a:AuthnContextClassRef'))",
          "",
          "[Added Lines]",
          "1359:     describe \"#authn_instant\" do",
          "1360:       it \"extract the value of the AuthnInstant attribute\" do",
          "1361:         assert_equal \"2010-11-18T21:57:37Z\", response.authn_instant",
          "1365:     describe \"#authn_context_class_ref\" do",
          "1366:       it \"extract the value of the AuthnContextClassRef attribute\" do",
          "1367:         assert_equal \"urn:oasis:names:tc:SAML:2.0:ac:classes:Password\", response.authn_context_class_ref",
          "1368:       end",
          "",
          "---------------"
        ],
        "test/utils_test.rb||test/utils_test.rb": [
          "File: test/utils_test.rb -> test/utils_test.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "363:     end",
          "365:     it 'successfully decrypts with the first private key' do",
          "367:     end",
          "369:     it 'successfully decrypts with a subsequent private key' do",
          "371:     end",
          "373:     it 'raises an error when there is only one key and it fails to decrypt' do",
          "",
          "[Removed Lines]",
          "366:       assert_match %r{\\A<saml:Assertion}, RubySaml::Utils.decrypt_multi(encrypted, [private_key])",
          "370:       assert_match %r{\\A<saml:Assertion}, RubySaml::Utils.decrypt_multi(encrypted, [invalid_key1, private_key])",
          "",
          "[Added Lines]",
          "366:       assert_match(/\\A<saml:Assertion/, RubySaml::Utils.decrypt_multi(encrypted, [private_key]))",
          "370:       assert_match(/\\A<saml:Assertion/, RubySaml::Utils.decrypt_multi(encrypted, [invalid_key1, private_key]))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1bc447f297b769d1a9abeb619ce074bd9c410a72",
      "candidate_info": {
        "commit_hash": "1bc447f297b769d1a9abeb619ce074bd9c410a72",
        "repo": "SAML-Toolkits/ruby-saml",
        "commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/1bc447f297b769d1a9abeb619ce074bd9c410a72",
        "files": [
          "CHANGELOG.md",
          "README.md",
          "lib/onelogin/ruby-saml/version.rb",
          "lib/xml_security.rb"
        ],
        "message": "Release 1.17.0",
        "before_after_code_files": [
          "lib/onelogin/ruby-saml/version.rb||lib/onelogin/ruby-saml/version.rb",
          "lib/xml_security.rb||lib/xml_security.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/xml_security.rb||lib/xml_security.rb"
          ],
          "candidate": [
            "lib/xml_security.rb||lib/xml_security.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/onelogin/ruby-saml/version.rb||lib/onelogin/ruby-saml/version.rb": [
          "File: lib/onelogin/ruby-saml/version.rb -> lib/onelogin/ruby-saml/version.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module OneLogin",
          "2:   module RubySaml",
          "4:   end",
          "5: end",
          "",
          "[Removed Lines]",
          "3:     VERSION = '1.16.0'",
          "",
          "[Added Lines]",
          "3:     VERSION = '1.17.0'",
          "",
          "---------------"
        ],
        "lib/xml_security.rb||lib/xml_security.rb": [
          "File: lib/xml_security.rb -> lib/xml_security.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "325:       reference_nodes = document.xpath(\"//*[@ID=$id]\", nil, { 'id' => extract_signed_element_id })",
          "327:       if reference_nodes.length > 1 # ensures no elements with same ID to prevent signature wrapping attack.",
          "329:       end",
          "331:       hashed_element = reference_nodes[0]",
          "",
          "[Removed Lines]",
          "328:         return append_error(\"Digest Mismatch\", soft)",
          "",
          "[Added Lines]",
          "329:         return append_error(\"Digest mismatch. Duplicated ID found\", soft)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e9c1cdbd0f9afa467b585de279db0cbd0fb8ae97",
      "candidate_info": {
        "commit_hash": "e9c1cdbd0f9afa467b585de279db0cbd0fb8ae97",
        "repo": "SAML-Toolkits/ruby-saml",
        "commit_url": "https://github.com/SAML-Toolkits/ruby-saml/commit/e9c1cdbd0f9afa467b585de279db0cbd0fb8ae97",
        "files": [
          "lib/onelogin/ruby-saml/logoutresponse.rb",
          "lib/onelogin/ruby-saml/response.rb",
          "lib/onelogin/ruby-saml/saml_message.rb",
          "lib/onelogin/ruby-saml/settings.rb",
          "lib/onelogin/ruby-saml/slo_logoutrequest.rb",
          "lib/xml_security.rb",
          "test/xml_security_test.rb"
        ],
        "message": "Fix vulnerabilities: CVE-2025-25291, CVE-2025-25292: SAML authentication bypass via Signature Wrapping attack allowed due parser differential",
        "before_after_code_files": [
          "lib/onelogin/ruby-saml/logoutresponse.rb||lib/onelogin/ruby-saml/logoutresponse.rb",
          "lib/onelogin/ruby-saml/response.rb||lib/onelogin/ruby-saml/response.rb",
          "lib/onelogin/ruby-saml/saml_message.rb||lib/onelogin/ruby-saml/saml_message.rb",
          "lib/onelogin/ruby-saml/settings.rb||lib/onelogin/ruby-saml/settings.rb",
          "lib/onelogin/ruby-saml/slo_logoutrequest.rb||lib/onelogin/ruby-saml/slo_logoutrequest.rb",
          "lib/xml_security.rb||lib/xml_security.rb",
          "test/xml_security_test.rb||test/xml_security_test.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/xml_security.rb||lib/xml_security.rb"
          ],
          "candidate": [
            "lib/xml_security.rb||lib/xml_security.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/onelogin/ruby-saml/logoutresponse.rb||lib/onelogin/ruby-saml/logoutresponse.rb": [
          "File: lib/onelogin/ruby-saml/logoutresponse.rb -> lib/onelogin/ruby-saml/logoutresponse.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:       # @raise [ValidationError] if soft == false and validation fails",
          "151:       #",
          "152:       def validate_structure",
          "154:           return append_error(\"Invalid SAML Logout Response. Not match the saml-schema-protocol-2.0.xsd\")",
          "155:         end",
          "",
          "[Removed Lines]",
          "153:         unless valid_saml?(document, soft)",
          "",
          "[Added Lines]",
          "153:         check_malformed_doc = check_malformed_doc?(settings)",
          "154:         unless valid_saml?(document, soft, check_malformed_doc)",
          "",
          "---------------"
        ],
        "lib/onelogin/ruby-saml/response.rb||lib/onelogin/ruby-saml/response.rb": [
          "File: lib/onelogin/ruby-saml/response.rb -> lib/onelogin/ruby-saml/response.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:       PROTOCOL  = \"urn:oasis:names:tc:SAML:2.0:protocol\"",
          "18:       DSIG      = \"http://www.w3.org/2000/09/xmldsig#\"",
          "19:       XENC      = \"http://www.w3.org/2001/04/xmlenc#\"",
          "21:       # TODO: Settings should probably be initialized too... WDYT?",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:       SAML_NAMESPACES = {",
          "21:         \"p\" => PROTOCOL,",
          "22:         \"a\" => ASSERTION",
          "23:       }.freeze",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "303:           issuer_response_nodes = REXML::XPath.match(",
          "304:             document,",
          "305:             \"/p:Response/a:Issuer\",",
          "307:           )",
          "309:           unless issuer_response_nodes.size == 1",
          "",
          "[Removed Lines]",
          "306:             { \"p\" => PROTOCOL, \"a\" => ASSERTION }",
          "",
          "[Added Lines]",
          "310:             SAML_NAMESPACES",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "370:         ! REXML::XPath.first(",
          "371:           document,",
          "372:           \"(/p:Response/EncryptedAssertion/)|(/p:Response/a:EncryptedAssertion/)\",",
          "374:         ).nil?",
          "375:       end",
          "",
          "[Removed Lines]",
          "373:           { \"p\" => PROTOCOL, \"a\" => ASSERTION }",
          "",
          "[Added Lines]",
          "377:           SAML_NAMESPACES",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:           :validate_id,",
          "402:           :validate_success_status,",
          "403:           :validate_num_assertion,",
          "405:           :validate_signed_elements,",
          "406:           :validate_structure,",
          "407:           :validate_in_response_to,",
          "408:           :validate_one_conditions,",
          "409:           :validate_conditions,",
          "",
          "[Removed Lines]",
          "404:           :validate_no_duplicated_attributes,",
          "",
          "[Added Lines]",
          "410:           :validate_no_duplicated_attributes,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "444:       #",
          "445:       def validate_structure",
          "446:         structure_error_msg = \"Invalid SAML Response. Not match the saml-schema-protocol-2.0.xsd\"",
          "448:           return append_error(structure_error_msg)",
          "449:         end",
          "451:         unless decrypted_document.nil?",
          "453:             return append_error(structure_error_msg)",
          "454:           end",
          "455:         end",
          "",
          "[Removed Lines]",
          "447:         unless valid_saml?(document, soft)",
          "452:           unless valid_saml?(decrypted_document, soft)",
          "",
          "[Added Lines]",
          "452:         check_malformed_doc = check_malformed_doc_enabled?",
          "453:         unless valid_saml?(document, soft, check_malformed_doc)",
          "458:           unless valid_saml?(decrypted_document, soft, check_malformed_doc)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "841:         true",
          "842:       end",
          "844:       # Validates the Signature",
          "845:       # @return [Boolean] True if not contains a Signature or if the Signature is valid, otherwise False if soft=True",
          "846:       # @raise [ValidationError] if soft == false and validation fails",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "850:       def doc_to_validate",
          "851:         # If the response contains the signature, and the assertion was encrypted, validate the original SAML Response",
          "852:         # otherwise, review if the decrypted assertion contains a signature",
          "853:         sig_elements = REXML::XPath.match(",
          "854:           document,",
          "855:           \"/p:Response[@ID=$id]/ds:Signature\",",
          "856:           { \"p\" => PROTOCOL, \"ds\" => DSIG },",
          "857:           { 'id' => document.signed_element_id }",
          "858:         )",
          "860:         use_original = sig_elements.size == 1 || decrypted_document.nil?",
          "861:         doc = use_original ? document : decrypted_document",
          "862:         if !doc.processed",
          "863:           doc.cache_referenced_xml(@soft, check_malformed_doc_enabled?)",
          "864:         end",
          "866:         return doc",
          "867:       end",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "848:       def validate_signature",
          "849:         error_msg = \"Invalid Signature on SAML Response\"",
          "853:         sig_elements = REXML::XPath.match(",
          "854:           document,",
          "855:           \"/p:Response[@ID=$id]/ds:Signature\",",
          "",
          "[Removed Lines]",
          "851:         # If the response contains the signature, and the assertion was encrypted, validate the original SAML Response",
          "852:         # otherwise, review if the decrypted assertion contains a signature",
          "",
          "[Added Lines]",
          "876:         doc = doc_to_validate",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "857:           { 'id' => document.signed_element_id }",
          "858:         )",
          "864:         if sig_elements.nil? || sig_elements.size == 0",
          "865:           sig_elements = REXML::XPath.match(",
          "866:             doc,",
          "867:             \"/p:Response/a:Assertion[@ID=$id]/ds:Signature\",",
          "869:             { 'id' => doc.signed_element_id }",
          "870:           )",
          "871:         end",
          "",
          "[Removed Lines]",
          "860:         use_original = sig_elements.size == 1 || decrypted_document.nil?",
          "861:         doc = use_original ? document : decrypted_document",
          "863:         # Check signature nodes",
          "868:             {\"p\" => PROTOCOL, \"a\" => ASSERTION, \"ds\"=>DSIG},",
          "",
          "[Added Lines]",
          "885:         # Check signature node inside assertion",
          "890:             SAML_NAMESPACES.merge({\"ds\"=>DSIG}),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "943:           end",
          "944:       end",
          "946:       # Extracts the first appearance that matchs the subelt (pattern)",
          "947:       # Search on any Assertion that is signed, or has a Response parent signed",
          "948:       # @param subelt [String] The XPath pattern",
          "949:       # @return [REXML::Element | nil] If any matches, return the Element",
          "950:       #",
          "951:       def xpath_first_from_signed_assertion(subelt=nil)",
          "953:         node = REXML::XPath.first(",
          "954:             doc,",
          "964:         )",
          "965:         node",
          "966:       end",
          "",
          "[Removed Lines]",
          "952:         doc = decrypted_document.nil? ? document : decrypted_document",
          "955:             \"/p:Response/a:Assertion[@ID=$id]#{subelt}\",",
          "956:             { \"p\" => PROTOCOL, \"a\" => ASSERTION },",
          "957:             { 'id' => doc.signed_element_id }",
          "958:         )",
          "959:         node ||= REXML::XPath.first(",
          "960:             doc,",
          "961:             \"/p:Response[@ID=$id]/a:Assertion#{subelt}\",",
          "962:             { \"p\" => PROTOCOL, \"a\" => ASSERTION },",
          "963:             { 'id' => doc.signed_element_id }",
          "",
          "[Added Lines]",
          "968:       def get_cached_signed_assertion",
          "969:         xml = doc_to_validate.referenced_xml",
          "970:         empty_doc = REXML::Document.new",
          "972:         return empty_doc if xml.nil? # when no signature/reference is found, return empty document",
          "974:         root = REXML::Document.new(xml).root",
          "976:         if root.attributes[\"ID\"] != doc_to_validate.signed_element_id",
          "977:           return empty_doc",
          "978:         end",
          "980:         assertion = empty_doc",
          "981:         if root.name == \"Response\"",
          "982:           if REXML::XPath.first(root, \"a:Assertion\", {\"a\" => ASSERTION})",
          "983:             assertion = REXML::XPath.first(root, \"a:Assertion\", {\"a\" => ASSERTION})",
          "984:           elsif REXML::XPath.first(root, \"a:EncryptedAssertion\", {\"a\" => ASSERTION})",
          "985:             assertion = decrypt_assertion(REXML::XPath.first(root, \"a:EncryptedAssertion\", {\"a\" => ASSERTION}))",
          "986:           end",
          "987:         elsif root.name == \"Assertion\"",
          "988:           assertion = root",
          "989:         end",
          "991:         assertion",
          "992:       end",
          "994:       def signed_assertion",
          "995:         @signed_assertion ||= get_cached_signed_assertion",
          "996:       end",
          "1004:         doc = signed_assertion",
          "1007:             \"./#{subelt}\",",
          "1008:             SAML_NAMESPACES",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "971:       # @return [Array of REXML::Element] Return all matches",
          "972:       #",
          "973:       def xpath_from_signed_assertion(subelt=nil)",
          "975:         node = REXML::XPath.match(",
          "976:             doc,",
          "980:         )",
          "987:       end",
          "989:       # Generates the decrypted_document",
          "",
          "[Removed Lines]",
          "974:         doc = decrypted_document.nil? ? document : decrypted_document",
          "977:             \"/p:Response/a:Assertion[@ID=$id]#{subelt}\",",
          "978:             { \"p\" => PROTOCOL, \"a\" => ASSERTION },",
          "979:             { 'id' => doc.signed_element_id }",
          "981:         node.concat( REXML::XPath.match(",
          "982:             doc,",
          "983:             \"/p:Response[@ID=$id]/a:Assertion#{subelt}\",",
          "984:             { \"p\" => PROTOCOL, \"a\" => ASSERTION },",
          "985:             { 'id' => doc.signed_element_id }",
          "986:         ))",
          "",
          "[Added Lines]",
          "1019:         doc = signed_assertion",
          "1022:             \"./#{subelt}\",",
          "1023:             SAML_NAMESPACES",
          "1025:         node",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1017:         encrypted_assertion_node = REXML::XPath.first(",
          "1018:           document_copy,",
          "1019:           \"(/p:Response/EncryptedAssertion/)|(/p:Response/a:EncryptedAssertion/)\",",
          "1021:         )",
          "1022:         response_node.add(decrypt_assertion(encrypted_assertion_node))",
          "1023:         encrypted_assertion_node.remove",
          "",
          "[Removed Lines]",
          "1020:           { \"p\" => PROTOCOL, \"a\" => ASSERTION }",
          "",
          "[Added Lines]",
          "1059:           SAML_NAMESPACES",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1087:           Time.parse(node.attributes[attribute])",
          "1088:         end",
          "1089:       end",
          "1090:     end",
          "1091:   end",
          "1092: end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1130:       def check_malformed_doc_enabled?",
          "1131:         check_malformed_doc?(settings)",
          "1132:       end",
          "",
          "---------------"
        ],
        "lib/onelogin/ruby-saml/saml_message.rb||lib/onelogin/ruby-saml/saml_message.rb": [
          "File: lib/onelogin/ruby-saml/saml_message.rb -> lib/onelogin/ruby-saml/saml_message.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:       # Validates the SAML Message against the specified schema.",
          "59:       # @param document [REXML::Document] The message that will be validated",
          "60:       # @param soft [Boolean] soft Enable or Disable the soft mode (In order to raise exceptions when the message is invalid or not)",
          "61:       # @return [Boolean] True if the XML is valid, otherwise False, if soft=True",
          "62:       # @raise [ValidationError] if soft == false and validation fails",
          "63:       #",
          "65:         begin",
          "69:         rescue StandardError => error",
          "70:           return false if soft",
          "71:           raise ValidationError.new(\"XML load failed: #{error.message}\")",
          "",
          "[Removed Lines]",
          "64:       def valid_saml?(document, soft = true)",
          "66:           xml = Nokogiri::XML(document.to_s) do |config|",
          "67:             config.options = XMLSecurity::BaseDocument::NOKOGIRI_OPTIONS",
          "68:           end",
          "",
          "[Added Lines]",
          "61:       # @param check_malformed_doc [Boolean] check_malformed_doc Enable or Disable the check for malformed XML",
          "65:       def valid_saml?(document, soft = true, check_malformed_doc = true)",
          "67:           xml = XMLSecurity::BaseDocument.safe_load_xml(document, check_malformed_doc)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:       # Base64 decode and try also to inflate a SAML Message",
          "83:       # @param saml [String] The deflated and encoded SAML Message",
          "84:       # @return [String] The plain SAML Message",
          "85:       #",
          "86:       def decode_raw_saml(saml, settings = nil)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:       # @param settings [OneLogin::RubySaml::Settings|nil] Toolkit settings",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:         decoded = decode(saml)",
          "95:         begin",
          "97:         rescue",
          "99:         end",
          "101:         if message.bytesize > settings.message_max_bytesize",
          "103:         end",
          "105:         message",
          "",
          "[Removed Lines]",
          "96:           message = inflate(decoded)",
          "98:           message = decoded",
          "102:           raise ValidationError.new(\"Encoded SAML Message exceeds \" + settings.message_max_bytesize.to_s + \" bytes, so was rejected\")",
          "",
          "[Added Lines]",
          "96:             message = inflate(decoded)",
          "98:             message = decoded",
          "102:             raise ValidationError.new(\"SAML Message exceeds \" + settings.message_max_bytesize.to_s + \" bytes, so was rejected\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:       def deflate(inflated)",
          "160:         Zlib::Deflate.deflate(inflated, 9)[2..-5]",
          "161:       end",
          "162:     end",
          "163:   end",
          "164: end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:       def check_malformed_doc?(settings)",
          "164:         default_value = OneLogin::RubySaml::Settings::DEFAULTS[:check_malformed_doc]",
          "166:         settings.nil? ? default_value : settings.check_malformed_doc",
          "167:       end",
          "",
          "---------------"
        ],
        "lib/onelogin/ruby-saml/settings.rb||lib/onelogin/ruby-saml/settings.rb": [
          "File: lib/onelogin/ruby-saml/settings.rb -> lib/onelogin/ruby-saml/settings.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:       attr_accessor :compress_response",
          "56:       attr_accessor :double_quote_xml_attribute_values",
          "57:       attr_accessor :message_max_bytesize",
          "58:       attr_accessor :passive",
          "59:       attr_reader   :protocol_binding",
          "60:       attr_accessor :attributes_index",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58:       attr_accessor :check_malformed_doc",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281:         :compress_response                         => true,",
          "282:         :message_max_bytesize                      => 250000,",
          "283:         :soft                                      => true,",
          "284:         :double_quote_xml_attribute_values         => false,",
          "285:         :security                                  => {",
          "286:           :authn_requests_signed      => false,",
          "287:           :logout_requests_signed     => false,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:         :check_malformed_doc                       => true,",
          "",
          "---------------"
        ],
        "lib/onelogin/ruby-saml/slo_logoutrequest.rb||lib/onelogin/ruby-saml/slo_logoutrequest.rb": [
          "File: lib/onelogin/ruby-saml/slo_logoutrequest.rb -> lib/onelogin/ruby-saml/slo_logoutrequest.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:       # @raise [ValidationError] if soft == false and validation fails",
          "239:       #",
          "240:       def validate_structure",
          "242:           return append_error(\"Invalid SAML Logout Request. Not match the saml-schema-protocol-2.0.xsd\")",
          "243:         end",
          "",
          "[Removed Lines]",
          "241:         unless valid_saml?(document, soft)",
          "",
          "[Added Lines]",
          "241:         check_malformed_doc = check_malformed_doc?(settings)",
          "242:         unless valid_saml?(document, soft, check_malformed_doc)",
          "",
          "---------------"
        ],
        "lib/xml_security.rb||lib/xml_security.rb": [
          "File: lib/xml_security.rb -> lib/xml_security.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     NOKOGIRI_OPTIONS = Nokogiri::XML::ParseOptions::STRICT |",
          "43:                        Nokogiri::XML::ParseOptions::NONET",
          "45:     def canon_algorithm(element)",
          "46:       algorithm = element",
          "47:       if algorithm.is_a?(REXML::Element)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     # Safety load the SAML Message XML",
          "46:     # @param document [REXML::Document] The message to be loaded",
          "47:     # @param check_malformed_doc [Boolean] check_malformed_doc Enable or Disable the check for malformed XML",
          "48:     # @return [Nokogiri::XML] The nokogiri document",
          "49:     # @raise [ValidationError] If there was a problem loading the SAML Message XML",
          "50:     def self.safe_load_xml(document, check_malformed_doc = true)",
          "51:       doc_str = document.to_s",
          "52:       if doc_str.include?(\"<!DOCTYPE\")",
          "53:        raise StandardError.new(\"Dangerous XML detected. No Doctype nodes allowed\")",
          "54:       end",
          "56:       begin",
          "57:         xml = Nokogiri::XML(doc_str) do |config|",
          "58:           config.options = self::NOKOGIRI_OPTIONS",
          "59:         end",
          "60:       rescue StandardError => error",
          "61:         raise StandardError.new(error.message)",
          "62:       end",
          "64:       if xml.internal_subset",
          "65:         raise StandardError.new(\"Dangerous XML detected. No Doctype nodes allowed\")",
          "66:       end",
          "68:       unless xml.errors.empty?",
          "69:         raise StandardError.new(\"There were XML errors when parsing: #{xml.errors}\") if check_malformed_doc",
          "70:       end",
          "72:       xml",
          "73:     end",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:       #<KeyInfo />",
          "115:       #<Object />",
          "116:     #</Signature>",
          "122:       signature_element = REXML::Element.new(\"ds:Signature\").add_namespace('ds', DSIG)",
          "123:       signed_info_element = signature_element.add_element(\"ds:SignedInfo\")",
          "",
          "[Removed Lines]",
          "117:     def sign_document(private_key, certificate, signature_method = RSA_SHA1, digest_method = SHA1)",
          "118:       noko = Nokogiri::XML(self.to_s) do |config|",
          "119:         config.options = XMLSecurity::BaseDocument::NOKOGIRI_OPTIONS",
          "120:       end",
          "",
          "[Added Lines]",
          "147:     def sign_document(private_key, certificate, signature_method = RSA_SHA1, digest_method = SHA1, check_malformed_doc = true)",
          "148:       noko = XMLSecurity::BaseDocument.safe_load_xml(self.to_s, check_malformed_doc)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:       reference_element.add_element(\"ds:DigestValue\").text = compute_digest(canon_doc, algorithm(digest_method_element))",
          "141:       # add SignatureValue",
          "146:       noko_signed_info_element = noko_sig_element.at_xpath('//ds:Signature/ds:SignedInfo', 'ds' => DSIG)",
          "147:       canon_string = noko_signed_info_element.canonicalize(canon_algorithm(C14N))",
          "",
          "[Removed Lines]",
          "142:       noko_sig_element = Nokogiri::XML(signature_element.to_s) do |config|",
          "143:         config.options = XMLSecurity::BaseDocument::NOKOGIRI_OPTIONS",
          "144:       end",
          "",
          "[Added Lines]",
          "170:       noko_sig_element = XMLSecurity::BaseDocument.safe_load_xml(signature_element.to_s, check_malformed_doc)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "190:     def initialize(response, errors = [])",
          "191:       super(response)",
          "192:       @errors = errors",
          "193:     end",
          "195:     def signed_element_id",
          "196:       @signed_element_id ||= extract_signed_element_id",
          "197:     end",
          "199:     def validate_document(idp_cert_fingerprint, soft = true, options = {})",
          "200:       # get cert from response",
          "201:       cert_element = REXML::XPath.first(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:       reset_elements",
          "220:     end",
          "222:     def reset_elements",
          "223:       @referenced_xml = nil",
          "224:       @cached_signed_info = nil",
          "225:       @signature = nil",
          "226:       @signature_algorithm = nil",
          "227:       @ref = nil",
          "228:       @processed = false",
          "229:     end",
          "231:     def processed",
          "232:       @processed",
          "233:     end",
          "235:     def referenced_xml",
          "236:       @referenced_xml",
          "243:     # Validates the referenced_xml, which is the signed part of the document",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "224:         if fingerprint != idp_cert_fingerprint.gsub(/[^a-zA-Z0-9]/,\"\").downcase",
          "225:           return append_error(\"Fingerprint mismatch\", soft)",
          "226:         end",
          "227:       else",
          "228:         if options[:cert]",
          "229:           base64_cert = Base64.encode64(options[:cert].to_pem)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:         base64_cert = Base64.encode64(cert.to_der)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "259:         if idp_cert.to_pem != cert.to_pem",
          "260:           return append_error(\"Certificate of the Signature element does not match provided certificate\", soft)",
          "261:         end",
          "264:       end",
          "266:     end",
          "272:       end",
          "274:       # create a rexml document",
          "",
          "[Removed Lines]",
          "262:       else",
          "263:         base64_cert = Base64.encode64(idp_cert.to_pem)",
          "265:       validate_signature(base64_cert, true)",
          "268:     def validate_signature(base64_cert, soft = true)",
          "270:       document = Nokogiri::XML(self.to_s) do |config|",
          "271:         config.options = XMLSecurity::BaseDocument::NOKOGIRI_OPTIONS",
          "",
          "[Added Lines]",
          "310:       encoded_idp_cert = Base64.encode64(idp_cert.to_pem)",
          "311:       validate_signature(encoded_idp_cert, true)",
          "314:     def cache_referenced_xml(soft, check_malformed_doc = true)",
          "315:       reset_elements",
          "316:       @processed = true",
          "318:       begin",
          "319:         nokogiri_document = XMLSecurity::BaseDocument.safe_load_xml(self, check_malformed_doc)",
          "320:       rescue StandardError => error",
          "321:         @errors << error.message",
          "322:         return false if soft",
          "323:         raise ValidationError.new(\"XML load failed: #{error.message}\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "281:           {\"ds\"=>DSIG}",
          "282:       )",
          "284:       # signature method",
          "285:       sig_alg_value = REXML::XPath.first(",
          "286:         sig_element,",
          "287:         \"./ds:SignedInfo/ds:SignatureMethod\",",
          "288:         {\"ds\"=>DSIG}",
          "289:       )",
          "292:       # get signature",
          "293:       base64_signature = REXML::XPath.first(",
          "",
          "[Removed Lines]",
          "290:       signature_algorithm = algorithm(sig_alg_value)",
          "",
          "[Added Lines]",
          "336:       return if sig_element.nil?",
          "344:       @signature_algorithm = algorithm(sig_alg_value)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "295:         \"./ds:SignatureValue\",",
          "296:         {\"ds\" => DSIG}",
          "297:       )",
          "300:       # canonicalization method",
          "301:       canon_algorithm = canon_algorithm REXML::XPath.first(",
          "",
          "[Removed Lines]",
          "298:       signature = Base64.decode64(OneLogin::RubySaml::Utils.element_text(base64_signature))",
          "",
          "[Added Lines]",
          "353:       return if base64_signature.nil?",
          "355:       base64_signature_text = OneLogin::RubySaml::Utils.element_text(base64_signature)",
          "356:       @signature = base64_signature_text.nil? ? nil : Base64.decode64(base64_signature_text)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "304:         'ds' => DSIG",
          "305:       )",
          "308:       noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' => DSIG)",
          "320:       # get inclusive namespaces",
          "321:       inclusive_namespaces = extract_inclusive_namespaces",
          "323:       # check digests",
          "332:       hashed_element = reference_nodes[0]",
          "334:       canon_algorithm = canon_algorithm REXML::XPath.first(",
          "336:         './ds:CanonicalizationMethod',",
          "337:         { \"ds\" => DSIG }",
          "338:       )",
          "344:       digest_algorithm = algorithm(REXML::XPath.first(",
          "346:         \"./ds:DigestMethod\",",
          "347:         { \"ds\" => DSIG }",
          "348:       ))",
          "350:       encoded_digest_value = REXML::XPath.first(",
          "352:         \"./ds:DigestValue\",",
          "353:         { \"ds\" => DSIG }",
          "354:       )",
          "358:         return append_error(\"Digest mismatch\", soft)",
          "359:       end",
          "365:       # verify signature",
          "367:         return append_error(\"Key validation error\", soft)",
          "368:       end",
          "",
          "[Removed Lines]",
          "307:       noko_sig_element = document.at_xpath('//ds:Signature', 'ds' => DSIG)",
          "310:       canon_string = noko_signed_info_element.canonicalize(canon_algorithm)",
          "311:       noko_sig_element.remove",
          "313:       # get signed info",
          "314:       signed_info_element = REXML::XPath.first(",
          "315:         sig_element,",
          "316:         \"./ds:SignedInfo\",",
          "317:         { \"ds\" => DSIG }",
          "318:       )",
          "324:       ref = REXML::XPath.first(signed_info_element, \"./ds:Reference\", {\"ds\"=>DSIG})",
          "326:       reference_nodes = document.xpath(\"//*[@ID=$id]\", nil, { 'id' => extract_signed_element_id })",
          "328:       if reference_nodes.length > 1 # ensures no elements with same ID to prevent signature wrapping attack.",
          "329:         return append_error(\"Digest mismatch. Duplicated ID found\", soft)",
          "330:       end",
          "335:         signed_info_element,",
          "340:       canon_algorithm = process_transforms(ref, canon_algorithm)",
          "342:       canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces)",
          "345:         ref,",
          "349:       hash = digest_algorithm.digest(canon_hashed_element)",
          "351:         ref,",
          "355:       digest_value = Base64.decode64(OneLogin::RubySaml::Utils.element_text(encoded_digest_value))",
          "357:       unless digests_match?(hash, digest_value)",
          "361:       # get certificate object",
          "362:       cert_text = Base64.decode64(base64_cert)",
          "363:       cert = OpenSSL::X509::Certificate.new(cert_text)",
          "366:       unless cert.public_key.verify(signature_algorithm.new, signature, canon_string)",
          "",
          "[Added Lines]",
          "365:       noko_sig_element = nokogiri_document.at_xpath('//ds:Signature', 'ds' => DSIG)",
          "368:       @cached_signed_info = noko_signed_info_element.canonicalize(canon_algorithm)",
          "370:       ### Now get the @referenced_xml to use?",
          "371:       rexml_signed_info = REXML::Document.new(@cached_signed_info.to_s).root",
          "373:       noko_sig_element.remove",
          "379:       @ref = REXML::XPath.first(rexml_signed_info, \"./ds:Reference\", {\"ds\"=>DSIG})",
          "380:       return if @ref.nil?",
          "382:       reference_nodes = nokogiri_document.xpath(\"//*[@ID=$id]\", nil, { 'id' => extract_signed_element_id })",
          "385:       return if hashed_element.nil?",
          "388:         rexml_signed_info,",
          "393:       canon_algorithm = process_transforms(@ref, canon_algorithm)",
          "395:       @referenced_xml = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces)",
          "396:     end",
          "398:     def validate_signature(base64_cert, soft = true)",
          "399:       if !@processed",
          "400:         cache_referenced_xml(soft)",
          "401:       end",
          "403:       return append_error(\"No Signature Algorithm Method found\", soft) if @signature_algorithm.nil?",
          "404:       return append_error(\"No Signature node found\", soft) if @signature.nil?",
          "405:       return append_error(\"No canonized SignedInfo \", soft) if @cached_signed_info.nil?",
          "406:       return append_error(\"No Reference node found\", soft) if @ref.nil?",
          "407:       return append_error(\"No referenced XML\", soft) if @referenced_xml.nil?",
          "409:       # get certificate object",
          "410:       cert_text = Base64.decode64(base64_cert)",
          "411:       cert = OpenSSL::X509::Certificate.new(cert_text)",
          "414:         @ref,",
          "418:       hash = digest_algorithm.digest(@referenced_xml)",
          "420:         @ref,",
          "424:       encoded_digest_value_text = OneLogin::RubySaml::Utils.element_text(encoded_digest_value)",
          "425:       digest_value = encoded_digest_value_text.nil? ? nil : Base64.decode64(encoded_digest_value_text)",
          "427:       # Compare the computed \"hash\" with the \"signed\" hash",
          "428:       unless hash && hash == digest_value",
          "433:       unless cert.public_key.verify(@signature_algorithm.new, @signature, @cached_signed_info)",
          "",
          "---------------"
        ],
        "test/xml_security_test.rb||test/xml_security_test.rb": [
          "File: test/xml_security_test.rb -> test/xml_security_test.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "387:         let(:document) { OneLogin::RubySaml::Response.new(document_data) }",
          "388:         let(:fingerprint) { '4b68c453c7d994aad9025c99d5efcf566287fe8d' }",
          "391:           assert document.document.validate_document(fingerprint, true), 'Document should be valid'",
          "393:         end",
          "394:       end",
          "395:     end",
          "",
          "[Removed Lines]",
          "390:         it 'is valid, but fails to retrieve information' do",
          "392:           assert document.name_id.nil?, 'Document should expose only signed, valid details'",
          "",
          "[Added Lines]",
          "390:         it 'is valid, but the unsigned information is ignored in favour of the signed information' do",
          "392:           assert_equal 'someone@example.org', document.name_id, 'Document should expose only signed, valid details'",
          "",
          "---------------"
        ]
      }
    }
  ]
}
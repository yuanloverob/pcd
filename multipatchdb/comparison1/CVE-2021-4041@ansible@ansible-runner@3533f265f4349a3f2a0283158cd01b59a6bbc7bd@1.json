{
  "cve_id": "CVE-2021-4041",
  "cve_desc": "A flaw was found in ansible-runner. An improper escaping of the shell command, while calling the ansible_runner.interface.run_command, can lead to parameters getting executed as host's shell command. A developer could unintentionally write code that gets executed in the host rather than the virtual environment.",
  "repo": "ansible/ansible-runner",
  "patch_hash": "3533f265f4349a3f2a0283158cd01b59a6bbc7bd",
  "patch_info": {
    "commit_hash": "3533f265f4349a3f2a0283158cd01b59a6bbc7bd",
    "repo": "ansible/ansible-runner",
    "commit_url": "https://github.com/ansible/ansible-runner/commit/3533f265f4349a3f2a0283158cd01b59a6bbc7bd",
    "files": [
      "ansible_runner/config/doc.py",
      "ansible_runner/runner.py",
      "test/integration/test_interface.py",
      "test/unit/config/test_doc.py"
    ],
    "message": "Remove shell use in subprocess\n\nCo-authored-by: Sam Doran <sdoran@redhat.com>",
    "before_after_code_files": [
      "ansible_runner/config/doc.py||ansible_runner/config/doc.py",
      "ansible_runner/runner.py||ansible_runner/runner.py",
      "test/integration/test_interface.py||test/integration/test_interface.py",
      "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
    ]
  },
  "patch_diff": {
    "ansible_runner/config/doc.py||ansible_runner/config/doc.py": [
      "File: ansible_runner/config/doc.py -> ansible_runner/config/doc.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:         if module_path:",
      "88:             self.cmdline_args.extend(['-M', module_path])",
      "92:         self.command = [self._ansible_doc_exec_path] + self.cmdline_args",
      "93:         self._handle_command_wrap(self.execution_mode, self.cmdline_args)",
      "",
      "[Removed Lines]",
      "90:         self.cmdline_args.append(\" \".join(plugin_names))",
      "",
      "[Added Lines]",
      "90:         self.cmdline_args.extend(plugin_names)",
      "",
      "---------------"
    ],
    "ansible_runner/runner.py||ansible_runner/runner.py": [
      "File: ansible_runner/runner.py -> ansible_runner/runner.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "204:             user = getpass.getuser()",
      "205:             group = grp.getgrgid(os.getgid()).gr_name",
      "209:             _, stderr = proc.communicate()",
      "210:             if proc.returncode:",
      "211:                 # Unable to create cgroup",
      "",
      "[Removed Lines]",
      "207:             cmd = 'cgcreate -a {user}:{group} -t {user}:{group} -g cpuacct,memory,pids:{}'.format(cgroup_path, user=user, group=group)",
      "208:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)",
      "",
      "[Added Lines]",
      "207:             cmd = ['cgcreate',",
      "208:                    '-a', f'{user}:{group}',",
      "209:                    '-t', f'{user}:{group}',",
      "210:                    '-g', f'cpuacct,memory,pids:{cgroup_path}',",
      "211:                    ]",
      "212:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "249:                     'stderr': error_fd,",
      "250:                     'check': True,",
      "251:                     'universal_newlines': True,",
      "253:                 }",
      "254:                 if subprocess_timeout is not None:",
      "255:                     kwargs.update({'timeout': subprocess_timeout})",
      "259:                 stdout_response = proc_out.stdout",
      "260:                 stderr_response = proc_out.stderr",
      "",
      "[Removed Lines]",
      "252:                     'shell': True",
      "257:                 proc_out = run_subprocess(\" \".join(command), **kwargs)",
      "",
      "[Added Lines]",
      "260:                 proc_out = run_subprocess(command, **kwargs)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "391:                 return True",
      "392:             _delete()",
      "393:         if self.resource_profiling:",
      "396:             _, stderr = proc.communicate()",
      "397:             if proc.returncode:",
      "398:                 logger.error('Failed to delete cgroup: {}'.format(stderr))",
      "",
      "[Removed Lines]",
      "394:             cmd = 'cgdelete -g cpuacct,memory,pids:{}'.format(cgroup_path)",
      "395:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)",
      "",
      "[Added Lines]",
      "397:             cmd = ['cgdelete', '-g', f'cpuacct,memory,pids:{cgroup_path}']",
      "398:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "532:         container_name = self.config.container_name",
      "533:         if container_name:",
      "534:             container_cli = self.config.process_isolation_executable",
      "537:             _, stderr = proc.communicate()",
      "538:             if proc.returncode:",
      "539:                 logger.info('Error from {} kill {} command:\\n{}'.format(container_cli, container_name, stderr))",
      "",
      "[Removed Lines]",
      "535:             cmd = '{} kill {}'.format(container_cli, container_name)",
      "536:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)",
      "",
      "[Added Lines]",
      "538:             cmd = [container_cli, 'kill', container_name]",
      "539:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE)",
      "",
      "---------------"
    ],
    "test/integration/test_interface.py||test/integration/test_interface.py": [
      "File: test/integration/test_interface.py -> test/integration/test_interface.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:     assert err == ''",
      "155: @pytest.mark.test_all_runtimes",
      "156: def test_run_ansible_command_within_container(project_fixtures, runtime):",
      "157:     private_data_dir = project_fixtures / 'debug'",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "155: def test_run_command_injection_error():",
      "156:     out, err, rc = run_command(",
      "157:         executable_cmd='whoami',",
      "158:         cmdline_args=[';hostname'],",
      "159:         runner_mode='subprocess',",
      "160:     )",
      "161:     assert rc == 1",
      "162:     assert \"usage: whoami\" in err or \"whoami: extra operand \u2018;hostname\u2019\" in err",
      "165: @pytest.mark.test_all_runtimes",
      "166: def test_run_command_injection_error_within_container(runtime):",
      "167:     out, err, rc = run_command(",
      "168:         executable_cmd='whoami',",
      "169:         cmdline_args=[';hostname'],",
      "170:         runner_mode='subprocess',",
      "171:         process_isolation_executable=runtime,",
      "172:         process_isolation=True,",
      "173:         container_image=defaults.default_container_image,",
      "174:     )",
      "175:     assert rc == 1",
      "176:     assert \"whoami: extra operand ';hostname'\" in err",
      "",
      "---------------"
    ],
    "test/unit/config/test_doc.py||test/unit/config/test_doc.py": [
      "File: test/unit/config/test_doc.py -> test/unit/config/test_doc.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "52:     plugin_names = ['copy', 'file']",
      "53:     plugin_type = 'module'",
      "54:     rc.prepare_plugin_docs_command(plugin_names, plugin_type=plugin_type, snippet=True, playbook_dir='/tmp/test')",
      "56:     assert rc.command == expected_command",
      "57:     assert rc.runner_mode == 'subprocess'",
      "58:     assert rc.execution_mode == BaseExecutionMode.ANSIBLE_COMMANDS",
      "",
      "[Removed Lines]",
      "55:     expected_command = [get_executable_path('ansible-doc'), '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy file']",
      "",
      "[Added Lines]",
      "55:     expected_command = [get_executable_path('ansible-doc'), '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy', 'file']",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "113:         '-s',",
      "114:         '-t', 'module',",
      "115:         '--playbook-dir', '/tmp/test',",
      "117:         'file',",
      "118:     ])",
      "",
      "[Removed Lines]",
      "116:         'copy '",
      "",
      "[Added Lines]",
      "116:         'copy',",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7d012d743ce80ceb1f3478d792dc9b28caafb113",
      "candidate_info": {
        "commit_hash": "7d012d743ce80ceb1f3478d792dc9b28caafb113",
        "repo": "ansible/ansible-runner",
        "commit_url": "https://github.com/ansible/ansible-runner/commit/7d012d743ce80ceb1f3478d792dc9b28caafb113",
        "files": [
          "test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py"
        ],
        "message": "fix testcase failure",
        "before_after_code_files": [
          "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_doc.py||test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ],
          "candidate": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ]
        }
      },
      "candidate_diff": {
        "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py": [
          "File: test/unit/config/test_ansible_cfg.py -> test/unit/config/test_ansible_cfg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: from ansible_runner.config.ansible_cfg import AnsibleCfgConfig",
          "7: from ansible_runner.config._base import BaseExecutionMode",
          "8: from ansible_runner.exceptions import ConfigurationError",
          "11: def test_ansible_cfg_init_defaults():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: from ansible_runner.utils import get_executable_path",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: def test_prepare_config_command():",
          "25:     rc = AnsibleCfgConfig()",
          "26:     rc.prepare_ansible_config_command('list', config_file='/tmp/ansible.cfg')",
          "28:     assert rc.command == expected_command",
          "29:     assert rc.runner_mode == 'subprocess'",
          "",
          "[Removed Lines]",
          "27:     expected_command = ['ansible-config', 'list', '-c', '/tmp/ansible.cfg']",
          "",
          "[Added Lines]",
          "28:     expected_command = [get_executable_path('ansible-config'), 'list', '-c', '/tmp/ansible.cfg']",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "75:         extra_container_args + \\",
          "76:         ['--name', 'ansible_runner_foo'] + \\",
          "79:     for index, element in enumerate(expected_command_start):",
          "80:         if '--user=' in element:",
          "",
          "[Removed Lines]",
          "77:         ['my_container', 'ansible-config', 'list', '-c', '/tmp/ansible.cfg']",
          "",
          "[Added Lines]",
          "78:         ['my_container', get_executable_path('ansible-config'), 'list', '-c', '/tmp/ansible.cfg']",
          "",
          "---------------"
        ],
        "test/unit/config/test_doc.py||test/unit/config/test_doc.py": [
          "File: test/unit/config/test_doc.py -> test/unit/config/test_doc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: from ansible_runner.config.doc import DocConfig",
          "7: from ansible_runner.config._base import BaseExecutionMode",
          "8: from ansible_runner.exceptions import ConfigurationError",
          "11: def test_ansible_doc_defaults():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: from ansible_runner.utils import get_executable_path",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45:     plugin_names = ['copy', 'file']",
          "46:     plugin_type = 'module'",
          "47:     rc.prepare_plugin_docs_command(plugin_names, plugin_type=plugin_type, snippet=True, playbook_dir='/tmp/test')",
          "49:     assert rc.command == expected_command",
          "50:     assert rc.runner_mode == 'subprocess'",
          "51:     assert rc.execution_mode == BaseExecutionMode.ANSIBLE_COMMANDS",
          "",
          "[Removed Lines]",
          "48:     expected_command = ['ansible-doc', '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy file']",
          "",
          "[Added Lines]",
          "49:     expected_command = [get_executable_path('ansible-doc'), '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy file']",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "85:         extra_container_args + \\",
          "86:         ['--name', 'ansible_runner_foo'] + \\",
          "89:     for index, element in enumerate(expected_command_start):",
          "90:         if '--user=' in element:",
          "",
          "[Removed Lines]",
          "87:         ['my_container'] + ['ansible-doc', '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy file']",
          "",
          "[Added Lines]",
          "88:         ['my_container'] + [get_executable_path('ansible-doc'), '-s', '-t', 'module', '--playbook-dir', '/tmp/test', 'copy file']",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "96: def test_prepare_plugin_list_command():",
          "97:     rc = DocConfig()",
          "98:     rc.prepare_plugin_list_command(list_files=True, plugin_type='module', playbook_dir='/tmp/test', module_path='/test/module')",
          "100:     assert rc.command == expected_command",
          "101:     assert rc.runner_mode == 'subprocess'",
          "102:     assert rc.execution_mode == BaseExecutionMode.ANSIBLE_COMMANDS",
          "",
          "[Removed Lines]",
          "99:     expected_command = ['ansible-doc', '-F', '-t', 'module', '--playbook-dir', '/tmp/test', '-M', '/test/module']",
          "",
          "[Added Lines]",
          "100:     expected_command = [get_executable_path('ansible-doc'), '-F', '-t', 'module', '--playbook-dir', '/tmp/test', '-M', '/test/module']",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "132:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "133:         extra_container_args + \\",
          "134:         ['--name', 'ansible_runner_foo'] + \\",
          "137:     for index, element in enumerate(expected_command_start):",
          "138:         if '--user=' in element:",
          "",
          "[Removed Lines]",
          "135:         ['my_container'] + ['ansible-doc', '-F', '-t', 'module', '--playbook-dir', '/tmp/test', '-M', '/test/module']",
          "",
          "[Added Lines]",
          "136:         ['my_container'] + [get_executable_path('ansible-doc'), '-F', '-t', 'module', '--playbook-dir', '/tmp/test', '-M', '/test/module']",
          "",
          "---------------"
        ],
        "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py": [
          "File: test/unit/config/test_inventory.py -> test/unit/config/test_inventory.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: from ansible_runner.config.inventory import InventoryConfig",
          "7: from ansible_runner.config._base import BaseExecutionMode",
          "8: from ansible_runner.exceptions import ConfigurationError",
          "11: def test_ansible_cfg_init_defaults():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: from ansible_runner.utils import get_executable_path",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:     inventories = ['/tmp/inventory1', '/tmp/inventory2']",
          "27:     rc.prepare_inventory_command('list', inventories, response_format='yaml', playbook_dir='/tmp',",
          "28:                                  vault_ids='1234', vault_password_file='/tmp/password')",
          "30:                        ['/tmp', '--vault-id', '1234', '--vault-password-file', '/tmp/password']",
          "31:     assert rc.command == expected_command",
          "32:     assert rc.runner_mode == 'subprocess'",
          "",
          "[Removed Lines]",
          "29:     expected_command = ['ansible-inventory', '--list', '-i', '/tmp/inventory1', '-i', '/tmp/inventory2', '--yaml', '--playbook-dir'] + \\",
          "",
          "[Added Lines]",
          "30:     expected_command = [get_executable_path('ansible-inventory'), '--list', '-i', '/tmp/inventory1', '-i', '/tmp/inventory2', '--yaml', '--playbook-dir'] + \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "109:         extra_container_args + \\",
          "110:         ['--name', 'ansible_runner_foo', 'my_container'] + \\",
          "112:         ['/tmp', '--vault-id', '1234', '--vault-password-file', '/tmp/password']",
          "114:     for index, element in enumerate(expected_command_start):",
          "",
          "[Removed Lines]",
          "111:         ['ansible-inventory', '--list', '-i', '/tmp/inventory1', '-i', '/tmp/inventory2', '--yaml', '--playbook-dir'] + \\",
          "",
          "[Added Lines]",
          "112:         [get_executable_path('ansible-inventory'), '--list', '-i', '/tmp/inventory1', '-i', '/tmp/inventory2', '--yaml', '--playbook-dir'] + \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d4d1584503c075ca425a9b15729ebc7547ef3a3",
      "candidate_info": {
        "commit_hash": "6d4d1584503c075ca425a9b15729ebc7547ef3a3",
        "repo": "ansible/ansible-runner",
        "commit_url": "https://github.com/ansible/ansible-runner/commit/6d4d1584503c075ca425a9b15729ebc7547ef3a3",
        "files": [
          "test/unit/config/test__base.py",
          "test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_command.py",
          "test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py"
        ],
        "message": "fix unit test failures",
        "before_after_code_files": [
          "test/unit/config/test__base.py||test/unit/config/test__base.py",
          "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_command.py||test/unit/config/test_command.py",
          "test/unit/config/test_doc.py||test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ],
          "candidate": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ]
        }
      },
      "candidate_diff": {
        "test/unit/config/test__base.py||test/unit/config/test__base.py": [
          "File: test/unit/config/test__base.py -> test/unit/config/test__base.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "288:     if container_runtime == 'podman':",
          "289:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "293:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "294:         extra_container_args + \\",
          "295:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "291:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "292:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "291:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "292:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py": [
          "File: test/unit/config/test_ansible_cfg.py -> test/unit/config/test_ansible_cfg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     if container_runtime == 'podman':",
          "71:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "75:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "76:         extra_container_args + \\",
          "77:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "73:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "74:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "73:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "74:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_command.py||test/unit/config/test_command.py": [
          "File: test/unit/config/test_command.py -> test/unit/config/test_command.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:         extra_container_args = ['--user={os.getuid()}']",
          "80:     expected_command_start = [container_runtime, 'run', '--rm', '--interactive', '--tty', '--workdir', '/runner/project'] + \\",
          "82:     if container_runtime == 'podman':",
          "83:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "87:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "88:         extra_container_args + \\",
          "89:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "81:                              ['-v', '{}:{}'.format(cwd, cwd), '-v', '{}/.ssh/:/home/runner/.ssh/'.format(os.environ['HOME'])]",
          "85:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "86:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "81:                              ['-v', '{}/:{}'.format(cwd, cwd), '-v', '{}/.ssh/:/home/runner/.ssh/'.format(os.environ['HOME'])]",
          "85:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "86:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_doc.py||test/unit/config/test_doc.py": [
          "File: test/unit/config/test_doc.py -> test/unit/config/test_doc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:     if container_runtime == 'podman':",
          "81:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "85:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "86:         extra_container_args + \\",
          "87:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "83:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "84:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "83:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "84:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:     if container_runtime == 'podman':",
          "129:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "133:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "134:         extra_container_args + \\",
          "135:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "131:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "132:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "131:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "132:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py": [
          "File: test/unit/config/test_inventory.py -> test/unit/config/test_inventory.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:     if container_runtime == 'podman':",
          "106:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "110:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "111:         extra_container_args + \\",
          "112:         ['--name', 'ansible_runner_foo', 'my_container'] + \\",
          "",
          "[Removed Lines]",
          "108:     expected_command_start += ['-v', '{}/artifacts:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "109:         ['-v', '{}:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "108:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "109:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec5a831152229ade0669e22d50b685519bfa1407",
      "candidate_info": {
        "commit_hash": "ec5a831152229ade0669e22d50b685519bfa1407",
        "repo": "ansible/ansible-runner",
        "commit_url": "https://github.com/ansible/ansible-runner/commit/ec5a831152229ade0669e22d50b685519bfa1407",
        "files": [
          ".gitignore",
          "ansible_runner/config/_base.py",
          "test/integration/test_main.py",
          "test/unit/config/test__base.py",
          "test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_command.py",
          "test/unit/config/test_container_volmount_generation.py",
          "test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py",
          "test/unit/config/test_runner.py"
        ],
        "message": "Fix, test",
        "before_after_code_files": [
          "ansible_runner/config/_base.py||ansible_runner/config/_base.py",
          "test/integration/test_main.py||test/integration/test_main.py",
          "test/unit/config/test__base.py||test/unit/config/test__base.py",
          "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py",
          "test/unit/config/test_command.py||test/unit/config/test_command.py",
          "test/unit/config/test_container_volmount_generation.py||test/unit/config/test_container_volmount_generation.py",
          "test/unit/config/test_doc.py||test/unit/config/test_doc.py",
          "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py",
          "test/unit/config/test_runner.py||test/unit/config/test_runner.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ],
          "candidate": [
            "test/unit/config/test_doc.py||test/unit/config/test_doc.py"
          ]
        }
      },
      "candidate_diff": {
        "ansible_runner/config/_base.py||ansible_runner/config/_base.py": [
          "File: ansible_runner/config/_base.py -> ansible_runner/config/_base.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "276:     def _ensure_path_safe_to_mount(self, path):",
          "277:         if os.path.isfile(path):",
          "278:             path = os.path.dirname(path)",
          "280:             raise ConfigurationError(\"When using containerized execution, cannot mount '/' or '/home' or '/usr'\")",
          "282:     def _get_playbook_path(self, cmdline_args):",
          "",
          "[Removed Lines]",
          "279:         if path in ('/', '/home', '/usr'):",
          "",
          "[Added Lines]",
          "279:         if os.path.join(path, \"\") in ('/', '/home/', '/usr/'):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:                     break",
          "312:         return _playbook",
          "324:         if src_mount_path is None or not os.path.exists(src_mount_path):",
          "325:             logger.debug(\"Source volume mount path does not exit {0}\".format(src_mount_path))",
          "326:             return",
          "349:         if labels:",
          "350:             volume_mount_path += labels",
          "352:         # check if mount path already added in args list",
          "353:         if volume_mount_path not in args_list:",
          "356:     def _handle_ansible_cmd_options_bind_mounts(self, args_list, cmdline_args):",
          "357:         inventory_file_options = ['-i', '--inventory', '--inventory-file']",
          "",
          "[Removed Lines]",
          "315:     def _add_trailing_slash_if_needed(self, some_path):",
          "316:         if os.path.isdir(some_path):",
          "317:             return some_path + '/' if (some_path[-1] != '/') else some_path",
          "318:         else:",
          "319:             return some_path",
          "322:     def _update_volume_mount_paths(self, args_list, src_mount_path, dest_mount_path=None, labels=None):",
          "328:         if dest_mount_path is None:",
          "329:             dest_mount_path = src_mount_path",
          "331:         self._ensure_path_safe_to_mount(src_mount_path)",
          "333:         src_mount_path = self._add_trailing_slash_if_needed(src_mount_path)",
          "335:         if os.path.isabs(src_mount_path):",
          "336:             if os.path.isdir(src_mount_path):",
          "337:                 volume_mount_path = \"{}:{}\".format(src_mount_path, dest_mount_path)",
          "338:             else:",
          "339:                 volume_mount_path = \"{}:{}\".format(os.path.dirname(src_mount_path), os.path.dirname(dest_mount_path))",
          "340:         else:",
          "341:             if self.container_workdir and not os.path.isabs(dest_mount_path):",
          "342:                 dest_mount_path = os.path.join(self.container_workdir, dest_mount_path)",
          "344:             if os.path.isdir(os.path.abspath(src_mount_path)):",
          "345:                 volume_mount_path = \"{}:{}\".format(src_mount_path, dest_mount_path)",
          "346:             else:",
          "347:                 volume_mount_path = \"{}:{}\".format(os.path.dirname(src_mount_path), os.path.dirname(dest_mount_path))",
          "354:             args_list.extend(['-v', volume_mount_path])",
          "",
          "[Added Lines]",
          "314:     def _update_volume_mount_paths(",
          "315:         self, args_list, src_mount_path, dst_mount_path=None, labels=None",
          "316:     ):",
          "322:         # ensure source is abs",
          "323:         src_path = os.path.abspath(os.path.expanduser(os.path.expandvars(src_mount_path)))",
          "325:         # set dest src (if None) relative to workdir(not absolute) or provided",
          "326:         if dst_mount_path is None:",
          "327:             dst_path = src_path",
          "328:         elif self.container_workdir and not os.path.isabs(dst_mount_path):",
          "329:             dst_path = os.path.abspath(",
          "330:                 os.path.expanduser(",
          "331:                     os.path.expandvars(os.path.join(self.container_workdir, dst_mount_path))",
          "332:                 )",
          "333:             )",
          "334:         else:",
          "335:             dst_path = os.path.abspath(os.path.expanduser(os.path.expandvars(dst_mount_path)))",
          "337:         # ensure each is a directory not file, use src for dest",
          "338:         # because dest doesn't exist locally",
          "339:         src_dir = src_path if os.path.isdir(src_path) else os.path.dirname(src_path)",
          "340:         dst_dir = dst_path if os.path.isdir(src_path) else os.path.dirname(dst_path)",
          "342:         # always ensure a trailing slash",
          "343:         src_dir = os.path.join(src_dir, \"\")",
          "344:         dst_dir = os.path.join(dst_dir, \"\")",
          "346:         # ensure the src and dest are safe mount points",
          "347:         # after stripping off the file and resolving",
          "348:         self._ensure_path_safe_to_mount(src_dir)",
          "349:         self._ensure_path_safe_to_mount(dst_dir)",
          "351:         # format the src dest str",
          "352:         volume_mount_path = \"{}:{}\".format(src_dir, dst_dir)",
          "354:         # add labels as needed",
          "356:             if not labels.startswith(\":\"):",
          "357:                 volume_mount_path += \":\"",
          "363:             args_list.extend([\"-v\", volume_mount_path])",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "444:             # runtime commands need artifacts mounted to output data",
          "445:             self._update_volume_mount_paths(new_args,",
          "446:                                             \"{}/artifacts\".format(self.private_data_dir),",
          "448:                                             labels=\":Z\")",
          "450:             # Mount the entire private_data_dir",
          "451:             # custom show paths inside private_data_dir do not make sense",
          "452:             self._update_volume_mount_paths(new_args,",
          "453:                                             \"{}\".format(self.private_data_dir),",
          "455:                                             labels=\":Z\")",
          "456:         else:",
          "457:             subdir_path = os.path.join(self.private_data_dir, 'artifacts')",
          "",
          "[Removed Lines]",
          "447:                                             dest_mount_path=\"/runner/artifacts\",",
          "454:                                             dest_mount_path=\"/runner\",",
          "",
          "[Added Lines]",
          "456:                                             dst_mount_path=\"/runner/artifacts\",",
          "463:                                             dst_mount_path=\"/runner\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "461:             # Mount the entire private_data_dir",
          "462:             # custom show paths inside private_data_dir do not make sense",
          "465:         if self.container_volume_mounts:",
          "466:             for mapping in self.container_volume_mounts:",
          "",
          "[Removed Lines]",
          "463:             self._update_volume_mount_paths(new_args, \"{}\".format(self.private_data_dir), dest_mount_path=\"/runner\", labels=\":Z\")",
          "",
          "[Added Lines]",
          "472:             self._update_volume_mount_paths(new_args, \"{}\".format(self.private_data_dir), dst_mount_path=\"/runner\", labels=\":Z\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "469:                 labels = None",
          "470:                 if len(volume_mounts) == 3:",
          "471:                     labels = \":%s\" %volume_mounts[2]",
          "474:         # Reference the file with list of keys to pass into container",
          "475:         # this file will be written in ansible_runner.runner",
          "",
          "[Removed Lines]",
          "472:                 self._update_volume_mount_paths(new_args, volume_mounts[0], dest_mount_path=volume_mounts[1], labels=labels)",
          "",
          "[Added Lines]",
          "481:                 self._update_volume_mount_paths(new_args, volume_mounts[0], dst_mount_path=volume_mounts[1], labels=labels)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "534:                         else:",
          "535:                             dest_path = os.environ[env]",
          "539:                     new_args.extend([\"-e\", \"{}={}\".format(env, dest_path)])",
          "541:             for paths in cli_automount['PATHS']:",
          "542:                 if os.path.exists(paths['src']):",
          "",
          "[Removed Lines]",
          "537:                         self._update_volume_mount_paths(new_args, os.environ[env], dest_mount_path=dest_path)",
          "543:                     self._update_volume_mount_paths(new_args, paths['src'], dest_mount_path=paths['dest'])",
          "",
          "[Added Lines]",
          "546:                         self._update_volume_mount_paths(new_args, os.environ[env], dst_mount_path=dest_path)",
          "552:                     self._update_volume_mount_paths(new_args, paths['src'], dst_mount_path=paths['dest'])",
          "",
          "---------------"
        ],
        "test/integration/test_main.py||test/integration/test_main.py": [
          "File: test/integration/test_main.py -> test/integration/test_main.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:     rc = main(['run', '-r', 'benthomasson.hello_role',",
          "134:                '--hosts', 'localhost',",
          "135:                '--roles-path', 'test/integration/project/roles',",
          "137:                'test/integration'])",
          "139:     assert rc == 0",
          "",
          "[Removed Lines]",
          "136:                '--logfile', 'new_logfile',",
          "138:     assert os.path.exists('new_logfile')",
          "",
          "[Added Lines]",
          "136:                '--logfile', 'test_role_logfile',",
          "138:     assert os.path.exists('test_role_logfile'), rc",
          "",
          "---------------"
        ],
        "test/unit/config/test__base.py||test/unit/config/test__base.py": [
          "File: test/unit/config/test__base.py -> test/unit/config/test__base.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "261:     for i, entry in enumerate(new_args):",
          "262:         if entry == '-v':",
          "263:             mount = new_args[i + 1]",
          "265:                 break",
          "266:     else:",
          "267:         raise Exception('Could not find expected mount, args: {}'.format(new_args))",
          "",
          "[Removed Lines]",
          "264:             if mount.endswith('project_path:Z'):",
          "",
          "[Added Lines]",
          "264:             if mount.endswith('project_path/:Z'):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "295:     if container_runtime == 'podman':",
          "296:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "300:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "301:         extra_container_args + \\",
          "302:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "298:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "299:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "298:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "299:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_ansible_cfg.py||test/unit/config/test_ansible_cfg.py": [
          "File: test/unit/config/test_ansible_cfg.py -> test/unit/config/test_ansible_cfg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:     if container_runtime == 'podman':",
          "71:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "75:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "76:         extra_container_args + \\",
          "77:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "73:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "74:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "73:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "74:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_command.py||test/unit/config/test_command.py": [
          "File: test/unit/config/test_command.py -> test/unit/config/test_command.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:         extra_container_args = ['--user={os.getuid()}']",
          "80:     expected_command_start = [container_runtime, 'run', '--rm', '--tty', '--interactive', '--workdir', '/runner/project'] + \\",
          "83:     if container_runtime == 'podman':",
          "84:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "88:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "89:         extra_container_args + \\",
          "90:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "81:                              ['-v', '{}/:{}'.format(cwd, cwd), '-v', '{}/.ssh/:/home/runner/.ssh/'.format(os.environ['HOME'])]",
          "86:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "87:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "81:                              ['-v', '{}/:{}/'.format(cwd, cwd), '-v', '{}/.ssh/:/home/runner/.ssh/'.format(os.environ['HOME'])]",
          "86:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "87:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_container_volmount_generation.py||test/unit/config/test_container_volmount_generation.py": [
          "File: test/unit/config/test_container_volmount_generation.py -> test/unit/config/test_container_volmount_generation.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \"\"\" Ensure the generation of container volume mounts is handled",
          "2: predictably and consistently \"\"\"",
          "4: import os",
          "5: import pytest",
          "7: from unittest.mock import patch",
          "9: from typing import NamedTuple",
          "11: from ansible_runner.config._base import BaseConfig",
          "12: from ansible_runner.exceptions import ConfigurationError",
          "15: class Variation(NamedTuple):",
          "16:     \"\"\"one piece of the path\"\"\"",
          "18:     comment: str",
          "19:     path: str",
          "22: dir_variations = (",
          "23:     Variation(comment=\"dir no slash\", path=\"/somedir_0\"),",
          "24:     Variation(comment=\"dir with slash\", path=\"/somedir_1/\"),",
          "25:     Variation(comment=\"nested dir no slash\", path=\"/somedir/otherdir_0\"),",
          "26:     Variation(comment=\"nested dir with slash\", path=\"/somedir/otherdir_1/\"),",
          "27:     Variation(comment=\"path with dot\", path=\"/somedir/foo.bar\"),",
          "28:     Variation(comment=\"path with var no slash\", path=\"$HOME/somedir_0\"),",
          "29:     Variation(comment=\"path with var slash\", path=\"$HOME/somedir_1\"),",
          "30:     Variation(comment=\"path with ~ no slash\", path=\"~/somedir_2\"),",
          "31:     Variation(comment=\"path with ~ slash\", path=\"~/somedir_3\"),",
          "32: )",
          "34: labels = (None, \"\", \"Z\", \"ro,Z\", \":z\")",
          "35: not_safe = (\"/\", \"/home\", \"/usr\")",
          "38: def id_for_dst(value):",
          "39:     \"\"\"generate a test id for dest\"\"\"",
          "40:     return f\"dst->{value.comment}\"",
          "43: def id_for_isdir(value):",
          "44:     \"\"\"generate a test id for dest\"\"\"",
          "45:     return f\"isdir->{value}\"",
          "48: def id_for_label(value):",
          "49:     \"\"\"generate a test id for labels\"\"\"",
          "50:     return f\"labels->{value}\"",
          "53: def id_for_src(value):",
          "54:     \"\"\"generate a test id for src\"\"\"",
          "55:     return f\"src->{value.comment}\"",
          "58: def resolve_path(path):",
          "59:     \"\"\"Fully resolve a path\"\"\"",
          "60:     return os.path.abspath(os.path.expanduser(os.path.expandvars(path)))",
          "63: def generate_volmount_args(src_str, dst_str, labels):",
          "64:     \"\"\"Generate a podman style volmount string\"\"\"",
          "65:     vol_mount_str = f\"{src_str}:{dst_str}\"",
          "66:     if labels:",
          "67:         if not labels.startswith(\":\"):",
          "68:             vol_mount_str += \":\"",
          "69:         vol_mount_str += labels",
          "70:     return [\"-v\", vol_mount_str]",
          "73: @patch(\"os.path.exists\", return_value=True)",
          "74: @pytest.mark.parametrize(\"not_safe\", not_safe)",
          "75: def test_check_not_safe_to_mount_dir(_mock_ope, not_safe):",
          "76:     \"\"\"Ensure unsafe directories are not mounted\"\"\"",
          "77:     with pytest.raises(ConfigurationError):",
          "78:         BaseConfig()._update_volume_mount_paths(",
          "79:             args_list=[], src_mount_path=not_safe, dst_mount_path=None",
          "80:         )",
          "83: @patch(\"os.path.exists\", return_value=True)",
          "84: @pytest.mark.parametrize(\"not_safe\", not_safe)",
          "85: def test_check_not_safe_to_mount_file(_mock_ope, not_safe):",
          "86:     \"\"\"Ensure unsafe directories for a given file are not mounted\"\"\"",
          "87:     file_path = os.path.join(not_safe, \"file.txt\")",
          "88:     with pytest.raises(ConfigurationError):",
          "89:         BaseConfig()._update_volume_mount_paths(",
          "90:             args_list=[], src_mount_path=file_path, dst_mount_path=None",
          "91:         )",
          "94: @patch(\"os.path.exists\", return_value=True)",
          "95: @patch(\"os.path.isdir\", return_value=True)",
          "96: @pytest.mark.parametrize(\"path\", dir_variations, ids=id_for_src)",
          "97: def test_duplicate_detection_dst(_mock_ope, _mock_isdir, path):",
          "98:     \"\"\"Ensure no duplicate volumne mount entries are created\"\"\"",
          "99:     base_config = BaseConfig()",
          "101:     def generate(args_list):",
          "102:         for entry in dir_variations:",
          "103:             for label in labels:",
          "104:                 base_config._update_volume_mount_paths(",
          "105:                     args_list=first_pass,",
          "106:                     src_mount_path=path.path,",
          "107:                     dst_mount_path=entry.path,",
          "108:                     labels=label,",
          "109:                 )",
          "111:     first_pass = []",
          "112:     generate(first_pass)",
          "113:     second_pass = first_pass[:]",
          "114:     generate(second_pass)",
          "115:     assert first_pass == second_pass",
          "118: @patch(\"os.path.exists\", return_value=True)",
          "119: @patch(\"os.path.isdir\", return_value=True)",
          "120: @pytest.mark.parametrize(\"labels\", labels, ids=id_for_label)",
          "121: @pytest.mark.parametrize(\"path\", dir_variations, ids=id_for_src)",
          "122: def test_no_dst_all_dirs(_mock_ope, _mock_isdir, path, labels):",
          "123:     \"\"\"Ensure dst == src when not provided\"\"\"",
          "124:     src_str = os.path.join(resolve_path(path.path), \"\")",
          "125:     dst_str = src_str",
          "126:     expected = generate_volmount_args(src_str=src_str, dst_str=dst_str, labels=labels)",
          "128:     result = []",
          "129:     BaseConfig()._update_volume_mount_paths(",
          "130:         args_list=result, src_mount_path=path.path, dst_mount_path=None, labels=labels",
          "131:     )",
          "133:     explanation = (",
          "134:         f\"provided: {path.path}:{None}\",",
          "135:         f\"got: {result}\",",
          "136:         f\"expected {expected}\",",
          "137:     )",
          "138:     assert result == expected, explanation",
          "139:     assert all(part.endswith('/') for part in result[1].split(':')[0:1]), explanation",
          "143: @patch(\"os.path.exists\", return_value=True)",
          "144: @patch(\"os.path.isdir\", return_value=True)",
          "145: @pytest.mark.parametrize(\"labels\", labels, ids=id_for_label)",
          "146: @pytest.mark.parametrize(\"dst\", dir_variations, ids=id_for_dst)",
          "147: @pytest.mark.parametrize(\"src\", dir_variations, ids=id_for_src)",
          "148: def test_src_dst_all_dirs(_mock_ope, _mock_isdir, src, dst, labels):",
          "149:     \"\"\"Ensure src and dest end with trailing slash\"\"\"",
          "150:     src_str = os.path.join(resolve_path(src.path), \"\")",
          "151:     dst_str = os.path.join(resolve_path(dst.path), \"\")",
          "152:     expected = generate_volmount_args(src_str=src_str, dst_str=dst_str, labels=labels)",
          "154:     result = []",
          "155:     BaseConfig()._update_volume_mount_paths(",
          "156:         args_list=result, src_mount_path=src.path, dst_mount_path=dst.path, labels=labels",
          "157:     )",
          "159:     explanation = (",
          "160:         f\"provided: {src.path}:{dst.path}\",",
          "161:         f\"got: {result}\",",
          "162:         f\"expected {expected}\",",
          "163:     )",
          "164:     assert result == expected, explanation",
          "165:     assert all(part.endswith('/') for part in result[1].split(':')[0:1]), explanation",
          "169: @patch(\"os.path.exists\", return_value=True)",
          "170: @pytest.mark.parametrize(\"labels\", labels, ids=id_for_label)",
          "171: @pytest.mark.parametrize(\"path\", dir_variations, ids=id_for_src)",
          "172: def test_src_dst_all_files(_mock_ope, path, labels):",
          "173:     \"\"\"Ensure file paths are tranformed correctly into dir paths\"\"\"",
          "174:     src_str = os.path.join(resolve_path(path.path), \"\")",
          "175:     dst_str = src_str",
          "176:     expected = generate_volmount_args(src_str=src_str, dst_str=dst_str, labels=labels)",
          "178:     result = []",
          "179:     src_file = os.path.join(path.path, \"\", \"file.txt\")",
          "180:     dest_file = src_file",
          "182:     base_config = BaseConfig()",
          "183:     with patch(\"os.path.isdir\", return_value=False):",
          "184:         base_config._update_volume_mount_paths(",
          "185:             args_list=result, src_mount_path=src_file, dst_mount_path=dest_file, labels=labels",
          "186:         )",
          "188:     explanation = (",
          "189:         f\"provided: {src_file}:{dest_file}\",",
          "190:         f\"got: {result}\",",
          "191:         f\"expected {expected}\",",
          "192:     )",
          "193:     assert result == expected, explanation",
          "194:     assert all(part.endswith('/') for part in result[1].split(':')[0:1]), explanation",
          "198: @patch(\"os.path.exists\", return_value=True)",
          "199: @patch(\"os.path.isdir\", return_value=True)",
          "200: @pytest.mark.parametrize(\"relative\", (\".\", \"..\", \"../..\"))",
          "201: @pytest.mark.parametrize(\"labels\", labels, ids=id_for_label)",
          "202: @pytest.mark.parametrize(\"dst\", dir_variations, ids=id_for_dst)",
          "203: @pytest.mark.parametrize(\"src\", dir_variations, ids=id_for_src)",
          "204: def test_src_dst_all_relative_dirs(_mock_ope, _mock_isdir, src, dst, labels, relative):",
          "205:     \"\"\"Ensure src is resolved and dest mapped to workdir when relative\"\"\"",
          "206:     relative_src = f\"{relative}{src.path}\"",
          "207:     relative_dst = f\"{relative}{dst.path}\"",
          "208:     workdir = \"/workdir\"",
          "209:     src_str = os.path.join(resolve_path(relative_src), \"\")",
          "210:     dst_str = os.path.join(resolve_path(os.path.join(workdir, relative_dst)), \"\")",
          "211:     expected = generate_volmount_args(src_str=src_str, dst_str=dst_str, labels=labels)",
          "213:     result = []",
          "214:     BaseConfig(container_workdir=workdir)._update_volume_mount_paths(",
          "215:         args_list=result, src_mount_path=relative_src, dst_mount_path=relative_dst, labels=labels",
          "216:     )",
          "218:     explanation = (",
          "219:         f\"provided: {relative_src}:{relative_dst}\",",
          "220:         f\"got: {result}\",",
          "221:         f\"expected {expected}\",",
          "222:     )",
          "223:     assert result == expected, explanation",
          "224:     assert all(part.endswith('/') for part in result[1].split(':')[0:1]), explanation",
          "",
          "---------------"
        ],
        "test/unit/config/test_doc.py||test/unit/config/test_doc.py": [
          "File: test/unit/config/test_doc.py -> test/unit/config/test_doc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:     if container_runtime == 'podman':",
          "81:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "85:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "86:         extra_container_args + \\",
          "87:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "83:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "84:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "83:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "84:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:     if container_runtime == 'podman':",
          "129:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "133:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "134:         extra_container_args + \\",
          "135:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "131:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "132:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "131:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "132:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_inventory.py||test/unit/config/test_inventory.py": [
          "File: test/unit/config/test_inventory.py -> test/unit/config/test_inventory.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:     if container_runtime == 'podman':",
          "106:         expected_command_start +=['--group-add=root', '--userns=keep-id', '--ipc=host']",
          "110:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "111:         extra_container_args + \\",
          "112:         ['--name', 'ansible_runner_foo', 'my_container'] + \\",
          "",
          "[Removed Lines]",
          "108:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts:Z'.format(rc.private_data_dir)] + \\",
          "109:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "",
          "[Added Lines]",
          "108:     expected_command_start += ['-v', '{}/artifacts/:/runner/artifacts/:Z'.format(rc.private_data_dir)] + \\",
          "109:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "",
          "---------------"
        ],
        "test/unit/config/test_runner.py||test/unit/config/test_runner.py": [
          "File: test/unit/config/test_runner.py -> test/unit/config/test_runner.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "637: @patch('os.path.exists', return_value=True)",
          "638: def test_container_volume_mounting_with_Z(mock_isdir, mock_exists, tmpdir):",
          "639:     rc = RunnerConfig(str(tmpdir))",
          "641:     rc.container_name = 'foo'",
          "642:     rc.env = {}",
          "643:     new_args = rc.wrap_args_for_containerization(['ansible-playbook', 'foo.yml'], 0, None)",
          "",
          "[Removed Lines]",
          "640:     rc.container_volume_mounts = ['project_path:project_path:Z']",
          "",
          "[Added Lines]",
          "640:     rc.container_volume_mounts = ['/tmp/project_path:/tmp/project_path:Z']",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "645:     for i, entry in enumerate(new_args):",
          "646:         if entry == '-v':",
          "647:             mount = new_args[i + 1]",
          "649:                 break",
          "650:     else:",
          "651:         raise Exception('Could not find expected mount, args: {}'.format(new_args))",
          "",
          "[Removed Lines]",
          "648:             if mount.endswith(':project_path:Z'):",
          "",
          "[Added Lines]",
          "648:             if mount.endswith(':/tmp/project_path/:Z'):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "663:         rc.process_isolation = True",
          "664:         rc.process_isolation_executable=container_runtime",
          "665:         rc.container_image = 'my_container'",
          "667:         mock_containerized.return_value = True",
          "668:         rc.prepare()",
          "",
          "[Removed Lines]",
          "666:         rc.container_volume_mounts=['/host1:/container1', 'host2:/container2']",
          "",
          "[Added Lines]",
          "666:         rc.container_volume_mounts=['/host1:/container1', '/host2:/container2']",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "674:         extra_container_args = ['--user={os.getuid()}']",
          "676:     expected_command_start = [container_runtime, 'run', '--rm', '--tty', '--interactive', '--workdir', '/runner/project'] + \\",
          "679:         ['--env-file', '{}/env.list'.format(rc.artifact_dir)] + \\",
          "680:         extra_container_args + \\",
          "681:         ['--name', 'ansible_runner_foo'] + \\",
          "",
          "[Removed Lines]",
          "677:         ['-v', '{}/:/runner:Z'.format(rc.private_data_dir)] + \\",
          "678:         ['-v', '/host1/:/container1', '-v', 'host2/:/container2'] + \\",
          "",
          "[Added Lines]",
          "677:         ['-v', '{}/:/runner/:Z'.format(rc.private_data_dir)] + \\",
          "678:         ['-v', '/host1/:/container1/', '-v', '/host2/:/container2/'] + \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7b2f1ca7faeff6ff3c795272c7ce929053c878ec",
      "candidate_info": {
        "commit_hash": "7b2f1ca7faeff6ff3c795272c7ce929053c878ec",
        "repo": "ansible/ansible-runner",
        "commit_url": "https://github.com/ansible/ansible-runner/commit/7b2f1ca7faeff6ff3c795272c7ce929053c878ec",
        "files": [
          "ansible_runner/__init__.py",
          "ansible_runner/ansible_config.py",
          "ansible_runner/base_config.py",
          "ansible_runner/command_config.py",
          "ansible_runner/doc_config.py",
          "ansible_runner/interface.py",
          "ansible_runner/inventory_config.py",
          "ansible_runner/runner.py",
          "ansible_runner/utils.py",
          "docs/python_interface.rst"
        ],
        "message": "Update runner to run ansible command line utilities\n\n*  Add interface to run ansible commands and generic commands\n   in local and container environments\n   -> run_command\n   -> run_command_async\n*  Add interface to get installed plugin docs within local and container\n   environments\n   -> get_plugin_docs\n   -> get_plugin_docs_async\n*  Add interface to get list of installed plugins within local and container\n   environments\n   -> get_plugin_list\n*  Add interface to get ansible configuration details\n   -> get_ansible_config\n*  Add interface to get ansible inventory details\n   -> get_inventory\n*  Add a new `subprocess` runner mode to handle non-interactive and long\n   running command executions\n*  Update docs\n\nTODO:\n*  Refactor `runner_config.py` to use `BaseConfig` class\n*  Remove `CLI_EXECENV` execution mode and relevant changes as\n   the newly added `run_command` interface will provide this functionality",
        "before_after_code_files": [
          "ansible_runner/__init__.py||ansible_runner/__init__.py",
          "ansible_runner/ansible_config.py||ansible_runner/ansible_config.py",
          "ansible_runner/base_config.py||ansible_runner/base_config.py",
          "ansible_runner/command_config.py||ansible_runner/command_config.py",
          "ansible_runner/doc_config.py||ansible_runner/doc_config.py",
          "ansible_runner/interface.py||ansible_runner/interface.py",
          "ansible_runner/inventory_config.py||ansible_runner/inventory_config.py",
          "ansible_runner/runner.py||ansible_runner/runner.py",
          "ansible_runner/utils.py||ansible_runner/utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ansible_runner/runner.py||ansible_runner/runner.py"
          ],
          "candidate": [
            "ansible_runner/runner.py||ansible_runner/runner.py"
          ]
        }
      },
      "candidate_diff": {
        "ansible_runner/__init__.py||ansible_runner/__init__.py": [
          "File: ansible_runner/__init__.py -> ansible_runner/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import pkg_resources",
          "4: from .exceptions import AnsibleRunnerException, ConfigurationError, CallbackError # noqa",
          "5: from .runner_config import RunnerConfig # noqa",
          "6: from .runner import Runner # noqa",
          "",
          "[Removed Lines]",
          "3: from .interface import run, run_async # noqa",
          "",
          "[Added Lines]",
          "3: from .interface import run, run_async, \\",
          "4:                         run_command, run_command_async, \\",
          "5:                         get_plugin_docs, get_plugin_docs_async, get_plugin_list, \\",
          "6:                         get_inventory, \\",
          "7:                         get_ansible_config     # noqa",
          "",
          "---------------"
        ],
        "ansible_runner/ansible_config.py||ansible_runner/ansible_config.py": [
          "File: ansible_runner/ansible_config.py -> ansible_runner/ansible_config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ############################",
          "2: # Licensed to the Apache Software Foundation (ASF) under one",
          "3: # or more contributor license agreements.  See the NOTICE file",
          "4: # distributed with this work for additional information",
          "5: # regarding copyright ownership.  The ASF licenses this file",
          "6: # to you under the Apache License, Version 2.0 (the",
          "7: # \"License\"); you may not use this file except in compliance",
          "8: # with the License.  You may obtain a copy of the License at",
          "9: #",
          "10: #   http://www.apache.org/licenses/LICENSE-2.0",
          "11: #",
          "12: # Unless required by applicable law or agreed to in writing,",
          "13: # software distributed under the License is distributed on an",
          "14: # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
          "15: # KIND, either express or implied.  See the License for the",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "18: #",
          "19: import logging",
          "20: from ansible_runner import base_config",
          "21: from ansible_runner.exceptions import ConfigurationError",
          "23: logger = logging.getLogger('ansible-runner')",
          "26: class AnsibleConfig(base_config.BaseConfig):",
          "27:     \"\"\"",
          "28:     A ``Runner`` configuration object that's meant to encapsulate the configuration used by the",
          "29:     :py:mod:`ansible_runner.runner.AnsibleConfig` object to launch and manage the invocation of",
          "30:     command execution.",
          "32:     Typically this object is initialized for you when using the standard ``get_ansible_config`` interfaces in :py:mod:`ansible_runner.interface`",
          "33:     but can be used to construct the ``AnsibleConfig`` configuration to be invoked elsewhere. It can also be overridden to provide different",
          "34:     functionality to the AnsibleConfig object.",
          "36:     :Example:",
          "38:     >>> ac = AnsibleConfig(...)",
          "39:     >>> r = Runner(config=ac)",
          "40:     >>> r.run()",
          "42:     \"\"\"",
          "44:     def __init__(self, runner_mode=None, **kwargs):",
          "45:         # runner params",
          "46:         self.runner_mode = runner_mode if runner_mode else 'subprocess'",
          "47:         if self.runner_mode not in ['pexpect', 'subprocess']:",
          "48:             raise ConfigurationError(\"Invalid runner mode {0}, valid value is either 'pexpect' or 'subprocess'\".format(self.runner_mode))",
          "50:         self.execution_mode = base_config.ExecutionMode.ANSIBLE_COMMANDS",
          "51:         super(AnsibleConfig, self).__init__(**kwargs)",
          "53:     _supported_actions = ('list', 'dump', 'view')",
          "56:     def get_ansible_config(self, action, config_file=None, only_changed=None):",
          "58:         if action not in AnsibleConfig._supported_actions:",
          "59:             raise ConfigurationError(\"Invalid action {0}, valid value is one of either {1}\".format(action, \" \".join(AnsibleConfig._supported_actions)))",
          "61:         if action != 'dump' and only_changed:",
          "62:             raise ConfigurationError(\"only_changed is applicable for action 'dump'\")",
          "63:         self._prepare_env()",
          "64:         self.cmdline_args = []",
          "66:         self.cmdline_args.append(action)",
          "67:         if config_file:",
          "68:             self.cmdline_args.extend(['-c', config_file])",
          "70:         if only_changed:",
          "71:             self.cmdline_args.append('--only-changed')",
          "73:         self.command = ['ansible-config'] + self.cmdline_args",
          "74:         self._handle_command_wrap()",
          "",
          "---------------"
        ],
        "ansible_runner/base_config.py||ansible_runner/base_config.py": [
          "File: ansible_runner/base_config.py -> ansible_runner/base_config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ############################",
          "2: # Licensed to the Apache Software Foundation (ASF) under one",
          "3: # or more contributor license agreements.  See the NOTICE file",
          "4: # distributed with this work for additional information",
          "5: # regarding copyright ownership.  The ASF licenses this file",
          "6: # to you under the Apache License, Version 2.0 (the",
          "7: # \"License\"); you may not use this file except in compliance",
          "8: # with the License.  You may obtain a copy of the License at",
          "9: #",
          "10: #   http://www.apache.org/licenses/LICENSE-2.0",
          "11: #",
          "12: # Unless required by applicable law or agreed to in writing,",
          "13: # software distributed under the License is distributed on an",
          "14: # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
          "15: # KIND, either express or implied.  See the License for the",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "18: #",
          "19: import logging",
          "20: import os",
          "21: import pexpect",
          "22: import re",
          "24: from uuid import uuid4",
          "25: try:",
          "26:     from collections.abc import Mapping",
          "27: except ImportError:",
          "28:     from collections import Mapping",
          "30: from six import iteritems, string_types",
          "32: from ansible_runner import defaults",
          "33: from ansible_runner.output import debug",
          "34: from ansible_runner.exceptions import ConfigurationError",
          "35: from ansible_runner.loader import ArtifactLoader",
          "36: from ansible_runner.utils import (",
          "37:     open_fifo_write,",
          "38:     args2cmdline,",
          "39:     sanitize_container_name,",
          "40:     cli_mounts",
          "41: )",
          "43: logger = logging.getLogger('ansible-runner')",
          "46: class ExecutionMode():",
          "47:     NONE = 0",
          "48:     # run ansible commands either locally or within EE",
          "49:     ANSIBLE_COMMANDS = 1",
          "50:     # execute generic commands",
          "51:     GENERIC_COMMANDS = 2",
          "54: class BaseConfig(object):",
          "56:     def __init__(self,",
          "57:                  cwd=None, envvars=None, passwords=None, settings=None,",
          "58:                  private_data_dir=None, project_dir=None, artifact_dir=None, fact_cache_type='jsonfile', fact_cache=None,",
          "59:                  process_isolation=False, process_isolation_executable=None,",
          "60:                  container_image=None, container_volume_mounts=None, container_options=None, containter_workdir=None,",
          "61:                  ident=None, rotate_artifacts=0, ssh_key=None, quiet=False):",
          "62:         # common params",
          "63:         self.cwd = cwd",
          "64:         self.envvars = envvars",
          "65:         self.ssh_key_data = ssh_key",
          "67:         # container params",
          "68:         self.process_isolation = process_isolation",
          "69:         self.process_isolation_executable = process_isolation_executable or defaults.default_process_isolation_executable",
          "70:         self.container_image = container_image",
          "71:         self.container_volume_mounts = container_volume_mounts",
          "72:         self.containter_workdir = containter_workdir",
          "73:         self.container_name = None  # like other properties, not accurate until prepare is called",
          "74:         self.container_options = container_options",
          "75:         self._volume_mount_paths = []",
          "77:         # runner params",
          "78:         self.ident = ident",
          "79:         self.private_data_dir = private_data_dir",
          "80:         self.artifact_dir = artifact_dir",
          "81:         self.rotate_artifacts = rotate_artifacts",
          "82:         self.quiet = quiet",
          "83:         self.passwords = passwords",
          "84:         self.settings = settings",
          "86:         # setup initial environment",
          "87:         if private_data_dir:",
          "88:             self.private_data_dir = os.path.abspath(private_data_dir)",
          "89:         else:",
          "90:             self.private_data_dir = os.path.abspath(os.path.expanduser('~/.ansible-runner'))",
          "92:         if artifact_dir is None:",
          "93:             self.artifact_dir = os.path.join(self.private_data_dir, 'artifacts')",
          "94:         else:",
          "95:             self.artifact_dir = os.path.abspath(artifact_dir)",
          "97:         if ident is None:",
          "98:             self.ident = str(uuid4())",
          "99:         else:",
          "100:             self.ident = ident",
          "102:         self.artifact_dir = os.path.join(self.artifact_dir, \"{}\".format(self.ident))",
          "104:         if not project_dir:",
          "105:             self.project_dir = os.path.join(self.private_data_dir, 'project')",
          "106:         else:",
          "107:             self.project_dir = project_dir",
          "109:         self.rotate_artifacts = rotate_artifacts",
          "110:         self.fact_cache_type = fact_cache_type",
          "111:         self.fact_cache = os.path.join(self.artifact_dir, fact_cache or 'fact_cache') if self.fact_cache_type == 'jsonfile' else None",
          "113:         self.loader = ArtifactLoader(self.private_data_dir)",
          "115:         if not self.cwd:",
          "116:             if os.path.exists(self.project_dir):",
          "117:                 self.cwd = self.project_dir",
          "118:             else:",
          "119:                 self.cwd = os.getcwd()",
          "121:         if not os.path.exists(self.private_data_dir):",
          "122:             os.makedirs(self.private_data_dir, mode=0o700)",
          "123:         if not os.path.exists(self.artifact_dir):",
          "124:             os.makedirs(self.artifact_dir, mode=0o700)",
          "126:     _CONTAINER_ENGINES = ('docker', 'podman')",
          "128:     @property",
          "129:     def containerized(self):",
          "130:         return self.process_isolation and self.process_isolation_executable in self._CONTAINER_ENGINES",
          "132:     def _prepare_env(self):",
          "133:         \"\"\"",
          "134:         Manages reading environment metadata files under ``private_data_dir`` and merging/updating",
          "135:         with existing values so the :py:class:`ansible_runner.runner.Runner` object can read and use them easily",
          "136:         \"\"\"",
          "137:         try:",
          "138:             if self.settings:",
          "139:                 self.settings = self.settings.update(self.loader.load_file('env/settings', Mapping))",
          "140:             else:",
          "141:                 self.settings = self.loader.load_file('env/settings', Mapping)",
          "142:         except ConfigurationError:",
          "143:             debug(\"Not loading settings\")",
          "144:             self.settings = dict()",
          "146:         if self.runner_mode == 'pexpect':",
          "147:             try:",
          "148:                 passwords = self.loader.load_file('env/passwords', Mapping)",
          "149:                 self.expect_passwords = {",
          "150:                     re.compile(pattern, re.M): password",
          "151:                     for pattern, password in iteritems(passwords)",
          "152:                 }",
          "153:             except ConfigurationError:",
          "154:                 debug('Not loading passwords')",
          "155:                 self.expect_passwords = dict()",
          "157:             self.expect_passwords[pexpect.TIMEOUT] = None",
          "158:             self.expect_passwords[pexpect.EOF] = None",
          "159:             if self.passwords:",
          "160:                 self.expect_passwords.update(self.passwords)",
          "162:             self.pexpect_timeout = self.settings.get('pexpect_timeout', 5)",
          "163:             self.pexpect_use_poll = self.settings.get('pexpect_use_poll', True)",
          "165:             self.idle_timeout = self.settings.get('idle_timeout', None)",
          "166:             self.job_timeout = self.settings.get('job_timeout', None)",
          "168:         elif self.runner_mode == 'subprocess':",
          "169:             self.subprocess_timeout = self.settings.get('subprocess_timeout', 300)",
          "171:         self.process_isolation = self.settings.get('process_isolation', self.process_isolation)",
          "172:         self.process_isolation_executable = self.settings.get('process_isolation_executable', self.process_isolation_executable)",
          "174:         self.container_image = self.settings.get('container_image', self.container_image)",
          "175:         self.container_volume_mounts = self.settings.get('container_volume_mounts', self.container_volume_mounts)",
          "176:         self.container_options = self.settings.get('container_options', self.container_options)",
          "178:         if self.containerized:",
          "179:             self.container_name = \"ansible_runner_{}\".format(sanitize_container_name(self.ident))",
          "180:             self.env = {}",
          "181:             # Special flags to convey info to entrypoint or process in container",
          "182:             self.env['LAUNCHED_BY_RUNNER'] = '1'",
          "183:             artifact_dir = os.path.join(\"/runner/artifacts\", \"{}\".format(self.ident))",
          "184:             self.env['AWX_ISOLATED_DATA_DIR'] = artifact_dir",
          "185:             if self.fact_cache_type == 'jsonfile':",
          "186:                 self.env['ANSIBLE_CACHE_PLUGIN_CONNECTION'] = os.path.join(artifact_dir, 'fact_cache')",
          "187:         else:",
          "188:             # seed env with existing shell env",
          "189:             self.env = os.environ.copy()",
          "191:         if self.envvars and isinstance(self.envvars, dict):",
          "192:             self.env.update(self.envvars)",
          "194:         try:",
          "195:             envvars = self.loader.load_file('env/envvars', Mapping)",
          "196:             if envvars:",
          "197:                 self.env.update({str(k):str(v) for k, v in envvars.items()})",
          "198:         except ConfigurationError:",
          "199:             debug(\"Not loading environment vars\")",
          "200:             # Still need to pass default environment to pexpect",
          "202:         try:",
          "203:             if self.ssh_key_data is None:",
          "204:                 self.ssh_key_data = self.loader.load_file('env/ssh_key', string_types)",
          "205:         except ConfigurationError:",
          "206:             debug(\"Not loading ssh key\")",
          "207:             self.ssh_key_data = None",
          "209:         # write the SSH key data into a fifo read by ssh-agent",
          "210:         if self.ssh_key_data:",
          "211:             self.ssh_key_path = os.path.join(self.artifact_dir, 'ssh_key_data')",
          "212:             open_fifo_write(self.ssh_key_path, self.ssh_key_data)",
          "214:         self.container_image = self.settings.get('container_image', self.container_image)",
          "215:         self.container_volume_mounts = self.settings.get('container_volume_mounts', self.container_volume_mounts)",
          "216:         self.container_options = self.settings.get('container_options', self.container_options)",
          "218:         self.suppress_ansible_output = self.settings.get('suppress_ansible_output', self.quiet)",
          "220:         if 'fact_cache' in self.settings:",
          "221:             if 'fact_cache_type' in self.settings:",
          "222:                 if self.settings['fact_cache_type'] == 'jsonfile':",
          "223:                     self.fact_cache = os.path.join(self.artifact_dir, self.settings['fact_cache'])",
          "224:             else:",
          "225:                 self.fact_cache = os.path.join(self.artifact_dir, self.settings['fact_cache'])",
          "227:         # Use local callback directory",
          "228:         if not self.containerized:",
          "229:             callback_dir = self.env.get('AWX_LIB_DIRECTORY', os.getenv('AWX_LIB_DIRECTORY'))",
          "230:             if callback_dir is None:",
          "231:                 callback_dir = os.path.join(os.path.split(os.path.abspath(__file__))[0], \"callbacks\")",
          "232:             python_path = self.env.get('PYTHONPATH', os.getenv('PYTHONPATH', ''))",
          "233:             self.env['PYTHONPATH'] = ':'.join([python_path, callback_dir])",
          "234:             if python_path and not python_path.endswith(':'):",
          "235:                 python_path += ':'",
          "236:             self.env['ANSIBLE_CALLBACK_PLUGINS'] = ':'.join(filter(None,(self.env.get('ANSIBLE_CALLBACK_PLUGINS'), callback_dir)))",
          "238:         if 'AD_HOC_COMMAND_ID' in self.env:",
          "239:             self.env['ANSIBLE_STDOUT_CALLBACK'] = 'minimal'",
          "240:         else:",
          "241:             self.env['ANSIBLE_STDOUT_CALLBACK'] = 'awx_display'",
          "242:         self.env['ANSIBLE_RETRY_FILES_ENABLED'] = 'False'",
          "243:         if 'ANSIBLE_HOST_KEY_CHECKING' not in self.env:",
          "244:             self.env['ANSIBLE_HOST_KEY_CHECKING'] = 'False'",
          "245:         if not self.containerized:",
          "246:             self.env['AWX_ISOLATED_DATA_DIR'] = self.artifact_dir",
          "248:         if self.fact_cache_type == 'jsonfile':",
          "249:             self.env['ANSIBLE_CACHE_PLUGIN'] = 'jsonfile'",
          "250:             if not self.containerized:",
          "251:                 self.env['ANSIBLE_CACHE_PLUGIN_CONNECTION'] = self.fact_cache",
          "253:         debug('env:')",
          "254:         for k,v in sorted(self.env.items()):",
          "255:             debug(f' {k}: {v}')",
          "257:     def _handle_command_wrap(self):",
          "258:         if self.ssh_key_data:",
          "259:             logger.debug('ssh key data added')",
          "260:             self.command = self.wrap_args_with_ssh_agent(self.command, self.ssh_key_path)",
          "262:         if self.containerized:",
          "263:             logger.debug('containerization enabled')",
          "264:             self.command = self.wrap_args_for_containerization(self.command)",
          "265:         else:",
          "266:             logger.debug('containerization disabled')",
          "268:         if hasattr(self, 'command') and isinstance(self.command, list):",
          "269:             logger.debug(f\"command: {' '.join(self.command)}\")",
          "271:     def _ensure_path_safe_to_mount(self, path):",
          "272:         if os.path.isfile(path):",
          "273:             path = os.path.dirname(path)",
          "274:         if path in ('/', '/home', '/usr'):",
          "275:             raise ConfigurationError(\"When using containerized execution, cannot mount '/' or '/home' or '/usr'\")",
          "277:     def _get_playbook_path(self):",
          "278:         _playbook = \"\"",
          "279:         _book_keeping_copy = self.cmdline_args.copy()",
          "280:         for arg in self.cmdline_args:",
          "281:             if arg in ['-i', '--inventory', '--inventory-file']:",
          "282:                 _book_keeping_copy_inventory_index = _book_keeping_copy.index(arg)",
          "283:                 _book_keeping_copy.pop(_book_keeping_copy_inventory_index)",
          "284:                 try:",
          "285:                     _book_keeping_copy.pop(_book_keeping_copy_inventory_index)",
          "286:                 except IndexError:",
          "287:                     # invalid command, pass through for execution",
          "288:                     # to return correct error from ansible-core",
          "289:                     return None",
          "291:         if len(_book_keeping_copy) == 1:",
          "292:             # it's probably safe to assume this is the playbook",
          "293:             _playbook = _book_keeping_copy[0]",
          "294:         elif _book_keeping_copy[0][0] != '-':",
          "295:             # this should be the playbook, it's the only \"naked\" arg",
          "296:             _playbook = _book_keeping_copy[0]",
          "297:         else:",
          "298:             # parse everything beyond the first arg because we checked that",
          "299:             # in the previous case already",
          "300:             for arg in _book_keeping_copy[1:]:",
          "301:                 if arg[0] == '-':",
          "302:                     continue",
          "303:                 elif _book_keeping_copy[(_book_keeping_copy.index(arg) - 1)][0] != '-':",
          "304:                     _playbook = arg",
          "305:                     break",
          "307:         return _playbook",
          "309:     def _update_volume_mount_paths(self, args_list, src_mount_path, dest_mount_path=None, labels=None):",
          "311:         if src_mount_path is None or not os.path.exists(src_mount_path):",
          "312:             logger.debug(\"Source volume mount path does not exit {0}\".format(src_mount_path))",
          "313:             return",
          "315:         if dest_mount_path is None:",
          "316:             dest_mount_path = src_mount_path",
          "318:         self._ensure_path_safe_to_mount(src_mount_path)",
          "320:         if os.path.isabs(src_mount_path):",
          "321:             if os.path.isdir(src_mount_path):",
          "322:                 volume_mount_path = \"{}:{}\".format(src_mount_path, dest_mount_path)",
          "323:             else:",
          "324:                 volume_mount_path = \"{}:{}\".format(os.path.dirname(src_mount_path), os.path.dirname(dest_mount_path))",
          "325:         else:",
          "326:             if self.containter_workdir and not os.path.isabs(dest_mount_path):",
          "327:                 dest_mount_path = os.path.join(self.containter_workdir, dest_mount_path)",
          "329:             src_mount_path = os.path.abspath(src_mount_path)",
          "330:             dest_mount_path = os.path.abspath(dest_mount_path)",
          "332:             if os.path.isdir(src_mount_path):",
          "333:                 volume_mount_path = \"{}:{}\".format(src_mount_path, dest_mount_path)",
          "334:             else:",
          "335:                 volume_mount_path = \"{}:{}\".format(os.path.dirname(src_mount_path), os.path.dirname(dest_mount_path))",
          "337:         if labels:",
          "338:             volume_mount_path += labels",
          "340:         # check if mount path already added in args list",
          "341:         if ', '.join(map(str, ['-v', volume_mount_path])) not in ', '.join(map(str, args_list)):",
          "342:             args_list.extend(['-v', volume_mount_path])",
          "344:     def _handle_ansible_cmd_options_bind_mounts(self, args_list):",
          "345:         inventory_file_options = ['-i', '--inventory', '--inventory-file']",
          "346:         vault_file_options = ['--vault-password-file', '--vault-pass-file']",
          "347:         private_key_file_options = ['--private-key', '--key-file']",
          "349:         optional_mount_args = inventory_file_options + vault_file_options + private_key_file_options",
          "351:         if not self.cmdline_args:",
          "352:             return",
          "354:         if '-h' in self.cmdline_args or '--help' in self.cmdline_args:",
          "355:             return",
          "357:         if 'ansible-playbook' in self.command[0]:",
          "358:             playbook_file_path = self._get_playbook_path()",
          "359:             if playbook_file_path:",
          "360:                 self._update_volume_mount_paths(args_list, playbook_file_path)",
          "362:         cmdline_args_copy = self.cmdline_args.copy()",
          "363:         optional_arg_paths = []",
          "364:         for arg in self.cmdline_args:",
          "366:             if arg not in optional_mount_args:",
          "367:                 continue",
          "369:             optional_arg_index = cmdline_args_copy.index(arg)",
          "370:             optional_arg_paths.append(self.cmdline_args[optional_arg_index + 1])",
          "371:             cmdline_args_copy.pop(optional_arg_index)",
          "372:             try:",
          "373:                 optional_arg_value = cmdline_args_copy.pop(optional_arg_index)",
          "374:             except IndexError:",
          "375:                 # invalid command, pass through for execution",
          "376:                 # to return valid error from ansible-core",
          "377:                 return",
          "379:             if arg in inventory_file_options and optional_arg_value.endswith(','):",
          "380:                 # comma separated host list provided as value",
          "381:                 continue",
          "383:             self._update_volume_mount_paths(args_list, optional_arg_value)",
          "385:     def wrap_args_for_containerization(self, args):",
          "386:         new_args = [self.process_isolation_executable]",
          "387:         new_args.extend(['run', '--rm', '--interactive', '--tty'])",
          "388:         if self.runner_mode == 'pexpect':",
          "389:             new_args.extend(['--tty'])",
          "391:         #new_args.extend([\"-u\", 'root'])",
          "393:         if not self.containter_workdir:",
          "394:             self.container_workdir = \"/runner/project\"",
          "396:         workdir = self.container_workdir",
          "397:         if self.cwd is not None:",
          "398:             self._update_volume_mount_paths(new_args, self.cwd)",
          "399:             if os.path.isabs(self.cwd):",
          "400:                 workdir = self.cwd",
          "402:         self._ensure_path_safe_to_mount(workdir)",
          "403:         new_args.extend([\"--workdir\", workdir])",
          "405:         self._ensure_path_safe_to_mount(self.private_data_dir)",
          "407:         if self.execution_mode == ExecutionMode.ANSIBLE_COMMANDS:",
          "408:             self._handle_ansible_cmd_options_bind_mounts(new_args)",
          "410:         # Handle automounts",
          "411:         self._handle_automounts(new_args)",
          "413:         if 'podman' in self.process_isolation_executable:",
          "414:             # container namespace stuff",
          "415:             new_args.extend([\"--group-add=root\"])",
          "416:             new_args.extend([\"--userns=keep-id\"])",
          "417:             new_args.extend([\"--ipc=host\"])",
          "419:         self._update_volume_mount_paths(new_args, \"{}\".format(self.private_data_dir), dest_mount_path=\"/runner\", labels=\":Z\")",
          "421:         if self.container_volume_mounts:",
          "422:             for mapping in self.container_volume_mounts:",
          "423:                 volume_mounts = mapping.split(':', 2)",
          "424:                 self._ensure_path_safe_to_mount(volume_mounts[0])",
          "425:                 labels = None",
          "426:                 if len(volume_mounts) == 3:",
          "427:                     labels = volume_mounts[2]",
          "428:                 self._update_volume_mount_paths(new_args, volume_mounts[0], dest_mount_path=volume_mounts[1], labels=\":%s\" % labels)",
          "430:         # Reference the file with list of keys to pass into container",
          "431:         # this file will be written in ansible_runner.runner",
          "432:         env_file_host = os.path.join(self.artifact_dir, 'env.list')",
          "433:         new_args.extend(['--env-file', env_file_host])",
          "435:         if 'podman' in self.process_isolation_executable:",
          "436:             # docker doesnt support this option",
          "437:             new_args.extend(['--quiet'])",
          "439:         if 'docker' in self.process_isolation_executable:",
          "440:             new_args.extend([f'--user={os.getuid()}'])",
          "442:         new_args.extend(['--name', self.container_name])",
          "444:         if self.container_options:",
          "445:             new_args.extend(self.container_options)",
          "447:         new_args.extend([self.container_image])",
          "448:         new_args.extend(args)",
          "449:         logger.debug(f\"container engine invocation: {' '.join(new_args)}\")",
          "450:         return new_args",
          "452:     def wrap_args_with_ssh_agent(self, args, ssh_key_path, ssh_auth_sock=None, silence_ssh_add=False):",
          "453:         \"\"\"",
          "454:         Given an existing command line and parameterization this will return the same command line wrapped with the",
          "455:         necessary calls to ``ssh-agent``",
          "456:         \"\"\"",
          "457:         if self.containerized:",
          "458:             artifact_dir = os.path.join(\"/runner/artifacts\", \"{}\".format(self.ident))",
          "459:             ssh_key_path = os.path.join(artifact_dir, \"ssh_key_data\")",
          "461:         if ssh_key_path:",
          "462:             ssh_add_command = args2cmdline('ssh-add', ssh_key_path)",
          "463:             if silence_ssh_add:",
          "464:                 ssh_add_command = ' '.join([ssh_add_command, '2>/dev/null'])",
          "465:             ssh_key_cleanup_command = 'rm -f {}'.format(ssh_key_path)",
          "466:             # The trap ensures the fifo is cleaned up even if the call to ssh-add fails.",
          "467:             # This prevents getting into certain scenarios where subsequent reads will",
          "468:             # hang forever.",
          "469:             cmd = ' && '.join([args2cmdline('trap', ssh_key_cleanup_command, 'EXIT'),",
          "470:                                ssh_add_command,",
          "471:                                ssh_key_cleanup_command,",
          "472:                                args2cmdline(*args)])",
          "473:             args = ['ssh-agent']",
          "474:             if ssh_auth_sock:",
          "475:                 args.extend(['-a', ssh_auth_sock])",
          "476:             args.extend(['sh', '-c', cmd])",
          "477:         return args",
          "479:     def _handle_automounts(self, new_args):",
          "480:         for cli_automount in cli_mounts():",
          "481:             for env in cli_automount['ENVS']:",
          "482:                 if env in os.environ:",
          "483:                     dest_path = os.environ[env]",
          "485:                     if os.path.exists(os.environ[env]):",
          "486:                         if os.environ[env].startswith(os.environ['HOME']):",
          "487:                             dest_path = '/home/runner/{}'.format(os.environ[env].lstrip(os.environ['HOME']))",
          "488:                         elif os.environ[env].startswith('~'):",
          "489:                             dest_path = '/home/runner/{}'.format(os.environ[env].lstrip('~/'))",
          "490:                         else:",
          "491:                             dest_path = os.environ[env]",
          "493:                         self._update_volume_mount_paths(new_args, os.environ[env], dest_mount_path=dest_path)",
          "495:                     new_args.extend([\"-e\", \"{}={}\".format(env, dest_path)])",
          "497:             for paths in cli_automount['PATHS']:",
          "498:                 if os.path.exists(paths['src']):",
          "499:                     self._update_volume_mount_paths(new_args, paths['src'], dest_mount_path=paths['dest'])",
          "",
          "---------------"
        ],
        "ansible_runner/command_config.py||ansible_runner/command_config.py": [
          "File: ansible_runner/command_config.py -> ansible_runner/command_config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ############################",
          "2: # Licensed to the Apache Software Foundation (ASF) under one",
          "3: # or more contributor license agreements.  See the NOTICE file",
          "4: # distributed with this work for additional information",
          "5: # regarding copyright ownership.  The ASF licenses this file",
          "6: # to you under the Apache License, Version 2.0 (the",
          "7: # \"License\"); you may not use this file except in compliance",
          "8: # with the License.  You may obtain a copy of the License at",
          "9: #",
          "10: #   http://www.apache.org/licenses/LICENSE-2.0",
          "11: #",
          "12: # Unless required by applicable law or agreed to in writing,",
          "13: # software distributed under the License is distributed on an",
          "14: # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
          "15: # KIND, either express or implied.  See the License for the",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "18: #",
          "19: import logging",
          "20: import os",
          "22: from ansible_runner import base_config",
          "23: from ansible_runner.exceptions import ConfigurationError",
          "25: logger = logging.getLogger('ansible-runner')",
          "28: class CommandConfig(base_config.BaseConfig):",
          "29:     \"\"\"",
          "30:     A ``Runner`` configuration object that's meant to encapsulate the configuration used by the",
          "31:     :py:mod:`ansible_runner.runner.CommandConfig` object to launch and manage the invocation of",
          "32:     command execution.",
          "34:     Typically this object is initialized for you when using the standard ``run`_command` interfaces in :py:mod:`ansible_runner.interface`",
          "35:     but can be used to construct the ``CommandConfig`` configuration to be invoked elsewhere. It can also be overridden to provide different",
          "36:     functionality to the CommandConfig object.",
          "37:     :Example:",
          "39:     >>> cc = CommandConfig(...)",
          "40:     >>> r = Runner(config=cc)",
          "41:     >>> r.run()",
          "42:     \"\"\"",
          "44:     def __init__(self, input_fd=None, output_fd=None, error_fd=None, runner_mode=None, **kwargs):",
          "45:         # subprocess runner mode params",
          "46:         self.input_fd = input_fd",
          "47:         self.output_fd = output_fd",
          "48:         self.error_fd = error_fd",
          "50:         if runner_mode == 'pexpect' and not self.input_fd:",
          "51:             raise ConfigurationError(\"input_fd is applicable only with 'subprocess' runner mode\")",
          "53:         if runner_mode and runner_mode not in ['pexpect', 'subprocess']:",
          "54:             raise ConfigurationError(\"Invalid runner mode {0}, valid value is either 'pexpect' or 'subprocess'\".format(self.runner_mode))",
          "56:         # runner params",
          "57:         self.runner_mode = runner_mode",
          "59:         self.execution_mode = base_config.ExecutionMode.NONE",
          "61:         super(CommandConfig, self).__init__(**kwargs)",
          "63:     _ANSIBLE_NON_INERACTIVE_CMDS = (",
          "64:         'ansible-config',",
          "65:         'ansible-doc',",
          "66:         'ansible-galaxy',",
          "67:     )",
          "69:     def _set_runner_mode(self):",
          "70:         if self.input_fd is not None or self.executable_cmd.split(os.pathsep)[-1] in CommandConfig._ANSIBLE_NON_INERACTIVE_CMDS:",
          "71:             self.runner_mode = 'subprocess'",
          "72:         else:",
          "73:             self.runner_mode = 'pexpect'",
          "75:     def run_command(self, executable_cmd, cmdline_args=None):",
          "76:         self.executable_cmd = executable_cmd",
          "77:         self.cmdline_args = cmdline_args",
          "79:         if self.runner_mode is None:",
          "80:             self._set_runner_mode()",
          "82:         self._prepare_env()",
          "83:         self._prepare_command()",
          "85:         self._handle_command_wrap()",
          "87:     def _prepare_command(self):",
          "88:         \"\"\"",
          "89:         Determines if it is ``ansible`` command or ``generic`` command and generate the command line",
          "90:         \"\"\"",
          "91:         if not self.executable_cmd:",
          "92:             raise ConfigurationError(\"For CommandRunner 'executable_cmd' value is required\")",
          "94:         if self.executable_cmd.split(os.pathsep)[-1].startswith('ansible'):",
          "95:             self.execution_mode = base_config.ExecutionMode.ANSIBLE_COMMANDS",
          "96:         else:",
          "97:             self.execution_mode = base_config.ExecutionMode.GENERIC_COMMANDS",
          "99:         if self.cmdline_args:",
          "100:             self.command = [self.executable_cmd] + self.cmdline_args",
          "101:         else:",
          "102:             self.command = [self.executable_cmd]",
          "104:         if self.execution_mode == base_config.ExecutionMode.GENERIC_COMMANDS \\",
          "105:            and 'python' in self.executable_cmd.split(os.pathsep)[-1] and self.cmdline_args is None:",
          "106:             raise ConfigurationError(\"Runner requires python filename for execution\")",
          "107:         elif self.execution_mode == base_config.ExecutionMode.NONE:",
          "108:             raise ConfigurationError(\"No executable for runner to run\")",
          "",
          "---------------"
        ],
        "ansible_runner/doc_config.py||ansible_runner/doc_config.py": [
          "File: ansible_runner/doc_config.py -> ansible_runner/doc_config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ############################",
          "2: # Licensed to the Apache Software Foundation (ASF) under one",
          "3: # or more contributor license agreements.  See the NOTICE file",
          "4: # distributed with this work for additional information",
          "5: # regarding copyright ownership.  The ASF licenses this file",
          "6: # to you under the Apache License, Version 2.0 (the",
          "7: # \"License\"); you may not use this file except in compliance",
          "8: # with the License.  You may obtain a copy of the License at",
          "9: #",
          "10: #   http://www.apache.org/licenses/LICENSE-2.0",
          "11: #",
          "12: # Unless required by applicable law or agreed to in writing,",
          "13: # software distributed under the License is distributed on an",
          "14: # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
          "15: # KIND, either express or implied.  See the License for the",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "18: #",
          "19: import logging",
          "21: from ansible_runner import base_config",
          "22: from ansible_runner.exceptions import ConfigurationError",
          "24: logger = logging.getLogger('ansible-runner')",
          "27: class DocConfig(base_config.BaseConfig):",
          "28:     \"\"\"",
          "29:     A ``Runner`` configuration object that's meant to encapsulate the configuration used by the",
          "30:     :py:mod:`ansible_runner.runner.DocConfig` object to launch and manage the invocation of",
          "31:     command execution.",
          "33:     Typically this object is initialized for you when using the standard ``get_plugin_docs`` or ``get_plugin_list`` interfaces",
          "34:     in :py:mod:`ansible_runner.interface` but can be used to construct the ``DocConfig`` configuration to be invoked elsewhere.",
          "35:     It can also be overridden to provide different functionality to the DocConfig object.",
          "37:     :Example:",
          "39:     >>> dc = DocConfig(...)",
          "40:     >>> r = Runner(config=dc)",
          "41:     >>> r.run()",
          "43:     \"\"\"",
          "45:     def __init__(self, runner_mode=None, **kwargs):",
          "46:         # runner params",
          "47:         self.runner_mode = runner_mode if runner_mode else 'subprocess'",
          "48:         if self.runner_mode not in ['pexpect', 'subprocess']:",
          "49:             raise ConfigurationError(\"Invalid runner mode {0}, valid value is either 'pexpect' or 'subprocess'\".format(self.runner_mode))",
          "51:         self.execution_mode = base_config.ExecutionMode.ANSIBLE_COMMANDS",
          "52:         super(DocConfig, self).__init__(**kwargs)",
          "54:     _supported_response_formats = ('json', 'human')",
          "56:     def get_plugin_docs(self, plugin_names, plugin_type=None, response_format='json',",
          "57:                         snippet=False, playbook_dir=None, module_path=None):",
          "59:         if response_format and response_format not in DocConfig._supported_response_formats:",
          "60:             raise ConfigurationError(\"Invalid response_format {0}, valid value is one of either {1}\".format(response_format,",
          "61:                                                                                                             \" \".join(DocConfig._supported_output_formats)))",
          "63:         if not isinstance(plugin_names, list):",
          "64:             raise ConfigurationError(\"plugin_names should be of type list, instead received {0} of type {1}\".format(plugin_names, type(plugin_names)))",
          "66:         self._prepare_env()",
          "67:         self.command = ['ansible-doc']",
          "68:         self.cmdline_args = []",
          "70:         if response_format == 'json':",
          "71:             self.cmdline_args.append('-j')",
          "73:         if snippet:",
          "74:             self.cmdline_args.append('-s')",
          "76:         if plugin_type:",
          "77:             self.cmdline_args.extend(['-t', plugin_type])",
          "79:         if playbook_dir:",
          "80:             self.cmdline_args.extend(['--playbook-dir', playbook_dir])",
          "82:         if module_path:",
          "83:             self.cmdline_args.extend(['-M', module_path])",
          "85:         self.cmdline_args.append(\" \".join(plugin_names))",
          "87:         self.command = ['ansible-doc'] + self.cmdline_args",
          "88:         self._handle_command_wrap()",
          "90:     def get_plugin_list(self, list_files=None, response_format='json', plugin_type=None,",
          "91:                         playbook_dir=None, module_path=None):",
          "93:         if response_format and response_format not in DocConfig._supported_response_formats:",
          "94:             raise ConfigurationError(\"Invalid response_format {0}, valid value is one of either {1}\".format(response_format,",
          "95:                                                                                                             \" \".join(DocConfig._supported_output_formats)))",
          "97:         self._prepare_env()",
          "98:         self.cmdline_args = []",
          "100:         if list_files:",
          "101:             self.cmdline_args.append('-F')",
          "102:         else:",
          "103:             self.cmdline_args.append('-l')",
          "105:         if response_format == 'json':",
          "106:             self.cmdline_args.append('-j')",
          "108:         if plugin_type:",
          "109:             self.cmdline_args.extend(['-t', plugin_type])",
          "111:         if playbook_dir:",
          "112:             self.cmdline_args.extend(['--playbook-dir', playbook_dir])",
          "114:         if module_path:",
          "115:             self.cmdline_args.extend(['-M', module_path])",
          "117:         self.command = ['ansible-doc'] + self.cmdline_args",
          "118:         self._handle_command_wrap()",
          "",
          "---------------"
        ],
        "ansible_runner/interface.py||ansible_runner/interface.py": [
          "File: ansible_runner/interface.py -> ansible_runner/interface.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: from ansible_runner import output",
          "26: from ansible_runner.runner_config import RunnerConfig",
          "27: from ansible_runner.runner import Runner",
          "28: from ansible_runner.streaming import Transmitter, Worker, Processor",
          "29: from ansible_runner.utils import (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: from ansible_runner.command_config import CommandConfig",
          "28: from ansible_runner.inventory_config import InventoryConfig",
          "29: from ansible_runner.ansible_config import AnsibleConfig",
          "30: from ansible_runner.doc_config import DocConfig",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:     runner_thread = threading.Thread(target=r.run)",
          "257:     runner_thread.start()",
          "258:     return runner_thread, r",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "265: def init_command_config(executable_cmd, cmdline_args=None, **kwargs):",
          "266:     '''",
          "267:     Initialize the Runner() instance",
          "269:     This function will properly initialize both run_command() and run_command_async()",
          "270:     functions in the same way and return a value instance of Runner.",
          "272:     See parameters given to :py:func:`ansible_runner.interface.run_command`",
          "273:     '''",
          "274:     event_callback_handler = kwargs.pop('event_handler', None)",
          "275:     status_callback_handler = kwargs.pop('status_handler', None)",
          "276:     artifacts_handler = kwargs.pop('artifacts_handler', None)",
          "277:     cancel_callback = kwargs.pop('cancel_callback', None)",
          "278:     finished_callback = kwargs.pop('finished_callback', None)",
          "280:     rc = CommandConfig(**kwargs)",
          "281:     rc.run_command(executable_cmd, cmdline_args=cmdline_args)",
          "282:     return Runner(rc,",
          "283:                   event_handler=event_callback_handler,",
          "284:                   status_handler=status_callback_handler,",
          "285:                   artifacts_handler=artifacts_handler,",
          "286:                   cancel_callback=cancel_callback,",
          "287:                   finished_callback=finished_callback)",
          "290: def run_command(executable_cmd, cmdline_args=None, **kwargs):",
          "291:     '''",
          "292:     Run an (Ansible) commands in the foreground and return a Runner object when complete.",
          "294:     :param executable_cmd: The command to be executed.",
          "295:     :param cmdline_args: A list of arguments to be passed to the executable command.",
          "296:     :param input_fd: This parameter is applicable when ``runner_mode`` is set to ``subprocess``, it provides the",
          "297:                      input file descrption to interact with the sub-process running the command.",
          "298:     :param output_fd: The output file descriptor to stream the output of command execution.",
          "299:     :param error_fd: This parameter is applicable when ``runner_mode`` is set to ``subprocess``, it provides the",
          "300:                      error file descrption to read the error received while executing the command.",
          "301:     :param runner_mode: The applicable values are ``pexpect`` and ``subprocess``. If the value of ``input_fd`` parameter",
          "302:                         is set or the executable command is one of ``ansible-config``, ``ansible-doc`` or ``ansible-galaxy``",
          "303:                         the default value is set to ``subprocess`` else in other cases it is set to ``pexpect``.",
          "304:     :param cwd: The current working directory from which the command in executable_cmd shoulbe be executed.",
          "305:     :param envvars: Environment variables to be used when running Ansible. Environment variables will also be",
          "306:                     read from ``env/envvars`` in ``private_data_dir``",
          "307:     :param passwords: A dictionary containing password prompt patterns and response values used when processing output from",
          "308:                       Ansible. Passwords will also be read from ``env/passwords`` in ``private_data_dir``.",
          "309:     :param settings: A dictionary containing settings values for the ``ansible-runner`` runtime environment. These will also",
          "310:                      be read from ``env/settings`` in ``private_data_dir``.",
          "311:     :param ssh_key: The ssh private key passed to ``ssh-agent`` as part of the ansible-playbook run.",
          "312:     :param quiet: Disable all output",
          "313:     :param artifact_dir: The path to the directory where artifacts should live, this defaults to 'artifacts' under the private data dir",
          "314:     :param project_dir: The path to the playbook content, this defaults to 'project' within the private data dir",
          "315:     :param rotate_artifacts: Keep at most n artifact directories, disable with a value of 0 which is the default",
          "316:     :param process_isolation: Enable process isolation, using a container engine (e.g. podman).",
          "317:     :param process_isolation_executable: Process isolation executable or container engine used to isolate execution. (default: podman)",
          "318:     :param container_image: Container image to use when running an ansible task (default: quay.io/ansible/ansible-runner:devel)",
          "319:     :param container_volume_mounts: List of bind mounts in the form 'host_dir:/container_dir:labels. (default: None)",
          "320:     :param container_options: List of container options to pass to execution engine.",
          "321:     :param containter_workdir: The working directory within the container.",
          "322:     :param fact_cache: A string that will be used as the name for the subdirectory of the fact cache in artifacts directory.",
          "323:                        This is only used for 'jsonfile' type fact caches.",
          "324:     :param fact_cache_type: A string of the type of fact cache to use.  Defaults to 'jsonfile'.",
          "325:     :param private_data_dir: The directory containing all runner metadata needed to invoke the runner",
          "326:                              module. Output artifacts will also be stored here for later consumption.",
          "327:     :param ident: The run identifier for this invocation of Runner. Will be used to create and name",
          "328:                   the artifact directory holding the results of the invocation.",
          "329:     :param event_handler: An optional callback that will be invoked any time an event is received by Runner itself, return True to keep the event",
          "330:     :param cancel_callback: An optional callback that can inform runner to cancel (returning True) or not (returning False)",
          "331:     :param finished_callback: An optional callback that will be invoked at shutdown after process cleanup.",
          "332:     :param status_handler: An optional callback that will be invoked any time the status changes (e.g...started, running, failed, successful, timeout)",
          "333:     :param artifacts_handler: An optional callback that will be invoked at the end of the run to deal with the artifacts from the run.",
          "334:     :type executable_cmd: str",
          "335:     :type cmdline_args: list",
          "336:     :type input_fd: file descriptor",
          "337:     :type output_fd: file descriptor",
          "338:     :type error_fd: file descriptor",
          "339:     :type runner_mode: str",
          "340:     :type cwd: str",
          "341:     :type envvars: dict",
          "342:     :type passwords: dict",
          "343:     :type settings: dict",
          "344:     :type private_data_dir: str",
          "345:     :type project_dir: str",
          "346:     :type artifact_dir: int",
          "347:     :type fact_cache_type: str",
          "348:     :type fact_cache: str",
          "349:     :type process_isolation: bool",
          "350:     :type process_isolation_executable: str",
          "351:     :type container_image: str",
          "352:     :type container_volume_mounts: list",
          "353:     :type container_options: list",
          "354:     :type containter_workdir: str",
          "355:     :type ident: str",
          "356:     :type rotate_artifacts: int",
          "357:     :type ssh_key: str",
          "358:     :type quiet: bool",
          "359:     :type event_handler: function",
          "360:     :type cancel_callback: function",
          "361:     :type finished_callback: function",
          "362:     :type status_handler: function",
          "363:     :type artifacts_handler: function",
          "365:     :returns: Retunes a tuple of response and error string. In case if ``runner_mode`` is set to ``pexpect`` the error value is empty as",
          "366:               ``pexpect`` uses same output descriptor for stdout and stderr.",
          "367:     '''",
          "368:     r = init_command_config(executable_cmd, cmdline_args=cmdline_args, **kwargs)",
          "369:     r.run()",
          "370:     response = r.stdout.read()",
          "371:     error = r.stderr.read()",
          "372:     return response, error",
          "375: def run_command_async(executable_cmd, cmdline_args=None, **kwargs):",
          "376:     '''",
          "377:     Run an (Ansible) commands in the background which will start immediately. Returns the thread object and a Runner object.",
          "379:     This uses the same parameters as :py:func:`ansible_runner.interface.run_command`",
          "381:     :returns: A tuple containing a :py:class:`threading.Thread` object and a :py:class:`ansible_runner.runner.Runner` object",
          "382:     '''",
          "383:     r = init_command_config(executable_cmd, cmdline_args=cmdline_args, **kwargs)",
          "384:     runner_thread = threading.Thread(target=r.run)",
          "385:     runner_thread.start()",
          "386:     return runner_thread, r",
          "389: def init_plugin_docs_config(plugin_names, plugin_type=None, response_format=None, snippet=False, playbook_dir=None, **kwargs):",
          "390:     '''",
          "391:     Initialize the Runner() instance",
          "393:     This function will properly initialize both get_plugin_docs() and get_plugin_docs_async()",
          "394:     functions in the same way and return a value instance of Runner.",
          "396:     See parameters given to :py:func:`ansible_runner.interface.get_plugin_docs`",
          "397:     '''",
          "399:     event_callback_handler = kwargs.pop('event_handler', None)",
          "400:     status_callback_handler = kwargs.pop('status_handler', None)",
          "401:     artifacts_handler = kwargs.pop('artifacts_handler', None)",
          "402:     cancel_callback = kwargs.pop('cancel_callback', None)",
          "403:     finished_callback = kwargs.pop('finished_callback', None)",
          "405:     rd = DocConfig(**kwargs)",
          "406:     rd.get_plugin_docs(plugin_names, plugin_type=plugin_type, response_format=response_format, snippet=snippet, playbook_dir=playbook_dir)",
          "407:     return Runner(rd, event_handler=event_callback_handler, status_handler=status_callback_handler, artifacts_handler=artifacts_handler,",
          "408:                   cancel_callback=cancel_callback, finished_callback=finished_callback)",
          "411: def get_plugin_docs(plugin_names, plugin_type=None, response_format='json', snippet=False, playbook_dir=None, module_path=None, **kwargs):",
          "412:     '''",
          "413:     Run an ansible-doc command to get plugin docs  in the foreground and return a Runner object when complete.",
          "415:     :param plugin_names: The name of the plugins to get docs.",
          "416:     :param plugin_type: The type of the plugin mentioned in plugins_names. Valid values are ``become``, ``cache``, ``callback``,",
          "417:                         ``cliconf``, ``connection``, ``httpapi``, ``inventory``, ``lookup``, ``netconf``, ``shell``, ``vars``,",
          "418:                         ``module``, ``strategy``. If the value is not provided it defaults to ``module``.",
          "419:     :param response_format: The output format for response. Valid values can be one of ``json`` or ``human`` and the response",
          "420:                             is either json string or plain text in human readable foramt. Default value is ``json``.",
          "421:     :param snippet: Show playbook snippet for specified plugin(s).",
          "422:     :param playbook_dir: This parameter is used to sets the relative path to handle playbook adjacent installed plugins.",
          "423:     :param module_path: This parameter is prepend colon-separated path(s) to module library",
          "424:                         (default=~/.ansible/plugins/modules:/usr/share/ansible/plugins/modules).",
          "425:     :param runner_mode: The applicable values are ``pexpect`` and ``subprocess``. Default is set to ``subporcess``.",
          "426:     :param cwd: The current working directory from which the command in executable_cmd shoulbe be executed.",
          "427:     :param envvars: Environment variables to be used when running Ansible. Environment variables will also be",
          "428:                     read from ``env/envvars`` in ``private_data_dir``",
          "429:     :param passwords: A dictionary containing password prompt patterns and response values used when processing output from",
          "430:                       Ansible. Passwords will also be read from ``env/passwords`` in ``private_data_dir``.",
          "431:     :param settings: A dictionary containing settings values for the ``ansible-runner`` runtime environment. These will also",
          "432:                      be read from ``env/settings`` in ``private_data_dir``.",
          "433:     :param ssh_key: The ssh private key passed to ``ssh-agent`` as part of the ansible-playbook run.",
          "434:     :param quiet: Disable all output",
          "435:     :param artifact_dir: The path to the directory where artifacts should live, this defaults to 'artifacts' under the private data dir",
          "436:     :param project_dir: The path to the playbook content, this defaults to 'project' within the private data dir",
          "437:     :param rotate_artifacts: Keep at most n artifact directories, disable with a value of 0 which is the default",
          "438:     :param process_isolation: Enable process isolation, using a container engine (e.g. podman).",
          "439:     :param process_isolation_executable: Process isolation executable or container engine used to isolate execution. (default: podman)",
          "440:     :param container_image: Container image to use when running an ansible task (default: quay.io/ansible/ansible-runner:devel)",
          "441:     :param container_volume_mounts: List of bind mounts in the form 'host_dir:/container_dir:labels. (default: None)",
          "442:     :param container_options: List of container options to pass to execution engine.",
          "443:     :param containter_workdir: The working directory within the container.",
          "444:     :param fact_cache: A string that will be used as the name for the subdirectory of the fact cache in artifacts directory.",
          "445:                        This is only used for 'jsonfile' type fact caches.",
          "446:     :param fact_cache_type: A string of the type of fact cache to use.  Defaults to 'jsonfile'.",
          "447:     :param private_data_dir: The directory containing all runner metadata needed to invoke the runner",
          "448:                              module. Output artifacts will also be stored here for later consumption.",
          "449:     :param ident: The run identifier for this invocation of Runner. Will be used to create and name",
          "450:                   the artifact directory holding the results of the invocation.",
          "451:     :param event_handler: An optional callback that will be invoked any time an event is received by Runner itself, return True to keep the event",
          "452:     :param cancel_callback: An optional callback that can inform runner to cancel (returning True) or not (returning False)",
          "453:     :param finished_callback: An optional callback that will be invoked at shutdown after process cleanup.",
          "454:     :param status_handler: An optional callback that will be invoked any time the status changes (e.g...started, running, failed, successful, timeout)",
          "455:     :param artifacts_handler: An optional callback that will be invoked at the end of the run to deal with the artifacts from the run.",
          "456:     :type plugin_names: list",
          "457:     :type plugin_type: str",
          "458:     :type response_format: str",
          "459:     :type snippet: bool",
          "460:     :type playbook_dir: str",
          "461:     :type module_path: str",
          "462:     :type runner_mode: str",
          "463:     :type cwd: str",
          "464:     :type envvars: dict",
          "465:     :type passwords: dict",
          "466:     :type settings: dict",
          "467:     :type private_data_dir: str",
          "468:     :type project_dir: str",
          "469:     :type artifact_dir: int",
          "470:     :type fact_cache_type: str",
          "471:     :type fact_cache: str",
          "472:     :type process_isolation: bool",
          "473:     :type process_isolation_executable: str",
          "474:     :type container_image: str",
          "475:     :type container_volume_mounts: list",
          "476:     :type container_options: list",
          "477:     :type containter_workdir: str",
          "478:     :type ident: str",
          "479:     :type rotate_artifacts: int",
          "480:     :type ssh_key: str",
          "481:     :type quiet: bool",
          "482:     :type event_handler: function",
          "483:     :type cancel_callback: function",
          "484:     :type finished_callback: function",
          "485:     :type status_handler: function",
          "486:     :type artifacts_handler: function",
          "488:     :returns: Returns a tuple of response and error string. In case if ``runner_mode`` is set to ``pexpect`` the error value is empty as",
          "489:               ``pexpect`` uses same output descriptor for stdout and stderr.",
          "490:     '''",
          "491:     r = init_plugin_docs_config(plugin_names, plugin_type=plugin_type, response_format=response_format, snippet=snippet, playbook_dir=snippet, **kwargs)",
          "492:     r.run()",
          "493:     response = r.stdout.read()",
          "494:     error = r.stderr.read()",
          "495:     return response, error",
          "498: def get_plugin_docs_async(plugin_names, plugin_type=None, response_format=None, snippet=False, playbook_dir=None, **kwargs):",
          "499:     '''",
          "500:     Run an ansible-doc command in the background which will start immediately. Returns the thread object and a Runner object.",
          "502:     This uses the same parameters as :py:func:`ansible_runner.interface.get_plugin_docs`",
          "504:     :returns: A tuple containing a :py:class:`threading.Thread` object and a :py:class:`ansible_runner.runner.Runner` object",
          "505:     '''",
          "506:     r = init_plugin_docs_config(plugin_names, plugin_type=plugin_type, response_format=response_format, snippet=snippet, playbook_dir=snippet, **kwargs)",
          "507:     doc_runner_thread = threading.Thread(target=r.run)",
          "508:     doc_runner_thread.start()",
          "509:     return doc_runner_thread, r",
          "512: def get_plugin_list(list_files=None, response_format='json', plugin_type=None, playbook_dir=None, module_path=None, **kwargs):",
          "513:     '''",
          "514:     Run an ansible-doc command to get list of installed Ansible plugins.",
          "516:     :param list_files: The boolean parameter is set to ``True`` returns file path of the plugin along with the plugin name.",
          "517:     :param response_format: The output format for response. Valid values can be one of ``json`` or ``human`` and the response",
          "518:                             is either json string or plain text in human readable foramt. Default value is ``json``.",
          "519:     :param plugin_type: The type of the plugin mentioned in plugins_names. Valid values are ``become``, ``cache``, ``callback``,",
          "520:                         ``cliconf``, ``connection``, ``httpapi``, ``inventory``, ``lookup``, ``netconf``, ``shell``, ``vars``,",
          "521:                         ``module``, ``strategy``. If the value is not provided it defaults to ``module``.",
          "522:     :param playbook_dir: This parameter is used to sets the relative path to handle playbook adjacent installed plugins.",
          "523:     :param module_path: This parameter is prepend colon-separated path(s) to module library",
          "524:                         (default=~/.ansible/plugins/modules:/usr/share/ansible/plugins/modules).",
          "525:     :param runner_mode: The applicable values are ``pexpect`` and ``subprocess``. Default is set to ``subporcess``.",
          "526:     :param cwd: The current working directory from which the command in executable_cmd shoulbe be executed.",
          "527:     :param envvars: Environment variables to be used when running Ansible. Environment variables will also be",
          "528:                     read from ``env/envvars`` in ``private_data_dir``",
          "529:     :param passwords: A dictionary containing password prompt patterns and response values used when processing output from",
          "530:                       Ansible. Passwords will also be read from ``env/passwords`` in ``private_data_dir``.",
          "531:     :param settings: A dictionary containing settings values for the ``ansible-runner`` runtime environment. These will also",
          "532:                      be read from ``env/settings`` in ``private_data_dir``.",
          "533:     :param ssh_key: The ssh private key passed to ``ssh-agent`` as part of the ansible-playbook run.",
          "534:     :param quiet: Disable all output",
          "535:     :param artifact_dir: The path to the directory where artifacts should live, this defaults to 'artifacts' under the private data dir",
          "536:     :param project_dir: The path to the playbook content, this defaults to 'project' within the private data dir",
          "537:     :param rotate_artifacts: Keep at most n artifact directories, disable with a value of 0 which is the default",
          "538:     :param process_isolation: Enable process isolation, using a container engine (e.g. podman).",
          "539:     :param process_isolation_executable: Process isolation executable or container engine used to isolate execution. (default: podman)",
          "540:     :param container_image: Container image to use when running an ansible task (default: quay.io/ansible/ansible-runner:devel)",
          "541:     :param container_volume_mounts: List of bind mounts in the form 'host_dir:/container_dir:labels. (default: None)",
          "542:     :param container_options: List of container options to pass to execution engine.",
          "543:     :param containter_workdir: The working directory within the container.",
          "544:     :param fact_cache: A string that will be used as the name for the subdirectory of the fact cache in artifacts directory.",
          "545:                        This is only used for 'jsonfile' type fact caches.",
          "546:     :param fact_cache_type: A string of the type of fact cache to use.  Defaults to 'jsonfile'.",
          "547:     :param private_data_dir: The directory containing all runner metadata needed to invoke the runner",
          "548:                              module. Output artifacts will also be stored here for later consumption.",
          "549:     :param ident: The run identifier for this invocation of Runner. Will be used to create and name",
          "550:                   the artifact directory holding the results of the invocation.",
          "551:     :param event_handler: An optional callback that will be invoked any time an event is received by Runner itself, return True to keep the event",
          "552:     :param cancel_callback: An optional callback that can inform runner to cancel (returning True) or not (returning False)",
          "553:     :param finished_callback: An optional callback that will be invoked at shutdown after process cleanup.",
          "554:     :param status_handler: An optional callback that will be invoked any time the status changes (e.g...started, running, failed, successful, timeout)",
          "555:     :param artifacts_handler: An optional callback that will be invoked at the end of the run to deal with the artifacts from the run.",
          "556:     :type list_files: bool",
          "557:     :type plugin_type: str",
          "558:     :type response_format: str",
          "559:     :type playbook_dir: str",
          "560:     :type module_path: str",
          "561:     :type runner_mode: str",
          "562:     :type cwd: str",
          "563:     :type envvars: dict",
          "564:     :type passwords: dict",
          "565:     :type settings: dict",
          "566:     :type private_data_dir: str",
          "567:     :type project_dir: str",
          "568:     :type artifact_dir: int",
          "569:     :type fact_cache_type: str",
          "570:     :type fact_cache: str",
          "571:     :type process_isolation: bool",
          "572:     :type process_isolation_executable: str",
          "573:     :type container_image: str",
          "574:     :type container_volume_mounts: list",
          "575:     :type container_options: list",
          "576:     :type containter_workdir: str",
          "577:     :type ident: str",
          "578:     :type rotate_artifacts: int",
          "579:     :type ssh_key: str",
          "580:     :type quiet: bool",
          "581:     :type event_handler: function",
          "582:     :type cancel_callback: function",
          "583:     :type finished_callback: function",
          "584:     :type status_handler: function",
          "585:     :type artifacts_handler: function",
          "587:     :returns: Returns a tuple of response and error string. In case if ``runner_mode`` is set to ``pexpect`` the error value is empty as",
          "588:               ``pexpect`` uses same output descriptor for stdout and stderr.",
          "589:     '''",
          "590:     event_callback_handler = kwargs.pop('event_handler', None)",
          "591:     status_callback_handler = kwargs.pop('status_handler', None)",
          "592:     artifacts_handler = kwargs.pop('artifacts_handler', None)",
          "593:     cancel_callback = kwargs.pop('cancel_callback', None)",
          "594:     finished_callback = kwargs.pop('finished_callback', None)",
          "596:     rd = DocConfig(**kwargs)",
          "597:     rd.get_plugin_list(list_files=list_files, response_format=response_format, plugin_type=plugin_type,",
          "598:                        playbook_dir=playbook_dir, module_path=module_path)",
          "599:     r = Runner(rd,",
          "600:                event_handler=event_callback_handler,",
          "601:                status_handler=status_callback_handler,",
          "602:                artifacts_handler=artifacts_handler,",
          "603:                cancel_callback=cancel_callback,",
          "604:                finished_callback=finished_callback)",
          "605:     r.run()",
          "606:     response = r.stdout.read()",
          "607:     error = r.stderr.read()",
          "608:     return response, error",
          "611: def get_inventory(action, inventories, response_format='json', host=None, playbook_dir=None, vault_ids=None, vault_password_file=None, **kwargs):",
          "612:     '''",
          "613:     Run an ansible-inventory command to get inventory releated details.",
          "615:     :param action: Valid values are one of ``graph``, ``host``, ``list``",
          "616:                    ``graph`` create inventory graph, ``host`` returns specific host info and works as inventory script and",
          "617:                    ``list`` output all hosts info and also works as inventory script.",
          "618:     :param inventories: List of inventory host path.",
          "619:     :param response_format: The output format for response. Valid values can be one of ``json``, ``yaml``, ``toml``.",
          "620:                             Default is ``json``. If ``action`` is ``graph`` only allowed value is ``json``.",
          "621:     :param host: When ``action`` is set to ``host`` this parameter is used to get the host specific information.",
          "622:     :param playbook_dir: This parameter is used to sets the relative path for the inventory.",
          "623:     :param vault_ids: The vault identity to use.",
          "624:     :param vault_password_file: The vault password files to use.",
          "625:     :param runner_mode: The applicable values are ``pexpect`` and ``subprocess``. Default is set to ``subporcess``.",
          "626:     :param cwd: The current working directory from which the command in executable_cmd shoulbe be executed.",
          "627:     :param envvars: Environment variables to be used when running Ansible. Environment variables will also be",
          "628:                     read from ``env/envvars`` in ``private_data_dir``",
          "629:     :param passwords: A dictionary containing password prompt patterns and response values used when processing output from",
          "630:                       Ansible. Passwords will also be read from ``env/passwords`` in ``private_data_dir``.",
          "631:     :param settings: A dictionary containing settings values for the ``ansible-runner`` runtime environment. These will also",
          "632:                      be read from ``env/settings`` in ``private_data_dir``.",
          "633:     :param ssh_key: The ssh private key passed to ``ssh-agent`` as part of the ansible-playbook run.",
          "634:     :param quiet: Disable all output",
          "635:     :param artifact_dir: The path to the directory where artifacts should live, this defaults to 'artifacts' under the private data dir",
          "636:     :param project_dir: The path to the playbook content, this defaults to 'project' within the private data dir",
          "637:     :param rotate_artifacts: Keep at most n artifact directories, disable with a value of 0 which is the default",
          "638:     :param process_isolation: Enable process isolation, using a container engine (e.g. podman).",
          "639:     :param process_isolation_executable: Process isolation executable or container engine used to isolate execution. (default: podman)",
          "640:     :param container_image: Container image to use when running an ansible task (default: quay.io/ansible/ansible-runner:devel)",
          "641:     :param container_volume_mounts: List of bind mounts in the form 'host_dir:/container_dir:labels. (default: None)",
          "642:     :param container_options: List of container options to pass to execution engine.",
          "643:     :param containter_workdir: The working directory within the container.",
          "644:     :param fact_cache: A string that will be used as the name for the subdirectory of the fact cache in artifacts directory.",
          "645:                        This is only used for 'jsonfile' type fact caches.",
          "646:     :param fact_cache_type: A string of the type of fact cache to use.  Defaults to 'jsonfile'.",
          "647:     :param private_data_dir: The directory containing all runner metadata needed to invoke the runner",
          "648:                              module. Output artifacts will also be stored here for later consumption.",
          "649:     :param ident: The run identifier for this invocation of Runner. Will be used to create and name",
          "650:                   the artifact directory holding the results of the invocation.",
          "651:     :param event_handler: An optional callback that will be invoked any time an event is received by Runner itself, return True to keep the event",
          "652:     :param cancel_callback: An optional callback that can inform runner to cancel (returning True) or not (returning False)",
          "653:     :param finished_callback: An optional callback that will be invoked at shutdown after process cleanup.",
          "654:     :param status_handler: An optional callback that will be invoked any time the status changes (e.g...started, running, failed, successful, timeout)",
          "655:     :param artifacts_handler: An optional callback that will be invoked at the end of the run to deal with the artifacts from the run.",
          "656:     :type action: str",
          "657:     :type inventories: list",
          "658:     :type response_format: str",
          "659:     :type host: str",
          "660:     :type playbook_dir: str",
          "661:     :type vault_ids: str",
          "662:     :type vault_password_file: str",
          "663:     :type runner_mode: str",
          "664:     :type cwd: str",
          "665:     :type envvars: dict",
          "666:     :type passwords: dict",
          "667:     :type settings: dict",
          "668:     :type private_data_dir: str",
          "669:     :type project_dir: str",
          "670:     :type artifact_dir: int",
          "671:     :type fact_cache_type: str",
          "672:     :type fact_cache: str",
          "673:     :type process_isolation: bool",
          "674:     :type process_isolation_executable: str",
          "675:     :type container_image: str",
          "676:     :type container_volume_mounts: list",
          "677:     :type container_options: list",
          "678:     :type containter_workdir: str",
          "679:     :type ident: str",
          "680:     :type rotate_artifacts: int",
          "681:     :type ssh_key: str",
          "682:     :type quiet: bool",
          "683:     :type event_handler: function",
          "684:     :type cancel_callback: function",
          "685:     :type finished_callback: function",
          "686:     :type status_handler: function",
          "687:     :type artifacts_handler: function",
          "689:     :returns: Returns a tuple of response and error string. In case if ``runner_mode`` is set to ``pexpect`` the error value is",
          "690:               empty as ``pexpect`` uses same output descriptor for stdout and stderr.",
          "691:     '''",
          "693:     event_callback_handler = kwargs.pop('event_handler', None)",
          "694:     status_callback_handler = kwargs.pop('status_handler', None)",
          "695:     artifacts_handler = kwargs.pop('artifacts_handler', None)",
          "696:     cancel_callback = kwargs.pop('cancel_callback', None)",
          "697:     finished_callback = kwargs.pop('finished_callback', None)",
          "699:     rd = InventoryConfig(**kwargs)",
          "700:     rd.get_inventory(action=action, inventories=inventories, response_format=response_format, host=host, playbook_dir=playbook_dir,",
          "701:                      vault_ids=vault_ids, vault_password_file=vault_password_file)",
          "702:     r = Runner(rd,",
          "703:                event_handler=event_callback_handler,",
          "704:                status_handler=status_callback_handler,",
          "705:                artifacts_handler=artifacts_handler,",
          "706:                cancel_callback=cancel_callback,",
          "707:                finished_callback=finished_callback)",
          "708:     r.run()",
          "709:     response = r.stdout.read()",
          "710:     error = r.stderr.read()",
          "711:     return response, error",
          "714: def get_ansible_config(action, config_file=None, only_changed=None, **kwargs):",
          "715:     '''",
          "716:     Run an ansible-config command to get ansible configuration releated details.",
          "718:     :param action: Valid values are one of ``list``, ``dump``, ``view``",
          "719:                    ``list`` returns all config options, ``dump`` returns the active configuration and",
          "720:                    ``view`` returns the view of configuration file.",
          "721:     :param config_file: Path to configuration file, defaults to first file found in precedence.                         .",
          "722:     :param only_changed: The boolean value when set to ``True`` returns only the configurations that have changed",
          "723:                          from the default. This parameter is applicable only when ``action`` is set to ``dump``.",
          "724:     :param runner_mode: The applicable values are ``pexpect`` and ``subprocess``. Default is set to ``subporcess``.",
          "725:     :param cwd: The current working directory from which the command in executable_cmd shoulbe be executed.",
          "726:     :param envvars: Environment variables to be used when running Ansible. Environment variables will also be",
          "727:                     read from ``env/envvars`` in ``private_data_dir``",
          "728:     :param passwords: A dictionary containing password prompt patterns and response values used when processing output from Ansible.",
          "729:                       Passwords will also be read from ``env/passwords`` in ``private_data_dir``.",
          "730:     :param settings: A dictionary containing settings values for the ``ansible-runner`` runtime environment. These will also",
          "731:                      be read from ``env/settings`` in ``private_data_dir``.",
          "732:     :param ssh_key: The ssh private key passed to ``ssh-agent`` as part of the ansible-playbook run.",
          "733:     :param quiet: Disable all output",
          "734:     :param artifact_dir: The path to the directory where artifacts should live, this defaults to 'artifacts' under the private data dir",
          "735:     :param project_dir: The path to the playbook content, this defaults to 'project' within the private data dir",
          "736:     :param rotate_artifacts: Keep at most n artifact directories, disable with a value of 0 which is the default",
          "737:     :param process_isolation: Enable process isolation, using a container engine (e.g. podman).",
          "738:     :param process_isolation_executable: Process isolation executable or container engine used to isolate execution. (default: podman)",
          "739:     :param container_image: Container image to use when running an ansible task (default: quay.io/ansible/ansible-runner:devel)",
          "740:     :param container_volume_mounts: List of bind mounts in the form 'host_dir:/container_dir:labels. (default: None)",
          "741:     :param container_options: List of container options to pass to execution engine.",
          "742:     :param containter_workdir: The working directory within the container.",
          "743:     :param fact_cache: A string that will be used as the name for the subdirectory of the fact cache in artifacts directory.",
          "744:                        This is only used for 'jsonfile' type fact caches.",
          "745:     :param fact_cache_type: A string of the type of fact cache to use.  Defaults to 'jsonfile'.",
          "746:     :param private_data_dir: The directory containing all runner metadata needed to invoke the runner",
          "747:                              module. Output artifacts will also be stored here for later consumption.",
          "748:     :param ident: The run identifier for this invocation of Runner. Will be used to create and name",
          "749:                   the artifact directory holding the results of the invocation.",
          "750:     :param event_handler: An optional callback that will be invoked any time an event is received by Runner itself, return True to keep the event",
          "751:     :param cancel_callback: An optional callback that can inform runner to cancel (returning True) or not (returning False)",
          "752:     :param finished_callback: An optional callback that will be invoked at shutdown after process cleanup.",
          "753:     :param status_handler: An optional callback that will be invoked any time the status changes (e.g...started, running, failed, successful, timeout)",
          "754:     :param artifacts_handler: An optional callback that will be invoked at the end of the run to deal with the artifacts from the run.",
          "755:     :type action: str",
          "756:     :type config_file: str",
          "757:     :type only_changed: bool",
          "758:     :type runner_mode: str",
          "759:     :type cwd: str",
          "760:     :type envvars: dict",
          "761:     :type passwords: dict",
          "762:     :type settings: dict",
          "763:     :type private_data_dir: str",
          "764:     :type project_dir: str",
          "765:     :type artifact_dir: int",
          "766:     :type fact_cache_type: str",
          "767:     :type fact_cache: str",
          "768:     :type process_isolation: bool",
          "769:     :type process_isolation_executable: str",
          "770:     :type container_image: str",
          "771:     :type container_volume_mounts: list",
          "772:     :type container_options: list",
          "773:     :type containter_workdir: str",
          "774:     :type ident: str",
          "775:     :type rotate_artifacts: int",
          "776:     :type ssh_key: str",
          "777:     :type quiet: bool",
          "778:     :type event_handler: function",
          "779:     :type cancel_callback: function",
          "780:     :type finished_callback: function",
          "781:     :type status_handler: function",
          "782:     :type artifacts_handler: function",
          "784:     :returns: Returns a tuple of response and error string. In case if ``runner_mode`` is set to ``pexpect`` the error value is",
          "785:               empty as ``pexpect`` uses same output descriptor for stdout and stderr.",
          "786:     '''",
          "787:     event_callback_handler = kwargs.pop('event_handler', None)",
          "788:     status_callback_handler = kwargs.pop('status_handler', None)",
          "789:     artifacts_handler = kwargs.pop('artifacts_handler', None)",
          "790:     cancel_callback = kwargs.pop('cancel_callback', None)",
          "791:     finished_callback = kwargs.pop('finished_callback', None)",
          "793:     rd = AnsibleConfig(**kwargs)",
          "794:     rd.get_ansible_config(action=action, config_file=config_file, only_changed=only_changed)",
          "795:     r = Runner(rd,",
          "796:                event_handler=event_callback_handler,",
          "797:                status_handler=status_callback_handler,",
          "798:                artifacts_handler=artifacts_handler,",
          "799:                cancel_callback=cancel_callback,",
          "800:                finished_callback=finished_callback)",
          "801:     r.run()",
          "802:     response = r.stdout.read()",
          "803:     error = r.stderr.read()",
          "804:     return response, error",
          "",
          "---------------"
        ],
        "ansible_runner/inventory_config.py||ansible_runner/inventory_config.py": [
          "File: ansible_runner/inventory_config.py -> ansible_runner/inventory_config.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: ############################",
          "2: # Licensed to the Apache Software Foundation (ASF) under one",
          "3: # or more contributor license agreements.  See the NOTICE file",
          "4: # distributed with this work for additional information",
          "5: # regarding copyright ownership.  The ASF licenses this file",
          "6: # to you under the Apache License, Version 2.0 (the",
          "7: # \"License\"); you may not use this file except in compliance",
          "8: # with the License.  You may obtain a copy of the License at",
          "9: #",
          "10: #   http://www.apache.org/licenses/LICENSE-2.0",
          "11: #",
          "12: # Unless required by applicable law or agreed to in writing,",
          "13: # software distributed under the License is distributed on an",
          "14: # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
          "15: # KIND, either express or implied.  See the License for the",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "18: #",
          "19: import logging",
          "20: from ansible_runner import base_config",
          "21: from ansible_runner.exceptions import ConfigurationError",
          "23: logger = logging.getLogger('ansible-runner')",
          "26: class InventoryConfig(base_config.BaseConfig):",
          "27:     \"\"\"",
          "28:     A ``Runner`` configuration object that's meant to encapsulate the configuration used by the",
          "29:     :py:mod:`ansible_runner.runner.InventoryConfig` object to launch and manage the invocation of",
          "30:     command execution.",
          "32:     Typically this object is initialized for you when using the standard ``get_inventory`` interfaces in :py:mod:`ansible_runner.interface`",
          "33:     but can be used to construct the ``InventoryConfig`` configuration to be invoked elsewhere. It can also be overridden to provide different",
          "34:     functionality to the InventoryConfig object.",
          "36:     :Example:",
          "38:     >>> ic = InventoryConfig(...)",
          "39:     >>> r = Runner(config=ic)",
          "40:     >>> r.run()",
          "42:     \"\"\"",
          "44:     def __init__(self, runner_mode=None, **kwargs):",
          "45:         # runner params",
          "46:         self.runner_mode = runner_mode if runner_mode else 'subprocess'",
          "47:         if self.runner_mode not in ['pexpect', 'subprocess']:",
          "48:             raise ConfigurationError(\"Invalid runner mode {0}, valid value is either 'pexpect' or 'subprocess'\".format(self.runner_mode))",
          "50:         self.execution_mode = base_config.ExecutionMode.ANSIBLE_COMMANDS",
          "51:         super(InventoryConfig, self).__init__(**kwargs)",
          "53:     _supported_response_formats = ('json', 'yaml', 'toml')",
          "54:     _supported_actions = ('graph', 'host', 'list')",
          "56:     def get_inventory(self, action, inventories, response_format='json', host=None, playbook_dir=None, vault_ids=None, vault_password_file=None):",
          "58:         if action not in InventoryConfig._supported_actions:",
          "59:             raise ConfigurationError(\"Invalid action {0}, valid value is one of either {1}\".format(action, \" \".join(InventoryConfig._supported_actions)))",
          "61:         if response_format and response_format not in InventoryConfig._supported_response_formats:",
          "62:             raise ConfigurationError(\"Invalid response_format {0}, valid value is one of \"",
          "63:                                      \"either {1}\".format(response_format, \" \".join(InventoryConfig._supported_output_formats)))",
          "65:         if not isinstance(inventories, list):",
          "66:             raise ConfigurationError(\"inventories should be of type list, instead received {0} of type {1}\".format(inventories, type(inventories)))",
          "68:         if action == \"host\" and host is None:",
          "69:             raise ConfigurationError(\"Value of host paramter is required when action in 'host'\")",
          "71:         if action == \"graph\" and response_format and response_format != 'json':",
          "72:             raise ConfigurationError(\"'graph' action supports only 'json' response format\")",
          "74:         self._prepare_env()",
          "75:         self.cmdline_args = []",
          "77:         self.cmdline_args.append('--{0}'.format(action))",
          "78:         if action == 'host':",
          "79:             self.cmdline_args.append(host)",
          "81:         for inv in inventories:",
          "82:             self.cmdline_args.extend(['-i', inv])",
          "84:         if response_format in ['yaml', 'toml']:",
          "85:             self.cmdline_args.append('--{0}'.format(response_format))",
          "87:         if playbook_dir:",
          "88:             self.cmdline_args.extend(['--playbook-dir', playbook_dir])",
          "90:         if vault_ids:",
          "91:             self.cmdline_args.extend(['--vault-id', vault_ids])",
          "93:         if vault_password_file:",
          "94:             self.cmdline_args.extend(['--vault-password-file', vault_password_file])",
          "96:         self.command = ['ansible-inventory'] + self.cmdline_args",
          "97:         self._handle_command_wrap()",
          "",
          "---------------"
        ],
        "ansible_runner/runner.py||ansible_runner/runner.py": [
          "File: ansible_runner/runner.py -> ansible_runner/runner.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import json",
          "5: import errno",
          "6: import signal",
          "8: import shutil",
          "9: import codecs",
          "10: import collections",
          "",
          "[Removed Lines]",
          "7: from subprocess import Popen, PIPE",
          "",
          "[Added Lines]",
          "7: from subprocess import Popen, PIPE, CalledProcessError, TimeoutExpired, run as run_subprocess",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:         self.status = \"unstarted\"",
          "40:         self.rc = None",
          "41:         self.remove_partials = remove_partials",
          "43:     def event_callback(self, event_data):",
          "44:         '''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43:         # default runner mode to pexpect",
          "44:         self.runner_mode = self.config.runner_mode if hasattr(self.config, 'runner_mode') else 'pexpect'",
          "46:         self.resource_profiling = self.config.resource_profiling if hasattr(self.config, 'resource_profiling') else False",
          "47:         self.directory_isolation_path = self.config.directory_isolation_path if hasattr(self.config, 'directory_isolation_path') else None",
          "48:         self.directory_isolation_cleanup = self.config.directory_isolation_cleanup if hasattr(self.config, 'directory_isolation_cleanup') else None",
          "49:         self.process_isolation = self.config.process_isolation if hasattr(self.config, 'process_isolation') else None",
          "50:         self.process_isolation_path_actual = self.config.process_isolation_path_actual if hasattr(self.config, 'process_isolation_path_actual') else None",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "98:         Launch the Ansible task configured in self.config (A RunnerConfig object), returns once the",
          "99:         invocation is complete",
          "100:         '''",
          "101:         self.status_callback('starting')",
          "102:         stdout_filename = os.path.join(self.config.artifact_dir, 'stdout')",
          "103:         command_filename = os.path.join(self.config.artifact_dir, 'command')",
          "105:         try:",
          "106:             os.makedirs(self.config.artifact_dir, mode=0o700)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:         password_patterns = []",
          "111:         password_values = []",
          "116:         stderr_filename = os.path.join(self.config.artifact_dir, 'stderr')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:         if self.config.ident is not None:",
          "128:             cleanup_artifact_dir(os.path.join(self.config.artifact_dir, \"..\"), self.config.rotate_artifacts)",
          "130:         stdout_handle = codecs.open(stdout_filename, 'w', encoding='utf-8')",
          "134:             # We iterate over `expect_passwords.keys()` and",
          "135:             # `expect_passwords.values()` separately to map matched inputs to",
          "136:             # patterns and choose the proper string to send to the subprocess;",
          "137:             # enforce usage of an OrderedDict so that the ordering of elements in",
          "138:             # `keys()` matches `values()`.",
          "139:             expect_passwords = collections.OrderedDict(self.config.expect_passwords)",
          "143:         # pexpect needs all env vars to be utf-8 encoded bytes",
          "144:         # https://github.com/pexpect/pexpect/issues/512",
          "",
          "[Removed Lines]",
          "131:         stdout_handle = OutputEventFilter(stdout_handle, self.event_callback, self.config.suppress_ansible_output, output_json=self.config.json_mode)",
          "133:         if not isinstance(self.config.expect_passwords, collections.OrderedDict):",
          "140:         password_patterns = list(expect_passwords.keys())",
          "141:         password_values = list(expect_passwords.values())",
          "",
          "[Added Lines]",
          "143:         if hasattr(self.config, 'suppress_ansible_output'):",
          "144:             suppress_ansible_output = self.config.suppress_ansible_output",
          "145:         else:",
          "146:             suppress_ansible_output = False",
          "148:         if hasattr(self.config, 'json_mode'):",
          "149:             output_json = self.config.json_mode",
          "150:         else:",
          "151:             output_json = False",
          "154:         stdout_handle = OutputEventFilter(stdout_handle, self.event_callback, suppress_ansible_output, output_json=output_json)",
          "155:         stderr_handle = codecs.open(stderr_filename, 'w', encoding='utf-8')",
          "156:         stderr_handle = OutputEventFilter(stderr_handle, self.event_callback, suppress_ansible_output, output_json=output_json)",
          "158:         if self.runner_mode == 'pexpect' and not isinstance(self.config.expect_passwords, collections.OrderedDict):",
          "165:             password_patterns = list(expect_passwords.keys())",
          "166:             password_values = list(expect_passwords.values())",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "166:         }",
          "168:         # Prepare to collect performance data",
          "170:             cgroup_path = '{0}/{1}'.format(self.config.resource_profiling_base_cgroup, self.config.ident)",
          "172:             import getpass",
          "",
          "[Removed Lines]",
          "169:         if self.config.resource_profiling:",
          "",
          "[Added Lines]",
          "194:         if self.resource_profiling:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "188:         self.status_callback('running')",
          "189:         self.last_stdout_update = time.time()",
          "241:                 self.timed_out = True",
          "245:                 self.kill_container()",
          "256:         if self.canceled:",
          "257:             self.status_callback('canceled')",
          "259:             self.status_callback('successful')",
          "260:         elif self.timed_out:",
          "261:             self.status_callback('timeout')",
          "262:         else:",
          "263:             self.status_callback('failed')",
          "265:         for filename, data in [",
          "266:             ('status', self.status),",
          "267:             ('rc', self.rc),",
          "",
          "[Removed Lines]",
          "190:         try:",
          "191:             child = pexpect.spawn(",
          "192:                 command[0],",
          "193:                 command[1:],",
          "194:                 cwd=cwd,",
          "195:                 env=env,",
          "196:                 ignore_sighup=True,",
          "197:                 encoding='utf-8',",
          "198:                 codec_errors='replace',",
          "199:                 echo=False,",
          "200:                 use_poll=self.config.pexpect_use_poll,",
          "201:             )",
          "202:             child.logfile_read = stdout_handle",
          "203:         except pexpect.exceptions.ExceptionPexpect as e:",
          "204:             child = collections.namedtuple(",
          "205:                 'MissingProcess', 'exitstatus isalive close'",
          "206:             )(",
          "207:                 exitstatus=127,",
          "208:                 isalive=lambda: False,",
          "209:                 close=lambda: None,",
          "210:             )",
          "212:             def _decode(x):",
          "213:                 return x.decode('utf-8') if six.PY2 else x",
          "215:             # create the events directory (the callback plugin won't run, so it",
          "216:             # won't get created)",
          "217:             events_directory = os.path.join(self.config.artifact_dir, 'job_events')",
          "218:             if not os.path.exists(events_directory):",
          "219:                 os.mkdir(events_directory, 0o700)",
          "220:             stdout_handle.write(_decode(str(e)))",
          "221:             stdout_handle.write(_decode('\\n'))",
          "223:         job_start = time.time()",
          "224:         while child.isalive():",
          "225:             result_id = child.expect(password_patterns,",
          "226:                                      timeout=self.config.pexpect_timeout,",
          "227:                                      searchwindowsize=100)",
          "228:             password = password_values[result_id]",
          "229:             if password is not None:",
          "230:                 child.sendline(password)",
          "231:                 self.last_stdout_update = time.time()",
          "232:             if self.cancel_callback:",
          "233:                 try:",
          "234:                     self.canceled = self.cancel_callback()",
          "235:                 except Exception as e:",
          "236:                     # TODO: logger.exception('Could not check cancel callback - cancelling immediately')",
          "237:                     #if isinstance(extra_update_fields, dict):",
          "238:                     #    extra_update_fields['job_explanation'] = \"System error during job execution, check system logs\"",
          "239:                     raise CallbackError(\"Exception in Cancel Callback: {}\".format(e))",
          "240:             if self.config.job_timeout and not self.canceled and (time.time() - job_start) > self.config.job_timeout:",
          "242:                 # if isinstance(extra_update_fields, dict):",
          "243:                 #     extra_update_fields['job_explanation'] = \"Job terminated due to timeout\"",
          "244:             if self.canceled or self.timed_out or self.errored:",
          "246:                 Runner.handle_termination(child.pid, is_cancel=self.canceled)",
          "247:             if self.config.idle_timeout and (time.time() - self.last_stdout_update) > self.config.idle_timeout:",
          "248:                 self.kill_container()",
          "249:                 Runner.handle_termination(child.pid, is_cancel=False)",
          "250:                 self.timed_out = True",
          "252:         stdout_handle.flush()",
          "253:         stdout_handle.close()",
          "254:         child.close()",
          "258:         elif child.exitstatus == 0 and not self.timed_out:",
          "264:         self.rc = child.exitstatus if not (self.timed_out or self.canceled) else 254",
          "",
          "[Added Lines]",
          "216:         # The subprocess runner interface provides stdin/stdout/stderr with streaming capability",
          "217:         # to the caller if input_fd/output_fd/error_fd is passed to config class.",
          "218:         # Alsp, provides an workaround for known issue in pexpect for long running non-interactive process",
          "219:         # https://pexpect.readthedocs.io/en/stable/commonissues.html#truncated-output-just-before-child-exits",
          "220:         if self.runner_mode == 'subprocess':",
          "221:             if hasattr(self.config, 'input_fd') and self.config.input_fd:",
          "222:                 input_fd = self.config.input_fd",
          "223:             else:",
          "224:                 input_fd = None",
          "226:             if hasattr(self.config, 'output_fd') and self.config.output_fd:",
          "227:                 output_fd = self.config.output_fd",
          "228:             else:",
          "229:                 output_fd = PIPE",
          "231:             if hasattr(self.config, 'error_fd') and self.config.error_fd:",
          "232:                 error_fd = self.config.error_fd",
          "233:             else:",
          "234:                 error_fd = PIPE",
          "236:             subprocess_timeout = self.config.subprocess_timeout if hasattr(self.config, 'subprocess_timeout') else None",
          "237:             try:",
          "238:                 stdout_response = ''",
          "239:                 stderr_response = ''",
          "240:                 proc_out = run_subprocess(",
          "241:                     \" \".join(command),",
          "242:                     cwd=cwd,",
          "243:                     env=env,",
          "244:                     stdin=input_fd,",
          "245:                     stdout=output_fd,",
          "246:                     stderr=error_fd,",
          "247:                     timeout=subprocess_timeout,",
          "248:                     check=True,",
          "249:                     universal_newlines=True,",
          "250:                     shell=True,",
          "251:                 )",
          "252:                 stdout_response = proc_out.stdout",
          "253:                 stderr_response = proc_out.stderr",
          "254:                 self.rc = proc_out.returncode",
          "255:             except CalledProcessError as exc:",
          "256:                 logger.debug(\"{cmd} execution failed, returncode: {rc}, output: {output}, stdout: {stdout}, stderr: {stderr}\".format(",
          "257:                     cmd=exc.cmd, rc=exc.returncode, output=exc.output, stdout=exc.stdout, stderr=exc.stderr))",
          "258:                 self.rc = exc.returncode",
          "259:                 self.errored = True",
          "260:                 stdout_response = exc.stdout",
          "261:                 stderr_response = exc.stderr",
          "262:             except TimeoutExpired as exc:",
          "263:                 logger.debug(\"{cmd} execution timedout, timeout: {timeout}, output: {output}, stdout: {stdout}, stderr: {stderr}\".format(",
          "264:                     cmd=exc.cmd, timeout=exc.timeout, output=exc.output, stdout=exc.stdout, stderr=exc.stderr))",
          "265:                 self.rc = 254",
          "266:                 stdout_response = exc.stdout",
          "267:                 stderr_response = exc.stderr",
          "269:             except Exception as exc:",
          "270:                 import traceback",
          "271:                 stderr_response = traceback.format_exc()",
          "272:                 self.rc = 254",
          "273:                 self.errored = True",
          "274:                 logger.debug(\"received execption: {exc}\".format(exc=str(exc)))",
          "276:             if self.timed_out or self.errored:",
          "279:             if stdout_response:",
          "280:                 if isinstance(stdout_response, bytes):",
          "281:                     stdout_response = stdout_response.decode()",
          "282:                 stdout_handle.write(stdout_response)",
          "283:             if stderr_response:",
          "284:                 if isinstance(stderr_response, bytes):",
          "285:                     stderr_response = stderr_response.decode()",
          "286:                 stderr_handle.write(stderr_response)",
          "287:         else:",
          "288:             try:",
          "289:                 child = pexpect.spawn(",
          "290:                     command[0],",
          "291:                     command[1:],",
          "292:                     cwd=cwd,",
          "293:                     env=env,",
          "294:                     ignore_sighup=True,",
          "295:                     encoding='utf-8',",
          "296:                     codec_errors='replace',",
          "297:                     echo=False,",
          "298:                     use_poll=self.config.pexpect_use_poll,",
          "299:                 )",
          "300:                 child.logfile_read = stdout_handle",
          "301:             except pexpect.exceptions.ExceptionPexpect as e:",
          "302:                 child = collections.namedtuple(",
          "303:                     'MissingProcess', 'exitstatus isalive close'",
          "304:                 )(",
          "305:                     exitstatus=127,",
          "306:                     isalive=lambda: False,",
          "307:                     close=lambda: None,",
          "308:                 )",
          "310:                 def _decode(x):",
          "311:                     return x.decode('utf-8') if six.PY2 else x",
          "313:                 # create the events directory (the callback plugin won't run, so it",
          "314:                 # won't get created)",
          "315:                 events_directory = os.path.join(self.config.artifact_dir, 'job_events')",
          "316:                 if not os.path.exists(events_directory):",
          "317:                     os.mkdir(events_directory, 0o700)",
          "318:                 stdout_handle.write(_decode(str(e)))",
          "319:                 stdout_handle.write(_decode('\\n'))",
          "321:             job_start = time.time()",
          "322:             while child.isalive():",
          "323:                 result_id = child.expect(password_patterns, timeout=self.config.pexpect_timeout, searchwindowsize=100)",
          "324:                 password = password_values[result_id]",
          "325:                 if password is not None:",
          "326:                     child.sendline(password)",
          "327:                     self.last_stdout_update = time.time()",
          "328:                 if self.cancel_callback:",
          "329:                     try:",
          "330:                         self.canceled = self.cancel_callback()",
          "331:                     except Exception as e:",
          "332:                         # TODO: logger.exception('Could not check cancel callback - cancelling immediately')",
          "333:                         #if isinstance(extra_update_fields, dict):",
          "334:                         #    extra_update_fields['job_explanation'] = \"System error during job execution, check system logs\"",
          "335:                         raise CallbackError(\"Exception in Cancel Callback: {}\".format(e))",
          "336:                 if self.config.job_timeout and not self.canceled and (time.time() - job_start) > self.config.job_timeout:",
          "337:                     self.timed_out = True",
          "338:                     # if isinstance(extra_update_fields, dict):",
          "339:                     #     extra_update_fields['job_explanation'] = \"Job terminated due to timeout\"",
          "340:                 if self.canceled or self.timed_out or self.errored:",
          "341:                     self.kill_container()",
          "342:                     Runner.handle_termination(child.pid, is_cancel=self.canceled)",
          "343:                 if self.config.idle_timeout and (time.time() - self.last_stdout_update) > self.config.idle_timeout:",
          "344:                     self.kill_container()",
          "345:                     Runner.handle_termination(child.pid, is_cancel=False)",
          "346:                     self.timed_out = True",
          "348:             stdout_handle.flush()",
          "349:             stdout_handle.close()",
          "350:             child.close()",
          "351:             self.rc = child.exitstatus if not (self.timed_out or self.canceled) else 254",
          "355:         elif self.rc == 0 and not self.timed_out:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "271:                 os.close(os.open(artifact_path, os.O_CREAT, stat.S_IRUSR | stat.S_IWUSR))",
          "272:             with open(artifact_path, 'w') as f:",
          "273:                 f.write(str(data))",
          "277:             def _delete(retries=15):",
          "278:                 try:",
          "280:                 except OSError as e:",
          "281:                     res = False",
          "282:                     if e.errno == 16 and retries > 0:",
          "",
          "[Removed Lines]",
          "274:         if self.config.directory_isolation_path and self.config.directory_isolation_cleanup:",
          "275:             shutil.rmtree(self.config.directory_isolation_path)",
          "276:         if self.config.process_isolation and self.config.process_isolation_path_actual:",
          "279:                     shutil.rmtree(self.config.process_isolation_path_actual)",
          "",
          "[Added Lines]",
          "371:         if self.directory_isolation_path and self.directory_isolation_cleanup:",
          "372:             shutil.rmtree(self.directory_isolation_path)",
          "373:         if self.process_isolation and self.process_isolation_path_actual:",
          "376:                     shutil.rmtree(self.process_isolation_path_actual)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "286:                         raise",
          "287:                 return True",
          "288:             _delete()",
          "290:             cmd = 'cgdelete -g cpuacct,memory,pids:{}'.format(cgroup_path)",
          "291:             proc = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)",
          "292:             _, stderr = proc.communicate()",
          "",
          "[Removed Lines]",
          "289:         if self.config.resource_profiling:",
          "",
          "[Added Lines]",
          "386:         if self.resource_profiling:",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "317:             raise AnsibleRunnerException(\"stdout missing\")",
          "318:         return open(os.path.join(self.config.artifact_dir, 'stdout'), 'r')",
          "320:     @property",
          "321:     def events(self):",
          "322:         '''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "417:     @property",
          "418:     def stderr(self):",
          "419:         '''",
          "420:         Returns an open file handle to the stderr representing the Ansible run",
          "421:         '''",
          "422:         stderr_path = os.path.join(self.config.artifact_dir, 'stderr')",
          "423:         if not os.path.exists(stderr_path):",
          "424:             raise AnsibleRunnerException(\"stderr missing\")",
          "425:         return open(os.path.join(self.config.artifact_dir, 'stderr'), 'r')",
          "",
          "---------------"
        ],
        "ansible_runner/utils.py||ansible_runner/utils.py": [
          "File: ansible_runner/utils.py -> ansible_runner/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:     invalid characters so it can be used in docker/podman CLI commands",
          "430:     \"\"\"",
          "431:     return re.sub('[^a-zA-Z0-9_-]', '_', text_type(original_name))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "434: def cli_mounts():",
          "435:     return [",
          "436:         {",
          "437:             'ENVS': ['SSH_AUTH_SOCK'],",
          "438:             'PATHS': [",
          "439:                 {",
          "440:                     'src': '{}/.ssh/'.format(os.environ['HOME']),",
          "441:                     'dest': '/home/runner/.ssh/'",
          "442:                 },",
          "443:                 {",
          "444:                     'src': '/etc/ssh/ssh_known_hosts',",
          "445:                     'dest': '/etc/ssh/ssh_known_hosts'",
          "446:                 }",
          "447:             ]",
          "448:         },",
          "449:     ]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "82703435307162a4f3ac95ab57fd27b0387ffe14",
      "candidate_info": {
        "commit_hash": "82703435307162a4f3ac95ab57fd27b0387ffe14",
        "repo": "ansible/ansible-runner",
        "commit_url": "https://github.com/ansible/ansible-runner/commit/82703435307162a4f3ac95ab57fd27b0387ffe14",
        "files": [
          "ansible_runner/config/_base.py",
          "ansible_runner/runner.py"
        ],
        "message": "update subprocess timeout logic",
        "before_after_code_files": [
          "ansible_runner/config/_base.py||ansible_runner/config/_base.py",
          "ansible_runner/runner.py||ansible_runner/runner.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ansible_runner/runner.py||ansible_runner/runner.py"
          ],
          "candidate": [
            "ansible_runner/runner.py||ansible_runner/runner.py"
          ]
        }
      },
      "candidate_diff": {
        "ansible_runner/config/_base.py||ansible_runner/config/_base.py": [
          "File: ansible_runner/config/_base.py -> ansible_runner/config/_base.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "167:             self.job_timeout = self.settings.get('job_timeout', None)",
          "169:         elif self.runner_mode == 'subprocess':",
          "172:         self.process_isolation = self.settings.get('process_isolation', self.process_isolation)",
          "173:         self.process_isolation_executable = self.settings.get('process_isolation_executable', self.process_isolation_executable)",
          "",
          "[Removed Lines]",
          "170:             self.subprocess_timeout = self.settings.get('subprocess_timeout', 300)",
          "",
          "[Added Lines]",
          "170:             self.subprocess_timeout = self.settings.get('subprocess_timeout', None)",
          "",
          "---------------"
        ],
        "ansible_runner/runner.py||ansible_runner/runner.py": [
          "File: ansible_runner/runner.py -> ansible_runner/runner.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:             try:",
          "235:                 stdout_response = ''",
          "236:                 stderr_response = ''",
          "249:                 stdout_response = proc_out.stdout",
          "250:                 stderr_response = proc_out.stderr",
          "251:                 self.rc = proc_out.returncode",
          "",
          "[Removed Lines]",
          "237:                 proc_out = run_subprocess(",
          "238:                     \" \".join(command),",
          "239:                     cwd=cwd,",
          "240:                     env=env,",
          "241:                     stdin=input_fd,",
          "242:                     stdout=output_fd,",
          "243:                     stderr=error_fd,",
          "244:                     timeout=subprocess_timeout,",
          "245:                     check=True,",
          "246:                     universal_newlines=True,",
          "247:                     shell=True,",
          "248:                 )",
          "",
          "[Added Lines]",
          "237:                 kwargs = {",
          "238:                     'cwd': cwd,",
          "239:                     'env': env,",
          "240:                     'stdin': input_fd,",
          "241:                     'stdout': output_fd,",
          "242:                     'stderr': error_fd,",
          "243:                     'check': True,",
          "244:                     'universal_newlines': True,",
          "245:                     'shell': True",
          "246:                 }",
          "247:                 if subprocess_timeout is not None:",
          "248:                     kwargs.update({'timeout': subprocess_timeout})",
          "250:                 proc_out = run_subprocess( \" \".join(command), **kwargs)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-39441",
  "cve_desc": "Apache Airflow SMTP Provider before 1.3.0, Apache Airflow IMAP Provider before 3.3.0, and\u00a0Apache Airflow before 2.7.0 are affected by the\u00a0Validation of OpenSSL Certificate vulnerability.\n\nThe default SSL context with SSL library did not check a server's X.509\u00a0certificate.\u00a0 Instead, the code accepted any certificate, which could\u00a0result in the disclosure of mail server credentials or mail contents\u00a0when the client connects to an attacker in a MITM position.\n\nUsers are strongly advised to upgrade to Apache Airflow version 2.7.0 or newer, Apache Airflow IMAP Provider version 3.3.0 or newer, and Apache Airflow SMTP Provider version 1.3.0 or newer to mitigate the risk associated with this vulnerability",
  "repo": "apache/airflow",
  "patch_hash": "dbacacbd4d476da757de148a4e747924c34fd7fe",
  "patch_info": {
    "commit_hash": "dbacacbd4d476da757de148a4e747924c34fd7fe",
    "repo": "apache/airflow",
    "commit_url": "https://github.com/apache/airflow/commit/dbacacbd4d476da757de148a4e747924c34fd7fe",
    "files": [
      "airflow/providers/smtp/CHANGELOG.rst",
      "airflow/providers/smtp/hooks/smtp.py",
      "airflow/providers/smtp/provider.yaml",
      "docs/apache-airflow-providers-smtp/configurations-ref.rst",
      "docs/apache-airflow-providers-smtp/index.rst",
      "docs/apache-airflow/configurations-ref.rst",
      "tests/providers/smtp/hooks/test_smtp.py"
    ],
    "message": "Allows to choose SSL context for SMTP provider (#33075)\n\n* Allows to choose SSL context for SMTP provider\n\nThis change add two options to choose from when SSL SMTP connection\nis created:\n\n* default - for balance between compatibility and security\n* none - in case compatibility with existing infrastructure is\n\u00a0 preferred\n\nThe fallback is:\n\n* The Airflow \"email\", \"ssl_context\"\n* \"default\"\n\n* Update airflow/providers/smtp/CHANGELOG.rst\n\nCo-authored-by: Ephraim Anierobi <splendidzigy24@gmail.com>\n(cherry picked from commit e20325db38fdfdd9db423a345b13d18aab6fe578)",
    "before_after_code_files": [
      "airflow/providers/smtp/hooks/smtp.py||airflow/providers/smtp/hooks/smtp.py",
      "tests/providers/smtp/hooks/test_smtp.py||tests/providers/smtp/hooks/test_smtp.py"
    ]
  },
  "patch_diff": {
    "airflow/providers/smtp/hooks/smtp.py||airflow/providers/smtp/hooks/smtp.py": [
      "File: airflow/providers/smtp/hooks/smtp.py -> airflow/providers/smtp/hooks/smtp.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: import os",
      "27: import re",
      "28: import smtplib",
      "29: from email.mime.application import MIMEApplication",
      "30: from email.mime.multipart import MIMEMultipart",
      "31: from email.mime.text import MIMEText",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29: import ssl",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "109:             smtp_kwargs[\"port\"] = self.port",
      "110:         smtp_kwargs[\"timeout\"] = self.timeout",
      "112:         return SMTP(**smtp_kwargs)",
      "114:     @classmethod",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "112:         if self.use_ssl:",
      "113:             from airflow.configuration import conf",
      "115:             ssl_context_string = conf.get(\"smtp_provider\", \"SSL_CONTEXT\", fallback=None)",
      "116:             if ssl_context_string is None:",
      "117:                 ssl_context_string = conf.get(\"email\", \"SSL_CONTEXT\", fallback=None)",
      "118:             if ssl_context_string is None:",
      "119:                 ssl_context_string = \"default\"",
      "120:             if ssl_context_string == \"default\":",
      "121:                 ssl_context = ssl.create_default_context()",
      "122:             elif ssl_context_string == \"none\":",
      "123:                 ssl_context = None",
      "124:             else:",
      "125:                 raise RuntimeError(",
      "126:                     f\"The email.ssl_context configuration variable must \"",
      "127:                     f\"be set to 'default' or 'none' and is '{ssl_context_string}'.\"",
      "128:                 )",
      "129:             smtp_kwargs[\"context\"] = ssl_context",
      "",
      "---------------"
    ],
    "tests/providers/smtp/hooks/test_smtp.py||tests/providers/smtp/hooks/test_smtp.py": [
      "File: tests/providers/smtp/hooks/test_smtp.py -> tests/providers/smtp/hooks/test_smtp.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: from airflow.providers.smtp.hooks.smtp import SmtpHook",
      "31: from airflow.utils import db",
      "32: from airflow.utils.session import create_session",
      "34: smtplib_string = \"airflow.providers.smtp.hooks.smtp.smtplib\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "33: from tests.test_utils.config import conf_vars",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "75:         )",
      "77:     @patch(smtplib_string)",
      "79:         mock_conn = _create_fake_smtp(mock_smtplib)",
      "81:         with SmtpHook():",
      "82:             pass",
      "85:         mock_conn.login.assert_called_once_with(\"smtp_user\", \"smtp_password\")",
      "86:         assert mock_conn.close.call_count == 1",
      "",
      "[Removed Lines]",
      "78:     def test_connect_and_disconnect(self, mock_smtplib):",
      "84:         mock_smtplib.SMTP_SSL.assert_called_once_with(host=\"smtp_server_address\", port=465, timeout=30)",
      "",
      "[Added Lines]",
      "79:     @patch(\"ssl.create_default_context\")",
      "80:     def test_connect_and_disconnect(self, create_default_context, mock_smtplib):",
      "85:         assert create_default_context.called",
      "86:         mock_smtplib.SMTP_SSL.assert_called_once_with(",
      "87:             host=\"smtp_server_address\", port=465, timeout=30, context=create_default_context.return_value",
      "88:         )",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "202:     @patch(\"smtplib.SMTP_SSL\")",
      "203:     @patch(\"smtplib.SMTP\")",
      "205:         mock_smtp_ssl.return_value = Mock()",
      "206:         with SmtpHook() as smtp_hook:",
      "207:             smtp_hook.send_email_smtp(to=\"to\", subject=\"subject\", html_content=\"content\", from_email=\"from\")",
      "208:         assert not mock_smtp.called",
      "211:     @patch(\"smtplib.SMTP_SSL\")",
      "212:     @patch(\"smtplib.SMTP\")",
      "",
      "[Removed Lines]",
      "204:     def test_send_mime_ssl(self, mock_smtp, mock_smtp_ssl):",
      "209:         mock_smtp_ssl.assert_called_once_with(host=\"smtp_server_address\", port=465, timeout=30)",
      "",
      "[Added Lines]",
      "208:     @patch(\"ssl.create_default_context\")",
      "209:     def test_send_mime_ssl(self, create_default_context, mock_smtp, mock_smtp_ssl):",
      "214:         assert create_default_context.called",
      "215:         mock_smtp_ssl.assert_called_once_with(",
      "216:             host=\"smtp_server_address\", port=465, timeout=30, context=create_default_context.return_value",
      "217:         )",
      "219:     @patch(\"smtplib.SMTP_SSL\")",
      "220:     @patch(\"smtplib.SMTP\")",
      "221:     @patch(\"ssl.create_default_context\")",
      "222:     def test_send_mime_ssl_none_email_context(self, create_default_context, mock_smtp, mock_smtp_ssl):",
      "223:         mock_smtp_ssl.return_value = Mock()",
      "224:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\", (\"email\", \"ssl_context\"): \"none\"}):",
      "225:             with SmtpHook() as smtp_hook:",
      "226:                 smtp_hook.send_email_smtp(",
      "227:                     to=\"to\", subject=\"subject\", html_content=\"content\", from_email=\"from\"",
      "228:                 )",
      "229:         assert not mock_smtp.called",
      "230:         assert not create_default_context.called",
      "231:         mock_smtp_ssl.assert_called_once_with(host=\"smtp_server_address\", port=465, timeout=30, context=None)",
      "233:     @patch(\"smtplib.SMTP_SSL\")",
      "234:     @patch(\"smtplib.SMTP\")",
      "235:     @patch(\"ssl.create_default_context\")",
      "236:     def test_send_mime_ssl_none_smtp_provider_context(self, create_default_context, mock_smtp, mock_smtp_ssl):",
      "237:         mock_smtp_ssl.return_value = Mock()",
      "238:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\", (\"smtp_provider\", \"ssl_context\"): \"none\"}):",
      "239:             with SmtpHook() as smtp_hook:",
      "240:                 smtp_hook.send_email_smtp(",
      "241:                     to=\"to\", subject=\"subject\", html_content=\"content\", from_email=\"from\"",
      "242:                 )",
      "243:         assert not mock_smtp.called",
      "244:         assert not create_default_context.called",
      "245:         mock_smtp_ssl.assert_called_once_with(host=\"smtp_server_address\", port=465, timeout=30, context=None)",
      "247:     @patch(\"smtplib.SMTP_SSL\")",
      "248:     @patch(\"smtplib.SMTP\")",
      "249:     @patch(\"ssl.create_default_context\")",
      "250:     def test_send_mime_ssl_none_smtp_provider_default_email_context(",
      "251:         self, create_default_context, mock_smtp, mock_smtp_ssl",
      "252:     ):",
      "253:         mock_smtp_ssl.return_value = Mock()",
      "254:         with conf_vars(",
      "255:             {",
      "256:                 (\"smtp\", \"smtp_ssl\"): \"True\",",
      "257:                 (\"email\", \"ssl_context\"): \"default\",",
      "258:                 (\"smtp_provider\", \"ssl_context\"): \"none\",",
      "259:             }",
      "260:         ):",
      "261:             with SmtpHook() as smtp_hook:",
      "262:                 smtp_hook.send_email_smtp(",
      "263:                     to=\"to\", subject=\"subject\", html_content=\"content\", from_email=\"from\"",
      "264:                 )",
      "265:         assert not mock_smtp.called",
      "266:         assert not create_default_context.called",
      "267:         mock_smtp_ssl.assert_called_once_with(host=\"smtp_server_address\", port=465, timeout=30, context=None)",
      "269:     @patch(\"smtplib.SMTP_SSL\")",
      "270:     @patch(\"smtplib.SMTP\")",
      "271:     @patch(\"ssl.create_default_context\")",
      "272:     def test_send_mime_ssl_default_smtp_provider_none_email_context(",
      "273:         self, create_default_context, mock_smtp, mock_smtp_ssl",
      "274:     ):",
      "275:         mock_smtp_ssl.return_value = Mock()",
      "276:         with conf_vars(",
      "277:             {",
      "278:                 (\"smtp\", \"smtp_ssl\"): \"True\",",
      "279:                 (\"email\", \"ssl_context\"): \"none\",",
      "280:                 (\"smtp_provider\", \"ssl_context\"): \"default\",",
      "281:             }",
      "282:         ):",
      "283:             with SmtpHook() as smtp_hook:",
      "284:                 smtp_hook.send_email_smtp(",
      "285:                     to=\"to\", subject=\"subject\", html_content=\"content\", from_email=\"from\"",
      "286:                 )",
      "287:         assert not mock_smtp.called",
      "288:         assert create_default_context.called",
      "289:         mock_smtp_ssl.assert_called_once_with(",
      "290:             host=\"smtp_server_address\", port=465, timeout=30, context=create_default_context.return_value",
      "291:         )",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "270:     @patch(\"airflow.models.connection.Connection\")",
      "271:     @patch(\"smtplib.SMTP_SSL\")",
      "273:         mock_smtp_ssl().sendmail.side_effect = smtplib.SMTPServerDisconnected()",
      "274:         custom_retry_limit = 10",
      "275:         custom_timeout = 60",
      "",
      "[Removed Lines]",
      "272:     def test_send_mime_custom_timeout_retrylimit(self, mock_smtp_ssl, connection_mock):",
      "",
      "[Added Lines]",
      "354:     @patch(\"ssl.create_default_context\")",
      "355:     def test_send_mime_custom_timeout_retrylimit(",
      "356:         self, create_default_context, mock_smtp_ssl, connection_mock",
      "357:     ):",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "287:             with pytest.raises(smtplib.SMTPServerDisconnected):",
      "288:                 smtp_hook.send_email_smtp(to=\"to\", subject=\"subject\", html_content=\"content\")",
      "289:         mock_smtp_ssl.assert_any_call(",
      "291:         )",
      "292:         assert mock_smtp_ssl().sendmail.call_count == 10",
      "",
      "[Removed Lines]",
      "290:             host=fake_conn.host, port=fake_conn.port, timeout=fake_conn.extra_dejson[\"timeout\"]",
      "",
      "[Added Lines]",
      "375:             host=fake_conn.host,",
      "376:             port=fake_conn.port,",
      "377:             timeout=fake_conn.extra_dejson[\"timeout\"],",
      "378:             context=create_default_context.return_value,",
      "380:         assert create_default_context.called",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
      "candidate_info": {
        "commit_hash": "fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
        "files": [
          "airflow/config_templates/config.yml",
          "airflow/jobs/job.py",
          "airflow/jobs/triggerer_job_runner.py",
          "airflow/models/trigger.py",
          "tests/jobs/test_base_job.py",
          "tests/models/test_trigger.py"
        ],
        "message": "Configurable health check threshold for triggerer (#33089)\n\nRecently the Triggerer was forced to a health check threshold of\n`trigger_heartbeat * 2.1` with a default of 5s for the heartbeat, this\ngenerates a threshold of 10.5s, the previous threshold was 30s, this\nleads to a very unstable situation where Triggerers are not given a\nreasonable amount of time to heartbeat and their triggers are taken\nfrom them.\n\nThis change allows the user to configure this threshold the same way we\ndo for the scheduler.\n\n(cherry picked from commit 6ec3b9abb67617ebbea2129421c05e45dc863bee)",
        "before_after_code_files": [
          "airflow/jobs/job.py||airflow/jobs/job.py",
          "airflow/jobs/triggerer_job_runner.py||airflow/jobs/triggerer_job_runner.py",
          "airflow/models/trigger.py||airflow/models/trigger.py",
          "tests/jobs/test_base_job.py||tests/jobs/test_base_job.py",
          "tests/models/test_trigger.py||tests/models/test_trigger.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/33247"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/jobs/job.py||airflow/jobs/job.py": [
          "File: airflow/jobs/job.py -> airflow/jobs/job.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:         \"\"\"",
          "130:         if self.job_type == \"SchedulerJob\":",
          "131:             health_check_threshold: int = conf.getint(\"scheduler\", \"scheduler_health_check_threshold\")",
          "132:         else:",
          "133:             health_check_threshold: int = self.heartrate * grace_multiplier",
          "134:         return (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:         elif self.job_type == \"TriggererJob\":",
          "133:             health_check_threshold: int = conf.getint(\"triggerer\", \"triggerer_health_check_threshold\")",
          "",
          "---------------"
        ],
        "airflow/jobs/triggerer_job_runner.py||airflow/jobs/triggerer_job_runner.py": [
          "File: airflow/jobs/triggerer_job_runner.py -> airflow/jobs/triggerer_job_runner.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:         else:",
          "258:             raise ValueError(f\"Capacity number {capacity} is invalid\")",
          "260:         should_queue = True",
          "261:         if DISABLE_WRAPPER:",
          "262:             self.log.warning(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:         self.health_check_threshold = conf.getint(\"triggerer\", \"triggerer_health_check_threshold\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "364:     def load_triggers(self):",
          "365:         \"\"\"Query the database for the triggers we're supposed to be running and update the runner.\"\"\"",
          "367:         ids = Trigger.ids_for_triggerer(self.job.id)",
          "368:         self.trigger_runner.update_triggers(set(ids))",
          "",
          "[Removed Lines]",
          "366:         Trigger.assign_unassigned(self.job.id, self.capacity, self.job.heartrate)",
          "",
          "[Added Lines]",
          "368:         Trigger.assign_unassigned(self.job.id, self.capacity, self.health_check_threshold)",
          "",
          "---------------"
        ],
        "airflow/models/trigger.py||airflow/models/trigger.py": [
          "File: airflow/models/trigger.py -> airflow/models/trigger.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:     @classmethod",
          "200:     @internal_api_call",
          "201:     @provide_session",
          "203:         \"\"\"",
          "204:         Assign unassigned triggers based on a number of conditions.",
          "209:         \"\"\"",
          "210:         from airflow.jobs.job import Job  # To avoid circular import",
          "",
          "[Removed Lines]",
          "202:     def assign_unassigned(cls, triggerer_id, capacity, heartrate, session: Session = NEW_SESSION) -> None:",
          "206:         Takes a triggerer_id, the capacity for that triggerer and the Triggerer job heartrate,",
          "207:         and assigns unassigned triggers until that capacity is reached, or there are no more",
          "208:         unassigned triggers.",
          "",
          "[Added Lines]",
          "202:     def assign_unassigned(",
          "203:         cls, triggerer_id, capacity, health_check_threshold, session: Session = NEW_SESSION",
          "204:     ) -> None:",
          "208:         Takes a triggerer_id, the capacity for that triggerer and the Triggerer job heartrate",
          "209:         health check threshold, and assigns unassigned triggers until that capacity is reached,",
          "210:         or there are no more unassigned triggers.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "215:         if capacity <= 0:",
          "216:             return",
          "220:         alive_triggerer_ids = session.scalars(",
          "221:             select(Job.id).where(",
          "222:                 Job.end_date.is_(None),",
          "",
          "[Removed Lines]",
          "217:         # we multiply heartrate by a grace_multiplier to give the triggerer",
          "218:         # a chance to heartbeat before we consider it dead",
          "219:         health_check_threshold = heartrate * 2.1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/jobs/test_base_job.py||tests/jobs/test_base_job.py": [
          "File: tests/jobs/test_base_job.py -> tests/jobs/test_base_job.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: import sys",
          "22: from unittest.mock import ANY, Mock, patch",
          "25: from sqlalchemy.exc import OperationalError",
          "27: from airflow.executors.sequential_executor import SequentialExecutor",
          "",
          "[Removed Lines]",
          "24: from pytest import raises",
          "",
          "[Added Lines]",
          "24: import pytest",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:         job = Job()",
          "86:         job_runner = MockJobRunner(job=job, func=abort)",
          "88:             run_job(job=job, execute_callable=job_runner._execute)",
          "90:         assert job.state == State.FAILED",
          "",
          "[Removed Lines]",
          "87:         with raises(RuntimeError):",
          "",
          "[Added Lines]",
          "87:         with pytest.raises(RuntimeError):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148:         job.latest_heartbeat = timezone.utcnow() - datetime.timedelta(seconds=10)",
          "149:         assert job.is_alive() is False, \"Completed jobs even with recent heartbeat should not be alive\"",
          "153:         assert job.is_alive() is True",
          "155:         job.latest_heartbeat = timezone.utcnow() - datetime.timedelta(seconds=20)",
          "",
          "[Removed Lines]",
          "151:     def test_is_alive_scheduler(self):",
          "152:         job = Job(heartrate=10, state=State.RUNNING, job_type=\"SchedulerJob\")",
          "",
          "[Added Lines]",
          "151:     @pytest.mark.parametrize(\"job_type\", [\"SchedulerJob\", \"TriggererJob\"])",
          "152:     def test_is_alive_scheduler(self, job_type):",
          "153:         job = Job(heartrate=10, state=State.RUNNING, job_type=job_type)",
          "",
          "---------------"
        ],
        "tests/models/test_trigger.py||tests/models/test_trigger.py": [
          "File: tests/models/test_trigger.py -> tests/models/test_trigger.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:     \"\"\"",
          "142:     Tests that unassigned triggers of all appropriate states are assigned.",
          "143:     \"\"\"",
          "144:     triggerer_heartrate = 10",
          "145:     finished_triggerer = Job(heartrate=triggerer_heartrate, state=State.SUCCESS)",
          "146:     TriggererJobRunner(finished_triggerer)",
          "148:     session.add(finished_triggerer)",
          "149:     assert not finished_triggerer.is_alive()",
          "150:     healthy_triggerer = Job(heartrate=triggerer_heartrate, state=State.RUNNING)",
          "",
          "[Removed Lines]",
          "147:     finished_triggerer.end_date = timezone.utcnow() - datetime.timedelta(hours=1)",
          "",
          "[Added Lines]",
          "144:     time_now = timezone.utcnow()",
          "148:     finished_triggerer.end_date = time_now - datetime.timedelta(hours=1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     TriggererJobRunner(new_triggerer)",
          "156:     session.add(new_triggerer)",
          "157:     assert new_triggerer.is_alive()",
          "158:     session.commit()",
          "159:     trigger_on_healthy_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "160:     trigger_on_healthy_triggerer.id = 1",
          "161:     trigger_on_healthy_triggerer.triggerer_id = healthy_triggerer.id",
          "162:     trigger_on_killed_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "164:     trigger_on_killed_triggerer.triggerer_id = finished_triggerer.id",
          "165:     trigger_unassigned_to_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "167:     assert trigger_unassigned_to_triggerer.triggerer_id is None",
          "168:     session.add(trigger_on_healthy_triggerer)",
          "169:     session.add(trigger_on_killed_triggerer)",
          "170:     session.add(trigger_unassigned_to_triggerer)",
          "171:     session.commit()",
          "174:     session.expire_all()",
          "175:     # Check that trigger on killed triggerer and unassigned trigger are assigned to new triggerer",
          "176:     assert (",
          "",
          "[Removed Lines]",
          "163:     trigger_on_killed_triggerer.id = 2",
          "166:     trigger_unassigned_to_triggerer.id = 3",
          "172:     assert session.query(Trigger).count() == 3",
          "173:     Trigger.assign_unassigned(new_triggerer.id, 100, session=session, heartrate=triggerer_heartrate)",
          "",
          "[Added Lines]",
          "159:     # This trigger's last heartbeat is older than the check threshold, expect",
          "160:     # its triggers to be taken by other healthy triggerers below",
          "161:     unhealthy_triggerer = Job(",
          "162:         heartrate=triggerer_heartrate,",
          "163:         state=State.RUNNING,",
          "164:         latest_heartbeat=time_now - datetime.timedelta(seconds=100),",
          "165:     )",
          "166:     TriggererJobRunner(unhealthy_triggerer)",
          "167:     session.add(unhealthy_triggerer)",
          "168:     # Triggerer is not healtht, its last heartbeat was too long ago",
          "169:     assert not unhealthy_triggerer.is_alive()",
          "174:     trigger_on_unhealthy_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "175:     trigger_on_unhealthy_triggerer.id = 2",
          "176:     trigger_on_unhealthy_triggerer.triggerer_id = unhealthy_triggerer.id",
          "178:     trigger_on_killed_triggerer.id = 3",
          "181:     trigger_unassigned_to_triggerer.id = 4",
          "184:     session.add(trigger_on_unhealthy_triggerer)",
          "188:     assert session.query(Trigger).count() == 4",
          "189:     Trigger.assign_unassigned(new_triggerer.id, 100, health_check_threshold=30)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "186:         session.query(Trigger).filter(Trigger.id == trigger_on_healthy_triggerer.id).one().triggerer_id",
          "187:         == healthy_triggerer.id",
          "188:     )",
          "246: def test_get_sorted_triggers(session, create_task_instance):",
          "",
          "[Removed Lines]",
          "191: @pytest.mark.parametrize(\"check_triggerer_heartrate\", [10, 60, 300])",
          "192: def test_assign_unassigned_missing_heartbeat(session, create_task_instance, check_triggerer_heartrate):",
          "193:     \"\"\"",
          "194:     Tests that the triggers assigned to a dead triggers are considered as unassigned",
          "195:     and they are  assigned to an alive triggerer.",
          "196:     \"\"\"",
          "197:     import time_machine",
          "199:     block_triggerer_heartrate = 9999",
          "200:     with time_machine.travel(datetime.datetime.utcnow(), tick=False) as t:",
          "201:         first_triggerer = Job(heartrate=block_triggerer_heartrate, state=State.RUNNING)",
          "202:         TriggererJobRunner(first_triggerer)",
          "203:         session.add(first_triggerer)",
          "204:         assert first_triggerer.is_alive()",
          "205:         second_triggerer = Job(heartrate=block_triggerer_heartrate, state=State.RUNNING)",
          "206:         TriggererJobRunner(second_triggerer)",
          "207:         session.add(second_triggerer)",
          "208:         assert second_triggerer.is_alive()",
          "209:         session.commit()",
          "210:         trigger_on_first_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "211:         trigger_on_first_triggerer.id = 1",
          "212:         trigger_on_first_triggerer.triggerer_id = first_triggerer.id",
          "213:         trigger_on_second_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "214:         trigger_on_second_triggerer.id = 2",
          "215:         trigger_on_second_triggerer.triggerer_id = second_triggerer.id",
          "216:         session.add(trigger_on_first_triggerer)",
          "217:         session.add(trigger_on_second_triggerer)",
          "218:         session.commit()",
          "219:         assert session.query(Trigger).count() == 2",
          "220:         triggers_ids = [",
          "221:             (first_triggerer.id, second_triggerer.id),",
          "222:             (first_triggerer.id, second_triggerer.id),",
          "223:             (first_triggerer.id, second_triggerer.id),",
          "224:             # Check that after more than 2.1 heartrates, the first triggerer is considered dead",
          "225:             # and the first trigger is assigned to the second triggerer",
          "226:             (second_triggerer.id, second_triggerer.id),",
          "227:         ]",
          "228:         for i in range(4):",
          "229:             Trigger.assign_unassigned(",
          "230:                 second_triggerer.id, 100, session=session, heartrate=check_triggerer_heartrate",
          "231:             )",
          "232:             session.expire_all()",
          "233:             # Check that trigger on killed triggerer and unassigned trigger are assigned to new triggerer",
          "234:             assert (",
          "235:                 session.query(Trigger).filter(Trigger.id == trigger_on_first_triggerer.id).one().triggerer_id",
          "236:                 == triggers_ids[i][0]",
          "237:             )",
          "238:             assert (",
          "239:                 session.query(Trigger).filter(Trigger.id == trigger_on_second_triggerer.id).one().triggerer_id",
          "240:                 == triggers_ids[i][1]",
          "241:             )",
          "242:             t.shift(datetime.timedelta(seconds=check_triggerer_heartrate))",
          "243:             second_triggerer.latest_heartbeat += datetime.timedelta(seconds=check_triggerer_heartrate)",
          "",
          "[Added Lines]",
          "205:     # Check that trigger on unhealthy triggerer is assigned to new triggerer",
          "206:     assert (",
          "207:         session.query(Trigger).filter(Trigger.id == trigger_on_unhealthy_triggerer.id).one().triggerer_id",
          "208:         == new_triggerer.id",
          "209:     )",
          "",
          "---------------"
        ]
      }
    }
  ]
}
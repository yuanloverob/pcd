{
  "cve_id": "CVE-2024-24825",
  "cve_desc": "DIRAC is a distributed resource framework. In affected versions any user could get a token that has been requested by another user/agent. This may expose resources to unintended parties. This issue has been addressed in release version 8.0.37. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
  "repo": "DIRACGrid/DIRAC",
  "patch_hash": "f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
  "patch_info": {
    "commit_hash": "f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
    "repo": "DIRACGrid/DIRAC",
    "commit_url": "https://github.com/DIRACGrid/DIRAC/commit/f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
    "files": [
      "src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py"
    ],
    "message": "Merge pull request from GHSA-59qj-jcjv-662j\n\n[8.0] Remove server side cache in TokenManager",
    "before_after_code_files": [
      "src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py"
    ]
  },
  "patch_diff": {
    "src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py": [
      "File: src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py -> src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: .. image:: /_static/Systems/FS/TokenManager_getToken.png",
      "17:     :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)",
      "20: This helps reduce the number of requests to both the service and the Identity Provider (IdP).",
      "22: If the client has a valid **access token** in the cache, it is used until it expires.",
      "",
      "[Removed Lines]",
      "19: The service and its client have a mechanism for caching the received tokens.",
      "",
      "[Added Lines]",
      "19: The client has a mechanism for caching the received tokens.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "24: ``client_id`` and ``client_secret`` of the Identity Provider client are registered.",
      "26: Otherwise, the client makes an RPC call to the **TornadoManager** service.",
      "30: \"\"\"",
      "32: import pprint",
      "",
      "[Removed Lines]",
      "27: It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.",
      "28: If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
      "29: is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.",
      "",
      "[Added Lines]",
      "27: The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
      "28: is taken and the **exchange token** request to Identity Provider is made.",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "42: from DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (",
      "43:     getIdProviderClient,",
      "44:     getCachedKey,",
      "46:     DEFAULT_RT_EXPIRATION_TIME,",
      "47:     DEFAULT_AT_EXPIRATION_TIME,",
      "48: )",
      "55: class TokenManagerHandler(TornadoService):",
      "56:     DEFAULT_AUTHORIZATION = [\"authenticated\"]",
      "",
      "[Removed Lines]",
      "45:     getCachedToken,",
      "51: # Used to synchronize the cache with user tokens",
      "52: gTokensSync = ThreadSafe.Synchronizer()",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "62:         :return: S_OK()/S_ERROR()",
      "63:         \"\"\"",
      "67:         # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.",
      "68:         # This allows you to manage tokens without the involvement of their owners.",
      "",
      "[Removed Lines]",
      "64:         # Cache containing tokens from scope requested by the client",
      "65:         cls.__tokensCache = DictCache()",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "181:         # Not authorized!",
      "182:         return S_ERROR(\"You can't get tokens!\")",
      "185:     def export_getToken(",
      "186:         self,",
      "187:         username: str = None,",
      "",
      "[Removed Lines]",
      "184:     @gTokensSync",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "213:             return result",
      "214:         idpObj = result[\"Value\"]",
      "223:         # A client token is requested",
      "224:         if not username:",
      "",
      "[Removed Lines]",
      "216:         # Search for an existing token in tokensCache",
      "217:         cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)",
      "218:         result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)",
      "219:         if result[\"OK\"]:",
      "220:             # A valid token has been found and is returned",
      "221:             return result",
      "",
      "[Added Lines]",
      "207:         # getCachedKey is just used here to resolve the default scopes",
      "208:         _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "227:                 return result",
      "229:             # Get the client token with requested scope and audience",
      "232:             result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)",
      "243:             return result",
      "245:         # A user token is requested",
      "",
      "[Removed Lines]",
      "230:             scope = cachedKey[1]",
      "231:             audience = cachedKey[2]",
      "233:             if not result[\"OK\"]:",
      "234:                 return result",
      "235:             token = result[\"Value\"]",
      "237:             # Caching new token: only get an access token (no refresh token in this context)",
      "238:             self.__tokensCache.add(",
      "239:                 cachedKey,",
      "240:                 result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,",
      "241:                 token,",
      "242:             )",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "262:                         # refresh token with requested scope",
      "263:                         result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)",
      "264:                         if result[\"OK\"]:",
      "271:                             return result",
      "272:                 # Did not find any token associated with the found user ID",
      "273:                 err.append(result.get(\"Message\", f\"No token found for {uid}\"))",
      "",
      "[Removed Lines]",
      "265:                             # caching new tokens",
      "266:                             self.__tokensCache.add(",
      "267:                                 cachedKey,",
      "268:                                 result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,",
      "269:                                 result[\"Value\"],",
      "270:                             )",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9487921684e2925b4cf72d6c423718cf4950f3fe",
      "candidate_info": {
        "commit_hash": "9487921684e2925b4cf72d6c423718cf4950f3fe",
        "repo": "DIRACGrid/DIRAC",
        "commit_url": "https://github.com/DIRACGrid/DIRAC/commit/9487921684e2925b4cf72d6c423718cf4950f3fe",
        "files": [
          "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py"
        ],
        "message": "Merge pull request from GHSA-59qj-jcjv-662j\n\n[integration] Remove server side cache in TokenManager",
        "before_after_code_files": [
          "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py": [
          "File: src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py -> src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: .. image:: /_static/Systems/FS/TokenManager_getToken.png",
          "17:     :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)",
          "20: This helps reduce the number of requests to both the service and the Identity Provider (IdP).",
          "22: If the client has a valid **access token** in the cache, it is used until it expires.",
          "",
          "[Removed Lines]",
          "19: The service and its client have a mechanism for caching the received tokens.",
          "",
          "[Added Lines]",
          "19: The client has a mechanism for caching the received tokens.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: ``client_id`` and ``client_secret`` of the Identity Provider client are registered.",
          "26: Otherwise, the client makes an RPC call to the **TornadoManager** service.",
          "30: \"\"\"",
          "32: import pprint",
          "",
          "[Removed Lines]",
          "27: It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.",
          "28: If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
          "29: is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.",
          "",
          "[Added Lines]",
          "27: The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
          "28: is taken and the **exchange token** request to Identity Provider is made.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "47: )",
          "48: from DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory",
          "54: class TornadoTokenManagerHandler(TornadoService):",
          "55:     DEFAULT_AUTHORIZATION = [\"authenticated\"]",
          "",
          "[Removed Lines]",
          "50: # Used to synchronize the cache with user tokens",
          "51: gTokensSync = ThreadSafe.Synchronizer()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "61:         :return: S_OK()/S_ERROR()",
          "62:         \"\"\"",
          "66:         # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.",
          "67:         # This allows you to manage tokens without the involvement of their owners.",
          "",
          "[Removed Lines]",
          "63:         # Cache containing tokens from scope requested by the client",
          "64:         cls.__tokensCache = DictCache()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "180:         # Not authorized!",
          "181:         return S_ERROR(\"You can't get tokens!\")",
          "184:     def export_getToken(",
          "185:         self,",
          "186:         username: str = None,",
          "",
          "[Removed Lines]",
          "183:     @gTokensSync",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "212:             return result",
          "213:         idpObj = result[\"Value\"]",
          "222:         # A client token is requested",
          "223:         if not username:",
          "",
          "[Removed Lines]",
          "215:         # Search for an existing token in tokensCache",
          "216:         cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)",
          "217:         result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)",
          "218:         if result[\"OK\"]:",
          "219:             # A valid token has been found and is returned",
          "220:             return result",
          "",
          "[Added Lines]",
          "208:         # getCachedKey is just used here to resolve the default scopes",
          "209:         _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "226:                 return result",
          "228:             # Get the client token with requested scope and audience",
          "231:             result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)",
          "242:             return result",
          "244:         # A user token is requested",
          "",
          "[Removed Lines]",
          "229:             scope = cachedKey[1]",
          "230:             audience = cachedKey[2]",
          "232:             if not result[\"OK\"]:",
          "233:                 return result",
          "234:             token = result[\"Value\"]",
          "236:             # Caching new token: only get an access token (no refresh token in this context)",
          "237:             self.__tokensCache.add(",
          "238:                 cachedKey,",
          "239:                 result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,",
          "240:                 token,",
          "241:             )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "261:                         # refresh token with requested scope",
          "262:                         result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)",
          "263:                         if result[\"OK\"]:",
          "270:                             return result",
          "271:                 # Did not find any token associated with the found user ID",
          "272:                 err.append(result.get(\"Message\", f\"No token found for {uid}\"))",
          "",
          "[Removed Lines]",
          "264:                             # caching new tokens",
          "265:                             self.__tokensCache.add(",
          "266:                                 cachedKey,",
          "267:                                 result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,",
          "268:                                 result[\"Value\"],",
          "269:                             )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46692f0ea77c5a3349da5b31583520d5cfdfab01",
      "candidate_info": {
        "commit_hash": "46692f0ea77c5a3349da5b31583520d5cfdfab01",
        "repo": "DIRACGrid/DIRAC",
        "commit_url": "https://github.com/DIRACGrid/DIRAC/commit/46692f0ea77c5a3349da5b31583520d5cfdfab01",
        "files": [
          "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py"
        ],
        "message": "fix (TokenManager): remove server side cache",
        "before_after_code_files": [
          "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py||src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py": [
          "File: src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py -> src/DIRAC/FrameworkSystem/Service/TornadoTokenManagerHandler.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: .. image:: /_static/Systems/FS/TokenManager_getToken.png",
          "17:     :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)",
          "20: This helps reduce the number of requests to both the service and the Identity Provider (IdP).",
          "22: If the client has a valid **access token** in the cache, it is used until it expires.",
          "",
          "[Removed Lines]",
          "19: The service and its client have a mechanism for caching the received tokens.",
          "",
          "[Added Lines]",
          "19: The client has a mechanism for caching the received tokens.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: ``client_id`` and ``client_secret`` of the Identity Provider client are registered.",
          "26: Otherwise, the client makes an RPC call to the **TornadoManager** service.",
          "30: \"\"\"",
          "32: import pprint",
          "",
          "[Removed Lines]",
          "27: It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.",
          "28: If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
          "29: is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.",
          "",
          "[Added Lines]",
          "27: The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`",
          "28: is taken and the **exchange token** request to Identity Provider is made.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "47: )",
          "48: from DIRAC.Resources.IdProvider.IdProviderFactory import IdProviderFactory",
          "54: class TornadoTokenManagerHandler(TornadoService):",
          "55:     DEFAULT_AUTHORIZATION = [\"authenticated\"]",
          "",
          "[Removed Lines]",
          "50: # Used to synchronize the cache with user tokens",
          "51: gTokensSync = ThreadSafe.Synchronizer()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "61:         :return: S_OK()/S_ERROR()",
          "62:         \"\"\"",
          "66:         # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.",
          "67:         # This allows you to manage tokens without the involvement of their owners.",
          "",
          "[Removed Lines]",
          "63:         # Cache containing tokens from scope requested by the client",
          "64:         cls.__tokensCache = DictCache()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "180:         # Not authorized!",
          "181:         return S_ERROR(\"You can't get tokens!\")",
          "184:     def export_getToken(",
          "185:         self,",
          "186:         username: str = None,",
          "",
          "[Removed Lines]",
          "183:     @gTokensSync",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "212:             return result",
          "213:         idpObj = result[\"Value\"]",
          "222:         # A client token is requested",
          "223:         if not username:",
          "",
          "[Removed Lines]",
          "215:         # Search for an existing token in tokensCache",
          "216:         cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)",
          "217:         result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)",
          "218:         if result[\"OK\"]:",
          "219:             # A valid token has been found and is returned",
          "220:             return result",
          "",
          "[Added Lines]",
          "208:         # getCachedKey is just used here to resolve the default scopes",
          "209:         _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "226:                 return result",
          "228:             # Get the client token with requested scope and audience",
          "231:             result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)",
          "242:             return result",
          "244:         # A user token is requested",
          "",
          "[Removed Lines]",
          "229:             scope = cachedKey[1]",
          "230:             audience = cachedKey[2]",
          "232:             if not result[\"OK\"]:",
          "233:                 return result",
          "234:             token = result[\"Value\"]",
          "236:             # Caching new token: only get an access token (no refresh token in this context)",
          "237:             self.__tokensCache.add(",
          "238:                 cachedKey,",
          "239:                 result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,",
          "240:                 token,",
          "241:             )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "261:                         # refresh token with requested scope",
          "262:                         result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)",
          "263:                         if result[\"OK\"]:",
          "270:                             return result",
          "271:                 # Did not find any token associated with the found user ID",
          "272:                 err.append(result.get(\"Message\", f\"No token found for {uid}\"))",
          "",
          "[Removed Lines]",
          "264:                             # caching new tokens",
          "265:                             self.__tokensCache.add(",
          "266:                                 cachedKey,",
          "267:                                 result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,",
          "268:                                 result[\"Value\"],",
          "269:                             )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
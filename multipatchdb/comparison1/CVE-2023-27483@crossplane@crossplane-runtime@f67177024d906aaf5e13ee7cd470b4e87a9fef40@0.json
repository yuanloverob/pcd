{
  "cve_id": "CVE-2023-27483",
  "cve_desc": "crossplane-runtime is a set of go libraries used to build Kubernetes controllers in Crossplane and its related stacks. An out of memory panic vulnerability has been discovered in affected versions. Applications that use the `Paved` type's `SetValue` method with user provided input without proper validation might use excessive amounts of memory and cause an out of memory panic. In the fieldpath package, the Paved.SetValue method sets a value on the Paved object according to the provided path, without any validation. This allows setting values in slices at any provided index, which grows the target array up to the requested index, the index is currently capped at max uint32 (4294967295) given how indexes are parsed,  but that is still an unnecessarily large value. If callers are not validating paths' indexes on their own, which most probably are not going to do, given that the input is parsed directly in the SetValue method, this could allow users to consume arbitrary amounts of memory. Applications that do not use the `Paved` type's `SetValue` method are not affected. This issue has been addressed in versions 0.16.1 and 0.19.2. Users are advised to upgrade. Users unable to upgrade can parse and validate the path before passing it to the `SetValue` method of the `Paved` type, constraining the index size as deemed appropriate.",
  "repo": "crossplane/crossplane-runtime",
  "patch_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
  "patch_info": {
    "commit_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "repo": "crossplane/crossplane-runtime",
    "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "files": [
      "pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go"
    ],
    "message": "Add a package for getting and setting unstructured fields by path\n\nhttps://github.com/kubernetes-sigs/kustomize/blob/d190e1/api/k8sdeps/kunstruct/helper.go\nhttps://github.com/kubernetes/apimachinery/blob/2373d0/pkg/apis/meta/v1/unstructured/helpers.go\n\nThis package is similar to the above two, with some key differences:\n\n* Our fieldpath lexer is a little stricter; it won't allow dangling open braces,\n  unexpected periods, or empty brackets. It also supplies the position of any\n  syntax error if lexing fails.\n* We support setting and getting fields within a pkg/json unmarshalled object by\n  fieldpath. Other packages support only getting fields, or only setting fields\n  in paths that do not contain any array indexes.\n\nSigned-off-by: Nic Cope <negz@rk0n.org>",
    "before_after_code_files": [
      "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
    ]
  },
  "patch_diff": {
    "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
      "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "43: package fieldpath",
      "45: import (",
      "46:  \"fmt\"",
      "47:  \"strconv\"",
      "48:  \"strings\"",
      "49:  \"unicode/utf8\"",
      "51:  \"github.com/pkg/errors\"",
      "52: )",
      "56: type SegmentType int",
      "59: const (",
      "60:  _ SegmentType = iota",
      "61:  SegmentField",
      "62:  SegmentIndex",
      "63: )",
      "66: type Segment struct {",
      "67:  Type  SegmentType",
      "68:  Field string",
      "69:  Index uint",
      "70: }",
      "73: type Segments []Segment",
      "75: func (sg Segments) String() string {",
      "76:  var b strings.Builder",
      "78:  for _, s := range sg {",
      "79:   switch s.Type {",
      "80:   case SegmentField:",
      "81:    if strings.ContainsRune(s.Field, period) {",
      "82:     b.WriteString(fmt.Sprintf(\"[%s]\", s.Field))",
      "83:     continue",
      "84:    }",
      "85:    b.WriteString(fmt.Sprintf(\".%s\", s.Field))",
      "86:   case SegmentIndex:",
      "87:    b.WriteString(fmt.Sprintf(\"[%d]\", s.Index))",
      "88:   }",
      "89:  }",
      "91:  return strings.TrimPrefix(b.String(), \".\")",
      "92: }",
      "98: func FieldOrIndex(s string) Segment {",
      "102:  if i, err := strconv.ParseUint(s, 10, 32); err == nil {",
      "103:   return Segment{Type: SegmentIndex, Index: uint(i)}",
      "104:  }",
      "108:  return Field(s)",
      "109: }",
      "113: func Field(s string) Segment {",
      "114:  return Segment{Type: SegmentField, Field: strings.Trim(s, \"'\\\"\")}",
      "115: }",
      "118: func Parse(path string) (Segments, error) {",
      "119:  l := &lexer{input: path, items: make(chan item)}",
      "120:  go l.run()",
      "122:  segments := make(Segments, 0, 1)",
      "123:  for i := range l.items {",
      "124:   switch i.typ {",
      "125:   case itemField:",
      "126:    segments = append(segments, Field(i.val))",
      "127:   case itemFieldOrIndex:",
      "128:    segments = append(segments, FieldOrIndex(i.val))",
      "129:   case itemError:",
      "130:    return nil, errors.Errorf(\"%s at position %d\", i.val, i.pos)",
      "131:   }",
      "132:  }",
      "133:  return segments, nil",
      "134: }",
      "136: const (",
      "137:  period       = '.'",
      "138:  leftBracket  = '['",
      "139:  rightBracket = ']'",
      "140: )",
      "142: type itemType int",
      "144: const (",
      "145:  itemError itemType = iota",
      "146:  itemPeriod",
      "147:  itemLeftBracket",
      "148:  itemRightBracket",
      "149:  itemField",
      "150:  itemFieldOrIndex",
      "151:  itemEOL",
      "152: )",
      "154: type item struct {",
      "155:  typ itemType",
      "156:  pos int",
      "157:  val string",
      "158: }",
      "160: type stateFn func(*lexer) stateFn",
      "164: type lexer struct {",
      "165:  input string",
      "166:  pos   int",
      "167:  start int",
      "168:  items chan item",
      "169: }",
      "171: func (l *lexer) run() {",
      "172:  for state := lexField; state != nil; {",
      "173:   state = state(l)",
      "174:  }",
      "175:  close(l.items)",
      "176: }",
      "178: func (l *lexer) emit(t itemType) {",
      "180:  if l.pos <= l.start {",
      "181:   return",
      "182:  }",
      "183:  l.items <- item{typ: t, pos: l.start, val: l.input[l.start:l.pos]}",
      "184:  l.start = l.pos",
      "185: }",
      "187: func (l *lexer) errorf(pos int, format string, args ...interface{}) stateFn {",
      "188:  l.items <- item{typ: itemError, pos: pos, val: fmt.Sprintf(format, args...)}",
      "189:  return nil",
      "190: }",
      "192: func lexField(l *lexer) stateFn {",
      "193:  for i, r := range l.input[l.pos:] {",
      "194:   switch r {",
      "196:   case rightBracket:",
      "197:    return l.errorf(l.pos+i, \"unexpected %q\", rightBracket)",
      "200:   case leftBracket:",
      "201:    l.pos += i",
      "202:    l.emit(itemField)",
      "203:    return lexLeftBracket",
      "206:   case period:",
      "207:    l.pos += i",
      "208:    l.emit(itemField)",
      "209:    return lexPeriod",
      "210:   }",
      "211:  }",
      "214:  l.pos = len(l.input)",
      "215:  l.emit(itemField)",
      "216:  l.emit(itemEOL)",
      "217:  return nil",
      "218: }",
      "220: func lexPeriod(l *lexer) stateFn {",
      "222:  if l.pos == 0 || l.pos == len(l.input)-1 {",
      "223:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "224:  }",
      "226:  l.pos += utf8.RuneLen(period)",
      "227:  l.emit(itemPeriod)",
      "231:  r, _ := utf8.DecodeRuneInString(l.input[l.pos:])",
      "232:  if r == period {",
      "233:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "234:  }",
      "235:  if r == leftBracket {",
      "236:   return l.errorf(l.pos, \"unexpected %q\", leftBracket)",
      "237:  }",
      "239:  return lexField",
      "240: }",
      "242: func lexLeftBracket(l *lexer) stateFn {",
      "244:  if !strings.ContainsRune(l.input[l.pos:], rightBracket) {",
      "245:   return l.errorf(l.pos, \"unterminated %q\", leftBracket)",
      "246:  }",
      "248:  l.pos += utf8.RuneLen(leftBracket)",
      "249:  l.emit(itemLeftBracket)",
      "250:  return lexFieldOrIndex",
      "251: }",
      "255: func lexFieldOrIndex(l *lexer) stateFn {",
      "258:  rbi := strings.IndexRune(l.input[l.pos:], rightBracket)",
      "261:  if rbi == 0 {",
      "262:   return l.errorf(l.pos, \"unexpected %q\", rightBracket)",
      "263:  }",
      "266:  if lbi := strings.IndexRune(l.input[l.pos:l.pos+rbi], leftBracket); lbi > -1 {",
      "267:   return l.errorf(l.pos+lbi, \"unexpected %q\", leftBracket)",
      "268:  }",
      "271:  l.pos += rbi",
      "272:  l.emit(itemFieldOrIndex)",
      "273:  return lexRightBracket",
      "274: }",
      "276: func lexRightBracket(l *lexer) stateFn {",
      "277:  l.pos += utf8.RuneLen(rightBracket)",
      "278:  l.emit(itemRightBracket)",
      "279:  return lexField",
      "280: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go": [
      "File: pkg/fieldpath/fieldpath_test.go -> pkg/fieldpath/fieldpath_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"math\"",
      "21:  \"strconv\"",
      "22:  \"testing\"",
      "24:  \"github.com/google/go-cmp/cmp\"",
      "25:  \"github.com/pkg/errors\"",
      "27:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "28: )",
      "30: func TestSegments(t *testing.T) {",
      "31:  cases := map[string]struct {",
      "32:   s    Segments",
      "33:   want string",
      "34:  }{",
      "35:   \"SingleField\": {",
      "36:    s:    Segments{Field(\"spec\")},",
      "37:    want: \"spec\",",
      "38:   },",
      "39:   \"SingleIndex\": {",
      "40:    s:    Segments{FieldOrIndex(\"0\")},",
      "41:    want: \"[0]\",",
      "42:   },",
      "43:   \"FieldsAndIndex\": {",
      "44:    s: Segments{",
      "45:     Field(\"spec\"),",
      "46:     Field(\"containers\"),",
      "47:     FieldOrIndex(\"0\"),",
      "48:     Field(\"name\"),",
      "49:    },",
      "50:    want: \"spec.containers[0].name\",",
      "51:   },",
      "52:   \"PeriodsInField\": {",
      "53:    s: Segments{",
      "54:     Field(\"data\"),",
      "55:     Field(\".config.yml\"),",
      "56:    },",
      "57:    want: \"data[.config.yml]\",",
      "58:   },",
      "59:  }",
      "61:  for name, tc := range cases {",
      "62:   t.Run(name, func(t *testing.T) {",
      "63:    if diff := cmp.Diff(tc.want, tc.s.String()); diff != \"\" {",
      "64:     t.Errorf(\"s.String(): -want, +got:\\n %s\", diff)",
      "65:    }",
      "67:   })",
      "68:  }",
      "69: }",
      "71: func TestFieldOrIndex(t *testing.T) {",
      "72:  cases := map[string]struct {",
      "73:   reason string",
      "74:   s      string",
      "75:   want   Segment",
      "76:  }{",
      "77:   \"Field\": {",
      "78:    reason: \"An unambiguous string should be interpreted as a field segment\",",
      "79:    s:      \"coolField\",",
      "80:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "81:   },",
      "82:   \"QuotedField\": {",
      "83:    reason: \"A quoted string should be interpreted as a field segment with the quotes removed\",",
      "84:    s:      \"'coolField'\",",
      "85:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "86:   },",
      "87:   \"Index\": {",
      "88:    reason: \"An unambiguous integer should be interpreted as an index segment\",",
      "89:    s:      \"3\",",
      "90:    want:   Segment{Type: SegmentIndex, Index: 3},",
      "91:   },",
      "92:   \"Negative\": {",
      "93:    reason: \"A negative integer should be interpreted as an field segment\",",
      "94:    s:      \"-3\",",
      "95:    want:   Segment{Type: SegmentField, Field: \"-3\"},",
      "96:   },",
      "97:   \"Float\": {",
      "98:    reason: \"A float should be interpreted as an field segment\",",
      "99:    s:      \"3.0\",",
      "100:    want:   Segment{Type: SegmentField, Field: \"3.0\"},",
      "101:   },",
      "102:   \"Overflow\": {",
      "103:    reason: \"A very big integer will be interpreted as a field segment\",",
      "104:    s:      strconv.Itoa(math.MaxUint32 + 1),",
      "105:    want:   Segment{Type: SegmentField, Field: strconv.Itoa(math.MaxUint32 + 1)},",
      "106:   },",
      "107:  }",
      "108:  for name, tc := range cases {",
      "109:   t.Run(name, func(t *testing.T) {",
      "110:    got := FieldOrIndex(tc.s)",
      "111:    if diff := cmp.Diff(tc.want, got); diff != \"\" {",
      "112:     t.Errorf(\"\\nFieldOrIndex(...): %s: -want, +got:\\n%s\", tc.reason, diff)",
      "113:    }",
      "114:   })",
      "115:  }",
      "116: }",
      "118: func TestParse(t *testing.T) {",
      "119:  type want struct {",
      "120:   s   Segments",
      "121:   err error",
      "122:  }",
      "124:  cases := map[string]struct {",
      "125:   reason string",
      "126:   path   string",
      "127:   want   want",
      "128:  }{",
      "129:   \"SingleField\": {",
      "130:    reason: \"A path with no brackets or periods should be interpreted as a single field segment\",",
      "131:    path:   \"spec\",",
      "132:    want: want{",
      "133:     s: Segments{Field(\"spec\")},",
      "134:    },",
      "135:   },",
      "136:   \"SingleIndex\": {",
      "137:    reason: \"An integer surrounded by brackets should be interpreted as an index\",",
      "138:    path:   \"[0]\",",
      "139:    want: want{",
      "140:     s: Segments{FieldOrIndex(\"0\")},",
      "141:    },",
      "142:   },",
      "143:   \"TwoFields\": {",
      "144:    reason: \"A path with one period should be interpreted as two field segments\",",
      "145:    path:   \"metadata.name\",",
      "146:    want: want{",
      "147:     s: Segments{Field(\"metadata\"), Field(\"name\")},",
      "148:    },",
      "149:   },",
      "150:   \"APIConventionsExample\": {",
      "151:    reason: \"The example given by the Kubernetes API convention should be parse correctly\",",
      "152:    path:   \"fields[1].state.current\",",
      "153:    want: want{",
      "154:     s: Segments{",
      "155:      Field(\"fields\"),",
      "156:      FieldOrIndex(\"1\"),",
      "157:      Field(\"state\"),",
      "158:      Field(\"current\"),",
      "159:     },",
      "160:    },",
      "161:   },",
      "162:   \"SimpleIndex\": {",
      "163:    reason: \"Indexing an object field that is an array should result in a field and an index\",",
      "164:    path:   \"items[0]\",",
      "165:    want: want{",
      "166:     s: Segments{Field(\"items\"), FieldOrIndex(\"0\")},",
      "167:    },",
      "168:   },",
      "169:   \"FieldsAndIndex\": {",
      "170:    reason: \"A path with periods and braces should be interpreted as fields and indices\",",
      "171:    path:   \"spec.containers[0].name\",",
      "172:    want: want{",
      "173:     s: Segments{",
      "174:      Field(\"spec\"),",
      "175:      Field(\"containers\"),",
      "176:      FieldOrIndex(\"0\"),",
      "177:      Field(\"name\"),",
      "178:     },",
      "179:    },",
      "180:   },",
      "181:   \"NestedArray\": {",
      "182:    reason: \"A nested array should result in two consecutive index fields\",",
      "183:    path:   \"nested[0][1].name\",",
      "184:    want: want{",
      "185:     s: Segments{",
      "186:      Field(\"nested\"),",
      "187:      FieldOrIndex(\"0\"),",
      "188:      FieldOrIndex(\"1\"),",
      "189:      Field(\"name\"),",
      "190:     },",
      "191:    },",
      "192:   },",
      "193:   \"BracketStyleField\": {",
      "194:    reason: \"A field name can be specified using brackets rather than a period\",",
      "195:    path:   \"spec[containers][0].name\",",
      "196:    want: want{",
      "197:     s: Segments{",
      "198:      Field(\"spec\"),",
      "199:      Field(\"containers\"),",
      "200:      FieldOrIndex(\"0\"),",
      "201:      Field(\"name\"),",
      "202:     },",
      "203:    },",
      "204:   },",
      "205:   \"BracketFieldWithPeriod\": {",
      "206:    reason: \"A field name specified using brackets can include a period\",",
      "207:    path:   \"data[.config.yml]\",",
      "208:    want: want{",
      "209:     s: Segments{",
      "210:      Field(\"data\"),",
      "211:      FieldOrIndex(\".config.yml\"),",
      "212:     },",
      "213:    },",
      "214:   },",
      "215:   \"LeadingPeriod\": {",
      "216:    reason: \"A path may not start with a period (unlike a JSON path)\",",
      "217:    path:   \".metadata.name\",",
      "218:    want: want{",
      "219:     err: errors.New(\"unexpected '.' at position 0\"),",
      "220:    },",
      "221:   },",
      "222:   \"TrailingPeriod\": {",
      "223:    reason: \"A path may not end with a period\",",
      "224:    path:   \"metadata.name.\",",
      "225:    want: want{",
      "226:     err: errors.New(\"unexpected '.' at position 13\"),",
      "227:    },",
      "228:   },",
      "229:   \"BracketsFollowingPeriod\": {",
      "230:    reason: \"Brackets may not follow a period\",",
      "231:    path:   \"spec.containers.[0].name\",",
      "232:    want: want{",
      "233:     err: errors.New(\"unexpected '[' at position 16\"),",
      "234:    },",
      "235:   },",
      "236:   \"DoublePeriod\": {",
      "237:    reason: \"A path may not include two consecutive periods\",",
      "238:    path:   \"metadata..name\",",
      "239:    want: want{",
      "240:     err: errors.New(\"unexpected '.' at position 9\"),",
      "241:    },",
      "242:   },",
      "243:   \"DanglingRightBracket\": {",
      "244:    reason: \"A right bracket may not appear in a field name\",",
      "245:    path:   \"metadata.]name\",",
      "246:    want: want{",
      "247:     err: errors.New(\"unexpected ']' at position 9\"),",
      "248:    },",
      "249:   },",
      "250:   \"DoubleOpenBracket\": {",
      "251:    reason: \"Brackets may not be nested\",",
      "252:    path:   \"spec[bracketed[name]]\",",
      "253:    want: want{",
      "254:     err: errors.New(\"unexpected '[' at position 14\"),",
      "255:    },",
      "256:   },",
      "257:   \"DanglingLeftBracket\": {",
      "258:    reason: \"A left bracket must be closed\",",
      "259:    path:   \"spec[name\",",
      "260:    want: want{",
      "261:     err: errors.New(\"unterminated '[' at position 4\"),",
      "262:    },",
      "263:   },",
      "264:   \"EmptyBracket\": {",
      "265:    reason: \"Brackets may not be empty\",",
      "266:    path:   \"spec[]\",",
      "267:    want: want{",
      "268:     err: errors.New(\"unexpected ']' at position 5\"),",
      "269:    },",
      "270:   },",
      "271:  }",
      "272:  for name, tc := range cases {",
      "273:   t.Run(name, func(t *testing.T) {",
      "274:    got, err := Parse(tc.path)",
      "275:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "276:     t.Fatalf(\"\\nParse(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "277:    }",
      "278:    if diff := cmp.Diff(tc.want.s, got); diff != \"\" {",
      "279:     t.Errorf(\"\\nParse(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "280:    }",
      "281:   })",
      "282:  }",
      "283: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
      "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "22:  \"github.com/pkg/errors\"",
      "23: )",
      "26: type Paved struct {",
      "27:  object map[string]interface{}",
      "28: }",
      "31: func Pave(object map[string]interface{}) *Paved {",
      "32:  return &Paved{object: object}",
      "33: }",
      "36: func (p Paved) MarshalJSON() ([]byte, error) {",
      "37:  return json.Marshal(p.object)",
      "38: }",
      "41: func (p *Paved) UnmarshalJSON(data []byte) error {",
      "42:  return json.Unmarshal(data, &p.object)",
      "43: }",
      "45: func (p *Paved) getValue(s Segments) (interface{}, error) {",
      "46:  var it interface{} = p.object",
      "47:  for i, current := range s {",
      "48:   final := i == len(s)-1",
      "49:   switch current.Type {",
      "50:   case SegmentIndex:",
      "51:    array, ok := it.([]interface{})",
      "52:    if !ok {",
      "53:     return nil, errors.Errorf(\"%s: not an array\", s[:i])",
      "54:    }",
      "55:    if int(current.Index) >= len(array) {",
      "56:     return nil, errors.Errorf(\"%s: no such element\", s[:i+1])",
      "57:    }",
      "58:    if final {",
      "59:     return array[current.Index], nil",
      "60:    }",
      "61:    it = array[current.Index]",
      "63:   case SegmentField:",
      "64:    object, ok := it.(map[string]interface{})",
      "65:    if !ok {",
      "66:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
      "67:    }",
      "68:    v, ok := object[current.Field]",
      "69:    if !ok {",
      "70:     return nil, errors.Errorf(\"%s: no such field\", s[:i+1])",
      "71:    }",
      "72:    if final {",
      "73:     return v, nil",
      "74:    }",
      "75:    it = object[current.Field]",
      "76:   }",
      "77:  }",
      "80:  return nil, nil",
      "81: }",
      "84: func (p *Paved) GetValue(path string) (interface{}, error) {",
      "85:  segments, err := Parse(path)",
      "86:  if err != nil {",
      "87:   return nil, errors.Wrapf(err, \"cannot parse path %q\", path)",
      "88:  }",
      "90:  return p.getValue(segments)",
      "91: }",
      "94: func (p *Paved) GetString(path string) (string, error) {",
      "95:  v, err := p.GetValue(path)",
      "96:  if err != nil {",
      "97:   return \"\", err",
      "98:  }",
      "100:  s, ok := v.(string)",
      "101:  if !ok {",
      "102:   return \"\", errors.Errorf(\"%s: not a string\", path)",
      "103:  }",
      "104:  return s, nil",
      "105: }",
      "108: func (p *Paved) GetStringArray(path string) ([]string, error) {",
      "109:  v, err := p.GetValue(path)",
      "110:  if err != nil {",
      "111:   return nil, err",
      "112:  }",
      "114:  a, ok := v.([]interface{})",
      "115:  if !ok {",
      "116:   return nil, errors.Errorf(\"%s: not an array\", path)",
      "117:  }",
      "119:  sa := make([]string, len(a))",
      "120:  for i := range a {",
      "121:   s, ok := a[i].(string)",
      "122:   if !ok {",
      "123:    return nil, errors.Errorf(\"%s: not an array of strings\", path)",
      "124:   }",
      "125:   sa[i] = s",
      "126:  }",
      "128:  return sa, nil",
      "129: }",
      "132: func (p *Paved) GetStringObject(path string) (map[string]string, error) {",
      "133:  v, err := p.GetValue(path)",
      "134:  if err != nil {",
      "135:   return nil, err",
      "136:  }",
      "138:  o, ok := v.(map[string]interface{})",
      "139:  if !ok {",
      "140:   return nil, errors.Errorf(\"%s: not an object\", path)",
      "141:  }",
      "143:  so := make(map[string]string)",
      "144:  for k, in := range o {",
      "145:   s, ok := in.(string)",
      "146:   if !ok {",
      "147:    return nil, errors.Errorf(\"%s: not an object with string field values\", path)",
      "148:   }",
      "149:   so[k] = s",
      "151:  }",
      "153:  return so, nil",
      "154: }",
      "157: func (p *Paved) GetBool(path string) (bool, error) {",
      "158:  v, err := p.GetValue(path)",
      "159:  if err != nil {",
      "160:   return false, err",
      "161:  }",
      "163:  b, ok := v.(bool)",
      "164:  if !ok {",
      "165:   return false, errors.Errorf(\"%s: not a bool\", path)",
      "166:  }",
      "167:  return b, nil",
      "168: }",
      "171: func (p *Paved) GetNumber(path string) (float64, error) {",
      "172:  v, err := p.GetValue(path)",
      "173:  if err != nil {",
      "174:   return 0, err",
      "175:  }",
      "177:  f, ok := v.(float64)",
      "178:  if !ok {",
      "179:   return 0, errors.Errorf(\"%s: not a (float64) number\", path)",
      "180:  }",
      "181:  return f, nil",
      "182: }",
      "184: func (p *Paved) setValue(s Segments, value interface{}) error {",
      "185:  var in interface{} = p.object",
      "186:  for i, current := range s {",
      "187:   final := i == len(s)-1",
      "189:   switch current.Type {",
      "190:   case SegmentIndex:",
      "191:    array, ok := in.([]interface{})",
      "192:    if !ok {",
      "193:     return errors.Errorf(\"%s is not an array\", s[:i])",
      "194:    }",
      "196:    if final {",
      "197:     array[current.Index] = value",
      "198:     return nil",
      "199:    }",
      "201:    prepareElement(array, current, s[i+1])",
      "202:    in = array[current.Index]",
      "204:   case SegmentField:",
      "205:    object, ok := in.(map[string]interface{})",
      "206:    if !ok {",
      "207:     return errors.Errorf(\"%s is not an object\", s[:i])",
      "208:    }",
      "210:    if final {",
      "211:     object[current.Field] = value",
      "212:     return nil",
      "213:    }",
      "215:    prepareField(object, current, s[i+1])",
      "216:    in = object[current.Field]",
      "217:   }",
      "218:  }",
      "220:  return nil",
      "221: }",
      "223: func prepareElement(array []interface{}, current, next Segment) {",
      "226:  if array[current.Index] == nil {",
      "227:   switch next.Type {",
      "228:   case SegmentIndex:",
      "229:    array[current.Index] = make([]interface{}, next.Index+1)",
      "230:   case SegmentField:",
      "231:    array[current.Index] = make(map[string]interface{})",
      "232:   }",
      "233:   return",
      "234:  }",
      "238:  if next.Type != SegmentIndex {",
      "239:   return",
      "240:  }",
      "242:  na, ok := array[current.Index].([]interface{})",
      "243:  if !ok {",
      "244:   return",
      "245:  }",
      "247:  if int(next.Index) < len(na) {",
      "248:   return",
      "249:  }",
      "251:  array[current.Index] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "252: }",
      "254: func prepareField(object map[string]interface{}, current, next Segment) {",
      "257:  if _, ok := object[current.Field]; !ok {",
      "258:   switch next.Type {",
      "259:   case SegmentIndex:",
      "260:    object[current.Field] = make([]interface{}, next.Index+1)",
      "261:   case SegmentField:",
      "262:    object[current.Field] = make(map[string]interface{})",
      "263:   }",
      "264:   return",
      "265:  }",
      "269:  if next.Type != SegmentIndex {",
      "270:   return",
      "271:  }",
      "273:  na, ok := object[current.Field].([]interface{})",
      "274:  if !ok {",
      "275:   return",
      "276:  }",
      "278:  if int(next.Index) < len(na) {",
      "279:   return",
      "280:  }",
      "282:  object[current.Field] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "283: }",
      "286: func (p *Paved) SetValue(path string, value interface{}) error {",
      "287:  segments, err := Parse(path)",
      "288:  if err != nil {",
      "289:   return errors.Wrapf(err, \"cannot parse path %q\", path)",
      "290:  }",
      "291:  return p.setValue(segments, value)",
      "292: }",
      "295: func (p *Paved) SetString(path, value string) error {",
      "296:  return p.SetValue(path, value)",
      "297: }",
      "300: func (p *Paved) SetBool(path string, value bool) error {",
      "301:  return p.SetValue(path, value)",
      "302: }",
      "305: func (p *Paved) SetNumber(path string, value float64) error {",
      "306:  return p.SetValue(path, value)",
      "307: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
      "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "21:  \"testing\"",
      "23:  \"github.com/google/go-cmp/cmp\"",
      "24:  \"github.com/pkg/errors\"",
      "26:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "27: )",
      "29: func TestGetValue(t *testing.T) {",
      "30:  type want struct {",
      "31:   value interface{}",
      "32:   err   error",
      "33:  }",
      "34:  cases := map[string]struct {",
      "35:   reason string",
      "36:   path   string",
      "37:   data   []byte",
      "38:   want   want",
      "39:  }{",
      "40:   \"MetadataName\": {",
      "41:    reason: \"It should be possible to get a field from a nested object\",",
      "42:    path:   \"metadata.name\",",
      "43:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "44:    want: want{",
      "45:     value: \"cool\",",
      "46:    },",
      "47:   },",
      "48:   \"ContainerName\": {",
      "49:    reason: \"It should be possible to get a field from an object array element\",",
      "50:    path:   \"spec.containers[0].name\",",
      "51:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "52:    want: want{",
      "53:     value: \"cool\",",
      "54:    },",
      "55:   },",
      "56:   \"NestedArray\": {",
      "57:    reason: \"It should be possible to get a field from a nested array\",",
      "58:    path:   \"items[0][1]\",",
      "59:    data:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),",
      "60:    want: want{",
      "61:     value: \"b\",",
      "62:    },",
      "63:   },",
      "64:   \"OwnerRefController\": {",
      "65:    reason: \"Requesting a boolean field path should work.\",",
      "66:    path:   \"metadata.ownerRefs[0].controller\",",
      "67:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "68:    want: want{",
      "69:     value: true,",
      "70:    },",
      "71:   },",
      "72:   \"MetadataVersion\": {",
      "73:    reason: \"Requesting a number field should work\",",
      "74:    path:   \"metadata.version\",",
      "75:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "76:    want: want{",
      "77:     value: float64(2),",
      "78:    },",
      "79:   },",
      "80:   \"MetadataNope\": {",
      "81:    reason: \"Requesting a non-existent object field should fail\",",
      "82:    path:   \"metadata.name\",",
      "83:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "84:    want: want{",
      "85:     err: errors.New(\"metadata.name: no such field\"),",
      "86:    },",
      "87:   },",
      "88:   \"InsufficientContainers\": {",
      "89:    reason: \"Requesting a non-existent array element should fail\",",
      "90:    path:   \"spec.containers[1].name\",",
      "91:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "92:    want: want{",
      "93:     err: errors.New(\"spec.containers[1]: no such element\"),",
      "94:    },",
      "95:   },",
      "96:   \"NotAnArray\": {",
      "97:    reason: \"Indexing an object should fail\",",
      "98:    path:   \"metadata[1]\",",
      "99:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "100:    want: want{",
      "101:     err: errors.New(\"metadata: not an array\"),",
      "102:    },",
      "103:   },",
      "104:   \"NotAnObject\": {",
      "105:    reason: \"Requesting a field in an array should fail\",",
      "106:    path:   \"spec.containers[nope].name\",",
      "107:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "108:    want: want{",
      "109:     err: errors.New(\"spec.containers: not an object\"),",
      "110:    },",
      "111:   },",
      "112:   \"MalformedPath\": {",
      "113:    reason: \"Requesting an invalid field path should fail\",",
      "114:    path:   \"spec[]\",",
      "115:    want: want{",
      "116:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "117:    },",
      "118:   },",
      "119:  }",
      "121:  for name, tc := range cases {",
      "122:   t.Run(name, func(t *testing.T) {",
      "123:    in := make(map[string]interface{})",
      "124:    _ = json.Unmarshal(tc.data, &in)",
      "125:    p := Pave(in)",
      "127:    got, err := p.GetValue(tc.path)",
      "128:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "129:     t.Fatalf(\"\\np.GetValue(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "130:    }",
      "131:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "132:     t.Errorf(\"\\np.GetValue(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "133:    }",
      "134:   })",
      "135:  }",
      "136: }",
      "138: func TestGetString(t *testing.T) {",
      "139:  type want struct {",
      "140:   value string",
      "141:   err   error",
      "142:  }",
      "143:  cases := map[string]struct {",
      "144:   reason string",
      "145:   path   string",
      "146:   data   []byte",
      "147:   want   want",
      "148:  }{",
      "149:   \"MetadataName\": {",
      "150:    reason: \"It should be possible to get a field from a nested object\",",
      "151:    path:   \"metadata.name\",",
      "152:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "153:    want: want{",
      "154:     value: \"cool\",",
      "155:    },",
      "156:   },",
      "157:   \"MalformedPath\": {",
      "158:    reason: \"Requesting an invalid field path should fail\",",
      "159:    path:   \"spec[]\",",
      "160:    want: want{",
      "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "162:    },",
      "163:   },",
      "164:   \"NotAString\": {",
      "165:    reason: \"Requesting an non-string field path should fail\",",
      "166:    path:   \"metadata.version\",",
      "167:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "168:    want: want{",
      "169:     err: errors.New(\"metadata.version: not a string\"),",
      "170:    },",
      "171:   },",
      "172:  }",
      "174:  for name, tc := range cases {",
      "175:   t.Run(name, func(t *testing.T) {",
      "176:    in := make(map[string]interface{})",
      "177:    _ = json.Unmarshal(tc.data, &in)",
      "178:    p := Pave(in)",
      "180:    got, err := p.GetString(tc.path)",
      "181:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "182:     t.Fatalf(\"\\np.GetString(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "183:    }",
      "184:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "185:     t.Errorf(\"\\np.GetString(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "186:    }",
      "187:   })",
      "188:  }",
      "189: }",
      "191: func TestGetStringArray(t *testing.T) {",
      "192:  type want struct {",
      "193:   value []string",
      "194:   err   error",
      "195:  }",
      "196:  cases := map[string]struct {",
      "197:   reason string",
      "198:   path   string",
      "199:   data   []byte",
      "200:   want   want",
      "201:  }{",
      "202:   \"MetadataLabels\": {",
      "203:    reason: \"It should be possible to get a field from a nested object\",",
      "204:    path:   \"spec.containers[0].command\",",
      "205:    data:   []byte(`{\"spec\": {\"containers\": [{\"command\": [\"/bin/bash\"]}]}}`),",
      "206:    want: want{",
      "207:     value: []string{\"/bin/bash\"},",
      "208:    },",
      "209:   },",
      "210:   \"MalformedPath\": {",
      "211:    reason: \"Requesting an invalid field path should fail\",",
      "212:    path:   \"spec[]\",",
      "213:    want: want{",
      "214:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "215:    },",
      "216:   },",
      "217:   \"NotAnArray\": {",
      "218:    reason: \"Requesting an non-object field path should fail\",",
      "219:    path:   \"metadata.version\",",
      "220:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "221:    want: want{",
      "222:     err: errors.New(\"metadata.version: not an array\"),",
      "223:    },",
      "224:   },",
      "225:   \"NotAStringArray\": {",
      "226:    reason: \"Requesting an non-string-object field path should fail\",",
      "227:    path:   \"metadata.versions\",",
      "228:    data:   []byte(`{\"metadata\":{\"versions\":[1,2]}}`),",
      "229:    want: want{",
      "230:     err: errors.New(\"metadata.versions: not an array of strings\"),",
      "231:    },",
      "232:   },",
      "233:  }",
      "235:  for name, tc := range cases {",
      "236:   t.Run(name, func(t *testing.T) {",
      "237:    in := make(map[string]interface{})",
      "238:    _ = json.Unmarshal(tc.data, &in)",
      "239:    p := Pave(in)",
      "241:    got, err := p.GetStringArray(tc.path)",
      "242:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "243:     t.Fatalf(\"\\np.GetStringArray(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "244:    }",
      "245:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "246:     t.Errorf(\"\\np.GetStringArray(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "247:    }",
      "248:   })",
      "249:  }",
      "250: }",
      "252: func TestGetStringObject(t *testing.T) {",
      "253:  type want struct {",
      "254:   value map[string]string",
      "255:   err   error",
      "256:  }",
      "257:  cases := map[string]struct {",
      "258:   reason string",
      "259:   path   string",
      "260:   data   []byte",
      "261:   want   want",
      "262:  }{",
      "263:   \"MetadataLabels\": {",
      "264:    reason: \"It should be possible to get a field from a nested object\",",
      "265:    path:   \"metadata.labels\",",
      "266:    data:   []byte(`{\"metadata\":{\"labels\":{\"cool\":\"true\"}}}`),",
      "267:    want: want{",
      "268:     value: map[string]string{\"cool\": \"true\"},",
      "269:    },",
      "270:   },",
      "271:   \"MalformedPath\": {",
      "272:    reason: \"Requesting an invalid field path should fail\",",
      "273:    path:   \"spec[]\",",
      "274:    want: want{",
      "275:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "276:    },",
      "277:   },",
      "278:   \"NotAnObject\": {",
      "279:    reason: \"Requesting an non-object field path should fail\",",
      "280:    path:   \"metadata.version\",",
      "281:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "282:    want: want{",
      "283:     err: errors.New(\"metadata.version: not an object\"),",
      "284:    },",
      "285:   },",
      "286:   \"NotAStringObject\": {",
      "287:    reason: \"Requesting an non-string-object field path should fail\",",
      "288:    path:   \"metadata.versions\",",
      "289:    data:   []byte(`{\"metadata\":{\"versions\":{\"a\": 2}}}`),",
      "290:    want: want{",
      "291:     err: errors.New(\"metadata.versions: not an object with string field values\"),",
      "292:    },",
      "293:   },",
      "294:  }",
      "296:  for name, tc := range cases {",
      "297:   t.Run(name, func(t *testing.T) {",
      "298:    in := make(map[string]interface{})",
      "299:    _ = json.Unmarshal(tc.data, &in)",
      "300:    p := Pave(in)",
      "302:    got, err := p.GetStringObject(tc.path)",
      "303:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "304:     t.Fatalf(\"\\np.GetStringObject(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "305:    }",
      "306:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "307:     t.Errorf(\"\\np.GetStringObject(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "308:    }",
      "309:   })",
      "310:  }",
      "311: }",
      "313: func TestGetBool(t *testing.T) {",
      "314:  type want struct {",
      "315:   value bool",
      "316:   err   error",
      "317:  }",
      "318:  cases := map[string]struct {",
      "319:   reason string",
      "320:   path   string",
      "321:   data   []byte",
      "322:   want   want",
      "323:  }{",
      "324:   \"OwnerRefController\": {",
      "325:    reason: \"Requesting a boolean field path should work.\",",
      "326:    path:   \"metadata.ownerRefs[0].controller\",",
      "327:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "328:    want: want{",
      "329:     value: true,",
      "330:    },",
      "331:   },",
      "332:   \"MalformedPath\": {",
      "333:    reason: \"Requesting an invalid field path should fail\",",
      "334:    path:   \"spec[]\",",
      "335:    want: want{",
      "336:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "337:    },",
      "338:   },",
      "339:   \"NotABool\": {",
      "340:    reason: \"Requesting an non-boolean field path should fail\",",
      "341:    path:   \"metadata.name\",",
      "342:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "343:    want: want{",
      "344:     err: errors.New(\"metadata.name: not a bool\"),",
      "345:    },",
      "346:   },",
      "347:  }",
      "349:  for name, tc := range cases {",
      "350:   t.Run(name, func(t *testing.T) {",
      "351:    in := make(map[string]interface{})",
      "352:    _ = json.Unmarshal(tc.data, &in)",
      "353:    p := Pave(in)",
      "355:    got, err := p.GetBool(tc.path)",
      "356:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "357:     t.Fatalf(\"\\np.GetBool(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "358:    }",
      "359:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "360:     t.Errorf(\"\\np.GetBool(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "361:    }",
      "362:   })",
      "363:  }",
      "364: }",
      "366: func TestGetNumber(t *testing.T) {",
      "367:  type want struct {",
      "368:   value float64",
      "369:   err   error",
      "370:  }",
      "371:  cases := map[string]struct {",
      "372:   reason string",
      "373:   path   string",
      "374:   data   []byte",
      "375:   want   want",
      "376:  }{",
      "377:   \"MetadataVersion\": {",
      "378:    reason: \"Requesting a number field should work\",",
      "379:    path:   \"metadata.version\",",
      "380:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "381:    want: want{",
      "382:     value: 2,",
      "383:    },",
      "384:   },",
      "385:   \"MalformedPath\": {",
      "386:    reason: \"Requesting an invalid field path should fail\",",
      "387:    path:   \"spec[]\",",
      "388:    want: want{",
      "389:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "390:    },",
      "391:   },",
      "392:   \"NotANumber\": {",
      "393:    reason: \"Requesting an non-number field path should fail\",",
      "394:    path:   \"metadata.name\",",
      "395:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "396:    want: want{",
      "397:     err: errors.New(\"metadata.name: not a (float64) number\"),",
      "398:    },",
      "399:   },",
      "400:  }",
      "402:  for name, tc := range cases {",
      "403:   t.Run(name, func(t *testing.T) {",
      "404:    in := make(map[string]interface{})",
      "405:    _ = json.Unmarshal(tc.data, &in)",
      "406:    p := Pave(in)",
      "408:    got, err := p.GetNumber(tc.path)",
      "409:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "410:     t.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "411:    }",
      "412:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "413:     t.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "414:    }",
      "415:   })",
      "416:  }",
      "417: }",
      "419: func TestSetValue(t *testing.T) {",
      "420:  type args struct {",
      "421:   path  string",
      "422:   value interface{}",
      "423:  }",
      "424:  type want struct {",
      "425:   object map[string]interface{}",
      "426:   err    error",
      "427:  }",
      "428:  cases := map[string]struct {",
      "429:   reason string",
      "430:   data   []byte",
      "431:   args   args",
      "432:   want   want",
      "433:  }{",
      "434:   \"MetadataName\": {",
      "435:    reason: \"Setting an object field should work\",",
      "436:    data:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),",
      "437:    args: args{",
      "438:     path:  \"metadata.name\",",
      "439:     value: \"cool\",",
      "440:    },",
      "441:    want: want{",
      "442:     object: map[string]interface{}{",
      "443:      \"metadata\": map[string]interface{}{",
      "444:       \"name\": \"cool\",",
      "445:      },",
      "446:     },",
      "447:    },",
      "448:   },",
      "449:   \"NonExistentMetadataName\": {",
      "450:    reason: \"Setting a non-existent object field should work\",",
      "451:    data:   []byte(`{}`),",
      "452:    args: args{",
      "453:     path:  \"metadata.name\",",
      "454:     value: \"cool\",",
      "455:    },",
      "456:    want: want{",
      "457:     object: map[string]interface{}{",
      "458:      \"metadata\": map[string]interface{}{",
      "459:       \"name\": \"cool\",",
      "460:      },",
      "461:     },",
      "462:    },",
      "463:   },",
      "464:   \"ContainerName\": {",
      "465:    reason: \"Setting a field of an object that is an array element should work\",",
      "466:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"lame\"}]}}`),",
      "467:    args: args{",
      "468:     path:  \"spec.containers[0].name\",",
      "469:     value: \"cool\",",
      "470:    },",
      "471:    want: want{",
      "472:     object: map[string]interface{}{",
      "473:      \"spec\": map[string]interface{}{",
      "474:       \"containers\": []interface{}{",
      "475:        map[string]interface{}{",
      "476:         \"name\": \"cool\",",
      "477:        },",
      "478:       },",
      "479:      },",
      "480:     },",
      "481:    },",
      "482:   },",
      "483:   \"NonExistentContainerName\": {",
      "484:    reason: \"Setting a field of a non-existent object that is an array element should work\",",
      "485:    data:   []byte(`{}`),",
      "486:    args: args{",
      "487:     path:  \"spec.containers[0].name\",",
      "488:     value: \"cool\",",
      "489:    },",
      "490:    want: want{",
      "491:     object: map[string]interface{}{",
      "492:      \"spec\": map[string]interface{}{",
      "493:       \"containers\": []interface{}{",
      "494:        map[string]interface{}{",
      "495:         \"name\": \"cool\",",
      "496:        },",
      "497:       },",
      "498:      },",
      "499:     },",
      "500:    },",
      "501:   },",
      "502:   \"NewContainer\": {",
      "503:    reason: \"Growing an array object field should work\",",
      "504:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "505:    args: args{",
      "506:     path:  \"spec.containers[1].name\",",
      "507:     value: \"cooler\",",
      "508:    },",
      "509:    want: want{",
      "510:     object: map[string]interface{}{",
      "511:      \"spec\": map[string]interface{}{",
      "512:       \"containers\": []interface{}{",
      "513:        map[string]interface{}{",
      "514:         \"name\": \"cool\",",
      "515:        },",
      "516:        map[string]interface{}{",
      "517:         \"name\": \"cooler\",",
      "518:        },",
      "519:       },",
      "520:      },",
      "521:     },",
      "522:    },",
      "523:   },",
      "524:   \"NestedArray\": {",
      "525:    reason: \"Setting a value in a nested array should work\",",
      "526:    data:   []byte(`{}`),",
      "527:    args: args{",
      "528:     path:  \"data[0][0]\",",
      "529:     value: \"a\",",
      "530:    },",
      "531:    want: want{",
      "532:     object: map[string]interface{}{",
      "533:      \"data\": []interface{}{",
      "534:       []interface{}{\"a\"},",
      "535:      },",
      "536:     },",
      "537:    },",
      "538:   },",
      "539:   \"GrowNestedArray\": {",
      "540:    reason: \"Growing then setting a value in a nested array should work\",",
      "541:    data:   []byte(`{\"data\":[[\"a\"]]}`),",
      "542:    args: args{",
      "543:     path:  \"data[0][1]\",",
      "544:     value: \"b\",",
      "545:    },",
      "546:    want: want{",
      "547:     object: map[string]interface{}{",
      "548:      \"data\": []interface{}{",
      "549:       []interface{}{\"a\", \"b\"},",
      "550:      },",
      "551:     },",
      "552:    },",
      "553:   },",
      "554:   \"GrowArrayField\": {",
      "555:    reason: \"Growing then setting a value in an array field should work\",",
      "556:    data:   []byte(`{\"data\":[\"a\"]}`),",
      "557:    args: args{",
      "558:     path:  \"data[2]\",",
      "559:     value: \"c\",",
      "560:    },",
      "561:    want: want{",
      "562:     object: map[string]interface{}{",
      "563:      \"data\": []interface{}{\"a\", nil, \"c\"},",
      "564:     },",
      "565:    },",
      "566:   },",
      "567:   \"NotAnArray\": {",
      "568:    reason: \"Indexing an object field should fail\",",
      "569:    data:   []byte(`{\"data\":{}}`),",
      "570:    args: args{",
      "571:     path: \"data[0]\",",
      "572:    },",
      "573:    want: want{",
      "574:     object: map[string]interface{}{\"data\": map[string]interface{}{}},",
      "575:     err:    errors.New(\"data is not an array\"),",
      "576:    },",
      "577:   },",
      "578:   \"NotAnObject\": {",
      "579:    reason: \"Requesting a field in an array should fail\",",
      "580:    data:   []byte(`{\"data\":[]}`),",
      "581:    args: args{",
      "582:     path: \"data.name\",",
      "583:    },",
      "584:    want: want{",
      "585:     object: map[string]interface{}{\"data\": []interface{}{}},",
      "586:     err:    errors.New(\"data is not an object\"),",
      "587:    },",
      "588:   },",
      "589:   \"MalformedPath\": {",
      "590:    reason: \"Requesting an invalid field path should fail\",",
      "591:    args: args{",
      "592:     path: \"spec[]\",",
      "593:    },",
      "594:    want: want{",
      "595:     object: map[string]interface{}{},",
      "596:     err:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "597:    },",
      "598:   },",
      "599:  }",
      "601:  for name, tc := range cases {",
      "602:   t.Run(name, func(t *testing.T) {",
      "603:    in := make(map[string]interface{})",
      "604:    _ = json.Unmarshal(tc.data, &in)",
      "605:    p := Pave(in)",
      "607:    err := p.SetValue(tc.args.path, tc.args.value)",
      "608:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "609:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want error, +got error:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "610:    }",
      "611:    if diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {",
      "612:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want, +got:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "613:    }",
      "614:   })",
      "615:  }",
      "616: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "47bff13a91321eaeea0ce0eae312564387d6d421",
      "candidate_info": {
        "commit_hash": "47bff13a91321eaeea0ce0eae312564387d6d421",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/47bff13a91321eaeea0ce0eae312564387d6d421",
        "files": [
          "pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/fieldpath_test.go",
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Proper printing for wildcards\n\nSigned-off-by: Hasan Turken <turkenh@gmail.com>",
        "before_after_code_files": [
          "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
          "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:  for _, s := range sg {",
          "79:   switch s.Type {",
          "80:   case SegmentField:",
          "82:     b.WriteString(fmt.Sprintf(\"[%s]\", s.Field))",
          "83:     continue",
          "84:    }",
          "",
          "[Removed Lines]",
          "81:    if strings.ContainsRune(s.Field, period) {",
          "",
          "[Added Lines]",
          "81:    if s.Field == wildcard || strings.ContainsRune(s.Field, period) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:  period       = '.'",
          "139:  leftBracket  = '['",
          "140:  rightBracket = ']'",
          "141: )",
          "143: type itemType int",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:  wildcard = \"*\"",
          "",
          "---------------"
        ],
        "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go": [
          "File: pkg/fieldpath/fieldpath_test.go -> pkg/fieldpath/fieldpath_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:    },",
          "57:    want: \"data[.config.yml]\",",
          "58:   },",
          "59:  }",
          "61:  for name, tc := range cases {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:   \"Wildcard\": {",
          "60:    s: Segments{",
          "61:     Field(\"spec\"),",
          "62:     Field(\"containers\"),",
          "63:     FieldOrIndex(\"*\"),",
          "64:     Field(\"name\"),",
          "65:    },",
          "66:    want: \"spec.containers[*].name\",",
          "67:   },",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:  it := data",
          "158:  for i, current := range segments {",
          "161:    switch mapOrArray := it.(type) {",
          "162:    case []interface{}:",
          "163:     for ix := range mapOrArray {",
          "",
          "[Removed Lines]",
          "160:   if current.Type == SegmentField && current.Field == \"*\" {",
          "",
          "[Added Lines]",
          "160:   if current.Type == SegmentField && current.Field == wildcard {",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "942:    path:   \"spec.containers[0].name[*]\",",
          "943:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
          "944:    want: want{",
          "946:    },",
          "947:   },",
          "948:   \"NotAnArray\": {",
          "",
          "[Removed Lines]",
          "945:     err: errors.Wrapf(errors.Errorf(\"%q: unexpected wildcard usage\", \"spec.containers[0].name\"), \"cannot expand wildcards for segments: %q\", \"spec.containers[0].name.*\"),",
          "",
          "[Added Lines]",
          "945:     err: errors.Wrapf(errors.Errorf(\"%q: unexpected wildcard usage\", \"spec.containers[0].name\"), \"cannot expand wildcards for segments: %q\", \"spec.containers[0].name[*]\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4fccb39a42a963c67632d4120c11ff24d2eb38a",
      "candidate_info": {
        "commit_hash": "d4fccb39a42a963c67632d4120c11ff24d2eb38a",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/d4fccb39a42a963c67632d4120c11ff24d2eb38a",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "fix: enforce max index value for paths\n\nSigned-off-by: Philippe Scorsolini <p.scorsolini@gmail.com>\n(cherry picked from commit 7560fbc0415bf69c219b96949f3b2d2839538d56)",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  \"github.com/crossplane/crossplane-runtime/pkg/errors\"",
          "26: )",
          "28: type errNotFound struct {",
          "29:  error",
          "30: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: const DefaultMaxFieldPathIndex = 1024",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: type Paved struct {",
          "50: }",
          "55:  u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)",
          "57: }",
          "62: }",
          "",
          "[Removed Lines]",
          "49:  object map[string]interface{}",
          "54: func PaveObject(o runtime.Object) (*Paved, error) {",
          "56:  return Pave(u), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "60: func Pave(object map[string]interface{}) *Paved {",
          "61:  return &Paved{object: object}",
          "",
          "[Added Lines]",
          "52:  object            map[string]interface{}",
          "53:  maxFieldPathIndex uint",
          "56: type PavedOption func(paved *Paved)",
          "60: func PaveObject(o runtime.Object, opts ...PavedOption) (*Paved, error) {",
          "62:  return Pave(u, opts...), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "66: func Pave(object map[string]interface{}, opts ...PavedOption) *Paved {",
          "67:  p := &Paved{object: object, maxFieldPathIndex: DefaultMaxFieldPathIndex}",
          "69:  for _, opt := range opts {",
          "70:   opt(p)",
          "71:  }",
          "73:  return p",
          "74: }",
          "77: func WithMaxFieldPathIndex(max uint) PavedOption {",
          "78:  return func(paved *Paved) {",
          "79:   paved.maxFieldPathIndex = max",
          "80:  }",
          "81: }",
          "83: func (p *Paved) maxFieldPathIndexEnabled() bool {",
          "84:  return p.maxFieldPathIndex > 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "359:     return errors.Errorf(\"%s is not an array\", s[:i])",
          "360:    }",
          "362:    if final {",
          "363:     array[current.Index] = v",
          "364:     return nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "385:    if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {",
          "386:     return errors.Errorf(\"index %d is greater than max allowed index %d\", current.Index, p.maxFieldPathIndex)",
          "387:    }",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "20:  \"testing\"",
          "22:  \"github.com/google/go-cmp/cmp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  \"fmt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:  type args struct {",
          "594:   path  string",
          "595:   value interface{}",
          "596:  }",
          "597:  type want struct {",
          "598:   object map[string]interface{}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:   opts  []PavedOption",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:     },",
          "738:    },",
          "739:   },",
          "740:   \"MapStringString\": {",
          "741:    reason: \"A map of string to string should be converted to a map of string to interface{}\",",
          "742:    data:   []byte(`{\"metadata\":{}}`),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:   \"RejectsHighIndexes\": {",
          "743:    reason: \"Paths having indexes above the maximum default value are rejected\",",
          "744:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "745:    args: args{",
          "746:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "747:     value: \"c\",",
          "748:    },",
          "749:    want: want{",
          "750:     object: map[string]interface{}{",
          "751:      \"data\": []interface{}{\"a\"}},",
          "752:     err: errors.Wrap(errors.Errorf(\"found index above max (%[1]v > %[2]v): data[%[1]v]\",",
          "753:      MaxFieldPathIndex+1, MaxFieldPathIndex), \"invalid segments\"),",
          "754:    },",
          "755:   },",
          "756:   \"NotRejectsHighIndexesIfNoDefaultOptions\": {",
          "757:    reason: \"Paths having indexes above the maximum default value are not rejected if default disabled\",",
          "758:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "759:    args: args{",
          "760:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "761:     value: \"c\",",
          "762:     opts:  []PavedOption{},",
          "763:    },",
          "764:    want: want{",
          "765:     object: map[string]interface{}{",
          "766:      \"data\": func() []interface{} {",
          "767:       res := make([]interface{}, MaxFieldPathIndex+2)",
          "768:       res[0] = \"a\"",
          "769:       res[MaxFieldPathIndex+1] = \"c\"",
          "770:       return res",
          "771:      }()},",
          "772:    },",
          "773:   },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "817:   t.Run(name, func(t *testing.T) {",
          "818:    in := make(map[string]interface{})",
          "819:    _ = json.Unmarshal(tc.data, &in)",
          "822:    err := p.SetValue(tc.args.path, tc.args.value)",
          "823:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
          "",
          "[Removed Lines]",
          "820:    p := Pave(in)",
          "",
          "[Added Lines]",
          "854:    p := Pave(in, tc.args.opts...)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c714c6dceb8f9ef76f380c224f8235ce2f68d8f0",
      "candidate_info": {
        "commit_hash": "c714c6dceb8f9ef76f380c224f8235ce2f68d8f0",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/c714c6dceb8f9ef76f380c224f8235ce2f68d8f0",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "fieldpath: update unit tests to use the same json marshal/unmarshaller as apimachinery\n\nSigned-off-by: Muvaffak Onus <onus.muvaffak@gmail.com>",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "22:  \"github.com/pkg/errors\"",
          "23:  \"k8s.io/apimachinery/pkg/runtime\"",
          "24: )",
          "26: type errNotFound struct {",
          "",
          "[Removed Lines]",
          "20:  \"encoding/json\"",
          "",
          "[Added Lines]",
          "22:  \"k8s.io/apimachinery/pkg/util/json\"",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "21:  \"testing\"",
          "23:  \"github.com/google/go-cmp/cmp\"",
          "24:  \"github.com/pkg/errors\"",
          "25:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "26:  \"k8s.io/apimachinery/pkg/types\"",
          "28:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
          "29: )",
          "",
          "[Removed Lines]",
          "20:  \"encoding/json\"",
          "",
          "[Added Lines]",
          "26:  \"k8s.io/apimachinery/pkg/util/json\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:    },",
          "106:   },",
          "107:   \"MetadataVersion\": {",
          "109:    path:   \"metadata.version\",",
          "110:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
          "111:    want: want{",
          "112:     value: float64(2),",
          "113:    },",
          "",
          "[Removed Lines]",
          "108:    reason: \"Requesting a number field should work\",",
          "",
          "[Added Lines]",
          "108:    reason: \"Requesting an integer field should work\",",
          "111:    want: want{",
          "112:     value: int64(2),",
          "113:    },",
          "114:   },",
          "115:   \"SomeFloat\": {",
          "116:    reason: \"Requesting a float field should work\",",
          "117:    path:   \"metadata.version\",",
          "118:    data:   []byte(`{\"metadata\":{\"version\":2.0}}`),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "488:   \"MetadataVersion\": {",
          "489:    reason: \"Requesting a number field should work\",",
          "490:    path:   \"metadata.version\",",
          "492:    want: want{",
          "493:     value: 2,",
          "494:    },",
          "",
          "[Removed Lines]",
          "491:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
          "",
          "[Added Lines]",
          "499:    data:   []byte(`{\"metadata\":{\"version\":2.0}}`),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "527:  }",
          "528: }",
          "530: func TestSetValue(t *testing.T) {",
          "531:  type args struct {",
          "532:   path  string",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:  }",
          "536: }",
          "538: func TestGetInteger(t *testing.T) {",
          "539:  type want struct {",
          "540:   value int64",
          "541:   err   error",
          "542:  }",
          "543:  cases := map[string]struct {",
          "544:   reason string",
          "545:   path   string",
          "546:   data   []byte",
          "547:   want   want",
          "548:  }{",
          "549:   \"MetadataVersion\": {",
          "550:    reason: \"Requesting a number field should work\",",
          "551:    path:   \"metadata.version\",",
          "552:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
          "553:    want: want{",
          "554:     value: 2,",
          "555:    },",
          "556:   },",
          "557:   \"MalformedPath\": {",
          "558:    reason: \"Requesting an invalid field path should fail\",",
          "559:    path:   \"spec[]\",",
          "560:    want: want{",
          "561:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
          "562:    },",
          "563:   },",
          "564:   \"NotANumber\": {",
          "565:    reason: \"Requesting an non-number field path should fail\",",
          "566:    path:   \"metadata.name\",",
          "567:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
          "568:    want: want{",
          "569:     err: errors.New(\"metadata.name: not a (int64) number\"),",
          "570:    },",
          "571:   },",
          "572:  }",
          "574:  for name, tc := range cases {",
          "575:   t.Run(name, func(t *testing.T) {",
          "576:    in := make(map[string]interface{})",
          "577:    _ = json.Unmarshal(tc.data, &in)",
          "578:    p := Pave(in)",
          "580:    got, err := p.GetInteger(tc.path)",
          "581:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b1cd25a73b12cedda47fdc895d049b1f923cb8a4",
      "candidate_info": {
        "commit_hash": "b1cd25a73b12cedda47fdc895d049b1f923cb8a4",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/b1cd25a73b12cedda47fdc895d049b1f923cb8a4",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Change the error message\n\nSigned-off-by: Sergen Yal\u00e7\u0131n <yalcinsergen97@gmail.com>",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     }",
          "143:     it = object[current.Field]",
          "144:    case nil:",
          "146:    default:",
          "147:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
          "148:    }",
          "",
          "[Removed Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"field %q is not found in the path\", s[:i])}",
          "",
          "[Added Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"path %q is not found in the paved object\", s[:i])}",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
          "162:    },",
          "163:   },",
          "166:    path:   \"spec.containers[*].name\",",
          "167:    data:   []byte(`{\"spec\":{\"containers\": null}}`),",
          "168:    want: want{",
          "170:    },",
          "171:   },",
          "172:  }",
          "",
          "[Removed Lines]",
          "164:   \"NilValue\": {",
          "165:    reason: \"Requesting for an object that has nil value\",",
          "169:     err: errNotFound{errors.Errorf(\"field %q is not found in the path\", \"spec.containers\")},",
          "",
          "[Added Lines]",
          "164:   \"NilParent\": {",
          "165:    reason: \"Request for a path with a nil parent value\",",
          "169:     err: errNotFound{errors.Errorf(\"path %q is not found in the paved object\", \"spec.containers\")},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7b5d269f55ddaf28dcdf995df929e289ca9d104a",
      "candidate_info": {
        "commit_hash": "7b5d269f55ddaf28dcdf995df929e289ca9d104a",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/7b5d269f55ddaf28dcdf995df929e289ca9d104a",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "fix: enforce max index value for paths\n\nSigned-off-by: Philippe Scorsolini <p.scorsolini@gmail.com>\n(cherry picked from commit 7560fbc0415bf69c219b96949f3b2d2839538d56)",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  \"github.com/crossplane/crossplane-runtime/pkg/errors\"",
          "26: )",
          "28: type errNotFound struct {",
          "29:  error",
          "30: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: const DefaultMaxFieldPathIndex = 1024",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: type Paved struct {",
          "50: }",
          "55:  u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)",
          "57: }",
          "62: }",
          "",
          "[Removed Lines]",
          "49:  object map[string]interface{}",
          "54: func PaveObject(o runtime.Object) (*Paved, error) {",
          "56:  return Pave(u), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "60: func Pave(object map[string]interface{}) *Paved {",
          "61:  return &Paved{object: object}",
          "",
          "[Added Lines]",
          "52:  object            map[string]interface{}",
          "53:  maxFieldPathIndex uint",
          "56: type PavedOption func(paved *Paved)",
          "60: func PaveObject(o runtime.Object, opts ...PavedOption) (*Paved, error) {",
          "62:  return Pave(u, opts...), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "66: func Pave(object map[string]interface{}, opts ...PavedOption) *Paved {",
          "67:  p := &Paved{object: object, maxFieldPathIndex: DefaultMaxFieldPathIndex}",
          "69:  for _, opt := range opts {",
          "70:   opt(p)",
          "71:  }",
          "73:  return p",
          "74: }",
          "77: func WithMaxFieldPathIndex(max uint) PavedOption {",
          "78:  return func(paved *Paved) {",
          "79:   paved.maxFieldPathIndex = max",
          "80:  }",
          "81: }",
          "83: func (p *Paved) maxFieldPathIndexEnabled() bool {",
          "84:  return p.maxFieldPathIndex > 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "359:     return errors.Errorf(\"%s is not an array\", s[:i])",
          "360:    }",
          "362:    if final {",
          "363:     array[current.Index] = v",
          "364:     return nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "385:    if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {",
          "386:     return errors.Errorf(\"index %d is greater than max allowed index %d\", current.Index, p.maxFieldPathIndex)",
          "387:    }",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "20:  \"testing\"",
          "22:  \"github.com/google/go-cmp/cmp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  \"fmt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:  type args struct {",
          "594:   path  string",
          "595:   value interface{}",
          "596:  }",
          "597:  type want struct {",
          "598:   object map[string]interface{}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:   opts  []PavedOption",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:     },",
          "738:    },",
          "739:   },",
          "740:   \"MapStringString\": {",
          "741:    reason: \"A map of string to string should be converted to a map of string to interface{}\",",
          "742:    data:   []byte(`{\"metadata\":{}}`),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:   \"RejectsHighIndexes\": {",
          "743:    reason: \"Paths having indexes above the maximum default value are rejected\",",
          "744:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "745:    args: args{",
          "746:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "747:     value: \"c\",",
          "748:    },",
          "749:    want: want{",
          "750:     object: map[string]interface{}{",
          "751:      \"data\": []interface{}{\"a\"}},",
          "752:     err: errors.Wrap(errors.Errorf(\"found index above max (%[1]v > %[2]v): data[%[1]v]\",",
          "753:      MaxFieldPathIndex+1, MaxFieldPathIndex), \"invalid segments\"),",
          "754:    },",
          "755:   },",
          "756:   \"NotRejectsHighIndexesIfNoDefaultOptions\": {",
          "757:    reason: \"Paths having indexes above the maximum default value are not rejected if default disabled\",",
          "758:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "759:    args: args{",
          "760:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "761:     value: \"c\",",
          "762:     opts:  []PavedOption{},",
          "763:    },",
          "764:    want: want{",
          "765:     object: map[string]interface{}{",
          "766:      \"data\": func() []interface{} {",
          "767:       res := make([]interface{}, MaxFieldPathIndex+2)",
          "768:       res[0] = \"a\"",
          "769:       res[MaxFieldPathIndex+1] = \"c\"",
          "770:       return res",
          "771:      }()},",
          "772:    },",
          "773:   },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "817:   t.Run(name, func(t *testing.T) {",
          "818:    in := make(map[string]interface{})",
          "819:    _ = json.Unmarshal(tc.data, &in)",
          "822:    err := p.SetValue(tc.args.path, tc.args.value)",
          "823:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
          "",
          "[Removed Lines]",
          "820:    p := Pave(in)",
          "",
          "[Added Lines]",
          "854:    p := Pave(in, tc.args.opts...)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
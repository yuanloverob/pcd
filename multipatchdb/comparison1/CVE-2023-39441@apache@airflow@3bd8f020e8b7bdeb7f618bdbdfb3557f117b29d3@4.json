{
  "cve_id": "CVE-2023-39441",
  "cve_desc": "Apache Airflow SMTP Provider before 1.3.0, Apache Airflow IMAP Provider before 3.3.0, and\u00a0Apache Airflow before 2.7.0 are affected by the\u00a0Validation of OpenSSL Certificate vulnerability.\n\nThe default SSL context with SSL library did not check a server's X.509\u00a0certificate.\u00a0 Instead, the code accepted any certificate, which could\u00a0result in the disclosure of mail server credentials or mail contents\u00a0when the client connects to an attacker in a MITM position.\n\nUsers are strongly advised to upgrade to Apache Airflow version 2.7.0 or newer, Apache Airflow IMAP Provider version 3.3.0 or newer, and Apache Airflow SMTP Provider version 1.3.0 or newer to mitigate the risk associated with this vulnerability",
  "repo": "apache/airflow",
  "patch_hash": "3bd8f020e8b7bdeb7f618bdbdfb3557f117b29d3",
  "patch_info": {
    "commit_hash": "3bd8f020e8b7bdeb7f618bdbdfb3557f117b29d3",
    "repo": "apache/airflow",
    "commit_url": "https://github.com/apache/airflow/commit/3bd8f020e8b7bdeb7f618bdbdfb3557f117b29d3",
    "files": [
      "airflow/config_templates/config.yml",
      "airflow/utils/email.py",
      "newsfragments/33070.significant.rst",
      "tests/utils/test_email.py"
    ],
    "message": "Allows to choose SSL context for SMTP connection (#33070)\n\nThis change add two options to choose from when SSL SMTP connection\nis created:\n\n* default - for balance between compatibility and security\n* none - in case compatibility with existing infrastructure is\n  preferred\n\n(cherry picked from commit 120efc186556b1e9498f90ad436c74e5f4e138e9)",
    "before_after_code_files": [
      "airflow/utils/email.py||airflow/utils/email.py",
      "tests/utils/test_email.py||tests/utils/test_email.py"
    ]
  },
  "patch_diff": {
    "airflow/utils/email.py||airflow/utils/email.py": [
      "File: airflow/utils/email.py -> airflow/utils/email.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "21: import logging",
      "22: import os",
      "23: import smtplib",
      "24: import warnings",
      "25: from email.mime.application import MIMEApplication",
      "26: from email.mime.multipart import MIMEMultipart",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "24: import ssl",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "312:     :param with_ssl: Whether to use SSL encryption for the connection.",
      "313:     :return: An SMTP connection to the specified host and port.",
      "314:     \"\"\"",
      "322: def _get_email_list_from_str(addresses: str) -> list[str]:",
      "",
      "[Removed Lines]",
      "315:     return (",
      "316:         smtplib.SMTP_SSL(host=host, port=port, timeout=timeout)",
      "317:         if with_ssl",
      "318:         else smtplib.SMTP(host=host, port=port, timeout=timeout)",
      "319:     )",
      "",
      "[Added Lines]",
      "316:     if not with_ssl:",
      "317:         return smtplib.SMTP(host=host, port=port, timeout=timeout)",
      "318:     else:",
      "319:         ssl_context_string = conf.get(\"email\", \"SSL_CONTEXT\")",
      "320:         if ssl_context_string == \"default\":",
      "321:             ssl_context = ssl.create_default_context()",
      "322:         elif ssl_context_string == \"none\":",
      "323:             ssl_context = None",
      "324:         else:",
      "325:             raise RuntimeError(",
      "326:                 f\"The email.ssl_context configuration variable must \"",
      "327:                 f\"be set to 'default' or 'none' and is '{ssl_context_string}.\"",
      "328:             )",
      "329:         return smtplib.SMTP_SSL(host=host, port=port, timeout=timeout, context=ssl_context)",
      "",
      "---------------"
    ],
    "tests/utils/test_email.py||tests/utils/test_email.py": [
      "File: tests/utils/test_email.py -> tests/utils/test_email.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:     @mock.patch(\"smtplib.SMTP_SSL\")",
      "242:     @mock.patch(\"smtplib.SMTP\")",
      "244:         mock_smtp_ssl.return_value = mock.Mock()",
      "245:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\"}):",
      "246:             email.send_mime_email(\"from\", \"to\", MIMEMultipart(), dryrun=False)",
      "247:         assert not mock_smtp.called",
      "248:         mock_smtp_ssl.assert_called_once_with(",
      "249:             host=conf.get(\"smtp\", \"SMTP_HOST\"),",
      "250:             port=conf.getint(\"smtp\", \"SMTP_PORT\"),",
      "251:             timeout=conf.getint(\"smtp\", \"SMTP_TIMEOUT\"),",
      "252:         )",
      "254:     @mock.patch(\"smtplib.SMTP_SSL\")",
      "",
      "[Removed Lines]",
      "243:     def test_send_mime_ssl(self, mock_smtp, mock_smtp_ssl):",
      "",
      "[Added Lines]",
      "243:     def test_send_mime_ssl_none_context(self, mock_smtp, mock_smtp_ssl):",
      "244:         mock_smtp_ssl.return_value = mock.Mock()",
      "245:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\", (\"email\", \"ssl_context\"): \"none\"}):",
      "246:             email.send_mime_email(\"from\", \"to\", MIMEMultipart(), dryrun=False)",
      "247:         assert not mock_smtp.called",
      "248:         mock_smtp_ssl.assert_called_once_with(",
      "249:             host=conf.get(\"smtp\", \"SMTP_HOST\"),",
      "250:             port=conf.getint(\"smtp\", \"SMTP_PORT\"),",
      "251:             timeout=conf.getint(\"smtp\", \"SMTP_TIMEOUT\"),",
      "252:             context=None,",
      "253:         )",
      "255:     @mock.patch(\"smtplib.SMTP_SSL\")",
      "256:     @mock.patch(\"smtplib.SMTP\")",
      "257:     @mock.patch(\"ssl.create_default_context\")",
      "258:     def test_send_mime_ssl_default_context_if_not_set(self, create_default_context, mock_smtp, mock_smtp_ssl):",
      "263:         assert create_default_context.called",
      "268:             context=create_default_context.return_value,",
      "269:         )",
      "271:     @mock.patch(\"smtplib.SMTP_SSL\")",
      "272:     @mock.patch(\"smtplib.SMTP\")",
      "273:     @mock.patch(\"ssl.create_default_context\")",
      "274:     def test_send_mime_ssl_default_context_with_value_set_to_default(",
      "275:         self, create_default_context, mock_smtp, mock_smtp_ssl",
      "276:     ):",
      "277:         mock_smtp_ssl.return_value = mock.Mock()",
      "278:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\", (\"email\", \"ssl_context\"): \"default\"}):",
      "279:             email.send_mime_email(\"from\", \"to\", MIMEMultipart(), dryrun=False)",
      "280:         assert not mock_smtp.called",
      "281:         assert create_default_context.called",
      "282:         mock_smtp_ssl.assert_called_once_with(",
      "283:             host=conf.get(\"smtp\", \"SMTP_HOST\"),",
      "284:             port=conf.getint(\"smtp\", \"SMTP_PORT\"),",
      "285:             timeout=conf.getint(\"smtp\", \"SMTP_TIMEOUT\"),",
      "286:             context=create_default_context.return_value,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "300:     @mock.patch(\"smtplib.SMTP_SSL\")",
      "301:     @mock.patch(\"smtplib.SMTP\")",
      "303:         mock_smtp_ssl.side_effect = SMTPServerDisconnected()",
      "304:         msg = MIMEMultipart()",
      "305:         with conf_vars({(\"smtp\", \"smtp_ssl\"): \"True\"}):",
      "",
      "[Removed Lines]",
      "302:     def test_send_mime_ssl_complete_failure(self, mock_smtp, mock_smtp_ssl):",
      "",
      "[Added Lines]",
      "336:     @mock.patch(\"ssl.create_default_context\")",
      "337:     def test_send_mime_ssl_complete_failure(self, create_default_context, mock_smtp, mock_smtp_ssl):",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "310:             host=conf.get(\"smtp\", \"SMTP_HOST\"),",
      "311:             port=conf.getint(\"smtp\", \"SMTP_PORT\"),",
      "312:             timeout=conf.getint(\"smtp\", \"SMTP_TIMEOUT\"),",
      "313:         )",
      "314:         assert mock_smtp_ssl.call_count == conf.getint(\"smtp\", \"SMTP_RETRY_LIMIT\")",
      "315:         assert not mock_smtp.called",
      "316:         assert not mock_smtp_ssl.return_value.starttls.called",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "348:             context=create_default_context.return_value,",
      "350:         assert create_default_context.called",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ab036e9a305668ce2b63a9c59a3e84b484b50a5c",
      "candidate_info": {
        "commit_hash": "ab036e9a305668ce2b63a9c59a3e84b484b50a5c",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/ab036e9a305668ce2b63a9c59a3e84b484b50a5c",
        "files": [
          "airflow/www/static/js/dag/details/graph/Node.tsx"
        ],
        "message": "Use arrow with no circle for setup / teardown (#33098)\n\nJust seems easier to see.\n\n(cherry picked from commit b57fc45861a7527541e684c00333d983290a88c0)",
        "before_after_code_files": [
          "airflow/www/static/js/dag/details/graph/Node.tsx||airflow/www/static/js/dag/details/graph/Node.tsx"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/33038"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/www/static/js/dag/details/graph/Node.tsx||airflow/www/static/js/dag/details/graph/Node.tsx": [
          "File: airflow/www/static/js/dag/details/graph/Node.tsx -> airflow/www/static/js/dag/details/graph/Node.tsx",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import Tooltip from \"src/components/Tooltip\";",
          "29: import InstanceTooltip from \"src/dag/InstanceTooltip\";",
          "30: import { useContainerRef } from \"src/context/containerRef\";",
          "36: export interface CustomNodeProps {",
          "37:   label: string;",
          "",
          "[Removed Lines]",
          "31: import {",
          "32:   MdOutlineArrowCircleUp,",
          "33:   MdOutlineArrowCircleDown,",
          "34: } from \"react-icons/md\";",
          "",
          "[Added Lines]",
          "31: import { ImArrowUpRight2, ImArrowDownRight2 } from \"react-icons/im\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:                 {taskName}",
          "146:               </Text>",
          "147:               {setupTeardownType === \"setup\" && (",
          "149:               )}",
          "150:               {setupTeardownType === \"teardown\" && (",
          "152:               )}",
          "153:             </Flex>",
          "154:             {!!instance && instance.state && (",
          "",
          "[Removed Lines]",
          "148:                 <MdOutlineArrowCircleUp size={18} color={colors.gray[800]} />",
          "151:                 <MdOutlineArrowCircleDown size={18} color={colors.gray[800]} />",
          "",
          "[Added Lines]",
          "145:                 <ImArrowUpRight2 size={15} color={colors.gray[800]} />",
          "148:                 <ImArrowDownRight2 size={15} color={colors.gray[800]} />",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ecc84125dcf317e106cd2f3d1ed0d44b77b04d7",
      "candidate_info": {
        "commit_hash": "7ecc84125dcf317e106cd2f3d1ed0d44b77b04d7",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/7ecc84125dcf317e106cd2f3d1ed0d44b77b04d7",
        "files": [
          "airflow/models/baseoperator.py",
          "tests/models/test_baseoperator.py"
        ],
        "message": "Fix BaseOperator get_task_instances query (#33054)\n\n* Fix BaseOperator get_task_instances query\n\n* add unit test\n\n(cherry picked from commit f5a83bc90b237228db1434662f9dba5ebb719d47)",
        "before_after_code_files": [
          "airflow/models/baseoperator.py||airflow/models/baseoperator.py",
          "tests/models/test_baseoperator.py||tests/models/test_baseoperator.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/33038"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/models/baseoperator.py||airflow/models/baseoperator.py": [
          "File: airflow/models/baseoperator.py -> airflow/models/baseoperator.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1285:         \"\"\"Get task instances related to this task for a specific date range.\"\"\"",
          "1286:         from airflow.models import DagRun",
          "1290:             select(TaskInstance)",
          "1291:             .join(TaskInstance.dag_run)",
          "1292:             .where(TaskInstance.dag_id == self.dag_id)",
          "1293:             .where(TaskInstance.task_id == self.task_id)",
          "1299:     @provide_session",
          "1300:     def run(",
          "",
          "[Removed Lines]",
          "1288:         end_date = end_date or timezone.utcnow()",
          "1289:         return session.scalars(",
          "1294:             .where(DagRun.execution_date >= start_date)",
          "1295:             .where(DagRun.execution_date <= end_date)",
          "1296:             .order_by(DagRun.execution_date)",
          "1297:         ).all()",
          "",
          "[Added Lines]",
          "1288:         query = (",
          "1293:         )",
          "1294:         if start_date:",
          "1295:             query = query.where(DagRun.execution_date >= start_date)",
          "1296:         if end_date:",
          "1297:             query = query.where(DagRun.execution_date <= end_date)",
          "1298:         return session.scalars(query.order_by(DagRun.execution_date)).all()",
          "",
          "---------------"
        ],
        "tests/models/test_baseoperator.py||tests/models/test_baseoperator.py": [
          "File: tests/models/test_baseoperator.py -> tests/models/test_baseoperator.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: from airflow.decorators import task as task_decorator",
          "32: from airflow.exceptions import AirflowException, FailStopDagInvalidTriggerRule, RemovedInAirflow3Warning",
          "33: from airflow.lineage.entities import File",
          "35: from airflow.models.baseoperator import (",
          "36:     BaseOperator,",
          "37:     BaseOperatorMeta,",
          "",
          "[Removed Lines]",
          "34: from airflow.models import DAG",
          "",
          "[Added Lines]",
          "34: from airflow.models import DAG, DagRun, TaskInstance",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: from airflow.utils.edgemodifier import Label",
          "44: from airflow.utils.task_group import TaskGroup",
          "45: from airflow.utils.trigger_rule import TriggerRule",
          "46: from airflow.utils.weight_rule import WeightRule",
          "47: from tests.models import DEFAULT_DATE",
          "48: from tests.test_utils.config import conf_vars",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: from airflow.utils.types import DagRunType",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1023:         \"tg_2.my_work\": \"skipped\",",
          "1024:     }",
          "1025:     assert states == expected",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1029: def test_get_task_instances(session):",
          "1030:     import pendulum",
          "1032:     first_execution_date = pendulum.datetime(2023, 1, 1)",
          "1033:     second_execution_date = pendulum.datetime(2023, 1, 2)",
          "1034:     third_execution_date = pendulum.datetime(2023, 1, 3)",
          "1036:     test_dag = DAG(dag_id=\"test_dag\", start_date=first_execution_date)",
          "1037:     task = BaseOperator(task_id=\"test_task\", dag=test_dag)",
          "1039:     common_dr_kwargs = {",
          "1040:         \"dag_id\": test_dag.dag_id,",
          "1041:         \"run_type\": DagRunType.MANUAL,",
          "1042:     }",
          "1043:     dr1 = DagRun(execution_date=first_execution_date, run_id=\"test_run_id_1\", **common_dr_kwargs)",
          "1044:     ti_1 = TaskInstance(run_id=dr1.run_id, task=task, execution_date=first_execution_date)",
          "1045:     dr2 = DagRun(execution_date=second_execution_date, run_id=\"test_run_id_2\", **common_dr_kwargs)",
          "1046:     ti_2 = TaskInstance(run_id=dr2.run_id, task=task, execution_date=second_execution_date)",
          "1047:     dr3 = DagRun(execution_date=third_execution_date, run_id=\"test_run_id_3\", **common_dr_kwargs)",
          "1048:     ti_3 = TaskInstance(run_id=dr3.run_id, task=task, execution_date=third_execution_date)",
          "1049:     session.add_all([dr1, dr2, dr3, ti_1, ti_2, ti_3])",
          "1050:     session.commit()",
          "1052:     # get all task instances",
          "1053:     assert task.get_task_instances(session=session) == [ti_1, ti_2, ti_3]",
          "1054:     # get task instances with start_date",
          "1055:     assert task.get_task_instances(session=session, start_date=second_execution_date) == [ti_2, ti_3]",
          "1056:     # get task instances with end_date",
          "1057:     assert task.get_task_instances(session=session, end_date=second_execution_date) == [ti_1, ti_2]",
          "1058:     # get task instances with start_date and end_date",
          "1059:     assert task.get_task_instances(",
          "1060:         session=session, start_date=second_execution_date, end_date=second_execution_date",
          "1061:     ) == [ti_2]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3b038f408e254dda020e5be8c399b5dc94e7d418",
      "candidate_info": {
        "commit_hash": "3b038f408e254dda020e5be8c399b5dc94e7d418",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/3b038f408e254dda020e5be8c399b5dc94e7d418",
        "files": [
          "airflow/example_dags/example_params_ui_tutorial.py",
          "airflow/www/static/js/trigger.js",
          "airflow/www/templates/airflow/trigger.html",
          "docs/apache-airflow/core-concepts/params.rst"
        ],
        "message": "Add support for arrays of different data types in the Trigger Form UI (#32734)\n\n* Add JSON field for complex arrays with types other than string\n\n---------\n\nCo-authored-by: Matthieu Blais <matthieu.blais@tech.jago.com>\nCo-authored-by: Jens Scheffler <95105677+jens-scheffler-bosch@users.noreply.github.com>\nCo-authored-by: eladkal <45845474+eladkal@users.noreply.github.com>\n(cherry picked from commit da6931561f59a64f6489c56a5675c2cc6e6a2bca)",
        "before_after_code_files": [
          "airflow/example_dags/example_params_ui_tutorial.py||airflow/example_dags/example_params_ui_tutorial.py",
          "airflow/www/static/js/trigger.js||airflow/www/static/js/trigger.js",
          "airflow/www/templates/airflow/trigger.html||airflow/www/templates/airflow/trigger.html"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/33038"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/example_dags/example_params_ui_tutorial.py||airflow/example_dags/example_params_ui_tutorial.py": [
          "File: airflow/example_dags/example_params_ui_tutorial.py -> airflow/example_dags/example_params_ui_tutorial.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:                 # Note: Value display mapping does not need to be complete.s",
          "128:             },",
          "129:         ),",
          "130:         # Boolean as proper parameter with description",
          "131:         \"bool\": Param(",
          "132:             True,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130:         # An array of numbers",
          "131:         \"array_of_numbers\": Param(",
          "132:             [1, 2, 3],",
          "133:             \"Only integers are accepted in this array\",",
          "134:             type=\"array\",",
          "135:             title=\"Array of numbers\",",
          "136:             items={\"type\": \"number\"},",
          "137:         ),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:             title=\"JSON entry field\",",
          "209:             section=\"Special advanced stuff with form fields\",",
          "210:         ),",
          "211:         # If you want to have static parameters which are always passed and not editable by the user",
          "212:         # then you can use the JSON schema option of passing constant values. These parameters",
          "213:         # will not be displayed but passed to the DAG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:         \"array_of_objects\": Param(",
          "220:             [{\"name\": \"account_name\", \"country\": \"country_name\"}],",
          "221:             \"Array with complex objects and validation rules. \"",
          "222:             \"See <a href='https://json-schema.org/understanding-json-schema\"",
          "223:             \"/reference/array.html#items'>JSON Schema validation options in specs.</a>\",",
          "224:             type=\"array\",",
          "225:             title=\"JSON array field\",",
          "226:             items={",
          "227:                 \"type\": \"object\",",
          "228:                 \"properties\": {\"name\": {\"type\": \"string\"}, \"country_name\": {\"type\": \"string\"}},",
          "229:                 \"required\": [\"name\"],",
          "230:             },",
          "231:             section=\"Special advanced stuff with form fields\",",
          "232:         ),",
          "",
          "---------------"
        ],
        "airflow/www/static/js/trigger.js||airflow/www/static/js/trigger.js": [
          "File: airflow/www/static/js/trigger.js -> airflow/www/static/js/trigger.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:         params[keyName] = null;",
          "64:       } else if (",
          "65:         elements[i].attributes.valuetype &&",
          "67:       ) {",
          "68:         try {",
          "69:           const textValue = objectFields.get(elements[i].name).getValue();",
          "",
          "[Removed Lines]",
          "66:         elements[i].attributes.valuetype.value === \"object\"",
          "",
          "[Added Lines]",
          "66:         (elements[i].attributes.valuetype.value === \"object\" ||",
          "67:           elements[i].attributes.valuetype.value === \"advancedarray\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:     mode: { name: \"javascript\", json: true },",
          "113:     gutters: [\"CodeMirror-lint-markers\"],",
          "114:     lint: true,",
          "115:   });",
          "116:   jsonForm.setSize(null, height);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116:     indentUnit: 4,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "122:       if (elements[i].name && elements[i].name.startsWith(\"element_\")) {",
          "123:         if (",
          "124:           elements[i].attributes.valuetype &&",
          "126:         ) {",
          "128:           const field = CodeMirror.fromTextArea(elements[i], {",
          "",
          "[Removed Lines]",
          "125:           elements[i].attributes.valuetype.value === \"object\"",
          "",
          "[Added Lines]",
          "127:           (elements[i].attributes.valuetype.value === \"object\" ||",
          "128:             elements[i].attributes.valuetype.value === \"advancedarray\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "130:             mode: { name: \"javascript\", json: true },",
          "131:             gutters: [\"CodeMirror-lint-markers\"],",
          "132:             lint: true,",
          "133:           });",
          "134:           field.on(\"blur\", updateJSONconf);",
          "135:           objectFields.set(elements[i].name, field);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:             indentUnit: 4,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "230:         element.value = newValue.join(\"\\n\");",
          "231:       } else if (",
          "232:         element.attributes.valuetype &&",
          "234:       ) {",
          "235:         objectFields",
          "236:           .get(`element_${keys[i]}`)",
          "",
          "[Removed Lines]",
          "233:         element.attributes.valuetype.value === \"object\"",
          "",
          "[Added Lines]",
          "237:         (element.attributes.valuetype.value === \"object\" ||",
          "238:           element.attributes.valuetype.value === \"advancedarray\")",
          "",
          "---------------"
        ],
        "airflow/www/templates/airflow/trigger.html||airflow/www/templates/airflow/trigger.html": [
          "File: airflow/www/templates/airflow/trigger.html -> airflow/www/templates/airflow/trigger.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:         {% endfor -%}",
          "87:       </select>",
          "88:     {% elif form_details.schema and \"array\" in form_details.schema.type %}",
          "90:       <select multiple name=\"element_{{ form_key }}\" id=\"element_{{ form_key }}\" class=\"select2-drop-mask\" valuetype=\"multiselect\"",
          "91:         onchange=\"updateJSONconf();\"{% if not \"null\" in form_details.schema.type %} required=\"\"{% endif %}>",
          "92:         {% for option in form_details.schema.examples -%}",
          "",
          "[Removed Lines]",
          "89:       {% if \"examples\" in form_details.schema and form_details.schema.examples %}",
          "",
          "[Added Lines]",
          "89:       {% if \"items\" in form_details.schema and form_details.schema.items %}",
          "90:       <textarea class=\"form-control\" name=\"element_{{ form_key }}\" id=\"element_{{ form_key }}\" valuetype=\"advancedarray\" rows=\"6\"",
          "91:         {%- if not \"null\" in form_details.schema.type %} required=\"\"{% endif -%}>",
          "92:         {%- if form_details.value is sequence %}",
          "93:           {{- form_details.value | tojson() -}}",
          "94:         {% endif -%}",
          "95:       </textarea>",
          "96:       {% elif \"examples\" in form_details.schema and form_details.schema.examples %}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "906264dd904a8f44a1533ffb70ec0cd6b9f92a4b",
      "candidate_info": {
        "commit_hash": "906264dd904a8f44a1533ffb70ec0cd6b9f92a4b",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/906264dd904a8f44a1533ffb70ec0cd6b9f92a4b",
        "files": [
          "airflow/utils/email.py"
        ],
        "message": "Add doc-strings and small improvement to email util (#28634)",
        "before_after_code_files": [
          "airflow/utils/email.py||airflow/utils/email.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "airflow/utils/email.py||airflow/utils/email.py"
          ],
          "candidate": [
            "airflow/utils/email.py||airflow/utils/email.py"
          ]
        }
      },
      "candidate_diff": {
        "airflow/utils/email.py||airflow/utils/email.py": [
          "File: airflow/utils/email.py -> airflow/utils/email.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: import collections.abc",
          "21: import logging",
          "22: import os",
          "23: import smtplib",
          "24: import warnings",
          "25: from email.mime.application import MIMEApplication",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: import re",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     conn_id: str | None = None,",
          "48:     custom_headers: dict[str, Any] | None = None,",
          "52:     backend = conf.getimport(\"email\", \"EMAIL_BACKEND\")",
          "53:     backend_conn_id = conn_id or conf.get(\"email\", \"EMAIL_CONN_ID\")",
          "54:     from_email = conf.get(\"email\", \"from_email\", fallback=None)",
          "",
          "[Removed Lines]",
          "50: ):",
          "51:     \"\"\"Send email using backend specified in EMAIL_BACKEND.\"\"\"",
          "",
          "[Added Lines]",
          "51: ) -> None:",
          "52:     \"\"\"",
          "53:     Send an email using the backend specified in the *EMAIL_BACKEND* configuration option.",
          "55:     :param to: A list or iterable of email addresses to send the email to.",
          "56:     :param subject: The subject of the email.",
          "57:     :param html_content: The content of the email in HTML format.",
          "58:     :param files: A list of paths to files to attach to the email.",
          "59:     :param dryrun: If *True*, the email will not actually be sent. Default: *False*.",
          "60:     :param cc: A string or iterable of strings containing email addresses to send a copy of the email to.",
          "61:     :param bcc: A string or iterable of strings containing email addresses to send a",
          "62:         blind carbon copy of the email to.",
          "63:     :param mime_subtype: The subtype of the MIME message. Default: \"mixed\".",
          "64:     :param mime_charset: The charset of the email. Default: \"utf-8\".",
          "65:     :param conn_id: The connection ID to use for the backend. If not provided, the default connection",
          "66:         specified in the *EMAIL_CONN_ID* configuration option will be used.",
          "67:     :param custom_headers: A dictionary of additional headers to add to the MIME message.",
          "68:         No validations are run on these values, and they should be able to be encoded.",
          "69:     :param kwargs: Additional keyword arguments to pass to the backend.",
          "70:     \"\"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:     from_email: str | None = None,",
          "88:     custom_headers: dict[str, Any] | None = None,",
          "94:     >>> send_email('test@example.com', 'foo', '<b>Foo</b> bar', ['/dev/null'], dryrun=True)",
          "95:     \"\"\"",
          "",
          "[Removed Lines]",
          "90: ):",
          "91:     \"\"\"",
          "92:     Send an email with html content",
          "",
          "[Added Lines]",
          "109: ) -> None:",
          "110:     \"\"\"Send an email with html content.",
          "112:     :param to: Recipient email address or list of addresses.",
          "113:     :param subject: Email subject.",
          "114:     :param html_content: Email body in HTML format.",
          "115:     :param files: List of file paths to attach to the email.",
          "116:     :param dryrun: If True, the email will not be sent, but all other actions will be performed.",
          "117:     :param cc: Carbon copy recipient email address or list of addresses.",
          "118:     :param bcc: Blind carbon copy recipient email address or list of addresses.",
          "119:     :param mime_subtype: MIME subtype of the email.",
          "120:     :param mime_charset: MIME charset of the email.",
          "121:     :param conn_id: Connection ID of the SMTP server.",
          "122:     :param from_email: Sender email address.",
          "123:     :param custom_headers: Dictionary of custom headers to include in the email.",
          "124:     :param kwargs: Additional keyword arguments.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "133:     custom_headers: dict[str, Any] | None = None,",
          "134: ) -> tuple[MIMEMultipart, list[str]]:",
          "135:     \"\"\"",
          "151:     \"\"\"",
          "152:     to = get_email_address_list(to)",
          "",
          "[Removed Lines]",
          "136:     Build a MIME message that can be used to send an email and",
          "137:     returns full list of recipients.",
          "139:     :param mail_from: Email address to set as email's from",
          "140:     :param to: List of email addresses to set as email's to",
          "141:     :param subject: Email's subject",
          "142:     :param html_content: Content of email in HTML format",
          "143:     :param files: List of paths of files to be attached",
          "144:     :param cc: List of email addresses to set as email's CC",
          "145:     :param bcc: List of email addresses to set as email's BCC",
          "146:     :param mime_subtype: Can be used to specify the subtype of the message. Default = mixed",
          "147:     :param mime_charset: Email's charset. Default = UTF-8.",
          "148:     :param custom_headers: Additional headers to add to the MIME message.",
          "149:         No validations are run on these values and they should be able to be encoded.",
          "150:     :return: Email as MIMEMultipart and list of recipients' addresses.",
          "",
          "[Added Lines]",
          "168:     Build a MIME message that can be used to send an email and returns a full list of recipients.",
          "170:     :param mail_from: Email address to set as the email's \"From\" field.",
          "171:     :param to: A string or iterable of strings containing email addresses to set as the email's \"To\" field.",
          "172:     :param subject: The subject of the email.",
          "173:     :param html_content: The content of the email in HTML format.",
          "174:     :param files: A list of paths to files to be attached to the email.",
          "175:     :param cc: A string or iterable of strings containing email addresses to set as the email's \"CC\" field.",
          "176:     :param bcc: A string or iterable of strings containing email addresses to set as the email's \"BCC\" field.",
          "177:     :param mime_subtype: The subtype of the MIME message. Default: \"mixed\".",
          "178:     :param mime_charset: The charset of the email. Default: \"utf-8\".",
          "179:     :param custom_headers: Additional headers to add to the MIME message. No validations are run on these",
          "180:         values, and they should be able to be encoded.",
          "181:     :return: A tuple containing the email as a MIMEMultipart object and a list of recipient email addresses.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "159:     if cc:",
          "160:         cc = get_email_address_list(cc)",
          "161:         msg[\"CC\"] = \", \".join(cc)",
          "164:     if bcc:",
          "165:         # don't add bcc in header",
          "166:         bcc = get_email_address_list(bcc)",
          "169:     msg[\"Date\"] = formatdate(localtime=True)",
          "170:     mime_text = MIMEText(html_content, \"html\", mime_charset)",
          "",
          "[Removed Lines]",
          "162:         recipients = recipients + cc",
          "167:         recipients = recipients + bcc",
          "",
          "[Added Lines]",
          "193:         recipients += cc",
          "198:         recipients += bcc",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "192:     conn_id: str = \"smtp_default\",",
          "193:     dryrun: bool = False,",
          "194: ) -> None:",
          "196:     smtp_host = conf.get_mandatory_value(\"smtp\", \"SMTP_HOST\")",
          "197:     smtp_port = conf.getint(\"smtp\", \"SMTP_PORT\")",
          "198:     smtp_starttls = conf.getboolean(\"smtp\", \"SMTP_STARTTLS\")",
          "",
          "[Removed Lines]",
          "195:     \"\"\"Send MIME email.\"\"\"",
          "",
          "[Added Lines]",
          "226:     \"\"\"",
          "227:     Send a MIME email.",
          "229:     :param e_from: The email address of the sender.",
          "230:     :param e_to: The email address or a list of email addresses of the recipient(s).",
          "231:     :param mime_msg: The MIME message to send.",
          "232:     :param conn_id: The ID of the SMTP connection to use.",
          "233:     :param dryrun: If True, the email will not be sent, but a log message will be generated.",
          "234:     \"\"\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "247: def get_email_address_list(addresses: str | Iterable[str]) -> list[str]:",
          "249:     if isinstance(addresses, str):",
          "250:         return _get_email_list_from_str(addresses)",
          "252:     elif isinstance(addresses, collections.abc.Iterable):",
          "253:         if not all(isinstance(item, str) for item in addresses):",
          "254:             raise TypeError(\"The items in your iterable must be strings.\")",
          "255:         return list(addresses)",
          "261: def _get_smtp_connection(host: str, port: int, timeout: int, with_ssl: bool) -> smtplib.SMTP:",
          "262:     return (",
          "263:         smtplib.SMTP_SSL(host=host, port=port, timeout=timeout)",
          "264:         if with_ssl",
          "",
          "[Removed Lines]",
          "248:     \"\"\"Get list of email addresses.\"\"\"",
          "257:     received_type = type(addresses).__name__",
          "258:     raise TypeError(f\"Unexpected argument type: Received '{received_type}'.\")",
          "",
          "[Added Lines]",
          "287:     \"\"\"",
          "288:     Returns a list of email addresses from the provided input.",
          "290:     :param addresses: A string or iterable of strings containing email addresses.",
          "291:     :return: A list of email addresses.",
          "292:     :raises TypeError: If the input is not a string or iterable of strings.",
          "293:     \"\"\"",
          "300:     else:",
          "301:         raise TypeError(f\"Unexpected argument type: Received '{type(addresses).__name__}'.\")",
          "305:     \"\"\"",
          "306:     Returns an SMTP connection to the specified host and port, with optional SSL encryption.",
          "308:     :param host: The hostname or IP address of the SMTP server.",
          "309:     :param port: The port number to connect to on the SMTP server.",
          "310:     :param timeout: The timeout in seconds for the connection.",
          "311:     :param with_ssl: Whether to use SSL encryption for the connection.",
          "312:     :return: An SMTP connection to the specified host and port.",
          "313:     \"\"\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "269: def _get_email_list_from_str(addresses: str) -> list[str]:",
          "",
          "[Removed Lines]",
          "270:     delimiters = [\",\", \";\"]",
          "271:     for delimiter in delimiters:",
          "272:         if delimiter in addresses:",
          "273:             return [address.strip() for address in addresses.split(delimiter)]",
          "274:     return [addresses]",
          "",
          "[Added Lines]",
          "322:     \"\"\"",
          "323:     Extract a list of email addresses from a string. The string",
          "324:     can contain multiple email addresses separated by",
          "325:     any of the following delimiters: ',' or ';'.",
          "327:     :param addresses: A string containing one or more email addresses.",
          "328:     :return: A list of email addresses.",
          "329:     \"\"\"",
          "330:     pattern = r\"\\s*[,;]\\s*\"",
          "331:     return [address for address in re.split(pattern, addresses)]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
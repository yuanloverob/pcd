{
  "cve_id": "CVE-2022-41672",
  "cve_desc": "In Apache Airflow, prior to version 2.4.1, deactivating a user wouldn't prevent an already authenticated user from being able to continue using the UI or API.",
  "repo": "apache/airflow",
  "patch_hash": "12bfb571a895a28a58d3189b0fc10cfc1b89e24c",
  "patch_info": {
    "commit_hash": "12bfb571a895a28a58d3189b0fc10cfc1b89e24c",
    "repo": "apache/airflow",
    "commit_url": "https://github.com/apache/airflow/commit/12bfb571a895a28a58d3189b0fc10cfc1b89e24c",
    "files": [
      "airflow/www/app.py",
      "airflow/www/extensions/init_security.py",
      "tests/test_utils/decorators.py",
      "tests/www/views/conftest.py",
      "tests/www/views/test_session.py",
      "tests/www/views/test_views_base.py"
    ],
    "message": "Check user is active (#26635)\n\n(cherry picked from commit 59707cdf7eacb698ca375b5220af30a39ca1018c)",
    "before_after_code_files": [
      "airflow/www/app.py||airflow/www/app.py",
      "airflow/www/extensions/init_security.py||airflow/www/extensions/init_security.py",
      "tests/test_utils/decorators.py||tests/test_utils/decorators.py",
      "tests/www/views/conftest.py||tests/www/views/conftest.py",
      "tests/www/views/test_session.py||tests/www/views/test_session.py",
      "tests/www/views/test_views_base.py||tests/www/views/test_views_base.py"
    ]
  },
  "patch_diff": {
    "airflow/www/app.py||airflow/www/app.py": [
      "File: airflow/www/app.py -> airflow/www/app.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "39: from airflow.www.extensions.init_jinja_globals import init_jinja_globals",
      "40: from airflow.www.extensions.init_manifest_files import configure_manifest_files",
      "41: from airflow.www.extensions.init_robots import init_robots",
      "43: from airflow.www.extensions.init_session import init_airflow_session_interface",
      "44: from airflow.www.extensions.init_views import (",
      "45:     init_api_connexion,",
      "",
      "[Removed Lines]",
      "42: from airflow.www.extensions.init_security import init_api_experimental_auth, init_xframe_protection",
      "",
      "[Added Lines]",
      "42: from airflow.www.extensions.init_security import (",
      "43:     init_api_experimental_auth,",
      "44:     init_check_user_active,",
      "45:     init_xframe_protection,",
      "46: )",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "152:         init_jinja_globals(flask_app)",
      "153:         init_xframe_protection(flask_app)",
      "154:         init_airflow_session_interface(flask_app)",
      "155:     return flask_app",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "159:         init_check_user_active(flask_app)",
      "",
      "---------------"
    ],
    "airflow/www/extensions/init_security.py||airflow/www/extensions/init_security.py": [
      "File: airflow/www/extensions/init_security.py -> airflow/www/extensions/init_security.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: import logging",
      "20: from importlib import import_module",
      "22: from airflow.configuration import conf",
      "23: from airflow.exceptions import AirflowConfigException, AirflowException",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "22: from flask import g, redirect, url_for",
      "23: from flask_login import logout_user",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:         except ImportError as err:",
      "61:             log.critical(\"Cannot import %s for API authentication due to: %s\", backend, err)",
      "62:             raise AirflowException(err)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "68: def init_check_user_active(app):",
      "69:     @app.before_request",
      "70:     def check_user_active():",
      "71:         if g.user is not None and not g.user.is_anonymous and not g.user.is_active:",
      "72:             logout_user()",
      "73:             return redirect(url_for(app.appbuilder.sm.auth_view.endpoint + \".login\"))",
      "",
      "---------------"
    ],
    "tests/test_utils/decorators.py||tests/test_utils/decorators.py": [
      "File: tests/test_utils/decorators.py -> tests/test_utils/decorators.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "45:             \"init_xframe_protection\",",
      "46:             \"init_airflow_session_interface\",",
      "47:             \"init_appbuilder\",",
      "48:         ]",
      "50:         @functools.wraps(f)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "48:             \"init_check_user_active\",",
      "",
      "---------------"
    ],
    "tests/www/views/conftest.py||tests/www/views/conftest.py": [
      "File: tests/www/views/conftest.py -> tests/www/views/conftest.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "58:             \"init_jinja_globals\",",
      "59:             \"init_plugins\",",
      "60:             \"init_airflow_session_interface\",",
      "61:         ]",
      "62:     )",
      "63:     def factory():",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61:             \"init_check_user_active\",",
      "",
      "---------------"
    ],
    "tests/www/views/test_session.py||tests/www/views/test_session.py": [
      "File: tests/www/views/test_session.py -> tests/www/views/test_session.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "88:     new_session_cookie = get_session_cookie(user_client)",
      "89:     assert new_session_cookie is not None",
      "90:     assert old_session_cookie.value != new_session_cookie.value",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "93: def test_check_active_user(app, user_client):",
      "94:     user = app.appbuilder.sm.find_user(username=\"test_user\")",
      "95:     user.active = False",
      "96:     resp = user_client.get(\"/home\")",
      "97:     assert resp.status_code == 302",
      "98:     assert \"/login\" in resp.headers.get(\"Location\")",
      "100:     # And they were logged out",
      "101:     user.active = True",
      "102:     resp = user_client.get(\"/home\")",
      "103:     assert resp.status_code == 302",
      "104:     assert \"/login\" in resp.headers.get(\"Location\")",
      "",
      "---------------"
    ],
    "tests/www/views/test_views_base.py||tests/www/views/test_views_base.py": [
      "File: tests/www/views/test_views_base.py -> tests/www/views/test_views_base.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: from tests.test_utils.www import check_content_in_response, check_content_not_in_response",
      "34:     with assert_queries_count(16):",
      "36:     check_content_in_response('DAGs', resp)",
      "",
      "[Removed Lines]",
      "33: def test_index(admin_client):",
      "35:         resp = admin_client.get('/', follow_redirects=True)",
      "",
      "[Added Lines]",
      "33: def test_index_redirect(admin_client):",
      "34:     resp = admin_client.get('/')",
      "35:     assert resp.status_code == 302",
      "36:     assert '/home' in resp.headers.get(\"Location\")",
      "38:     resp = admin_client.get('/', follow_redirects=True)",
      "39:     check_content_in_response('DAGs', resp)",
      "42: def test_homepage_query_count(admin_client):",
      "44:         resp = admin_client.get('/home')",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "22f6c84a85ad0ce27a9679b48777009a5ac1e1f3",
      "candidate_info": {
        "commit_hash": "22f6c84a85ad0ce27a9679b48777009a5ac1e1f3",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/22f6c84a85ad0ce27a9679b48777009a5ac1e1f3",
        "files": [
          "airflow/configuration.py"
        ],
        "message": "Log warning when secret backend kwargs is invalid (#26580)\n\nThis should help debugging a bit.\n\n(cherry picked from commit 2060ed43955e09792cb9888deea0da239b7eee09)",
        "before_after_code_files": [
          "airflow/configuration.py||airflow/configuration.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/26688"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/configuration.py||airflow/configuration.py": [
          "File: airflow/configuration.py -> airflow/configuration.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1542:     \"\"\"Get Secret Backend if defined in airflow.cfg\"\"\"",
          "1543:     secrets_backend_cls = conf.getimport(section='secrets', key='backend')",
          "1556: def initialize_secrets_backends() -> list[BaseSecretsBackend]:",
          "",
          "[Removed Lines]",
          "1545:     if secrets_backend_cls:",
          "1546:         try:",
          "1547:             backends: Any = conf.get(section='secrets', key='backend_kwargs', fallback='{}')",
          "1548:             alternative_secrets_config_dict = json.loads(backends)",
          "1549:         except JSONDecodeError:",
          "1550:             alternative_secrets_config_dict = {}",
          "1552:         return secrets_backend_cls(**alternative_secrets_config_dict)",
          "1553:     return None",
          "",
          "[Added Lines]",
          "1545:     if not secrets_backend_cls:",
          "1546:         return None",
          "1548:     try:",
          "1549:         backend_kwargs = conf.getjson(section='secrets', key='backend_kwargs')",
          "1550:         if not backend_kwargs:",
          "1551:             backend_kwargs = {}",
          "1552:         elif not isinstance(backend_kwargs, dict):",
          "1553:             raise ValueError(\"not a dict\")",
          "1554:     except AirflowConfigException:",
          "1555:         log.warning(\"Failed to parse [secrets] backend_kwargs as JSON, defaulting to no kwargs.\")",
          "1556:         backend_kwargs = {}",
          "1557:     except ValueError:",
          "1558:         log.warning(\"Failed to parse [secrets] backend_kwargs into a dict, defaulting to no kwargs.\")",
          "1559:         backend_kwargs = {}",
          "1561:     return secrets_backend_cls(**backend_kwargs)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1723b86a8dd1a9a5c903abb369bb5b548033723e",
      "candidate_info": {
        "commit_hash": "1723b86a8dd1a9a5c903abb369bb5b548033723e",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/1723b86a8dd1a9a5c903abb369bb5b548033723e",
        "files": [
          "airflow/www/extensions/init_wsgi_middlewares.py"
        ],
        "message": "fix WSGI root app (#26549)\n\n* fix WSGI root app\n\nThe `start_response()` callable expects a string in argument `status`.\nSee <https://peps.python.org/pep-0333/#the-start-response-callable>.\n\nSigned-off-by: Steffen Prohaska <prohaska@zib.de>\n\n* Better type WSGI middleware\n\nThis provides typing guardrails for the middleware callable.\n\nSigned-off-by: Steffen Prohaska <prohaska@zib.de>\nCo-authored-by: Tzu-ping Chung <uranusjr@gmail.com>\n(cherry picked from commit 39f99ec612ed3a56b033c7a21c93000b7e1a59b5)",
        "before_after_code_files": [
          "airflow/www/extensions/init_wsgi_middlewares.py||airflow/www/extensions/init_wsgi_middlewares.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/26688"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/www/extensions/init_wsgi_middlewares.py||airflow/www/extensions/init_wsgi_middlewares.py": [
          "File: airflow/www/extensions/init_wsgi_middlewares.py -> airflow/www/extensions/init_wsgi_middlewares.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: # KIND, either express or implied.  See the License for the",
          "15: # specific language governing permissions and limitations",
          "16: # under the License.",
          "17: from __future__ import annotations",
          "19: from urllib.parse import urlparse",
          "21: from flask import Flask",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: from typing import TYPE_CHECKING, Iterable",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: from airflow.configuration import conf",
          "30:     return [b'Apache Airflow is not at this location']",
          "34:     \"\"\"Handle X-Forwarded-* headers and base_url support\"\"\"",
          "35:     # Apply DispatcherMiddleware",
          "36:     base_url = urlparse(conf.get('webserver', 'base_url'))[2]",
          "37:     if not base_url or base_url == '/':",
          "38:         base_url = \"\"",
          "39:     if base_url:",
          "44:     # Apply ProxyFix middleware",
          "45:     if conf.getboolean('webserver', 'ENABLE_PROXY_FIX'):",
          "",
          "[Removed Lines]",
          "28: def _root_app(_, resp):",
          "29:     resp(b'404 Not Found', [('Content-Type', 'text/plain')])",
          "33: def init_wsgi_middleware(flask_app: Flask):",
          "40:         flask_app.wsgi_app = DispatcherMiddleware(  # type: ignore",
          "41:             _root_app, mounts={base_url: flask_app.wsgi_app}  # type: ignore",
          "42:         )",
          "",
          "[Added Lines]",
          "29: if TYPE_CHECKING:",
          "30:     from _typeshed.wsgi import StartResponse, WSGIEnvironment",
          "33: def _root_app(env: WSGIEnvironment, resp: StartResponse) -> Iterable[bytes]:",
          "34:     resp('404 Not Found', [('Content-Type', 'text/plain')])",
          "38: def init_wsgi_middleware(flask_app: Flask) -> None:",
          "45:         wsgi_app = DispatcherMiddleware(_root_app, mounts={base_url: flask_app.wsgi_app})",
          "46:         flask_app.wsgi_app = wsgi_app  # type: ignore[assignment]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "45a461b37dcd9c8b97952ab535a7c057f1e944bd",
      "candidate_info": {
        "commit_hash": "45a461b37dcd9c8b97952ab535a7c057f1e944bd",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/45a461b37dcd9c8b97952ab535a7c057f1e944bd",
        "files": [
          "airflow/models/xcom_arg.py"
        ],
        "message": "Fix xcom arg.py .zip bug (#26636)\n\n(cherry picked from commit f219bfbe22e662a8747af19d688bbe843e1a953d)",
        "before_after_code_files": [
          "airflow/models/xcom_arg.py||airflow/models/xcom_arg.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/26688"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/models/xcom_arg.py||airflow/models/xcom_arg.py": [
          "File: airflow/models/xcom_arg.py -> airflow/models/xcom_arg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: from airflow.utils.context import Context",
          "32: from airflow.utils.edgemodifier import EdgeModifier",
          "33: from airflow.utils.session import NEW_SESSION, provide_session",
          "36: if TYPE_CHECKING:",
          "37:     from airflow.models.dag import DAG",
          "",
          "[Removed Lines]",
          "34: from airflow.utils.types import NOTSET",
          "",
          "[Added Lines]",
          "34: from airflow.utils.types import NOTSET, ArgNotSet",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "322:     def resolve(self, context: Context, session: Session = NEW_SESSION) -> Any:",
          "323:         task_id = self.operator.task_id",
          "324:         result = context[\"ti\"].xcom_pull(task_ids=task_id, key=str(self.key), default=NOTSET, session=session)",
          "326:             return result",
          "327:         if self.key == XCOM_RETURN_KEY:",
          "328:             return None",
          "",
          "[Removed Lines]",
          "325:         if result is not NOTSET:",
          "",
          "[Added Lines]",
          "325:         if not isinstance(result, ArgNotSet):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "438:     def __len__(self) -> int:",
          "439:         lengths = (len(v) for v in self.values)",
          "441:             return min(lengths)",
          "442:         return max(lengths)",
          "",
          "[Removed Lines]",
          "440:         if self.fillvalue is NOTSET:",
          "",
          "[Added Lines]",
          "440:         if isinstance(self.fillvalue, ArgNotSet):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "460:         args_iter = iter(self.args)",
          "461:         first = repr(next(args_iter))",
          "462:         rest = \", \".join(repr(arg) for arg in args_iter)",
          "464:             return f\"{first}.zip({rest})\"",
          "465:         return f\"{first}.zip({rest}, fillvalue={self.fillvalue!r})\"",
          "467:     def _serialize(self) -> dict[str, Any]:",
          "468:         args = [serialize_xcom_arg(arg) for arg in self.args]",
          "470:             return {\"args\": args}",
          "471:         return {\"args\": args, \"fillvalue\": self.fillvalue}",
          "",
          "[Removed Lines]",
          "463:         if self.fillvalue is NOTSET:",
          "469:         if self.fillvalue is NOTSET:",
          "",
          "[Added Lines]",
          "463:         if isinstance(self.fillvalue, ArgNotSet):",
          "469:         if isinstance(self.fillvalue, ArgNotSet):",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "486:         ready_lengths = [length for length in all_lengths if length is not None]",
          "487:         if len(ready_lengths) != len(self.args):",
          "488:             return None  # If any of the referenced XComs is not ready, we are not ready either.",
          "490:             return min(ready_lengths)",
          "491:         return max(ready_lengths)",
          "",
          "[Removed Lines]",
          "489:         if self.fillvalue is NOTSET:",
          "",
          "[Added Lines]",
          "489:         if isinstance(self.fillvalue, ArgNotSet):",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4ae13d9d68c3b4366b54bff8f7bb833c3fe65cef",
      "candidate_info": {
        "commit_hash": "4ae13d9d68c3b4366b54bff8f7bb833c3fe65cef",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/4ae13d9d68c3b4366b54bff8f7bb833c3fe65cef",
        "files": [
          "airflow/models/xcom_arg.py",
          "tests/models/test_xcom_arg.py"
        ],
        "message": "Allow MapXComArg to resolve after serialization  (#26591)\n\nThis is useful for cases where we want to resolve an XCom without\nrunning a worker, e.g. to display the value in UI.\n\nSince we don't want to actually call the mapper function in this case\n(the function is arbitrary code, and not running it is the entire point\nto serialize operators), \"resolving\" the XComArg in this case would\nmerely produce some kind of quasi-meaningful string representation,\ninstead of the actual value we'd get in the worker.\n\nAlso note that this only affects a very small number of cases, since\nonce a worker is run for the task instance, RenderedTaskInstanceFields\nwould store the real resolved value and take over UI representation,\navoiding this fake resolving logic to be accessed at all.\n\n(cherry picked from commit 3e01c0d97aeefce303e1fdb5cef160f192cce4fa)",
        "before_after_code_files": [
          "airflow/models/xcom_arg.py||airflow/models/xcom_arg.py",
          "tests/models/test_xcom_arg.py||tests/models/test_xcom_arg.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/26688"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/models/xcom_arg.py||airflow/models/xcom_arg.py": [
          "File: airflow/models/xcom_arg.py -> airflow/models/xcom_arg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: # KIND, either express or implied.  See the License for the",
          "15: # specific language governing permissions and limitations",
          "16: # under the License.",
          "17: from __future__ import annotations",
          "19: import inspect",
          "22: from sqlalchemy import func",
          "23: from sqlalchemy.orm import Session",
          "",
          "[Removed Lines]",
          "20: from typing import TYPE_CHECKING, Any, Callable, Iterator, Mapping, Sequence, overload",
          "",
          "[Added Lines]",
          "20: import contextlib",
          "22: from typing import TYPE_CHECKING, Any, Callable, Iterator, Mapping, Sequence, Union, overload",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:     from airflow.models.dag import DAG",
          "36:     from airflow.models.operator import Operator",
          "39: class XComArg(DependencyMixin):",
          "40:     \"\"\"Reference to an XCom value pushed from another operator.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: # Callable objects contained by MapXComArg. We only accept callables from",
          "41: # the user, but deserialize them into strings in a serialized XComArg for",
          "42: # safety (those callables are arbitrary user code).",
          "43: MapCallables = Sequence[Union[Callable[[Any], Any], str]]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "322:         raise XComNotFound(context[\"ti\"].dag_id, task_id, self.key)",
          "325: class _MapResult(Sequence):",
          "327:         self.value = value",
          "328:         self.callables = callables",
          "330:     def __getitem__(self, index: Any) -> Any:",
          "331:         value = self.value[index]",
          "334:         return value",
          "336:     def __len__(self) -> int:",
          "",
          "[Removed Lines]",
          "326:     def __init__(self, value: Sequence | dict, callables: Sequence[Callable[[Any], Any]]) -> None:",
          "332:         for f in self.callables:",
          "333:             value = f(value)",
          "",
          "[Added Lines]",
          "332: def _get_callable_name(f: Callable | str) -> str:",
          "333:     \"\"\"Try to \"describe\" a callable by getting its name.\"\"\"",
          "334:     if callable(f):",
          "335:         return f.__name__",
          "336:     # Parse the source to find whatever is behind \"def\". For safety, we don't",
          "337:     # want to evaluate the code in any meaningful way!",
          "338:     with contextlib.suppress(Exception):",
          "339:         kw, name, _ = f.lstrip().split(None, 2)",
          "340:         if kw == \"def\":",
          "341:             return name",
          "342:     return \"<function>\"",
          "346:     def __init__(self, value: Sequence | dict, callables: MapCallables) -> None:",
          "353:         # In the worker, we can access all actual callables. Call them.",
          "354:         callables = [f for f in self.callables if callable(f)]",
          "355:         if len(callables) == len(self.callables):",
          "356:             for f in callables:",
          "357:                 value = f(value)",
          "358:             return value",
          "360:         # In the scheduler, we don't have access to the actual callables, nor do",
          "361:         # we want to run it since it's arbitrary code. This builds a string to",
          "362:         # represent the call chain in the UI or logs instead.",
          "363:         for v in self.callables:",
          "364:             value = f\"{_get_callable_name(v)}({value})\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "343:     This is based on an XComArg, but also applies a series of \"transforms\" that",
          "344:     convert the pulled XCom value.",
          "345:     \"\"\"",
          "348:         for c in callables:",
          "349:             if getattr(c, \"_airflow_is_task_decorator\", False):",
          "350:                 raise ValueError(\"map() argument must be a plain function, not a @task operator\")",
          "",
          "[Removed Lines]",
          "347:     def __init__(self, arg: XComArg, callables: Sequence[Callable[[Any], Any]]) -> None:",
          "",
          "[Added Lines]",
          "377:     :meta private:",
          "380:     def __init__(self, arg: XComArg, callables: MapCallables) -> None:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "352:         self.callables = callables",
          "354:     def __repr__(self) -> str:",
          "357:     def _serialize(self) -> dict[str, Any]:",
          "358:         return {",
          "359:             \"arg\": serialize_xcom_arg(self.arg),",
          "361:         }",
          "363:     @classmethod",
          "",
          "[Removed Lines]",
          "355:         return f\"{self.arg!r}.map([{len(self.callables)} functions])\"",
          "360:             \"callables\": [inspect.getsource(c) for c in self.callables],",
          "",
          "[Added Lines]",
          "388:         map_calls = \"\".join(f\".map({_get_callable_name(f)})\" for f in self.callables)",
          "389:         return f\"{self.arg!r}{map_calls}\"",
          "394:             \"callables\": [inspect.getsource(c) if callable(c) else c for c in self.callables],",
          "",
          "---------------"
        ],
        "tests/models/test_xcom_arg.py||tests/models/test_xcom_arg.py": [
          "File: tests/models/test_xcom_arg.py -> tests/models/test_xcom_arg.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "212:     # Run \"push_letters\" and \"push_numbers\".",
          "213:     decision = dr.task_instance_scheduling_decisions(session=session)",
          "215:     for ti in decision.schedulable_tis:",
          "216:         ti.run(session=session)",
          "217:     session.commit()",
          "219:     # Run \"pull\".",
          "220:     decision = dr.task_instance_scheduling_decisions(session=session)",
          "222:     for ti in decision.schedulable_tis:",
          "223:         ti.run(session=session)",
          "",
          "[Removed Lines]",
          "214:     assert decision.schedulable_tis and all(ti.task_id.startswith(\"push_\") for ti in decision.schedulable_tis)",
          "221:     assert decision.schedulable_tis and all(ti.task_id == \"pull\" for ti in decision.schedulable_tis)",
          "",
          "[Added Lines]",
          "214:     assert sorted(ti.task_id for ti in decision.schedulable_tis) == [\"push_letters\", \"push_numbers\"]",
          "221:     assert sorted(ti.task_id for ti in decision.schedulable_tis) == [\"pull\"] * len(expected_results)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d81b2971bc4384775deff49522458d434255ca46",
      "candidate_info": {
        "commit_hash": "d81b2971bc4384775deff49522458d434255ca46",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/d81b2971bc4384775deff49522458d434255ca46",
        "files": [
          "airflow/www/utils.py",
          "airflow/www/views.py"
        ],
        "message": "Use COALESCE when ordering runs to handle NULL (#26626)\n\nData interval columns are NULL for runs created before 2.3, but SQL's\nNULL-sorting logic would make those old runs always appear first. In a\nperfect world we'd want to sort by get_run_data_interval(), but that's\nnot efficient, so instead the columns are coalesced into logical date,\nwhich is good enough in most cases.\n\n(cherry picked from commit 22d52c00f6397fde8d97cf2479c0614671f5b5ba)",
        "before_after_code_files": [
          "airflow/www/utils.py||airflow/www/utils.py",
          "airflow/www/views.py||airflow/www/views.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/26688"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/www/utils.py||airflow/www/utils.py": [
          "File: airflow/www/utils.py -> airflow/www/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: import json",
          "21: import textwrap",
          "22: import time",
          "24: from urllib.parse import urlencode",
          "27: from flask import request, url_for",
          "28: from flask.helpers import flash",
          "29: from flask_appbuilder.forms import FieldConverter",
          "",
          "[Removed Lines]",
          "23: from typing import Any",
          "26: import sqlalchemy as sqla",
          "",
          "[Added Lines]",
          "23: from typing import TYPE_CHECKING, Any, Sequence",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: from pendulum.datetime import DateTime",
          "38: from pygments import highlight, lexers",
          "39: from pygments.formatters import HtmlFormatter",
          "40: from sqlalchemy.ext.associationproxy import AssociationProxy",
          "43: from airflow.exceptions import RemovedInAirflow3Warning",
          "44: from airflow.models import errors",
          "45: from airflow.models.dagwarning import DagWarning",
          "46: from airflow.models.taskinstance import TaskInstance",
          "47: from airflow.utils import timezone",
          "",
          "[Removed Lines]",
          "42: from airflow import models",
          "",
          "[Added Lines]",
          "39: from sqlalchemy import func, types",
          "44: from airflow.models.dagrun import DagRun",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51: from airflow.www.forms import DateTimeWithTimezoneField",
          "52: from airflow.www.widgets import AirflowDateTimePickerWidget",
          "55: def datetime_to_string(value: DateTime | None) -> str | None:",
          "56:     if value is None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: if TYPE_CHECKING:",
          "55:     from sqlalchemy.orm.query import Query",
          "56:     from sqlalchemy.sql.operators import ColumnOperators",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "129:     }",
          "133:     if not dag_run:",
          "134:         return None",
          "",
          "[Removed Lines]",
          "132: def encode_dag_run(dag_run: models.DagRun | None) -> dict[str, Any] | None:",
          "",
          "[Added Lines]",
          "136: def encode_dag_run(dag_run: DagRun | None) -> dict[str, Any] | None:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "436:     return Markup('<a href=\"{url}\">{run_id}</a>').format(url=url, run_id=run_id)",
          "439: def format_map_index(attr: dict) -> str:",
          "440:     \"\"\"Format map index for list columns in model view.\"\"\"",
          "441:     value = attr['map_index']",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443: def _get_run_ordering_expr(name: str) -> ColumnOperators:",
          "444:     expr = DagRun.__table__.columns[name]",
          "445:     # Data interval columns are NULL for runs created before 2.3, but SQL's",
          "446:     # NULL-sorting logic would make those old runs always appear first. In a",
          "447:     # perfect world we'd want to sort by ``get_run_data_interval()``, but that's",
          "448:     # not efficient, so instead the columns are coalesced into execution_date,",
          "449:     # which is good enough in most cases.",
          "450:     if name in (\"data_interval_start\", \"data_interval_end\"):",
          "451:         expr = func.coalesce(expr, DagRun.execution_date)",
          "452:     return expr.desc()",
          "455: def sorted_dag_runs(query: Query, *, ordering: Sequence[str], limit: int) -> Sequence[DagRun]:",
          "456:     \"\"\"Produce DAG runs sorted by specified columns.",
          "458:     :param query: An ORM query object against *DagRun*.",
          "459:     :param ordering: Column names to sort the runs. should generally come from a",
          "460:         timetable's ``run_ordering``.",
          "461:     :param limit: Number of runs to limit to.",
          "462:     :return: A list of DagRun objects ordered by the specified columns. The list",
          "463:         contains only the *last* objects, but in *ascending* order.",
          "464:     \"\"\"",
          "465:     ordering_exprs = (_get_run_ordering_expr(name) for name in ordering)",
          "466:     runs = query.order_by(*ordering_exprs, DagRun.id.desc()).limit(limit).all()",
          "467:     runs.reverse()",
          "468:     return runs",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "651:             obj = self.list_columns[col_name].type",
          "652:             return (",
          "653:                 isinstance(obj, UtcDateTime)",
          "655:                 and isinstance(obj.impl, UtcDateTime)",
          "656:             )",
          "657:         return False",
          "",
          "[Removed Lines]",
          "654:                 or isinstance(obj, sqla.types.TypeDecorator)",
          "",
          "[Added Lines]",
          "686:                 or isinstance(obj, types.TypeDecorator)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "664:             obj = self.list_columns[col_name].type",
          "665:             return (",
          "666:                 isinstance(obj, ExtendedJSON)",
          "668:                 and isinstance(obj.impl, ExtendedJSON)",
          "669:             )",
          "670:         return False",
          "",
          "[Removed Lines]",
          "667:                 or isinstance(obj, sqla.types.TypeDecorator)",
          "",
          "[Added Lines]",
          "699:                 or isinstance(obj, types.TypeDecorator)",
          "",
          "---------------"
        ],
        "airflow/www/views.py||airflow/www/views.py": [
          "File: airflow/www/views.py -> airflow/www/views.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3454:             if run_state:",
          "3455:                 query = query.filter(DagRun.state == run_state)",
          "3461:             encoded_runs = [wwwutils.encode_dag_run(dr) for dr in dag_runs]",
          "3462:             data = {",
          "3463:                 'groups': dag_to_grid(dag, dag_runs, session),",
          "",
          "[Removed Lines]",
          "3457:             ordering = (DagRun.__table__.columns[name].desc() for name in dag.timetable.run_ordering)",
          "3458:             dag_runs = query.order_by(*ordering, DagRun.id.desc()).limit(num_runs).all()",
          "3459:             dag_runs.reverse()",
          "",
          "[Added Lines]",
          "3457:             dag_runs = wwwutils.sorted_dag_runs(query, ordering=dag.timetable.run_ordering, limit=num_runs)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
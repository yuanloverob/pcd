{
  "cve_id": "CVE-2023-27483",
  "cve_desc": "crossplane-runtime is a set of go libraries used to build Kubernetes controllers in Crossplane and its related stacks. An out of memory panic vulnerability has been discovered in affected versions. Applications that use the `Paved` type's `SetValue` method with user provided input without proper validation might use excessive amounts of memory and cause an out of memory panic. In the fieldpath package, the Paved.SetValue method sets a value on the Paved object according to the provided path, without any validation. This allows setting values in slices at any provided index, which grows the target array up to the requested index, the index is currently capped at max uint32 (4294967295) given how indexes are parsed,  but that is still an unnecessarily large value. If callers are not validating paths' indexes on their own, which most probably are not going to do, given that the input is parsed directly in the SetValue method, this could allow users to consume arbitrary amounts of memory. Applications that do not use the `Paved` type's `SetValue` method are not affected. This issue has been addressed in versions 0.16.1 and 0.19.2. Users are advised to upgrade. Users unable to upgrade can parse and validate the path before passing it to the `SetValue` method of the `Paved` type, constraining the index size as deemed appropriate.",
  "repo": "crossplane/crossplane-runtime",
  "patch_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
  "patch_info": {
    "commit_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "repo": "crossplane/crossplane-runtime",
    "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "files": [
      "pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go"
    ],
    "message": "Add a package for getting and setting unstructured fields by path\n\nhttps://github.com/kubernetes-sigs/kustomize/blob/d190e1/api/k8sdeps/kunstruct/helper.go\nhttps://github.com/kubernetes/apimachinery/blob/2373d0/pkg/apis/meta/v1/unstructured/helpers.go\n\nThis package is similar to the above two, with some key differences:\n\n* Our fieldpath lexer is a little stricter; it won't allow dangling open braces,\n  unexpected periods, or empty brackets. It also supplies the position of any\n  syntax error if lexing fails.\n* We support setting and getting fields within a pkg/json unmarshalled object by\n  fieldpath. Other packages support only getting fields, or only setting fields\n  in paths that do not contain any array indexes.\n\nSigned-off-by: Nic Cope <negz@rk0n.org>",
    "before_after_code_files": [
      "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
    ]
  },
  "patch_diff": {
    "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
      "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "43: package fieldpath",
      "45: import (",
      "46:  \"fmt\"",
      "47:  \"strconv\"",
      "48:  \"strings\"",
      "49:  \"unicode/utf8\"",
      "51:  \"github.com/pkg/errors\"",
      "52: )",
      "56: type SegmentType int",
      "59: const (",
      "60:  _ SegmentType = iota",
      "61:  SegmentField",
      "62:  SegmentIndex",
      "63: )",
      "66: type Segment struct {",
      "67:  Type  SegmentType",
      "68:  Field string",
      "69:  Index uint",
      "70: }",
      "73: type Segments []Segment",
      "75: func (sg Segments) String() string {",
      "76:  var b strings.Builder",
      "78:  for _, s := range sg {",
      "79:   switch s.Type {",
      "80:   case SegmentField:",
      "81:    if strings.ContainsRune(s.Field, period) {",
      "82:     b.WriteString(fmt.Sprintf(\"[%s]\", s.Field))",
      "83:     continue",
      "84:    }",
      "85:    b.WriteString(fmt.Sprintf(\".%s\", s.Field))",
      "86:   case SegmentIndex:",
      "87:    b.WriteString(fmt.Sprintf(\"[%d]\", s.Index))",
      "88:   }",
      "89:  }",
      "91:  return strings.TrimPrefix(b.String(), \".\")",
      "92: }",
      "98: func FieldOrIndex(s string) Segment {",
      "102:  if i, err := strconv.ParseUint(s, 10, 32); err == nil {",
      "103:   return Segment{Type: SegmentIndex, Index: uint(i)}",
      "104:  }",
      "108:  return Field(s)",
      "109: }",
      "113: func Field(s string) Segment {",
      "114:  return Segment{Type: SegmentField, Field: strings.Trim(s, \"'\\\"\")}",
      "115: }",
      "118: func Parse(path string) (Segments, error) {",
      "119:  l := &lexer{input: path, items: make(chan item)}",
      "120:  go l.run()",
      "122:  segments := make(Segments, 0, 1)",
      "123:  for i := range l.items {",
      "124:   switch i.typ {",
      "125:   case itemField:",
      "126:    segments = append(segments, Field(i.val))",
      "127:   case itemFieldOrIndex:",
      "128:    segments = append(segments, FieldOrIndex(i.val))",
      "129:   case itemError:",
      "130:    return nil, errors.Errorf(\"%s at position %d\", i.val, i.pos)",
      "131:   }",
      "132:  }",
      "133:  return segments, nil",
      "134: }",
      "136: const (",
      "137:  period       = '.'",
      "138:  leftBracket  = '['",
      "139:  rightBracket = ']'",
      "140: )",
      "142: type itemType int",
      "144: const (",
      "145:  itemError itemType = iota",
      "146:  itemPeriod",
      "147:  itemLeftBracket",
      "148:  itemRightBracket",
      "149:  itemField",
      "150:  itemFieldOrIndex",
      "151:  itemEOL",
      "152: )",
      "154: type item struct {",
      "155:  typ itemType",
      "156:  pos int",
      "157:  val string",
      "158: }",
      "160: type stateFn func(*lexer) stateFn",
      "164: type lexer struct {",
      "165:  input string",
      "166:  pos   int",
      "167:  start int",
      "168:  items chan item",
      "169: }",
      "171: func (l *lexer) run() {",
      "172:  for state := lexField; state != nil; {",
      "173:   state = state(l)",
      "174:  }",
      "175:  close(l.items)",
      "176: }",
      "178: func (l *lexer) emit(t itemType) {",
      "180:  if l.pos <= l.start {",
      "181:   return",
      "182:  }",
      "183:  l.items <- item{typ: t, pos: l.start, val: l.input[l.start:l.pos]}",
      "184:  l.start = l.pos",
      "185: }",
      "187: func (l *lexer) errorf(pos int, format string, args ...interface{}) stateFn {",
      "188:  l.items <- item{typ: itemError, pos: pos, val: fmt.Sprintf(format, args...)}",
      "189:  return nil",
      "190: }",
      "192: func lexField(l *lexer) stateFn {",
      "193:  for i, r := range l.input[l.pos:] {",
      "194:   switch r {",
      "196:   case rightBracket:",
      "197:    return l.errorf(l.pos+i, \"unexpected %q\", rightBracket)",
      "200:   case leftBracket:",
      "201:    l.pos += i",
      "202:    l.emit(itemField)",
      "203:    return lexLeftBracket",
      "206:   case period:",
      "207:    l.pos += i",
      "208:    l.emit(itemField)",
      "209:    return lexPeriod",
      "210:   }",
      "211:  }",
      "214:  l.pos = len(l.input)",
      "215:  l.emit(itemField)",
      "216:  l.emit(itemEOL)",
      "217:  return nil",
      "218: }",
      "220: func lexPeriod(l *lexer) stateFn {",
      "222:  if l.pos == 0 || l.pos == len(l.input)-1 {",
      "223:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "224:  }",
      "226:  l.pos += utf8.RuneLen(period)",
      "227:  l.emit(itemPeriod)",
      "231:  r, _ := utf8.DecodeRuneInString(l.input[l.pos:])",
      "232:  if r == period {",
      "233:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "234:  }",
      "235:  if r == leftBracket {",
      "236:   return l.errorf(l.pos, \"unexpected %q\", leftBracket)",
      "237:  }",
      "239:  return lexField",
      "240: }",
      "242: func lexLeftBracket(l *lexer) stateFn {",
      "244:  if !strings.ContainsRune(l.input[l.pos:], rightBracket) {",
      "245:   return l.errorf(l.pos, \"unterminated %q\", leftBracket)",
      "246:  }",
      "248:  l.pos += utf8.RuneLen(leftBracket)",
      "249:  l.emit(itemLeftBracket)",
      "250:  return lexFieldOrIndex",
      "251: }",
      "255: func lexFieldOrIndex(l *lexer) stateFn {",
      "258:  rbi := strings.IndexRune(l.input[l.pos:], rightBracket)",
      "261:  if rbi == 0 {",
      "262:   return l.errorf(l.pos, \"unexpected %q\", rightBracket)",
      "263:  }",
      "266:  if lbi := strings.IndexRune(l.input[l.pos:l.pos+rbi], leftBracket); lbi > -1 {",
      "267:   return l.errorf(l.pos+lbi, \"unexpected %q\", leftBracket)",
      "268:  }",
      "271:  l.pos += rbi",
      "272:  l.emit(itemFieldOrIndex)",
      "273:  return lexRightBracket",
      "274: }",
      "276: func lexRightBracket(l *lexer) stateFn {",
      "277:  l.pos += utf8.RuneLen(rightBracket)",
      "278:  l.emit(itemRightBracket)",
      "279:  return lexField",
      "280: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go": [
      "File: pkg/fieldpath/fieldpath_test.go -> pkg/fieldpath/fieldpath_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"math\"",
      "21:  \"strconv\"",
      "22:  \"testing\"",
      "24:  \"github.com/google/go-cmp/cmp\"",
      "25:  \"github.com/pkg/errors\"",
      "27:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "28: )",
      "30: func TestSegments(t *testing.T) {",
      "31:  cases := map[string]struct {",
      "32:   s    Segments",
      "33:   want string",
      "34:  }{",
      "35:   \"SingleField\": {",
      "36:    s:    Segments{Field(\"spec\")},",
      "37:    want: \"spec\",",
      "38:   },",
      "39:   \"SingleIndex\": {",
      "40:    s:    Segments{FieldOrIndex(\"0\")},",
      "41:    want: \"[0]\",",
      "42:   },",
      "43:   \"FieldsAndIndex\": {",
      "44:    s: Segments{",
      "45:     Field(\"spec\"),",
      "46:     Field(\"containers\"),",
      "47:     FieldOrIndex(\"0\"),",
      "48:     Field(\"name\"),",
      "49:    },",
      "50:    want: \"spec.containers[0].name\",",
      "51:   },",
      "52:   \"PeriodsInField\": {",
      "53:    s: Segments{",
      "54:     Field(\"data\"),",
      "55:     Field(\".config.yml\"),",
      "56:    },",
      "57:    want: \"data[.config.yml]\",",
      "58:   },",
      "59:  }",
      "61:  for name, tc := range cases {",
      "62:   t.Run(name, func(t *testing.T) {",
      "63:    if diff := cmp.Diff(tc.want, tc.s.String()); diff != \"\" {",
      "64:     t.Errorf(\"s.String(): -want, +got:\\n %s\", diff)",
      "65:    }",
      "67:   })",
      "68:  }",
      "69: }",
      "71: func TestFieldOrIndex(t *testing.T) {",
      "72:  cases := map[string]struct {",
      "73:   reason string",
      "74:   s      string",
      "75:   want   Segment",
      "76:  }{",
      "77:   \"Field\": {",
      "78:    reason: \"An unambiguous string should be interpreted as a field segment\",",
      "79:    s:      \"coolField\",",
      "80:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "81:   },",
      "82:   \"QuotedField\": {",
      "83:    reason: \"A quoted string should be interpreted as a field segment with the quotes removed\",",
      "84:    s:      \"'coolField'\",",
      "85:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "86:   },",
      "87:   \"Index\": {",
      "88:    reason: \"An unambiguous integer should be interpreted as an index segment\",",
      "89:    s:      \"3\",",
      "90:    want:   Segment{Type: SegmentIndex, Index: 3},",
      "91:   },",
      "92:   \"Negative\": {",
      "93:    reason: \"A negative integer should be interpreted as an field segment\",",
      "94:    s:      \"-3\",",
      "95:    want:   Segment{Type: SegmentField, Field: \"-3\"},",
      "96:   },",
      "97:   \"Float\": {",
      "98:    reason: \"A float should be interpreted as an field segment\",",
      "99:    s:      \"3.0\",",
      "100:    want:   Segment{Type: SegmentField, Field: \"3.0\"},",
      "101:   },",
      "102:   \"Overflow\": {",
      "103:    reason: \"A very big integer will be interpreted as a field segment\",",
      "104:    s:      strconv.Itoa(math.MaxUint32 + 1),",
      "105:    want:   Segment{Type: SegmentField, Field: strconv.Itoa(math.MaxUint32 + 1)},",
      "106:   },",
      "107:  }",
      "108:  for name, tc := range cases {",
      "109:   t.Run(name, func(t *testing.T) {",
      "110:    got := FieldOrIndex(tc.s)",
      "111:    if diff := cmp.Diff(tc.want, got); diff != \"\" {",
      "112:     t.Errorf(\"\\nFieldOrIndex(...): %s: -want, +got:\\n%s\", tc.reason, diff)",
      "113:    }",
      "114:   })",
      "115:  }",
      "116: }",
      "118: func TestParse(t *testing.T) {",
      "119:  type want struct {",
      "120:   s   Segments",
      "121:   err error",
      "122:  }",
      "124:  cases := map[string]struct {",
      "125:   reason string",
      "126:   path   string",
      "127:   want   want",
      "128:  }{",
      "129:   \"SingleField\": {",
      "130:    reason: \"A path with no brackets or periods should be interpreted as a single field segment\",",
      "131:    path:   \"spec\",",
      "132:    want: want{",
      "133:     s: Segments{Field(\"spec\")},",
      "134:    },",
      "135:   },",
      "136:   \"SingleIndex\": {",
      "137:    reason: \"An integer surrounded by brackets should be interpreted as an index\",",
      "138:    path:   \"[0]\",",
      "139:    want: want{",
      "140:     s: Segments{FieldOrIndex(\"0\")},",
      "141:    },",
      "142:   },",
      "143:   \"TwoFields\": {",
      "144:    reason: \"A path with one period should be interpreted as two field segments\",",
      "145:    path:   \"metadata.name\",",
      "146:    want: want{",
      "147:     s: Segments{Field(\"metadata\"), Field(\"name\")},",
      "148:    },",
      "149:   },",
      "150:   \"APIConventionsExample\": {",
      "151:    reason: \"The example given by the Kubernetes API convention should be parse correctly\",",
      "152:    path:   \"fields[1].state.current\",",
      "153:    want: want{",
      "154:     s: Segments{",
      "155:      Field(\"fields\"),",
      "156:      FieldOrIndex(\"1\"),",
      "157:      Field(\"state\"),",
      "158:      Field(\"current\"),",
      "159:     },",
      "160:    },",
      "161:   },",
      "162:   \"SimpleIndex\": {",
      "163:    reason: \"Indexing an object field that is an array should result in a field and an index\",",
      "164:    path:   \"items[0]\",",
      "165:    want: want{",
      "166:     s: Segments{Field(\"items\"), FieldOrIndex(\"0\")},",
      "167:    },",
      "168:   },",
      "169:   \"FieldsAndIndex\": {",
      "170:    reason: \"A path with periods and braces should be interpreted as fields and indices\",",
      "171:    path:   \"spec.containers[0].name\",",
      "172:    want: want{",
      "173:     s: Segments{",
      "174:      Field(\"spec\"),",
      "175:      Field(\"containers\"),",
      "176:      FieldOrIndex(\"0\"),",
      "177:      Field(\"name\"),",
      "178:     },",
      "179:    },",
      "180:   },",
      "181:   \"NestedArray\": {",
      "182:    reason: \"A nested array should result in two consecutive index fields\",",
      "183:    path:   \"nested[0][1].name\",",
      "184:    want: want{",
      "185:     s: Segments{",
      "186:      Field(\"nested\"),",
      "187:      FieldOrIndex(\"0\"),",
      "188:      FieldOrIndex(\"1\"),",
      "189:      Field(\"name\"),",
      "190:     },",
      "191:    },",
      "192:   },",
      "193:   \"BracketStyleField\": {",
      "194:    reason: \"A field name can be specified using brackets rather than a period\",",
      "195:    path:   \"spec[containers][0].name\",",
      "196:    want: want{",
      "197:     s: Segments{",
      "198:      Field(\"spec\"),",
      "199:      Field(\"containers\"),",
      "200:      FieldOrIndex(\"0\"),",
      "201:      Field(\"name\"),",
      "202:     },",
      "203:    },",
      "204:   },",
      "205:   \"BracketFieldWithPeriod\": {",
      "206:    reason: \"A field name specified using brackets can include a period\",",
      "207:    path:   \"data[.config.yml]\",",
      "208:    want: want{",
      "209:     s: Segments{",
      "210:      Field(\"data\"),",
      "211:      FieldOrIndex(\".config.yml\"),",
      "212:     },",
      "213:    },",
      "214:   },",
      "215:   \"LeadingPeriod\": {",
      "216:    reason: \"A path may not start with a period (unlike a JSON path)\",",
      "217:    path:   \".metadata.name\",",
      "218:    want: want{",
      "219:     err: errors.New(\"unexpected '.' at position 0\"),",
      "220:    },",
      "221:   },",
      "222:   \"TrailingPeriod\": {",
      "223:    reason: \"A path may not end with a period\",",
      "224:    path:   \"metadata.name.\",",
      "225:    want: want{",
      "226:     err: errors.New(\"unexpected '.' at position 13\"),",
      "227:    },",
      "228:   },",
      "229:   \"BracketsFollowingPeriod\": {",
      "230:    reason: \"Brackets may not follow a period\",",
      "231:    path:   \"spec.containers.[0].name\",",
      "232:    want: want{",
      "233:     err: errors.New(\"unexpected '[' at position 16\"),",
      "234:    },",
      "235:   },",
      "236:   \"DoublePeriod\": {",
      "237:    reason: \"A path may not include two consecutive periods\",",
      "238:    path:   \"metadata..name\",",
      "239:    want: want{",
      "240:     err: errors.New(\"unexpected '.' at position 9\"),",
      "241:    },",
      "242:   },",
      "243:   \"DanglingRightBracket\": {",
      "244:    reason: \"A right bracket may not appear in a field name\",",
      "245:    path:   \"metadata.]name\",",
      "246:    want: want{",
      "247:     err: errors.New(\"unexpected ']' at position 9\"),",
      "248:    },",
      "249:   },",
      "250:   \"DoubleOpenBracket\": {",
      "251:    reason: \"Brackets may not be nested\",",
      "252:    path:   \"spec[bracketed[name]]\",",
      "253:    want: want{",
      "254:     err: errors.New(\"unexpected '[' at position 14\"),",
      "255:    },",
      "256:   },",
      "257:   \"DanglingLeftBracket\": {",
      "258:    reason: \"A left bracket must be closed\",",
      "259:    path:   \"spec[name\",",
      "260:    want: want{",
      "261:     err: errors.New(\"unterminated '[' at position 4\"),",
      "262:    },",
      "263:   },",
      "264:   \"EmptyBracket\": {",
      "265:    reason: \"Brackets may not be empty\",",
      "266:    path:   \"spec[]\",",
      "267:    want: want{",
      "268:     err: errors.New(\"unexpected ']' at position 5\"),",
      "269:    },",
      "270:   },",
      "271:  }",
      "272:  for name, tc := range cases {",
      "273:   t.Run(name, func(t *testing.T) {",
      "274:    got, err := Parse(tc.path)",
      "275:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "276:     t.Fatalf(\"\\nParse(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "277:    }",
      "278:    if diff := cmp.Diff(tc.want.s, got); diff != \"\" {",
      "279:     t.Errorf(\"\\nParse(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "280:    }",
      "281:   })",
      "282:  }",
      "283: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
      "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "22:  \"github.com/pkg/errors\"",
      "23: )",
      "26: type Paved struct {",
      "27:  object map[string]interface{}",
      "28: }",
      "31: func Pave(object map[string]interface{}) *Paved {",
      "32:  return &Paved{object: object}",
      "33: }",
      "36: func (p Paved) MarshalJSON() ([]byte, error) {",
      "37:  return json.Marshal(p.object)",
      "38: }",
      "41: func (p *Paved) UnmarshalJSON(data []byte) error {",
      "42:  return json.Unmarshal(data, &p.object)",
      "43: }",
      "45: func (p *Paved) getValue(s Segments) (interface{}, error) {",
      "46:  var it interface{} = p.object",
      "47:  for i, current := range s {",
      "48:   final := i == len(s)-1",
      "49:   switch current.Type {",
      "50:   case SegmentIndex:",
      "51:    array, ok := it.([]interface{})",
      "52:    if !ok {",
      "53:     return nil, errors.Errorf(\"%s: not an array\", s[:i])",
      "54:    }",
      "55:    if int(current.Index) >= len(array) {",
      "56:     return nil, errors.Errorf(\"%s: no such element\", s[:i+1])",
      "57:    }",
      "58:    if final {",
      "59:     return array[current.Index], nil",
      "60:    }",
      "61:    it = array[current.Index]",
      "63:   case SegmentField:",
      "64:    object, ok := it.(map[string]interface{})",
      "65:    if !ok {",
      "66:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
      "67:    }",
      "68:    v, ok := object[current.Field]",
      "69:    if !ok {",
      "70:     return nil, errors.Errorf(\"%s: no such field\", s[:i+1])",
      "71:    }",
      "72:    if final {",
      "73:     return v, nil",
      "74:    }",
      "75:    it = object[current.Field]",
      "76:   }",
      "77:  }",
      "80:  return nil, nil",
      "81: }",
      "84: func (p *Paved) GetValue(path string) (interface{}, error) {",
      "85:  segments, err := Parse(path)",
      "86:  if err != nil {",
      "87:   return nil, errors.Wrapf(err, \"cannot parse path %q\", path)",
      "88:  }",
      "90:  return p.getValue(segments)",
      "91: }",
      "94: func (p *Paved) GetString(path string) (string, error) {",
      "95:  v, err := p.GetValue(path)",
      "96:  if err != nil {",
      "97:   return \"\", err",
      "98:  }",
      "100:  s, ok := v.(string)",
      "101:  if !ok {",
      "102:   return \"\", errors.Errorf(\"%s: not a string\", path)",
      "103:  }",
      "104:  return s, nil",
      "105: }",
      "108: func (p *Paved) GetStringArray(path string) ([]string, error) {",
      "109:  v, err := p.GetValue(path)",
      "110:  if err != nil {",
      "111:   return nil, err",
      "112:  }",
      "114:  a, ok := v.([]interface{})",
      "115:  if !ok {",
      "116:   return nil, errors.Errorf(\"%s: not an array\", path)",
      "117:  }",
      "119:  sa := make([]string, len(a))",
      "120:  for i := range a {",
      "121:   s, ok := a[i].(string)",
      "122:   if !ok {",
      "123:    return nil, errors.Errorf(\"%s: not an array of strings\", path)",
      "124:   }",
      "125:   sa[i] = s",
      "126:  }",
      "128:  return sa, nil",
      "129: }",
      "132: func (p *Paved) GetStringObject(path string) (map[string]string, error) {",
      "133:  v, err := p.GetValue(path)",
      "134:  if err != nil {",
      "135:   return nil, err",
      "136:  }",
      "138:  o, ok := v.(map[string]interface{})",
      "139:  if !ok {",
      "140:   return nil, errors.Errorf(\"%s: not an object\", path)",
      "141:  }",
      "143:  so := make(map[string]string)",
      "144:  for k, in := range o {",
      "145:   s, ok := in.(string)",
      "146:   if !ok {",
      "147:    return nil, errors.Errorf(\"%s: not an object with string field values\", path)",
      "148:   }",
      "149:   so[k] = s",
      "151:  }",
      "153:  return so, nil",
      "154: }",
      "157: func (p *Paved) GetBool(path string) (bool, error) {",
      "158:  v, err := p.GetValue(path)",
      "159:  if err != nil {",
      "160:   return false, err",
      "161:  }",
      "163:  b, ok := v.(bool)",
      "164:  if !ok {",
      "165:   return false, errors.Errorf(\"%s: not a bool\", path)",
      "166:  }",
      "167:  return b, nil",
      "168: }",
      "171: func (p *Paved) GetNumber(path string) (float64, error) {",
      "172:  v, err := p.GetValue(path)",
      "173:  if err != nil {",
      "174:   return 0, err",
      "175:  }",
      "177:  f, ok := v.(float64)",
      "178:  if !ok {",
      "179:   return 0, errors.Errorf(\"%s: not a (float64) number\", path)",
      "180:  }",
      "181:  return f, nil",
      "182: }",
      "184: func (p *Paved) setValue(s Segments, value interface{}) error {",
      "185:  var in interface{} = p.object",
      "186:  for i, current := range s {",
      "187:   final := i == len(s)-1",
      "189:   switch current.Type {",
      "190:   case SegmentIndex:",
      "191:    array, ok := in.([]interface{})",
      "192:    if !ok {",
      "193:     return errors.Errorf(\"%s is not an array\", s[:i])",
      "194:    }",
      "196:    if final {",
      "197:     array[current.Index] = value",
      "198:     return nil",
      "199:    }",
      "201:    prepareElement(array, current, s[i+1])",
      "202:    in = array[current.Index]",
      "204:   case SegmentField:",
      "205:    object, ok := in.(map[string]interface{})",
      "206:    if !ok {",
      "207:     return errors.Errorf(\"%s is not an object\", s[:i])",
      "208:    }",
      "210:    if final {",
      "211:     object[current.Field] = value",
      "212:     return nil",
      "213:    }",
      "215:    prepareField(object, current, s[i+1])",
      "216:    in = object[current.Field]",
      "217:   }",
      "218:  }",
      "220:  return nil",
      "221: }",
      "223: func prepareElement(array []interface{}, current, next Segment) {",
      "226:  if array[current.Index] == nil {",
      "227:   switch next.Type {",
      "228:   case SegmentIndex:",
      "229:    array[current.Index] = make([]interface{}, next.Index+1)",
      "230:   case SegmentField:",
      "231:    array[current.Index] = make(map[string]interface{})",
      "232:   }",
      "233:   return",
      "234:  }",
      "238:  if next.Type != SegmentIndex {",
      "239:   return",
      "240:  }",
      "242:  na, ok := array[current.Index].([]interface{})",
      "243:  if !ok {",
      "244:   return",
      "245:  }",
      "247:  if int(next.Index) < len(na) {",
      "248:   return",
      "249:  }",
      "251:  array[current.Index] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "252: }",
      "254: func prepareField(object map[string]interface{}, current, next Segment) {",
      "257:  if _, ok := object[current.Field]; !ok {",
      "258:   switch next.Type {",
      "259:   case SegmentIndex:",
      "260:    object[current.Field] = make([]interface{}, next.Index+1)",
      "261:   case SegmentField:",
      "262:    object[current.Field] = make(map[string]interface{})",
      "263:   }",
      "264:   return",
      "265:  }",
      "269:  if next.Type != SegmentIndex {",
      "270:   return",
      "271:  }",
      "273:  na, ok := object[current.Field].([]interface{})",
      "274:  if !ok {",
      "275:   return",
      "276:  }",
      "278:  if int(next.Index) < len(na) {",
      "279:   return",
      "280:  }",
      "282:  object[current.Field] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "283: }",
      "286: func (p *Paved) SetValue(path string, value interface{}) error {",
      "287:  segments, err := Parse(path)",
      "288:  if err != nil {",
      "289:   return errors.Wrapf(err, \"cannot parse path %q\", path)",
      "290:  }",
      "291:  return p.setValue(segments, value)",
      "292: }",
      "295: func (p *Paved) SetString(path, value string) error {",
      "296:  return p.SetValue(path, value)",
      "297: }",
      "300: func (p *Paved) SetBool(path string, value bool) error {",
      "301:  return p.SetValue(path, value)",
      "302: }",
      "305: func (p *Paved) SetNumber(path string, value float64) error {",
      "306:  return p.SetValue(path, value)",
      "307: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
      "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "21:  \"testing\"",
      "23:  \"github.com/google/go-cmp/cmp\"",
      "24:  \"github.com/pkg/errors\"",
      "26:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "27: )",
      "29: func TestGetValue(t *testing.T) {",
      "30:  type want struct {",
      "31:   value interface{}",
      "32:   err   error",
      "33:  }",
      "34:  cases := map[string]struct {",
      "35:   reason string",
      "36:   path   string",
      "37:   data   []byte",
      "38:   want   want",
      "39:  }{",
      "40:   \"MetadataName\": {",
      "41:    reason: \"It should be possible to get a field from a nested object\",",
      "42:    path:   \"metadata.name\",",
      "43:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "44:    want: want{",
      "45:     value: \"cool\",",
      "46:    },",
      "47:   },",
      "48:   \"ContainerName\": {",
      "49:    reason: \"It should be possible to get a field from an object array element\",",
      "50:    path:   \"spec.containers[0].name\",",
      "51:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "52:    want: want{",
      "53:     value: \"cool\",",
      "54:    },",
      "55:   },",
      "56:   \"NestedArray\": {",
      "57:    reason: \"It should be possible to get a field from a nested array\",",
      "58:    path:   \"items[0][1]\",",
      "59:    data:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),",
      "60:    want: want{",
      "61:     value: \"b\",",
      "62:    },",
      "63:   },",
      "64:   \"OwnerRefController\": {",
      "65:    reason: \"Requesting a boolean field path should work.\",",
      "66:    path:   \"metadata.ownerRefs[0].controller\",",
      "67:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "68:    want: want{",
      "69:     value: true,",
      "70:    },",
      "71:   },",
      "72:   \"MetadataVersion\": {",
      "73:    reason: \"Requesting a number field should work\",",
      "74:    path:   \"metadata.version\",",
      "75:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "76:    want: want{",
      "77:     value: float64(2),",
      "78:    },",
      "79:   },",
      "80:   \"MetadataNope\": {",
      "81:    reason: \"Requesting a non-existent object field should fail\",",
      "82:    path:   \"metadata.name\",",
      "83:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "84:    want: want{",
      "85:     err: errors.New(\"metadata.name: no such field\"),",
      "86:    },",
      "87:   },",
      "88:   \"InsufficientContainers\": {",
      "89:    reason: \"Requesting a non-existent array element should fail\",",
      "90:    path:   \"spec.containers[1].name\",",
      "91:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "92:    want: want{",
      "93:     err: errors.New(\"spec.containers[1]: no such element\"),",
      "94:    },",
      "95:   },",
      "96:   \"NotAnArray\": {",
      "97:    reason: \"Indexing an object should fail\",",
      "98:    path:   \"metadata[1]\",",
      "99:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "100:    want: want{",
      "101:     err: errors.New(\"metadata: not an array\"),",
      "102:    },",
      "103:   },",
      "104:   \"NotAnObject\": {",
      "105:    reason: \"Requesting a field in an array should fail\",",
      "106:    path:   \"spec.containers[nope].name\",",
      "107:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "108:    want: want{",
      "109:     err: errors.New(\"spec.containers: not an object\"),",
      "110:    },",
      "111:   },",
      "112:   \"MalformedPath\": {",
      "113:    reason: \"Requesting an invalid field path should fail\",",
      "114:    path:   \"spec[]\",",
      "115:    want: want{",
      "116:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "117:    },",
      "118:   },",
      "119:  }",
      "121:  for name, tc := range cases {",
      "122:   t.Run(name, func(t *testing.T) {",
      "123:    in := make(map[string]interface{})",
      "124:    _ = json.Unmarshal(tc.data, &in)",
      "125:    p := Pave(in)",
      "127:    got, err := p.GetValue(tc.path)",
      "128:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "129:     t.Fatalf(\"\\np.GetValue(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "130:    }",
      "131:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "132:     t.Errorf(\"\\np.GetValue(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "133:    }",
      "134:   })",
      "135:  }",
      "136: }",
      "138: func TestGetString(t *testing.T) {",
      "139:  type want struct {",
      "140:   value string",
      "141:   err   error",
      "142:  }",
      "143:  cases := map[string]struct {",
      "144:   reason string",
      "145:   path   string",
      "146:   data   []byte",
      "147:   want   want",
      "148:  }{",
      "149:   \"MetadataName\": {",
      "150:    reason: \"It should be possible to get a field from a nested object\",",
      "151:    path:   \"metadata.name\",",
      "152:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "153:    want: want{",
      "154:     value: \"cool\",",
      "155:    },",
      "156:   },",
      "157:   \"MalformedPath\": {",
      "158:    reason: \"Requesting an invalid field path should fail\",",
      "159:    path:   \"spec[]\",",
      "160:    want: want{",
      "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "162:    },",
      "163:   },",
      "164:   \"NotAString\": {",
      "165:    reason: \"Requesting an non-string field path should fail\",",
      "166:    path:   \"metadata.version\",",
      "167:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "168:    want: want{",
      "169:     err: errors.New(\"metadata.version: not a string\"),",
      "170:    },",
      "171:   },",
      "172:  }",
      "174:  for name, tc := range cases {",
      "175:   t.Run(name, func(t *testing.T) {",
      "176:    in := make(map[string]interface{})",
      "177:    _ = json.Unmarshal(tc.data, &in)",
      "178:    p := Pave(in)",
      "180:    got, err := p.GetString(tc.path)",
      "181:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "182:     t.Fatalf(\"\\np.GetString(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "183:    }",
      "184:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "185:     t.Errorf(\"\\np.GetString(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "186:    }",
      "187:   })",
      "188:  }",
      "189: }",
      "191: func TestGetStringArray(t *testing.T) {",
      "192:  type want struct {",
      "193:   value []string",
      "194:   err   error",
      "195:  }",
      "196:  cases := map[string]struct {",
      "197:   reason string",
      "198:   path   string",
      "199:   data   []byte",
      "200:   want   want",
      "201:  }{",
      "202:   \"MetadataLabels\": {",
      "203:    reason: \"It should be possible to get a field from a nested object\",",
      "204:    path:   \"spec.containers[0].command\",",
      "205:    data:   []byte(`{\"spec\": {\"containers\": [{\"command\": [\"/bin/bash\"]}]}}`),",
      "206:    want: want{",
      "207:     value: []string{\"/bin/bash\"},",
      "208:    },",
      "209:   },",
      "210:   \"MalformedPath\": {",
      "211:    reason: \"Requesting an invalid field path should fail\",",
      "212:    path:   \"spec[]\",",
      "213:    want: want{",
      "214:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "215:    },",
      "216:   },",
      "217:   \"NotAnArray\": {",
      "218:    reason: \"Requesting an non-object field path should fail\",",
      "219:    path:   \"metadata.version\",",
      "220:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "221:    want: want{",
      "222:     err: errors.New(\"metadata.version: not an array\"),",
      "223:    },",
      "224:   },",
      "225:   \"NotAStringArray\": {",
      "226:    reason: \"Requesting an non-string-object field path should fail\",",
      "227:    path:   \"metadata.versions\",",
      "228:    data:   []byte(`{\"metadata\":{\"versions\":[1,2]}}`),",
      "229:    want: want{",
      "230:     err: errors.New(\"metadata.versions: not an array of strings\"),",
      "231:    },",
      "232:   },",
      "233:  }",
      "235:  for name, tc := range cases {",
      "236:   t.Run(name, func(t *testing.T) {",
      "237:    in := make(map[string]interface{})",
      "238:    _ = json.Unmarshal(tc.data, &in)",
      "239:    p := Pave(in)",
      "241:    got, err := p.GetStringArray(tc.path)",
      "242:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "243:     t.Fatalf(\"\\np.GetStringArray(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "244:    }",
      "245:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "246:     t.Errorf(\"\\np.GetStringArray(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "247:    }",
      "248:   })",
      "249:  }",
      "250: }",
      "252: func TestGetStringObject(t *testing.T) {",
      "253:  type want struct {",
      "254:   value map[string]string",
      "255:   err   error",
      "256:  }",
      "257:  cases := map[string]struct {",
      "258:   reason string",
      "259:   path   string",
      "260:   data   []byte",
      "261:   want   want",
      "262:  }{",
      "263:   \"MetadataLabels\": {",
      "264:    reason: \"It should be possible to get a field from a nested object\",",
      "265:    path:   \"metadata.labels\",",
      "266:    data:   []byte(`{\"metadata\":{\"labels\":{\"cool\":\"true\"}}}`),",
      "267:    want: want{",
      "268:     value: map[string]string{\"cool\": \"true\"},",
      "269:    },",
      "270:   },",
      "271:   \"MalformedPath\": {",
      "272:    reason: \"Requesting an invalid field path should fail\",",
      "273:    path:   \"spec[]\",",
      "274:    want: want{",
      "275:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "276:    },",
      "277:   },",
      "278:   \"NotAnObject\": {",
      "279:    reason: \"Requesting an non-object field path should fail\",",
      "280:    path:   \"metadata.version\",",
      "281:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "282:    want: want{",
      "283:     err: errors.New(\"metadata.version: not an object\"),",
      "284:    },",
      "285:   },",
      "286:   \"NotAStringObject\": {",
      "287:    reason: \"Requesting an non-string-object field path should fail\",",
      "288:    path:   \"metadata.versions\",",
      "289:    data:   []byte(`{\"metadata\":{\"versions\":{\"a\": 2}}}`),",
      "290:    want: want{",
      "291:     err: errors.New(\"metadata.versions: not an object with string field values\"),",
      "292:    },",
      "293:   },",
      "294:  }",
      "296:  for name, tc := range cases {",
      "297:   t.Run(name, func(t *testing.T) {",
      "298:    in := make(map[string]interface{})",
      "299:    _ = json.Unmarshal(tc.data, &in)",
      "300:    p := Pave(in)",
      "302:    got, err := p.GetStringObject(tc.path)",
      "303:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "304:     t.Fatalf(\"\\np.GetStringObject(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "305:    }",
      "306:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "307:     t.Errorf(\"\\np.GetStringObject(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "308:    }",
      "309:   })",
      "310:  }",
      "311: }",
      "313: func TestGetBool(t *testing.T) {",
      "314:  type want struct {",
      "315:   value bool",
      "316:   err   error",
      "317:  }",
      "318:  cases := map[string]struct {",
      "319:   reason string",
      "320:   path   string",
      "321:   data   []byte",
      "322:   want   want",
      "323:  }{",
      "324:   \"OwnerRefController\": {",
      "325:    reason: \"Requesting a boolean field path should work.\",",
      "326:    path:   \"metadata.ownerRefs[0].controller\",",
      "327:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "328:    want: want{",
      "329:     value: true,",
      "330:    },",
      "331:   },",
      "332:   \"MalformedPath\": {",
      "333:    reason: \"Requesting an invalid field path should fail\",",
      "334:    path:   \"spec[]\",",
      "335:    want: want{",
      "336:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "337:    },",
      "338:   },",
      "339:   \"NotABool\": {",
      "340:    reason: \"Requesting an non-boolean field path should fail\",",
      "341:    path:   \"metadata.name\",",
      "342:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "343:    want: want{",
      "344:     err: errors.New(\"metadata.name: not a bool\"),",
      "345:    },",
      "346:   },",
      "347:  }",
      "349:  for name, tc := range cases {",
      "350:   t.Run(name, func(t *testing.T) {",
      "351:    in := make(map[string]interface{})",
      "352:    _ = json.Unmarshal(tc.data, &in)",
      "353:    p := Pave(in)",
      "355:    got, err := p.GetBool(tc.path)",
      "356:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "357:     t.Fatalf(\"\\np.GetBool(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "358:    }",
      "359:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "360:     t.Errorf(\"\\np.GetBool(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "361:    }",
      "362:   })",
      "363:  }",
      "364: }",
      "366: func TestGetNumber(t *testing.T) {",
      "367:  type want struct {",
      "368:   value float64",
      "369:   err   error",
      "370:  }",
      "371:  cases := map[string]struct {",
      "372:   reason string",
      "373:   path   string",
      "374:   data   []byte",
      "375:   want   want",
      "376:  }{",
      "377:   \"MetadataVersion\": {",
      "378:    reason: \"Requesting a number field should work\",",
      "379:    path:   \"metadata.version\",",
      "380:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "381:    want: want{",
      "382:     value: 2,",
      "383:    },",
      "384:   },",
      "385:   \"MalformedPath\": {",
      "386:    reason: \"Requesting an invalid field path should fail\",",
      "387:    path:   \"spec[]\",",
      "388:    want: want{",
      "389:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "390:    },",
      "391:   },",
      "392:   \"NotANumber\": {",
      "393:    reason: \"Requesting an non-number field path should fail\",",
      "394:    path:   \"metadata.name\",",
      "395:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "396:    want: want{",
      "397:     err: errors.New(\"metadata.name: not a (float64) number\"),",
      "398:    },",
      "399:   },",
      "400:  }",
      "402:  for name, tc := range cases {",
      "403:   t.Run(name, func(t *testing.T) {",
      "404:    in := make(map[string]interface{})",
      "405:    _ = json.Unmarshal(tc.data, &in)",
      "406:    p := Pave(in)",
      "408:    got, err := p.GetNumber(tc.path)",
      "409:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "410:     t.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "411:    }",
      "412:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "413:     t.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "414:    }",
      "415:   })",
      "416:  }",
      "417: }",
      "419: func TestSetValue(t *testing.T) {",
      "420:  type args struct {",
      "421:   path  string",
      "422:   value interface{}",
      "423:  }",
      "424:  type want struct {",
      "425:   object map[string]interface{}",
      "426:   err    error",
      "427:  }",
      "428:  cases := map[string]struct {",
      "429:   reason string",
      "430:   data   []byte",
      "431:   args   args",
      "432:   want   want",
      "433:  }{",
      "434:   \"MetadataName\": {",
      "435:    reason: \"Setting an object field should work\",",
      "436:    data:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),",
      "437:    args: args{",
      "438:     path:  \"metadata.name\",",
      "439:     value: \"cool\",",
      "440:    },",
      "441:    want: want{",
      "442:     object: map[string]interface{}{",
      "443:      \"metadata\": map[string]interface{}{",
      "444:       \"name\": \"cool\",",
      "445:      },",
      "446:     },",
      "447:    },",
      "448:   },",
      "449:   \"NonExistentMetadataName\": {",
      "450:    reason: \"Setting a non-existent object field should work\",",
      "451:    data:   []byte(`{}`),",
      "452:    args: args{",
      "453:     path:  \"metadata.name\",",
      "454:     value: \"cool\",",
      "455:    },",
      "456:    want: want{",
      "457:     object: map[string]interface{}{",
      "458:      \"metadata\": map[string]interface{}{",
      "459:       \"name\": \"cool\",",
      "460:      },",
      "461:     },",
      "462:    },",
      "463:   },",
      "464:   \"ContainerName\": {",
      "465:    reason: \"Setting a field of an object that is an array element should work\",",
      "466:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"lame\"}]}}`),",
      "467:    args: args{",
      "468:     path:  \"spec.containers[0].name\",",
      "469:     value: \"cool\",",
      "470:    },",
      "471:    want: want{",
      "472:     object: map[string]interface{}{",
      "473:      \"spec\": map[string]interface{}{",
      "474:       \"containers\": []interface{}{",
      "475:        map[string]interface{}{",
      "476:         \"name\": \"cool\",",
      "477:        },",
      "478:       },",
      "479:      },",
      "480:     },",
      "481:    },",
      "482:   },",
      "483:   \"NonExistentContainerName\": {",
      "484:    reason: \"Setting a field of a non-existent object that is an array element should work\",",
      "485:    data:   []byte(`{}`),",
      "486:    args: args{",
      "487:     path:  \"spec.containers[0].name\",",
      "488:     value: \"cool\",",
      "489:    },",
      "490:    want: want{",
      "491:     object: map[string]interface{}{",
      "492:      \"spec\": map[string]interface{}{",
      "493:       \"containers\": []interface{}{",
      "494:        map[string]interface{}{",
      "495:         \"name\": \"cool\",",
      "496:        },",
      "497:       },",
      "498:      },",
      "499:     },",
      "500:    },",
      "501:   },",
      "502:   \"NewContainer\": {",
      "503:    reason: \"Growing an array object field should work\",",
      "504:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "505:    args: args{",
      "506:     path:  \"spec.containers[1].name\",",
      "507:     value: \"cooler\",",
      "508:    },",
      "509:    want: want{",
      "510:     object: map[string]interface{}{",
      "511:      \"spec\": map[string]interface{}{",
      "512:       \"containers\": []interface{}{",
      "513:        map[string]interface{}{",
      "514:         \"name\": \"cool\",",
      "515:        },",
      "516:        map[string]interface{}{",
      "517:         \"name\": \"cooler\",",
      "518:        },",
      "519:       },",
      "520:      },",
      "521:     },",
      "522:    },",
      "523:   },",
      "524:   \"NestedArray\": {",
      "525:    reason: \"Setting a value in a nested array should work\",",
      "526:    data:   []byte(`{}`),",
      "527:    args: args{",
      "528:     path:  \"data[0][0]\",",
      "529:     value: \"a\",",
      "530:    },",
      "531:    want: want{",
      "532:     object: map[string]interface{}{",
      "533:      \"data\": []interface{}{",
      "534:       []interface{}{\"a\"},",
      "535:      },",
      "536:     },",
      "537:    },",
      "538:   },",
      "539:   \"GrowNestedArray\": {",
      "540:    reason: \"Growing then setting a value in a nested array should work\",",
      "541:    data:   []byte(`{\"data\":[[\"a\"]]}`),",
      "542:    args: args{",
      "543:     path:  \"data[0][1]\",",
      "544:     value: \"b\",",
      "545:    },",
      "546:    want: want{",
      "547:     object: map[string]interface{}{",
      "548:      \"data\": []interface{}{",
      "549:       []interface{}{\"a\", \"b\"},",
      "550:      },",
      "551:     },",
      "552:    },",
      "553:   },",
      "554:   \"GrowArrayField\": {",
      "555:    reason: \"Growing then setting a value in an array field should work\",",
      "556:    data:   []byte(`{\"data\":[\"a\"]}`),",
      "557:    args: args{",
      "558:     path:  \"data[2]\",",
      "559:     value: \"c\",",
      "560:    },",
      "561:    want: want{",
      "562:     object: map[string]interface{}{",
      "563:      \"data\": []interface{}{\"a\", nil, \"c\"},",
      "564:     },",
      "565:    },",
      "566:   },",
      "567:   \"NotAnArray\": {",
      "568:    reason: \"Indexing an object field should fail\",",
      "569:    data:   []byte(`{\"data\":{}}`),",
      "570:    args: args{",
      "571:     path: \"data[0]\",",
      "572:    },",
      "573:    want: want{",
      "574:     object: map[string]interface{}{\"data\": map[string]interface{}{}},",
      "575:     err:    errors.New(\"data is not an array\"),",
      "576:    },",
      "577:   },",
      "578:   \"NotAnObject\": {",
      "579:    reason: \"Requesting a field in an array should fail\",",
      "580:    data:   []byte(`{\"data\":[]}`),",
      "581:    args: args{",
      "582:     path: \"data.name\",",
      "583:    },",
      "584:    want: want{",
      "585:     object: map[string]interface{}{\"data\": []interface{}{}},",
      "586:     err:    errors.New(\"data is not an object\"),",
      "587:    },",
      "588:   },",
      "589:   \"MalformedPath\": {",
      "590:    reason: \"Requesting an invalid field path should fail\",",
      "591:    args: args{",
      "592:     path: \"spec[]\",",
      "593:    },",
      "594:    want: want{",
      "595:     object: map[string]interface{}{},",
      "596:     err:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "597:    },",
      "598:   },",
      "599:  }",
      "601:  for name, tc := range cases {",
      "602:   t.Run(name, func(t *testing.T) {",
      "603:    in := make(map[string]interface{})",
      "604:    _ = json.Unmarshal(tc.data, &in)",
      "605:    p := Pave(in)",
      "607:    err := p.SetValue(tc.args.path, tc.args.value)",
      "608:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "609:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want error, +got error:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "610:    }",
      "611:    if diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {",
      "612:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want, +got:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "613:    }",
      "614:   })",
      "615:  }",
      "616: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "195a02da319e4663c0949938d1cb33d88ab4912a",
      "candidate_info": {
        "commit_hash": "195a02da319e4663c0949938d1cb33d88ab4912a",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/195a02da319e4663c0949938d1cb33d88ab4912a",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Change the error message with a more consistent with the other errors\n\nSigned-off-by: Sergen Yal\u00e7\u0131n <yalcinsergen97@gmail.com>",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     }",
          "143:     it = object[current.Field]",
          "144:    case nil:",
          "146:    default:",
          "147:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
          "148:    }",
          "",
          "[Removed Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"path %q is not found in the paved object\", s[:i])}",
          "",
          "[Added Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"%s: expected map, got nil\", s[:i])}",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "166:    path:   \"spec.containers[*].name\",",
          "167:    data:   []byte(`{\"spec\":{\"containers\": null}}`),",
          "168:    want: want{",
          "170:    },",
          "171:   },",
          "172:  }",
          "",
          "[Removed Lines]",
          "169:     err: errNotFound{errors.Errorf(\"path %q is not found in the paved object\", \"spec.containers\")},",
          "",
          "[Added Lines]",
          "169:     err: errNotFound{errors.Errorf(\"%s: expected map, got nil\", \"spec.containers\")},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1deb753676be3a07903692e7c5333678c5e8d9df",
      "candidate_info": {
        "commit_hash": "1deb753676be3a07903692e7c5333678c5e8d9df",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/1deb753676be3a07903692e7c5333678c5e8d9df",
        "files": [
          "pkg/connection/store/vault/kv/fake/mocks.go",
          "pkg/connection/store/vault/kv/secret.go",
          "pkg/connection/store/vault/kv/v1.go",
          "pkg/connection/store/vault/kv/v1_test.go",
          "pkg/connection/store/vault/kv/v2.go",
          "pkg/connection/store/vault/kv/v2_test.go",
          "pkg/errors/errors.go",
          "pkg/errors/errors_test.go",
          "pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/merge.go",
          "pkg/fieldpath/merge_test.go",
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go",
          "pkg/logging/logging.go",
          "pkg/parser/fsreader.go",
          "pkg/parser/parser.go",
          "pkg/ratelimiter/reconciler_test.go",
          "pkg/resource/enqueue_handlers.go",
          "pkg/resource/enqueue_handlers_test.go",
          "pkg/resource/unstructured/claim/claim.go",
          "pkg/resource/unstructured/claim/claim_test.go",
          "pkg/resource/unstructured/client.go",
          "pkg/resource/unstructured/client_test.go",
          "pkg/resource/unstructured/composed/composed.go",
          "pkg/resource/unstructured/composed/composed_test.go",
          "pkg/resource/unstructured/composite/composite.go",
          "pkg/resource/unstructured/composite/composite_test.go"
        ],
        "message": "s/interface{}/any/g\n\nSigned-off-by: Aditya Sharma <git@adi.run>",
        "before_after_code_files": [
          "pkg/connection/store/vault/kv/fake/mocks.go||pkg/connection/store/vault/kv/fake/mocks.go",
          "pkg/connection/store/vault/kv/secret.go||pkg/connection/store/vault/kv/secret.go",
          "pkg/connection/store/vault/kv/v1.go||pkg/connection/store/vault/kv/v1.go",
          "pkg/connection/store/vault/kv/v1_test.go||pkg/connection/store/vault/kv/v1_test.go",
          "pkg/connection/store/vault/kv/v2.go||pkg/connection/store/vault/kv/v2.go",
          "pkg/connection/store/vault/kv/v2_test.go||pkg/connection/store/vault/kv/v2_test.go",
          "pkg/errors/errors.go||pkg/errors/errors.go",
          "pkg/errors/errors_test.go||pkg/errors/errors_test.go",
          "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/merge.go||pkg/fieldpath/merge.go",
          "pkg/fieldpath/merge_test.go||pkg/fieldpath/merge_test.go",
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go",
          "pkg/logging/logging.go||pkg/logging/logging.go",
          "pkg/parser/fsreader.go||pkg/parser/fsreader.go",
          "pkg/parser/parser.go||pkg/parser/parser.go",
          "pkg/ratelimiter/reconciler_test.go||pkg/ratelimiter/reconciler_test.go",
          "pkg/resource/enqueue_handlers.go||pkg/resource/enqueue_handlers.go",
          "pkg/resource/enqueue_handlers_test.go||pkg/resource/enqueue_handlers_test.go",
          "pkg/resource/unstructured/claim/claim.go||pkg/resource/unstructured/claim/claim.go",
          "pkg/resource/unstructured/claim/claim_test.go||pkg/resource/unstructured/claim/claim_test.go",
          "pkg/resource/unstructured/client.go||pkg/resource/unstructured/client.go",
          "pkg/resource/unstructured/client_test.go||pkg/resource/unstructured/client_test.go",
          "pkg/resource/unstructured/composed/composed.go||pkg/resource/unstructured/composed/composed.go",
          "pkg/resource/unstructured/composed/composed_test.go||pkg/resource/unstructured/composed/composed_test.go",
          "pkg/resource/unstructured/composite/composite.go||pkg/resource/unstructured/composite/composite.go",
          "pkg/resource/unstructured/composite/composite_test.go||pkg/resource/unstructured/composite/composite_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/connection/store/vault/kv/fake/mocks.go||pkg/connection/store/vault/kv/fake/mocks.go": [
          "File: pkg/connection/store/vault/kv/fake/mocks.go -> pkg/connection/store/vault/kv/fake/mocks.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: type LogicalClient struct {",
          "25:  ReadFn   func(path string) (*api.Secret, error)",
          "27:  DeleteFn func(path string) (*api.Secret, error)",
          "28: }",
          "",
          "[Removed Lines]",
          "26:  WriteFn  func(path string, data map[string]interface{}) (*api.Secret, error)",
          "",
          "[Added Lines]",
          "26:  WriteFn  func(path string, data map[string]any) (*api.Secret, error)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: }",
          "37:  return l.WriteFn(path, data)",
          "38: }",
          "",
          "[Removed Lines]",
          "36: func (l *LogicalClient) Write(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "36: func (l *LogicalClient) Write(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------"
        ],
        "pkg/connection/store/vault/kv/secret.go||pkg/connection/store/vault/kv/secret.go": [
          "File: pkg/connection/store/vault/kv/secret.go -> pkg/connection/store/vault/kv/secret.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: type LogicalClient interface {",
          "40:  Read(path string) (*api.Secret, error)",
          "42:  Delete(path string) (*api.Secret, error)",
          "43: }",
          "",
          "[Removed Lines]",
          "41:  Write(path string, data map[string]interface{}) (*api.Secret, error)",
          "",
          "[Added Lines]",
          "41:  Write(path string, data map[string]any) (*api.Secret, error)",
          "",
          "---------------"
        ],
        "pkg/connection/store/vault/kv/v1.go||pkg/connection/store/vault/kv/v1.go": [
          "File: pkg/connection/store/vault/kv/v1.go -> pkg/connection/store/vault/kv/v1.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:  return nil",
          "107: }",
          "111:  for k, v := range existing.Data {",
          "113:   if !strings.HasPrefix(k, metadataPrefix) {",
          "",
          "[Removed Lines]",
          "109: func payloadV1(existing, new *Secret) (map[string]interface{}, bool) {",
          "110:  payload := make(map[string]interface{}, len(existing.Data)+len(new.Data))",
          "",
          "[Added Lines]",
          "109: func payloadV1(existing, new *Secret) (map[string]any, bool) {",
          "110:  payload := make(map[string]any, len(existing.Data)+len(new.Data))",
          "",
          "---------------"
        ],
        "pkg/connection/store/vault/kv/v1_test.go||pkg/connection/store/vault/kv/v1_test.go": [
          "File: pkg/connection/store/vault/kv/v1_test.go -> pkg/connection/store/vault/kv/v1_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "86:       }",
          "87:       return &api.Secret{",
          "89:         \"foo\":                               \"bar\",",
          "90:         metadataPrefix + \"owner\":            \"jdoe\",",
          "91:         metadataPrefix + \"mission_critical\": \"false\",",
          "",
          "[Removed Lines]",
          "88:        Data: map[string]interface{}{",
          "",
          "[Added Lines]",
          "88:        Data: map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:     client: &fake.LogicalClient{",
          "159:      ReadFn: func(path string) (*api.Secret, error) {",
          "160:       return &api.Secret{",
          "162:         \"key1\": \"val1\",",
          "163:         \"key2\": \"val2\",",
          "164:        },",
          "165:       }, nil",
          "166:      },",
          "168:       return nil, errBoom",
          "169:      },",
          "170:     },",
          "",
          "[Removed Lines]",
          "161:        Data: map[string]interface{}{",
          "167:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "161:        Data: map[string]any{",
          "167:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:     client: &fake.LogicalClient{",
          "185:      ReadFn: func(path string) (*api.Secret, error) {",
          "186:       return &api.Secret{",
          "188:         \"foo\":                               \"bar\",",
          "189:         metadataPrefix + \"owner\":            \"jdoe\",",
          "190:         metadataPrefix + \"mission_critical\": \"false\",",
          "191:        },",
          "192:       }, nil",
          "193:      },",
          "195:       return nil, errors.New(\"no write operation expected\")",
          "196:      },",
          "197:     },",
          "",
          "[Removed Lines]",
          "187:        Data: map[string]interface{}{",
          "194:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "187:        Data: map[string]any{",
          "194:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217:       return nil, nil",
          "218:      },",
          "220:       if diff := cmp.Diff(filepath.Join(mountPath, secretName), path); diff != \"\" {",
          "221:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "222:       }",
          "224:        \"key1\": \"val1\",",
          "225:        \"key2\": \"val2\",",
          "226:       }, data); diff != \"\" {",
          "",
          "[Removed Lines]",
          "219:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "223:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "219:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "223:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "245:     client: &fake.LogicalClient{",
          "246:      ReadFn: func(path string) (*api.Secret, error) {",
          "247:       return &api.Secret{",
          "249:         \"key1\": \"val1\",",
          "250:         \"key2\": \"val2\",",
          "251:        },",
          "252:       }, nil",
          "253:      },",
          "255:       if diff := cmp.Diff(filepath.Join(mountPath, secretName), path); diff != \"\" {",
          "256:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "257:       }",
          "259:        \"key1\": \"val1updated\",",
          "260:        \"key2\": \"val2\",",
          "261:        \"key3\": \"val3\",",
          "",
          "[Removed Lines]",
          "248:        Data: map[string]interface{}{",
          "254:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "258:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "248:        Data: map[string]any{",
          "254:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "258:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "286:     client: &fake.LogicalClient{",
          "287:      ReadFn: func(path string) (*api.Secret, error) {",
          "288:       return &api.Secret{",
          "290:         \"key1\": \"val1\",",
          "291:         \"key2\": \"val2\",",
          "292:        },",
          "293:       }, nil",
          "294:      },",
          "296:       if diff := cmp.Diff(filepath.Join(mountPath, secretName), path); diff != \"\" {",
          "297:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "298:       }",
          "300:        \"key1\": \"val1updated\",",
          "301:        \"key2\": \"val2\",",
          "302:        \"key3\": \"val3\",",
          "",
          "[Removed Lines]",
          "289:        Data: map[string]interface{}{",
          "295:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "299:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "289:        Data: map[string]any{",
          "295:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "299:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "327:     client: &fake.LogicalClient{",
          "328:      ReadFn: func(path string) (*api.Secret, error) {",
          "329:       return &api.Secret{",
          "331:         \"key1\": \"val1\",",
          "332:         \"key2\": \"val2\",",
          "333:        },",
          "334:       }, nil",
          "335:      },",
          "337:       if diff := cmp.Diff(filepath.Join(mountPath, secretName), path); diff != \"\" {",
          "338:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "339:       }",
          "341:        \"key1\":                 \"val1\",",
          "342:        \"key2\":                 \"val2\",",
          "343:        metadataPrefix + \"foo\": \"bar\",",
          "",
          "[Removed Lines]",
          "330:        Data: map[string]interface{}{",
          "336:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "340:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "330:        Data: map[string]any{",
          "336:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "340:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "367:     client: &fake.LogicalClient{",
          "368:      ReadFn: func(path string) (*api.Secret, error) {",
          "369:       return &api.Secret{",
          "371:         \"key1\":                 \"val1\",",
          "372:         \"key2\":                 \"val2\",",
          "373:         metadataPrefix + \"old\": \"meta\",",
          "374:        },",
          "375:       }, nil",
          "376:      },",
          "378:       if diff := cmp.Diff(filepath.Join(mountPath, secretName), path); diff != \"\" {",
          "379:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "380:       }",
          "382:        \"key1\":                 \"val1\",",
          "383:        \"key2\":                 \"val2\",",
          "384:        metadataPrefix + \"old\": \"meta\",",
          "",
          "[Removed Lines]",
          "370:        Data: map[string]interface{}{",
          "377:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "381:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "370:        Data: map[string]any{",
          "377:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "381:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "467:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "468:       }",
          "469:       return &api.Secret{",
          "471:         \"foo\": \"bar\",",
          "472:        },",
          "473:       }, nil",
          "",
          "[Removed Lines]",
          "470:        Data: map[string]interface{}{",
          "",
          "[Added Lines]",
          "470:        Data: map[string]any{",
          "",
          "---------------"
        ],
        "pkg/connection/store/vault/kv/v2.go||pkg/connection/store/vault/kv/v2.go": [
          "File: pkg/connection/store/vault/kv/v2.go -> pkg/connection/store/vault/kv/v2.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:  return errors.Wrap(err, errDelete)",
          "107: }",
          "110:  data := make(map[string]string, len(existing.Data)+len(new.Data))",
          "111:  for k, v := range existing.Data {",
          "112:   data[k] = v",
          "",
          "[Removed Lines]",
          "109: func dataPayload(existing, new *Secret) (map[string]interface{}, bool) {",
          "",
          "[Added Lines]",
          "109: func dataPayload(existing, new *Secret) (map[string]any, bool) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122:  if existing.version != \"\" {",
          "123:   ver = existing.version",
          "124:  }",
          "127:    \"cas\": ver,",
          "128:   },",
          "129:   \"data\": data,",
          "130:  }, changed",
          "131: }",
          "135:   \"custom_metadata\": new,",
          "136:  }",
          "137:  if len(existing) != len(new) {",
          "",
          "[Removed Lines]",
          "125:  return map[string]interface{}{",
          "126:   \"options\": map[string]interface{}{",
          "133: func metadataPayload(existing, new map[string]string) (map[string]interface{}, bool) {",
          "134:  payload := map[string]interface{}{",
          "",
          "[Added Lines]",
          "125:  return map[string]any{",
          "126:   \"options\": map[string]any{",
          "133: func metadataPayload(existing, new map[string]string) (map[string]any, bool) {",
          "134:  payload := map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160: }",
          "162: func parseSecretData(payload *fieldpath.Paved, kv *Secret) error {",
          "164:  err := payload.GetValueInto(\"data\", &sData)",
          "165:  if fieldpath.IsNotFound(err) {",
          "166:   return nil",
          "",
          "[Removed Lines]",
          "163:  sData := map[string]interface{}{}",
          "",
          "[Added Lines]",
          "163:  sData := map[string]any{}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "179: }",
          "181: func parseSecretMeta(payload *fieldpath.Paved, kv *Secret) error {",
          "183:  err := payload.GetValueInto(\"metadata\", &sMeta)",
          "184:  if fieldpath.IsNotFound(err) {",
          "185:   return nil",
          "",
          "[Removed Lines]",
          "182:  sMeta := map[string]interface{}{}",
          "",
          "[Added Lines]",
          "182:  sMeta := map[string]any{}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "193:   return err",
          "194:  }",
          "197:  err = pavedMeta.GetValueInto(\"custom_metadata\", &customMeta)",
          "198:  if fieldpath.IsNotFound(err) {",
          "199:   return nil",
          "",
          "[Removed Lines]",
          "196:  customMeta := map[string]interface{}{}",
          "",
          "[Added Lines]",
          "196:  customMeta := map[string]any{}",
          "",
          "---------------"
        ],
        "pkg/connection/store/vault/kv/v2_test.go||pkg/connection/store/vault/kv/v2_test.go": [
          "File: pkg/connection/store/vault/kv/v2_test.go -> pkg/connection/store/vault/kv/v2_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:       return &api.Secret{",
          "103:          \"created_time\": \"2018-03-22T02:24:06.945319214Z\",",
          "105:           \"owner\":            \"jdoe\",",
          "106:           \"mission_critical\": \"false\",",
          "107:          },",
          "",
          "[Removed Lines]",
          "101:        Data: map[string]interface{}{",
          "102:         \"metadata\": map[string]interface{}{",
          "104:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "101:        Data: map[string]any{",
          "102:         \"metadata\": map[string]any{",
          "104:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "132:       return &api.Secret{",
          "137:          \"foo\": \"bar\",",
          "138:         },",
          "139:        },",
          "",
          "[Removed Lines]",
          "135:        Data: map[string]interface{}{",
          "136:         \"data\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "135:        Data: map[string]any{",
          "136:         \"data\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "159:       return &api.Secret{",
          "164:          \"foo\": \"bar\",",
          "165:         },",
          "167:          \"created_time\": \"2018-03-22T02:24:06.945319214Z\",",
          "169:           \"owner\":            \"jdoe\",",
          "170:           \"mission_critical\": \"false\",",
          "171:          },",
          "",
          "[Removed Lines]",
          "162:        Data: map[string]interface{}{",
          "163:         \"data\": map[string]interface{}{",
          "166:         \"metadata\": map[string]interface{}{",
          "168:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "162:        Data: map[string]any{",
          "163:         \"data\": map[string]any{",
          "166:         \"metadata\": map[string]any{",
          "168:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "242:     client: &fake.LogicalClient{",
          "243:      ReadFn: func(path string) (*api.Secret, error) {",
          "244:       return &api.Secret{",
          "246:         \"data\": map[string]string{",
          "247:          \"key1\": \"val1\",",
          "248:          \"key2\": \"val2\",",
          "249:         },",
          "252:           \"foo\": \"bar\",",
          "253:           \"baz\": \"qux\",",
          "254:          },",
          "",
          "[Removed Lines]",
          "245:        Data: map[string]interface{}{",
          "250:         \"metadata\": map[string]interface{}{",
          "251:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "245:        Data: map[string]any{",
          "250:         \"metadata\": map[string]any{",
          "251:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "257:        },",
          "258:       }, nil",
          "259:      },",
          "261:       return nil, errBoom",
          "262:      },",
          "263:     },",
          "",
          "[Removed Lines]",
          "260:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "260:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "280:     client: &fake.LogicalClient{",
          "281:      ReadFn: func(path string) (*api.Secret, error) {",
          "282:       return &api.Secret{",
          "284:         \"data\": map[string]string{",
          "285:          \"key1\": \"val1\",",
          "286:          \"key2\": \"val2\",",
          "287:         },",
          "290:           \"foo\": \"bar\",",
          "291:          },",
          "292:          \"version\": json.Number(\"2\"),",
          "",
          "[Removed Lines]",
          "283:        Data: map[string]interface{}{",
          "288:         \"metadata\": map[string]interface{}{",
          "289:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "283:        Data: map[string]any{",
          "288:         \"metadata\": map[string]any{",
          "289:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "294:        },",
          "295:       }, nil",
          "296:      },",
          "298:       return nil, errBoom",
          "299:      },",
          "300:     },",
          "",
          "[Removed Lines]",
          "297:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "297:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "318:       return &api.Secret{",
          "323:          \"foo\": \"bar\",",
          "324:         },",
          "326:          \"created_time\": \"2018-03-22T02:24:06.945319214Z\",",
          "328:           \"owner\":            \"jdoe\",",
          "329:           \"mission_critical\": \"false\",",
          "330:          },",
          "",
          "[Removed Lines]",
          "321:        Data: map[string]interface{}{",
          "322:         \"data\": map[string]interface{}{",
          "325:         \"metadata\": map[string]interface{}{",
          "327:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "321:        Data: map[string]any{",
          "322:         \"data\": map[string]any{",
          "325:         \"metadata\": map[string]any{",
          "327:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "335:        },",
          "336:       }, nil",
          "337:      },",
          "339:       return nil, errors.New(\"no write operation expected\")",
          "340:      },",
          "341:     },",
          "",
          "[Removed Lines]",
          "338:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "",
          "[Added Lines]",
          "338:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "361:       return nil, nil",
          "362:      },",
          "364:       if diff := cmp.Diff(filepath.Join(mountPath, \"data\", secretName), path); diff != \"\" {",
          "365:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "366:       }",
          "368:        \"data\": map[string]string{",
          "369:         \"key1\": \"val1\",",
          "370:         \"key2\": \"val2\",",
          "371:        },",
          "373:         \"cas\": json.Number(\"0\"),",
          "374:        },",
          "375:       }, data); diff != \"\" {",
          "",
          "[Removed Lines]",
          "363:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "367:       if diff := cmp.Diff(map[string]interface{}{",
          "372:        \"options\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "363:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "367:       if diff := cmp.Diff(map[string]any{",
          "372:        \"options\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "394:     client: &fake.LogicalClient{",
          "395:      ReadFn: func(path string) (*api.Secret, error) {",
          "396:       return &api.Secret{",
          "399:          \"key1\": \"val1\",",
          "400:          \"key2\": \"val2\",",
          "401:         },",
          "404:           \"foo\": \"bar\",",
          "405:           \"baz\": \"qux\",",
          "406:          },",
          "",
          "[Removed Lines]",
          "397:        Data: map[string]interface{}{",
          "398:         \"data\": map[string]interface{}{",
          "402:         \"metadata\": map[string]interface{}{",
          "403:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "397:        Data: map[string]any{",
          "398:         \"data\": map[string]any{",
          "402:         \"metadata\": map[string]any{",
          "403:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "409:        },",
          "410:       }, nil",
          "411:      },",
          "413:       if diff := cmp.Diff(filepath.Join(mountPath, \"data\", secretName), path); diff != \"\" {",
          "414:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "415:       }",
          "417:        \"data\": map[string]string{",
          "418:         \"key1\": \"val1updated\",",
          "419:         \"key2\": \"val2\",",
          "420:         \"key3\": \"val3\",",
          "421:        },",
          "423:         \"cas\": json.Number(\"2\"),",
          "424:        },",
          "425:       }, data); diff != \"\" {",
          "",
          "[Removed Lines]",
          "412:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "416:       if diff := cmp.Diff(map[string]interface{}{",
          "422:        \"options\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "412:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "416:       if diff := cmp.Diff(map[string]any{",
          "422:        \"options\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "452:     client: &fake.LogicalClient{",
          "453:      ReadFn: func(path string) (*api.Secret, error) {",
          "454:       return &api.Secret{",
          "457:          \"key1\": \"val1\",",
          "458:          \"key2\": \"val2\",",
          "459:         },",
          "462:           \"foo\": \"bar\",",
          "463:           \"baz\": \"qux\",",
          "464:          },",
          "",
          "[Removed Lines]",
          "455:        Data: map[string]interface{}{",
          "456:         \"data\": map[string]interface{}{",
          "460:         \"metadata\": map[string]interface{}{",
          "461:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "455:        Data: map[string]any{",
          "456:         \"data\": map[string]any{",
          "460:         \"metadata\": map[string]any{",
          "461:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "467:        },",
          "468:       }, nil",
          "469:      },",
          "471:       if diff := cmp.Diff(filepath.Join(mountPath, \"data\", secretName), path); diff != \"\" {",
          "472:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "473:       }",
          "475:        \"data\": map[string]string{",
          "476:         \"key1\": \"val1updated\",",
          "477:         \"key2\": \"val2\",",
          "478:         \"key3\": \"val3\",",
          "479:        },",
          "481:         \"cas\": json.Number(\"2\"),",
          "482:        },",
          "483:       }, data); diff != \"\" {",
          "",
          "[Removed Lines]",
          "470:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "474:       if diff := cmp.Diff(map[string]interface{}{",
          "480:        \"options\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "470:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "474:       if diff := cmp.Diff(map[string]any{",
          "480:        \"options\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "510:     client: &fake.LogicalClient{",
          "511:      ReadFn: func(path string) (*api.Secret, error) {",
          "512:       return &api.Secret{",
          "515:          \"key1\": \"val1\",",
          "516:          \"key2\": \"val2\",",
          "517:         },",
          "519:          \"version\": json.Number(\"2\"),",
          "520:         },",
          "521:        },",
          "522:       }, nil",
          "523:      },",
          "525:       if diff := cmp.Diff(filepath.Join(mountPath, \"metadata\", secretName), path); diff != \"\" {",
          "526:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "527:       }",
          "529:        \"custom_metadata\": map[string]string{",
          "530:         \"foo\": \"bar\",",
          "531:         \"baz\": \"qux\",",
          "",
          "[Removed Lines]",
          "513:        Data: map[string]interface{}{",
          "514:         \"data\": map[string]interface{}{",
          "518:         \"metadata\": map[string]interface{}{",
          "524:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "528:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "513:        Data: map[string]any{",
          "514:         \"data\": map[string]any{",
          "518:         \"metadata\": map[string]any{",
          "524:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "528:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "555:     client: &fake.LogicalClient{",
          "556:      ReadFn: func(path string) (*api.Secret, error) {",
          "557:       return &api.Secret{",
          "560:          \"key1\": \"val1\",",
          "561:          \"key2\": \"val2\",",
          "562:         },",
          "565:           \"old\": \"meta\",",
          "566:          },",
          "567:          \"version\": json.Number(\"2\"),",
          "",
          "[Removed Lines]",
          "558:        Data: map[string]interface{}{",
          "559:         \"data\": map[string]interface{}{",
          "563:         \"metadata\": map[string]interface{}{",
          "564:          \"custom_metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "558:        Data: map[string]any{",
          "559:         \"data\": map[string]any{",
          "563:         \"metadata\": map[string]any{",
          "564:          \"custom_metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "569:        },",
          "570:       }, nil",
          "571:      },",
          "573:       if diff := cmp.Diff(filepath.Join(mountPath, \"metadata\", secretName), path); diff != \"\" {",
          "574:        t.Errorf(\"r: -want, +got:\\n%s\", diff)",
          "575:       }",
          "577:        \"custom_metadata\": map[string]string{",
          "578:         \"foo\": \"bar\",",
          "579:         \"baz\": \"qux\",",
          "",
          "[Removed Lines]",
          "572:      WriteFn: func(path string, data map[string]interface{}) (*api.Secret, error) {",
          "576:       if diff := cmp.Diff(map[string]interface{}{",
          "",
          "[Added Lines]",
          "572:      WriteFn: func(path string, data map[string]any) (*api.Secret, error) {",
          "576:       if diff := cmp.Diff(map[string]any{",
          "",
          "---------------"
        ],
        "pkg/errors/errors.go||pkg/errors/errors.go": [
          "File: pkg/errors/errors.go -> pkg/errors/errors.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "64: func As(err error, target interface{}) bool { return errors.As(err, target) }",
          "",
          "[Added Lines]",
          "64: func As(err error, target any) bool { return errors.As(err, target) }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "78: func Errorf(format string, a ...interface{}) error { return fmt.Errorf(format, a...) }",
          "",
          "[Added Lines]",
          "78: func Errorf(format string, a ...any) error { return fmt.Errorf(format, a...) }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:  if err == nil {",
          "93:   return nil",
          "94:  }",
          "",
          "[Removed Lines]",
          "91: func WithMessagef(err error, format string, args ...interface{}) error {",
          "",
          "[Added Lines]",
          "91: func WithMessagef(err error, format string, args ...any) error {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101: }",
          "105:  return WithMessagef(err, format, args...)",
          "106: }",
          "",
          "[Removed Lines]",
          "104: func Wrapf(err error, format string, args ...interface{}) error {",
          "",
          "[Added Lines]",
          "104: func Wrapf(err error, format string, args ...any) error {",
          "",
          "---------------"
        ],
        "pkg/errors/errors_test.go||pkg/errors/errors_test.go": [
          "File: pkg/errors/errors_test.go -> pkg/errors/errors_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:  type args struct {",
          "64:   err     error",
          "65:   message string",
          "67:  }",
          "68:  cases := map[string]struct {",
          "69:   args args",
          "",
          "[Removed Lines]",
          "66:   args    []interface{}",
          "",
          "[Added Lines]",
          "66:   args    []any",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:    args: args{",
          "81:     err:     New(\"boom\"),",
          "82:     message: \"very useful context about %s\",",
          "84:    },",
          "85:    want: Errorf(\"very useful context about %s: %w\", \"ducks\", New(\"boom\")),",
          "86:   },",
          "",
          "[Removed Lines]",
          "83:     args:    []interface{}{\"ducks\"},",
          "",
          "[Added Lines]",
          "83:     args:    []any{\"ducks\"},",
          "",
          "---------------"
        ],
        "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
          "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:  l.start = l.pos",
          "188: }",
          "191:  l.items <- item{typ: itemError, pos: pos, val: fmt.Sprintf(format, args...)}",
          "192:  return nil",
          "193: }",
          "",
          "[Removed Lines]",
          "190: func (l *lexer) errorf(pos int, format string, args ...interface{}) stateFn {",
          "",
          "[Added Lines]",
          "190: func (l *lexer) errorf(pos int, format string, args ...any) stateFn {",
          "",
          "---------------"
        ],
        "pkg/fieldpath/merge.go||pkg/fieldpath/merge.go": [
          "File: pkg/fieldpath/merge.go -> pkg/fieldpath/merge.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:  dst, err := p.GetValue(path)",
          "36:  if IsNotFound(err) || mo == nil {",
          "37:   dst = nil",
          "",
          "[Removed Lines]",
          "34: func (p *Paved) MergeValue(path string, value interface{}, mo *xpv1.MergeOptions) error {",
          "",
          "[Added Lines]",
          "34: func (p *Paved) MergeValue(path string, value any, mo *xpv1.MergeOptions) error {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:  const keyArg = \"arg\"",
          "62:    keyArg: arg,",
          "63:   }",
          "64:  }",
          "",
          "[Removed Lines]",
          "55: func merge(dst, src interface{}, mergeOptions *xpv1.MergeOptions) (interface{}, error) {",
          "60:  argWrap := func(arg interface{}) map[string]interface{} {",
          "61:   return map[string]interface{}{",
          "",
          "[Added Lines]",
          "55: func merge(dst, src any, mergeOptions *xpv1.MergeOptions) (any, error) {",
          "60:  argWrap := func(arg any) map[string]any {",
          "61:   return map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:  return mDst[keyArg], nil",
          "81: }",
          "84:  sliceDst, sliceSrc := reflect.ValueOf(dst), reflect.ValueOf(src)",
          "85:  if sliceDst.Kind() == reflect.Ptr {",
          "86:   sliceDst = sliceDst.Elem()",
          "",
          "[Removed Lines]",
          "83: func removeSourceDuplicates(dst, src interface{}) interface{} {",
          "",
          "[Added Lines]",
          "83: func removeSourceDuplicates(dst, src any) any {",
          "",
          "---------------"
        ],
        "pkg/fieldpath/merge_test.go||pkg/fieldpath/merge_test.go": [
          "File: pkg/fieldpath/merge_test.go -> pkg/fieldpath/merge_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:  }",
          "49:  arrSrc := []string{valSrc}",
          "52:  }",
          "53:  arrDst := []string{valDst}",
          "56:  }",
          "57:  valFalse, valTrue := false, true",
          "59:  type fields struct {",
          "61:  }",
          "62:  type args struct {",
          "63:   path  string",
          "65:   mo    *xpv1.MergeOptions",
          "66:  }",
          "67:  type want struct {",
          "",
          "[Removed Lines]",
          "50:  fnMapSrc := func() map[string]interface{} {",
          "51:   return map[string]interface{}{pathTest: valSrc}",
          "54:  fnMapDst := func() map[string]interface{} {",
          "55:   return map[string]interface{}{pathTest: map[string]interface{}{pathTest: valDst}}",
          "60:   object map[string]interface{}",
          "64:   value interface{}",
          "",
          "[Added Lines]",
          "50:  fnMapSrc := func() map[string]any {",
          "51:   return map[string]any{pathTest: valSrc}",
          "54:  fnMapDst := func() map[string]any {",
          "55:   return map[string]any{pathTest: map[string]any{pathTest: valDst}}",
          "60:   object map[string]any",
          "64:   value any",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:   \"MergeArrayNoMergeOptions\": {",
          "78:    reason: \"If no merge options are given, default is to override an array\",",
          "79:    fields: fields{",
          "81:      pathTest: valDst,",
          "82:     },",
          "83:    },",
          "",
          "[Removed Lines]",
          "80:     object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "80:     object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:   \"MergeArrayNoAppend\": {",
          "93:    reason: \"If MergeOptions.AppendSlice is false, an array should be overridden when merging\",",
          "94:    fields: fields{",
          "96:      pathTest: arrDst,",
          "97:     },",
          "98:    },",
          "",
          "[Removed Lines]",
          "95:     object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "95:     object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:   \"MergeArrayAppend\": {",
          "111:    reason: \"If MergeOptions.AppendSlice is true, dst array should be merged with the src array\",",
          "112:    fields: fields{",
          "114:      pathTest: arrDst,",
          "115:     },",
          "116:    },",
          "",
          "[Removed Lines]",
          "113:     object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "113:     object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:   \"MergeArrayAppendDuplicate\": {",
          "129:    reason: \"If MergeOptions.AppendSlice is true, dst array should be merged with the src array not allowing duplicates\",",
          "130:    fields: fields{",
          "132:      pathTest: []string{valDst, valSrc},",
          "133:     },",
          "134:    },",
          "",
          "[Removed Lines]",
          "131:     object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "131:     object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "191:  }",
          "192:  for name, tc := range tests {",
          "193:   t.Run(name, func(t *testing.T) {",
          "195:    if err := json.Unmarshal([]byte(tc.want.serialized), &want); err != nil {",
          "196:     t.Fatalf(\"Test case error: Unable to unmarshall JSON doc: %v\", err)",
          "197:    }",
          "",
          "[Removed Lines]",
          "194:    want := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "194:    want := make(map[string]any)",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: type Paved struct {",
          "50: }",
          "",
          "[Removed Lines]",
          "49:  object map[string]interface{}",
          "",
          "[Added Lines]",
          "49:  object map[string]any",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57: }",
          "61:  return &Paved{object: object}",
          "62: }",
          "",
          "[Removed Lines]",
          "60: func Pave(object map[string]interface{}) *Paved {",
          "",
          "[Added Lines]",
          "60: func Pave(object map[string]any) *Paved {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72: }",
          "76:  if p.object == nil {",
          "78:  }",
          "79:  return p.object",
          "80: }",
          "84:  p.object = content",
          "85: }",
          "88:  return getValueFromInterface(p.object, s)",
          "89: }",
          "92:  for i, current := range s {",
          "93:   final := i == len(s)-1",
          "94:   switch current.Type {",
          "95:   case SegmentIndex:",
          "97:    if !ok {",
          "98:     return nil, errors.Errorf(\"%s: not an array\", s[:i])",
          "99:    }",
          "",
          "[Removed Lines]",
          "75: func (p *Paved) UnstructuredContent() map[string]interface{} {",
          "77:   return make(map[string]interface{})",
          "83: func (p *Paved) SetUnstructuredContent(content map[string]interface{}) {",
          "87: func (p *Paved) getValue(s Segments) (interface{}, error) {",
          "91: func getValueFromInterface(it interface{}, s Segments) (interface{}, error) {",
          "96:    array, ok := it.([]interface{})",
          "",
          "[Added Lines]",
          "75: func (p *Paved) UnstructuredContent() map[string]any {",
          "77:   return make(map[string]any)",
          "83: func (p *Paved) SetUnstructuredContent(content map[string]any) {",
          "87: func (p *Paved) getValue(s Segments) (any, error) {",
          "91: func getValueFromInterface(it any, s Segments) (any, error) {",
          "96:    array, ok := it.([]any)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "105:    }",
          "106:    it = array[current.Index]",
          "107:   case SegmentField:",
          "109:    if !ok {",
          "110:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
          "111:    }",
          "",
          "[Removed Lines]",
          "108:    object, ok := it.(map[string]interface{})",
          "",
          "[Added Lines]",
          "108:    object, ok := it.(map[string]any)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "156:  var res []Segments",
          "157:  it := data",
          "158:  for i, current := range segments {",
          "160:   if current.Type == SegmentField && current.Field == wildcard {",
          "161:    switch mapOrArray := it.(type) {",
          "163:     for ix := range mapOrArray {",
          "164:      expanded := make(Segments, len(segments))",
          "165:      copy(expanded, segments)",
          "",
          "[Removed Lines]",
          "155: func expandWildcards(data interface{}, segments Segments) ([]Segments, error) { //nolint:gocyclo",
          "162:    case []interface{}:",
          "",
          "[Added Lines]",
          "155: func expandWildcards(data any, segments Segments) ([]Segments, error) { //nolint:gocyclo",
          "162:    case []any:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "170:      }",
          "171:      res = append(res, r...)",
          "172:     }",
          "174:     for k := range mapOrArray {",
          "175:      expanded := make(Segments, len(segments))",
          "176:      copy(expanded, segments)",
          "",
          "[Removed Lines]",
          "173:    case map[string]interface{}:",
          "",
          "[Added Lines]",
          "173:    case map[string]any:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "199: }",
          "203:  segments, err := Parse(path)",
          "204:  if err != nil {",
          "205:   return nil, errors.Wrapf(err, \"cannot parse path %q\", path)",
          "",
          "[Removed Lines]",
          "202: func (p *Paved) GetValue(path string) (interface{}, error) {",
          "",
          "[Added Lines]",
          "202: func (p *Paved) GetValue(path string) (any, error) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "209: }",
          "213:  val, err := p.GetValue(path)",
          "214:  if err != nil {",
          "215:   return err",
          "",
          "[Removed Lines]",
          "212: func (p *Paved) GetValueInto(path string, out interface{}) error {",
          "",
          "[Added Lines]",
          "212: func (p *Paved) GetValueInto(path string, out any) error {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "242:   return nil, err",
          "243:  }",
          "246:  if !ok {",
          "247:   return nil, errors.Errorf(\"%s: not an array\", path)",
          "248:  }",
          "",
          "[Removed Lines]",
          "245:  a, ok := v.([]interface{})",
          "",
          "[Added Lines]",
          "245:  a, ok := v.([]any)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "266:   return nil, err",
          "267:  }",
          "270:  if !ok {",
          "271:   return nil, errors.Errorf(\"%s: not an object\", path)",
          "272:  }",
          "",
          "[Removed Lines]",
          "269:  o, ok := v.(map[string]interface{})",
          "",
          "[Added Lines]",
          "269:  o, ok := v.(map[string]any)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "334:  return f, nil",
          "335: }",
          "343:  j, err := json.Marshal(value)",
          "344:  if err != nil {",
          "345:   return errors.Wrap(err, \"cannot marshal value to JSON\")",
          "",
          "[Removed Lines]",
          "337: func (p *Paved) setValue(s Segments, value interface{}) error {",
          "342:  var v interface{}",
          "",
          "[Added Lines]",
          "337: func (p *Paved) setValue(s Segments, value any) error {",
          "342:  var v any",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "348:   return errors.Wrap(err, \"cannot unmarshal value from JSON\")",
          "349:  }",
          "352:  for i, current := range s {",
          "353:   final := i == len(s)-1",
          "355:   switch current.Type {",
          "356:   case SegmentIndex:",
          "358:    if !ok {",
          "359:     return errors.Errorf(\"%s is not an array\", s[:i])",
          "360:    }",
          "",
          "[Removed Lines]",
          "351:  var in interface{} = p.object",
          "357:    array, ok := in.([]interface{})",
          "",
          "[Added Lines]",
          "351:  var in any = p.object",
          "357:    array, ok := in.([]any)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "368:    in = array[current.Index]",
          "370:   case SegmentField:",
          "372:    if !ok {",
          "373:     return errors.Errorf(\"%s is not an object\", s[:i])",
          "374:    }",
          "",
          "[Removed Lines]",
          "371:    object, ok := in.(map[string]interface{})",
          "",
          "[Added Lines]",
          "371:    object, ok := in.(map[string]any)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "386:  return nil",
          "387: }",
          "392:  if array[current.Index] == nil {",
          "393:   switch next.Type {",
          "394:   case SegmentIndex:",
          "396:   case SegmentField:",
          "398:   }",
          "399:   return",
          "400:  }",
          "",
          "[Removed Lines]",
          "389: func prepareElement(array []interface{}, current, next Segment) {",
          "395:    array[current.Index] = make([]interface{}, next.Index+1)",
          "397:    array[current.Index] = make(map[string]interface{})",
          "",
          "[Added Lines]",
          "389: func prepareElement(array []any, current, next Segment) {",
          "395:    array[current.Index] = make([]any, next.Index+1)",
          "397:    array[current.Index] = make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "405:   return",
          "406:  }",
          "409:  if !ok {",
          "410:   return",
          "411:  }",
          "",
          "[Removed Lines]",
          "408:  na, ok := array[current.Index].([]interface{})",
          "",
          "[Added Lines]",
          "408:  na, ok := array[current.Index].([]any)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "414:   return",
          "415:  }",
          "418: }",
          "423:  if _, ok := object[current.Field]; !ok {",
          "424:   switch next.Type {",
          "425:   case SegmentIndex:",
          "427:   case SegmentField:",
          "429:   }",
          "430:   return",
          "431:  }",
          "",
          "[Removed Lines]",
          "417:  array[current.Index] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
          "420: func prepareField(object map[string]interface{}, current, next Segment) {",
          "426:    object[current.Field] = make([]interface{}, next.Index+1)",
          "428:    object[current.Field] = make(map[string]interface{})",
          "",
          "[Added Lines]",
          "417:  array[current.Index] = append(na, make([]any, int(next.Index)-len(na)+1)...)",
          "420: func prepareField(object map[string]any, current, next Segment) {",
          "426:    object[current.Field] = make([]any, next.Index+1)",
          "428:    object[current.Field] = make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "436:   return",
          "437:  }",
          "440:  if !ok {",
          "441:   return",
          "442:  }",
          "",
          "[Removed Lines]",
          "439:  na, ok := object[current.Field].([]interface{})",
          "",
          "[Added Lines]",
          "439:  na, ok := object[current.Field].([]any)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "445:   return",
          "446:  }",
          "449: }",
          "453:  segments, err := Parse(path)",
          "454:  if err != nil {",
          "455:   return errors.Wrapf(err, \"cannot parse path %q\", path)",
          "",
          "[Removed Lines]",
          "448:  object[current.Field] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
          "452: func (p *Paved) SetValue(path string, value interface{}) error {",
          "",
          "[Added Lines]",
          "448:  object[current.Field] = append(na, make([]any, int(next.Index)-len(na)+1)...)",
          "452: func (p *Paved) SetValue(path string, value any) error {",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: func TestGetValue(t *testing.T) {",
          "66:  type want struct {",
          "68:   err   error",
          "69:  }",
          "70:  cases := map[string]struct {",
          "",
          "[Removed Lines]",
          "67:   value interface{}",
          "",
          "[Added Lines]",
          "67:   value any",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:  for name, tc := range cases {",
          "166:   t.Run(name, func(t *testing.T) {",
          "168:    _ = json.Unmarshal(tc.data, &in)",
          "169:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "167:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "167:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191:  type args struct {",
          "192:   path string",
          "194:  }",
          "195:  type want struct {",
          "197:   err error",
          "198:  }",
          "199:  cases := map[string]struct {",
          "",
          "[Removed Lines]",
          "193:   out  interface{}",
          "196:   out interface{}",
          "",
          "[Added Lines]",
          "193:   out  any",
          "196:   out any",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "241:  for name, tc := range cases {",
          "242:   t.Run(name, func(t *testing.T) {",
          "244:    _ = json.Unmarshal(tc.data, &in)",
          "245:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "243:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "243:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "294:  for name, tc := range cases {",
          "295:   t.Run(name, func(t *testing.T) {",
          "297:    _ = json.Unmarshal(tc.data, &in)",
          "298:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "296:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "296:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "355:  for name, tc := range cases {",
          "356:   t.Run(name, func(t *testing.T) {",
          "358:    _ = json.Unmarshal(tc.data, &in)",
          "359:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "357:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "357:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "416:  for name, tc := range cases {",
          "417:   t.Run(name, func(t *testing.T) {",
          "419:    _ = json.Unmarshal(tc.data, &in)",
          "420:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "418:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "418:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "469:  for name, tc := range cases {",
          "470:   t.Run(name, func(t *testing.T) {",
          "472:    _ = json.Unmarshal(tc.data, &in)",
          "473:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "471:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "471:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "522:  for name, tc := range cases {",
          "523:   t.Run(name, func(t *testing.T) {",
          "525:    _ = json.Unmarshal(tc.data, &in)",
          "526:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "524:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "524:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "575:  for name, tc := range cases {",
          "576:   t.Run(name, func(t *testing.T) {",
          "578:    _ = json.Unmarshal(tc.data, &in)",
          "579:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "577:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "577:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "592: func TestSetValue(t *testing.T) {",
          "593:  type args struct {",
          "594:   path  string",
          "596:  }",
          "597:  type want struct {",
          "599:   err    error",
          "600:  }",
          "601:  cases := map[string]struct {",
          "",
          "[Removed Lines]",
          "595:   value interface{}",
          "598:   object map[string]interface{}",
          "",
          "[Added Lines]",
          "595:   value any",
          "598:   object map[string]any",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "612:     value: \"cool\",",
          "613:    },",
          "614:    want: want{",
          "617:       \"name\": \"cool\",",
          "618:      },",
          "619:     },",
          "",
          "[Removed Lines]",
          "615:     object: map[string]interface{}{",
          "616:      \"metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "615:     object: map[string]any{",
          "616:      \"metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "627:     value: \"cool\",",
          "628:    },",
          "629:    want: want{",
          "632:       \"name\": \"cool\",",
          "633:      },",
          "634:     },",
          "",
          "[Removed Lines]",
          "630:     object: map[string]interface{}{",
          "631:      \"metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "630:     object: map[string]any{",
          "631:      \"metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "642:     value: \"cool\",",
          "643:    },",
          "644:    want: want{",
          "649:         \"name\": \"cool\",",
          "650:        },",
          "651:       },",
          "",
          "[Removed Lines]",
          "645:     object: map[string]interface{}{",
          "646:      \"spec\": map[string]interface{}{",
          "647:       \"containers\": []interface{}{",
          "648:        map[string]interface{}{",
          "",
          "[Added Lines]",
          "645:     object: map[string]any{",
          "646:      \"spec\": map[string]any{",
          "647:       \"containers\": []any{",
          "648:        map[string]any{",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "661:     value: \"cool\",",
          "662:    },",
          "663:    want: want{",
          "668:         \"name\": \"cool\",",
          "669:        },",
          "670:       },",
          "",
          "[Removed Lines]",
          "664:     object: map[string]interface{}{",
          "665:      \"spec\": map[string]interface{}{",
          "666:       \"containers\": []interface{}{",
          "667:        map[string]interface{}{",
          "",
          "[Added Lines]",
          "664:     object: map[string]any{",
          "665:      \"spec\": map[string]any{",
          "666:       \"containers\": []any{",
          "667:        map[string]any{",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "680:     value: \"cooler\",",
          "681:    },",
          "682:    want: want{",
          "687:         \"name\": \"cool\",",
          "688:        },",
          "690:         \"name\": \"cooler\",",
          "691:        },",
          "692:       },",
          "",
          "[Removed Lines]",
          "683:     object: map[string]interface{}{",
          "684:      \"spec\": map[string]interface{}{",
          "685:       \"containers\": []interface{}{",
          "686:        map[string]interface{}{",
          "689:        map[string]interface{}{",
          "",
          "[Added Lines]",
          "683:     object: map[string]any{",
          "684:      \"spec\": map[string]any{",
          "685:       \"containers\": []any{",
          "686:        map[string]any{",
          "689:        map[string]any{",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "702:     value: \"a\",",
          "703:    },",
          "704:    want: want{",
          "708:      },",
          "709:     },",
          "710:    },",
          "",
          "[Removed Lines]",
          "705:     object: map[string]interface{}{",
          "706:      \"data\": []interface{}{",
          "707:       []interface{}{\"a\"},",
          "",
          "[Added Lines]",
          "705:     object: map[string]any{",
          "706:      \"data\": []any{",
          "707:       []any{\"a\"},",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "717:     value: \"b\",",
          "718:    },",
          "719:    want: want{",
          "723:      },",
          "724:     },",
          "725:    },",
          "",
          "[Removed Lines]",
          "720:     object: map[string]interface{}{",
          "721:      \"data\": []interface{}{",
          "722:       []interface{}{\"a\", \"b\"},",
          "",
          "[Added Lines]",
          "720:     object: map[string]any{",
          "721:      \"data\": []any{",
          "722:       []any{\"a\", \"b\"},",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "732:     value: \"c\",",
          "733:    },",
          "734:    want: want{",
          "737:     },",
          "738:    },",
          "739:   },",
          "740:   \"MapStringString\": {",
          "742:    data:   []byte(`{\"metadata\":{}}`),",
          "743:    args: args{",
          "744:     path:  \"metadata.labels\",",
          "745:     value: map[string]string{\"cool\": \"very\"},",
          "746:    },",
          "747:    want: want{",
          "751:      },",
          "752:     },",
          "753:    },",
          "754:   },",
          "755:   \"OwnerReference\": {",
          "757:    data:   []byte(`{\"metadata\":{}}`),",
          "758:    args: args{",
          "759:     path: \"metadata.ownerRefs[0]\",",
          "",
          "[Removed Lines]",
          "735:     object: map[string]interface{}{",
          "736:      \"data\": []interface{}{\"a\", nil, \"c\"},",
          "741:    reason: \"A map of string to string should be converted to a map of string to interface{}\",",
          "748:     object: map[string]interface{}{",
          "749:      \"metadata\": map[string]interface{}{",
          "750:       \"labels\": map[string]interface{}{\"cool\": \"very\"},",
          "756:    reason: \"An ObjectReference (i.e. struct) should be converted to a map of string to interface{}\",",
          "",
          "[Added Lines]",
          "735:     object: map[string]any{",
          "736:      \"data\": []any{\"a\", nil, \"c\"},",
          "741:    reason: \"A map of string to string should be converted to a map of string to any\",",
          "748:     object: map[string]any{",
          "749:      \"metadata\": map[string]any{",
          "750:       \"labels\": map[string]any{\"cool\": \"very\"},",
          "756:    reason: \"An ObjectReference (i.e. struct) should be converted to a map of string to any\",",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "765:     },",
          "766:    },",
          "767:    want: want{",
          "772:         \"apiVersion\": \"v\",",
          "773:         \"kind\":       \"k\",",
          "774:         \"name\":       \"n\",",
          "",
          "[Removed Lines]",
          "768:     object: map[string]interface{}{",
          "769:      \"metadata\": map[string]interface{}{",
          "770:       \"ownerRefs\": []interface{}{",
          "771:        map[string]interface{}{",
          "",
          "[Added Lines]",
          "768:     object: map[string]any{",
          "769:      \"metadata\": map[string]any{",
          "770:       \"ownerRefs\": []any{",
          "771:        map[string]any{",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "786:     path: \"data[0]\",",
          "787:    },",
          "788:    want: want{",
          "790:     err:    errors.New(\"data is not an array\"),",
          "791:    },",
          "792:   },",
          "",
          "[Removed Lines]",
          "789:     object: map[string]interface{}{\"data\": map[string]interface{}{}},",
          "",
          "[Added Lines]",
          "789:     object: map[string]any{\"data\": map[string]any{}},",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "797:     path: \"data.name\",",
          "798:    },",
          "799:    want: want{",
          "801:     err:    errors.New(\"data is not an object\"),",
          "802:    },",
          "803:   },",
          "",
          "[Removed Lines]",
          "800:     object: map[string]interface{}{\"data\": []interface{}{}},",
          "",
          "[Added Lines]",
          "800:     object: map[string]any{\"data\": []any{}},",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "807:     path: \"spec[]\",",
          "808:    },",
          "809:    want: want{",
          "811:     err:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
          "812:    },",
          "813:   },",
          "",
          "[Removed Lines]",
          "810:     object: map[string]interface{}{},",
          "",
          "[Added Lines]",
          "810:     object: map[string]any{},",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "816:  for name, tc := range cases {",
          "817:   t.Run(name, func(t *testing.T) {",
          "819:    _ = json.Unmarshal(tc.data, &in)",
          "820:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "818:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "818:    in := make(map[string]any)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "973:  for name, tc := range cases {",
          "974:   t.Run(name, func(t *testing.T) {",
          "976:    _ = json.Unmarshal(tc.data, &in)",
          "977:    p := Pave(in)",
          "",
          "[Removed Lines]",
          "975:    in := make(map[string]interface{})",
          "",
          "[Added Lines]",
          "975:    in := make(map[string]any)",
          "",
          "---------------"
        ],
        "pkg/logging/logging.go||pkg/logging/logging.go": [
          "File: pkg/logging/logging.go -> pkg/logging/logging.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: }",
          "",
          "[Removed Lines]",
          "49:  Info(msg string, keysAndValues ...interface{})",
          "55:  Debug(msg string, keysAndValues ...interface{})",
          "61:  WithValues(keysAndValues ...interface{}) Logger",
          "",
          "[Added Lines]",
          "49:  Info(msg string, keysAndValues ...any)",
          "55:  Debug(msg string, keysAndValues ...any)",
          "61:  WithValues(keysAndValues ...any) Logger",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: type nopLogger struct{}",
          "",
          "[Removed Lines]",
          "69: func (l nopLogger) Info(msg string, keysAndValues ...interface{})  {}",
          "70: func (l nopLogger) Debug(msg string, keysAndValues ...interface{}) {}",
          "71: func (l nopLogger) WithValues(keysAndValues ...interface{}) Logger { return nopLogger{} }",
          "",
          "[Added Lines]",
          "69: func (l nopLogger) Info(msg string, keysAndValues ...any)  {}",
          "70: func (l nopLogger) Debug(msg string, keysAndValues ...any) {}",
          "71: func (l nopLogger) WithValues(keysAndValues ...any) Logger { return nopLogger{} }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:  log logr.Logger",
          "82: }",
          "85:  l.log.Info(msg, keysAndValues...)",
          "86: }",
          "89:  l.log.V(1).Info(msg, keysAndValues...)",
          "90: }",
          "93:  return logrLogger{log: l.log.WithValues(keysAndValues...)}",
          "94: }",
          "",
          "[Removed Lines]",
          "84: func (l logrLogger) Info(msg string, keysAndValues ...interface{}) {",
          "88: func (l logrLogger) Debug(msg string, keysAndValues ...interface{}) {",
          "92: func (l logrLogger) WithValues(keysAndValues ...interface{}) Logger {",
          "",
          "[Added Lines]",
          "84: func (l logrLogger) Info(msg string, keysAndValues ...any) {",
          "88: func (l logrLogger) Debug(msg string, keysAndValues ...any) {",
          "92: func (l logrLogger) WithValues(keysAndValues ...any) Logger {",
          "",
          "---------------"
        ],
        "pkg/parser/fsreader.go||pkg/parser/fsreader.go": [
          "File: pkg/parser/fsreader.go -> pkg/parser/fsreader.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "147: }",
          "153:  index := r.index",
          "",
          "[Removed Lines]",
          "150: func (r *FsReadCloser) Annotate() interface{} {",
          "",
          "[Added Lines]",
          "150: func (r *FsReadCloser) Annotate() any {",
          "",
          "---------------"
        ],
        "pkg/parser/parser.go||pkg/parser/parser.go": [
          "File: pkg/parser/parser.go -> pkg/parser/parser.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: type AnnotatedReadCloser interface {",
          "40:  io.ReadCloser",
          "42: }",
          "",
          "[Removed Lines]",
          "41:  Annotate() interface{}",
          "",
          "[Added Lines]",
          "41:  Annotate() any",
          "",
          "---------------"
        ],
        "pkg/ratelimiter/reconciler_test.go||pkg/ratelimiter/reconciler_test.go": [
          "File: pkg/ratelimiter/reconciler_test.go -> pkg/ratelimiter/reconciler_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: type predictableRateLimiter struct{ d time.Duration }",
          "40: func TestReconcile(t *testing.T) {",
          "41:  type args struct {",
          "",
          "[Removed Lines]",
          "36: func (r *predictableRateLimiter) When(_ interface{}) time.Duration { return r.d }",
          "37: func (r *predictableRateLimiter) Forget(_ interface{})             {}",
          "38: func (r *predictableRateLimiter) NumRequeues(_ interface{}) int    { return 0 }",
          "",
          "[Added Lines]",
          "36: func (r *predictableRateLimiter) When(_ any) time.Duration { return r.d }",
          "37: func (r *predictableRateLimiter) Forget(_ any)             {}",
          "38: func (r *predictableRateLimiter) NumRequeues(_ any) int    { return 0 }",
          "",
          "---------------"
        ],
        "pkg/resource/enqueue_handlers.go||pkg/resource/enqueue_handlers.go": [
          "File: pkg/resource/enqueue_handlers.go -> pkg/resource/enqueue_handlers.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: )",
          "27: type adder interface {",
          "29: }",
          "",
          "[Removed Lines]",
          "28:  Add(item interface{})",
          "",
          "[Added Lines]",
          "28:  Add(item any)",
          "",
          "---------------"
        ],
        "pkg/resource/enqueue_handlers_test.go||pkg/resource/enqueue_handlers_test.go": [
          "File: pkg/resource/enqueue_handlers_test.go -> pkg/resource/enqueue_handlers_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  _ handler.EventHandler = &EnqueueRequestForProviderConfig{}",
          "34: )",
          "39:  fn(item)",
          "40: }",
          "",
          "[Removed Lines]",
          "36: type addFn func(item interface{})",
          "38: func (fn addFn) Add(item interface{}) {",
          "",
          "[Added Lines]",
          "36: type addFn func(item any)",
          "38: func (fn addFn) Add(item any) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:   queue adder",
          "48:  }{",
          "49:   \"NotProviderConfigReferencer\": {",
          "51:   },",
          "52:   \"IsProviderConfigReferencer\": {",
          "53:    obj: &fake.ProviderConfigUsage{",
          "",
          "[Removed Lines]",
          "50:    queue: addFn(func(_ interface{}) { t.Errorf(\"queue.Add() called unexpectedly\") }),",
          "",
          "[Added Lines]",
          "50:    queue: addFn(func(_ any) { t.Errorf(\"queue.Add() called unexpectedly\") }),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:      Ref: xpv1.Reference{Name: name},",
          "56:     },",
          "57:    },",
          "59:     want := reconcile.Request{NamespacedName: types.NamespacedName{Name: name}}",
          "60:     if diff := cmp.Diff(want, got); diff != \"\" {",
          "61:      t.Errorf(\"-want, +got:\\n%s\", diff)",
          "",
          "[Removed Lines]",
          "58:    queue: addFn(func(got interface{}) {",
          "",
          "[Added Lines]",
          "58:    queue: addFn(func(got any) {",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/claim/claim.go||pkg/resource/unstructured/claim/claim.go": [
          "File: pkg/resource/unstructured/claim/claim.go -> pkg/resource/unstructured/claim/claim.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: func New(opts ...Option) *Unstructured {",
          "52:  for _, f := range opts {",
          "53:   f(c)",
          "54:  }",
          "",
          "[Removed Lines]",
          "51:  c := &Unstructured{Unstructured: unstructured.Unstructured{Object: make(map[string]interface{})}}",
          "",
          "[Added Lines]",
          "51:  c := &Unstructured{Unstructured: unstructured.Unstructured{Object: make(map[string]any)}}",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/claim/claim_test.go||pkg/resource/unstructured/claim/claim_test.go": [
          "File: pkg/resource/unstructured/claim/claim_test.go -> pkg/resource/unstructured/claim/claim_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   \"New\": {",
          "44:    gvk: gvk,",
          "45:    want: &Unstructured{Unstructured: unstructured.Unstructured{",
          "47:      \"apiVersion\": \"g/v1\",",
          "48:      \"kind\":       \"k\",",
          "49:     },",
          "",
          "[Removed Lines]",
          "46:     Object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "46:     Object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:   },",
          "87:   \"WeirdStatus\": {",
          "88:    reason: \"It should not be possible to set a condition when status is not an object.\",",
          "90:     \"status\": \"wat\",",
          "91:    }}},",
          "92:    set:  []xpv1.Condition{xpv1.Available()},",
          "",
          "[Removed Lines]",
          "89:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "89:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:   },",
          "96:   \"WeirdStatusConditions\": {",
          "97:    reason: \"Conditions should be overwritten if they are not an object.\",",
          "100:      \"conditions\": \"wat\",",
          "101:     },",
          "102:    }}},",
          "",
          "[Removed Lines]",
          "98:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "99:     \"status\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "98:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "99:     \"status\": map[string]any{",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/client.go||pkg/resource/unstructured/client.go": [
          "File: pkg/resource/unstructured/client.go -> pkg/resource/unstructured/client.go"
        ],
        "pkg/resource/unstructured/client_test.go||pkg/resource/unstructured/client_test.go": [
          "File: pkg/resource/unstructured/client_test.go -> pkg/resource/unstructured/client_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: type Wrapped struct{ client.Object }",
          "42: func (w *Wrapped) GetUnstructured() *unstructured.Unstructured {",
          "45:    \"name\": nameWrapped,",
          "46:   },",
          "47:  }}",
          "",
          "[Removed Lines]",
          "43:  return &unstructured.Unstructured{Object: map[string]interface{}{",
          "44:   \"metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "43:  return &unstructured.Unstructured{Object: map[string]any{",
          "44:   \"metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: func NewWrappedList() *WrappedList { return &WrappedList{} }",
          "61: func NewUnwrapped() *unstructured.Unstructured {",
          "64:    \"name\": nameUnwrapped,",
          "65:   },",
          "66:  }}",
          "",
          "[Removed Lines]",
          "62:  return &unstructured.Unstructured{Object: map[string]interface{}{",
          "63:   \"metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "62:  return &unstructured.Unstructured{Object: map[string]any{",
          "63:   \"metadata\": map[string]any{",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/composed/composed.go||pkg/resource/unstructured/composed/composed.go": [
          "File: pkg/resource/unstructured/composed/composed.go -> pkg/resource/unstructured/composed/composed.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: func New(opts ...Option) *Unstructured {",
          "53:  for _, f := range opts {",
          "54:   f(cr)",
          "55:  }",
          "",
          "[Removed Lines]",
          "52:  cr := &Unstructured{unstructured.Unstructured{Object: make(map[string]interface{})}}",
          "",
          "[Added Lines]",
          "52:  cr := &Unstructured{unstructured.Unstructured{Object: make(map[string]any)}}",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/composed/composed_test.go||pkg/resource/unstructured/composed/composed_test.go": [
          "File: pkg/resource/unstructured/composed/composed_test.go -> pkg/resource/unstructured/composed/composed_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:   \"New\": {",
          "41:    ref: ref,",
          "42:    want: &Unstructured{Unstructured: unstructured.Unstructured{",
          "44:      \"apiVersion\": \"a/v1\",",
          "45:      \"kind\":       \"k\",",
          "47:       \"name\":      \"name\",",
          "48:       \"namespace\": \"ns\",",
          "49:      },",
          "",
          "[Removed Lines]",
          "43:     Object: map[string]interface{}{",
          "46:      \"metadata\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "43:     Object: map[string]any{",
          "46:      \"metadata\": map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:   },",
          "88:   \"WeirdStatus\": {",
          "89:    reason: \"It should not be possible to set a condition when status is not an object.\",",
          "91:     \"status\": \"wat\",",
          "92:    }}},",
          "93:    set:  []xpv1.Condition{xpv1.Available()},",
          "",
          "[Removed Lines]",
          "90:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "90:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "96:   },",
          "97:   \"WeirdStatusConditions\": {",
          "98:    reason: \"Conditions should be overwritten if they are not an object.\",",
          "101:      \"conditions\": \"wat\",",
          "102:     },",
          "103:    }}},",
          "",
          "[Removed Lines]",
          "99:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "100:     \"status\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "99:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "100:     \"status\": map[string]any{",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/composite/composite.go||pkg/resource/unstructured/composite/composite.go": [
          "File: pkg/resource/unstructured/composite/composite.go -> pkg/resource/unstructured/composite/composite.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: func New(opts ...Option) *Unstructured {",
          "52:  for _, f := range opts {",
          "53:   f(c)",
          "54:  }",
          "",
          "[Removed Lines]",
          "51:  c := &Unstructured{unstructured.Unstructured{Object: make(map[string]interface{})}}",
          "",
          "[Added Lines]",
          "51:  c := &Unstructured{unstructured.Unstructured{Object: make(map[string]any)}}",
          "",
          "---------------"
        ],
        "pkg/resource/unstructured/composite/composite_test.go||pkg/resource/unstructured/composite/composite_test.go": [
          "File: pkg/resource/unstructured/composite/composite_test.go -> pkg/resource/unstructured/composite/composite_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   \"New\": {",
          "44:    gvk: gvk,",
          "45:    want: &Unstructured{Unstructured: unstructured.Unstructured{",
          "47:      \"apiVersion\": \"g/v1\",",
          "48:      \"kind\":       \"k\",",
          "49:     },",
          "",
          "[Removed Lines]",
          "46:     Object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "46:     Object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:   },",
          "87:   \"WeirdStatus\": {",
          "88:    reason: \"It should not be possible to set a condition when status is not an object.\",",
          "90:     \"status\": \"wat\",",
          "91:    }}},",
          "92:    set:  []xpv1.Condition{xpv1.Available()},",
          "",
          "[Removed Lines]",
          "89:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "",
          "[Added Lines]",
          "89:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "95:   },",
          "96:   \"WeirdStatusConditions\": {",
          "97:    reason: \"Conditions should be overwritten if they are not an object.\",",
          "100:      \"conditions\": \"wat\",",
          "101:     },",
          "102:    }}},",
          "",
          "[Removed Lines]",
          "98:    u: &Unstructured{unstructured.Unstructured{Object: map[string]interface{}{",
          "99:     \"status\": map[string]interface{}{",
          "",
          "[Added Lines]",
          "98:    u: &Unstructured{unstructured.Unstructured{Object: map[string]any{",
          "99:     \"status\": map[string]any{",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7560fbc0415bf69c219b96949f3b2d2839538d56",
      "candidate_info": {
        "commit_hash": "7560fbc0415bf69c219b96949f3b2d2839538d56",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/7560fbc0415bf69c219b96949f3b2d2839538d56",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "fix: enforce max index value for paths\n\nSigned-off-by: Philippe Scorsolini <p.scorsolini@gmail.com>",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  \"github.com/crossplane/crossplane-runtime/pkg/errors\"",
          "26: )",
          "28: type errNotFound struct {",
          "29:  error",
          "30: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: const DefaultMaxFieldPathIndex = 1024",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: type Paved struct {",
          "50: }",
          "55:  u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)",
          "57: }",
          "62: }",
          "",
          "[Removed Lines]",
          "49:  object map[string]any",
          "54: func PaveObject(o runtime.Object) (*Paved, error) {",
          "56:  return Pave(u), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "60: func Pave(object map[string]any) *Paved {",
          "61:  return &Paved{object: object}",
          "",
          "[Added Lines]",
          "52:  object            map[string]any",
          "53:  maxFieldPathIndex uint",
          "56: type PavedOption func(paved *Paved)",
          "60: func PaveObject(o runtime.Object, opts ...PavedOption) (*Paved, error) {",
          "62:  return Pave(u, opts...), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "66: func Pave(object map[string]any, opts ...PavedOption) *Paved {",
          "67:  p := &Paved{object: object, maxFieldPathIndex: DefaultMaxFieldPathIndex}",
          "69:  for _, opt := range opts {",
          "70:   opt(p)",
          "71:  }",
          "73:  return p",
          "74: }",
          "77: func WithMaxFieldPathIndex(max uint) PavedOption {",
          "78:  return func(paved *Paved) {",
          "79:   paved.maxFieldPathIndex = max",
          "80:  }",
          "81: }",
          "83: func (p *Paved) maxFieldPathIndexEnabled() bool {",
          "84:  return p.maxFieldPathIndex > 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "358:     return errors.Errorf(\"%s is not an array\", s[:i])",
          "359:    }",
          "361:    if final {",
          "362:     array[current.Index] = v",
          "363:     return nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "384:    if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {",
          "385:     return errors.Errorf(\"index %d is greater than max allowed index %d\", current.Index, p.maxFieldPathIndex)",
          "386:    }",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "20:  \"testing\"",
          "22:  \"github.com/google/go-cmp/cmp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  \"fmt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:  type args struct {",
          "594:   path  string",
          "595:   value any",
          "596:  }",
          "597:  type want struct {",
          "598:   object map[string]any",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:   opts  []PavedOption",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:     },",
          "738:    },",
          "739:   },",
          "740:   \"MapStringString\": {",
          "741:    reason: \"A map of string to string should be converted to a map of string to any\",",
          "742:    data:   []byte(`{\"metadata\":{}}`),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:   \"RejectsHighIndexes\": {",
          "743:    reason: \"Paths having indexes above the maximum default value are rejected\",",
          "744:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "745:    args: args{",
          "746:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "747:     value: \"c\",",
          "748:    },",
          "749:    want: want{",
          "750:     object: map[string]any{",
          "751:      \"data\": []any{\"a\"}},",
          "752:     err: errors.Wrap(errors.Errorf(\"found index above max (%[1]v > %[2]v): data[%[1]v]\",",
          "753:      MaxFieldPathIndex+1, MaxFieldPathIndex), \"invalid segments\"),",
          "754:    },",
          "755:   },",
          "756:   \"NotRejectsHighIndexesIfNoDefaultOptions\": {",
          "757:    reason: \"Paths having indexes above the maximum default value are not rejected if default disabled\",",
          "758:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "759:    args: args{",
          "760:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "761:     value: \"c\",",
          "762:     opts:  []PavedOption{},",
          "763:    },",
          "764:    want: want{",
          "765:     object: map[string]any{",
          "766:      \"data\": func() []any {",
          "767:       res := make([]any, MaxFieldPathIndex+2)",
          "768:       res[0] = \"a\"",
          "769:       res[MaxFieldPathIndex+1] = \"c\"",
          "770:       return res",
          "771:      }()},",
          "772:    },",
          "773:   },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "817:   t.Run(name, func(t *testing.T) {",
          "818:    in := make(map[string]any)",
          "819:    _ = json.Unmarshal(tc.data, &in)",
          "822:    err := p.SetValue(tc.args.path, tc.args.value)",
          "823:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
          "",
          "[Removed Lines]",
          "820:    p := Pave(in)",
          "",
          "[Added Lines]",
          "854:    p := Pave(in, tc.args.opts...)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b33c53e6d593d262068fe6016aceed53b964902a",
      "candidate_info": {
        "commit_hash": "b33c53e6d593d262068fe6016aceed53b964902a",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/b33c53e6d593d262068fe6016aceed53b964902a",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Round-trip paved values through JSON serialisation before setting them\n\nPaved objects expect their internal unstructured content to be of the types\nproduced by json.Unmarshal. This allows us to enforce that for any call to\np.SetValue(\"some.path\", T) where T is any JSON serialisable type.\n\nSigned-off-by: Nic Cope <negz@rk0n.org>",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "195: }",
          "197: func (p *Paved) setValue(s Segments, value interface{}) error {",
          "198:  var in interface{} = p.object",
          "199:  for i, current := range s {",
          "200:   final := i == len(s)-1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:  var v interface{}",
          "203:  j, err := json.Marshal(value)",
          "204:  if err != nil {",
          "205:   return errors.Wrap(err, \"cannot marshal value to JSON\")",
          "206:  }",
          "207:  if err := json.Unmarshal(j, &v); err != nil {",
          "208:   return errors.Wrap(err, \"cannot unmarshal value from JSON\")",
          "209:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:    }",
          "209:    if final {",
          "211:     return nil",
          "212:    }",
          "",
          "[Removed Lines]",
          "210:     array[current.Index] = value",
          "",
          "[Added Lines]",
          "223:     array[current.Index] = v",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "221:    }",
          "223:    if final {",
          "225:     return nil",
          "226:    }",
          "",
          "[Removed Lines]",
          "224:     object[current.Field] = value",
          "",
          "[Added Lines]",
          "237:     object[current.Field] = v",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:  \"github.com/google/go-cmp/cmp\"",
          "24:  \"github.com/pkg/errors\"",
          "26:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
          "27: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "26:  \"k8s.io/apimachinery/pkg/types\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "564:     },",
          "565:    },",
          "566:   },",
          "567:   \"NotAnArray\": {",
          "568:    reason: \"Indexing an object field should fail\",",
          "569:    data:   []byte(`{\"data\":{}}`),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "569:   \"MapStringString\": {",
          "570:    reason: \"A map of string to string should be converted to a map of string to interface{}\",",
          "571:    data:   []byte(`{\"metadata\":{}}`),",
          "572:    args: args{",
          "573:     path:  \"metadata.labels\",",
          "574:     value: map[string]string{\"cool\": \"very\"},",
          "575:    },",
          "576:    want: want{",
          "577:     object: map[string]interface{}{",
          "578:      \"metadata\": map[string]interface{}{",
          "579:       \"labels\": map[string]interface{}{\"cool\": \"very\"},",
          "580:      },",
          "581:     },",
          "582:    },",
          "583:   },",
          "584:   \"OwnerReference\": {",
          "585:    reason: \"An ObjectReference (i.e. struct) should be converted to a map of string to interface{}\",",
          "586:    data:   []byte(`{\"metadata\":{}}`),",
          "587:    args: args{",
          "588:     path: \"metadata.ownerRefs[0]\",",
          "589:     value: metav1.OwnerReference{",
          "590:      APIVersion: \"v\",",
          "591:      Kind:       \"k\",",
          "592:      Name:       \"n\",",
          "593:      UID:        types.UID(\"u\"),",
          "594:     },",
          "595:    },",
          "596:    want: want{",
          "597:     object: map[string]interface{}{",
          "598:      \"metadata\": map[string]interface{}{",
          "599:       \"ownerRefs\": []interface{}{",
          "600:        map[string]interface{}{",
          "601:         \"apiVersion\": \"v\",",
          "602:         \"kind\":       \"k\",",
          "603:         \"name\":       \"n\",",
          "604:         \"uid\":        \"u\",",
          "605:        },",
          "606:       },",
          "607:      },",
          "608:     },",
          "609:    },",
          "610:   },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12c1e9f8ecd731afc4e092967508fa226b80a461",
      "candidate_info": {
        "commit_hash": "12c1e9f8ecd731afc4e092967508fa226b80a461",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/12c1e9f8ecd731afc4e092967508fa226b80a461",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "fix: enforce max index value for paths\n\nSigned-off-by: Philippe Scorsolini <p.scorsolini@gmail.com>\n(cherry picked from commit 7560fbc0415bf69c219b96949f3b2d2839538d56)",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  \"github.com/crossplane/crossplane-runtime/pkg/errors\"",
          "26: )",
          "28: type errNotFound struct {",
          "29:  error",
          "30: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: const DefaultMaxFieldPathIndex = 1024",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: type Paved struct {",
          "50: }",
          "55:  u, err := runtime.DefaultUnstructuredConverter.ToUnstructured(o)",
          "57: }",
          "62: }",
          "",
          "[Removed Lines]",
          "49:  object map[string]any",
          "54: func PaveObject(o runtime.Object) (*Paved, error) {",
          "56:  return Pave(u), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "60: func Pave(object map[string]any) *Paved {",
          "61:  return &Paved{object: object}",
          "",
          "[Added Lines]",
          "52:  object            map[string]any",
          "53:  maxFieldPathIndex uint",
          "56: type PavedOption func(paved *Paved)",
          "60: func PaveObject(o runtime.Object, opts ...PavedOption) (*Paved, error) {",
          "62:  return Pave(u, opts...), errors.Wrap(err, \"cannot convert object to unstructured data\")",
          "66: func Pave(object map[string]any, opts ...PavedOption) *Paved {",
          "67:  p := &Paved{object: object, maxFieldPathIndex: DefaultMaxFieldPathIndex}",
          "69:  for _, opt := range opts {",
          "70:   opt(p)",
          "71:  }",
          "73:  return p",
          "74: }",
          "77: func WithMaxFieldPathIndex(max uint) PavedOption {",
          "78:  return func(paved *Paved) {",
          "79:   paved.maxFieldPathIndex = max",
          "80:  }",
          "81: }",
          "83: func (p *Paved) maxFieldPathIndexEnabled() bool {",
          "84:  return p.maxFieldPathIndex > 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "358:     return errors.Errorf(\"%s is not an array\", s[:i])",
          "359:    }",
          "361:    if final {",
          "362:     array[current.Index] = v",
          "363:     return nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "384:    if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {",
          "385:     return errors.Errorf(\"index %d is greater than max allowed index %d\", current.Index, p.maxFieldPathIndex)",
          "386:    }",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package fieldpath",
          "19: import (",
          "20:  \"testing\"",
          "22:  \"github.com/google/go-cmp/cmp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  \"fmt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:  type args struct {",
          "594:   path  string",
          "595:   value any",
          "596:  }",
          "597:  type want struct {",
          "598:   object map[string]any",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:   opts  []PavedOption",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "737:     },",
          "738:    },",
          "739:   },",
          "740:   \"MapStringString\": {",
          "741:    reason: \"A map of string to string should be converted to a map of string to any\",",
          "742:    data:   []byte(`{\"metadata\":{}}`),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:   \"RejectsHighIndexes\": {",
          "743:    reason: \"Paths having indexes above the maximum default value are rejected\",",
          "744:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "745:    args: args{",
          "746:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "747:     value: \"c\",",
          "748:    },",
          "749:    want: want{",
          "750:     object: map[string]any{",
          "751:      \"data\": []any{\"a\"}},",
          "752:     err: errors.Wrap(errors.Errorf(\"found index above max (%[1]v > %[2]v): data[%[1]v]\",",
          "753:      MaxFieldPathIndex+1, MaxFieldPathIndex), \"invalid segments\"),",
          "754:    },",
          "755:   },",
          "756:   \"NotRejectsHighIndexesIfNoDefaultOptions\": {",
          "757:    reason: \"Paths having indexes above the maximum default value are not rejected if default disabled\",",
          "758:    data:   []byte(`{\"data\":[\"a\"]}`),",
          "759:    args: args{",
          "760:     path:  fmt.Sprintf(\"data[%v]\", MaxFieldPathIndex+1),",
          "761:     value: \"c\",",
          "762:     opts:  []PavedOption{},",
          "763:    },",
          "764:    want: want{",
          "765:     object: map[string]any{",
          "766:      \"data\": func() []any {",
          "767:       res := make([]any, MaxFieldPathIndex+2)",
          "768:       res[0] = \"a\"",
          "769:       res[MaxFieldPathIndex+1] = \"c\"",
          "770:       return res",
          "771:      }()},",
          "772:    },",
          "773:   },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "817:   t.Run(name, func(t *testing.T) {",
          "818:    in := make(map[string]any)",
          "819:    _ = json.Unmarshal(tc.data, &in)",
          "822:    err := p.SetValue(tc.args.path, tc.args.value)",
          "823:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
          "",
          "[Removed Lines]",
          "820:    p := Pave(in)",
          "",
          "[Added Lines]",
          "854:    p := Pave(in, tc.args.opts...)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
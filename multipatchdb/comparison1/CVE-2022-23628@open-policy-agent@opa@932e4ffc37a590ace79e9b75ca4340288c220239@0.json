{
  "cve_id": "CVE-2022-23628",
  "cve_desc": "OPA is an open source, general-purpose policy engine. Under certain conditions, pretty-printing an abstract syntax tree (AST) that contains synthetic nodes could change the logic of some statements by reordering array literals. Example of policies impacted are those that parse and compare web paths. **All of these** three conditions have to be met to create an adverse effect: 1. An AST of Rego had to be **created programmatically** such that it ends up containing terms without a location (such as wildcard variables). 2. The AST had to be **pretty-printed** using the `github.com/open-policy-agent/opa/format` package. 3. The result of the pretty-printing had to be **parsed and evaluated again** via an OPA instance using the bundles, or the Golang packages. If any of these three conditions are not met, you are not affected. Notably, all three would be true if using **optimized bundles**, i.e. bundles created with `opa build -O=1` or higher. In that case, the optimizer would fulfil condition (1.), the result of that would be pretty-printed when writing the bundle to disk, fulfilling (2.). When the bundle was then used, we'd satisfy (3.). As a workaround users may disable optimization when creating bundles.",
  "repo": "open-policy-agent/opa",
  "patch_hash": "932e4ffc37a590ace79e9b75ca4340288c220239",
  "patch_info": {
    "commit_hash": "932e4ffc37a590ace79e9b75ca4340288c220239",
    "repo": "open-policy-agent/opa",
    "commit_url": "https://github.com/open-policy-agent/opa/commit/932e4ffc37a590ace79e9b75ca4340288c220239",
    "files": [
      "format/format.go",
      "format/format_test.go"
    ],
    "message": "format: don't group iterable when one has defaulted location (#4260)\n\nAs mentioned in the comment, empty file names happen when the format\npackage's Ast() function does a sweep of its input, and adds a\n\"default location\" to everything that has a nil location.\n\nDuring PE, when generated the pairs to save in saveUnify, we'll\nreturn Var Terms without locations. Fixing that seemed like a bigger\nhurdle, so I went this route.\n\nThe new check is such that if any term has the default file in\nits location, such as would happen if we're formatting code that\nwas created programmatically (not parsed), we'll group the terms'\nelements, but print them in one line.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
    "before_after_code_files": [
      "format/format.go||format/format.go",
      "format/format_test.go||format/format_test.go"
    ]
  },
  "patch_diff": {
    "format/format.go||format/format.go": [
      "File: format/format.go -> format/format.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "14:  \"github.com/open-policy-agent/opa/ast\"",
      "15: )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: const defaultLocationFile = \"__format_default__\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "154: }",
      "156: func defaultLocation(x ast.Node) *ast.Location {",
      "158: }",
      "160: type writer struct {",
      "",
      "[Removed Lines]",
      "157:  return ast.NewLocation([]byte(x.String()), \"\", 1, 1)",
      "",
      "[Added Lines]",
      "162:  return ast.NewLocation([]byte(x.String()), defaultLocationFile, 1, 1)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "896: func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {",
      "903:  for _, elem := range elements {",
      "908:    return [][]interface{}{elements}",
      "909:   }",
      "910:  }",
      "911:  sort.Slice(elements, func(i, j int) bool {",
      "912:   return locLess(elements[i], elements[j])",
      "913:  })",
      "914:  var lines [][]interface{}",
      "915:  var cur []interface{}",
      "916:  for i, t := range elements {",
      "",
      "[Removed Lines]",
      "902:  vis := ast.NewVarVisitor()",
      "904:   vis.Walk(elem)",
      "905:  }",
      "906:  for v := range vis.Vars() {",
      "907:   if v.IsGenerated() {",
      "",
      "[Added Lines]",
      "907:  def := false // default location found?",
      "909:   ast.WalkTerms(elem, func(t *ast.Term) bool {",
      "910:    if t.Location.File == defaultLocationFile {",
      "911:     def = true",
      "912:     return true",
      "913:    }",
      "914:    return false",
      "915:   })",
      "916:   if def { // return as-is",
      "",
      "---------------"
    ],
    "format/format_test.go||format/format_test.go": [
      "File: format/format_test.go -> format/format_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "336:    expected: `_x",
      "337: a[_x[y][[z, w]]]`,",
      "338:   },",
      "339:  }",
      "341:  for _, tc := range cases {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "339:   {",
      "340:    note: \"expr with wildcard that has a default location\",",
      "341:    toFmt: func() *ast.Expr {",
      "342:     expr := ast.MustParseExpr(`[\"foo\", _] = split(input.foo, \":\")`)",
      "343:     ast.WalkTerms(expr, func(term *ast.Term) bool {",
      "344:      v, ok := term.Value.(ast.Var)",
      "345:      if ok && v.IsWildcard() {",
      "346:       term.Location = defaultLocation(term)",
      "347:       return true",
      "348:      }",
      "349:      term.Location.File = \"foo.rego\"",
      "350:      term.Location.Row = 2",
      "351:      return false",
      "352:     })",
      "353:     return expr",
      "354:    }(),",
      "355:    expected: `[\"foo\", _] = split(input.foo, \":\")`,",
      "356:   },",
      "357:   {",
      "358:    note: \"expr all terms having empty-file locations\",",
      "359:    toFmt: ast.MustParseExpr(`[",
      "360:      \"foo\",",
      "361:      _",
      "362:      ] = split(input.foo, \":\")`),",
      "363:    expected: `",
      "364: [",
      "365:  \"foo\",",
      "366:  _,",
      "367: ] = split(input.foo, \":\")`,",
      "368:   },",
      "369:   {",
      "370:    note: \"expr where all terms having empty-file locations, and one is a default location\",",
      "371:    toFmt: func() *ast.Expr {",
      "372:     expr := ast.MustParseExpr(`",
      "373: [\"foo\", __local1__] = split(input.foo, \":\")`)",
      "374:     ast.WalkTerms(expr, func(term *ast.Term) bool {",
      "375:      if ast.VarTerm(\"__local1__\").Equal(term) {",
      "376:       term.Location = defaultLocation(term)",
      "377:       return true",
      "378:      }",
      "379:      return false",
      "380:     })",
      "381:     return expr",
      "382:    }(),",
      "383:    expected: `[\"foo\", __local1__] = split(input.foo, \":\")`,",
      "384:   },",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "347:    expected := strings.TrimSpace(tc.expected)",
      "348:    actual := strings.TrimSpace(string(bs))",
      "349:    if actual != expected {",
      "351:    }",
      "352:   })",
      "353:  }",
      "",
      "[Removed Lines]",
      "350:     t.Fatalf(\"Expected:\\n\\n%s\\n\\nGot:\\n\\n%s\\n\\n\", expected, actual)",
      "",
      "[Added Lines]",
      "396:     t.Fatalf(\"Expected:\\n\\n%q\\n\\nGot:\\n\\n%q\\n\\n\", expected, actual)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c174c2a46860d47e2e9c3c2a5a4526a1292ee2ea",
      "candidate_info": {
        "commit_hash": "c174c2a46860d47e2e9c3c2a5a4526a1292ee2ea",
        "repo": "open-policy-agent/opa",
        "commit_url": "https://github.com/open-policy-agent/opa/commit/c174c2a46860d47e2e9c3c2a5a4526a1292ee2ea",
        "files": [
          "format/format.go",
          "format/format_test.go"
        ],
        "message": "format: don't linebreak when there are generated vars in func call (#4019)\n\nFixes #4018.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
        "before_after_code_files": [
          "format/format.go||format/format.go",
          "format/format_test.go||format/format_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "format/format.go||format/format.go",
            "format/format_test.go||format/format_test.go"
          ],
          "candidate": [
            "format/format.go||format/format.go",
            "format/format_test.go||format/format_test.go"
          ]
        }
      },
      "candidate_diff": {
        "format/format.go||format/format.go": [
          "File: format/format.go -> format/format.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "855: func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {",
          "856:  sort.Slice(elements, func(i, j int) bool {",
          "857:   return locLess(elements[i], elements[j])",
          "858:  })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "861:  vis := ast.NewVarVisitor()",
          "862:  for _, elem := range elements {",
          "863:   vis.Walk(elem)",
          "864:  }",
          "865:  for v := range vis.Vars() {",
          "866:   if v.IsGenerated() {",
          "867:    return [][]interface{}{elements}",
          "868:   }",
          "869:  }",
          "",
          "---------------"
        ],
        "format/format_test.go||format/format_test.go": [
          "File: format/format_test.go -> format/format_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:  \"testing\"",
          "15:  \"github.com/open-policy-agent/opa/ast\"",
          "16: )",
          "18: func TestFormatNilLocation(t *testing.T) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16:  \"github.com/open-policy-agent/opa/ast/location\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:  }",
          "43: }",
          "45: func TestFormatSourceError(t *testing.T) {",
          "46:  rego := \"testfiles/test.rego.error\"",
          "47:  contents, err := ioutil.ReadFile(rego)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: func TestFormatNilLocationFunctionArgs(t *testing.T) {",
          "47:  b := ast.NewBody()",
          "48:  s := ast.StringTerm(\" \")",
          "49:  s.SetLocation(location.NewLocation([]byte(\"foo\"), \"p.rego\", 2, 2))",
          "50:  b.Append(ast.Split.Expr(ast.NewTerm(ast.Var(\"__local1__\")), s, ast.NewTerm(ast.Var(\"__local2__\"))))",
          "51:  exp := \"split(__local1__, \\\" \\\", __local2__)\\n\"",
          "52:  bs, err := Ast(b)",
          "53:  if err != nil {",
          "54:   t.Fatal(err)",
          "55:  }",
          "56:  if string(bs) != exp {",
          "57:   t.Fatalf(\"Expected %q but got %q\", exp, string(bs))",
          "58:  }",
          "59: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-30624",
  "cve_desc": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 6.0.2, 7.0.1, and 8.0.1, Wasmtime's implementation of managing per-instance state, such as tables and memories, contains LLVM-level undefined behavior. This undefined behavior was found to cause runtime-level issues when compiled with LLVM 16 which causes some writes, which are critical for correctness, to be optimized away. Vulnerable versions of Wasmtime compiled with Rust 1.70, which is currently in beta, or later are known to have incorrectly compiled functions. Versions of Wasmtime compiled with the current Rust stable release, 1.69, and prior are not known at this time to have any issues, but can theoretically exhibit potential issues.\n\nThe underlying problem is that Wasmtime's runtime state for an instance involves a Rust-defined structure called `Instance` which has a trailing `VMContext` structure after it. This `VMContext` structure has a runtime-defined layout that is unique per-module. This representation cannot be expressed with safe code in Rust so `unsafe` code is required to maintain this state. The code doing this, however, has methods which take `&self` as an argument but modify data in the `VMContext` part of the allocation. This means that pointers derived from `&self` are mutated. This is typically not allowed, except in the presence of `UnsafeCell`, in Rust. When compiled to LLVM these functions have `noalias readonly` parameters which means it's UB to write through the pointers.\n\nWasmtime's internal representation and management of `VMContext` has been updated to use `&mut self` methods where appropriate. Additionally verification tools for `unsafe` code in Rust, such as `cargo miri`, are planned to be executed on the `main` branch soon to fix any Rust-level issues that may be exploited in future compiler versions.\n\nPrecomplied binaries available for Wasmtime from GitHub releases have been compiled with at most LLVM 15 so are not known to be vulnerable. As mentioned above, however, it's still recommended to update.\n\nWasmtime version 6.0.2, 7.0.1, and 8.0.1 have been issued which contain the patch necessary to work correctly on LLVM 16 and have no known UB on LLVM 15 and earlier. If Wasmtime is compiled with Rust 1.69 and prior, which use LLVM 15, then there are no known issues. There is a theoretical possibility for undefined behavior to exploited, however, so it's recommended that users upgrade to a patched version of Wasmtime. Users using beta Rust (1.70 at this time) or nightly Rust (1.71 at this time) must update to a patched version to work correctly.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
  "patch_info": {
    "commit_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e",
    "files": [
      "RELEASES.md",
      "crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs"
    ],
    "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix dates and fill out more notes",
    "before_after_code_files": [
      "crates/environ/src/module.rs||crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
    ]
  },
  "patch_diff": {
    "crates/environ/src/module.rs||crates/environ/src/module.rs": [
      "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:         }",
      "242:         let mut idx = 0;",
      "243:         let ok = self.module.memory_initialization.init_memory(",
      "244:             InitMemory::CompileTime(&self.module),",
      "",
      "[Removed Lines]",
      "245:             &mut |memory, init| {",
      "",
      "[Added Lines]",
      "244:             &mut (),",
      "246:             |(), memory, init| {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "529:         &self,",
      "532:     ) -> bool {",
      "533:         let initializers = match self {",
      "",
      "[Removed Lines]",
      "528:     pub fn init_memory(",
      "530:         state: InitMemory<'_>,",
      "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "[Added Lines]",
      "529:     pub fn init_memory<T>(",
      "531:         state: &mut T,",
      "532:         init: InitMemory<'_, T>,",
      "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "543:             MemoryInitialization::Static { map } => {",
      "544:                 for (index, init) in map {",
      "545:                     if let Some(init) = init {",
      "547:                         if !result {",
      "548:                             return result;",
      "549:                         }",
      "",
      "[Removed Lines]",
      "546:                         let result = write(index, init);",
      "",
      "[Added Lines]",
      "548:                         let result = write(state, index, init);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "569:             let base = match base {",
      "571:                     InitMemory::Runtime {",
      "572:                         get_global_as_u64, ..",
      "574:                     InitMemory::CompileTime(_) => return false,",
      "575:                 },",
      "576:                 None => 0,",
      "",
      "[Removed Lines]",
      "570:                 Some(index) => match &state {",
      "573:                     } => get_global_as_u64(index),",
      "",
      "[Added Lines]",
      "572:                 Some(index) => match &init {",
      "575:                     } => get_global_as_u64(state, index),",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "585:                 None => return false,",
      "586:             };",
      "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
      "590:                 InitMemory::Runtime {",
      "591:                     memory_size_in_pages,",
      "592:                     ..",
      "594:             };",
      "",
      "[Removed Lines]",
      "588:             let cur_size_in_pages = match &state {",
      "593:                 } => memory_size_in_pages(memory_index),",
      "",
      "[Added Lines]",
      "590:             let cur_size_in_pages = match &init {",
      "595:                 } => memory_size_in_pages(state, memory_index),",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "616:                 offset: start,",
      "617:                 data: data.clone(),",
      "618:             };",
      "620:             if !result {",
      "621:                 return result;",
      "622:             }",
      "",
      "[Removed Lines]",
      "619:             let result = write(memory_index, &init);",
      "",
      "[Added Lines]",
      "621:             let result = write(state, memory_index, &init);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "631: pub enum InitMemory<'a> {",
      "",
      "[Added Lines]",
      "633: pub enum InitMemory<'a, T> {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "641:     Runtime {",
      "647:     },",
      "648: }",
      "",
      "[Removed Lines]",
      "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
      "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
      "",
      "[Added Lines]",
      "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
      "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
      "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "",
      "[Removed Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
      "151:         (self.vmctx_ptr().cast::<u8>())",
      "",
      "[Added Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
      "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
      "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:     #[allow(dead_code)]",
      "187:         unsafe { *self.table_ptr(index) }",
      "188:     }",
      "192:         unsafe {",
      "194:         }",
      "195:     }",
      "200:     }",
      "",
      "[Removed Lines]",
      "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
      "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "[Added Lines]",
      "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
      "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:     }",
      "242:         unsafe { &*self.global_ptr(index) }",
      "243:     }",
      "248:     }",
      "",
      "[Removed Lines]",
      "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "[Added Lines]",
      "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "254:     pub(crate) fn defined_or_imported_global_ptr(",
      "256:         index: GlobalIndex,",
      "257:     ) -> *mut VMGlobalDefinition {",
      "258:         if let Some(index) = self.module().defined_global_index(index) {",
      "",
      "[Removed Lines]",
      "255:         &self,",
      "",
      "[Added Lines]",
      "261:         &mut self,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "263:     }",
      "268:     }",
      "273:     }",
      "278:     }",
      "",
      "[Removed Lines]",
      "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
      "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
      "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
      "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
      "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
      "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "[Added Lines]",
      "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
      "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
      "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
      "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
      "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
      "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "402:     }",
      "406:         let index = DefinedTableIndex::new(",
      "407:             usize::try_from(",
      "408:                 (table as *const VMTableDefinition)",
      "",
      "[Removed Lines]",
      "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "[Added Lines]",
      "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "584:             let func = &self.module().functions[index];",
      "585:             let sig = func.signature;",
      "586:             let anyfunc: *mut VMCallerCheckedFuncRef = self",
      "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
      "589:                 );",
      "590:             self.construct_anyfunc(index, sig, anyfunc);",
      "",
      "[Removed Lines]",
      "587:                 .vmctx_plus_offset::<VMCallerCheckedFuncRef>(",
      "",
      "[Added Lines]",
      "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "923:     ) {",
      "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
      "927:         self.set_callee(None);",
      "928:         self.set_store(store.as_raw());",
      "931:         let signatures = self.runtime_info.signature_ids();",
      "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
      "939:         ptr::copy_nonoverlapping(",
      "940:             imports.functions.as_ptr(),",
      "942:             imports.functions.len(),",
      "943:         );",
      "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
      "945:         ptr::copy_nonoverlapping(",
      "946:             imports.tables.as_ptr(),",
      "948:             imports.tables.len(),",
      "949:         );",
      "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
      "951:         ptr::copy_nonoverlapping(",
      "952:             imports.memories.as_ptr(),",
      "954:             imports.memories.len(),",
      "955:         );",
      "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
      "957:         ptr::copy_nonoverlapping(",
      "958:             imports.globals.as_ptr(),",
      "960:             imports.globals.len(),",
      "961:         );",
      "",
      "[Removed Lines]",
      "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
      "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
      "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
      "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
      "",
      "[Added Lines]",
      "942:             &VMBuiltinFunctionsArray::INIT;",
      "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
      "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
      "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
      "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
      "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
      "973:             ptr = ptr.add(1);",
      "",
      "[Removed Lines]",
      "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
      "",
      "[Added Lines]",
      "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
      "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
      "985:             let memory_index = module.memory_index(defined_memory_index);",
      "",
      "[Removed Lines]",
      "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
      "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
      "",
      "[Added Lines]",
      "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
      "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1068: impl Drop for Instance {",
      "1069:     fn drop(&mut self) {",
      "1073:                 Some(idx) => idx,",
      "1074:                 None => continue,",
      "1075:             };",
      "",
      "[Removed Lines]",
      "1071:         for (idx, global) in self.module().globals.iter() {",
      "1072:             let idx = match self.module().defined_global_index(idx) {",
      "",
      "[Added Lines]",
      "1078:         let module = self.module().clone();",
      "1079:         for (idx, global) in module.globals.iter() {",
      "1080:             let idx = match module.defined_global_index(idx) {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1182:     }",
      "1187:     }",
      "",
      "[Removed Lines]",
      "1185:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1186:         self.instance().table_index(table)",
      "",
      "[Added Lines]",
      "1193:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1194:         self.instance_mut().table_index(table)",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
      "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "200:     fn purge_module(&self, module: CompiledModuleId);",
      "201: }",
      "204:     match init.base {",
      "205:         Some(base) => {",
      "214:             init.offset",
      "215:                 .checked_add(val)",
      "",
      "[Removed Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
      "206:             let val = unsafe {",
      "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
      "209:                 } else {",
      "211:                 }",
      "212:             };",
      "",
      "[Added Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
      "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "256:         TableInitialization::FuncTable { segments, .. }",
      "257:         | TableInitialization::Segments { segments } => {",
      "258:             for segment in segments {",
      "259:                 instance.table_init_segment(",
      "260:                     segment.table_index,",
      "261:                     &segment.elements,",
      "263:                     0,",
      "264:                     segment.elements.len() as u32,",
      "265:                 )?;",
      "",
      "[Removed Lines]",
      "262:                     get_table_init_start(segment, instance)?,",
      "",
      "[Added Lines]",
      "253:                 let start = get_table_init_start(segment, instance)?;",
      "257:                     start,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "270:     Ok(())",
      "271: }",
      "274:     match init.base {",
      "275:         Some(base) => {",
      "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
      "277:                 .memory",
      "278:                 .memory64;",
      "279:             let val = unsafe {",
      "285:                 if mem64 {",
      "287:                 } else {",
      "289:                 }",
      "290:             };",
      "",
      "[Removed Lines]",
      "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
      "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
      "281:                     instance.global(def_index)",
      "282:                 } else {",
      "283:                     &*instance.imported_global(base).from",
      "284:                 };",
      "288:                     u64::from(*global.as_u32())",
      "",
      "[Added Lines]",
      "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
      "275:                 let global = instance.defined_or_imported_global_ptr(base);",
      "279:                     u64::from(*(*global).as_u32())",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "297:     }",
      "298: }",
      "301:     for init in initializers {",
      "302:         let memory = instance.get_memory(init.memory_index);",
      "303:         let start = get_memory_init_start(init, instance)?;",
      "",
      "[Removed Lines]",
      "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
      "",
      "[Added Lines]",
      "291: fn check_memory_init_bounds(",
      "292:     instance: &mut Instance,",
      "293:     initializers: &[MemoryInitializer],",
      "294: ) -> Result<()> {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "319: }",
      "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
      "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
      "335:         } else {",
      "337:         }",
      "338:     };",
      "",
      "[Removed Lines]",
      "322:     let memory_size_in_pages =",
      "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
      "327:     let get_global_as_u64 = &|global| unsafe {",
      "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
      "329:             instance.global(def_index)",
      "330:         } else {",
      "331:             &*instance.imported_global(global).from",
      "332:         };",
      "336:             u64::from(*def.as_u32())",
      "",
      "[Added Lines]",
      "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
      "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
      "318:     };",
      "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
      "323:         let def = instance.defined_or_imported_global_ptr(global);",
      "327:             u64::from(*(*def).as_u32())",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:     let ok = module.memory_initialization.init_memory(",
      "349:         InitMemory::Runtime {",
      "350:             memory_size_in_pages,",
      "351:             get_global_as_u64,",
      "352:         },",
      "",
      "[Removed Lines]",
      "353:         &mut |memory_index, init| {",
      "",
      "[Added Lines]",
      "340:         instance,",
      "345:         |instance, memory_index, init| {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
      "384:     check_table_init_bounds(instance, module)?;",
      "387:         MemoryInitialization::Segmented(initializers) => {",
      "388:             check_memory_init_bounds(instance, initializers)?;",
      "389:         }",
      "",
      "[Removed Lines]",
      "386:     match &instance.module().memory_initialization {",
      "",
      "[Added Lines]",
      "378:     match &module.memory_initialization {",
      "",
      "---------------"
    ],
    "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
      "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
      "414:     let index = GlobalIndex::from_u32(index);",
      "416:     let global = instance.defined_or_imported_global_ptr(index);",
      "417:     match (*global).as_externref().clone() {",
      "418:         None => ptr::null_mut(),",
      "",
      "[Removed Lines]",
      "415:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "415:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "435:     };",
      "437:     let index = GlobalIndex::from_u32(index);",
      "439:     let global = instance.defined_or_imported_global_ptr(index);",
      "",
      "[Removed Lines]",
      "438:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "438:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------"
    ],
    "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
      "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "219: where",
      "220:     F: FnMut(*mut VMContext),",
      "221: {",
      "224:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
      "225:         wasmtime_setjmp(",
      "",
      "[Removed Lines]",
      "222:     let limits = (*caller).instance().runtime_limits();",
      "",
      "[Added Lines]",
      "222:     let limits = (*caller).instance_mut().runtime_limits();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e0b9663e4489bbdf48f3887274a0b179883690f4",
      "candidate_info": {
        "commit_hash": "e0b9663e4489bbdf48f3887274a0b179883690f4",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/e0b9663e4489bbdf48f3887274a0b179883690f4",
        "files": [
          "Cargo.lock",
          "crates/jit/Cargo.toml",
          "crates/jit/src/instantiate.rs",
          "crates/jit/src/lib.rs",
          "crates/runtime/Cargo.toml",
          "crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs",
          "crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/trampoline/memory.rs",
          "tests/all/limits.rs",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Remove some custom error types in Wasmtime (#5347)\n\n* Remove some custom error types in Wasmtime\n\nThese types are mostly cumbersome to work with nowadays that `anyhow` is\nused everywhere else. This commit removes `InstantiationError` and\n`SetupError` in favor of using `anyhow::Error` throughout. This can\neventually culminate in creation of specific errors for embedders to\ndowncast to but for now this should be general enough.\n\n* Fix Windows build",
        "before_after_code_files": [
          "Cargo.lock||Cargo.lock",
          "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs",
          "crates/jit/src/lib.rs||crates/jit/src/lib.rs",
          "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs",
          "tests/all/limits.rs||tests/all/limits.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "Cargo.lock||Cargo.lock": [
          "File: Cargo.lock -> Cargo.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "3643:  \"rustc-demangle\",",
          "3644:  \"serde\",",
          "3645:  \"target-lexicon\",",
          "3647:  \"wasmtime-environ\",",
          "3648:  \"wasmtime-jit-debug\",",
          "3649:  \"wasmtime-jit-icache-coherence\",",
          "",
          "[Removed Lines]",
          "3646:  \"thiserror\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3687:  \"paste\",",
          "3688:  \"rand 0.8.5\",",
          "3689:  \"rustix\",",
          "3691:  \"wasmtime-asm-macros\",",
          "3692:  \"wasmtime-environ\",",
          "3693:  \"wasmtime-fiber\",",
          "",
          "[Removed Lines]",
          "3690:  \"thiserror\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs": [
          "File: crates/jit/src/instantiate.rs -> crates/jit/src/instantiate.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: use std::ops::Range;",
          "15: use std::str;",
          "16: use std::sync::Arc;",
          "18: use wasmtime_environ::obj;",
          "19: use wasmtime_environ::{",
          "22: };",
          "23: use wasmtime_runtime::{",
          "26: };",
          "",
          "[Removed Lines]",
          "17: use thiserror::Error;",
          "20:     CompileError, DefinedFuncIndex, FuncIndex, FunctionLoc, MemoryInitialization, Module,",
          "21:     ModuleTranslation, PrimaryMap, SignatureIndex, StackMapInformation, Tunables, WasmFunctionInfo,",
          "24:     CompiledModuleId, CompiledModuleIdAllocator, GdbJitImageRegistration, InstantiationError,",
          "25:     MmapVec, VMFunctionBody, VMTrampoline,",
          "30: #[derive(Error, Debug)]",
          "31: pub enum SetupError {",
          "33:     #[error(\"Validation error: {0}\")]",
          "34:     Validate(String),",
          "37:     #[error(\"WebAssembly failed to compile\")]",
          "38:     Compile(#[from] CompileError),",
          "42:     #[error(\"Instantiation failed during setup\")]",
          "43:     Instantiate(#[from] InstantiationError),",
          "46:     #[error(\"Debug information error\")]",
          "47:     DebugInfo(#[from] anyhow::Error),",
          "48: }",
          "",
          "[Added Lines]",
          "19:     DefinedFuncIndex, FuncIndex, FunctionLoc, MemoryInitialization, Module, ModuleTranslation,",
          "20:     PrimaryMap, SignatureIndex, StackMapInformation, Tunables, WasmFunctionInfo,",
          "23:     CompiledModuleId, CompiledModuleIdAllocator, GdbJitImageRegistration, MmapVec, VMFunctionBody,",
          "24:     VMTrampoline,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "446:         if self.meta.native_debug_info_present {",
          "447:             let text = self.text();",
          "448:             let bytes = create_gdbjit_image(self.mmap().to_vec(), (text.as_ptr(), text.len()))",
          "450:             profiler.module_load(self, Some(&bytes));",
          "451:             let reg = GdbJitImageRegistration::register(bytes);",
          "452:             self.dbg_jit_registration = Some(reg);",
          "",
          "[Removed Lines]",
          "449:                 .map_err(SetupError::DebugInfo)?;",
          "",
          "[Added Lines]",
          "426:                 .context(\"failed to create jit image for gdb\")?;",
          "",
          "---------------"
        ],
        "crates/jit/src/lib.rs||crates/jit/src/lib.rs": [
          "File: crates/jit/src/lib.rs -> crates/jit/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: pub use crate::code_memory::CodeMemory;",
          "31: pub use crate::instantiate::{",
          "33: };",
          "34: pub use demangling::*;",
          "35: pub use profiling::*;",
          "",
          "[Removed Lines]",
          "32:     subslice_range, CompiledModule, CompiledModuleInfo, ObjectBuilder, SetupError, SymbolizeContext,",
          "",
          "[Added Lines]",
          "32:     subslice_range, CompiledModule, CompiledModuleInfo, ObjectBuilder, SymbolizeContext,",
          "",
          "---------------"
        ],
        "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs": [
          "File: crates/runtime/src/cow.rs -> crates/runtime/src/cow.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #![cfg_attr(not(unix), allow(unused_imports, unused_variables))]",
          "7: use crate::MmapVec;",
          "8: use anyhow::Result;",
          "9: use libc::c_void;",
          "",
          "[Removed Lines]",
          "6: use crate::InstantiationError;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "486:         initial_size_bytes: usize,",
          "487:         maybe_image: Option<&Arc<MemoryImage>>,",
          "488:         style: &MemoryStyle,",
          "490:         assert!(!self.dirty);",
          "491:         assert!(initial_size_bytes <= self.static_size);",
          "",
          "[Removed Lines]",
          "489:     ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "488:     ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "501:         if self.image.as_ref() != maybe_image {",
          "504:         }",
          "509:         if self.accessible < initial_size_bytes {",
          "512:             self.accessible = initial_size_bytes;",
          "513:         }",
          "",
          "[Removed Lines]",
          "502:             self.remove_image()",
          "503:                 .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "510:             self.set_protection(self.accessible..initial_size_bytes, true)",
          "511:                 .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "",
          "[Added Lines]",
          "501:             self.remove_image()?;",
          "508:             self.set_protection(self.accessible..initial_size_bytes, true)?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "523:         if initial_size_bytes < self.accessible {",
          "524:             match style {",
          "525:                 MemoryStyle::Static { .. } => {",
          "528:                     self.accessible = initial_size_bytes;",
          "529:                 }",
          "530:                 MemoryStyle::Dynamic { .. } => {}",
          "",
          "[Removed Lines]",
          "526:                     self.set_protection(initial_size_bytes..self.accessible, false)",
          "527:                         .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "",
          "[Added Lines]",
          "523:                     self.set_protection(initial_size_bytes..self.accessible, false)?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "543:                 );",
          "544:                 if image.len > 0 {",
          "545:                     unsafe {",
          "549:                     }",
          "550:                 }",
          "551:             }",
          "",
          "[Removed Lines]",
          "546:                         image",
          "547:                             .map_at(self.base)",
          "548:                             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "",
          "[Added Lines]",
          "542:                         image.map_at(self.base)?;",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use crate::memory::{DefaultMemoryCreator, Memory};",
          "4: use crate::table::Table;",
          "5: use crate::{CompiledModuleId, ModuleRuntimeInfo, Store};",
          "7: use std::alloc;",
          "8: use std::any::Any;",
          "9: use std::convert::TryFrom;",
          "10: use std::ptr;",
          "11: use std::sync::Arc;",
          "13: use wasmtime_environ::{",
          "14:     DefinedMemoryIndex, DefinedTableIndex, HostPtr, InitMemory, MemoryInitialization,",
          "15:     MemoryInitializer, Module, PrimaryMap, TableInitialization, TableInitializer, Trap, VMOffsets,",
          "",
          "[Removed Lines]",
          "6: use anyhow::Result;",
          "12: use thiserror::Error;",
          "",
          "[Added Lines]",
          "6: use anyhow::{anyhow, bail, Result};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:     }",
          "87: }",
          "",
          "[Removed Lines]",
          "90: #[derive(Error, Debug)]",
          "91: #[error(\"Link error: {0}\")]",
          "92: pub struct LinkError(pub String);",
          "95: #[derive(Error, Debug)]",
          "96: pub enum InstantiationError {",
          "98:     #[error(\"Insufficient resources: {0}\")]",
          "99:     Resource(anyhow::Error),",
          "102:     #[error(\"Failed to link module\")]",
          "103:     Link(#[from] LinkError),",
          "106:     #[error(\"Trap occurred during instantiation\")]",
          "107:     Trap(Trap),",
          "110:     #[error(\"Limit of {0} concurrent instances has been reached\")]",
          "111:     Limit(u32),",
          "112: }",
          "115: #[cfg(feature = \"async\")]",
          "116: #[derive(Error, Debug)]",
          "117: pub enum FiberStackError {",
          "119:     #[error(\"Insufficient resources: {0}\")]",
          "120:     Resource(anyhow::Error),",
          "122:     #[error(\"fiber stacks are not supported by the allocator\")]",
          "123:     NotSupported,",
          "125:     #[error(\"Limit of {0} concurrent fibers has been reached\")]",
          "126:     Limit(u32),",
          "127: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "154:     unsafe fn allocate(",
          "155:         &self,",
          "156:         req: InstanceAllocationRequest,",
          "157:     ) -> Result<InstanceHandle, InstantiationError>;",
          "",
          "[Added Lines]",
          "113:     unsafe fn allocate(&self, req: InstanceAllocationRequest) -> Result<InstanceHandle>;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "166:         handle: &mut InstanceHandle,",
          "167:         module: &Module,",
          "168:         is_bulk_memory: bool,",
          "",
          "[Removed Lines]",
          "169:     ) -> Result<(), InstantiationError>;",
          "",
          "[Added Lines]",
          "125:     ) -> Result<()>;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "182:     #[cfg(feature = \"async\")]",
          "",
          "[Removed Lines]",
          "183:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError>;",
          "",
          "[Added Lines]",
          "139:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack>;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "198:     fn purge_module(&self, module: CompiledModuleId);",
          "199: }",
          "205:     match init.base {",
          "206:         Some(base) => {",
          "207:             let val = unsafe {",
          "",
          "[Removed Lines]",
          "201: fn get_table_init_start(",
          "202:     init: &TableInitializer,",
          "203:     instance: &Instance,",
          "204: ) -> Result<u32, InstantiationError> {",
          "",
          "[Added Lines]",
          "157: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "212:                 }",
          "213:             };",
          "220:         }",
          "221:         None => Ok(init.offset),",
          "222:     }",
          "223: }",
          "229:     match &module.table_initialization {",
          "230:         TableInitialization::FuncTable { segments, .. }",
          "231:         | TableInitialization::Segments { segments } => {",
          "",
          "[Removed Lines]",
          "215:             init.offset.checked_add(val).ok_or_else(|| {",
          "216:                 InstantiationError::Link(LinkError(",
          "217:                     \"element segment global base overflows\".to_owned(),",
          "218:                 ))",
          "219:             })",
          "225: fn check_table_init_bounds(",
          "226:     instance: &mut Instance,",
          "227:     module: &Module,",
          "228: ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "168:             init.offset",
          "169:                 .checked_add(val)",
          "170:                 .ok_or_else(|| anyhow!(\"element segment global base overflows\"))",
          "176: fn check_table_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "241:                     }",
          "242:                     _ => {",
          "246:                     }",
          "247:                 }",
          "248:             }",
          "",
          "[Removed Lines]",
          "243:                         return Err(InstantiationError::Link(LinkError(",
          "244:                             \"table out of bounds: elements segment does not fit\".to_owned(),",
          "245:                         )))",
          "",
          "[Added Lines]",
          "191:                         bail!(\"table out of bounds: elements segment does not fit\")",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "252:     Ok(())",
          "253: }",
          "",
          "[Removed Lines]",
          "255: fn initialize_tables(instance: &mut Instance, module: &Module) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "201: fn initialize_tables(instance: &mut Instance, module: &Module) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "264:         TableInitialization::FuncTable { segments, .. }",
          "265:         | TableInitialization::Segments { segments } => {",
          "266:             for segment in segments {",
          "276:             }",
          "277:         }",
          "278:     }",
          "",
          "[Removed Lines]",
          "267:                 instance",
          "268:                     .table_init_segment(",
          "269:                         segment.table_index,",
          "270:                         &segment.elements,",
          "271:                         get_table_init_start(segment, instance)?,",
          "272:                         0,",
          "273:                         segment.elements.len() as u32,",
          "274:                     )",
          "275:                     .map_err(InstantiationError::Trap)?;",
          "",
          "[Added Lines]",
          "213:                 instance.table_init_segment(",
          "214:                     segment.table_index,",
          "215:                     &segment.elements,",
          "216:                     get_table_init_start(segment, instance)?,",
          "217:                     0,",
          "218:                     segment.elements.len() as u32,",
          "219:                 )?;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "280:     Ok(())",
          "281: }",
          "287:     match init.base {",
          "288:         Some(base) => {",
          "289:             let mem64 = instance.module().memory_plans[init.memory_index]",
          "",
          "[Removed Lines]",
          "283: fn get_memory_init_start(",
          "284:     init: &MemoryInitializer,",
          "285:     instance: &Instance,",
          "286: ) -> Result<u64, InstantiationError> {",
          "",
          "[Added Lines]",
          "227: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "302:                 }",
          "303:             };",
          "308:         }",
          "309:         None => Ok(init.offset),",
          "310:     }",
          "311: }",
          "317:     for init in initializers {",
          "318:         let memory = instance.get_memory(init.memory_index);",
          "319:         let start = get_memory_init_start(init, instance)?;",
          "",
          "[Removed Lines]",
          "305:             init.offset.checked_add(val).ok_or_else(|| {",
          "306:                 InstantiationError::Link(LinkError(\"data segment global base overflows\".to_owned()))",
          "307:             })",
          "313: fn check_memory_init_bounds(",
          "314:     instance: &Instance,",
          "315:     initializers: &[MemoryInitializer],",
          "316: ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "246:             init.offset",
          "247:                 .checked_add(val)",
          "248:                 .ok_or_else(|| anyhow!(\"data segment global base overflows\"))",
          "254: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "327:             }",
          "328:             _ => {",
          "332:             }",
          "333:         }",
          "334:     }",
          "",
          "[Removed Lines]",
          "329:                 return Err(InstantiationError::Link(LinkError(",
          "330:                     \"memory out of bounds: data segment does not fit\".into(),",
          "331:                 )))",
          "",
          "[Added Lines]",
          "267:                 bail!(\"memory out of bounds: data segment does not fit\")",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "336:     Ok(())",
          "337: }",
          "340:     let memory_size_in_pages =",
          "341:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
          "",
          "[Removed Lines]",
          "339: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "275: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "392:         },",
          "393:     );",
          "394:     if !ok {",
          "396:     }",
          "398:     Ok(())",
          "399: }",
          "402:     check_table_init_bounds(instance, module)?;",
          "404:     match &instance.module().memory_initialization {",
          "",
          "[Removed Lines]",
          "395:         return Err(InstantiationError::Trap(Trap::MemoryOutOfBounds));",
          "401: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "331:         return Err(Trap::MemoryOutOfBounds.into());",
          "337: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "416:     instance: &mut Instance,",
          "417:     module: &Module,",
          "418:     is_bulk_memory: bool,",
          "",
          "[Removed Lines]",
          "419: ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "355: ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "456:     fn create_tables(",
          "457:         store: &mut StorePtr,",
          "458:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "460:         let module = runtime_info.module();",
          "461:         let num_imports = module.num_imported_tables;",
          "462:         let mut tables: PrimaryMap<DefinedTableIndex, _> =",
          "463:             PrimaryMap::with_capacity(module.table_plans.len() - num_imports);",
          "464:         for (_, table) in module.table_plans.iter().skip(num_imports) {",
          "473:         }",
          "474:         Ok(tables)",
          "475:     }",
          "",
          "[Removed Lines]",
          "459:     ) -> Result<PrimaryMap<DefinedTableIndex, Table>, InstantiationError> {",
          "465:             tables.push(",
          "466:                 Table::new_dynamic(table, unsafe {",
          "467:                     store",
          "468:                         .get()",
          "469:                         .expect(\"if module has table plans, store is not empty\")",
          "470:                 })",
          "471:                 .map_err(InstantiationError::Resource)?,",
          "472:             );",
          "",
          "[Added Lines]",
          "395:     ) -> Result<PrimaryMap<DefinedTableIndex, Table>> {",
          "401:             tables.push(Table::new_dynamic(table, unsafe {",
          "402:                 store",
          "403:                     .get()",
          "404:                     .expect(\"if module has table plans, store is not empty\")",
          "405:             })?);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "478:         &self,",
          "479:         store: &mut StorePtr,",
          "480:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "482:         let module = runtime_info.module();",
          "483:         let creator = self",
          "484:             .mem_creator",
          "",
          "[Removed Lines]",
          "481:     ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>, InstantiationError> {",
          "",
          "[Added Lines]",
          "414:     ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>> {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "491:             let defined_memory_idx = module",
          "492:                 .defined_memory_index(memory_idx)",
          "493:                 .expect(\"Skipped imports, should never be None\");",
          "511:         }",
          "512:         Ok(memories)",
          "513:     }",
          "",
          "[Removed Lines]",
          "494:             let image = runtime_info",
          "495:                 .memory_image(defined_memory_idx)",
          "496:                 .map_err(|err| InstantiationError::Resource(err.into()))?;",
          "498:             memories.push(",
          "499:                 Memory::new_dynamic(",
          "500:                     plan,",
          "501:                     creator,",
          "502:                     unsafe {",
          "503:                         store",
          "504:                             .get()",
          "505:                             .expect(\"if module has memory plans, store is not empty\")",
          "506:                     },",
          "507:                     image,",
          "508:                 )",
          "509:                 .map_err(InstantiationError::Resource)?,",
          "510:             );",
          "",
          "[Added Lines]",
          "427:             let image = runtime_info.memory_image(defined_memory_idx)?;",
          "429:             memories.push(Memory::new_dynamic(",
          "430:                 plan,",
          "431:                 creator,",
          "432:                 unsafe {",
          "433:                     store",
          "434:                         .get()",
          "435:                         .expect(\"if module has memory plans, store is not empty\")",
          "436:                 },",
          "437:                 image,",
          "438:             )?);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "532: pub unsafe fn allocate_single_memory_instance(",
          "533:     req: InstanceAllocationRequest,",
          "534:     memory: Memory,",
          "536:     let mut memories = PrimaryMap::default();",
          "537:     memories.push(memory);",
          "538:     let tables = PrimaryMap::default();",
          "",
          "[Removed Lines]",
          "535: ) -> Result<InstanceHandle, InstantiationError> {",
          "",
          "[Added Lines]",
          "463: ) -> Result<InstanceHandle> {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "554: }",
          "556: unsafe impl InstanceAllocator for OnDemandInstanceAllocator {",
          "561:         let memories = self.create_memories(&mut req.store, &req.runtime_info)?;",
          "562:         let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;",
          "563:         let module = req.runtime_info.module();",
          "",
          "[Removed Lines]",
          "557:     unsafe fn allocate(",
          "558:         &self,",
          "559:         mut req: InstanceAllocationRequest,",
          "560:     ) -> Result<InstanceHandle, InstantiationError> {",
          "",
          "[Added Lines]",
          "485:     unsafe fn allocate(&self, mut req: InstanceAllocationRequest) -> Result<InstanceHandle> {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "577:         handle: &mut InstanceHandle,",
          "578:         module: &Module,",
          "579:         is_bulk_memory: bool,",
          "581:         initialize_instance(handle.instance_mut(), module, is_bulk_memory)",
          "582:     }",
          "",
          "[Removed Lines]",
          "580:     ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "505:     ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "586:     }",
          "588:     #[cfg(feature = \"async\")]",
          "590:         if self.stack_size == 0 {",
          "592:         }",
          "596:     }",
          "598:     #[cfg(feature = \"async\")]",
          "",
          "[Removed Lines]",
          "589:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {",
          "591:             return Err(FiberStackError::NotSupported);",
          "594:         wasmtime_fiber::FiberStack::new(self.stack_size)",
          "595:             .map_err(|e| FiberStackError::Resource(e.into()))",
          "",
          "[Added Lines]",
          "514:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack> {",
          "516:             bail!(\"fiber stacks are not supported by the allocator\")",
          "519:         let stack = wasmtime_fiber::FiberStack::new(self.stack_size)?;",
          "520:         Ok(stack)",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: use crate::{instance::Instance, Memory, Mmap, Table};",
          "15: use crate::{CompiledModuleId, MemoryImageSlot, ModuleRuntimeInfo, Store};",
          "16: use anyhow::{anyhow, bail, Context, Result};",
          "",
          "[Removed Lines]",
          "10: use super::{",
          "11:     initialize_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,",
          "12:     InstantiationError,",
          "13: };",
          "",
          "[Added Lines]",
          "10: use super::{initialize_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41: #[cfg(all(feature = \"async\", unix))]",
          "42: use imp::{commit_stack_pages, reset_stack_pages_to_zero};",
          "47: fn round_up_to_pow2(n: usize, to: usize) -> usize {",
          "48:     debug_assert!(to > 0);",
          "49:     debug_assert!(to.is_power_of_two());",
          "",
          "[Removed Lines]",
          "44: #[cfg(feature = \"async\")]",
          "45: use super::FiberStackError;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "167:         &self,",
          "168:         instance_index: usize,",
          "169:         req: InstanceAllocationRequest,",
          "171:         let module = req.runtime_info.module();",
          "",
          "[Removed Lines]",
          "170:     ) -> Result<InstanceHandle, InstantiationError> {",
          "",
          "[Added Lines]",
          "164:     ) -> Result<InstanceHandle> {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "182:         let mut memories =",
          "183:             PrimaryMap::with_capacity(module.memory_plans.len() - module.num_imported_memories);",
          "",
          "[Removed Lines]",
          "178:         let offsets = self",
          "179:             .validate_instance_size(module)",
          "180:             .map_err(InstantiationError::Resource)?;",
          "",
          "[Added Lines]",
          "172:         let offsets = self.validate_instance_size(module)?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "214:         })",
          "215:     }",
          "221:         let id = self",
          "222:             .index_allocator",
          "223:             .alloc(req.runtime_info.unique_id())",
          "226:         match unsafe { self.initialize_instance(id.index(), req) } {",
          "227:             Ok(handle) => Ok(handle),",
          "",
          "[Removed Lines]",
          "217:     fn allocate(",
          "218:         &self,",
          "219:         req: InstanceAllocationRequest,",
          "220:     ) -> Result<InstanceHandle, InstantiationError> {",
          "224:             .ok_or_else(|| InstantiationError::Limit(self.max_instances as u32))?;",
          "",
          "[Added Lines]",
          "209:     fn allocate(&self, req: InstanceAllocationRequest) -> Result<InstanceHandle> {",
          "213:             .ok_or_else(|| {",
          "214:                 anyhow!(",
          "215:                     \"maximum concurrent instance limit of {} reached\",",
          "216:                     self.max_instances",
          "217:                 )",
          "218:             })?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "271:         store: Option<*mut dyn Store>,",
          "272:         memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,",
          "273:         tables: &mut PrimaryMap<DefinedTableIndex, Table>,",
          "275:         self.allocate_memories(instance_index, runtime_info, store, memories)?;",
          "276:         self.allocate_tables(instance_index, runtime_info, store, tables)?;",
          "",
          "[Removed Lines]",
          "274:     ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "268:     ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "284:         runtime_info: &dyn ModuleRuntimeInfo,",
          "285:         store: Option<*mut dyn Store>,",
          "286:         memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,",
          "288:         let module = runtime_info.module();",
          "293:         for (memory_index, plan) in module",
          "294:             .memory_plans",
          "",
          "[Removed Lines]",
          "287:     ) -> Result<(), InstantiationError> {",
          "290:         self.validate_memory_plans(module)",
          "291:             .map_err(InstantiationError::Resource)?;",
          "",
          "[Added Lines]",
          "281:     ) -> Result<()> {",
          "284:         self.validate_memory_plans(module)?;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "321:             let mut slot = self",
          "322:                 .memories",
          "323:                 .take_memory_image_slot(instance_index, defined_index);",
          "327:             let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "324:             let image = runtime_info",
          "325:                 .memory_image(defined_index)",
          "326:                 .map_err(|err| InstantiationError::Resource(err.into()))?;",
          "",
          "[Added Lines]",
          "317:             let image = runtime_info.memory_image(defined_index)?;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "349:         }",
          "351:         Ok(())",
          "",
          "[Removed Lines]",
          "342:             slot.instantiate(initial_size as usize, image, &plan.style)",
          "343:                 .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "345:             memories.push(",
          "346:                 Memory::new_static(plan, memory, slot, unsafe { &mut *store.unwrap() })",
          "347:                     .map_err(InstantiationError::Resource)?,",
          "348:             );",
          "",
          "[Added Lines]",
          "333:             slot.instantiate(initial_size as usize, image, &plan.style)?;",
          "335:             memories.push(Memory::new_static(plan, memory, slot, unsafe {",
          "336:                 &mut *store.unwrap()",
          "337:             })?);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "380:         runtime_info: &dyn ModuleRuntimeInfo,",
          "381:         store: Option<*mut dyn Store>,",
          "382:         tables: &mut PrimaryMap<DefinedTableIndex, Table>,",
          "384:         let module = runtime_info.module();",
          "389:         let mut bases = self.tables.get(instance_index);",
          "390:         for (_, plan) in module.table_plans.iter().skip(module.num_imported_tables) {",
          "",
          "[Removed Lines]",
          "383:     ) -> Result<(), InstantiationError> {",
          "386:         self.validate_table_plans(module)",
          "387:             .map_err(InstantiationError::Resource)?;",
          "",
          "[Added Lines]",
          "372:     ) -> Result<()> {",
          "375:         self.validate_table_plans(module)?;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "393:             commit_table_pages(",
          "394:                 base as *mut u8,",
          "395:                 self.tables.max_elements as usize * mem::size_of::<*mut u8>(),",
          "409:         }",
          "411:         Ok(())",
          "",
          "[Removed Lines]",
          "396:             )",
          "397:             .map_err(InstantiationError::Resource)?;",
          "399:             tables.push(",
          "400:                 Table::new_static(",
          "401:                     plan,",
          "402:                     unsafe {",
          "403:                         std::slice::from_raw_parts_mut(base, self.tables.max_elements as usize)",
          "404:                     },",
          "405:                     unsafe { &mut *store.unwrap() },",
          "406:                 )",
          "407:                 .map_err(InstantiationError::Resource)?,",
          "408:             );",
          "",
          "[Added Lines]",
          "384:             )?;",
          "386:             tables.push(Table::new_static(",
          "387:                 plan,",
          "388:                 unsafe { std::slice::from_raw_parts_mut(base, self.tables.max_elements as usize) },",
          "389:                 unsafe { &mut *store.unwrap() },",
          "390:             )?);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "930:         })",
          "931:     }",
          "934:         if self.stack_size == 0 {",
          "936:         }",
          "938:         let index = self",
          "939:             .index_allocator",
          "940:             .alloc(None)",
          "942:             .index();",
          "944:         assert!(index < self.max_instances);",
          "",
          "[Removed Lines]",
          "933:     fn allocate(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {",
          "935:             return Err(FiberStackError::NotSupported);",
          "941:             .ok_or(FiberStackError::Limit(self.max_instances as u32))?",
          "",
          "[Added Lines]",
          "915:     fn allocate(&self) -> Result<wasmtime_fiber::FiberStack> {",
          "917:             bail!(\"pooling allocator not configured to enable fiber stack allocation\");",
          "923:             .ok_or_else(|| {",
          "924:                 anyhow!(",
          "925:                     \"maximum concurrent fiber limit of {} reached\",",
          "926:                     self.max_instances",
          "927:                 )",
          "928:             })?",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "952:                 .as_mut_ptr()",
          "953:                 .add((index * self.stack_size) + self.page_size);",
          "960:         }",
          "961:     }",
          "",
          "[Removed Lines]",
          "955:             commit_stack_pages(bottom_of_stack, size_without_guard)",
          "956:                 .map_err(FiberStackError::Resource)?;",
          "958:             wasmtime_fiber::FiberStack::from_top_ptr(bottom_of_stack.add(size_without_guard))",
          "959:                 .map_err(|e| FiberStackError::Resource(e.into()))",
          "",
          "[Added Lines]",
          "942:             commit_stack_pages(bottom_of_stack, size_without_guard)?;",
          "944:             let stack =",
          "945:                 wasmtime_fiber::FiberStack::from_top_ptr(bottom_of_stack.add(size_without_guard))?;",
          "946:             Ok(stack)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1106:         Ok(())",
          "1107:     }",
          "1113:         self.instances.allocate(req)",
          "1114:     }",
          "",
          "[Removed Lines]",
          "1109:     unsafe fn allocate(",
          "1110:         &self,",
          "1111:         req: InstanceAllocationRequest,",
          "1112:     ) -> Result<InstanceHandle, InstantiationError> {",
          "",
          "[Added Lines]",
          "1096:     unsafe fn allocate(&self, req: InstanceAllocationRequest) -> Result<InstanceHandle> {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1118:         handle: &mut InstanceHandle,",
          "1119:         module: &Module,",
          "1120:         is_bulk_memory: bool,",
          "1122:         let instance = handle.instance_mut();",
          "1123:         initialize_instance(instance, module, is_bulk_memory)",
          "1124:     }",
          "",
          "[Removed Lines]",
          "1121:     ) -> Result<(), InstantiationError> {",
          "",
          "[Added Lines]",
          "1105:     ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1128:     }",
          "1130:     #[cfg(all(feature = \"async\", unix))]",
          "1132:         self.stacks.allocate()",
          "1133:     }",
          "",
          "[Removed Lines]",
          "1131:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {",
          "",
          "[Added Lines]",
          "1115:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack> {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1138:     }",
          "1140:     #[cfg(all(feature = \"async\", windows))]",
          "1142:         if self.stack_size == 0 {",
          "1144:         }",
          "1149:     }",
          "1151:     #[cfg(all(feature = \"async\", windows))]",
          "",
          "[Removed Lines]",
          "1141:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {",
          "1143:             return Err(FiberStackError::NotSupported);",
          "1147:         wasmtime_fiber::FiberStack::new(self.stack_size)",
          "1148:             .map_err(|e| FiberStackError::Resource(e.into()))",
          "",
          "[Added Lines]",
          "1125:     fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack> {",
          "1127:             bail!(\"fiber stack allocation not supported\")",
          "1131:         let stack = wasmtime_fiber::FiberStack::new(self.stack_size)?;",
          "1132:         Ok(stack)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1269:             host_state: Box::new(()),",
          "1270:             store: StorePtr::empty(),",
          "1271:         }) {",
          "1273:             _ => panic!(\"unexpected error\"),",
          "1274:         };",
          "",
          "[Removed Lines]",
          "1272:             Err(InstantiationError::Limit(3)) => {}",
          "",
          "[Added Lines]",
          "1256:             Err(_) => {}",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1415:         assert_eq!(pool.index_allocator.testing_freelist(), []);",
          "1422:         for stack in stacks {",
          "1423:             pool.deallocate(&stack);",
          "",
          "[Removed Lines]",
          "1417:         match pool.allocate().unwrap_err() {",
          "1418:             FiberStackError::Limit(10) => {}",
          "1419:             _ => panic!(\"unexpected error\"),",
          "1420:         };",
          "",
          "[Added Lines]",
          "1401:         pool.allocate().unwrap_err();",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: pub use crate::imports::Imports;",
          "56: pub use crate::instance::{",
          "57:     allocate_single_memory_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,",
          "59: };",
          "60: #[cfg(feature = \"pooling-allocator\")]",
          "61: pub use crate::instance::{",
          "",
          "[Removed Lines]",
          "58:     InstantiationError, LinkError, OnDemandInstanceAllocator, StorePtr,",
          "",
          "[Added Lines]",
          "58:     OnDemandInstanceAllocator, StorePtr,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs": [
          "File: crates/wasmtime/src/instance.rs -> crates/wasmtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:     AsContextMut, Engine, Export, Extern, Func, Global, Memory, Module, SharedMemory,",
          "6:     StoreContextMut, Table, TypedFunc,",
          "7: };",
          "9: use std::mem;",
          "10: use std::sync::Arc;",
          "11: use wasmtime_environ::{EntityType, FuncIndex, GlobalIndex, MemoryIndex, PrimaryMap, TableIndex};",
          "12: use wasmtime_runtime::{",
          "15: };",
          "",
          "[Removed Lines]",
          "8: use anyhow::{anyhow, bail, Context, Error, Result};",
          "13:     Imports, InstanceAllocationRequest, InstantiationError, StorePtr, VMContext, VMFunctionBody,",
          "14:     VMFunctionImport, VMGlobalImport, VMMemoryImport, VMOpaqueContext, VMTableImport,",
          "",
          "[Added Lines]",
          "8: use anyhow::{anyhow, bail, Context, Result};",
          "13:     Imports, InstanceAllocationRequest, StorePtr, VMContext, VMFunctionBody, VMFunctionImport,",
          "14:     VMGlobalImport, VMMemoryImport, VMOpaqueContext, VMTableImport,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "335:         Ok((instance, compiled_module.module().start_func))",
          "336:     }",
          "",
          "[Removed Lines]",
          "320:         store",
          "321:             .engine()",
          "322:             .allocator()",
          "323:             .initialize(",
          "324:                 &mut instance_handle,",
          "325:                 compiled_module.module(),",
          "326:                 store.engine().config().features.bulk_memory,",
          "327:             )",
          "328:             .map_err(|e| -> Error {",
          "329:                 match e {",
          "330:                     InstantiationError::Trap(trap) => trap.into(),",
          "331:                     other => other.into(),",
          "332:                 }",
          "333:             })?;",
          "",
          "[Added Lines]",
          "320:         store.engine().allocator().initialize(",
          "321:             &mut instance_handle,",
          "322:             compiled_module.module(),",
          "323:             store.engine().config().features.bulk_memory,",
          "324:         )?;",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs": [
          "File: crates/wasmtime/src/trampoline/memory.rs -> crates/wasmtime/src/trampoline/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: use wasmtime_environ::{EntityIndex, MemoryPlan, MemoryStyle, Module, WASM_PAGE_SIZE};",
          "9: use wasmtime_runtime::{",
          "10:     allocate_single_memory_instance, DefaultMemoryCreator, Imports, InstanceAllocationRequest,",
          "13: };",
          "",
          "[Removed Lines]",
          "11:     InstantiationError, Memory, MemoryImage, RuntimeLinearMemory, RuntimeMemoryCreator,",
          "12:     SharedMemory, StorePtr, VMMemoryDefinition,",
          "",
          "[Added Lines]",
          "11:     Memory, MemoryImage, RuntimeLinearMemory, RuntimeMemoryCreator, SharedMemory, StorePtr,",
          "12:     VMMemoryDefinition,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:                     .as_mut()",
          "49:                     .expect(\"the store pointer cannot be null here\")",
          "50:             };",
          "53:         }",
          "54:     };",
          "",
          "[Removed Lines]",
          "51:             Memory::new_dynamic(&plan, creator, store, None)",
          "52:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "",
          "[Added Lines]",
          "51:             Memory::new_dynamic(&plan, creator, store, None)?",
          "",
          "---------------"
        ],
        "tests/all/limits.rs||tests/all/limits.rs": [
          "File: tests/all/limits.rs -> tests/all/limits.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "253:         Ok(_) => unreachable!(),",
          "254:         Err(e) => assert_eq!(",
          "255:             e.to_string(),",
          "257:         ),",
          "258:     }",
          "",
          "[Removed Lines]",
          "256:             \"Insufficient resources: memory minimum size of 11 pages exceeds memory limits\"",
          "",
          "[Added Lines]",
          "256:             \"memory minimum size of 11 pages exceeds memory limits\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "261:         Ok(_) => unreachable!(),",
          "262:         Err(e) => assert_eq!(",
          "263:             e.to_string(),",
          "265:         ),",
          "266:     }",
          "",
          "[Removed Lines]",
          "264:             \"Insufficient resources: memory minimum size of 25 pages exceeds memory limits\"",
          "",
          "[Added Lines]",
          "264:             \"memory minimum size of 25 pages exceeds memory limits\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "329:         Ok(_) => unreachable!(),",
          "330:         Err(e) => assert_eq!(",
          "331:             e.to_string(),",
          "333:         ),",
          "334:     }",
          "",
          "[Removed Lines]",
          "332:             \"Insufficient resources: table minimum size of 23 elements exceeds table limits\"",
          "",
          "[Added Lines]",
          "332:             \"table minimum size of 23 elements exceeds table limits\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:         Ok(_) => unreachable!(),",
          "342:         Err(e) => assert_eq!(",
          "343:             e.to_string(),",
          "345:         ),",
          "346:     }",
          "",
          "[Removed Lines]",
          "344:             \"Insufficient resources: table minimum size of 99 elements exceeds table limits\"",
          "",
          "[Added Lines]",
          "344:             \"table minimum size of 99 elements exceeds table limits\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "374:         Ok(_) => unreachable!(),",
          "375:         Err(e) => assert_eq!(",
          "376:             e.to_string(),",
          "378:         ),",
          "379:     }",
          "",
          "[Removed Lines]",
          "377:             \"Insufficient resources: memory minimum size of 5 pages exceeds memory limits\"",
          "",
          "[Added Lines]",
          "377:             \"memory minimum size of 5 pages exceeds memory limits\"",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "428:             Err(e) => assert_eq!(",
          "429:                 e.to_string(),",
          "430:                 format!(",
          "432:                     INSTANCE_LIMIT",
          "433:                 )",
          "434:             ),",
          "",
          "[Removed Lines]",
          "431:                     \"Limit of {} concurrent instances has been reached\",",
          "",
          "[Added Lines]",
          "431:                     \"maximum concurrent instance limit of {} reached\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dd0364d367c579abc8f572d2a056aca6cd286887",
      "candidate_info": {
        "commit_hash": "dd0364d367c579abc8f572d2a056aca6cd286887",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/dd0364d367c579abc8f572d2a056aca6cd286887",
        "files": [
          ".github/workflows/main.yml",
          "crates/c-api/Cargo.toml",
          "crates/cli-flags/Cargo.toml",
          "crates/cranelift/Cargo.toml",
          "crates/cranelift/src/func_environ.rs",
          "crates/environ/Cargo.toml",
          "crates/environ/src/builtin.rs",
          "crates/fuzzing/Cargo.toml",
          "crates/runtime/Cargo.toml",
          "crates/runtime/src/externref.rs",
          "crates/runtime/src/externref/gc.rs",
          "crates/runtime/src/externref/no_gc.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/table.rs",
          "crates/runtime/src/vmcontext.rs",
          "crates/wasmtime/Cargo.toml",
          "crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/engine/serialization.rs",
          "crates/wasmtime/src/runtime.rs",
          "crates/wasmtime/src/runtime/externals/global.rs",
          "crates/wasmtime/src/runtime/externals/table.rs",
          "crates/wasmtime/src/runtime/func.rs",
          "crates/wasmtime/src/runtime/func/typed.rs",
          "crates/wasmtime/src/runtime/module/registry.rs",
          "crates/wasmtime/src/runtime/ref.rs",
          "crates/wasmtime/src/runtime/ref/gc_ref.rs",
          "crates/wasmtime/src/runtime/ref/no_gc_ref.rs",
          "crates/wasmtime/src/runtime/store.rs",
          "crates/wasmtime/src/runtime/trampoline/global.rs",
          "crates/wasmtime/src/runtime/uninhabited.rs",
          "crates/wasmtime/src/runtime/values.rs",
          "crates/wast/Cargo.toml",
          "winch/codegen/src/codegen/builtin.rs",
          "winch/filetests/filetests/x64/table/fill.wat"
        ],
        "message": "Wasmtime: Add a `gc` cargo feature (#7975)\n\n* Wasmtime: Add a `gc` cargo feature\n\nThis controls whether support for `ExternRef` and its associated deferred,\nreference-counting garbage collector is enabled at compile time or not. It will\nalso be used for similarly for Wasmtime's full Wasm GC support as that gets\nadded.\n\n* Add CI for `gc` Cargo feature\n\n* Cut down on the number of `#[cfg(feature = \"gc\")]`s outside the implementation of `[VM]ExternRef`\n\n* Fix wasmparser reference types configuration with GC disabled/enabled\n\n* More config fix\n\n* doc cfg\n\n* Make the dummy `VMExternRefActivationsTable` inhabited\n\n* Fix winch tests\n\n* final review bits\n\n* Enable wasmtime's gc cargo feature for the C API\n\n* Enable wasmtime's gc cargo feature from wasmtime-cli-flags\n\n* enable gc cargo feature in a couple other crates",
        "before_after_code_files": [
          "crates/cranelift/src/func_environ.rs||crates/cranelift/src/func_environ.rs",
          "crates/environ/src/builtin.rs||crates/environ/src/builtin.rs",
          "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs",
          "crates/runtime/src/externref/gc.rs||crates/runtime/src/externref/gc.rs",
          "crates/runtime/src/externref/no_gc.rs||crates/runtime/src/externref/no_gc.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/table.rs||crates/runtime/src/table.rs",
          "crates/runtime/src/vmcontext.rs||crates/runtime/src/vmcontext.rs",
          "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/engine/serialization.rs||crates/wasmtime/src/engine/serialization.rs",
          "crates/wasmtime/src/runtime.rs||crates/wasmtime/src/runtime.rs",
          "crates/wasmtime/src/runtime/externals/global.rs||crates/wasmtime/src/runtime/externals/global.rs",
          "crates/wasmtime/src/runtime/externals/table.rs||crates/wasmtime/src/runtime/externals/table.rs",
          "crates/wasmtime/src/runtime/func.rs||crates/wasmtime/src/runtime/func.rs",
          "crates/wasmtime/src/runtime/func/typed.rs||crates/wasmtime/src/runtime/func/typed.rs",
          "crates/wasmtime/src/runtime/module/registry.rs||crates/wasmtime/src/runtime/module/registry.rs",
          "crates/wasmtime/src/runtime/ref.rs||crates/wasmtime/src/runtime/ref.rs",
          "crates/wasmtime/src/runtime/ref/gc_ref.rs||crates/wasmtime/src/runtime/ref/gc_ref.rs",
          "crates/wasmtime/src/runtime/ref/no_gc_ref.rs||crates/wasmtime/src/runtime/ref/no_gc_ref.rs",
          "crates/wasmtime/src/runtime/store.rs||crates/wasmtime/src/runtime/store.rs",
          "crates/wasmtime/src/runtime/trampoline/global.rs||crates/wasmtime/src/runtime/trampoline/global.rs",
          "crates/wasmtime/src/runtime/uninhabited.rs||crates/wasmtime/src/runtime/uninhabited.rs",
          "crates/wasmtime/src/runtime/values.rs||crates/wasmtime/src/runtime/values.rs",
          "winch/codegen/src/codegen/builtin.rs||winch/codegen/src/codegen/builtin.rs",
          "winch/filetests/filetests/x64/table/fill.wat||winch/filetests/filetests/x64/table/fill.wat"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/cranelift/src/func_environ.rs||crates/cranelift/src/func_environ.rs": [
          "File: crates/cranelift/src/func_environ.rs -> crates/cranelift/src/func_environ.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:     ) => {",
          "37:         struct BuiltinFunctionSignatures {",
          "38:             pointer_type: ir::Type,",
          "39:             reference_type: ir::Type,",
          "40:             call_conv: isa::CallConv,",
          "41:             $(",
          "42:                 $name: Option<ir::SigRef>,",
          "43:             )*",
          "44:         }",
          "46:         impl BuiltinFunctionSignatures {",
          "47:             fn new(",
          "48:                 pointer_type: ir::Type,",
          "49:                 reference_type: ir::Type,",
          "50:                 call_conv: isa::CallConv,",
          "51:             ) -> Self {",
          "52:                 Self {",
          "53:                     pointer_type,",
          "54:                     reference_type,",
          "55:                     call_conv,",
          "56:                     $(",
          "57:                         $name: None,",
          "58:                     )*",
          "59:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37:         #[allow(unused_doc_comments)]",
          "41:             #[cfg(feature = \"gc\")]",
          "47:                 $( #[$attr] )*",
          "52:         #[allow(unused_doc_comments)]",
          "59:                 #[cfg(not(feature = \"gc\"))]",
          "60:                 let _ = reference_type;",
          "65:                     #[cfg(feature = \"gc\")]",
          "71:                         $( #[$attr] )*",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:                 AbiParam::special(self.pointer_type, ArgumentPurpose::VMContext)",
          "64:             }",
          "66:             fn reference(&self) -> AbiParam {",
          "67:                 AbiParam::new(self.reference_type)",
          "68:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81:             #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:             }",
          "91:             $(",
          "92:                 fn $name(&mut self, func: &mut Function) -> ir::SigRef {",
          "93:                     let sig = self.$name.unwrap_or_else(|| {",
          "94:                         func.import_signature(Signature {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108:                 $( #[$attr] )*",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "339:     fn mutate_externref_ref_count(",
          "340:         &mut self,",
          "341:         builder: &mut FunctionBuilder,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356:     #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1324:                     self.builtin_function_signatures",
          "1325:                         .table_grow_func_ref(&mut pos.func),",
          "1326:                 ),",
          "1327:                 WasmHeapType::Extern => (",
          "1328:                     BuiltinFunctionIndex::table_grow_externref(),",
          "1329:                     self.builtin_function_signatures",
          "1330:                         .table_grow_externref(&mut pos.func),",
          "1331:                 ),",
          "1332:             };",
          "1334:         let (vmctx, func_addr) = self.translate_load_builtin_function_address(&mut pos, func_idx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1345:                 #[cfg(feature = \"gc\")]",
          "1351:                 #[cfg(not(feature = \"gc\"))]",
          "1352:                 WasmHeapType::Extern => {",
          "1353:                     return Err(cranelift_wasm::wasm_unsupported!(",
          "1354:                         \"support for `externref` disabled at compile time because \\",
          "1355:                      the `gc` cargo feature was not enabled\",",
          "1356:                     ))",
          "1357:                 }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1350:         table: ir::Table,",
          "1351:         index: ir::Value,",
          "1352:     ) -> WasmResult<ir::Value> {",
          "1355:         let plan = &self.module.table_plans[table_index];",
          "1356:         match plan.table.wasm_ty.heap_type {",
          "1357:             WasmHeapType::Func | WasmHeapType::Concrete(_) | WasmHeapType::NoFunc => match plan",
          "",
          "[Removed Lines]",
          "1353:         let pointer_type = self.pointer_type();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1361:                     Ok(self.get_or_init_func_ref_table_elem(builder, table_index, table, index))",
          "1362:                 }",
          "1363:             },",
          "1364:             WasmHeapType::Extern => {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1388:             #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1385:                 let reference_type = self.reference_type(WasmHeapType::Extern);",
          "1387:                 builder.ensure_inserted_block();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1410:                 let pointer_type = self.pointer_type();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1478:                 Ok(elem)",
          "1479:             }",
          "1480:         }",
          "1481:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1506:             #[cfg(not(feature = \"gc\"))]",
          "1507:             WasmHeapType::Extern => {",
          "1508:                 return Err(cranelift_wasm::wasm_unsupported!(",
          "1509:                     \"support for `externref` disabled at compile time because the \\",
          "1510:                  `gc` cargo feature was not enabled\",",
          "1511:                 ))",
          "1512:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1510:                 }",
          "1511:             },",
          "1513:             WasmHeapType::Extern => {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1546:             #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1641:                 Ok(())",
          "1642:             }",
          "1643:         }",
          "1644:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1678:             #[cfg(not(feature = \"gc\"))]",
          "1679:             WasmHeapType::Extern => {",
          "1680:                 return Err(cranelift_wasm::wasm_unsupported!(",
          "1681:                     \"support for `externref` disabled at compile time because the \\",
          "1682:                      `gc` cargo feature was not enabled\",",
          "1683:                 ))",
          "1684:             }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1658:                     self.builtin_function_signatures",
          "1659:                         .table_fill_func_ref(&mut pos.func),",
          "1660:                 ),",
          "1661:                 WasmHeapType::Extern => (",
          "1662:                     BuiltinFunctionIndex::table_fill_externref(),",
          "1663:                     self.builtin_function_signatures",
          "1664:                         .table_fill_externref(&mut pos.func),",
          "1665:                 ),",
          "1666:             };",
          "1668:         let (vmctx, builtin_addr) =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1703:                 #[cfg(feature = \"gc\")]",
          "1709:                 #[cfg(not(feature = \"gc\"))]",
          "1710:                 WasmHeapType::Extern => {",
          "1711:                     return Err(cranelift_wasm::wasm_unsupported!(",
          "1712:                         \"support for `externref` disabled at compile time because the \\",
          "1713:                          `gc` cargo feature was not enabled\",",
          "1714:                     ));",
          "1715:                 }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1727:         Ok(pos.func.dfg.first_result(call_inst))",
          "1728:     }",
          "1730:     fn translate_custom_global_get(",
          "1731:         &mut self,",
          "1732:         mut pos: cranelift_codegen::cursor::FuncCursor<'_>,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1780:     #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1754:         Ok(pos.func.dfg.first_result(call_inst))",
          "1755:     }",
          "1757:     fn translate_custom_global_set(",
          "1758:         &mut self,",
          "1759:         mut pos: cranelift_codegen::cursor::FuncCursor<'_>,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1808:     #[cfg(not(feature = \"gc\"))]",
          "1809:     fn translate_custom_global_get(",
          "1810:         &mut self,",
          "1811:         _pos: FuncCursor,",
          "1812:         index: GlobalIndex,",
          "1813:     ) -> WasmResult<ir::Value> {",
          "1814:         debug_assert_eq!(",
          "1815:             self.module.globals[index].wasm_ty,",
          "1816:             WasmValType::Ref(WasmRefType::EXTERNREF),",
          "1817:             \"We only use GlobalVariable::Custom for externref\"",
          "1818:         );",
          "1819:         Err(cranelift_wasm::wasm_unsupported!(",
          "1820:             \"support for `externref` disabled at compile time because the \\",
          "1821:              `gc` cargo feature was not enabled\",",
          "1822:         ))",
          "1823:     }",
          "1825:     #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1781:         Ok(())",
          "1782:     }",
          "1784:     fn make_heap(&mut self, func: &mut ir::Function, index: MemoryIndex) -> WasmResult<Heap> {",
          "1785:         let pointer_type = self.pointer_type();",
          "1786:         let is_shared = self.module.memory_plans[index].memory.shared;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1853:     #[cfg(not(feature = \"gc\"))]",
          "1854:     fn translate_custom_global_set(",
          "1855:         &mut self,",
          "1856:         _pos: FuncCursor,",
          "1857:         index: GlobalIndex,",
          "1858:         _value: ir::Value,",
          "1859:     ) -> WasmResult<()> {",
          "1860:         debug_assert_eq!(",
          "1861:             self.module.globals[index].wasm_ty,",
          "1862:             WasmValType::Ref(WasmRefType::EXTERNREF),",
          "1863:             \"We only use GlobalVariable::Custom for externref\"",
          "1864:         );",
          "1865:         Err(cranelift_wasm::wasm_unsupported!(",
          "1866:             \"support for `externref` disabled at compile time because the \\",
          "1867:              `gc` cargo feature was not enabled\",",
          "1868:         ))",
          "1869:     }",
          "",
          "---------------"
        ],
        "crates/environ/src/builtin.rs||crates/environ/src/builtin.rs": [
          "File: crates/environ/src/builtin.rs -> crates/environ/src/builtin.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:             table_get_lazy_init_func_ref(vmctx: vmctx, table: i32, index: i32) -> pointer;",
          "28:             table_grow_func_ref(vmctx: vmctx, table: i32, delta: i32, init: pointer) -> i32;",
          "34:             table_fill_func_ref(vmctx: vmctx, table: i32, dst: i32, val: pointer, len: i32);",
          "45:             memory_atomic_notify(vmctx: vmctx, memory: i32, addr: i64, count: i32) -> i32;",
          "",
          "[Removed Lines]",
          "30:             table_grow_externref(vmctx: vmctx, table: i32, delta: i32, init: reference) -> i32;",
          "32:             table_fill_externref(vmctx: vmctx, table: i32, dst: i32, val: reference, len: i32);",
          "36:             drop_externref(vmctx: vmctx, val: pointer);",
          "39:             activations_table_insert_with_gc(vmctx: vmctx, val: reference);",
          "41:             externref_global_get(vmctx: vmctx, global: i32) -> reference;",
          "43:             externref_global_set(vmctx: vmctx, global: i32, val: reference);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:             update_stack_pointer(vmctx: vmctx, value: i32);",
          "69:             update_mem_size(vmctx: vmctx, num_bytes: i32);",
          "70:         }",
          "71:     };",
          "72: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:             #[cfg(feature = \"gc\")]",
          "60:             drop_externref(vmctx: vmctx, val: pointer);",
          "64:             #[cfg(feature = \"gc\")]",
          "65:             activations_table_insert_with_gc(vmctx: vmctx, val: reference);",
          "68:             #[cfg(feature = \"gc\")]",
          "69:             externref_global_get(vmctx: vmctx, global: i32) -> reference;",
          "72:             #[cfg(feature = \"gc\")]",
          "73:             externref_global_set(vmctx: vmctx, global: i32, val: reference);",
          "76:             #[cfg(feature = \"gc\")]",
          "77:             table_grow_externref(vmctx: vmctx, table: i32, delta: i32, init: reference) -> i32;",
          "80:             #[cfg(feature = \"gc\")]",
          "81:             table_fill_externref(vmctx: vmctx, table: i32, dst: i32, val: reference, len: i32);",
          "",
          "---------------"
        ],
        "crates/runtime/src/externref.rs||crates/runtime/src/externref.rs": [
          "File: crates/runtime/src/externref.rs -> crates/runtime/src/externref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "102: use crate::{Backtrace, SendSyncPtr, VMRuntimeLimits};",
          "103: use std::alloc::Layout;",
          "104: use std::any::Any;",
          "105: use std::cell::UnsafeCell;",
          "106: use std::cmp;",
          "107: use std::collections::HashSet;",
          "108: use std::hash::{Hash, Hasher};",
          "109: use std::mem;",
          "110: use std::ops::Deref;",
          "111: use std::ptr::{self, NonNull};",
          "112: use std::sync::atomic::{self, AtomicUsize, Ordering};",
          "113: use wasmtime_environ::StackMap;",
          "165: #[derive(Debug)]",
          "166: #[repr(transparent)]",
          "167: pub struct VMExternRef(SendSyncPtr<VMExternData>);",
          "169: impl std::fmt::Pointer for VMExternRef {",
          "170:     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "171:         std::fmt::Pointer::fmt(&self.0, f)",
          "172:     }",
          "173: }",
          "175: #[repr(C)]",
          "176: pub(crate) struct VMExternData {",
          "190:     ref_count: AtomicUsize,",
          "194:     value_ptr: SendSyncPtr<dyn Any + Send + Sync>,",
          "195: }",
          "197: impl Clone for VMExternRef {",
          "198:     #[inline]",
          "199:     fn clone(&self) -> VMExternRef {",
          "200:         self.extern_data().increment_ref_count();",
          "201:         VMExternRef(self.0)",
          "202:     }",
          "203: }",
          "205: impl Drop for VMExternRef {",
          "206:     #[inline]",
          "207:     fn drop(&mut self) {",
          "208:         let data = self.extern_data();",
          "217:         if data.ref_count.fetch_sub(1, Ordering::Release) != 1 {",
          "218:             return;",
          "219:         }",
          "220:         atomic::fence(Ordering::Acquire);",
          "222:         unsafe {",
          "223:             VMExternData::drop_and_dealloc(self.0);",
          "224:         }",
          "225:     }",
          "226: }",
          "228: impl VMExternData {",
          "236:     unsafe fn layout_for(value_size: usize, value_align: usize) -> (Layout, usize) {",
          "237:         let extern_data_size = mem::size_of::<VMExternData>();",
          "238:         let extern_data_align = mem::align_of::<VMExternData>();",
          "240:         let value_and_padding_size = round_up_to_align(value_size, extern_data_align).unwrap();",
          "242:         let alloc_align = std::cmp::max(value_align, extern_data_align);",
          "243:         let alloc_size = value_and_padding_size + extern_data_size;",
          "245:         debug_assert!(",
          "246:             Layout::from_size_align(alloc_size, alloc_align).is_ok(),",
          "247:             \"should create a `Layout` for size={} and align={} okay\",",
          "248:             alloc_size,",
          "249:             alloc_align,",
          "250:         );",
          "251:         (",
          "252:             Layout::from_size_align_unchecked(alloc_size, alloc_align),",
          "253:             value_and_padding_size,",
          "254:         )",
          "255:     }",
          "258:     pub(crate) unsafe fn drop_and_dealloc(mut data: SendSyncPtr<VMExternData>) {",
          "259:         log::trace!(\"Dropping externref data @ {:p}\", data);",
          "264:         let (alloc_ptr, layout) = {",
          "265:             let data = data.as_mut();",
          "266:             debug_assert_eq!(data.ref_count.load(Ordering::SeqCst), 0);",
          "270:             let (layout, _) = {",
          "271:                 let value = data.value_ptr.as_ref();",
          "272:                 Self::layout_for(mem::size_of_val(value), mem::align_of_val(value))",
          "273:             };",
          "275:             ptr::drop_in_place(data.value_ptr.as_ptr());",
          "276:             let alloc_ptr = data.value_ptr.as_ptr().cast::<u8>();",
          "278:             (alloc_ptr, layout)",
          "279:         };",
          "281:         ptr::drop_in_place(data.as_ptr());",
          "282:         std::alloc::dealloc(alloc_ptr, layout);",
          "283:     }",
          "285:     #[inline]",
          "286:     fn increment_ref_count(&self) {",
          "294:         self.ref_count.fetch_add(1, Ordering::Relaxed);",
          "295:     }",
          "296: }",
          "298: #[inline]",
          "299: fn round_up_to_align(n: usize, align: usize) -> Option<usize> {",
          "300:     debug_assert!(align.is_power_of_two());",
          "301:     let align_minus_one = align - 1;",
          "302:     Some(n.checked_add(align_minus_one)? & !align_minus_one)",
          "303: }",
          "305: impl VMExternRef {",
          "307:     pub fn new<T>(value: T) -> VMExternRef",
          "308:     where",
          "309:         T: 'static + Any + Send + Sync,",
          "310:     {",
          "311:         VMExternRef::new_with(|| value)",
          "312:     }",
          "315:     pub fn new_with<T>(make_value: impl FnOnce() -> T) -> VMExternRef",
          "316:     where",
          "317:         T: 'static + Any + Send + Sync,",
          "318:     {",
          "319:         unsafe {",
          "320:             let (layout, footer_offset) =",
          "321:                 VMExternData::layout_for(mem::size_of::<T>(), mem::align_of::<T>());",
          "323:             let alloc_ptr = std::alloc::alloc(layout);",
          "324:             let alloc_ptr = NonNull::new(alloc_ptr).unwrap_or_else(|| {",
          "325:                 std::alloc::handle_alloc_error(layout);",
          "326:             });",
          "328:             let value_ptr = alloc_ptr.cast::<T>();",
          "329:             ptr::write(value_ptr.as_ptr(), make_value());",
          "331:             let extern_data_ptr =",
          "332:                 alloc_ptr.cast::<u8>().as_ptr().add(footer_offset) as *mut VMExternData;",
          "334:             ptr::write(",
          "335:                 extern_data_ptr,",
          "336:                 VMExternData {",
          "337:                     ref_count: AtomicUsize::new(1),",
          "339:                     value_ptr: SendSyncPtr::new(NonNull::new_unchecked(value_ptr.as_ptr())),",
          "340:                 },",
          "341:             );",
          "343:             log::trace!(\"New externref data @ {:p}\", extern_data_ptr);",
          "344:             VMExternRef(NonNull::new_unchecked(extern_data_ptr).into())",
          "345:         }",
          "346:     }",
          "357:     #[inline]",
          "358:     pub fn as_raw(&self) -> *mut u8 {",
          "359:         let ptr = self.0.as_ptr().cast::<u8>();",
          "360:         ptr",
          "361:     }",
          "371:     pub unsafe fn into_raw(self) -> *mut u8 {",
          "372:         let ptr = self.0.as_ptr().cast::<u8>();",
          "373:         std::mem::forget(self);",
          "374:         ptr",
          "375:     }",
          "385:     pub unsafe fn from_raw(ptr: *mut u8) -> Self {",
          "386:         debug_assert!(!ptr.is_null());",
          "387:         VMExternRef(NonNull::new_unchecked(ptr).cast().into())",
          "388:     }",
          "401:     pub unsafe fn clone_from_raw(ptr: *mut u8) -> Self {",
          "402:         debug_assert!(!ptr.is_null());",
          "403:         let x = VMExternRef(NonNull::new_unchecked(ptr).cast().into());",
          "404:         x.extern_data().increment_ref_count();",
          "405:         x",
          "406:     }",
          "412:     pub fn strong_count(&self) -> usize {",
          "413:         self.extern_data().ref_count.load(Ordering::SeqCst)",
          "414:     }",
          "416:     #[inline]",
          "417:     fn extern_data(&self) -> &VMExternData {",
          "418:         unsafe { self.0.as_ref() }",
          "419:     }",
          "420: }",
          "427: impl VMExternRef {",
          "433:     #[inline]",
          "434:     pub fn eq(a: &Self, b: &Self) -> bool {",
          "435:         ptr::eq(a.0.as_ptr(), b.0.as_ptr())",
          "436:     }",
          "442:     #[inline]",
          "443:     pub fn hash<H>(externref: &Self, hasher: &mut H)",
          "444:     where",
          "445:         H: Hasher,",
          "446:     {",
          "447:         ptr::hash(externref.0.as_ptr(), hasher);",
          "448:     }",
          "455:     #[inline]",
          "456:     pub fn cmp(a: &Self, b: &Self) -> cmp::Ordering {",
          "457:         let a = a.0.as_ptr() as usize;",
          "458:         let b = b.0.as_ptr() as usize;",
          "459:         a.cmp(&b)",
          "460:     }",
          "461: }",
          "463: impl Deref for VMExternRef {",
          "464:     type Target = dyn Any;",
          "466:     fn deref(&self) -> &dyn Any {",
          "467:         unsafe { self.extern_data().value_ptr.as_ref() }",
          "468:     }",
          "469: }",
          "476: #[derive(Clone, Debug)]",
          "477: struct VMExternRefWithTraits(VMExternRef);",
          "479: impl Hash for VMExternRefWithTraits {",
          "480:     fn hash<H>(&self, hasher: &mut H)",
          "481:     where",
          "482:         H: Hasher,",
          "483:     {",
          "484:         VMExternRef::hash(&self.0, hasher)",
          "485:     }",
          "486: }",
          "488: impl PartialEq for VMExternRefWithTraits {",
          "489:     fn eq(&self, other: &Self) -> bool {",
          "490:         VMExternRef::eq(&self.0, &other.0)",
          "491:     }",
          "492: }",
          "494: impl Eq for VMExternRefWithTraits {}",
          "496: type TableElem = UnsafeCell<Option<VMExternRef>>;",
          "503: #[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.",
          "504: pub struct VMExternRefActivationsTable {",
          "509:     alloc: VMExternRefTableAlloc,",
          "518:     over_approximated_stack_roots: HashSet<VMExternRefWithTraits>,",
          "526:     precise_stack_roots: HashSet<VMExternRefWithTraits>,",
          "530:     #[cfg(debug_assertions)]",
          "531:     gc_okay: bool,",
          "532: }",
          "534: #[repr(C)] // This is accessed from JIT code.",
          "535: struct VMExternRefTableAlloc {",
          "540:     next: UnsafeCell<NonNull<TableElem>>,",
          "546:     end: NonNull<TableElem>,",
          "551:     chunk: Box<[TableElem]>,",
          "552: }",
          "557: unsafe impl Send for VMExternRefTableAlloc {}",
          "558: unsafe impl Sync for VMExternRefTableAlloc {}",
          "560: fn _assert_send_sync() {",
          "561:     fn _assert<T: Send + Sync>() {}",
          "562:     _assert::<VMExternRefActivationsTable>();",
          "563:     _assert::<VMExternRef>();",
          "564: }",
          "566: impl VMExternRefActivationsTable {",
          "567:     const CHUNK_SIZE: usize = 4096 / mem::size_of::<usize>();",
          "570:     pub fn new() -> Self {",
          "576:         let mut chunk: Box<[TableElem]> = Box::new([]);",
          "577:         let next = chunk.as_mut_ptr();",
          "578:         let end = unsafe { next.add(chunk.len()) };",
          "580:         VMExternRefActivationsTable {",
          "581:             alloc: VMExternRefTableAlloc {",
          "582:                 next: UnsafeCell::new(NonNull::new(next).unwrap()),",
          "583:                 end: NonNull::new(end).unwrap(),",
          "584:                 chunk,",
          "585:             },",
          "586:             over_approximated_stack_roots: HashSet::new(),",
          "587:             precise_stack_roots: HashSet::new(),",
          "588:             #[cfg(debug_assertions)]",
          "589:             gc_okay: true,",
          "590:         }",
          "591:     }",
          "593:     fn new_chunk(size: usize) -> Box<[UnsafeCell<Option<VMExternRef>>]> {",
          "594:         assert!(size >= Self::CHUNK_SIZE);",
          "595:         (0..size).map(|_| UnsafeCell::new(None)).collect()",
          "596:     }",
          "599:     #[inline]",
          "600:     pub fn bump_capacity_remaining(&self) -> usize {",
          "601:         let end = self.alloc.end.as_ptr() as usize;",
          "602:         let next = unsafe { *self.alloc.next.get() };",
          "603:         end - next.as_ptr() as usize",
          "604:     }",
          "615:     #[inline]",
          "616:     pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {",
          "617:         unsafe {",
          "618:             let next = *self.alloc.next.get();",
          "619:             if next == self.alloc.end {",
          "620:                 return Err(externref);",
          "621:             }",
          "623:             debug_assert!(",
          "624:                 (*next.as_ref().get()).is_none(),",
          "625:                 \"slots >= the `next` bump finger are always `None`\"",
          "626:             );",
          "627:             ptr::write(next.as_ptr(), UnsafeCell::new(Some(externref)));",
          "629:             let next = NonNull::new_unchecked(next.as_ptr().add(1));",
          "630:             debug_assert!(next <= self.alloc.end);",
          "633:             Ok(())",
          "634:         }",
          "635:     }",
          "643:     #[inline]",
          "644:     pub unsafe fn insert_with_gc(",
          "645:         &mut self,",
          "646:         limits: *const VMRuntimeLimits,",
          "647:         externref: VMExternRef,",
          "648:         module_info_lookup: &dyn ModuleInfoLookup,",
          "649:     ) {",
          "650:         #[cfg(debug_assertions)]",
          "651:         assert!(self.gc_okay);",
          "653:         if let Err(externref) = self.try_insert(externref) {",
          "654:             self.gc_and_insert_slow(limits, externref, module_info_lookup);",
          "655:         }",
          "656:     }",
          "658:     #[inline(never)]",
          "659:     unsafe fn gc_and_insert_slow(",
          "660:         &mut self,",
          "661:         limits: *const VMRuntimeLimits,",
          "662:         externref: VMExternRef,",
          "663:         module_info_lookup: &dyn ModuleInfoLookup,",
          "664:     ) {",
          "665:         gc(limits, module_info_lookup, self);",
          "670:         self.over_approximated_stack_roots",
          "671:             .insert(VMExternRefWithTraits(externref));",
          "672:     }",
          "675:     #[inline]",
          "676:     pub fn insert_without_gc(&mut self, externref: VMExternRef) {",
          "677:         if let Err(externref) = self.try_insert(externref) {",
          "678:             self.insert_slow_without_gc(externref);",
          "679:         }",
          "680:     }",
          "682:     #[inline(never)]",
          "683:     fn insert_slow_without_gc(&mut self, externref: VMExternRef) {",
          "684:         self.over_approximated_stack_roots",
          "685:             .insert(VMExternRefWithTraits(externref));",
          "686:     }",
          "688:     fn num_filled_in_bump_chunk(&self) -> usize {",
          "689:         let next = unsafe { *self.alloc.next.get() };",
          "690:         let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);",
          "691:         let slots_unused = bytes_unused / mem::size_of::<TableElem>();",
          "692:         self.alloc.chunk.len().saturating_sub(slots_unused)",
          "693:     }",
          "695:     fn elements(&self, mut f: impl FnMut(&VMExternRef)) {",
          "696:         for elem in self.over_approximated_stack_roots.iter() {",
          "697:             f(&elem.0);",
          "698:         }",
          "702:         let num_filled = self.num_filled_in_bump_chunk();",
          "703:         for slot in self.alloc.chunk.iter().take(num_filled) {",
          "704:             if let Some(elem) = unsafe { &*slot.get() } {",
          "705:                 f(elem);",
          "706:             }",
          "707:         }",
          "708:     }",
          "710:     fn insert_precise_stack_root(",
          "711:         precise_stack_roots: &mut HashSet<VMExternRefWithTraits>,",
          "712:         root: NonNull<VMExternData>,",
          "713:     ) {",
          "714:         let root = unsafe { VMExternRef::clone_from_raw(root.as_ptr().cast()) };",
          "715:         log::trace!(\"Found externref on stack: {:p}\", root);",
          "716:         precise_stack_roots.insert(VMExternRefWithTraits(root));",
          "717:     }",
          "721:     fn sweep(&mut self) {",
          "722:         log::trace!(\"begin GC sweep\");",
          "725:         let num_filled = self.num_filled_in_bump_chunk();",
          "726:         unsafe {",
          "728:         }",
          "729:         for slot in self.alloc.chunk.iter().take(num_filled) {",
          "730:             unsafe {",
          "732:             }",
          "733:         }",
          "734:         debug_assert!(",
          "735:             self.alloc",
          "736:                 .chunk",
          "737:                 .iter()",
          "738:                 .all(|slot| unsafe { (*slot.get()).as_ref().is_none() }),",
          "739:             \"after sweeping the bump chunk, all slots should be `None`\"",
          "740:         );",
          "744:         if self.alloc.chunk.is_empty() {",
          "745:             self.alloc.chunk = Self::new_chunk(Self::CHUNK_SIZE);",
          "746:             self.alloc.end =",
          "747:                 NonNull::new(unsafe { self.alloc.chunk.as_mut_ptr().add(self.alloc.chunk.len()) })",
          "748:                     .unwrap();",
          "749:         }",
          "752:         unsafe {",
          "753:             let next = self.alloc.chunk.as_mut_ptr();",
          "754:             debug_assert!(!next.is_null());",
          "756:         }",
          "760:         mem::swap(",
          "761:             &mut self.precise_stack_roots,",
          "762:             &mut self.over_approximated_stack_roots,",
          "763:         );",
          "771:         self.precise_stack_roots.clear();",
          "773:         log::trace!(\"end GC sweep\");",
          "774:     }",
          "781:     #[inline]",
          "782:     pub fn set_gc_okay(&mut self, okay: bool) -> bool {",
          "783:         #[cfg(debug_assertions)]",
          "784:         {",
          "785:             return std::mem::replace(&mut self.gc_okay, okay);",
          "786:         }",
          "787:         #[cfg(not(debug_assertions))]",
          "788:         {",
          "789:             let _ = okay;",
          "790:             return true;",
          "791:         }",
          "792:     }",
          "793: }",
          "",
          "[Added Lines]",
          "1: #[cfg(feature = \"gc\")]",
          "2: mod gc;",
          "3: #[cfg(feature = \"gc\")]",
          "4: pub use gc::*;",
          "6: #[cfg(not(feature = \"gc\"))]",
          "7: mod no_gc;",
          "8: #[cfg(not(feature = \"gc\"))]",
          "9: pub use no_gc::*;",
          "11: use wasmtime_environ::StackMap;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "805:     fn lookup_stack_map(&self, pc: usize) -> Option<&StackMap>;",
          "806: }",
          "",
          "[Removed Lines]",
          "808: #[derive(Debug, Default)]",
          "809: struct DebugOnly<T> {",
          "810:     inner: T,",
          "811: }",
          "813: impl<T> std::ops::Deref for DebugOnly<T> {",
          "814:     type Target = T;",
          "816:     fn deref(&self) -> &T {",
          "817:         if cfg!(debug_assertions) {",
          "818:             &self.inner",
          "819:         } else {",
          "820:             panic!(",
          "821:                 \"only deref `DebugOnly` when `cfg(debug_assertions)` or \\",
          "822:                  inside a `debug_assert!(..)`\"",
          "823:             )",
          "824:         }",
          "825:     }",
          "826: }",
          "828: impl<T> std::ops::DerefMut for DebugOnly<T> {",
          "829:     fn deref_mut(&mut self) -> &mut T {",
          "830:         if cfg!(debug_assertions) {",
          "831:             &mut self.inner",
          "832:         } else {",
          "833:             panic!(",
          "834:                 \"only deref `DebugOnly` when `cfg(debug_assertions)` or \\",
          "835:                  inside a `debug_assert!(..)`\"",
          "836:             )",
          "837:         }",
          "838:     }",
          "839: }",
          "852: pub unsafe fn gc(",
          "853:     limits: *const VMRuntimeLimits,",
          "854:     module_info_lookup: &dyn ModuleInfoLookup,",
          "855:     externref_activations_table: &mut VMExternRefActivationsTable,",
          "856: ) {",
          "857:     log::debug!(\"start GC\");",
          "859:     #[cfg(debug_assertions)]",
          "860:     assert!(externref_activations_table.gc_okay);",
          "862:     debug_assert!({",
          "868:         externref_activations_table.precise_stack_roots.is_empty()",
          "869:     });",
          "886:     let mut activations_table_set: DebugOnly<HashSet<_>> = Default::default();",
          "887:     if cfg!(debug_assertions) {",
          "888:         externref_activations_table.elements(|elem| {",
          "889:             activations_table_set.insert(elem.as_raw() as *mut VMExternData);",
          "890:         });",
          "891:     }",
          "893:     log::trace!(\"begin GC trace\");",
          "894:     Backtrace::trace(limits, |frame| {",
          "895:         let pc = frame.pc();",
          "896:         debug_assert!(pc != 0, \"we should always get a valid PC for Wasm frames\");",
          "898:         let fp = frame.fp();",
          "899:         debug_assert!(",
          "900:             fp != 0,",
          "901:             \"we should always get a valid frame pointer for Wasm frames\"",
          "902:         );",
          "904:         let module_info = module_info_lookup",
          "905:             .lookup(pc)",
          "906:             .expect(\"should have module info for Wasm frame\");",
          "908:         let stack_map = match module_info.lookup_stack_map(pc) {",
          "909:             Some(sm) => sm,",
          "910:             None => {",
          "911:                 log::trace!(\"No stack map for this Wasm frame\");",
          "912:                 return std::ops::ControlFlow::Continue(());",
          "913:             }",
          "914:         };",
          "915:         log::trace!(",
          "916:             \"We have a stack map that maps {} words in this Wasm frame\",",
          "917:             stack_map.mapped_words()",
          "918:         );",
          "920:         let sp = fp - stack_map.mapped_words() as usize * mem::size_of::<usize>();",
          "922:         for i in 0..(stack_map.mapped_words() as usize) {",
          "927:             let stack_slot = sp + i * mem::size_of::<usize>();",
          "929:             if !stack_map.get_bit(i) {",
          "930:                 log::trace!(",
          "931:                     \"Stack slot @ {:p} does not contain externrefs\",",
          "932:                     stack_slot as *const (),",
          "933:                 );",
          "934:                 continue;",
          "935:             }",
          "937:             let stack_slot = stack_slot as *const *mut VMExternData;",
          "938:             let r = std::ptr::read(stack_slot);",
          "939:             log::trace!(\"Stack slot @ {:p} = {:p}\", stack_slot, r);",
          "941:             debug_assert!(",
          "942:                 r.is_null() || activations_table_set.contains(&r),",
          "943:                 \"every on-stack externref inside a Wasm frame should \\",
          "944:                  have an entry in the VMExternRefActivationsTable; \\",
          "945:                  {:?} is not in the table\",",
          "946:                 r",
          "947:             );",
          "949:             if let Some(r) = NonNull::new(r) {",
          "950:                 VMExternRefActivationsTable::insert_precise_stack_root(",
          "951:                     &mut externref_activations_table.precise_stack_roots,",
          "952:                     r,",
          "953:                 );",
          "954:             }",
          "955:         }",
          "957:         std::ops::ControlFlow::Continue(())",
          "958:     });",
          "959:     log::trace!(\"end GC trace\");",
          "961:     externref_activations_table.sweep();",
          "963:     log::debug!(\"end GC\");",
          "964: }",
          "966: #[cfg(test)]",
          "967: mod tests {",
          "968:     use super::*;",
          "970:     #[test]",
          "971:     fn extern_ref_is_pointer_sized_and_aligned() {",
          "972:         assert_eq!(mem::size_of::<VMExternRef>(), mem::size_of::<*mut ()>());",
          "973:         assert_eq!(mem::align_of::<VMExternRef>(), mem::align_of::<*mut ()>());",
          "974:         assert_eq!(",
          "975:             mem::size_of::<Option<VMExternRef>>(),",
          "976:             mem::size_of::<*mut ()>()",
          "977:         );",
          "978:         assert_eq!(",
          "979:             mem::align_of::<Option<VMExternRef>>(),",
          "980:             mem::align_of::<*mut ()>()",
          "981:         );",
          "982:     }",
          "984:     #[test]",
          "985:     fn ref_count_is_at_correct_offset() {",
          "986:         let s = \"hi\";",
          "987:         let s: &(dyn Any + Send + Sync) = &s as _;",
          "988:         let s: *const (dyn Any + Send + Sync) = s as _;",
          "989:         let s: *mut (dyn Any + Send + Sync) = s as _;",
          "991:         let extern_data = VMExternData {",
          "992:             ref_count: AtomicUsize::new(0),",
          "993:             value_ptr: NonNull::new(s).unwrap().into(),",
          "994:         };",
          "996:         let extern_data_ptr = &extern_data as *const _;",
          "997:         let ref_count_ptr = &extern_data.ref_count as *const _;",
          "999:         let actual_offset = (ref_count_ptr as usize) - (extern_data_ptr as usize);",
          "1001:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "1002:             ptr: 8,",
          "1003:             num_imported_functions: 0,",
          "1004:             num_imported_tables: 0,",
          "1005:             num_imported_memories: 0,",
          "1006:             num_imported_globals: 0,",
          "1007:             num_defined_tables: 0,",
          "1008:             num_defined_memories: 0,",
          "1009:             num_owned_memories: 0,",
          "1010:             num_defined_globals: 0,",
          "1011:             num_escaped_funcs: 0,",
          "1012:         });",
          "1013:         assert_eq!(",
          "1014:             offsets.vm_extern_data_ref_count(),",
          "1015:             actual_offset.try_into().unwrap(),",
          "1016:         );",
          "1017:     }",
          "1019:     #[test]",
          "1020:     fn table_next_is_at_correct_offset() {",
          "1021:         let table = VMExternRefActivationsTable::new();",
          "1023:         let table_ptr = &table as *const _;",
          "1024:         let next_ptr = &table.alloc.next as *const _;",
          "1026:         let actual_offset = (next_ptr as usize) - (table_ptr as usize);",
          "1028:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "1029:             ptr: 8,",
          "1030:             num_imported_functions: 0,",
          "1031:             num_imported_tables: 0,",
          "1032:             num_imported_memories: 0,",
          "1033:             num_imported_globals: 0,",
          "1034:             num_defined_tables: 0,",
          "1035:             num_defined_memories: 0,",
          "1036:             num_owned_memories: 0,",
          "1037:             num_defined_globals: 0,",
          "1038:             num_escaped_funcs: 0,",
          "1039:         });",
          "1040:         assert_eq!(",
          "1041:             offsets.vm_extern_ref_activation_table_next() as usize,",
          "1042:             actual_offset",
          "1043:         );",
          "1044:     }",
          "1046:     #[test]",
          "1047:     fn table_end_is_at_correct_offset() {",
          "1048:         let table = VMExternRefActivationsTable::new();",
          "1050:         let table_ptr = &table as *const _;",
          "1051:         let end_ptr = &table.alloc.end as *const _;",
          "1053:         let actual_offset = (end_ptr as usize) - (table_ptr as usize);",
          "1055:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "1056:             ptr: 8,",
          "1057:             num_imported_functions: 0,",
          "1058:             num_imported_tables: 0,",
          "1059:             num_imported_memories: 0,",
          "1060:             num_imported_globals: 0,",
          "1061:             num_defined_tables: 0,",
          "1062:             num_defined_memories: 0,",
          "1063:             num_owned_memories: 0,",
          "1064:             num_defined_globals: 0,",
          "1065:             num_escaped_funcs: 0,",
          "1066:         });",
          "1067:         assert_eq!(",
          "1068:             offsets.vm_extern_ref_activation_table_end() as usize,",
          "1069:             actual_offset",
          "1070:         );",
          "1071:     }",
          "1072: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/runtime/src/externref/gc.rs||crates/runtime/src/externref/gc.rs": [
          "File: crates/runtime/src/externref/gc.rs -> crates/runtime/src/externref/gc.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: use crate::{Backtrace, ModuleInfoLookup, SendSyncPtr, VMRuntimeLimits};",
          "103: use std::alloc::Layout;",
          "104: use std::any::Any;",
          "105: use std::cell::UnsafeCell;",
          "106: use std::cmp;",
          "107: use std::collections::HashSet;",
          "108: use std::hash::{Hash, Hasher};",
          "109: use std::mem;",
          "110: use std::ops::Deref;",
          "111: use std::ptr::{self, NonNull};",
          "112: use std::sync::atomic::{self, AtomicUsize, Ordering};",
          "164: #[derive(Debug)]",
          "165: #[repr(transparent)]",
          "166: pub struct VMExternRef(SendSyncPtr<VMExternData>);",
          "168: impl std::fmt::Pointer for VMExternRef {",
          "169:     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "170:         std::fmt::Pointer::fmt(&self.0, f)",
          "171:     }",
          "172: }",
          "174: #[repr(C)]",
          "175: pub(crate) struct VMExternData {",
          "189:     ref_count: AtomicUsize,",
          "193:     value_ptr: SendSyncPtr<dyn Any + Send + Sync>,",
          "194: }",
          "196: impl Clone for VMExternRef {",
          "197:     #[inline]",
          "198:     fn clone(&self) -> VMExternRef {",
          "199:         self.extern_data().increment_ref_count();",
          "200:         VMExternRef(self.0)",
          "201:     }",
          "202: }",
          "204: impl Drop for VMExternRef {",
          "205:     #[inline]",
          "206:     fn drop(&mut self) {",
          "207:         let data = self.extern_data();",
          "216:         if data.ref_count.fetch_sub(1, Ordering::Release) != 1 {",
          "217:             return;",
          "218:         }",
          "219:         atomic::fence(Ordering::Acquire);",
          "221:         unsafe {",
          "222:             VMExternData::drop_and_dealloc(self.0);",
          "223:         }",
          "224:     }",
          "225: }",
          "227: impl VMExternData {",
          "235:     unsafe fn layout_for(value_size: usize, value_align: usize) -> (Layout, usize) {",
          "236:         let extern_data_size = mem::size_of::<VMExternData>();",
          "237:         let extern_data_align = mem::align_of::<VMExternData>();",
          "239:         let value_and_padding_size = round_up_to_align(value_size, extern_data_align).unwrap();",
          "241:         let alloc_align = std::cmp::max(value_align, extern_data_align);",
          "242:         let alloc_size = value_and_padding_size + extern_data_size;",
          "244:         debug_assert!(",
          "245:             Layout::from_size_align(alloc_size, alloc_align).is_ok(),",
          "246:             \"should create a `Layout` for size={} and align={} okay\",",
          "247:             alloc_size,",
          "248:             alloc_align,",
          "249:         );",
          "250:         (",
          "251:             Layout::from_size_align_unchecked(alloc_size, alloc_align),",
          "252:             value_and_padding_size,",
          "253:         )",
          "254:     }",
          "257:     pub(crate) unsafe fn drop_and_dealloc(mut data: SendSyncPtr<VMExternData>) {",
          "258:         log::trace!(\"Dropping externref data @ {:p}\", data);",
          "263:         let (alloc_ptr, layout) = {",
          "264:             let data = data.as_mut();",
          "265:             debug_assert_eq!(data.ref_count.load(Ordering::SeqCst), 0);",
          "269:             let (layout, _) = {",
          "270:                 let value = data.value_ptr.as_ref();",
          "271:                 Self::layout_for(mem::size_of_val(value), mem::align_of_val(value))",
          "272:             };",
          "274:             ptr::drop_in_place(data.value_ptr.as_ptr());",
          "275:             let alloc_ptr = data.value_ptr.as_ptr().cast::<u8>();",
          "277:             (alloc_ptr, layout)",
          "278:         };",
          "280:         ptr::drop_in_place(data.as_ptr());",
          "281:         std::alloc::dealloc(alloc_ptr, layout);",
          "282:     }",
          "284:     #[inline]",
          "285:     fn increment_ref_count(&self) {",
          "293:         self.ref_count.fetch_add(1, Ordering::Relaxed);",
          "294:     }",
          "295: }",
          "297: #[inline]",
          "298: fn round_up_to_align(n: usize, align: usize) -> Option<usize> {",
          "299:     debug_assert!(align.is_power_of_two());",
          "300:     let align_minus_one = align - 1;",
          "301:     Some(n.checked_add(align_minus_one)? & !align_minus_one)",
          "302: }",
          "304: impl VMExternRef {",
          "306:     pub fn new<T>(value: T) -> VMExternRef",
          "307:     where",
          "308:         T: 'static + Any + Send + Sync,",
          "309:     {",
          "310:         VMExternRef::new_with(|| value)",
          "311:     }",
          "314:     pub fn new_with<T>(make_value: impl FnOnce() -> T) -> VMExternRef",
          "315:     where",
          "316:         T: 'static + Any + Send + Sync,",
          "317:     {",
          "318:         unsafe {",
          "319:             let (layout, footer_offset) =",
          "320:                 VMExternData::layout_for(mem::size_of::<T>(), mem::align_of::<T>());",
          "322:             let alloc_ptr = std::alloc::alloc(layout);",
          "323:             let alloc_ptr = NonNull::new(alloc_ptr).unwrap_or_else(|| {",
          "324:                 std::alloc::handle_alloc_error(layout);",
          "325:             });",
          "327:             let value_ptr = alloc_ptr.cast::<T>();",
          "328:             ptr::write(value_ptr.as_ptr(), make_value());",
          "330:             let extern_data_ptr =",
          "331:                 alloc_ptr.cast::<u8>().as_ptr().add(footer_offset) as *mut VMExternData;",
          "333:             ptr::write(",
          "334:                 extern_data_ptr,",
          "335:                 VMExternData {",
          "336:                     ref_count: AtomicUsize::new(1),",
          "338:                     value_ptr: SendSyncPtr::new(NonNull::new_unchecked(value_ptr.as_ptr())),",
          "339:                 },",
          "340:             );",
          "342:             log::trace!(\"New externref data @ {:p}\", extern_data_ptr);",
          "343:             VMExternRef(NonNull::new_unchecked(extern_data_ptr).into())",
          "344:         }",
          "345:     }",
          "356:     #[inline]",
          "357:     pub fn as_raw(&self) -> *mut u8 {",
          "358:         let ptr = self.0.as_ptr().cast::<u8>();",
          "359:         ptr",
          "360:     }",
          "370:     pub unsafe fn into_raw(self) -> *mut u8 {",
          "371:         let ptr = self.0.as_ptr().cast::<u8>();",
          "372:         std::mem::forget(self);",
          "373:         ptr",
          "374:     }",
          "384:     #[inline]",
          "385:     pub unsafe fn from_raw(ptr: *mut u8) -> Option<Self> {",
          "386:         Some(VMExternRef(NonNull::new(ptr)?.cast().into()))",
          "387:     }",
          "400:     #[inline]",
          "401:     pub unsafe fn clone_from_raw(ptr: *mut u8) -> Option<Self> {",
          "402:         let x = VMExternRef(NonNull::new(ptr)?.cast::<VMExternData>().into());",
          "403:         x.extern_data().increment_ref_count();",
          "404:         Some(x)",
          "405:     }",
          "411:     pub fn strong_count(&self) -> usize {",
          "412:         self.extern_data().ref_count.load(Ordering::SeqCst)",
          "413:     }",
          "415:     #[inline]",
          "416:     fn extern_data(&self) -> &VMExternData {",
          "417:         unsafe { self.0.as_ref() }",
          "418:     }",
          "419: }",
          "426: impl VMExternRef {",
          "432:     #[inline]",
          "433:     pub fn eq(a: &Self, b: &Self) -> bool {",
          "434:         ptr::eq(a.0.as_ptr(), b.0.as_ptr())",
          "435:     }",
          "441:     #[inline]",
          "442:     pub fn hash<H>(externref: &Self, hasher: &mut H)",
          "443:     where",
          "444:         H: Hasher,",
          "445:     {",
          "446:         ptr::hash(externref.0.as_ptr(), hasher);",
          "447:     }",
          "454:     #[inline]",
          "455:     pub fn cmp(a: &Self, b: &Self) -> cmp::Ordering {",
          "456:         let a = a.0.as_ptr() as usize;",
          "457:         let b = b.0.as_ptr() as usize;",
          "458:         a.cmp(&b)",
          "459:     }",
          "460: }",
          "462: impl Deref for VMExternRef {",
          "463:     type Target = dyn Any;",
          "465:     fn deref(&self) -> &dyn Any {",
          "466:         unsafe { self.extern_data().value_ptr.as_ref() }",
          "467:     }",
          "468: }",
          "475: #[derive(Clone, Debug)]",
          "476: struct VMExternRefWithTraits(VMExternRef);",
          "478: impl Hash for VMExternRefWithTraits {",
          "479:     fn hash<H>(&self, hasher: &mut H)",
          "480:     where",
          "481:         H: Hasher,",
          "482:     {",
          "483:         VMExternRef::hash(&self.0, hasher)",
          "484:     }",
          "485: }",
          "487: impl PartialEq for VMExternRefWithTraits {",
          "488:     fn eq(&self, other: &Self) -> bool {",
          "489:         VMExternRef::eq(&self.0, &other.0)",
          "490:     }",
          "491: }",
          "493: impl Eq for VMExternRefWithTraits {}",
          "495: type TableElem = UnsafeCell<Option<VMExternRef>>;",
          "502: #[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.",
          "503: pub struct VMExternRefActivationsTable {",
          "508:     alloc: VMExternRefTableAlloc,",
          "517:     over_approximated_stack_roots: HashSet<VMExternRefWithTraits>,",
          "525:     precise_stack_roots: HashSet<VMExternRefWithTraits>,",
          "529:     #[cfg(debug_assertions)]",
          "530:     gc_okay: bool,",
          "531: }",
          "533: #[repr(C)] // This is accessed from JIT code.",
          "534: struct VMExternRefTableAlloc {",
          "539:     next: UnsafeCell<NonNull<TableElem>>,",
          "545:     end: NonNull<TableElem>,",
          "550:     chunk: Box<[TableElem]>,",
          "551: }",
          "556: unsafe impl Send for VMExternRefTableAlloc {}",
          "557: unsafe impl Sync for VMExternRefTableAlloc {}",
          "559: fn _assert_send_sync() {",
          "560:     fn _assert<T: Send + Sync>() {}",
          "561:     _assert::<VMExternRefActivationsTable>();",
          "562:     _assert::<VMExternRef>();",
          "563: }",
          "565: impl VMExternRefActivationsTable {",
          "566:     const CHUNK_SIZE: usize = 4096 / mem::size_of::<usize>();",
          "569:     pub fn new() -> Self {",
          "575:         let mut chunk: Box<[TableElem]> = Box::new([]);",
          "576:         let next = chunk.as_mut_ptr();",
          "577:         let end = unsafe { next.add(chunk.len()) };",
          "579:         VMExternRefActivationsTable {",
          "580:             alloc: VMExternRefTableAlloc {",
          "581:                 next: UnsafeCell::new(NonNull::new(next).unwrap()),",
          "582:                 end: NonNull::new(end).unwrap(),",
          "583:                 chunk,",
          "584:             },",
          "585:             over_approximated_stack_roots: HashSet::new(),",
          "586:             precise_stack_roots: HashSet::new(),",
          "587:             #[cfg(debug_assertions)]",
          "588:             gc_okay: true,",
          "589:         }",
          "590:     }",
          "592:     fn new_chunk(size: usize) -> Box<[UnsafeCell<Option<VMExternRef>>]> {",
          "593:         assert!(size >= Self::CHUNK_SIZE);",
          "594:         (0..size).map(|_| UnsafeCell::new(None)).collect()",
          "595:     }",
          "598:     #[inline]",
          "599:     pub fn bump_capacity_remaining(&self) -> usize {",
          "600:         let end = self.alloc.end.as_ptr() as usize;",
          "601:         let next = unsafe { *self.alloc.next.get() };",
          "602:         end - next.as_ptr() as usize",
          "603:     }",
          "614:     #[inline]",
          "615:     pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {",
          "616:         unsafe {",
          "617:             let next = *self.alloc.next.get();",
          "618:             if next == self.alloc.end {",
          "619:                 return Err(externref);",
          "620:             }",
          "622:             debug_assert!(",
          "623:                 (*next.as_ref().get()).is_none(),",
          "624:                 \"slots >= the `next` bump finger are always `None`\"",
          "625:             );",
          "626:             ptr::write(next.as_ptr(), UnsafeCell::new(Some(externref)));",
          "628:             let next = NonNull::new_unchecked(next.as_ptr().add(1));",
          "629:             debug_assert!(next <= self.alloc.end);",
          "632:             Ok(())",
          "633:         }",
          "634:     }",
          "642:     #[inline]",
          "643:     pub unsafe fn insert_with_gc(",
          "644:         &mut self,",
          "645:         limits: *const VMRuntimeLimits,",
          "646:         externref: VMExternRef,",
          "647:         module_info_lookup: &dyn ModuleInfoLookup,",
          "648:     ) {",
          "649:         #[cfg(debug_assertions)]",
          "650:         assert!(self.gc_okay);",
          "652:         if let Err(externref) = self.try_insert(externref) {",
          "653:             self.gc_and_insert_slow(limits, externref, module_info_lookup);",
          "654:         }",
          "655:     }",
          "657:     #[inline(never)]",
          "658:     unsafe fn gc_and_insert_slow(",
          "659:         &mut self,",
          "660:         limits: *const VMRuntimeLimits,",
          "661:         externref: VMExternRef,",
          "662:         module_info_lookup: &dyn ModuleInfoLookup,",
          "663:     ) {",
          "664:         gc(limits, module_info_lookup, self);",
          "669:         self.over_approximated_stack_roots",
          "670:             .insert(VMExternRefWithTraits(externref));",
          "671:     }",
          "674:     #[inline]",
          "675:     pub fn insert_without_gc(&mut self, externref: VMExternRef) {",
          "676:         if let Err(externref) = self.try_insert(externref) {",
          "677:             self.insert_slow_without_gc(externref);",
          "678:         }",
          "679:     }",
          "681:     #[inline(never)]",
          "682:     fn insert_slow_without_gc(&mut self, externref: VMExternRef) {",
          "683:         self.over_approximated_stack_roots",
          "684:             .insert(VMExternRefWithTraits(externref));",
          "685:     }",
          "687:     fn num_filled_in_bump_chunk(&self) -> usize {",
          "688:         let next = unsafe { *self.alloc.next.get() };",
          "689:         let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);",
          "690:         let slots_unused = bytes_unused / mem::size_of::<TableElem>();",
          "691:         self.alloc.chunk.len().saturating_sub(slots_unused)",
          "692:     }",
          "694:     fn elements(&self, mut f: impl FnMut(&VMExternRef)) {",
          "695:         for elem in self.over_approximated_stack_roots.iter() {",
          "696:             f(&elem.0);",
          "697:         }",
          "701:         let num_filled = self.num_filled_in_bump_chunk();",
          "702:         for slot in self.alloc.chunk.iter().take(num_filled) {",
          "703:             if let Some(elem) = unsafe { &*slot.get() } {",
          "704:                 f(elem);",
          "705:             }",
          "706:         }",
          "707:     }",
          "709:     fn insert_precise_stack_root(",
          "710:         precise_stack_roots: &mut HashSet<VMExternRefWithTraits>,",
          "711:         root: NonNull<VMExternData>,",
          "712:     ) {",
          "713:         let root = unsafe { VMExternRef::clone_from_raw(root.as_ptr().cast()).unwrap() };",
          "714:         log::trace!(\"Found externref on stack: {:p}\", root);",
          "715:         precise_stack_roots.insert(VMExternRefWithTraits(root));",
          "716:     }",
          "720:     fn sweep(&mut self) {",
          "721:         log::trace!(\"begin GC sweep\");",
          "724:         let num_filled = self.num_filled_in_bump_chunk();",
          "725:         unsafe {",
          "727:         }",
          "728:         for slot in self.alloc.chunk.iter().take(num_filled) {",
          "729:             unsafe {",
          "731:             }",
          "732:         }",
          "733:         debug_assert!(",
          "734:             self.alloc",
          "735:                 .chunk",
          "736:                 .iter()",
          "737:                 .all(|slot| unsafe { (*slot.get()).as_ref().is_none() }),",
          "738:             \"after sweeping the bump chunk, all slots should be `None`\"",
          "739:         );",
          "743:         if self.alloc.chunk.is_empty() {",
          "744:             self.alloc.chunk = Self::new_chunk(Self::CHUNK_SIZE);",
          "745:             self.alloc.end =",
          "746:                 NonNull::new(unsafe { self.alloc.chunk.as_mut_ptr().add(self.alloc.chunk.len()) })",
          "747:                     .unwrap();",
          "748:         }",
          "751:         unsafe {",
          "752:             let next = self.alloc.chunk.as_mut_ptr();",
          "753:             debug_assert!(!next.is_null());",
          "755:         }",
          "759:         mem::swap(",
          "760:             &mut self.precise_stack_roots,",
          "761:             &mut self.over_approximated_stack_roots,",
          "762:         );",
          "770:         self.precise_stack_roots.clear();",
          "772:         log::trace!(\"end GC sweep\");",
          "773:     }",
          "780:     #[inline]",
          "781:     pub fn set_gc_okay(&mut self, okay: bool) -> bool {",
          "782:         #[cfg(debug_assertions)]",
          "783:         {",
          "784:             return std::mem::replace(&mut self.gc_okay, okay);",
          "785:         }",
          "786:         #[cfg(not(debug_assertions))]",
          "787:         {",
          "788:             let _ = okay;",
          "789:             return true;",
          "790:         }",
          "791:     }",
          "792: }",
          "794: #[derive(Debug, Default)]",
          "795: struct DebugOnly<T> {",
          "796:     inner: T,",
          "797: }",
          "799: impl<T> std::ops::Deref for DebugOnly<T> {",
          "800:     type Target = T;",
          "802:     fn deref(&self) -> &T {",
          "803:         if cfg!(debug_assertions) {",
          "804:             &self.inner",
          "805:         } else {",
          "806:             panic!(",
          "807:                 \"only deref `DebugOnly` when `cfg(debug_assertions)` or \\",
          "808:                  inside a `debug_assert!(..)`\"",
          "809:             )",
          "810:         }",
          "811:     }",
          "812: }",
          "814: impl<T> std::ops::DerefMut for DebugOnly<T> {",
          "815:     fn deref_mut(&mut self) -> &mut T {",
          "816:         if cfg!(debug_assertions) {",
          "817:             &mut self.inner",
          "818:         } else {",
          "819:             panic!(",
          "820:                 \"only deref `DebugOnly` when `cfg(debug_assertions)` or \\",
          "821:                  inside a `debug_assert!(..)`\"",
          "822:             )",
          "823:         }",
          "824:     }",
          "825: }",
          "838: pub unsafe fn gc(",
          "839:     limits: *const VMRuntimeLimits,",
          "840:     module_info_lookup: &dyn ModuleInfoLookup,",
          "841:     externref_activations_table: &mut VMExternRefActivationsTable,",
          "842: ) {",
          "843:     log::debug!(\"start GC\");",
          "845:     #[cfg(debug_assertions)]",
          "846:     assert!(externref_activations_table.gc_okay);",
          "848:     debug_assert!({",
          "854:         externref_activations_table.precise_stack_roots.is_empty()",
          "855:     });",
          "872:     let mut activations_table_set: DebugOnly<HashSet<_>> = Default::default();",
          "873:     if cfg!(debug_assertions) {",
          "874:         externref_activations_table.elements(|elem| {",
          "875:             activations_table_set.insert(elem.as_raw() as *mut VMExternData);",
          "876:         });",
          "877:     }",
          "879:     log::trace!(\"begin GC trace\");",
          "880:     Backtrace::trace(limits, |frame| {",
          "881:         let pc = frame.pc();",
          "882:         debug_assert!(pc != 0, \"we should always get a valid PC for Wasm frames\");",
          "884:         let fp = frame.fp();",
          "885:         debug_assert!(",
          "886:             fp != 0,",
          "887:             \"we should always get a valid frame pointer for Wasm frames\"",
          "888:         );",
          "890:         let module_info = module_info_lookup",
          "891:             .lookup(pc)",
          "892:             .expect(\"should have module info for Wasm frame\");",
          "894:         let stack_map = match module_info.lookup_stack_map(pc) {",
          "895:             Some(sm) => sm,",
          "896:             None => {",
          "897:                 log::trace!(\"No stack map for this Wasm frame\");",
          "898:                 return std::ops::ControlFlow::Continue(());",
          "899:             }",
          "900:         };",
          "901:         log::trace!(",
          "902:             \"We have a stack map that maps {} words in this Wasm frame\",",
          "903:             stack_map.mapped_words()",
          "904:         );",
          "906:         let sp = fp - stack_map.mapped_words() as usize * mem::size_of::<usize>();",
          "908:         for i in 0..(stack_map.mapped_words() as usize) {",
          "913:             let stack_slot = sp + i * mem::size_of::<usize>();",
          "915:             if !stack_map.get_bit(i) {",
          "916:                 log::trace!(",
          "917:                     \"Stack slot @ {:p} does not contain externrefs\",",
          "918:                     stack_slot as *const (),",
          "919:                 );",
          "920:                 continue;",
          "921:             }",
          "923:             let stack_slot = stack_slot as *const *mut VMExternData;",
          "924:             let r = std::ptr::read(stack_slot);",
          "925:             log::trace!(\"Stack slot @ {:p} = {:p}\", stack_slot, r);",
          "927:             debug_assert!(",
          "928:                 r.is_null() || activations_table_set.contains(&r),",
          "929:                 \"every on-stack externref inside a Wasm frame should \\",
          "930:                  have an entry in the VMExternRefActivationsTable; \\",
          "931:                  {:?} is not in the table\",",
          "932:                 r",
          "933:             );",
          "935:             if let Some(r) = NonNull::new(r) {",
          "936:                 VMExternRefActivationsTable::insert_precise_stack_root(",
          "937:                     &mut externref_activations_table.precise_stack_roots,",
          "938:                     r,",
          "939:                 );",
          "940:             }",
          "941:         }",
          "943:         std::ops::ControlFlow::Continue(())",
          "944:     });",
          "945:     log::trace!(\"end GC trace\");",
          "947:     externref_activations_table.sweep();",
          "949:     log::debug!(\"end GC\");",
          "950: }",
          "952: #[cfg(test)]",
          "953: mod tests {",
          "954:     use super::*;",
          "956:     #[test]",
          "957:     fn extern_ref_is_pointer_sized_and_aligned() {",
          "958:         assert_eq!(mem::size_of::<VMExternRef>(), mem::size_of::<*mut ()>());",
          "959:         assert_eq!(mem::align_of::<VMExternRef>(), mem::align_of::<*mut ()>());",
          "960:         assert_eq!(",
          "961:             mem::size_of::<Option<VMExternRef>>(),",
          "962:             mem::size_of::<*mut ()>()",
          "963:         );",
          "964:         assert_eq!(",
          "965:             mem::align_of::<Option<VMExternRef>>(),",
          "966:             mem::align_of::<*mut ()>()",
          "967:         );",
          "968:     }",
          "970:     #[test]",
          "971:     fn ref_count_is_at_correct_offset() {",
          "972:         let s = \"hi\";",
          "973:         let s: &(dyn Any + Send + Sync) = &s as _;",
          "974:         let s: *const (dyn Any + Send + Sync) = s as _;",
          "975:         let s: *mut (dyn Any + Send + Sync) = s as _;",
          "977:         let extern_data = VMExternData {",
          "978:             ref_count: AtomicUsize::new(0),",
          "979:             value_ptr: NonNull::new(s).unwrap().into(),",
          "980:         };",
          "982:         let extern_data_ptr = &extern_data as *const _;",
          "983:         let ref_count_ptr = &extern_data.ref_count as *const _;",
          "985:         let actual_offset = (ref_count_ptr as usize) - (extern_data_ptr as usize);",
          "987:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "988:             ptr: 8,",
          "989:             num_imported_functions: 0,",
          "990:             num_imported_tables: 0,",
          "991:             num_imported_memories: 0,",
          "992:             num_imported_globals: 0,",
          "993:             num_defined_tables: 0,",
          "994:             num_defined_memories: 0,",
          "995:             num_owned_memories: 0,",
          "996:             num_defined_globals: 0,",
          "997:             num_escaped_funcs: 0,",
          "998:         });",
          "999:         assert_eq!(",
          "1000:             offsets.vm_extern_data_ref_count(),",
          "1001:             actual_offset.try_into().unwrap(),",
          "1002:         );",
          "1003:     }",
          "1005:     #[test]",
          "1006:     fn table_next_is_at_correct_offset() {",
          "1007:         let table = VMExternRefActivationsTable::new();",
          "1009:         let table_ptr = &table as *const _;",
          "1010:         let next_ptr = &table.alloc.next as *const _;",
          "1012:         let actual_offset = (next_ptr as usize) - (table_ptr as usize);",
          "1014:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "1015:             ptr: 8,",
          "1016:             num_imported_functions: 0,",
          "1017:             num_imported_tables: 0,",
          "1018:             num_imported_memories: 0,",
          "1019:             num_imported_globals: 0,",
          "1020:             num_defined_tables: 0,",
          "1021:             num_defined_memories: 0,",
          "1022:             num_owned_memories: 0,",
          "1023:             num_defined_globals: 0,",
          "1024:             num_escaped_funcs: 0,",
          "1025:         });",
          "1026:         assert_eq!(",
          "1027:             offsets.vm_extern_ref_activation_table_next() as usize,",
          "1028:             actual_offset",
          "1029:         );",
          "1030:     }",
          "1032:     #[test]",
          "1033:     fn table_end_is_at_correct_offset() {",
          "1034:         let table = VMExternRefActivationsTable::new();",
          "1036:         let table_ptr = &table as *const _;",
          "1037:         let end_ptr = &table.alloc.end as *const _;",
          "1039:         let actual_offset = (end_ptr as usize) - (table_ptr as usize);",
          "1041:         let offsets = wasmtime_environ::VMOffsets::from(wasmtime_environ::VMOffsetsFields {",
          "1042:             ptr: 8,",
          "1043:             num_imported_functions: 0,",
          "1044:             num_imported_tables: 0,",
          "1045:             num_imported_memories: 0,",
          "1046:             num_imported_globals: 0,",
          "1047:             num_defined_tables: 0,",
          "1048:             num_defined_memories: 0,",
          "1049:             num_owned_memories: 0,",
          "1050:             num_defined_globals: 0,",
          "1051:             num_escaped_funcs: 0,",
          "1052:         });",
          "1053:         assert_eq!(",
          "1054:             offsets.vm_extern_ref_activation_table_end() as usize,",
          "1055:             actual_offset",
          "1056:         );",
          "1057:     }",
          "1058: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/externref/no_gc.rs||crates/runtime/src/externref/no_gc.rs": [
          "File: crates/runtime/src/externref/no_gc.rs -> crates/runtime/src/externref/no_gc.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #![allow(missing_docs)]",
          "8: use crate::{ModuleInfoLookup, VMRuntimeLimits};",
          "9: use std::any::Any;",
          "10: use std::cmp;",
          "11: use std::hash::Hasher;",
          "12: use std::ops::Deref;",
          "14: #[derive(Clone)]",
          "15: enum Uninhabited {}",
          "17: #[derive(Clone)]",
          "18: pub struct VMExternRef(Uninhabited);",
          "20: impl std::fmt::Pointer for VMExternRef {",
          "21:     fn fmt(&self, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "22:         match self.0 {}",
          "23:     }",
          "24: }",
          "26: impl Drop for VMExternRef {",
          "27:     fn drop(&mut self) {",
          "28:         match self.0 {}",
          "29:     }",
          "30: }",
          "32: impl VMExternRef {",
          "34:     pub fn assert_unreachable<T>(&self) -> T {",
          "35:         match self.0 {}",
          "36:     }",
          "38:     pub fn as_raw(&self) -> *mut u8 {",
          "39:         match self.0 {}",
          "40:     }",
          "42:     pub unsafe fn into_raw(self) -> *mut u8 {",
          "43:         match self.0 {}",
          "44:     }",
          "46:     pub unsafe fn from_raw(ptr: *mut u8) -> Option<Self> {",
          "47:         assert!(ptr.is_null());",
          "48:         None",
          "49:     }",
          "51:     pub unsafe fn clone_from_raw(ptr: *mut u8) -> Option<Self> {",
          "52:         assert!(ptr.is_null());",
          "53:         None",
          "54:     }",
          "56:     pub fn strong_count(&self) -> usize {",
          "57:         match self.0 {}",
          "58:     }",
          "60:     pub fn eq(a: &Self, _b: &Self) -> bool {",
          "61:         match a.0 {}",
          "62:     }",
          "64:     pub fn hash<H>(externref: &Self, _hasher: &mut H)",
          "65:     where",
          "66:         H: Hasher,",
          "67:     {",
          "68:         match externref.0 {}",
          "69:     }",
          "71:     pub fn cmp(a: &Self, _b: &Self) -> cmp::Ordering {",
          "72:         match a.0 {}",
          "73:     }",
          "74: }",
          "76: impl Deref for VMExternRef {",
          "77:     type Target = dyn Any;",
          "79:     fn deref(&self) -> &dyn Any {",
          "80:         match self.0 {}",
          "81:     }",
          "82: }",
          "84: pub struct VMExternRefActivationsTable {",
          "85:     _priv: (),",
          "86: }",
          "88: impl VMExternRefActivationsTable {",
          "89:     pub fn new() -> Self {",
          "90:         Self { _priv: () }",
          "91:     }",
          "93:     pub fn bump_capacity_remaining(&self) -> usize {",
          "94:         usize::MAX",
          "95:     }",
          "97:     pub fn try_insert(&mut self, externref: VMExternRef) -> Result<(), VMExternRef> {",
          "98:         match externref.0 {}",
          "99:     }",
          "101:     pub unsafe fn insert_with_gc(",
          "102:         &mut self,",
          "103:         _limits: *const VMRuntimeLimits,",
          "104:         externref: VMExternRef,",
          "105:         _module_info_lookup: &dyn ModuleInfoLookup,",
          "106:     ) {",
          "107:         match externref.0 {}",
          "108:     }",
          "110:     pub fn insert_without_gc(&mut self, externref: VMExternRef) {",
          "111:         match externref.0 {}",
          "112:     }",
          "114:     pub fn set_gc_okay(&mut self, _okay: bool) -> bool {",
          "115:         true",
          "116:     }",
          "117: }",
          "119: pub unsafe fn gc(",
          "120:     _limits: *const VMRuntimeLimits,",
          "121:     _module_info_lookup: &dyn ModuleInfoLookup,",
          "122:     _externref_activations_table: &mut VMExternRefActivationsTable,",
          "123: ) {",
          "125: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1286:                 WasmValType::Ref(WasmRefType {",
          "1287:                     heap_type: WasmHeapType::Extern,",
          "1288:                     ..",
          "1290:                 _ => continue,",
          "1291:             }",
          "1295:         }",
          "1296:     }",
          "1297: }",
          "",
          "[Removed Lines]",
          "1289:                 }) => {}",
          "1292:             unsafe {",
          "1293:                 drop((*self.global_ptr(idx)).as_externref_mut().take());",
          "1294:             }",
          "",
          "[Added Lines]",
          "1291:                 }) => unsafe {",
          "1292:                     drop((*self.global_ptr(idx)).as_externref_mut().take());",
          "1293:                 },",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: use anyhow::bail;",
          "63: use anyhow::Result;",
          "64: use cfg_if::cfg_if;",
          "67: use std::time::{Duration, Instant};",
          "71: #[cfg(feature = \"wmemcheck\")]",
          "72: use wasmtime_wmemcheck::AccessError::{",
          "73:     DoubleMalloc, InvalidFree, InvalidRead, InvalidWrite, OutOfBounds,",
          "",
          "[Removed Lines]",
          "65: use std::mem;",
          "66: use std::ptr::{self, NonNull};",
          "68: use wasmtime_environ::{",
          "69:     DataIndex, ElemIndex, FuncIndex, GlobalIndex, MemoryIndex, TableIndex, Trap, Unsigned,",
          "70: };",
          "",
          "[Added Lines]",
          "66: use wasmtime_environ::{DataIndex, ElemIndex, FuncIndex, MemoryIndex, TableIndex, Trap, Unsigned};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82: pub mod trampolines {",
          "83:     use crate::arch::wasm_to_libcall_trampoline;",
          "84:     use crate::{Instance, TrapReason, VMContext};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81:     #![allow(unused_doc_comments, unused_attributes)]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:                 extern \"C\" {",
          "100:                     #[allow(missing_docs)]",
          "101:                     #[allow(improper_ctypes)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:                 $( #[$attr] )*",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106:                     ) $(-> libcall!(@ty $result))?;",
          "107:                 }",
          "109:                 wasm_to_libcall_trampoline!($name ; [<impl_ $name>]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:                 $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "121:                 #[cfg_attr(target_arch = \"s390x\", wasmtime_versioned_export_macros::versioned_export)]",
          "122:                 unsafe extern \"C\" fn [<impl_ $name>](",
          "123:                     vmctx: *mut VMContext,",
          "124:                     $( $pname : libcall!(@ty $param), )*",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:                 $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "140:                 #[allow(non_upper_case_globals)]",
          "141:                 #[used]",
          "142:                 static [<impl_ $name _ref>]: unsafe extern \"C\" fn(",
          "144:                     $( $pname : libcall!(@ty $param), )*",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:                 $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "221:     init_value: *mut u8,",
          "222: ) -> Result<u32> {",
          "223:     let table_index = TableIndex::from_u32(table_index);",
          "224:     let element = match instance.table_element_type(table_index) {",
          "225:         TableElementType::Func => (init_value as *mut VMFuncRef).into(),",
          "234:     };",
          "235:     Ok(match instance.table_grow(table_index, delta, element)? {",
          "236:         Some(r) => r,",
          "237:         None => (-1_i32).unsigned(),",
          "",
          "[Removed Lines]",
          "226:         TableElementType::Extern => {",
          "227:             let init_value = if init_value.is_null() {",
          "228:                 None",
          "229:             } else {",
          "230:                 Some(VMExternRef::clone_from_raw(init_value))",
          "231:             };",
          "232:             init_value.into()",
          "233:         }",
          "",
          "[Added Lines]",
          "231:         TableElementType::Extern => VMExternRef::clone_from_raw(init_value).into(),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "239: }",
          "241: use table_grow as table_grow_func_ref;",
          "242: use table_grow as table_grow_externref;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242: #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "258:             let val = val as *mut VMFuncRef;",
          "259:             table.fill(dst, val.into(), len)",
          "260:         }",
          "261:         TableElementType::Extern => {",
          "267:             table.fill(dst, val.into(), len)",
          "268:         }",
          "269:     }",
          "270: }",
          "272: use table_fill as table_fill_func_ref;",
          "273: use table_fill as table_fill_externref;",
          "",
          "[Removed Lines]",
          "262:             let val = if val.is_null() {",
          "263:                 None",
          "264:             } else {",
          "265:                 Some(VMExternRef::clone_from_raw(val))",
          "266:             };",
          "",
          "[Added Lines]",
          "264:             let val = VMExternRef::clone_from_raw(val);",
          "272: #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "380: }",
          "383: unsafe fn drop_externref(_instance: &mut Instance, externref: *mut u8) {",
          "384:     let externref = externref as *mut crate::externref::VMExternData;",
          "386:     crate::externref::VMExternData::drop_and_dealloc(externref);",
          "387: }",
          "391: unsafe fn activations_table_insert_with_gc(instance: &mut Instance, externref: *mut u8) {",
          "393:     let limits = *instance.runtime_limits();",
          "394:     let (activations_table, module_info_lookup) = (*instance.store()).externref_activations_table();",
          "",
          "[Removed Lines]",
          "385:     let externref = NonNull::new(externref).unwrap().into();",
          "392:     let externref = VMExternRef::clone_from_raw(externref);",
          "",
          "[Added Lines]",
          "383: #[cfg(feature = \"gc\")]",
          "386:     let externref = std::ptr::NonNull::new(externref).unwrap().into();",
          "392: #[cfg(feature = \"gc\")]",
          "394:     let externref = VMExternRef::clone_from_raw(externref).unwrap();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "406: }",
          "409: unsafe fn externref_global_get(instance: &mut Instance, index: u32) -> *mut u8 {",
          "411:     let limits = *instance.runtime_limits();",
          "412:     let global = instance.defined_or_imported_global_ptr(index);",
          "413:     match (*global).as_externref().clone() {",
          "415:         Some(externref) => {",
          "416:             let raw = externref.as_raw();",
          "417:             let (activations_table, module_info_lookup) =",
          "",
          "[Removed Lines]",
          "410:     let index = GlobalIndex::from_u32(index);",
          "414:         None => ptr::null_mut(),",
          "",
          "[Added Lines]",
          "411: #[cfg(feature = \"gc\")]",
          "413:     let index = wasmtime_environ::GlobalIndex::from_u32(index);",
          "417:         None => std::ptr::null_mut(),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "423: }",
          "426: unsafe fn externref_global_set(instance: &mut Instance, index: u32, externref: *mut u8) {",
          "434:     let global = instance.defined_or_imported_global_ptr(index);",
          "441:     drop(old);",
          "442: }",
          "",
          "[Removed Lines]",
          "427:     let externref = if externref.is_null() {",
          "428:         None",
          "429:     } else {",
          "430:         Some(VMExternRef::clone_from_raw(externref))",
          "431:     };",
          "433:     let index = GlobalIndex::from_u32(index);",
          "440:     let old = mem::replace((*global).as_externref_mut(), externref);",
          "",
          "[Added Lines]",
          "429: #[cfg(feature = \"gc\")]",
          "431:     let externref = VMExternRef::clone_from_raw(externref);",
          "433:     let index = wasmtime_environ::GlobalIndex::from_u32(index);",
          "440:     let old = std::mem::replace((*global).as_externref_mut(), externref);",
          "",
          "---------------"
        ],
        "crates/runtime/src/table.rs||crates/runtime/src/table.rs": [
          "File: crates/runtime/src/table.rs -> crates/runtime/src/table.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: use crate::vmcontext::{VMFuncRef, VMTableDefinition};",
          "7: use anyhow::{bail, format_err, Error, Result};",
          "8: use sptr::Strict;",
          "9: use std::ops::Range;",
          "",
          "[Removed Lines]",
          "6: use crate::{SendSyncPtr, Store, VMExternRef};",
          "",
          "[Added Lines]",
          "5: #![cfg_attr(feature = \"gc\", allow(irrefutable_let_patterns))]",
          "7: use crate::externref::VMExternRef;",
          "9: use crate::{SendSyncPtr, Store};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:             }",
          "58:             (TableElementType::Extern, None) => Self::ExternRef(None),",
          "59:             (TableElementType::Extern, Some(ptr)) => {",
          "61:             }",
          "62:         }",
          "63:     }",
          "",
          "[Removed Lines]",
          "60:                 Self::ExternRef(Some(VMExternRef::from_raw(ptr.as_ptr())))",
          "",
          "[Added Lines]",
          "65:                 Self::ExternRef(VMExternRef::from_raw(ptr.as_ptr()))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:             TableElementType::Func => TableElement::from_table_value(ty, ptr),",
          "75:             TableElementType::Extern => {",
          "77:             }",
          "78:         }",
          "79:     }",
          "",
          "[Removed Lines]",
          "76:                 Self::ExternRef(ptr.map(|p| VMExternRef::clone_from_raw(p.as_ptr())))",
          "",
          "[Added Lines]",
          "81:                 Self::ExternRef(ptr.and_then(|p| VMExternRef::clone_from_raw(p.as_ptr())))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "112:     pub(crate) unsafe fn into_ref_asserting_initialized(self) -> *mut u8 {",
          "113:         match self {",
          "114:             Self::FuncRef(e) => e.cast(),",
          "116:             Self::UninitFunc => panic!(\"Uninitialized table element value outside of table slot\"),",
          "117:         }",
          "118:     }",
          "",
          "[Removed Lines]",
          "115:             Self::ExternRef(e) => e.map_or(ptr::null_mut(), |e| e.into_raw()),",
          "",
          "[Added Lines]",
          "121:             Self::ExternRef(e) => e.map_or(ptr::null_mut(), |e| e.into_raw()),",
          "",
          "---------------"
        ],
        "crates/runtime/src/vmcontext.rs||crates/runtime/src/vmcontext.rs": [
          "File: crates/runtime/src/vmcontext.rs -> crates/runtime/src/vmcontext.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "390: #[cfg(test)]",
          "391: mod test_vmglobal_definition {",
          "392:     use super::VMGlobalDefinition;",
          "394:     use std::mem::{align_of, size_of};",
          "395:     use wasmtime_environ::{Module, PtrSize, VMOffsets};",
          "",
          "[Removed Lines]",
          "393:     use crate::externref::VMExternRef;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "421:     }",
          "423:     #[test]",
          "424:     fn check_vmglobal_can_contain_externref() {",
          "425:         assert!(size_of::<VMExternRef>() <= size_of::<VMGlobalDefinition>());",
          "426:     }",
          "427: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "423:     #[cfg(feature = \"gc\")]",
          "425:         use crate::externref::VMExternRef;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "536:     pub unsafe fn as_externref(&self) -> &Option<VMExternRef> {",
          "538:     }",
          "541:     pub unsafe fn as_externref_mut(&mut self) -> &mut Option<VMExternRef> {",
          "543:             .storage",
          "544:             .as_mut()",
          "545:             .as_mut_ptr()",
          "547:     }",
          "",
          "[Removed Lines]",
          "537:         &*(self.storage.as_ref().as_ptr().cast::<Option<VMExternRef>>())",
          "542:         &mut *(self",
          "546:             .cast::<Option<VMExternRef>>())",
          "",
          "[Added Lines]",
          "538:         let ret = &*(self.storage.as_ref().as_ptr().cast::<Option<VMExternRef>>());",
          "539:         assert!(cfg!(feature = \"gc\") || ret.is_none());",
          "540:         ret",
          "545:         let ret = &mut *(self",
          "549:             .cast::<Option<VMExternRef>>());",
          "550:         assert!(cfg!(feature = \"gc\") || ret.is_none());",
          "551:         ret",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "707:         #[repr(C)]",
          "708:         pub struct VMBuiltinFunctionsArray {",
          "709:             $(",
          "710:                 $name: unsafe extern \"C\" fn(",
          "711:                     $(define_builtin_array!(@ty $param)),*",
          "712:                 ) $( -> define_builtin_array!(@ty $result))?,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "715:                 $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "714:         }",
          "716:         impl VMBuiltinFunctionsArray {",
          "717:             pub const INIT: VMBuiltinFunctionsArray = VMBuiltinFunctionsArray {",
          "719:             };",
          "720:         }",
          "721:     };",
          "",
          "[Removed Lines]",
          "718:                 $($name: crate::libcalls::trampolines::$name,)*",
          "",
          "[Added Lines]",
          "723:             #[allow(unused_doc_comments)]",
          "725:                 $(",
          "726:                     $( #[ $attr ] )*",
          "727:                     $name: crate::libcalls::trampolines::$name,",
          "728:                 )*",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1098:     #[inline]",
          "1099:     pub fn externref(i: *mut c_void) -> ValRaw {",
          "1100:         ValRaw {",
          "1101:             externref: Strict::map_addr(i, |i| i.to_le()),",
          "1102:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1110:         assert!(cfg!(feature = \"gc\") || i.is_null());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1154:     #[inline]",
          "1155:     pub fn get_externref(&self) -> *mut c_void {",
          "1157:     }",
          "1158: }",
          "",
          "[Removed Lines]",
          "1156:         unsafe { Strict::map_addr(self.externref, |i| usize::from_le(i)) }",
          "",
          "[Added Lines]",
          "1167:         let ptr = unsafe { Strict::map_addr(self.externref, |i| usize::from_le(i)) };",
          "1168:         assert!(cfg!(feature = \"gc\") || ptr.is_null());",
          "1169:         ptr",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs": [
          "File: crates/wasmtime/src/config.rs -> crates/wasmtime/src/config.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "252:             ret.cranelift_opt_level(OptLevel::Speed);",
          "253:         }",
          "255:         ret.wasm_reference_types(true);",
          "256:         ret.wasm_multi_value(true);",
          "257:         ret.wasm_bulk_memory(true);",
          "258:         ret.wasm_simd(true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "255:         #[cfg(feature = \"gc\")]",
          "257:         #[cfg(not(feature = \"gc\"))]",
          "258:         {",
          "259:             ret.features.reference_types = false;",
          "260:             ret.features.function_references = false;",
          "261:             ret.features.gc = false;",
          "262:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "732:     pub fn wasm_reference_types(&mut self, enable: bool) -> &mut Self {",
          "733:         self.features.reference_types = enable;",
          "734:         self",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "740:     #[cfg(feature = \"gc\")]",
          "741:     #[cfg_attr(docsrs, doc(cfg(feature = \"gc\")))]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "750:     pub fn wasm_function_references(&mut self, enable: bool) -> &mut Self {",
          "751:         self.features.function_references = enable;",
          "752:         self",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "760:     #[cfg(feature = \"gc\")]",
          "761:     #[cfg_attr(docsrs, doc(cfg(feature = \"gc\")))]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "770:     pub fn wasm_gc(&mut self, enable: bool) -> &mut Self {",
          "771:         self.features.gc = enable;",
          "772:         self",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782:     #[cfg(feature = \"gc\")]",
          "783:     #[cfg_attr(docsrs, doc(cfg(feature = \"gc\")))]",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/engine/serialization.rs||crates/wasmtime/src/engine/serialization.rs": [
          "File: crates/wasmtime/src/engine/serialization.rs -> crates/wasmtime/src/engine/serialization.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: use crate::{Engine, ModuleVersionStrategy, Precompiled};",
          "26: use object::write::{Object, StandardSegment};",
          "27: use object::{File, FileFlags, Object as _, ObjectSection, SectionKind};",
          "28: use serde_derive::{Deserialize, Serialize};",
          "",
          "[Removed Lines]",
          "25: use anyhow::{anyhow, bail, Context, Result};",
          "",
          "[Added Lines]",
          "25: use anyhow::{anyhow, bail, ensure, Context, Result};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "406:         Ok(())",
          "407:     }",
          "409:     fn check_features(&mut self, other: &wasmparser::WasmFeatures) -> Result<()> {",
          "410:         let WasmFeatures {",
          "411:             reference_types,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "409:     fn check_cfg_bool(",
          "410:         cfg: bool,",
          "411:         cfg_str: &str,",
          "412:         found: bool,",
          "413:         expected: bool,",
          "414:         feature: &str,",
          "415:     ) -> Result<()> {",
          "416:         if cfg {",
          "417:             Self::check_bool(found, expected, feature)",
          "418:         } else {",
          "419:             assert!(!expected);",
          "420:             ensure!(",
          "421:                 !found,",
          "422:                 \"Module was compiled with {feature} but support in the host \\",
          "423:                  was disabled at compile time because the `{cfg_str}` Cargo \\",
          "424:                  feature was not enabled\",",
          "425:             );",
          "426:             Ok(())",
          "427:         }",
          "428:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "424:             gc,",
          "425:         } = self.features;",
          "428:             reference_types,",
          "429:             other.reference_types,",
          "430:             \"WebAssembly reference types support\",",
          "431:         )?;",
          "432:         Self::check_bool(",
          "433:             multi_value,",
          "434:             other.multi_value,",
          "",
          "[Removed Lines]",
          "427:         Self::check_bool(",
          "",
          "[Added Lines]",
          "448:         Self::check_cfg_bool(",
          "449:             cfg!(feature = \"gc\"),",
          "450:             \"gc\",",
          "455:         Self::check_cfg_bool(",
          "456:             cfg!(feature = \"gc\"),",
          "457:             \"gc\",",
          "458:             function_references,",
          "459:             other.function_references,",
          "460:             \"WebAssembly function-references support\",",
          "461:         )?;",
          "462:         Self::check_cfg_bool(",
          "463:             cfg!(feature = \"gc\"),",
          "464:             \"gc\",",
          "465:             gc,",
          "466:             other.gc,",
          "467:             \"WebAssembly garbage collection support\",",
          "468:         )?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "472:             other.relaxed_simd,",
          "473:             \"WebAssembly relaxed-simd support\",",
          "474:         )?;",
          "482:         Ok(())",
          "483:     }",
          "",
          "[Removed Lines]",
          "475:         Self::check_bool(",
          "476:             function_references,",
          "477:             other.function_references,",
          "478:             \"WebAssembly function-references support\",",
          "479:         )?;",
          "480:         Self::check_bool(gc, other.gc, \"WebAssembly garbage collection support\")?;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime.rs||crates/wasmtime/src/runtime.rs": [
          "File: crates/wasmtime/src/runtime.rs -> crates/wasmtime/src/runtime.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: pub(crate) mod trap;",
          "22: pub(crate) mod type_registry;",
          "23: pub(crate) mod types;",
          "24: pub(crate) mod v128;",
          "25: pub(crate) mod values;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: pub(crate) mod uninhabited;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66: pub use v128::V128;",
          "67: pub use values::*;",
          "69: #[cfg(feature = \"profiling\")]",
          "70: pub use profiling::GuestProfiler;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: pub(crate) use uninhabited::*;",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/externals/global.rs||crates/wasmtime/src/runtime/externals/global.rs": [
          "File: crates/wasmtime/src/runtime/externals/global.rs -> crates/wasmtime/src/runtime/externals/global.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:                 ValType::V128 => Val::V128((*definition.as_u128()).into()),",
          "111:                 ValType::Ref(ref_ty) => {",
          "112:                     let reference = match ref_ty.heap_type() {",
          "113:                         HeapType::Extern => Ref::Extern(",
          "114:                             definition",
          "115:                                 .as_externref()",
          "116:                                 .clone()",
          "118:                         ),",
          "123:                     };",
          "124:                     debug_assert!(",
          "125:                         ref_ty.is_nullable() || !reference.is_null(),",
          "",
          "[Removed Lines]",
          "117:                                 .map(|inner| ExternRef { inner }),",
          "119:                         HeapType::Func | HeapType::Concrete(_) => {",
          "120:                             Ref::Func(Func::from_raw(store, definition.as_func_ref().cast()))",
          "121:                         }",
          "122:                         HeapType::NoFunc => Ref::Func(None),",
          "",
          "[Added Lines]",
          "113:                         HeapType::Func | HeapType::Concrete(_) => {",
          "114:                             Ref::Func(Func::from_raw(store, definition.as_func_ref().cast()))",
          "115:                         }",
          "117:                         HeapType::NoFunc => Ref::Func(None),",
          "123:                                 .map(|inner| ExternRef::from_vm_extern_ref(inner)),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:                 Val::ExternRef(e) => {",
          "169:                     drop(old);",
          "170:                 }",
          "171:             }",
          "",
          "[Removed Lines]",
          "168:                     let old = mem::replace(definition.as_externref_mut(), e.map(|e| e.inner));",
          "",
          "[Added Lines]",
          "170:                     let old = mem::replace(",
          "171:                         definition.as_externref_mut(),",
          "172:                         e.map(|e| e.into_vm_extern_ref()),",
          "173:                     );",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/externals/table.rs||crates/wasmtime/src/runtime/externals/table.rs": [
          "File: crates/wasmtime/src/runtime/externals/table.rs -> crates/wasmtime/src/runtime/externals/table.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:                     let func = Func::from_vm_func_ref(store, f);",
          "155:                     Some(func.into())",
          "156:                 }",
          "157:                 runtime::TableElement::ExternRef(None) => Some(Ref::Extern(None)),",
          "158:                 runtime::TableElement::ExternRef(Some(x)) => {",
          "160:                     Some(x.into())",
          "161:                 }",
          "165:             }",
          "166:         }",
          "167:     }",
          "",
          "[Removed Lines]",
          "159:                     let x = ExternRef { inner: x };",
          "162:                 runtime::TableElement::UninitFunc => {",
          "163:                     unreachable!(\"lazy init above should have converted UninitFunc\")",
          "164:                 }",
          "",
          "[Added Lines]",
          "158:                 runtime::TableElement::UninitFunc => {",
          "159:                     unreachable!(\"lazy init above should have converted UninitFunc\")",
          "160:                 }",
          "164:                 #[cfg_attr(not(feature = \"gc\"), allow(unreachable_code, unused_variables))]",
          "166:                     let x = ExternRef::from_vm_extern_ref(x);",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/func.rs||crates/wasmtime/src/runtime/func.rs": [
          "File: crates/wasmtime/src/runtime/func.rs -> crates/wasmtime/src/runtime/func.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::store::{StoreData, StoreOpaque, Stored};",
          "2: use crate::type_registry::RegisteredType;",
          "3: use crate::{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::runtime::Uninhabited;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:     _inner: Uninhabited,",
          "79: }",
          "84: impl NoFunc {",
          "86:     #[inline]",
          "",
          "[Removed Lines]",
          "81: #[derive(Copy, Clone, Debug, PartialEq, Eq)]",
          "82: enum Uninhabited {}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1159:         let values_vec_size = params.len().max(ty.results().len());",
          "1173:         {",
          "1175:         }",
          "",
          "[Removed Lines]",
          "1168:         if ty.as_wasm_func_type().externref_params_count()",
          "1169:             > store",
          "1170:                 .0",
          "1171:                 .externref_activations_table()",
          "1172:                 .bump_capacity_remaining()",
          "1174:             store.gc();",
          "",
          "[Added Lines]",
          "1159:         #[cfg(feature = \"gc\")]",
          "1168:             if ty.as_wasm_func_type().externref_params_count()",
          "1169:                 > store",
          "1170:                     .0",
          "1171:                     .externref_activations_table()",
          "1172:                     .bump_capacity_remaining()",
          "1173:             {",
          "1174:                 store.gc();",
          "1175:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1307:         let (params, results) = val_vec.split_at_mut(nparams);",
          "1308:         func(caller.sub_caller(), params, results)?;",
          "1317:         {",
          "1319:         }",
          "",
          "[Removed Lines]",
          "1311:         if ty.as_wasm_func_type().externref_returns_count()",
          "1312:             > caller",
          "1313:                 .store",
          "1314:                 .0",
          "1315:                 .externref_activations_table()",
          "1316:                 .bump_capacity_remaining()",
          "1318:             caller.store.gc();",
          "",
          "[Added Lines]",
          "1311:         #[cfg(feature = \"gc\")]",
          "1314:             if ty.as_wasm_func_type().externref_returns_count()",
          "1315:                 > caller",
          "1316:                     .store",
          "1317:                     .0",
          "1318:                     .externref_activations_table()",
          "1319:                     .bump_capacity_remaining()",
          "1320:             {",
          "1321:                 caller.store.gc();",
          "1322:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2026:     pub fn gc(&mut self) {",
          "2027:         self.store.gc()",
          "2028:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2030:     #[cfg(feature = \"gc\")]",
          "2031:     #[cfg_attr(docsrs, doc(cfg(feature = \"gc\")))]",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/func/typed.rs||crates/wasmtime/src/runtime/func/typed.rs": [
          "File: crates/wasmtime/src/runtime/func/typed.rs -> crates/wasmtime/src/runtime/func/typed.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:             Self::debug_typecheck(store.0, func.as_ref().type_index);",
          "157:         }",
          "165:         {",
          "167:         }",
          "",
          "[Removed Lines]",
          "160:         if params.externrefs_count()",
          "161:             > store",
          "162:                 .0",
          "163:                 .externref_activations_table()",
          "164:                 .bump_capacity_remaining()",
          "166:             store.gc();",
          "",
          "[Added Lines]",
          "159:         #[cfg(feature = \"gc\")]",
          "162:             if params.externrefs_count()",
          "163:                 > store",
          "164:                     .0",
          "165:                     .externref_activations_table()",
          "166:                     .bump_capacity_remaining()",
          "167:             {",
          "168:                 store.gc();",
          "169:             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "423:     f64/u64/get_f64 => F64",
          "424: }",
          "426: unsafe impl WasmTy for ExternRef {",
          "427:     type Abi = NonNull<u8>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "429: #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "461:     #[inline]",
          "462:     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {",
          "464:         unsafe {",
          "",
          "[Removed Lines]",
          "463:         let abi = self.inner.as_raw();",
          "",
          "[Added Lines]",
          "467:         let inner = self.into_vm_extern_ref();",
          "468:         let abi = inner.as_raw();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "493:             let mut store = AutoAssertNoGc::new(store);",
          "496:             debug_assert!(!abi.is_null());",
          "497:             NonNull::new_unchecked(abi)",
          "",
          "[Removed Lines]",
          "494:             store.insert_vmexternref_without_gc(self.inner);",
          "",
          "[Added Lines]",
          "499:             store.insert_vmexternref_without_gc(inner);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "501:     #[inline]",
          "502:     unsafe fn from_abi(abi: Self::Abi, _store: &mut StoreOpaque) -> Self {",
          "506:     }",
          "507: }",
          "509: unsafe impl WasmTy for Option<ExternRef> {",
          "510:     type Abi = *mut u8;",
          "",
          "[Removed Lines]",
          "503:         ExternRef {",
          "504:             inner: wasmtime_runtime::VMExternRef::clone_from_raw(abi.as_ptr()),",
          "505:         }",
          "",
          "[Added Lines]",
          "508:         let inner = wasmtime_runtime::VMExternRef::clone_from_raw(abi.as_ptr()).unwrap();",
          "509:         ExternRef::from_vm_extern_ref(inner)",
          "513: #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "551:     #[inline]",
          "552:     unsafe fn from_abi(abi: Self::Abi, _store: &mut StoreOpaque) -> Self {",
          "560:     }",
          "561: }",
          "",
          "[Removed Lines]",
          "553:         if abi.is_null() {",
          "554:             None",
          "555:         } else {",
          "556:             Some(ExternRef {",
          "557:                 inner: wasmtime_runtime::VMExternRef::clone_from_raw(abi),",
          "558:             })",
          "559:         }",
          "",
          "[Added Lines]",
          "558:         let inner = wasmtime_runtime::VMExternRef::clone_from_raw(abi)?;",
          "559:         Some(ExternRef::from_vm_extern_ref(inner))",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/module/registry.rs||crates/wasmtime/src/runtime/module/registry.rs": [
          "File: crates/wasmtime/src/runtime/module/registry.rs -> crates/wasmtime/src/runtime/module/registry.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     ptr::NonNull,",
          "12:     sync::{Arc, RwLock},",
          "13: };",
          "",
          "[Removed Lines]",
          "14: use wasmtime_runtime::{ModuleInfo, VMSharedTypeIndex, VMWasmCallFunction};",
          "",
          "[Added Lines]",
          "14: use wasmtime_runtime::{VMSharedTypeIndex, VMWasmCallFunction};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:     }",
          "71:         let (module, _) = self.module_and_offset(pc)?;",
          "72:         Some(module.module_info())",
          "73:     }",
          "",
          "[Removed Lines]",
          "70:     pub fn lookup_module_info(&self, pc: usize) -> Option<&dyn ModuleInfo> {",
          "",
          "[Added Lines]",
          "70:     pub fn lookup_module_info(&self, pc: usize) -> Option<&dyn wasmtime_runtime::ModuleInfo> {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/ref.rs||crates/wasmtime/src/runtime/ref.rs": [
          "File: crates/wasmtime/src/runtime/ref.rs -> crates/wasmtime/src/runtime/ref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #![allow(missing_docs)]",
          "3: use crate::AsContextMut;",
          "4: use std::any::Any;",
          "5: use std::ffi::c_void;",
          "6: use wasmtime_runtime::VMExternRef;",
          "9: #[derive(Clone, Debug)]",
          "10: #[repr(transparent)]",
          "11: pub struct ExternRef {",
          "12:     pub(crate) inner: VMExternRef,",
          "13: }",
          "15: impl ExternRef {",
          "17:     pub fn new<T>(value: T) -> ExternRef",
          "18:     where",
          "19:         T: 'static + Any + Send + Sync,",
          "20:     {",
          "21:         let inner = VMExternRef::new(value);",
          "22:         ExternRef { inner }",
          "23:     }",
          "26:     pub fn data(&self) -> &dyn Any {",
          "27:         &*self.inner",
          "28:     }",
          "34:     pub fn strong_count(&self) -> usize {",
          "35:         self.inner.strong_count()",
          "36:     }",
          "42:     pub fn ptr_eq(&self, other: &ExternRef) -> bool {",
          "43:         VMExternRef::eq(&self.inner, &other.inner)",
          "44:     }",
          "74:     pub unsafe fn from_raw(raw: *mut c_void) -> Option<ExternRef> {",
          "75:         let raw = raw.cast::<u8>();",
          "76:         if raw.is_null() {",
          "77:             None",
          "78:         } else {",
          "79:             Some(ExternRef {",
          "80:                 inner: VMExternRef::clone_from_raw(raw),",
          "81:             })",
          "82:         }",
          "83:     }",
          "95:     pub unsafe fn to_raw(&self, mut store: impl AsContextMut) -> *mut c_void {",
          "96:         let externref_ptr = self.inner.as_raw();",
          "97:         store",
          "98:             .as_context_mut()",
          "99:             .0",
          "100:             .insert_vmexternref_without_gc(self.inner.clone());",
          "101:         externref_ptr.cast()",
          "102:     }",
          "103: }",
          "105: impl std::fmt::Pointer for ExternRef {",
          "106:     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "107:         std::fmt::Pointer::fmt(&self.inner, f)",
          "108:     }",
          "109: }",
          "",
          "[Added Lines]",
          "1: #[cfg(feature = \"gc\")]",
          "2: mod gc_ref;",
          "3: #[cfg(feature = \"gc\")]",
          "4: pub use gc_ref::*;",
          "6: #[cfg(not(feature = \"gc\"))]",
          "7: mod no_gc_ref;",
          "8: #[cfg(not(feature = \"gc\"))]",
          "9: pub use no_gc_ref::*;",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/ref/gc_ref.rs||crates/wasmtime/src/runtime/ref/gc_ref.rs": [
          "File: crates/wasmtime/src/runtime/ref/gc_ref.rs -> crates/wasmtime/src/runtime/ref/gc_ref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::AsContextMut;",
          "2: use std::any::Any;",
          "3: use std::ffi::c_void;",
          "4: use wasmtime_runtime::VMExternRef;",
          "7: #[derive(Clone, Debug)]",
          "8: #[repr(transparent)]",
          "9: pub struct ExternRef {",
          "10:     inner: VMExternRef,",
          "11: }",
          "13: impl ExternRef {",
          "15:     pub fn new<T>(value: T) -> ExternRef",
          "16:     where",
          "17:         T: 'static + Any + Send + Sync,",
          "18:     {",
          "19:         let inner = VMExternRef::new(value);",
          "20:         ExternRef { inner }",
          "21:     }",
          "23:     pub(crate) fn from_vm_extern_ref(inner: VMExternRef) -> Self {",
          "24:         ExternRef { inner }",
          "25:     }",
          "27:     pub(crate) fn into_vm_extern_ref(self) -> VMExternRef {",
          "28:         self.inner",
          "29:     }",
          "32:     pub fn data(&self) -> &dyn Any {",
          "33:         &*self.inner",
          "34:     }",
          "40:     pub fn strong_count(&self) -> usize {",
          "41:         self.inner.strong_count()",
          "42:     }",
          "48:     pub fn ptr_eq(&self, other: &ExternRef) -> bool {",
          "49:         VMExternRef::eq(&self.inner, &other.inner)",
          "50:     }",
          "80:     pub unsafe fn from_raw(raw: *mut c_void) -> Option<ExternRef> {",
          "81:         let raw = raw.cast::<u8>();",
          "82:         let inner = VMExternRef::clone_from_raw(raw)?;",
          "83:         Some(ExternRef { inner })",
          "84:     }",
          "96:     pub unsafe fn to_raw(&self, mut store: impl AsContextMut) -> *mut c_void {",
          "97:         let externref_ptr = self.inner.as_raw();",
          "98:         store",
          "99:             .as_context_mut()",
          "100:             .0",
          "101:             .insert_vmexternref_without_gc(self.inner.clone());",
          "102:         externref_ptr.cast()",
          "103:     }",
          "104: }",
          "106: impl std::fmt::Pointer for ExternRef {",
          "107:     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "108:         std::fmt::Pointer::fmt(&self.inner, f)",
          "109:     }",
          "110: }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/ref/no_gc_ref.rs||crates/wasmtime/src/runtime/ref/no_gc_ref.rs": [
          "File: crates/wasmtime/src/runtime/ref/no_gc_ref.rs -> crates/wasmtime/src/runtime/ref/no_gc_ref.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #![allow(missing_docs)]",
          "9: use crate::runtime::Uninhabited;",
          "10: use crate::AsContextMut;",
          "11: use std::any::Any;",
          "12: use std::ffi::c_void;",
          "13: use wasmtime_runtime::VMExternRef;",
          "19: #[derive(Clone, Debug)]",
          "20: pub struct ExternRef {",
          "21:     _inner: Uninhabited,",
          "22: }",
          "24: impl ExternRef {",
          "25:     pub(crate) fn from_vm_extern_ref(inner: VMExternRef) -> Self {",
          "26:         inner.assert_unreachable()",
          "27:     }",
          "29:     pub(crate) fn into_vm_extern_ref(self) -> VMExternRef {",
          "30:         match self._inner {}",
          "31:     }",
          "33:     pub fn data(&self) -> &dyn Any {",
          "34:         match self._inner {}",
          "35:     }",
          "37:     pub fn strong_count(&self) -> usize {",
          "38:         match self._inner {}",
          "39:     }",
          "41:     pub fn ptr_eq(&self, _other: &ExternRef) -> bool {",
          "42:         match self._inner {}",
          "43:     }",
          "45:     pub unsafe fn from_raw(raw: *mut c_void) -> Option<ExternRef> {",
          "46:         assert!(raw.is_null());",
          "47:         None",
          "48:     }",
          "50:     pub unsafe fn to_raw(&self, mut store: impl AsContextMut) -> *mut c_void {",
          "51:         let _ = &mut store;",
          "52:         match self._inner {}",
          "53:     }",
          "54: }",
          "56: impl std::fmt::Pointer for ExternRef {",
          "57:     fn fmt(&self, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
          "58:         match self._inner {}",
          "59:     }",
          "60: }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/store.rs||crates/wasmtime/src/runtime/store.rs": [
          "File: crates/wasmtime/src/runtime/store.rs -> crates/wasmtime/src/runtime/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "97: use std::task::{Context, Poll};",
          "98: use wasmtime_runtime::mpk::{self, ProtectionKey, ProtectionMask};",
          "99: use wasmtime_runtime::{",
          "103: };",
          "105: mod context;",
          "",
          "[Removed Lines]",
          "100:     ExportGlobal, InstanceAllocationRequest, InstanceAllocator, InstanceHandle, ModuleInfo,",
          "101:     OnDemandInstanceAllocator, SignalHandler, StoreBox, StorePtr, VMContext, VMExternRef,",
          "102:     VMExternRefActivationsTable, VMFuncRef, VMRuntimeLimits, WasmFault,",
          "",
          "[Added Lines]",
          "100:     ExportGlobal, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,",
          "101:     OnDemandInstanceAllocator, SignalHandler, StoreBox, StorePtr, VMContext, VMFuncRef,",
          "102:     VMRuntimeLimits, WasmFault,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "307:     #[cfg(feature = \"component-model\")]",
          "308:     num_component_instances: usize,",
          "309:     signal_handler: Option<Box<SignalHandler<'static>>>,",
          "311:     modules: ModuleRegistry,",
          "312:     func_refs: FuncRefs,",
          "313:     host_globals: Vec<StoreBox<VMHostGlobalContext>>,",
          "",
          "[Removed Lines]",
          "310:     externref_activations_table: VMExternRefActivationsTable,",
          "",
          "[Added Lines]",
          "310:     externref_activations_table: wasmtime_runtime::VMExternRefActivationsTable,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "392: where",
          "393:     T: std::ops::DerefMut<Target = StoreOpaque>,",
          "394: {",
          "396:     prev_okay: bool,",
          "397:     store: T,",
          "398: }",
          "",
          "[Removed Lines]",
          "395:     #[cfg(debug_assertions)]",
          "",
          "[Added Lines]",
          "395:     #[cfg(all(debug_assertions, feature = \"gc\"))]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "404:     #[inline]",
          "405:     pub fn new(mut store: T) -> Self {",
          "406:         let _ = &mut store;",
          "408:         {",
          "409:             let prev_okay = store.externref_activations_table.set_gc_okay(false);",
          "410:             return AutoAssertNoGc { store, prev_okay };",
          "411:         }",
          "413:         {",
          "414:             return AutoAssertNoGc { store };",
          "415:         }",
          "",
          "[Removed Lines]",
          "407:         #[cfg(debug_assertions)]",
          "412:         #[cfg(not(debug_assertions))]",
          "",
          "[Added Lines]",
          "407:         #[cfg(all(debug_assertions, feature = \"gc\"))]",
          "412:         #[cfg(not(all(debug_assertions, feature = \"gc\")))]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "441:     T: std::ops::DerefMut<Target = StoreOpaque>,",
          "442: {",
          "443:     fn drop(&mut self) {",
          "445:         {",
          "446:             self.store",
          "447:                 .externref_activations_table",
          "",
          "[Removed Lines]",
          "444:         #[cfg(debug_assertions)]",
          "",
          "[Added Lines]",
          "444:         #[cfg(all(debug_assertions, feature = \"gc\"))]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "497:                 #[cfg(feature = \"component-model\")]",
          "498:                 num_component_instances: 0,",
          "499:                 signal_handler: None,",
          "501:                 modules: ModuleRegistry::default(),",
          "502:                 func_refs: FuncRefs::default(),",
          "503:                 host_globals: Vec::new(),",
          "",
          "[Removed Lines]",
          "500:                 externref_activations_table: VMExternRefActivationsTable::new(),",
          "",
          "[Added Lines]",
          "500:                 externref_activations_table: wasmtime_runtime::VMExternRefActivationsTable::new(),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "797:     pub fn gc(&mut self) {",
          "798:         self.inner.gc()",
          "799:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:     #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1039:     pub fn gc(&mut self) {",
          "1040:         self.0.gc()",
          "1041:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1044:     #[cfg(feature = \"gc\")]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1374:     }",
          "1376:     #[inline]",
          "1378:         &mut self.externref_activations_table",
          "1379:     }",
          "",
          "[Removed Lines]",
          "1377:     pub fn externref_activations_table(&mut self) -> &mut VMExternRefActivationsTable {",
          "",
          "[Added Lines]",
          "1383:     pub fn externref_activations_table(",
          "1384:         &mut self,",
          "1385:     ) -> &mut wasmtime_runtime::VMExternRefActivationsTable {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1523:         &self.runtime_limits as *const VMRuntimeLimits as *mut VMRuntimeLimits",
          "1524:     }",
          "1527:         self.externref_activations_table.insert_without_gc(r);",
          "1528:     }",
          "",
          "[Removed Lines]",
          "1526:     pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {",
          "",
          "[Added Lines]",
          "1534:     pub unsafe fn insert_vmexternref_without_gc(&mut self, r: wasmtime_runtime::VMExternRef) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2042:     fn externref_activations_table(",
          "2043:         &mut self,",
          "2044:     ) -> (",
          "2046:         &dyn wasmtime_runtime::ModuleInfoLookup,",
          "2047:     ) {",
          "2048:         let inner = &mut self.inner;",
          "",
          "[Removed Lines]",
          "2045:         &mut VMExternRefActivationsTable,",
          "",
          "[Added Lines]",
          "2053:         &mut wasmtime_runtime::VMExternRefActivationsTable,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2299: }",
          "2301: impl wasmtime_runtime::ModuleInfoLookup for ModuleRegistry {",
          "2303:         self.lookup_module_info(pc)",
          "2304:     }",
          "2305: }",
          "",
          "[Removed Lines]",
          "2302:     fn lookup(&self, pc: usize) -> Option<&dyn ModuleInfo> {",
          "",
          "[Added Lines]",
          "2310:     fn lookup(&self, pc: usize) -> Option<&dyn wasmtime_runtime::ModuleInfo> {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/trampoline/global.rs||crates/wasmtime/src/runtime/trampoline/global.rs": [
          "File: crates/wasmtime/src/runtime/trampoline/global.rs -> crates/wasmtime/src/runtime/trampoline/global.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:             }",
          "22:             crate::ValType::Ref(r) => match r.heap_type() {",
          "24:                 HeapType::Func | HeapType::Concrete(_) | HeapType::NoFunc => {",
          "26:                 }",
          "27:             },",
          "28:         }",
          "29:     }",
          "",
          "[Removed Lines]",
          "23:                 HeapType::Extern => unsafe { ptr::drop_in_place(self.global.as_externref_mut()) },",
          "",
          "[Added Lines]",
          "26:                 HeapType::Extern => unsafe { ptr::drop_in_place(self.global.as_externref_mut()) },",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/uninhabited.rs||crates/wasmtime/src/runtime/uninhabited.rs": [
          "File: crates/wasmtime/src/runtime/uninhabited.rs -> crates/wasmtime/src/runtime/uninhabited.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #[derive(Copy, Clone, Debug, PartialEq, Eq)]",
          "5: pub(crate) enum Uninhabited {}",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/runtime/values.rs||crates/wasmtime/src/runtime/values.rs": [
          "File: crates/wasmtime/src/runtime/values.rs -> crates/wasmtime/src/runtime/values.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:             Val::V128(b) => ValRaw::v128(b.as_u128()),",
          "179:             Val::ExternRef(e) => {",
          "180:                 let externref = match e {",
          "182:                     None => ptr::null_mut(),",
          "183:                 };",
          "184:                 ValRaw::externref(externref)",
          "185:             }",
          "",
          "[Removed Lines]",
          "181:                     Some(e) => e.to_raw(store),",
          "",
          "[Added Lines]",
          "182:                     Some(e) => e.to_raw(store),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:             ValType::V128 => Val::V128(raw.get_v128().into()),",
          "210:             ValType::Ref(ref_ty) => {",
          "211:                 let ref_ = match ref_ty.heap_type() {",
          "213:                     HeapType::Func | HeapType::Concrete(_) => {",
          "214:                         Func::from_raw(store, raw.get_funcref()).into()",
          "215:                     }",
          "216:                     HeapType::NoFunc => Ref::Func(None),",
          "217:                 };",
          "218:                 assert!(",
          "219:                     ref_ty.is_nullable() || !ref_.is_null(),",
          "",
          "[Removed Lines]",
          "212:                     HeapType::Extern => ExternRef::from_raw(raw.get_externref()).into(),",
          "",
          "[Added Lines]",
          "216:                     HeapType::Extern => ExternRef::from_raw(raw.get_externref()).into(),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "689:                 );",
          "690:                 Ok(TableElement::FuncRef(f.vm_func_ref(store).as_ptr()))",
          "691:             }",
          "692:             (Ref::Extern(e), HeapType::Extern) => match e {",
          "693:                 None => {",
          "694:                     assert!(ty.is_nullable());",
          "695:                     Ok(TableElement::ExternRef(None))",
          "696:                 }",
          "698:             },",
          "699:             _ => unreachable!(\"checked that the value matches the type above\"),",
          "700:         }",
          "701:     }",
          "",
          "[Removed Lines]",
          "697:                 Some(e) => Ok(TableElement::ExternRef(Some(e.inner))),",
          "",
          "[Added Lines]",
          "698:                 Some(e) => Ok(TableElement::ExternRef(Some(e.into_vm_extern_ref()))),",
          "",
          "---------------"
        ],
        "winch/codegen/src/codegen/builtin.rs||winch/codegen/src/codegen/builtin.rs": [
          "File: winch/codegen/src/codegen/builtin.rs -> winch/codegen/src/codegen/builtin.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "94:             nearest_f64: Option<BuiltinFunction>,",
          "95:             $(",
          "96:                 $name: Option<BuiltinFunction>,",
          "97:             )*",
          "98:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96:                 $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:         impl BuiltinFunctions {",
          "103:             pub fn new<P: PtrSize>(vmoffsets: &VMOffsets<P>, call_conv: CallingConvention) -> Self {",
          "104:                 let size = vmoffsets.ptr.size();",
          "105:                 Self {",
          "106:                     ptr_size: size,",
          "107:                     call_conv,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:                 #[allow(unused_doc_comments)]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:                     nearest_f32: None,",
          "117:                     nearest_f64: None,",
          "118:                     $(",
          "119:                         $name: None,",
          "120:                     )*",
          "121:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:                         $( #[ $attr ] )*",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "246:             }",
          "248:             $(",
          "249:                 pub(crate) fn $name<A: ABI, P: PtrSize>(&mut self) -> BuiltinFunction {",
          "250:                     if self.$name.is_none() {",
          "251:                         let params = vec![ $(self.$param() ),* ];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252:                 $( #[ $attr ] )*",
          "",
          "---------------"
        ],
        "winch/filetests/filetests/x64/table/fill.wat||winch/filetests/filetests/x64/table/fill.wat": [
          "File: winch/filetests/filetests/x64/table/fill.wat -> winch/filetests/filetests/x64/table/fill.wat",
          "--- Hunk 1 ---",
          "[Context before]",
          "118: ;;   c1:  4883e0fe              and rax, 0xfffffffffffffffe",
          "119: ;;        4889442404            mov qword ptr [rsp + 4], rax",
          "120: ;;        4d8b5e38              mov r11, qword ptr [r14 + 0x38]",
          "122: ;;        448b5c2414            mov r11d, dword ptr [rsp + 0x14]",
          "123: ;;        4883ec04              sub rsp, 4",
          "124: ;;        44891c24              mov dword ptr [rsp], r11d",
          "",
          "[Removed Lines]",
          "121: ;;        498b4368              mov rax, qword ptr [r11 + 0x68]",
          "",
          "[Added Lines]",
          "121: ;;        498b4358              mov rax, qword ptr [r11 + 0x58]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7fdc6163681e4ceb287a06582b338e66863ef734",
      "candidate_info": {
        "commit_hash": "7fdc6163681e4ceb287a06582b338e66863ef734",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/7fdc6163681e4ceb287a06582b338e66863ef734",
        "files": [
          "crates/environ/src/module.rs",
          "crates/jit/src/instantiate.rs",
          "crates/runtime/src/instance/allocator.rs"
        ],
        "message": "Remove the `Paged` memory initialization variant (#4046)\n\n* Remove the `Paged` memory initialization variant\n\nThis commit simplifies the `MemoryInitialization` enum by removing the\n`Paged` variant. The `Paged` variant was originally added for uffd, but\nthat support has now been removed in #4040. This is no longer necessary\nbut is still used as an intermediate step of becoming a `Static` variant\nof initialized memory (which copy-on-write uses). As a result this\ncommit largely modifies the static initialization of memory steps and\nfolds the two methods together.\n\n* Apply suggestions from code review\n\nCo-authored-by: Peter Huene <peter@huene.dev>\n\nCo-authored-by: Peter Huene <peter@huene.dev>",
        "before_after_code_files": [
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ],
          "candidate": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "145:     Segmented(Vec<MemoryInitializer>),",
          "",
          "[Removed Lines]",
          "164:     Paged {",
          "175:         map: PrimaryMap<MemoryIndex, Vec<StaticMemoryInitializer>>,",
          "176:     },",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212: }",
          "214: impl ModuleTranslation<'_> {",
          "",
          "[Removed Lines]",
          "221:     pub fn try_paged_init(&mut self) {",
          "224:         if !self.module.memory_initialization.is_segmented() {",
          "225:             return;",
          "226:         }",
          "232:         let mut page_contents = PrimaryMap::with_capacity(self.module.memory_plans.len());",
          "233:         for _ in 0..self.module.memory_plans.len() {",
          "234:             page_contents.push(BTreeMap::new());",
          "235:         }",
          "240:         let mut data = self.data.iter();",
          "241:         let ok = self.module.memory_initialization.init_memory(",
          "242:             InitMemory::CompileTime(&self.module),",
          "243:             &mut |memory, init| {",
          "244:                 let data = data.next().unwrap();",
          "245:                 assert_eq!(data.len(), init.data.len());",
          "249:                 if self.module.defined_memory_index(memory).is_none() {",
          "250:                     return false;",
          "251:                 };",
          "252:                 let page_size = u64::from(WASM_PAGE_SIZE);",
          "253:                 let contents = &mut page_contents[memory];",
          "254:                 let mut page_index = init.offset / page_size;",
          "255:                 let mut page_offset = (init.offset % page_size) as usize;",
          "256:                 let mut data = &data[..];",
          "258:                 while !data.is_empty() {",
          "261:                     let page = contents",
          "262:                         .entry(page_index)",
          "263:                         .or_insert_with(|| vec![0; page_size as usize]);",
          "264:                     let page = &mut page[page_offset..];",
          "266:                     let len = std::cmp::min(data.len(), page.len());",
          "267:                     page[..len].copy_from_slice(&data[..len]);",
          "269:                     page_index += 1;",
          "270:                     page_offset = 0;",
          "271:                     data = &data[len..];",
          "272:                 }",
          "274:                 true",
          "275:             },",
          "276:         );",
          "280:         if !ok {",
          "281:             return;",
          "282:         }",
          "295:         self.data.clear();",
          "296:         let mut map = PrimaryMap::with_capacity(page_contents.len());",
          "297:         let mut offset = 0;",
          "298:         for (memory, pages) in page_contents {",
          "299:             let mut page_offsets = Vec::with_capacity(pages.len());",
          "300:             for (page_index, page) in pages {",
          "303:                 if page.iter().all(|b| *b == 0) {",
          "304:                     continue;",
          "305:                 }",
          "306:                 let end = offset + (page.len() as u32);",
          "307:                 page_offsets.push(StaticMemoryInitializer {",
          "308:                     offset: page_index * u64::from(WASM_PAGE_SIZE),",
          "309:                     data: offset..end,",
          "310:                 });",
          "311:                 offset = end;",
          "312:                 self.data.push(page.into());",
          "313:             }",
          "314:             let index = map.push(page_offsets);",
          "315:             assert_eq!(index, memory);",
          "316:         }",
          "317:         self.module.memory_initialization = MemoryInitialization::Paged { map };",
          "318:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "349:     pub fn try_static_init(&mut self, page_size: u64, max_image_size_always_allowed: u64) {",
          "",
          "[Removed Lines]",
          "354:         self.try_paged_init();",
          "355:         let map = match &mut self.module.memory_initialization {",
          "356:             MemoryInitialization::Paged { map } => map,",
          "357:             _ => return,",
          "358:         };",
          "360:         let memory_init_size = |pages: &[StaticMemoryInitializer]| {",
          "361:             if pages.len() == 0 {",
          "362:                 return 0;",
          "363:             }",
          "364:             let first = &pages[0];",
          "365:             let last = &pages[pages.len() - 1];",
          "366:             last.offset - first.offset + (last.data.len() as u64)",
          "367:         };",
          "377:         let mut data = self.data.as_slice();",
          "378:         for (_memory_index, pages) in map.iter() {",
          "379:             let (memory_data, rest) = data.split_at(pages.len());",
          "380:             data = rest;",
          "386:             let data_size = memory_data.iter().map(|d| d.len()).sum::<usize>() as u64;",
          "387:             let memory_init_size = memory_init_size(pages);",
          "",
          "[Added Lines]",
          "217:         if !self.module.memory_initialization.is_segmented() {",
          "218:             return;",
          "219:         }",
          "224:         struct Memory {",
          "225:             data_size: u64,",
          "226:             min_addr: u64,",
          "227:             max_addr: u64,",
          "231:             segments: Vec<(usize, StaticMemoryInitializer)>,",
          "232:         }",
          "233:         let mut info = PrimaryMap::with_capacity(self.module.memory_plans.len());",
          "234:         for _ in 0..self.module.memory_plans.len() {",
          "235:             info.push(Memory {",
          "236:                 data_size: 0,",
          "237:                 min_addr: u64::MAX,",
          "238:                 max_addr: 0,",
          "239:                 segments: Vec::new(),",
          "240:             });",
          "241:         }",
          "242:         let mut idx = 0;",
          "243:         let ok = self.module.memory_initialization.init_memory(",
          "244:             InitMemory::CompileTime(&self.module),",
          "245:             &mut |memory, init| {",
          "250:                 if self.module.defined_memory_index(memory).is_none() {",
          "251:                     return false;",
          "252:                 };",
          "253:                 let info = &mut info[memory];",
          "254:                 let data_len = u64::from(init.data.end - init.data.start);",
          "255:                 info.data_size += data_len;",
          "256:                 info.min_addr = info.min_addr.min(init.offset);",
          "257:                 info.max_addr = info.max_addr.max(init.offset + data_len);",
          "258:                 info.segments.push((idx, init.clone()));",
          "259:                 idx += 1;",
          "260:                 true",
          "261:             },",
          "262:         );",
          "263:         if !ok {",
          "264:             return;",
          "265:         }",
          "269:         for info in info.values().filter(|i| i.data_size > 0) {",
          "270:             let image_size = info.max_addr - info.min_addr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "396:                 continue;",
          "397:             }",
          "403:                 continue;",
          "404:             }",
          "",
          "[Removed Lines]",
          "395:             if memory_init_size < data_size.saturating_mul(2) {",
          "402:             if memory_init_size < max_image_size_always_allowed {",
          "",
          "[Added Lines]",
          "278:             if image_size < info.data_size.saturating_mul(2) {",
          "285:             if image_size < max_image_size_always_allowed {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "409:             return;",
          "410:         }",
          "416:         let data = mem::replace(&mut self.data, Vec::new());",
          "430:             }",
          "449:                 Some(StaticMemoryInitializer {",
          "452:                 })",
          "453:             } else {",
          "454:                 None",
          "455:             };",
          "458:         }",
          "460:         self.data_align = Some(page_size);",
          "462:     }",
          "",
          "[Removed Lines]",
          "411:         assert!(data.is_empty());",
          "417:         let mut data = data.iter();",
          "418:         let mut image_map = PrimaryMap::with_capacity(map.len());",
          "419:         let mut offset = 0u32;",
          "420:         for (memory_index, pages) in map.iter() {",
          "423:             let capacity = usize::try_from(memory_init_size(pages)).unwrap();",
          "424:             let mut image = Vec::with_capacity(capacity);",
          "425:             for page in pages {",
          "426:                 let image_offset = usize::try_from(page.offset - pages[0].offset).unwrap();",
          "427:                 assert!(image.len() <= image_offset);",
          "428:                 image.resize(image_offset, 0u8);",
          "429:                 image.extend_from_slice(data.next().unwrap());",
          "431:             assert_eq!(image.len(), capacity);",
          "432:             assert_eq!(image.capacity(), capacity);",
          "436:             let init = if image.len() > 0 {",
          "437:                 let data_offset = offset;",
          "438:                 let len = u32::try_from(image.len()).unwrap();",
          "439:                 let data_offset_end = data_offset.checked_add(len).unwrap();",
          "440:                 offset += len;",
          "445:                 assert!(u64::from(data_offset) % page_size == 0);",
          "446:                 assert!(u64::from(len) % page_size == 0);",
          "447:                 self.data.push(image.into());",
          "450:                     offset: pages[0].offset,",
          "451:                     data: data_offset..data_offset_end,",
          "456:             let idx = image_map.push(init);",
          "457:             assert_eq!(idx, memory_index);",
          "459:         assert!(data.next().is_none());",
          "461:         self.module.memory_initialization = MemoryInitialization::Static { map: image_map };",
          "",
          "[Added Lines]",
          "299:         let mut map = PrimaryMap::with_capacity(info.len());",
          "300:         let mut module_data_size = 0u32;",
          "301:         for (memory, info) in info.iter() {",
          "304:             let extent = if info.segments.len() > 0 {",
          "305:                 (info.max_addr - info.min_addr) as usize",
          "306:             } else {",
          "307:                 0",
          "308:             };",
          "309:             let mut image = Vec::with_capacity(extent);",
          "310:             for (idx, init) in info.segments.iter() {",
          "311:                 let data = &data[*idx];",
          "312:                 assert_eq!(data.len(), init.data.len());",
          "313:                 let offset = usize::try_from(init.offset - info.min_addr).unwrap();",
          "314:                 if image.len() < offset {",
          "315:                     image.resize(offset, 0u8);",
          "316:                     image.extend_from_slice(data);",
          "317:                 } else {",
          "318:                     image.splice(",
          "319:                         offset..(offset + data.len()).min(image.len()),",
          "320:                         data.iter().copied(),",
          "321:                     );",
          "322:                 }",
          "324:             assert_eq!(image.len(), extent);",
          "325:             assert_eq!(image.capacity(), extent);",
          "326:             let mut offset = if info.segments.len() > 0 {",
          "327:                 info.min_addr",
          "328:             } else {",
          "329:                 0",
          "330:             };",
          "335:             if let Some(i) = image.iter().rposition(|i| *i != 0) {",
          "336:                 image.truncate(i + 1);",
          "337:             }",
          "340:             if let Some(i) = image.iter().position(|i| *i != 0) {",
          "341:                 offset += i as u64;",
          "342:                 image.drain(..i);",
          "343:             }",
          "344:             let mut len = u64::try_from(image.len()).unwrap();",
          "350:             if offset % page_size != 0 {",
          "351:                 let zero_padding = offset % page_size;",
          "352:                 self.data.push(vec![0; zero_padding as usize].into());",
          "353:                 offset -= zero_padding;",
          "354:                 len += zero_padding;",
          "355:             }",
          "356:             self.data.push(image.into());",
          "357:             if len % page_size != 0 {",
          "358:                 let zero_padding = page_size - (len % page_size);",
          "359:                 self.data.push(vec![0; zero_padding as usize].into());",
          "360:                 len += zero_padding;",
          "361:             }",
          "364:             assert!(offset % page_size == 0);",
          "365:             assert!(len % page_size == 0);",
          "374:             let len = u32::try_from(len).unwrap();",
          "375:             let init = if len > 0 {",
          "377:                     offset,",
          "378:                     data: module_data_size..module_data_size + len,",
          "383:             let idx = map.push(init);",
          "384:             assert_eq!(idx, memory);",
          "385:             module_data_size += len;",
          "388:         self.module.memory_initialization = MemoryInitialization::Static { map };",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "607:             MemoryInitialization::Segmented(list) => list,",
          "629:             MemoryInitialization::Static { map } => {",
          "630:                 for (index, init) in map {",
          "631:                     if let Some(init) = init {",
          "",
          "[Removed Lines]",
          "614:             MemoryInitialization::Paged { map } => {",
          "615:                 for (index, pages) in map {",
          "616:                     for init in pages {",
          "617:                         debug_assert_eq!(init.data.end - init.data.start, WASM_PAGE_SIZE);",
          "618:                         let result = write(index, init);",
          "619:                         if !result {",
          "620:                             return result;",
          "621:                         }",
          "622:                     }",
          "623:                 }",
          "624:                 return true;",
          "625:             }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs": [
          "File: crates/jit/src/instantiate.rs -> crates/jit/src/instantiate.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:         SectionKind::ReadOnlyData,",
          "180:     );",
          "181:     let mut total_data_len = 0;",
          "189:         total_data_len += data.len();",
          "190:     }",
          "191:     for data in passive_data.iter() {",
          "",
          "[Removed Lines]",
          "182:     for data in data {",
          "183:         let offset = obj.append_section_data(data_id, &data, data_align.unwrap_or(1));",
          "188:         assert_eq!(offset as usize, total_data_len);",
          "",
          "[Added Lines]",
          "182:     for (i, data) in data.iter().enumerate() {",
          "186:         let align = if i == 0 { data_align.unwrap_or(1) } else { 1 };",
          "187:         obj.append_section_data(data_id, data, align);",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "396:             check_memory_init_bounds(instance, initializers)?;",
          "397:         }",
          "400:     }",
          "402:     Ok(())",
          "",
          "[Removed Lines]",
          "399:         MemoryInitialization::Paged { .. } | MemoryInitialization::Static { .. } => {}",
          "",
          "[Added Lines]",
          "399:         MemoryInitialization::Static { .. } => {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "03715dda9d536cc8f81d4ed9d5d152139fcd2eb0",
      "candidate_info": {
        "commit_hash": "03715dda9d536cc8f81d4ed9d5d152139fcd2eb0",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/03715dda9d536cc8f81d4ed9d5d152139fcd2eb0",
        "files": [
          "crates/environ/src/vmoffsets.rs",
          "crates/jit/src/instantiate.rs",
          "crates/jit/src/profiling/jitdump_linux.rs",
          "crates/jit/src/profiling/vtune.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs",
          "crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/module/registry.rs",
          "crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/global.rs",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Tidy up some internals of instance allocation (#5346)\n\n* Simplify the `ModuleRuntimeInfo` trait slightly\n\nFold two functions into one as they're only called from one location\nanyway.\n\n* Remove ModuleRuntimeInfo::signature\n\nThis is redundant as the array mapping is already stored within the\n`VMContext` so that can be consulted rather than having a separate trait\nfunction for it. This required altering the `Global` creation slightly\nto work correctly in this situation.\n\n* Remove a now-dead constant\n\n* Shared `VMOffsets` across instances\n\nThis commit removes the computation of `VMOffsets` to being per-module\ninstead of per-instance. The `VMOffsets` structure is also quite large\nso this shaves off 112 bytes per instance which isn't a huge impact but\nshould help lower the cost of instantiating small modules.\n\n* Remove `InstanceAllocator::adjust_tunables`\n\nThis is no longer needed or necessary with the pooling allocator.\n\n* Fix compile warning\n\n* Fix a vtune warning\n\n* Fix pooling tests\n\n* Fix another test warning",
        "before_after_code_files": [
          "crates/environ/src/vmoffsets.rs||crates/environ/src/vmoffsets.rs",
          "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs",
          "crates/jit/src/profiling/jitdump_linux.rs||crates/jit/src/profiling/jitdump_linux.rs",
          "crates/jit/src/profiling/vtune.rs||crates/jit/src/profiling/vtune.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/module/registry.rs||crates/wasmtime/src/module/registry.rs",
          "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/global.rs||crates/wasmtime/src/trampoline/global.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/vmoffsets.rs||crates/environ/src/vmoffsets.rs": [
          "File: crates/environ/src/vmoffsets.rs -> crates/environ/src/vmoffsets.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: use std::convert::TryFrom;",
          "32: use wasmtime_types::OwnedMemoryIndex;",
          "39: #[cfg(target_pointer_width = \"32\")]",
          "40: fn cast_to_u32(sz: usize) -> u32 {",
          "41:     u32::try_from(sz).unwrap()",
          "",
          "[Removed Lines]",
          "37: pub const INTERRUPTED: usize = usize::max_value() - 32 * 1024;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs": [
          "File: crates/jit/src/instantiate.rs -> crates/jit/src/instantiate.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:     PrimaryMap, SignatureIndex, StackMapInformation, Tunables, WasmFunctionInfo,",
          "21: };",
          "22: use wasmtime_runtime::{",
          "25: };",
          "",
          "[Removed Lines]",
          "23:     CompiledModuleId, CompiledModuleIdAllocator, GdbJitImageRegistration, MmapVec, VMFunctionBody,",
          "24:     VMTrampoline,",
          "",
          "[Added Lines]",
          "23:     CompiledModuleId, CompiledModuleIdAllocator, GdbJitImageRegistration, MmapVec, VMTrampoline,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "482:         Arc::get_mut(&mut self.module)",
          "483:     }",
          "486:     #[inline]",
          "487:     pub fn finished_functions(",
          "488:         &self,",
          "498:     }",
          "",
          "[Removed Lines]",
          "489:     ) -> impl ExactSizeIterator<Item = (DefinedFuncIndex, *const [VMFunctionBody])> + '_ {",
          "490:         let text = self.text();",
          "491:         self.funcs.iter().map(move |(i, (_, loc))| {",
          "492:             let func = &text[loc.start as usize..][..loc.length as usize];",
          "493:             (",
          "494:                 i,",
          "495:                 std::ptr::slice_from_raw_parts(func.as_ptr().cast::<VMFunctionBody>(), func.len()),",
          "496:             )",
          "497:         })",
          "",
          "[Added Lines]",
          "489:     ) -> impl ExactSizeIterator<Item = (DefinedFuncIndex, &[u8])> + '_ {",
          "490:         self.funcs",
          "491:             .iter()",
          "492:             .map(move |(i, _)| (i, self.finished_function(i)))",
          "493:     }",
          "496:     #[inline]",
          "497:     pub fn finished_function(&self, index: DefinedFuncIndex) -> &[u8] {",
          "498:         let (_, loc) = &self.funcs[index];",
          "499:         &self.text()[loc.start as usize..][..loc.length as usize]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "523:         self.finished_functions()",
          "524:             .map(|(_, f)| f)",
          "525:             .zip(self.funcs.values().map(|f| &f.0.stack_maps[..]))",
          "",
          "[Removed Lines]",
          "520:     pub fn stack_maps(",
          "521:         &self,",
          "522:     ) -> impl Iterator<Item = (*const [VMFunctionBody], &[StackMapInformation])> {",
          "",
          "[Added Lines]",
          "522:     pub fn stack_maps(&self) -> impl Iterator<Item = (&[u8], &[StackMapInformation])> {",
          "",
          "---------------"
        ],
        "crates/jit/src/profiling/jitdump_linux.rs||crates/jit/src/profiling/jitdump_linux.rs": [
          "File: crates/jit/src/profiling/jitdump_linux.rs -> crates/jit/src/profiling/jitdump_linux.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:         let tid = pid; // ThreadId does appear to track underlying thread. Using PID.",
          "85:         for (idx, func) in module.finished_functions() {",
          "87:             if let Some(img) = &dbg_image {",
          "88:                 if let Err(err) = self.dump_from_debug_image(img, \"wasm\", addr, len, pid, tid) {",
          "89:                     println!(",
          "",
          "[Removed Lines]",
          "86:             let (addr, len) = unsafe { ((*func).as_ptr().cast::<u8>(), (*func).len()) };",
          "",
          "[Added Lines]",
          "86:             let addr = func.as_ptr();",
          "87:             let len = func.len();",
          "",
          "---------------"
        ],
        "crates/jit/src/profiling/vtune.rs||crates/jit/src/profiling/vtune.rs": [
          "File: crates/jit/src/profiling/vtune.rs -> crates/jit/src/profiling/vtune.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:             .unwrap_or_else(|| format!(\"wasm_module_{}\", global_module_id));",
          "95:         for (idx, func) in module.finished_functions() {",
          "97:             let method_name = super::debug_name(module, idx);",
          "98:             log::trace!(",
          "99:                 \"new function {:?}::{:?} @ {:?}\\n\",",
          "",
          "[Removed Lines]",
          "96:             let (addr, len) = unsafe { ((*func).as_ptr().cast::<u8>(), (*func).len()) };",
          "",
          "[Added Lines]",
          "96:             let addr = func.as_ptr();",
          "97:             let len = func.len();",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: };",
          "14: use crate::{",
          "15:     ExportFunction, ExportGlobal, ExportMemory, ExportTable, Imports, ModuleRuntimeInfo, Store,",
          "17: };",
          "18: use anyhow::Error;",
          "19: use memoffset::offset_of;",
          "",
          "[Removed Lines]",
          "16:     VMFunctionBody,",
          "",
          "[Added Lines]",
          "16:     VMFunctionBody, VMSharedSignatureIndex,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     runtime_info: Arc<dyn ModuleRuntimeInfo>,",
          "",
          "[Removed Lines]",
          "65:     offsets: VMOffsets<HostPtr>,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:     unsafe fn new_at(",
          "106:         ptr: *mut Instance,",
          "107:         alloc_size: usize,",
          "109:         req: InstanceAllocationRequest,",
          "110:         memories: PrimaryMap<DefinedMemoryIndex, Memory>,",
          "111:         tables: PrimaryMap<DefinedTableIndex, Table>,",
          "112:     ) {",
          "116:         let module = req.runtime_info.module();",
          "117:         let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());",
          "",
          "[Removed Lines]",
          "108:         offsets: VMOffsets<HostPtr>,",
          "114:         assert!(alloc_size >= Self::alloc_layout(&offsets).size());",
          "",
          "[Added Lines]",
          "110:         assert!(alloc_size >= Self::alloc_layout(req.runtime_info.offsets()).size());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "121:             ptr,",
          "122:             Instance {",
          "123:                 runtime_info: req.runtime_info.clone(),",
          "125:                 memories,",
          "126:                 tables,",
          "127:                 dropped_elements,",
          "",
          "[Removed Lines]",
          "124:                 offsets,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:             },",
          "134:         );",
          "137:     }",
          "",
          "[Removed Lines]",
          "136:         (*ptr).initialize_vmctx(module, req.store, req.imports);",
          "",
          "[Added Lines]",
          "131:         (*ptr).initialize_vmctx(module, req.runtime_info.offsets(), req.store, req.imports);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "148:         self.runtime_info.module()",
          "149:     }",
          "152:     fn imported_function(&self, index: FuncIndex) -> &VMFunctionImport {",
          "154:     }",
          "157:     fn imported_table(&self, index: TableIndex) -> &VMTableImport {",
          "159:     }",
          "162:     fn imported_memory(&self, index: MemoryIndex) -> &VMMemoryImport {",
          "164:     }",
          "167:     fn imported_global(&self, index: GlobalIndex) -> &VMGlobalImport {",
          "169:     }",
          "",
          "[Removed Lines]",
          "153:         unsafe { &*self.vmctx_plus_offset(self.offsets.vmctx_vmfunction_import(index)) }",
          "158:         unsafe { &*self.vmctx_plus_offset(self.offsets.vmctx_vmtable_import(index)) }",
          "163:         unsafe { &*self.vmctx_plus_offset(self.offsets.vmctx_vmmemory_import(index)) }",
          "168:         unsafe { &*self.vmctx_plus_offset(self.offsets.vmctx_vmglobal_import(index)) }",
          "",
          "[Added Lines]",
          "146:     fn offsets(&self) -> &VMOffsets<HostPtr> {",
          "147:         self.runtime_info.offsets()",
          "148:     }",
          "152:         unsafe { &*self.vmctx_plus_offset(self.offsets().vmctx_vmfunction_import(index)) }",
          "157:         unsafe { &*self.vmctx_plus_offset(self.offsets().vmctx_vmtable_import(index)) }",
          "162:         unsafe { &*self.vmctx_plus_offset(self.offsets().vmctx_vmmemory_import(index)) }",
          "167:         unsafe { &*self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_import(index)) }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "185:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "187:     }",
          "",
          "[Removed Lines]",
          "186:         unsafe { self.vmctx_plus_offset(self.offsets.vmctx_vmtable_definition(index)) }",
          "",
          "[Added Lines]",
          "185:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "223:     fn memory_ptr(&self, index: DefinedMemoryIndex) -> *mut VMMemoryDefinition {",
          "225:     }",
          "",
          "[Removed Lines]",
          "224:         unsafe { *self.vmctx_plus_offset(self.offsets.vmctx_vmmemory_pointer(index)) }",
          "",
          "[Added Lines]",
          "223:         unsafe { *self.vmctx_plus_offset(self.offsets().vmctx_vmmemory_pointer(index)) }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "233:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "235:     }",
          "",
          "[Removed Lines]",
          "234:         unsafe { self.vmctx_plus_offset(self.offsets.vmctx_vmglobal_definition(index)) }",
          "",
          "[Added Lines]",
          "233:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "253:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
          "255:     }",
          "258:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
          "260:     }",
          "263:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
          "265:     }",
          "",
          "[Removed Lines]",
          "254:         unsafe { self.vmctx_plus_offset(self.offsets.vmctx_runtime_limits()) }",
          "259:         unsafe { self.vmctx_plus_offset(self.offsets.vmctx_epoch_ptr()) }",
          "264:         unsafe { self.vmctx_plus_offset(self.offsets.vmctx_externref_activations_table()) }",
          "",
          "[Added Lines]",
          "253:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
          "258:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
          "263:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "277:     #[inline]",
          "278:     pub fn store(&self) -> *mut dyn Store {",
          "280:         assert!(!ptr.is_null());",
          "281:         ptr",
          "282:     }",
          "284:     pub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {",
          "285:         if let Some(store) = store {",
          "",
          "[Removed Lines]",
          "279:         let ptr = unsafe { *self.vmctx_plus_offset::<*mut dyn Store>(self.offsets.vmctx_store()) };",
          "",
          "[Added Lines]",
          "278:         let ptr =",
          "279:             unsafe { *self.vmctx_plus_offset::<*mut dyn Store>(self.offsets().vmctx_store()) };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "499:         sig: SignatureIndex,",
          "500:         into: *mut VMCallerCheckedAnyfunc,",
          "501:     ) {",
          "504:         let (func_ptr, vmctx) = if let Some(def_index) = self.module().defined_func_index(index) {",
          "505:             (",
          "509:                 VMOpaqueContext::from_vmcontext(self.vmctx_ptr()),",
          "510:             )",
          "511:         } else {",
          "",
          "[Removed Lines]",
          "502:         let type_index = self.runtime_info.signature(sig);",
          "506:                 (self.runtime_info.image_base()",
          "507:                     + self.runtime_info.function_loc(def_index).start as usize)",
          "508:                     as *mut _,",
          "",
          "[Added Lines]",
          "502:         let type_index = unsafe {",
          "503:             let base: *const VMSharedSignatureIndex =",
          "506:         };",
          "510:                 self.runtime_info.function(def_index),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "569:             let sig = func.signature;",
          "570:             let anyfunc: *mut VMCallerCheckedAnyfunc = self",
          "571:                 .vmctx_plus_offset::<VMCallerCheckedAnyfunc>(",
          "573:                 );",
          "574:             self.construct_anyfunc(index, sig, anyfunc);",
          "",
          "[Removed Lines]",
          "572:                     self.offsets.vmctx_anyfunc(func.anyfunc),",
          "",
          "[Added Lines]",
          "574:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "902:         assert!(std::ptr::eq(module, self.module().as_ref()));",
          "905:         self.set_callee(None);",
          "906:         self.set_store(store.as_raw());",
          "909:         let signatures = self.runtime_info.signature_ids();",
          "917:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
          "918:         ptr::copy_nonoverlapping(",
          "919:             imports.functions.as_ptr(),",
          "921:             imports.functions.len(),",
          "922:         );",
          "923:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
          "924:         ptr::copy_nonoverlapping(",
          "925:             imports.tables.as_ptr(),",
          "927:             imports.tables.len(),",
          "928:         );",
          "929:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
          "930:         ptr::copy_nonoverlapping(",
          "931:             imports.memories.as_ptr(),",
          "933:             imports.memories.len(),",
          "934:         );",
          "935:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
          "936:         ptr::copy_nonoverlapping(",
          "937:             imports.globals.as_ptr(),",
          "939:             imports.globals.len(),",
          "940:         );",
          "",
          "[Removed Lines]",
          "901:     unsafe fn initialize_vmctx(&mut self, module: &Module, store: StorePtr, imports: Imports) {",
          "914:             &VMBuiltinFunctionsArray::INIT;",
          "920:             self.vmctx_plus_offset(self.offsets.vmctx_imported_functions_begin()),",
          "926:             self.vmctx_plus_offset(self.offsets.vmctx_imported_tables_begin()),",
          "932:             self.vmctx_plus_offset(self.offsets.vmctx_imported_memories_begin()),",
          "938:             self.vmctx_plus_offset(self.offsets.vmctx_imported_globals_begin()),",
          "",
          "[Added Lines]",
          "903:     unsafe fn initialize_vmctx(",
          "904:         &mut self,",
          "905:         module: &Module,",
          "906:         offsets: &VMOffsets<HostPtr>,",
          "907:         store: StorePtr,",
          "908:         imports: Imports,",
          "909:     ) {",
          "927:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
          "933:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
          "939:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
          "945:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "950:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "951:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
          "952:             ptr = ptr.add(1);",
          "",
          "[Removed Lines]",
          "949:         let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_tables_begin());",
          "",
          "[Added Lines]",
          "956:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "962:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "963:             let defined_memory_index = DefinedMemoryIndex::new(i);",
          "964:             let memory_index = module.memory_index(defined_memory_index);",
          "",
          "[Removed Lines]",
          "960:         let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_memories_begin());",
          "961:         let mut owned_ptr = self.vmctx_plus_offset(self.offsets.vmctx_owned_memories_begin());",
          "",
          "[Added Lines]",
          "967:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
          "968:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: pub unsafe trait InstanceAllocator: Send + Sync {",
          "97:         Ok(())",
          "98:     }",
          "",
          "[Removed Lines]",
          "95:     fn validate(&self, module: &Module) -> Result<()> {",
          "96:         drop(module);",
          "103:     fn adjust_tunables(&self, tunables: &mut wasmtime_environ::Tunables) {",
          "104:         drop(tunables);",
          "105:     }",
          "",
          "[Added Lines]",
          "95:     fn validate(&self, module: &Module, offsets: &VMOffsets<HostPtr>) -> Result<()> {",
          "96:         drop((module, offsets));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "464:     let mut memories = PrimaryMap::default();",
          "465:     memories.push(memory);",
          "466:     let tables = PrimaryMap::default();",
          "470:     let instance = alloc::alloc(layout) as *mut Instance;",
          "472:     Ok(InstanceHandle { instance })",
          "473: }",
          "",
          "[Removed Lines]",
          "467:     let module = req.runtime_info.module();",
          "468:     let offsets = VMOffsets::new(HostPtr, module);",
          "469:     let layout = Instance::alloc_layout(&offsets);",
          "471:     Instance::new_at(instance, layout.size(), offsets, req, memories, tables);",
          "",
          "[Added Lines]",
          "460:     let layout = Instance::alloc_layout(req.runtime_info.offsets());",
          "462:     Instance::new_at(instance, layout.size(), req, memories, tables);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "478: pub unsafe fn deallocate(handle: &InstanceHandle) {",
          "480:     ptr::drop_in_place(handle.instance);",
          "481:     alloc::dealloc(handle.instance.cast(), layout);",
          "482: }",
          "",
          "[Removed Lines]",
          "479:     let layout = Instance::alloc_layout(&handle.instance().offsets);",
          "",
          "[Added Lines]",
          "470:     let layout = Instance::alloc_layout(handle.instance().offsets());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "485:     unsafe fn allocate(&self, mut req: InstanceAllocationRequest) -> Result<InstanceHandle> {",
          "486:         let memories = self.create_memories(&mut req.store, &req.runtime_info)?;",
          "487:         let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;",
          "491:         let instance_ptr = alloc::alloc(layout) as *mut Instance;",
          "495:         Ok(InstanceHandle {",
          "496:             instance: instance_ptr,",
          "",
          "[Removed Lines]",
          "488:         let module = req.runtime_info.module();",
          "489:         let offsets = VMOffsets::new(HostPtr, module);",
          "490:         let layout = Instance::alloc_layout(&offsets);",
          "493:         Instance::new_at(instance_ptr, layout.size(), offsets, req, memories, tables);",
          "",
          "[Added Lines]",
          "479:         let layout = Instance::alloc_layout(req.runtime_info.offsets());",
          "482:         Instance::new_at(instance_ptr, layout.size(), req, memories, tables);",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:         let mut memories =",
          "175:             PrimaryMap::with_capacity(module.memory_plans.len() - module.num_imported_memories);",
          "",
          "[Removed Lines]",
          "172:         let offsets = self.validate_instance_size(module)?;",
          "",
          "[Added Lines]",
          "172:         self.validate_instance_size(req.runtime_info.offsets())?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:         let instance_ptr = self.instance(instance_index) as _;",
          "204:         Ok(InstanceHandle {",
          "205:             instance: instance_ptr,",
          "",
          "[Removed Lines]",
          "195:         Instance::new_at(",
          "196:             instance_ptr,",
          "197:             self.instance_size,",
          "198:             offsets,",
          "199:             req,",
          "200:             memories,",
          "201:             tables,",
          "202:         );",
          "",
          "[Added Lines]",
          "195:         Instance::new_at(instance_ptr, self.instance_size, req, memories, tables);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:         Ok(())",
          "486:     }",
          "491:         if layout.size() <= self.instance_size {",
          "493:         }",
          "",
          "[Removed Lines]",
          "488:     fn validate_instance_size(&self, module: &Module) -> Result<VMOffsets<HostPtr>> {",
          "489:         let offsets = VMOffsets::new(HostPtr, module);",
          "490:         let layout = Instance::alloc_layout(&offsets);",
          "492:             return Ok(offsets);",
          "",
          "[Added Lines]",
          "481:     fn validate_instance_size(&self, offsets: &VMOffsets<HostPtr>) -> Result<()> {",
          "482:         let layout = Instance::alloc_layout(offsets);",
          "484:             return Ok(());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1078: }",
          "1080: unsafe impl InstanceAllocator for PoolingInstanceAllocator {",
          "1082:         self.instances.validate_memory_plans(module)?;",
          "1083:         self.instances.validate_table_plans(module)?;",
          "1093:         Ok(())",
          "1094:     }",
          "",
          "[Removed Lines]",
          "1081:     fn validate(&self, module: &Module) -> Result<()> {",
          "1091:         self.instances.validate_instance_size(module)?;",
          "",
          "[Added Lines]",
          "1073:     fn validate(&self, module: &Module, offsets: &VMOffsets<HostPtr>) -> Result<()> {",
          "1076:         self.instances.validate_instance_size(offsets)?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1145: #[cfg(test)]",
          "1146: mod test {",
          "1147:     use super::*;",
          "1149:     use std::sync::Arc;",
          "1152:     pub(crate) fn empty_runtime_info(",
          "1153:         module: Arc<wasmtime_environ::Module>,",
          "1154:     ) -> Arc<dyn ModuleRuntimeInfo> {",
          "1157:         impl ModuleRuntimeInfo for RuntimeInfo {",
          "1158:             fn module(&self) -> &Arc<wasmtime_environ::Module> {",
          "1159:                 &self.0",
          "1160:             }",
          "1168:                 unimplemented!()",
          "1169:             }",
          "1170:             fn memory_image(",
          "",
          "[Removed Lines]",
          "1148:     use crate::{CompiledModuleId, Imports, MemoryImage, StorePtr, VMSharedSignatureIndex};",
          "1150:     use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex, FunctionLoc, SignatureIndex};",
          "1155:         struct RuntimeInfo(Arc<wasmtime_environ::Module>);",
          "1161:             fn image_base(&self) -> usize {",
          "1162:                 0",
          "1163:             }",
          "1164:             fn function_loc(&self, _: DefinedFuncIndex) -> &FunctionLoc {",
          "1165:                 unimplemented!()",
          "1166:             }",
          "1167:             fn signature(&self, _: SignatureIndex) -> VMSharedSignatureIndex {",
          "",
          "[Added Lines]",
          "1133:     use crate::{",
          "1134:         CompiledModuleId, Imports, MemoryImage, StorePtr, VMFunctionBody, VMSharedSignatureIndex,",
          "1135:     };",
          "1137:     use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex};",
          "1142:         struct RuntimeInfo(Arc<wasmtime_environ::Module>, VMOffsets<HostPtr>);",
          "1148:             fn function(&self, _: DefinedFuncIndex) -> *mut VMFunctionBody {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1183:             fn signature_ids(&self) -> &[VMSharedSignatureIndex] {",
          "1184:                 &[]",
          "1185:             }",
          "1186:         }",
          "1189:     }",
          "1191:     #[cfg(target_pointer_width = \"64\")]",
          "",
          "[Removed Lines]",
          "1188:         Arc::new(RuntimeInfo(module))",
          "",
          "[Added Lines]",
          "1167:             fn offsets(&self) -> &VMOffsets<HostPtr> {",
          "1168:                 &self.1",
          "1169:             }",
          "1172:         let offsets = VMOffsets::new(HostPtr, &module);",
          "1173:         Arc::new(RuntimeInfo(module, offsets))",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: use anyhow::Error;",
          "24: use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};",
          "25: use std::sync::Arc;",
          "31: #[macro_use]",
          "32: mod trampolines;",
          "",
          "[Removed Lines]",
          "26: use wasmtime_environ::DefinedFuncIndex;",
          "27: use wasmtime_environ::DefinedMemoryIndex;",
          "28: use wasmtime_environ::FunctionLoc;",
          "29: use wasmtime_environ::SignatureIndex;",
          "",
          "[Added Lines]",
          "26: use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex, HostPtr, VMOffsets};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173:     fn module(&self) -> &Arc<wasmtime_environ::Module>;",
          "",
          "[Removed Lines]",
          "176:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex;",
          "179:     fn image_base(&self) -> usize;",
          "183:     fn function_loc(&self, func_index: DefinedFuncIndex) -> &FunctionLoc;",
          "",
          "[Added Lines]",
          "173:     fn function(&self, index: DefinedFuncIndex) -> *mut VMFunctionBody;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:     fn signature_ids(&self) -> &[VMSharedSignatureIndex];",
          "201: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     fn offsets(&self) -> &VMOffsets<HostPtr>;",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs": [
          "File: crates/wasmtime/src/engine.rs -> crates/wasmtime/src/engine.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:         #[cfg(compiler)]",
          "88:         let compiler = config.build_compiler()?;",
          "90:         let allocator = config.build_allocator()?;",
          "92:         let profiler = config.build_profiler()?;",
          "94:         Ok(Engine {",
          "",
          "[Removed Lines]",
          "91:         allocator.adjust_tunables(&mut config.tunables);",
          "",
          "[Added Lines]",
          "89:         drop(&mut config); // silence warnings without `cfg(compiler)`",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs": [
          "File: crates/wasmtime/src/module.rs -> crates/wasmtime/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: use std::sync::Arc;",
          "15: use wasmparser::{Parser, ValidPayload, Validator};",
          "16: use wasmtime_environ::{",
          "19: };",
          "20: use wasmtime_jit::{CodeMemory, CompiledModule, CompiledModuleInfo};",
          "21: use wasmtime_runtime::{",
          "23: };",
          "25: mod registry;",
          "",
          "[Removed Lines]",
          "17:     DefinedFuncIndex, DefinedMemoryIndex, FunctionLoc, ModuleEnvironment, ModuleTranslation,",
          "18:     ModuleTypes, ObjectKind, PrimaryMap, SignatureIndex, WasmFunctionInfo,",
          "22:     CompiledModuleId, MemoryImage, MmapVec, ModuleMemoryImages, VMSharedSignatureIndex,",
          "",
          "[Added Lines]",
          "17:     DefinedFuncIndex, DefinedMemoryIndex, HostPtr, ModuleEnvironment, ModuleTranslation,",
          "18:     ModuleTypes, ObjectKind, PrimaryMap, VMOffsets, WasmFunctionInfo,",
          "22:     CompiledModuleId, MemoryImage, MmapVec, ModuleMemoryImages, VMFunctionBody,",
          "23:     VMSharedSignatureIndex,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:     serializable: bool,",
          "126: }",
          "128: impl Module {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129:     offsets: VMOffsets<HostPtr>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "664:         )?;",
          "669:         Ok(Self {",
          "670:             inner: Arc::new(ModuleInner {",
          "",
          "[Removed Lines]",
          "667:         engine.allocator().validate(module.module())?;",
          "",
          "[Added Lines]",
          "671:         let offsets = VMOffsets::new(HostPtr, module.module());",
          "672:         engine.allocator().validate(module.module(), &offsets)?;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "673:                 memory_images: OnceCell::new(),",
          "674:                 module,",
          "675:                 serializable,",
          "676:             }),",
          "677:         })",
          "678:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "681:                 offsets,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1098:         self.module.module()",
          "1099:     }",
          "1111:     }",
          "1113:     fn memory_image(&self, memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryImage>>> {",
          "",
          "[Removed Lines]",
          "1101:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex {",
          "1102:         self.code.signatures().as_module_map()[index]",
          "1103:     }",
          "1105:     fn image_base(&self) -> usize {",
          "1106:         self.module.text().as_ptr() as usize",
          "1107:     }",
          "1109:     fn function_loc(&self, index: DefinedFuncIndex) -> &FunctionLoc {",
          "1110:         self.module.func_loc(index)",
          "",
          "[Added Lines]",
          "1107:     fn function(&self, index: DefinedFuncIndex) -> *mut VMFunctionBody {",
          "1108:         self.module",
          "1109:             .finished_function(index)",
          "1110:             .as_ptr()",
          "1111:             .cast::<VMFunctionBody>()",
          "1112:             .cast_mut()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1126:     fn signature_ids(&self) -> &[VMSharedSignatureIndex] {",
          "1127:         self.code.signatures().as_module_map().values().as_slice()",
          "1128:     }",
          "1129: }",
          "1131: impl wasmtime_runtime::ModuleInfo for ModuleInner {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1132:     fn offsets(&self) -> &VMOffsets<HostPtr> {",
          "1133:         &self.offsets",
          "1134:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1161: pub(crate) struct BareModuleInfo {",
          "1162:     module: Arc<wasmtime_environ::Module>,",
          "1165: }",
          "1167: impl BareModuleInfo {",
          "1168:     pub(crate) fn empty(module: Arc<wasmtime_environ::Module>) -> Self {",
          "1174:     }",
          "1176:     pub(crate) fn maybe_imported_func(",
          "1177:         module: Arc<wasmtime_environ::Module>,",
          "1179:     ) -> Self {",
          "1180:         BareModuleInfo {",
          "1181:             module,",
          "1183:             one_signature,",
          "1184:         }",
          "1185:     }",
          "",
          "[Removed Lines]",
          "1163:     image_base: usize,",
          "1164:     one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "1169:         BareModuleInfo {",
          "1170:             module,",
          "1171:             image_base: 0,",
          "1172:             one_signature: None,",
          "1173:         }",
          "1178:         one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "1182:             image_base: 0,",
          "",
          "[Added Lines]",
          "1169:     one_signature: Option<VMSharedSignatureIndex>,",
          "1170:     offsets: VMOffsets<HostPtr>,",
          "1175:         BareModuleInfo::maybe_imported_func(module, None)",
          "1180:         one_signature: Option<VMSharedSignatureIndex>,",
          "1183:             offsets: VMOffsets::new(HostPtr, &module),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1194:         &self.module",
          "1195:     }",
          "1210:         unreachable!()",
          "1211:     }",
          "",
          "[Removed Lines]",
          "1197:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex {",
          "1198:         let (signature_id, signature) = self",
          "1199:             .one_signature",
          "1200:             .expect(\"Signature for one function should be present if queried\");",
          "1201:         assert_eq!(index, signature_id);",
          "1202:         signature",
          "1203:     }",
          "1205:     fn image_base(&self) -> usize {",
          "1206:         self.image_base",
          "1207:     }",
          "1209:     fn function_loc(&self, _index: DefinedFuncIndex) -> &FunctionLoc {",
          "",
          "[Added Lines]",
          "1199:     fn function(&self, _index: DefinedFuncIndex) -> *mut VMFunctionBody {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1225:     fn signature_ids(&self) -> &[VMSharedSignatureIndex] {",
          "1226:         match &self.one_signature {",
          "1228:             None => &[],",
          "1229:         }",
          "1230:     }",
          "1231: }",
          "",
          "[Removed Lines]",
          "1227:             Some((_, id)) => std::slice::from_ref(id),",
          "",
          "[Added Lines]",
          "1217:             Some(id) => std::slice::from_ref(id),",
          "1222:     fn offsets(&self) -> &VMOffsets<HostPtr> {",
          "1223:         &self.offsets",
          "1224:     }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/module/registry.rs||crates/wasmtime/src/module/registry.rs": [
          "File: crates/wasmtime/src/module/registry.rs -> crates/wasmtime/src/module/registry.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:             None => return,",
          "163:         };",
          "166:         match self.modules.entry(start) {",
          "",
          "[Removed Lines]",
          "164:         let start = unsafe { (*func).as_ptr() as usize };",
          "",
          "[Added Lines]",
          "164:         let start = func.as_ptr() as usize;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "279:     Instance::new(&mut store, &module, &[])?;",
          "281:     for (i, alloc) in module.compiled_module().finished_functions() {",
          "285:             (ptr as usize, ptr as usize + len)",
          "286:         };",
          "287:         for pc in start..end {",
          "",
          "[Removed Lines]",
          "282:         let (start, end) = unsafe {",
          "283:             let ptr = (*alloc).as_ptr();",
          "284:             let len = (*alloc).len();",
          "",
          "[Added Lines]",
          "282:         let (start, end) = {",
          "283:             let ptr = alloc.as_ptr();",
          "284:             let len = alloc.len();",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs": [
          "File: crates/wasmtime/src/trampoline.rs -> crates/wasmtime/src/trampoline.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: use anyhow::Result;",
          "18: use std::any::Any;",
          "19: use std::sync::Arc;",
          "21: use wasmtime_runtime::{",
          "22:     Imports, InstanceAllocationRequest, InstanceAllocator, OnDemandInstanceAllocator, SharedMemory,",
          "23:     StorePtr, VMFunctionImport, VMSharedSignatureIndex,",
          "",
          "[Removed Lines]",
          "20: use wasmtime_environ::{GlobalIndex, MemoryIndex, Module, SignatureIndex, TableIndex};",
          "",
          "[Added Lines]",
          "20: use wasmtime_environ::{GlobalIndex, MemoryIndex, Module, TableIndex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:     store: &mut StoreOpaque,",
          "29:     host_state: Box<dyn Any + Send + Sync>,",
          "30:     func_imports: &[VMFunctionImport],",
          "32: ) -> Result<InstanceId> {",
          "33:     let mut imports = Imports::default();",
          "34:     imports.functions = func_imports;",
          "",
          "[Removed Lines]",
          "31:     one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "",
          "[Added Lines]",
          "31:     one_signature: Option<VMSharedSignatureIndex>,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/global.rs||crates/wasmtime/src/trampoline/global.rs": [
          "File: crates/wasmtime/src/trampoline/global.rs -> crates/wasmtime/src/trampoline/global.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:                 let f = f.caller_checked_anyfunc(store);",
          "41:                 let f = unsafe { f.as_ref() };",
          "44:                 module.types.push(ModuleType::Function(sig_id));",
          "45:                 let func_index = module.push_escaped_function(sig_id, AnyfuncIndex::from_u32(0));",
          "46:                 module.num_imported_funcs = 1;",
          "",
          "[Removed Lines]",
          "42:                 let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);",
          "43:                 one_signature = Some((sig_id, f.type_index));",
          "",
          "[Added Lines]",
          "42:                 let sig_id = SignatureIndex::from_u32(0);",
          "43:                 one_signature = Some(f.type_index);",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "647:     let engine = Engine::new(&config)?;",
          "648:     let expected = \"\\",
          "650: configured maximum of 16 bytes; breakdown of allocation requirement:",
          "653: \";",
          "654:     match Module::new(&engine, \"(module)\") {",
          "655:         Ok(_) => panic!(\"should have failed to compile\"),",
          "",
          "[Removed Lines]",
          "649: instance allocation for this module requires 336 bytes which exceeds the \\",
          "",
          "[Added Lines]",
          "649: instance allocation for this module requires 224 bytes which exceeds the \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "663:     lots_of_globals.push_str(\")\");",
          "665:     let expected = \"\\",
          "667: configured maximum of 16 bytes; breakdown of allocation requirement:",
          "671: \";",
          "672:     match Module::new(&engine, &lots_of_globals) {",
          "673:         Ok(_) => panic!(\"should have failed to compile\"),",
          "",
          "[Removed Lines]",
          "666: instance allocation for this module requires 1936 bytes which exceeds the \\",
          "",
          "[Added Lines]",
          "667: instance allocation for this module requires 1824 bytes which exceeds the \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "28371bfd40d0b0166674efa9f86b1530c8ded8a7",
      "candidate_info": {
        "commit_hash": "28371bfd40d0b0166674efa9f86b1530c8ded8a7",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/28371bfd40d0b0166674efa9f86b1530c8ded8a7",
        "files": [
          "crates/fuzzing/src/generators/memory.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs",
          "crates/runtime/src/memory.rs",
          "crates/runtime/src/traphandlers.rs",
          "crates/runtime/src/traphandlers/macos.rs",
          "crates/runtime/src/traphandlers/unix.rs",
          "crates/runtime/src/traphandlers/windows.rs",
          "crates/wasmtime/src/memory.rs",
          "crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline/memory.rs",
          "crates/wasmtime/src/trap.rs",
          "tests/all/memory_creator.rs",
          "tests/all/traps.rs"
        ],
        "message": "Validate faulting addresses are valid to fault on (#6028)\n\n* Validate faulting addresses are valid to fault on\n\nThis commit adds a defense-in-depth measure to Wasmtime which is\nintended to mitigate the impact of CVEs such as GHSA-ff4p-7xrq-q5r8.\nCurrently Wasmtime will catch `SIGSEGV` signals for WebAssembly code so\nlong as the instruction which faulted is an allow-listed instruction\n(aka has a trap code listed for it). With the recent security issue,\nhowever, the problem was that a wasm guest could exploit a compiler bug\nto access memory outside of its sandbox. If the access was successful\nthere's no real way to detect that, but if the access was unsuccessful\nthen Wasmtime would happily swallow the `SIGSEGV` and report a nominal\ntrap. To embedders, this might look like nothing is going awry.\n\nThe new strategy implemented here in this commit is to attempt to be\nmore robust towards these sorts of failures. When a `SIGSEGV` is raised\nthe faulting pc is recorded but additionally the address of the\ninaccessible location is also record. After the WebAssembly stack is\nunwound and control returns to Wasmtime which has access to a `Store`\nWasmtime will now use this inaccessible faulting address to translate it\nto a wasm address. This process should be guaranteed to succeed as\nWebAssembly should only be able to access a well-defined region of\nmemory for all linear memories in a `Store`.\n\nIf no linear memory in a `Store` could contain the faulting address,\nthen Wasmtime now prints a scary message and aborts the process. The\npurpose of this is to catch these sorts of bugs, make them very loud\nerrors, and hopefully mitigate impact. This would continue to not\nmitigate the impact of a guest successfully loading data outside of its\nsandbox, but if a guest was doing a sort of probing strategy trying to\nfind valid addresses then any invalid access would turn into a process\ncrash which would immediately be noticed by embedders.\n\nWhile I was here I went ahead and additionally took a stab at #3120.\nTraps due to `SIGSEGV` will now report the size of linear memory and the\naddress that was being accessed in addition to the bland \"access out of\nbounds\" error. While this is still somewhat bland in the context of a\nhigh level source language it's hopefully at least a little bit more\nactionable for some. I'll note though that this isn't a guaranteed\ncontextual message since only the default configuration for Wasmtime\ngenerates `SIGSEGV` on out-of-bounds memory accesses. Dynamically\nbounds-checked configurations, for example, don't do this.\n\nTesting-wise I unfortunately am not aware of a great way to test this.\nThe closet equivalent would be something like an `unsafe` method\n`Config::allow_wasm_sandbox_escape`. In lieu of adding tests, though, I\ncan confirm that during development the crashing messages works just\nfine as it took awhile on macOS to figure out where the faulting address\nwas recorded in the exception information which meant I had lots of\ninstances of recording an address of a trap not accessible from wasm.\n\n* Fix tests\n\n* Review comments\n\n* Fix compile after refactor\n\n* Fix compile on macOS\n\n* Fix trap test for s390x\n\ns390x rounds faulting addresses to 4k boundaries.",
        "before_after_code_files": [
          "crates/fuzzing/src/generators/memory.rs||crates/fuzzing/src/generators/memory.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs",
          "crates/runtime/src/traphandlers/macos.rs||crates/runtime/src/traphandlers/macos.rs",
          "crates/runtime/src/traphandlers/unix.rs||crates/runtime/src/traphandlers/unix.rs",
          "crates/runtime/src/traphandlers/windows.rs||crates/runtime/src/traphandlers/windows.rs",
          "crates/wasmtime/src/memory.rs||crates/wasmtime/src/memory.rs",
          "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs",
          "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs",
          "tests/all/memory_creator.rs||tests/all/memory_creator.rs",
          "tests/all/traps.rs||tests/all/traps.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/fuzzing/src/generators/memory.rs||crates/fuzzing/src/generators/memory.rs": [
          "File: crates/fuzzing/src/generators/memory.rs -> crates/fuzzing/src/generators/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use anyhow::Result;",
          "4: use arbitrary::{Arbitrary, Unstructured};",
          "5: use wasmtime::{LinearMemory, MemoryCreator, MemoryType};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: use std::ops::Range;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:         self.src[1..].as_ptr() as *mut _",
          "88:     }",
          "89: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:     fn wasm_accessible(&self) -> Range<usize> {",
          "92:         let base = self.as_ptr() as usize;",
          "93:         let len = self.byte_size();",
          "94:         base..base + len",
          "95:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: };",
          "14: use crate::{",
          "15:     ExportFunction, ExportGlobal, ExportMemory, ExportTable, Imports, ModuleRuntimeInfo, Store,",
          "17: };",
          "18: use anyhow::Error;",
          "19: use anyhow::Result;",
          "",
          "[Removed Lines]",
          "16:     VMFunctionBody, VMSharedSignatureIndex,",
          "",
          "[Added Lines]",
          "16:     VMFunctionBody, VMSharedSignatureIndex, WasmFault,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1046:             }",
          "1047:         }",
          "1048:     }",
          "1049: }",
          "1051: impl Drop for Instance {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1050:     fn wasm_fault(&self, addr: usize) -> Option<WasmFault> {",
          "1051:         let mut fault = None;",
          "1052:         for (_, memory) in self.memories.iter() {",
          "1053:             let accessible = memory.wasm_accessible();",
          "1054:             if accessible.start <= addr && addr < accessible.end {",
          "1057:                 assert!(fault.is_none());",
          "1058:                 fault = Some(WasmFault {",
          "1059:                     memory_size: memory.byte_size(),",
          "1060:                     wasm_address: u64::try_from(addr - accessible.start).unwrap(),",
          "1061:                 });",
          "1062:             }",
          "1063:         }",
          "1064:         fault",
          "1065:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1231:     pub fn initialize(&mut self, module: &Module, is_bulk_memory: bool) -> Result<()> {",
          "1232:         allocator::initialize_instance(self.instance_mut(), module, is_bulk_memory)",
          "1233:     }",
          "1234: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1259:     pub fn wasm_fault(&self, addr: usize) -> Option<WasmFault> {",
          "1260:         self.instance().wasm_fault(addr)",
          "1261:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "818:             slot.instantiate(initial_size as usize, image, &plan.style)?;",
          "823:         }",
          "825:         Ok(())",
          "",
          "[Removed Lines]",
          "820:             memories.push(Memory::new_static(plan, memory, slot, unsafe {",
          "821:                 &mut *req.store.get().unwrap()",
          "822:             })?);",
          "",
          "[Added Lines]",
          "820:             memories.push(Memory::new_static(",
          "821:                 plan,",
          "822:                 memory,",
          "823:                 slot,",
          "824:                 self.memories.memory_and_guard_size,",
          "825:                 unsafe { &mut *req.store.get().unwrap() },",
          "826:             )?);",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: )]",
          "23: use anyhow::Error;",
          "24: use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};",
          "25: use std::sync::Arc;",
          "26: use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex, HostPtr, VMOffsets};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: use std::fmt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:     TimedOut = 2,",
          "239: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "243: #[derive(Debug)]",
          "244: pub struct WasmFault {",
          "246:     pub memory_size: usize,",
          "248:     pub wasm_address: u64,",
          "249: }",
          "251: impl fmt::Display for WasmFault {",
          "252:     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
          "253:         write!(",
          "254:             f,",
          "255:             \"memory fault at wasm address 0x{:x} in linear memory of size 0x{:x}\",",
          "256:             self.wasm_address, self.memory_size,",
          "257:         )",
          "258:     }",
          "259: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs": [
          "File: crates/runtime/src/memory.rs -> crates/runtime/src/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: use anyhow::Error;",
          "10: use anyhow::{bail, format_err, Result};",
          "11: use std::convert::TryFrom;",
          "12: use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};",
          "13: use std::sync::{Arc, RwLock};",
          "14: use std::time::Instant;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: use std::ops::Range;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "154:     fn as_any_mut(&mut self) -> &mut dyn std::any::Any;",
          "155: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:     fn wasm_accessible(&self) -> Range<usize>;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:     fn as_any_mut(&mut self) -> &mut dyn std::any::Any {",
          "339:         self",
          "340:     }",
          "341: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "349:     fn wasm_accessible(&self) -> Range<usize> {",
          "350:         let base = self.mmap.as_mut_ptr() as usize + self.pre_guard_size;",
          "351:         let end = base + (self.mmap.len() - self.pre_guard_size);",
          "352:         base..end",
          "353:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "351:     size: usize,",
          "355:     memory_image: MemoryImageSlot,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "368:     memory_and_guard_size: usize,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "361:         initial_size: usize,",
          "362:         maximum_size: Option<usize>,",
          "363:         memory_image: MemoryImageSlot,",
          "364:     ) -> Result<Self> {",
          "365:         if base.len() < initial_size {",
          "366:             bail!(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "381:         memory_and_guard_size: usize,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "381:             base,",
          "382:             size: initial_size,",
          "383:             memory_image,",
          "384:         })",
          "385:     }",
          "386: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402:             memory_and_guard_size,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "420:     fn as_any_mut(&mut self) -> &mut dyn std::any::Any {",
          "421:         self",
          "422:     }",
          "423: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:     fn wasm_accessible(&self) -> Range<usize> {",
          "444:         let base = self.base.as_ptr() as usize;",
          "445:         let end = base + self.memory_and_guard_size;",
          "446:         base..end",
          "447:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "620:     fn as_any_mut(&mut self) -> &mut dyn std::any::Any {",
          "621:         self",
          "622:     }",
          "623: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "649:     fn wasm_accessible(&self) -> Range<usize> {",
          "650:         self.0.memory.read().unwrap().wasm_accessible()",
          "651:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "648:         plan: &MemoryPlan,",
          "649:         base: &'static mut [u8],",
          "650:         memory_image: MemoryImageSlot,",
          "651:         store: &mut dyn Store,",
          "652:     ) -> Result<Self> {",
          "653:         let (minimum, maximum) = Self::limit_new(plan, Some(store))?;",
          "655:         let allocation = Box::new(pooled_memory);",
          "656:         let allocation: Box<dyn RuntimeLinearMemory> = if plan.memory.shared {",
          "",
          "[Removed Lines]",
          "654:         let pooled_memory = StaticMemory::new(base, minimum, maximum, memory_image)?;",
          "",
          "[Added Lines]",
          "680:         memory_and_guard_size: usize,",
          "684:         let pooled_memory =",
          "685:             StaticMemory::new(base, minimum, maximum, memory_image, memory_and_guard_size)?;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "874:             }",
          "875:         }",
          "876:     }",
          "877: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "912:     pub fn wasm_accessible(&self) -> Range<usize> {",
          "913:         self.0.wasm_accessible()",
          "914:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:         needs_backtrace: bool,",
          "148:     },",
          "155:     Wasm(wasmtime_environ::Trap),",
          "",
          "[Removed Lines]",
          "152:     Jit(usize),",
          "",
          "[Added Lines]",
          "151:     Jit {",
          "156:         pc: usize,",
          "167:         faulting_addr: Option<usize>,",
          "168:     },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "176:     pub fn is_jit(&self) -> bool {",
          "178:     }",
          "179: }",
          "",
          "[Removed Lines]",
          "177:         matches!(self, TrapReason::Jit(_))",
          "",
          "[Added Lines]",
          "193:         matches!(self, TrapReason::Jit { .. })",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "470:         self.jmp_buf.replace(ptr::null())",
          "471:     }",
          "474:         let backtrace = self.capture_backtrace(Some((pc as usize, fp)));",
          "475:         unsafe {",
          "479:         }",
          "480:     }",
          "",
          "[Removed Lines]",
          "473:     fn set_jit_trap(&self, pc: *const u8, fp: usize) {",
          "476:             (*self.unwind.get())",
          "477:                 .as_mut_ptr()",
          "478:                 .write((UnwindReason::Trap(TrapReason::Jit(pc as usize)), backtrace));",
          "",
          "[Added Lines]",
          "489:     fn set_jit_trap(&self, pc: *const u8, fp: usize, faulting_addr: Option<usize>) {",
          "492:             (*self.unwind.get()).as_mut_ptr().write((",
          "493:                 UnwindReason::Trap(TrapReason::Jit {",
          "494:                     pc: pc as usize,",
          "495:                     faulting_addr,",
          "496:                 }),",
          "497:                 backtrace,",
          "498:             ));",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers/macos.rs||crates/runtime/src/traphandlers/macos.rs": [
          "File: crates/runtime/src/traphandlers/macos.rs -> crates/runtime/src/traphandlers/macos.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:         pub static NDR_record: NDR_record_t;",
          "76:     }",
          "79:     #[allow(dead_code)]",
          "80:     #[derive(Copy, Clone, Debug)]",
          "81:     pub struct __Request__exception_raise_t {",
          "",
          "[Removed Lines]",
          "78:     #[repr(C)]",
          "",
          "[Added Lines]",
          "89:     #[repr(C, packed(4))]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173: #[repr(C)]",
          "174: #[allow(dead_code)]",
          "175: struct ExceptionRequest {",
          "176:     body: __Request__exception_raise_t,",
          "177:     trailer: mach_msg_trailer_t,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: #[derive(Debug)]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "248:         _ => return false,",
          "249:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:     let (fault1, fault2) = if request.body.exception as u32 == EXC_BAD_ACCESS {",
          "273:         (1, request.body.code[1] as usize)",
          "274:     } else {",
          "275:         (0, 0)",
          "276:     };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "279:                 state.__rbp as usize,",
          "280:             );",
          "",
          "[Removed Lines]",
          "282:             let resume = |state: &mut ThreadState, pc: usize, fp: usize| {",
          "",
          "[Added Lines]",
          "309:             let resume = |state: &mut ThreadState, pc: usize, fp: usize, fault1: usize, fault2: usize| {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "306:                 state.__rip = unwind as u64;",
          "307:                 state.__rdi = pc as u64;",
          "308:                 state.__rsi = fp as u64;",
          "309:             };",
          "310:             let mut thread_state = ThreadState::new();",
          "311:         } else if #[cfg(target_arch = \"aarch64\")] {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336:                 state.__rdx = fault1 as u64;",
          "337:                 state.__rcx = fault2 as u64;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "318:                 state.__fp as usize,",
          "319:             );",
          "",
          "[Removed Lines]",
          "321:             let resume = |state: &mut ThreadState, pc: usize, fp: usize| {",
          "",
          "[Added Lines]",
          "350:             let resume = |state: &mut ThreadState, pc: usize, fp: usize, fault1: usize, fault2: usize| {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "330:                 state.__x[0] = pc as u64;",
          "331:                 state.__x[1] = fp as u64;",
          "332:                 state.__pc = unwind as u64;",
          "333:             };",
          "334:             let mut thread_state = mem::zeroed::<ThreadState>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361:                 state.__x[2] = fault1 as u64;",
          "362:                 state.__x[3] = fault2 as u64;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "377:     let kret = thread_set_state(",
          "378:         origin_thread,",
          "379:         thread_state_flavor,",
          "",
          "[Removed Lines]",
          "376:     resume(&mut thread_state, pc as usize, fp);",
          "",
          "[Added Lines]",
          "407:     resume(&mut thread_state, pc as usize, fp, fault1, fault2);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "394:     let jmp_buf = tls::with(|state| {",
          "395:         let state = state.unwrap();",
          "397:         state.jmp_buf.get()",
          "398:     });",
          "399:     debug_assert!(!jmp_buf.is_null());",
          "",
          "[Removed Lines]",
          "393: unsafe extern \"C\" fn unwind(wasm_pc: *const u8, wasm_fp: usize) -> ! {",
          "396:         state.set_jit_trap(wasm_pc, wasm_fp);",
          "",
          "[Added Lines]",
          "424: unsafe extern \"C\" fn unwind(",
          "425:     wasm_pc: *const u8,",
          "426:     wasm_fp: usize,",
          "427:     has_faulting_addr: usize,",
          "428:     faulting_addr: usize,",
          "429: ) -> ! {",
          "432:         let faulting_addr = if has_faulting_addr != 0 {",
          "433:             Some(faulting_addr)",
          "434:         } else {",
          "435:             None",
          "436:         };",
          "437:         state.set_jit_trap(wasm_pc, wasm_fp, faulting_addr);",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers/unix.rs||crates/runtime/src/traphandlers/unix.rs": [
          "File: crates/runtime/src/traphandlers/unix.rs -> crates/runtime/src/traphandlers/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:         if jmp_buf as usize == 1 {",
          "102:             return true;",
          "103:         }",
          "",
          "[Removed Lines]",
          "104:         info.set_jit_trap(pc, fp);",
          "",
          "[Added Lines]",
          "104:         let faulting_addr = match signum {",
          "105:             libc::SIGSEGV | libc::SIGBUS => Some((*siginfo).si_addr() as usize),",
          "106:             _ => None,",
          "107:         };",
          "108:         info.set_jit_trap(pc, fp, faulting_addr);",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers/windows.rs||crates/runtime/src/traphandlers/windows.rs": [
          "File: crates/runtime/src/traphandlers/windows.rs -> crates/runtime/src/traphandlers/windows.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:                 compile_error!(\"unsupported platform\");",
          "63:             }",
          "64:         }",
          "65:         let jmp_buf = info.take_jmp_buf_if_trap(ip, |handler| handler(exception_info));",
          "66:         if jmp_buf.is_null() {",
          "67:             ExceptionContinueSearch",
          "68:         } else if jmp_buf as usize == 1 {",
          "69:             ExceptionContinueExecution",
          "70:         } else {",
          "72:             wasmtime_longjmp(jmp_buf)",
          "73:         }",
          "74:     })",
          "",
          "[Removed Lines]",
          "71:             info.set_jit_trap(ip, fp);",
          "",
          "[Added Lines]",
          "69:         let faulting_addr = if record.ExceptionCode == EXCEPTION_ACCESS_VIOLATION {",
          "70:             assert!(record.NumberParameters >= 2);",
          "71:             Some(record.ExceptionInformation[1])",
          "72:         } else {",
          "73:             None",
          "74:         };",
          "81:             info.set_jit_trap(ip, fp, faulting_addr);",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/memory.rs||crates/wasmtime/src/memory.rs": [
          "File: crates/wasmtime/src/memory.rs -> crates/wasmtime/src/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: use anyhow::{bail, Result};",
          "6: use std::cell::UnsafeCell;",
          "7: use std::convert::TryFrom;",
          "8: use std::slice;",
          "9: use std::time::Instant;",
          "10: use wasmtime_environ::MemoryPlan;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: use std::ops::Range;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "613:     fn as_ptr(&self) -> *mut u8;",
          "614: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "618:     fn wasm_accessible(&self) -> Range<usize>;",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs": [
          "File: crates/wasmtime/src/store.rs -> crates/wasmtime/src/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     InstanceAllocationRequest, InstanceAllocator, InstanceHandle, ModuleInfo,",
          "98:     OnDemandInstanceAllocator, SignalHandler, StorePtr, VMCallerCheckedFuncRef, VMContext,",
          "99:     VMExternRef, VMExternRefActivationsTable, VMRuntimeLimits, VMSharedSignatureIndex,",
          "101: };",
          "103: mod context;",
          "",
          "[Removed Lines]",
          "100:     VMTrampoline,",
          "",
          "[Added Lines]",
          "100:     VMTrampoline, WasmFault,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1501:     pub(crate) fn push_rooted_funcs(&mut self, funcs: Arc<[Definition]>) {",
          "1502:         self.rooted_host_funcs.push(funcs);",
          "1503:     }",
          "1504: }",
          "1506: impl<T> StoreContextMut<'_, T> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1517:     pub(crate) fn wasm_fault(&self, pc: usize, addr: usize) -> Option<WasmFault> {",
          "1521:         if addr == 0 {",
          "1522:             return None;",
          "1523:         }",
          "1533:         let mut fault = None;",
          "1534:         for instance in self.instances.iter() {",
          "1535:             if let Some(f) = instance.handle.wasm_fault(addr) {",
          "1536:                 assert!(fault.is_none());",
          "1537:                 fault = Some(f);",
          "1538:             }",
          "1539:         }",
          "1540:         if fault.is_some() {",
          "1541:             return fault;",
          "1542:         }",
          "1544:         eprintln!(",
          "1545:             \"\\",
          "1546: Wasmtime caught a segfault for a wasm program because the faulting instruction",
          "1547: is allowed to segfault due to how linear memories are implemented. The address",
          "1548: that was accessed, however, is not known to any linear memory in use within this",
          "1549: Store. This may be indicative of a critical bug in Wasmtime's code generation",
          "1550: because all addresses which are known to be reachable from wasm won't reach this",
          "1551: message.",
          "1553:     pc:      0x{pc:x}",
          "1554:     address: 0x{addr:x}",
          "1556: This is a possible security issue because WebAssembly has accessed something it",
          "1557: shouldn't have been able to. Other accesses may have succeeded and this one just",
          "1558: happened to be caught. The process will now be aborted to prevent this damage",
          "1559: from going any further and to alert what's going on. If this is a security",
          "1560: issue please reach out to the Wasmtime team via its security policy",
          "1561: at https://bytecodealliance.org/security.",
          "1562: \"",
          "1563:         );",
          "1564:         std::process::abort();",
          "1565:     }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs": [
          "File: crates/wasmtime/src/trampoline/memory.rs -> crates/wasmtime/src/trampoline/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use crate::MemoryType;",
          "5: use anyhow::{anyhow, Result};",
          "6: use std::convert::TryFrom;",
          "7: use std::sync::Arc;",
          "8: use wasmtime_environ::{",
          "9:     DefinedMemoryIndex, DefinedTableIndex, EntityIndex, MemoryPlan, MemoryStyle, Module,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: use std::ops::Range;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:     fn as_any_mut(&mut self) -> &mut dyn std::any::Any {",
          "100:         self",
          "101:     }",
          "102: }",
          "104: #[derive(Clone)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104:     fn wasm_accessible(&self) -> Range<usize> {",
          "105:         self.mem.wasm_accessible()",
          "106:     }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trap.rs||crates/wasmtime/src/trap.rs": [
          "File: crates/wasmtime/src/trap.rs -> crates/wasmtime/src/trap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:             );",
          "104:             (error, None)",
          "105:         }",
          "107:             let code = store",
          "108:                 .modules()",
          "109:                 .lookup_trap_code(pc)",
          "110:                 .unwrap_or(Trap::StackOverflow);",
          "112:         }",
          "113:         wasmtime_runtime::TrapReason::Wasm(trap_code) => (trap_code.into(), None),",
          "114:     };",
          "",
          "[Removed Lines]",
          "106:         wasmtime_runtime::TrapReason::Jit(pc) => {",
          "111:             (code.into(), Some(pc))",
          "",
          "[Added Lines]",
          "106:         wasmtime_runtime::TrapReason::Jit { pc, faulting_addr } => {",
          "111:             let mut err: Error = code.into();",
          "117:             if let Some(fault) = faulting_addr.and_then(|addr| store.wasm_fault(pc, addr)) {",
          "118:                 err = err.context(fault);",
          "119:             }",
          "120:             (err, Some(pc))",
          "",
          "---------------"
        ],
        "tests/all/memory_creator.rs||tests/all/memory_creator.rs": [
          "File: tests/all/memory_creator.rs -> tests/all/memory_creator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6:     use rustix::mm::{mmap_anonymous, mprotect, munmap, MapFlags, MprotectFlags, ProtFlags};",
          "8:     use std::convert::TryFrom;",
          "9:     use std::ptr::null_mut;",
          "10:     use std::sync::{Arc, Mutex};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9:     use std::ops::Range;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:         fn as_ptr(&self) -> *mut u8 {",
          "75:             self.mem as *mut u8",
          "76:         }",
          "77:     }",
          "79:     struct CustomMemoryCreator {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79:         fn wasm_accessible(&self) -> Range<usize> {",
          "80:             let base = self.mem as usize;",
          "81:             let end = base + self.size;",
          "82:             base..end",
          "83:         }",
          "",
          "---------------"
        ],
        "tests/all/traps.rs||tests/all/traps.rs": [
          "File: tests/all/traps.rs -> tests/all/traps.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1279:         }",
          "1280:     }",
          "1281: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1283: #[test]",
          "1284: fn wasm_fault_address_reported_by_default() -> Result<()> {",
          "1285:     let engine = Engine::default();",
          "1286:     let mut store = Store::new(&engine, ());",
          "1287:     let module = Module::new(",
          "1288:         &engine,",
          "1289:         r#\"",
          "1290:             (module",
          "1291:                 (memory 1)",
          "1292:                 (func $start",
          "1293:                     i32.const 0xdeadbeef",
          "1294:                     i32.load",
          "1295:                     drop)",
          "1296:                 (start $start)",
          "1297:             )",
          "1298:         \"#,",
          "1299:     )?;",
          "1300:     let err = Instance::new(&mut store, &module, &[]).unwrap_err();",
          "1304:     let mut expected_addr = 0xdeadbeef_u32;",
          "1305:     if cfg!(target_arch = \"s390x\") {",
          "1306:         expected_addr &= 0xfffff000;",
          "1307:     }",
          "1314:     let err = format!(\"{err:?}\");",
          "1315:     assert!(",
          "1316:         err.contains(&format!(",
          "1317:             \"memory fault at wasm address 0x{expected_addr:x} in linear memory of size 0x10000\"",
          "1318:         )),",
          "1319:         \"bad error: {err}\"",
          "1320:     );",
          "1321:     Ok(())",
          "1322: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-35872",
  "cve_desc": "An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via the repr(Rust) type.",
  "repo": "rusqlite/rusqlite",
  "patch_hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
  "patch_info": {
    "commit_hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
    "repo": "rusqlite/rusqlite",
    "commit_url": "https://github.com/rusqlite/rusqlite/commit/71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
    "files": [
      "src/functions.rs"
    ],
    "message": "Ensure type use for auxdata is repr(C)",
    "before_after_code_files": [
      "src/functions.rs||src/functions.rs"
    ]
  },
  "patch_diff": {
    "src/functions.rs||src/functions.rs": [
      "File: src/functions.rs -> src/functions.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "70: use std::os::raw::{c_int, c_void};",
      "71: use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};",
      "72: use std::ptr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "70: use std::any::TypeId;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "179:     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {",
      "181:         unsafe {",
      "182:             ffi::sqlite3_set_auxdata(",
      "183:                 self.ctx,",
      "184:                 arg,",
      "185:                 boxed as *mut c_void,",
      "187:             )",
      "188:         };",
      "189:     }",
      "",
      "[Removed Lines]",
      "180:         let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));",
      "186:                 Some(free_boxed_value::<(std::any::TypeId, T)>),",
      "",
      "[Added Lines]",
      "181:         let boxed = Box::into_raw(Box::new(AuxData {",
      "182:             id: TypeId::of::<T>(),",
      "183:             value,",
      "184:         }));",
      "190:                 Some(free_boxed_value::<AuxData<T>>),",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "194:     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {",
      "196:         if p.is_null() {",
      "197:             Ok(None)",
      "198:         } else {",
      "201:                 Err(Error::GetAuxWrongType)",
      "202:             } else {",
      "204:             }",
      "205:         }",
      "206:     }",
      "207: }",
      "",
      "[Removed Lines]",
      "195:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };",
      "199:             let id_val = unsafe { &*p };",
      "200:             if std::any::TypeId::of::<T>() != id_val.0 {",
      "203:                 Ok(Some(&id_val.1))",
      "",
      "[Added Lines]",
      "199:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };",
      "203:             let id = unsafe { (*p).id };",
      "204:             if TypeId::of::<T>() != id {",
      "207:                 Ok(Some(unsafe { &(*p).value }))",
      "213: #[repr(C)]",
      "214: struct AuxData<T: 'static> {",
      "215:     id: TypeId,",
      "216:     value: T,",
      "217: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1b27ce0541a136b50492a816550e170b9913803f",
      "candidate_info": {
        "commit_hash": "1b27ce0541a136b50492a816550e170b9913803f",
        "repo": "rusqlite/rusqlite",
        "commit_url": "https://github.com/rusqlite/rusqlite/commit/1b27ce0541a136b50492a816550e170b9913803f",
        "files": [
          "src/functions.rs"
        ],
        "message": "Docs for new aux api",
        "before_after_code_files": [
          "src/functions.rs||src/functions.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/rusqlite/rusqlite/pull/701"
        ],
        "olp_code_files": {
          "patch": [
            "src/functions.rs||src/functions.rs"
          ],
          "candidate": [
            "src/functions.rs||src/functions.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/functions.rs||src/functions.rs": [
          "File: src/functions.rs -> src/functions.rs"
        ]
      }
    },
    {
      "candidate_hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
      "candidate_info": {
        "commit_hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
        "repo": "rusqlite/rusqlite",
        "commit_url": "https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
        "files": [
          "src/functions.rs"
        ],
        "message": "Actually fix auxdata api...",
        "before_after_code_files": [
          "src/functions.rs||src/functions.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/functions.rs||src/functions.rs"
          ],
          "candidate": [
            "src/functions.rs||src/functions.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/functions.rs||src/functions.rs": [
          "File: src/functions.rs -> src/functions.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: use std::os::raw::{c_int, c_void};",
          "72: use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};",
          "73: use std::ptr;",
          "74: use std::slice;",
          "76: use crate::ffi;",
          "77: use crate::ffi::sqlite3_context;",
          "",
          "[Removed Lines]",
          "70: use std::any::TypeId;",
          "",
          "[Added Lines]",
          "57: use std::any::Any;",
          "62: use std::sync::Arc;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:         unsafe { ValueRef::from_value(arg) }",
          "175:     }",
          "185:         unsafe {",
          "186:             ffi::sqlite3_set_auxdata(",
          "187:                 self.ctx,",
          "188:                 arg,",
          "191:             )",
          "192:         };",
          "193:     }",
          "200:         if p.is_null() {",
          "201:             Ok(None)",
          "202:         } else {",
          "209:         }",
          "210:     }",
          "211: }",
          "",
          "[Removed Lines]",
          "180:     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {",
          "181:         let boxed = Box::into_raw(Box::new(AuxData {",
          "182:             id: TypeId::of::<T>(),",
          "183:             value,",
          "184:         }));",
          "189:                 boxed as *mut c_void,",
          "190:                 Some(free_boxed_value::<AuxData<T>>),",
          "198:     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {",
          "199:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };",
          "203:             let id = unsafe { (*p).id };",
          "204:             if TypeId::of::<T>() != id {",
          "205:                 Err(Error::GetAuxWrongType)",
          "206:             } else {",
          "207:                 Ok(Some(unsafe { &(*p).value }))",
          "208:             }",
          "213: #[repr(C)]",
          "214: struct AuxData<T: 'static> {",
          "215:     id: TypeId,",
          "216:     value: T,",
          "217: }",
          "",
          "[Added Lines]",
          "166:     pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>",
          "167:     where",
          "168:         T: Send + Sync + 'static,",
          "169:         E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,",
          "170:         F: FnOnce(ValueRef<'_>) -> Result<T, E>,",
          "171:     {",
          "172:         if let Some(v) = self.get_aux(arg)? {",
          "173:             Ok(v)",
          "174:         } else {",
          "175:             let vr = self.get_raw(arg as usize);",
          "176:             self.set_aux(",
          "177:                 arg,",
          "178:                 func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,",
          "179:             )",
          "180:         }",
          "181:     }",
          "186:     pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {",
          "187:         let orig: Arc<T> = Arc::new(value);",
          "188:         let inner: AuxInner = orig.clone();",
          "189:         let outer = Box::new(inner);",
          "190:         let raw: *mut AuxInner = Box::into_raw(outer);",
          "195:                 raw as *mut _,",
          "196:                 Some(free_boxed_value::<AuxInner>),",
          "199:         Ok(orig)",
          "206:     pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {",
          "207:         let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };",
          "211:             let v: AuxInner = AuxInner::clone(unsafe { &*p });",
          "212:             v.downcast::<T>()",
          "213:                 .map(Some)",
          "214:                 .map_err(|_| Error::GetAuxWrongType)",
          "219: type AuxInner = Arc<dyn Any + Send + Sync + 'static>;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "777:     fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {",
          "778:         assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");",
          "792:         let is_match = {",
          "795:             let text = ctx",
          "796:                 .get_raw(1)",
          "797:                 .as_str()",
          "798:                 .map_err(|e| Error::UserFunctionError(e.into()))?;",
          "801:         };",
          "807:         Ok(is_match)",
          "808:     }",
          "",
          "[Removed Lines]",
          "780:         let saved_re: Option<&Regex> = ctx.get_aux(0)?;",
          "781:         let new_re = match saved_re {",
          "782:             None => {",
          "783:                 let s = ctx.get::<String>(0)?;",
          "784:                 match Regex::new(&s) {",
          "785:                     Ok(r) => Some(r),",
          "786:                     Err(err) => return Err(Error::UserFunctionError(Box::new(err))),",
          "787:                 }",
          "788:             }",
          "789:             Some(_) => None,",
          "790:         };",
          "793:             let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());",
          "800:             re.is_match(text)",
          "803:         if let Some(re) = new_re {",
          "804:             ctx.set_aux(0, re);",
          "805:         }",
          "",
          "[Added Lines]",
          "781:         type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;",
          "782:         let regexp: std::sync::Arc<Regex> = ctx",
          "783:             .get_or_create_aux(0, |vr| -> Result<_, BoxError> {",
          "784:                 Ok(Regex::new(vr.as_str()?)?)",
          "785:             })?;",
          "793:             regexp.is_match(text)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "878:         let db = Connection::open_in_memory().unwrap();",
          "879:         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {",
          "880:             if !ctx.get::<bool>(1)? {",
          "882:             } else {",
          "883:                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));",
          "885:             }",
          "886:             Ok(true)",
          "887:         })",
          "",
          "[Removed Lines]",
          "881:                 ctx.set_aux::<i64>(0, 100);",
          "884:                 assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));",
          "",
          "[Added Lines]",
          "870:                 ctx.set_aux::<i64>(0, 100)?;",
          "873:                 assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
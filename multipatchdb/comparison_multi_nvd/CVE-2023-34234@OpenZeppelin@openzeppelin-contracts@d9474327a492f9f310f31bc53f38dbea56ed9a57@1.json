{
  "cve_id": "CVE-2023-34234",
  "cve_desc": " OpenZeppelin Contracts is a library for smart contract development. By frontrunning the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. This impacts the `Governor` contract in v4.9.0 only, and the `GovernorCompatibilityBravo` contract since v4.3.0. This problem has been patched in 4.9.1 by introducing opt-in frontrunning protection. Users are advised to upgrade. Users unable to upgrade may submit the proposal creation transaction to an endpoint with frontrunning protection as a workaround.",
  "repo": "OpenZeppelin/openzeppelin-contracts",
  "patch_hash": "d9474327a492f9f310f31bc53f38dbea56ed9a57",
  "patch_info": {
    "commit_hash": "d9474327a492f9f310f31bc53f38dbea56ed9a57",
    "repo": "OpenZeppelin/openzeppelin-contracts",
    "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/d9474327a492f9f310f31bc53f38dbea56ed9a57",
    "files": [
      ".changeset/swift-bags-divide.md",
      "contracts/governance/Governor.sol",
      "test/governance/Governor.t.sol",
      "test/governance/Governor.test.js"
    ],
    "message": "Merge pull request from GHSA-5h3x-9wvq-w4m2\n\nCo-authored-by: Francisco <fg@frang.io>\nCo-authored-by: Ernesto Garc\u00eda <ernestognw@gmail.com>",
    "before_after_code_files": [
      "contracts/governance/Governor.sol||contracts/governance/Governor.sol",
      "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
      "test/governance/Governor.test.js||test/governance/Governor.test.js"
    ]
  },
  "patch_diff": {
    "contracts/governance/Governor.sol||contracts/governance/Governor.sol": [
      "File: contracts/governance/Governor.sol -> contracts/governance/Governor.sol",
      "--- Hunk 1 ---",
      "[Context before]",
      "272:         string memory description",
      "273:     ) public virtual override returns (uint256) {",
      "274:         address proposer = _msgSender();",
      "277:         require(",
      "278:             getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
      "279:             \"Governor: proposer votes below proposal threshold\"",
      "",
      "[Removed Lines]",
      "275:         uint256 currentTimepoint = clock();",
      "",
      "[Added Lines]",
      "275:         require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");",
      "277:         uint256 currentTimepoint = clock();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "628:     ) public virtual returns (bytes4) {",
      "629:         return this.onERC1155BatchReceived.selector;",
      "630:     }",
      "631: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "650:     function _isValidDescriptionForProposer(",
      "651:         address proposer,",
      "652:         string memory description",
      "653:     ) internal view virtual returns (bool) {",
      "654:         uint256 len = bytes(description).length;",
      "657:         if (len < 52) {",
      "658:             return true;",
      "659:         }",
      "662:         bytes12 marker;",
      "663:         assembly {",
      "670:             marker := mload(add(description, sub(len, 20)))",
      "671:         }",
      "674:         if (marker != bytes12(\"#proposer=0x\")) {",
      "675:             return true;",
      "676:         }",
      "679:         uint160 recovered = 0;",
      "680:         for (uint256 i = len - 40; i < len; ++i) {",
      "681:             (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);",
      "683:             if (!isHex) {",
      "684:                 return true;",
      "685:             }",
      "686:             recovered = (recovered << 4) | value;",
      "687:         }",
      "689:         return recovered == uint160(proposer);",
      "690:     }",
      "696:     function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {",
      "697:         uint8 c = uint8(char);",
      "698:         unchecked {",
      "700:             if (47 < c && c < 58) {",
      "701:                 return (true, c - 48);",
      "702:             }",
      "704:             else if (64 < c && c < 71) {",
      "705:                 return (true, c - 55);",
      "706:             }",
      "708:             else if (96 < c && c < 103) {",
      "709:                 return (true, c - 87);",
      "710:             }",
      "712:             else {",
      "713:                 return (false, 0);",
      "714:             }",
      "715:         }",
      "716:     }",
      "",
      "---------------"
    ],
    "test/governance/Governor.t.sol||test/governance/Governor.t.sol": [
      "File: test/governance/Governor.t.sol -> test/governance/Governor.t.sol",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: pragma solidity ^0.8.19;",
      "5: import \"forge-std/Test.sol\";",
      "6: import \"../../contracts/utils/Strings.sol\";",
      "7: import \"../../contracts/governance/Governor.sol\";",
      "9: contract GovernorInternalTest is Test, Governor {",
      "10:     constructor() Governor(\"\") {}",
      "12:     function testValidDescriptionForProposer(string memory description, address proposer, bool includeProposer) public {",
      "13:         if (includeProposer) {",
      "14:             description = string.concat(description, \"#proposer=\", Strings.toHexString(proposer));",
      "15:         }",
      "16:         assertTrue(_isValidDescriptionForProposer(proposer, description));",
      "17:     }",
      "19:     function testInvalidDescriptionForProposer(",
      "20:         string memory description,",
      "21:         address commitProposer,",
      "22:         address actualProposer",
      "23:     ) public {",
      "24:         vm.assume(commitProposer != actualProposer);",
      "25:         description = string.concat(description, \"#proposer=\", Strings.toHexString(commitProposer));",
      "26:         assertFalse(_isValidDescriptionForProposer(actualProposer, description));",
      "27:     }",
      "32:     function clock() public pure override returns (uint48) {}",
      "35:     function CLOCK_MODE() public pure override returns (string memory) {}",
      "38:     function COUNTING_MODE() public pure virtual override returns (string memory) {}",
      "40:     function votingDelay() public pure virtual override returns (uint256) {}",
      "42:     function votingPeriod() public pure virtual override returns (uint256) {}",
      "44:     function quorum(uint256) public pure virtual override returns (uint256) {}",
      "46:     function hasVoted(uint256, address) public pure virtual override returns (bool) {}",
      "48:     function _quorumReached(uint256) internal pure virtual override returns (bool) {}",
      "50:     function _voteSucceeded(uint256) internal pure virtual override returns (bool) {}",
      "52:     function _getVotes(address, uint256, bytes memory) internal pure virtual override returns (uint256) {}",
      "54:     function _countVote(uint256, address, uint8, uint256, bytes memory) internal virtual override {}",
      "55: }",
      "",
      "---------------"
    ],
    "test/governance/Governor.test.js||test/governance/Governor.test.js": [
      "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:         });",
      "552:       });",
      "554:       describe('onlyGovernance updates', function () {",
      "555:         it('setVotingDelay is protected', async function () {",
      "556:           await expectRevert(this.mock.setVotingDelay('0'), 'Governor: onlyGovernance');",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "554:       describe('frontrun protection using description suffix', function () {",
      "555:         describe('without protection', function () {",
      "556:           describe('without suffix', function () {",
      "557:             it('proposer can propose', async function () {",
      "558:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "559:             });",
      "561:             it('someone else can propose', async function () {",
      "562:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "563:             });",
      "564:           });",
      "566:           describe('with different suffix', function () {",
      "567:             beforeEach(async function () {",
      "568:               this.proposal = this.helper.setProposal(",
      "569:                 [",
      "570:                   {",
      "571:                     target: this.receiver.address,",
      "572:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "573:                     value,",
      "574:                   },",
      "575:                 ],",
      "576:                 `<proposal description>#wrong-suffix=${proposer}`,",
      "577:               );",
      "578:             });",
      "580:             it('proposer can propose', async function () {",
      "581:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "582:             });",
      "584:             it('someone else can propose', async function () {",
      "585:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "586:             });",
      "587:           });",
      "589:           describe('with proposer suffix but bad address part', function () {",
      "590:             beforeEach(async function () {",
      "591:               this.proposal = this.helper.setProposal(",
      "592:                 [",
      "593:                   {",
      "594:                     target: this.receiver.address,",
      "595:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "596:                     value,",
      "597:                   },",
      "598:                 ],",
      "599:                 `<proposal description>#proposer=0x3C44CdDdB6a900fa2b585dd299e03d12FA429XYZ`, // XYZ are not a valid hex char",
      "600:               );",
      "601:             });",
      "603:             it('propose can propose', async function () {",
      "604:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "605:             });",
      "607:             it('someone else can propose', async function () {",
      "608:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "609:             });",
      "610:           });",
      "611:         });",
      "613:         describe('with protection via proposer suffix', function () {",
      "614:           beforeEach(async function () {",
      "615:             this.proposal = this.helper.setProposal(",
      "616:               [",
      "617:                 {",
      "618:                   target: this.receiver.address,",
      "619:                   data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "620:                   value,",
      "621:                 },",
      "622:               ],",
      "623:               `<proposal description>#proposer=${proposer}`,",
      "624:             );",
      "625:           });",
      "627:           it('proposer can propose', async function () {",
      "628:             expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "629:           });",
      "631:           it('someone else cannot propose', async function () {",
      "632:             await expectRevert(this.helper.propose({ from: voter1 }), 'Governor: proposer restricted');",
      "633:           });",
      "634:         });",
      "635:       });",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c3cd70811b0993aab26840034c47e63fb3a2c993",
      "candidate_info": {
        "commit_hash": "c3cd70811b0993aab26840034c47e63fb3a2c993",
        "repo": "OpenZeppelin/openzeppelin-contracts",
        "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/c3cd70811b0993aab26840034c47e63fb3a2c993",
        "files": [
          "package-lock.json",
          "package.json",
          "test/governance/Governor.test.js",
          "test/governance/TimelockController.test.js",
          "test/governance/extensions/GovernorERC721.test.js",
          "test/governance/extensions/GovernorPreventLateQuorum.test.js",
          "test/governance/extensions/GovernorStorage.test.js",
          "test/governance/extensions/GovernorTimelockAccess.test.js",
          "test/governance/extensions/GovernorTimelockCompound.test.js",
          "test/governance/extensions/GovernorTimelockControl.test.js",
          "test/governance/extensions/GovernorVotesQuorumFraction.test.js",
          "test/governance/extensions/GovernorWithParams.test.js",
          "test/governance/utils/ERC6372.behavior.js",
          "test/governance/utils/Votes.behavior.js",
          "test/governance/utils/Votes.test.js",
          "test/helpers/governance.js",
          "test/helpers/iterate.js",
          "test/helpers/time.js",
          "test/helpers/txpool.js",
          "test/token/ERC20/extensions/ERC20Permit.test.js",
          "test/token/ERC20/extensions/ERC20Votes.test.js",
          "test/token/ERC721/extensions/ERC721Votes.test.js"
        ],
        "message": "Migrate governance tests to ethers.js (#4728)\n\nCo-authored-by: ernestognw <ernestognw@gmail.com>\nCo-authored-by: Hadrien Croubois <hadrien.croubois@gmail.com>",
        "before_after_code_files": [
          "test/governance/Governor.test.js||test/governance/Governor.test.js",
          "test/governance/TimelockController.test.js||test/governance/TimelockController.test.js",
          "test/governance/extensions/GovernorERC721.test.js||test/governance/extensions/GovernorERC721.test.js",
          "test/governance/extensions/GovernorPreventLateQuorum.test.js||test/governance/extensions/GovernorPreventLateQuorum.test.js",
          "test/governance/extensions/GovernorStorage.test.js||test/governance/extensions/GovernorStorage.test.js",
          "test/governance/extensions/GovernorTimelockAccess.test.js||test/governance/extensions/GovernorTimelockAccess.test.js",
          "test/governance/extensions/GovernorTimelockCompound.test.js||test/governance/extensions/GovernorTimelockCompound.test.js",
          "test/governance/extensions/GovernorTimelockControl.test.js||test/governance/extensions/GovernorTimelockControl.test.js",
          "test/governance/extensions/GovernorVotesQuorumFraction.test.js||test/governance/extensions/GovernorVotesQuorumFraction.test.js",
          "test/governance/extensions/GovernorWithParams.test.js||test/governance/extensions/GovernorWithParams.test.js",
          "test/governance/utils/ERC6372.behavior.js||test/governance/utils/ERC6372.behavior.js",
          "test/governance/utils/Votes.behavior.js||test/governance/utils/Votes.behavior.js",
          "test/governance/utils/Votes.test.js||test/governance/utils/Votes.test.js",
          "test/helpers/governance.js||test/helpers/governance.js",
          "test/helpers/iterate.js||test/helpers/iterate.js",
          "test/helpers/time.js||test/helpers/time.js",
          "test/helpers/txpool.js||test/helpers/txpool.js",
          "test/token/ERC20/extensions/ERC20Permit.test.js||test/token/ERC20/extensions/ERC20Permit.test.js",
          "test/token/ERC20/extensions/ERC20Votes.test.js||test/token/ERC20/extensions/ERC20Votes.test.js",
          "test/token/ERC721/extensions/ERC721Votes.test.js||test/token/ERC721/extensions/ERC721Votes.test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ],
          "candidate": [
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ]
        }
      },
      "candidate_diff": {
        "test/governance/Governor.test.js||test/governance/Governor.test.js": [
          "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "12: const { shouldSupportInterfaces } = require('../utils/introspection/SupportsInterface.behavior');",
          "13: const { shouldBehaveLikeERC6372 } = require('./utils/ERC6372.behavior');",
          "22: const TOKENS = [",
          "26: ];",
          "42:       beforeEach(async function () {",
          "70:         this.proposal = this.helper.setProposal(",
          "71:           [",
          "72:             {",
          "75:               value,",
          "76:             },",
          "77:           ],",
          "",
          "[Removed Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const ethSigUtil = require('eth-sig-util');",
          "4: const Wallet = require('ethereumjs-wallet').default;",
          "6: const Enums = require('../helpers/enums');",
          "7: const { getDomain, domainType, Ballot } = require('../helpers/eip712');",
          "8: const { GovernorHelper, proposalStatesToBitMap } = require('../helpers/governance');",
          "9: const { clockFromReceipt } = require('../helpers/time');",
          "10: const { expectRevertCustomError } = require('../helpers/customError');",
          "14: const { ZERO_BYTES32 } = require('@openzeppelin/test-helpers/src/constants');",
          "16: const Governor = artifacts.require('$GovernorMock');",
          "17: const CallReceiver = artifacts.require('CallReceiverMock');",
          "18: const ERC721 = artifacts.require('$ERC721');",
          "19: const ERC1155 = artifacts.require('$ERC1155');",
          "20: const ERC1271WalletMock = artifacts.require('ERC1271WalletMock');",
          "23:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "24:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "25:   { Token: artifacts.require('$ERC20VotesLegacyMock'), mode: 'blocknumber' },",
          "28: contract('Governor', function (accounts) {",
          "29:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "31:   const name = 'OZ-Governor';",
          "32:   const version = '1';",
          "33:   const tokenName = 'MockToken';",
          "34:   const tokenSymbol = 'MTKN';",
          "35:   const tokenSupply = web3.utils.toWei('100');",
          "36:   const votingDelay = web3.utils.toBN(4);",
          "37:   const votingPeriod = web3.utils.toBN(16);",
          "38:   const value = web3.utils.toWei('1');",
          "40:   for (const { mode, Token } of TOKENS) {",
          "41:     describe(`using ${Token._json.contractName}`, function () {",
          "43:         this.chainId = await web3.eth.getChainId();",
          "44:         try {",
          "45:           this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "46:         } catch {",
          "48:           this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "49:         }",
          "50:         this.mock = await Governor.new(",
          "51:           name, // name",
          "52:           votingDelay, // initialVotingDelay",
          "53:           votingPeriod, // initialVotingPeriod",
          "54:           0, // initialProposalThreshold",
          "55:           this.token.address, // tokenAddress",
          "56:           10, // quorumNumeratorValue",
          "57:         );",
          "58:         this.receiver = await CallReceiver.new();",
          "60:         this.helper = new GovernorHelper(this.mock, mode);",
          "62:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "64:         await this.token.$_mint(owner, tokenSupply);",
          "65:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "66:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "67:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "68:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "73:               target: this.receiver.address,",
          "74:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { GovernorHelper } = require('../helpers/governance');",
          "6: const { getDomain, Ballot } = require('../helpers/eip712');",
          "7: const { bigint: Enums } = require('../helpers/enums');",
          "8: const { bigint: time } = require('../helpers/time');",
          "14:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "15:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "16:   { Token: '$ERC20VotesLegacyMock', mode: 'blocknumber' },",
          "19: const name = 'OZ-Governor';",
          "20: const version = '1';",
          "21: const tokenName = 'MockToken';",
          "22: const tokenSymbol = 'MTKN';",
          "23: const tokenSupply = ethers.parseEther('100');",
          "24: const votingDelay = 4n;",
          "25: const votingPeriod = 16n;",
          "26: const value = ethers.parseEther('1');",
          "28: const signBallot = account => (contract, message) =>",
          "29:   getDomain(contract).then(domain => account.signTypedData(domain, { Ballot }, message));",
          "31: async function deployToken(contractName) {",
          "32:   try {",
          "33:     return await ethers.deployContract(contractName, [tokenName, tokenSymbol, tokenName, version]);",
          "34:   } catch (error) {",
          "35:     if (error.message == 'incorrect number of arguments to constructor') {",
          "37:       return ethers.deployContract(contractName, [tokenName, tokenSymbol, tokenName]);",
          "38:     }",
          "39:     throw error;",
          "40:   }",
          "41: }",
          "43: describe('Governor', function () {",
          "44:   for (const { Token, mode } of TOKENS) {",
          "45:     const fixture = async () => {",
          "46:       const [owner, proposer, voter1, voter2, voter3, voter4, userEOA] = await ethers.getSigners();",
          "47:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "49:       const token = await deployToken(Token, [tokenName, tokenSymbol, version]);",
          "50:       const mock = await ethers.deployContract('$GovernorMock', [",
          "51:         name, // name",
          "52:         votingDelay, // initialVotingDelay",
          "53:         votingPeriod, // initialVotingPeriod",
          "54:         0n, // initialProposalThreshold",
          "55:         token, // tokenAddress",
          "56:         10n, // quorumNumeratorValue",
          "57:       ]);",
          "59:       await owner.sendTransaction({ to: mock, value });",
          "60:       await token.$_mint(owner, tokenSupply);",
          "62:       const helper = new GovernorHelper(mock, mode);",
          "63:       await helper.connect(owner).delegate({ token: token, to: voter1, value: ethers.parseEther('10') });",
          "64:       await helper.connect(owner).delegate({ token: token, to: voter2, value: ethers.parseEther('7') });",
          "65:       await helper.connect(owner).delegate({ token: token, to: voter3, value: ethers.parseEther('5') });",
          "66:       await helper.connect(owner).delegate({ token: token, to: voter4, value: ethers.parseEther('2') });",
          "68:       return {",
          "69:         owner,",
          "70:         proposer,",
          "71:         voter1,",
          "72:         voter2,",
          "73:         voter3,",
          "74:         voter4,",
          "75:         userEOA,",
          "76:         receiver,",
          "77:         token,",
          "78:         mock,",
          "79:         helper,",
          "80:       };",
          "81:     };",
          "83:     describe(`using ${Token}`, function () {",
          "85:         Object.assign(this, await loadFixture(fixture));",
          "90:               target: this.receiver.target,",
          "91:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:       shouldBehaveLikeERC6372(mode);",
          "85:       it('deployment check', async function () {",
          "92:       });",
          "94:       it('nominal workflow', async function () {",
          "124:         await this.helper.waitForSnapshot();",
          "155:         await this.helper.waitForDeadline();",
          "157:         const txExecute = await this.helper.execute();",
          "173:       });",
          "175:       it('send ethers', async function () {",
          "179:           [",
          "180:             {",
          "182:               value,",
          "183:             },",
          "184:           ],",
          "185:           '<proposal description>',",
          "186:         );",
          "202:       });",
          "204:       describe('vote with signature', function () {",
          "226:         it('votes with an EOA signature', async function () {",
          "235:           await this.helper.propose();",
          "236:           await this.helper.waitForSnapshot();",
          "239:               support: Enums.VoteType.For,",
          "241:               nonce,",
          "243:             }),",
          "250:           await this.helper.waitForDeadline();",
          "251:           await this.helper.execute();",
          "256:         });",
          "258:         it('votes with a valid EIP-1271 signature', async function () {",
          "269:           await this.helper.propose();",
          "270:           await this.helper.waitForSnapshot();",
          "273:               support: Enums.VoteType.For,",
          "275:               nonce,",
          "277:             }),",
          "284:           await this.helper.waitForDeadline();",
          "285:           await this.helper.execute();",
          "290:         });",
          "292:         afterEach('no other votes are cast', async function () {",
          "296:         });",
          "297:       });",
          "",
          "[Removed Lines]",
          "86:         expect(await this.mock.name()).to.be.equal(name);",
          "87:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "88:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "89:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "90:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "91:         expect(await this.mock.COUNTING_MODE()).to.be.equal('support=bravo&quorum=for,abstain');",
          "96:         expect(await this.mock.proposalProposer(this.proposal.id)).to.be.equal(constants.ZERO_ADDRESS);",
          "97:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "98:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "99:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "100:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(value);",
          "101:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal('0');",
          "103:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal('0');",
          "104:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(false);",
          "107:         const txPropose = await this.helper.propose({ from: proposer });",
          "109:         expectEvent(txPropose, 'ProposalCreated', {",
          "110:           proposalId: this.proposal.id,",
          "111:           proposer,",
          "112:           targets: this.proposal.targets,",
          "114:           signatures: this.proposal.signatures,",
          "115:           calldatas: this.proposal.data,",
          "116:           voteStart: web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay),",
          "117:           voteEnd: web3.utils",
          "118:             .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "119:             .add(votingDelay)",
          "120:             .add(votingPeriod),",
          "121:           description: this.proposal.description,",
          "122:         });",
          "126:         expectEvent(",
          "127:           await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 }),",
          "128:           'VoteCast',",
          "129:           {",
          "130:             voter: voter1,",
          "131:             support: Enums.VoteType.For,",
          "132:             reason: 'This is nice',",
          "133:             weight: web3.utils.toWei('10'),",
          "134:           },",
          "135:         );",
          "137:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 }), 'VoteCast', {",
          "138:           voter: voter2,",
          "139:           support: Enums.VoteType.For,",
          "140:           weight: web3.utils.toWei('7'),",
          "141:         });",
          "143:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 }), 'VoteCast', {",
          "144:           voter: voter3,",
          "145:           support: Enums.VoteType.Against,",
          "146:           weight: web3.utils.toWei('5'),",
          "147:         });",
          "149:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 }), 'VoteCast', {",
          "150:           voter: voter4,",
          "151:           support: Enums.VoteType.Abstain,",
          "152:           weight: web3.utils.toWei('2'),",
          "153:         });",
          "159:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "161:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "164:         expect(await this.mock.proposalProposer(this.proposal.id)).to.be.equal(proposer);",
          "165:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "166:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "167:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "168:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "169:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal(value);",
          "171:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal('0');",
          "172:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(false);",
          "176:         const empty = web3.utils.toChecksumAddress(web3.utils.randomHex(20));",
          "178:         this.proposal = this.helper.setProposal(",
          "181:               target: empty,",
          "189:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(value);",
          "190:         expect(await web3.eth.getBalance(empty)).to.be.bignumber.equal('0');",
          "193:         await this.helper.propose();",
          "194:         await this.helper.waitForSnapshot();",
          "195:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "196:         await this.helper.waitForDeadline();",
          "197:         await this.helper.execute();",
          "200:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "201:         expect(await web3.eth.getBalance(empty)).to.be.bignumber.equal(value);",
          "205:         const sign = privateKey => async (contract, message) => {",
          "206:           const domain = await getDomain(contract);",
          "207:           return ethSigUtil.signTypedMessage(privateKey, {",
          "208:             data: {",
          "209:               primaryType: 'Ballot',",
          "210:               types: {",
          "211:                 EIP712Domain: domainType(domain),",
          "212:                 Ballot,",
          "213:               },",
          "214:               domain,",
          "215:               message,",
          "216:             },",
          "217:           });",
          "218:         };",
          "220:         afterEach('no other votes are cast for proposalId', async function () {",
          "221:           expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "222:           expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "223:           expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "224:         });",
          "227:           const voterBySig = Wallet.generate();",
          "228:           const voterBySigAddress = web3.utils.toChecksumAddress(voterBySig.getAddressString());",
          "230:           await this.token.delegate(voterBySigAddress, { from: voter1 });",
          "232:           const nonce = await this.mock.nonces(voterBySigAddress);",
          "237:           expectEvent(",
          "238:             await this.helper.vote({",
          "240:               voter: voterBySigAddress,",
          "242:               signature: sign(voterBySig.getPrivateKey()),",
          "244:             'VoteCast',",
          "245:             {",
          "246:               voter: voterBySigAddress,",
          "247:               support: Enums.VoteType.For,",
          "248:             },",
          "249:           );",
          "254:           expect(await this.mock.hasVoted(this.proposal.id, voterBySigAddress)).to.be.equal(true);",
          "255:           expect(await this.mock.nonces(voterBySigAddress)).to.be.bignumber.equal(nonce.addn(1));",
          "259:           const ERC1271WalletOwner = Wallet.generate();",
          "260:           ERC1271WalletOwner.address = web3.utils.toChecksumAddress(ERC1271WalletOwner.getAddressString());",
          "262:           const wallet = await ERC1271WalletMock.new(ERC1271WalletOwner.address);",
          "264:           await this.token.delegate(wallet.address, { from: voter1 });",
          "266:           const nonce = await this.mock.nonces(wallet.address);",
          "271:           expectEvent(",
          "272:             await this.helper.vote({",
          "274:               voter: wallet.address,",
          "276:               signature: sign(ERC1271WalletOwner.getPrivateKey()),",
          "278:             'VoteCast',",
          "279:             {",
          "280:               voter: wallet.address,",
          "281:               support: Enums.VoteType.For,",
          "282:             },",
          "283:           );",
          "288:           expect(await this.mock.hasVoted(this.proposal.id, wallet.address)).to.be.equal(true);",
          "289:           expect(await this.mock.nonces(wallet.address)).to.be.bignumber.equal(nonce.addn(1));",
          "293:           expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "294:           expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "295:           expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "",
          "[Added Lines]",
          "103:         expect(await this.mock.name()).to.equal(name);",
          "104:         expect(await this.mock.token()).to.equal(this.token.target);",
          "105:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "106:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "107:         expect(await this.mock.quorum(0)).to.equal(0n);",
          "108:         expect(await this.mock.COUNTING_MODE()).to.equal('support=bravo&quorum=for,abstain');",
          "113:         expect(await this.mock.proposalProposer(this.proposal.id)).to.equal(ethers.ZeroAddress);",
          "114:         expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "115:         expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.false;",
          "116:         expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.false;",
          "117:         expect(await ethers.provider.getBalance(this.mock)).to.equal(value);",
          "118:         expect(await ethers.provider.getBalance(this.receiver)).to.equal(0n);",
          "120:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(0n);",
          "121:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.false;",
          "124:         const txPropose = await this.helper.connect(this.proposer).propose();",
          "125:         const timepoint = await time.clockFromReceipt[mode](txPropose);",
          "127:         await expect(txPropose)",
          "128:           .to.emit(this.mock, 'ProposalCreated')",
          "129:           .withArgs(",
          "130:             this.proposal.id,",
          "131:             this.proposer.address,",
          "132:             this.proposal.targets,",
          "133:             this.proposal.values,",
          "134:             this.proposal.signatures,",
          "135:             this.proposal.data,",
          "136:             timepoint + votingDelay,",
          "137:             timepoint + votingDelay + votingPeriod,",
          "138:             this.proposal.description,",
          "139:           );",
          "143:         await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For, reason: 'This is nice' }))",
          "144:           .to.emit(this.mock, 'VoteCast')",
          "145:           .withArgs(this.voter1.address, this.proposal.id, Enums.VoteType.For, ethers.parseEther('10'), 'This is nice');",
          "147:         await expect(this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For }))",
          "148:           .to.emit(this.mock, 'VoteCast')",
          "149:           .withArgs(this.voter2.address, this.proposal.id, Enums.VoteType.For, ethers.parseEther('7'), '');",
          "151:         await expect(this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against }))",
          "152:           .to.emit(this.mock, 'VoteCast')",
          "153:           .withArgs(this.voter3.address, this.proposal.id, Enums.VoteType.Against, ethers.parseEther('5'), '');",
          "155:         await expect(this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain }))",
          "156:           .to.emit(this.mock, 'VoteCast')",
          "157:           .withArgs(this.voter4.address, this.proposal.id, Enums.VoteType.Abstain, ethers.parseEther('2'), '');",
          "163:         await expect(txExecute).to.emit(this.mock, 'ProposalExecuted').withArgs(this.proposal.id);",
          "165:         await expect(txExecute).to.emit(this.receiver, 'MockFunctionCalled');",
          "168:         expect(await this.mock.proposalProposer(this.proposal.id)).to.equal(this.proposer.address);",
          "169:         expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "170:         expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.true;",
          "171:         expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.true;",
          "172:         expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "173:         expect(await ethers.provider.getBalance(this.receiver)).to.equal(value);",
          "175:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(0n);",
          "176:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.false;",
          "180:         this.helper.setProposal(",
          "183:               target: this.userEOA.address,",
          "191:         await expect(async () => {",
          "192:           await this.helper.propose();",
          "193:           await this.helper.waitForSnapshot();",
          "194:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "195:           await this.helper.waitForDeadline();",
          "196:           return this.helper.execute();",
          "197:         }).to.changeEtherBalances([this.mock, this.userEOA], [-value, value]);",
          "202:           await this.token.connect(this.voter1).delegate(this.userEOA);",
          "204:           const nonce = await this.mock.nonces(this.userEOA);",
          "209:           await expect(",
          "210:             this.helper.vote({",
          "212:               voter: this.userEOA.address,",
          "214:               signature: signBallot(this.userEOA),",
          "216:           )",
          "217:             .to.emit(this.mock, 'VoteCast')",
          "218:             .withArgs(this.userEOA.address, this.proposal.id, Enums.VoteType.For, ethers.parseEther('10'), '');",
          "224:           expect(await this.mock.hasVoted(this.proposal.id, this.userEOA)).to.be.true;",
          "225:           expect(await this.mock.nonces(this.userEOA)).to.equal(nonce + 1n);",
          "229:           const wallet = await ethers.deployContract('ERC1271WalletMock', [this.userEOA]);",
          "231:           await this.token.connect(this.voter1).delegate(wallet);",
          "233:           const nonce = await this.mock.nonces(this.userEOA);",
          "238:           await expect(",
          "239:             this.helper.vote({",
          "241:               voter: wallet.target,",
          "243:               signature: signBallot(this.userEOA),",
          "245:           )",
          "246:             .to.emit(this.mock, 'VoteCast')",
          "247:             .withArgs(wallet.target, this.proposal.id, Enums.VoteType.For, ethers.parseEther('10'), '');",
          "252:           expect(await this.mock.hasVoted(this.proposal.id, wallet)).to.be.true;",
          "253:           expect(await this.mock.nonces(wallet)).to.equal(nonce + 1n);",
          "257:           expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "258:           expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.false;",
          "259:           expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "300:         describe('on propose', function () {",
          "301:           it('if proposal already exists', async function () {",
          "302:             await this.helper.propose();",
          "308:           });",
          "310:           it('if proposer has below threshold votes', async function () {",
          "313:             await this.mock.$_setProposalThreshold(threshold);",
          "319:           });",
          "320:         });",
          "322:         describe('on vote', function () {",
          "323:           it('if proposal does not exist', async function () {",
          "329:           });",
          "331:           it('if voting has not started', async function () {",
          "332:             await this.helper.propose();",
          "338:           });",
          "340:           it('if support value is invalid', async function () {",
          "341:             await this.helper.propose();",
          "342:             await this.helper.waitForSnapshot();",
          "345:               'GovernorInvalidVoteType',",
          "347:             );",
          "348:           });",
          "350:           it('if vote was already casted', async function () {",
          "351:             await this.helper.propose();",
          "352:             await this.helper.waitForSnapshot();",
          "359:           });",
          "361:           it('if voting is over', async function () {",
          "362:             await this.helper.propose();",
          "363:             await this.helper.waitForDeadline();",
          "369:           });",
          "370:         });",
          "372:         describe('on vote by signature', function () {",
          "373:           beforeEach(async function () {",
          "396:             await this.helper.propose();",
          "",
          "[Removed Lines]",
          "303:             await expectRevertCustomError(this.helper.propose(), 'GovernorUnexpectedProposalState', [",
          "304:               this.proposal.id,",
          "305:               Enums.ProposalState.Pending,",
          "306:               ZERO_BYTES32,",
          "307:             ]);",
          "311:             const votes = web3.utils.toWei('10');",
          "312:             const threshold = web3.utils.toWei('1000');",
          "314:             await expectRevertCustomError(this.helper.propose({ from: voter1 }), 'GovernorInsufficientProposerVotes', [",
          "315:               voter1,",
          "316:               votes,",
          "317:               threshold,",
          "318:             ]);",
          "324:             await expectRevertCustomError(",
          "325:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "326:               'GovernorNonexistentProposal',",
          "327:               [this.proposal.id],",
          "328:             );",
          "333:             await expectRevertCustomError(",
          "334:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "335:               'GovernorUnexpectedProposalState',",
          "336:               [this.proposal.id, Enums.ProposalState.Pending, proposalStatesToBitMap([Enums.ProposalState.Active])],",
          "337:             );",
          "343:             await expectRevertCustomError(",
          "344:               this.helper.vote({ support: web3.utils.toBN('255') }),",
          "346:               [],",
          "353:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "354:             await expectRevertCustomError(",
          "355:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "356:               'GovernorAlreadyCastVote',",
          "357:               [voter1],",
          "358:             );",
          "364:             await expectRevertCustomError(",
          "365:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "366:               'GovernorUnexpectedProposalState',",
          "367:               [this.proposal.id, Enums.ProposalState.Defeated, proposalStatesToBitMap([Enums.ProposalState.Active])],",
          "368:             );",
          "374:             this.voterBySig = Wallet.generate();",
          "375:             this.voterBySig.address = web3.utils.toChecksumAddress(this.voterBySig.getAddressString());",
          "377:             this.data = (contract, message) =>",
          "378:               getDomain(contract).then(domain => ({",
          "379:                 primaryType: 'Ballot',",
          "380:                 types: {",
          "381:                   EIP712Domain: domainType(domain),",
          "382:                   Ballot,",
          "383:                 },",
          "384:                 domain,",
          "385:                 message,",
          "386:               }));",
          "388:             this.signature = (contract, message) =>",
          "389:               this.data(contract, message).then(data =>",
          "390:                 ethSigUtil.signTypedMessage(this.voterBySig.getPrivateKey(), { data }),",
          "391:               );",
          "393:             await this.token.delegate(this.voterBySig.address, { from: voter1 });",
          "",
          "[Added Lines]",
          "267:             await expect(this.helper.propose())",
          "268:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "269:               .withArgs(this.proposal.id, Enums.ProposalState.Pending, ethers.ZeroHash);",
          "273:             const votes = ethers.parseEther('10');",
          "274:             const threshold = ethers.parseEther('1000');",
          "276:             await expect(this.helper.connect(this.voter1).propose())",
          "277:               .to.be.revertedWithCustomError(this.mock, 'GovernorInsufficientProposerVotes')",
          "278:               .withArgs(this.voter1.address, votes, threshold);",
          "284:             await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "285:               .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "286:               .withArgs(this.proposal.id);",
          "291:             await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "292:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "293:               .withArgs(",
          "294:                 this.proposal.id,",
          "295:                 Enums.ProposalState.Pending,",
          "296:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Active]),",
          "297:               );",
          "303:             await expect(this.helper.vote({ support: 255 })).to.be.revertedWithCustomError(",
          "304:               this.mock,",
          "312:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "313:             await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "314:               .to.be.revertedWithCustomError(this.mock, 'GovernorAlreadyCastVote')",
          "315:               .withArgs(this.voter1.address);",
          "321:             await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "322:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "323:               .withArgs(",
          "324:                 this.proposal.id,",
          "325:                 Enums.ProposalState.Defeated,",
          "326:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Active]),",
          "327:               );",
          "333:             await this.token.connect(this.voter1).delegate(this.userEOA);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "398:           });",
          "400:           it('if signature does not match signer', async function () {",
          "403:             const voteParams = {",
          "404:               support: Enums.VoteType.For,",
          "406:               nonce,",
          "413:             };",
          "416:           });",
          "418:           it('if vote nonce is incorrect', async function () {",
          "421:             const voteParams = {",
          "422:               support: Enums.VoteType.For,",
          "426:             };",
          "434:           });",
          "435:         });",
          "437:         describe('on queue', function () {",
          "438:           it('always', async function () {",
          "440:             await this.helper.waitForSnapshot();",
          "442:             await this.helper.waitForDeadline();",
          "444:           });",
          "445:         });",
          "447:         describe('on execute', function () {",
          "448:           it('if proposal does not exist', async function () {",
          "450:           });",
          "452:           it('if quorum is not reached', async function () {",
          "453:             await this.helper.propose();",
          "454:             await this.helper.waitForSnapshot();",
          "461:           });",
          "463:           it('if score not reached', async function () {",
          "464:             await this.helper.propose();",
          "465:             await this.helper.waitForSnapshot();",
          "472:           });",
          "474:           it('if voting is not over', async function () {",
          "475:             await this.helper.propose();",
          "476:             await this.helper.waitForSnapshot();",
          "483:           });",
          "485:           it('if receiver revert without reason', async function () {",
          "486:             this.helper.setProposal(",
          "487:               [",
          "488:                 {",
          "491:                 },",
          "492:               ],",
          "493:               '<proposal description>',",
          "",
          "[Removed Lines]",
          "401:             const nonce = await this.mock.nonces(this.voterBySig.address);",
          "405:               voter: this.voterBySig.address,",
          "407:               signature: async (...params) => {",
          "408:                 const sig = await this.signature(...params);",
          "409:                 const tamperedSig = web3.utils.hexToBytes(sig);",
          "410:                 tamperedSig[42] ^= 0xff;",
          "411:                 return web3.utils.bytesToHex(tamperedSig);",
          "412:               },",
          "415:             await expectRevertCustomError(this.helper.vote(voteParams), 'GovernorInvalidSignature', [voteParams.voter]);",
          "419:             const nonce = await this.mock.nonces(this.voterBySig.address);",
          "423:               voter: this.voterBySig.address,",
          "424:               nonce: nonce.addn(1),",
          "425:               signature: this.signature,",
          "428:             await expectRevertCustomError(",
          "429:               this.helper.vote(voteParams),",
          "431:               'GovernorInvalidSignature',",
          "432:               [voteParams.voter],",
          "433:             );",
          "439:             await this.helper.propose({ from: proposer });",
          "441:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "443:             await expectRevertCustomError(this.helper.queue(), 'GovernorQueueNotImplemented', []);",
          "449:             await expectRevertCustomError(this.helper.execute(), 'GovernorNonexistentProposal', [this.proposal.id]);",
          "455:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter3 });",
          "456:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "457:               this.proposal.id,",
          "458:               Enums.ProposalState.Active,",
          "459:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "460:             ]);",
          "466:             await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter1 });",
          "467:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "468:               this.proposal.id,",
          "469:               Enums.ProposalState.Active,",
          "470:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "471:             ]);",
          "477:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "478:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "479:               this.proposal.id,",
          "480:               Enums.ProposalState.Active,",
          "481:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "482:             ]);",
          "489:                   target: this.receiver.address,",
          "490:                   data: this.receiver.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "",
          "[Added Lines]",
          "341:             const nonce = await this.mock.nonces(this.userEOA);",
          "343:             function tamper(str, index, mask) {",
          "344:               const arrayStr = ethers.toBeArray(BigInt(str));",
          "345:               arrayStr[index] ^= mask;",
          "346:               return ethers.hexlify(arrayStr);",
          "347:             }",
          "351:               voter: this.userEOA.address,",
          "353:               signature: (...args) => signBallot(this.userEOA)(...args).then(sig => tamper(sig, 42, 0xff)),",
          "356:             await expect(this.helper.vote(voteParams))",
          "357:               .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidSignature')",
          "358:               .withArgs(voteParams.voter);",
          "362:             const nonce = await this.mock.nonces(this.userEOA);",
          "366:               voter: this.userEOA.address,",
          "367:               nonce: nonce + 1n,",
          "368:               signature: signBallot(this.userEOA),",
          "371:             await expect(this.helper.vote(voteParams))",
          "372:               .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidSignature')",
          "373:               .withArgs(voteParams.voter);",
          "379:             await this.helper.connect(this.proposer).propose();",
          "381:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "383:             await expect(this.helper.queue()).to.be.revertedWithCustomError(this.mock, 'GovernorQueueNotImplemented');",
          "389:             await expect(this.helper.execute())",
          "390:               .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "391:               .withArgs(this.proposal.id);",
          "397:             await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.For });",
          "398:             await expect(this.helper.execute())",
          "399:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "400:               .withArgs(",
          "401:                 this.proposal.id,",
          "402:                 Enums.ProposalState.Active,",
          "403:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "404:               );",
          "410:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.Against });",
          "411:             await expect(this.helper.execute())",
          "412:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "413:               .withArgs(",
          "414:                 this.proposal.id,",
          "415:                 Enums.ProposalState.Active,",
          "416:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "417:               );",
          "423:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "424:             await expect(this.helper.execute())",
          "425:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "426:               .withArgs(",
          "427:                 this.proposal.id,",
          "428:                 Enums.ProposalState.Active,",
          "429:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "430:               );",
          "437:                   target: this.receiver.target,",
          "438:                   data: this.receiver.interface.encodeFunctionData('mockFunctionRevertsNoReason'),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "496:             await this.helper.propose();",
          "497:             await this.helper.waitForSnapshot();",
          "499:             await this.helper.waitForDeadline();",
          "501:           });",
          "503:           it('if receiver revert with reason', async function () {",
          "504:             this.helper.setProposal(",
          "505:               [",
          "506:                 {",
          "509:                 },",
          "510:               ],",
          "511:               '<proposal description>',",
          "",
          "[Removed Lines]",
          "498:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "500:             await expectRevertCustomError(this.helper.execute(), 'FailedInnerCall', []);",
          "507:                   target: this.receiver.address,",
          "508:                   data: this.receiver.contract.methods.mockFunctionRevertsReason().encodeABI(),",
          "",
          "[Added Lines]",
          "446:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "448:             await expect(this.helper.execute()).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "455:                   target: this.receiver.target,",
          "456:                   data: this.receiver.interface.encodeFunctionData('mockFunctionRevertsReason'),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "514:             await this.helper.propose();",
          "515:             await this.helper.waitForSnapshot();",
          "517:             await this.helper.waitForDeadline();",
          "519:           });",
          "521:           it('if proposal was already executed', async function () {",
          "522:             await this.helper.propose();",
          "523:             await this.helper.waitForSnapshot();",
          "525:             await this.helper.waitForDeadline();",
          "526:             await this.helper.execute();",
          "532:           });",
          "533:         });",
          "534:       });",
          "536:       describe('state', function () {",
          "537:         it('Unset', async function () {",
          "541:         });",
          "543:         it('Pending & Active', async function () {",
          "544:           await this.helper.propose();",
          "546:           await this.helper.waitForSnapshot();",
          "550:         });",
          "552:         it('Defeated', async function () {",
          "553:           await this.helper.propose();",
          "554:           await this.helper.waitForDeadline();",
          "558:         });",
          "560:         it('Succeeded', async function () {",
          "561:           await this.helper.propose();",
          "562:           await this.helper.waitForSnapshot();",
          "564:           await this.helper.waitForDeadline();",
          "568:         });",
          "570:         it('Executed', async function () {",
          "571:           await this.helper.propose();",
          "572:           await this.helper.waitForSnapshot();",
          "574:           await this.helper.waitForDeadline();",
          "575:           await this.helper.execute();",
          "577:         });",
          "578:       });",
          "580:       describe('cancel', function () {",
          "581:         describe('internal', function () {",
          "582:           it('before proposal', async function () {",
          "586:           });",
          "588:           it('after proposal', async function () {",
          "589:             await this.helper.propose();",
          "591:             await this.helper.cancel('internal');",
          "594:             await this.helper.waitForSnapshot();",
          "600:           });",
          "602:           it('after vote', async function () {",
          "603:             await this.helper.propose();",
          "604:             await this.helper.waitForSnapshot();",
          "607:             await this.helper.cancel('internal');",
          "610:             await this.helper.waitForDeadline();",
          "616:           });",
          "618:           it('after deadline', async function () {",
          "619:             await this.helper.propose();",
          "620:             await this.helper.waitForSnapshot();",
          "622:             await this.helper.waitForDeadline();",
          "624:             await this.helper.cancel('internal');",
          "632:           });",
          "634:           it('after execution', async function () {",
          "635:             await this.helper.propose();",
          "636:             await this.helper.waitForSnapshot();",
          "638:             await this.helper.waitForDeadline();",
          "639:             await this.helper.execute();",
          "649:           });",
          "650:         });",
          "652:         describe('public', function () {",
          "653:           it('before proposal', async function () {",
          "657:           });",
          "659:           it('after proposal', async function () {",
          "",
          "[Removed Lines]",
          "516:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "518:             await expectRevert(this.helper.execute(), 'CallReceiverMock: reverting');",
          "524:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "527:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "528:               this.proposal.id,",
          "529:               Enums.ProposalState.Executed,",
          "530:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "531:             ]);",
          "538:           await expectRevertCustomError(this.mock.state(this.proposal.id), 'GovernorNonexistentProposal', [",
          "539:             this.proposal.id,",
          "540:           ]);",
          "545:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Pending);",
          "547:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Pending);",
          "548:           await this.helper.waitForSnapshot(+1);",
          "549:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "555:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "556:           await this.helper.waitForDeadline(+1);",
          "557:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Defeated);",
          "563:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "565:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "566:           await this.helper.waitForDeadline(+1);",
          "567:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "573:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "576:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Executed);",
          "583:             await expectRevertCustomError(this.helper.cancel('internal'), 'GovernorNonexistentProposal', [",
          "584:               this.proposal.id,",
          "585:             ]);",
          "592:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "595:             await expectRevertCustomError(",
          "596:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "597:               'GovernorUnexpectedProposalState',",
          "598:               [this.proposal.id, Enums.ProposalState.Canceled, proposalStatesToBitMap([Enums.ProposalState.Active])],",
          "599:             );",
          "605:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "608:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "611:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "612:               this.proposal.id,",
          "613:               Enums.ProposalState.Canceled,",
          "614:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "615:             ]);",
          "621:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "625:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "627:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "628:               this.proposal.id,",
          "629:               Enums.ProposalState.Canceled,",
          "630:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "631:             ]);",
          "637:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "641:             await expectRevertCustomError(this.helper.cancel('internal'), 'GovernorUnexpectedProposalState', [",
          "642:               this.proposal.id,",
          "643:               Enums.ProposalState.Executed,",
          "644:               proposalStatesToBitMap(",
          "645:                 [Enums.ProposalState.Canceled, Enums.ProposalState.Expired, Enums.ProposalState.Executed],",
          "646:                 { inverted: true },",
          "647:               ),",
          "648:             ]);",
          "654:             await expectRevertCustomError(this.helper.cancel('external'), 'GovernorNonexistentProposal', [",
          "655:               this.proposal.id,",
          "656:             ]);",
          "",
          "[Added Lines]",
          "464:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "466:             await expect(this.helper.execute()).to.be.revertedWith('CallReceiverMock: reverting');",
          "472:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "475:             await expect(this.helper.execute())",
          "476:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "477:               .withArgs(",
          "478:                 this.proposal.id,",
          "479:                 Enums.ProposalState.Executed,",
          "480:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "481:               );",
          "488:           await expect(this.mock.state(this.proposal.id))",
          "489:             .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "490:             .withArgs(this.proposal.id);",
          "495:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Pending);",
          "497:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Pending);",
          "498:           await this.helper.waitForSnapshot(1n);",
          "499:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Active);",
          "505:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Active);",
          "506:           await this.helper.waitForDeadline(1n);",
          "507:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Defeated);",
          "513:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "515:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Active);",
          "516:           await this.helper.waitForDeadline(1n);",
          "517:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Succeeded);",
          "523:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "526:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Executed);",
          "533:             await expect(this.helper.cancel('internal'))",
          "534:               .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "535:               .withArgs(this.proposal.id);",
          "542:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "545:             await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "546:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "547:               .withArgs(",
          "548:                 this.proposal.id,",
          "549:                 Enums.ProposalState.Canceled,",
          "550:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Active]),",
          "551:               );",
          "557:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "560:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "563:             await expect(this.helper.execute())",
          "564:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "565:               .withArgs(",
          "566:                 this.proposal.id,",
          "567:                 Enums.ProposalState.Canceled,",
          "568:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "569:               );",
          "575:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "579:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "581:             await expect(this.helper.execute())",
          "582:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "583:               .withArgs(",
          "584:                 this.proposal.id,",
          "585:                 Enums.ProposalState.Canceled,",
          "586:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "587:               );",
          "593:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "597:             await expect(this.helper.cancel('internal'))",
          "598:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "599:               .withArgs(",
          "600:                 this.proposal.id,",
          "601:                 Enums.ProposalState.Executed,",
          "602:                 GovernorHelper.proposalStatesToBitMap(",
          "603:                   [Enums.ProposalState.Canceled, Enums.ProposalState.Expired, Enums.ProposalState.Executed],",
          "604:                   { inverted: true },",
          "605:                 ),",
          "606:               );",
          "612:             await expect(this.helper.cancel('external'))",
          "613:               .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "614:               .withArgs(this.proposal.id);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "663:           });",
          "665:           it('after proposal - restricted to proposer', async function () {",
          "671:           });",
          "673:           it('after vote started', async function () {",
          "674:             await this.helper.propose();",
          "682:           });",
          "684:           it('after vote', async function () {",
          "685:             await this.helper.propose();",
          "686:             await this.helper.waitForSnapshot();",
          "694:           });",
          "696:           it('after deadline', async function () {",
          "697:             await this.helper.propose();",
          "698:             await this.helper.waitForSnapshot();",
          "700:             await this.helper.waitForDeadline();",
          "707:           });",
          "709:           it('after execution', async function () {",
          "710:             await this.helper.propose();",
          "711:             await this.helper.waitForSnapshot();",
          "713:             await this.helper.waitForDeadline();",
          "714:             await this.helper.execute();",
          "721:           });",
          "722:         });",
          "723:       });",
          "",
          "[Removed Lines]",
          "666:             await this.helper.propose();",
          "668:             await expectRevertCustomError(this.helper.cancel('external', { from: owner }), 'GovernorOnlyProposer', [",
          "669:               owner,",
          "670:             ]);",
          "675:             await this.helper.waitForSnapshot(1); // snapshot + 1 block",
          "677:             await expectRevertCustomError(this.helper.cancel('external'), 'GovernorUnexpectedProposalState', [",
          "678:               this.proposal.id,",
          "679:               Enums.ProposalState.Active,",
          "680:               proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "681:             ]);",
          "687:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "689:             await expectRevertCustomError(this.helper.cancel('external'), 'GovernorUnexpectedProposalState', [",
          "690:               this.proposal.id,",
          "691:               Enums.ProposalState.Active,",
          "692:               proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "693:             ]);",
          "699:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "702:             await expectRevertCustomError(this.helper.cancel('external'), 'GovernorUnexpectedProposalState', [",
          "703:               this.proposal.id,",
          "704:               Enums.ProposalState.Succeeded,",
          "705:               proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "706:             ]);",
          "712:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "716:             await expectRevertCustomError(this.helper.cancel('external'), 'GovernorUnexpectedProposalState', [",
          "717:               this.proposal.id,",
          "718:               Enums.ProposalState.Executed,",
          "719:               proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "720:             ]);",
          "",
          "[Added Lines]",
          "624:             await this.helper.connect(this.proposer).propose();",
          "626:             await expect(this.helper.connect(this.owner).cancel('external'))",
          "627:               .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyProposer')",
          "628:               .withArgs(this.owner.address);",
          "633:             await this.helper.waitForSnapshot(1n); // snapshot + 1 block",
          "635:             await expect(this.helper.cancel('external'))",
          "636:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "637:               .withArgs(",
          "638:                 this.proposal.id,",
          "639:                 Enums.ProposalState.Active,",
          "640:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "641:               );",
          "647:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "649:             await expect(this.helper.cancel('external'))",
          "650:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "651:               .withArgs(",
          "652:                 this.proposal.id,",
          "653:                 Enums.ProposalState.Active,",
          "654:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "655:               );",
          "661:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "664:             await expect(this.helper.cancel('external'))",
          "665:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "666:               .withArgs(",
          "667:                 this.proposal.id,",
          "668:                 Enums.ProposalState.Succeeded,",
          "669:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "670:               );",
          "676:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "680:             await expect(this.helper.cancel('external'))",
          "681:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "682:               .withArgs(",
          "683:                 this.proposal.id,",
          "684:                 Enums.ProposalState.Executed,",
          "685:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Pending]),",
          "686:               );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "725:       describe('proposal length', function () {",
          "726:         it('empty', async function () {",
          "727:           this.helper.setProposal([], '<proposal description>');",
          "729:         });",
          "731:         it('mismatch #1', async function () {",
          "732:           this.helper.setProposal(",
          "733:             {",
          "734:               targets: [],",
          "737:             },",
          "738:             '<proposal description>',",
          "739:           );",
          "741:         });",
          "743:         it('mismatch #2', async function () {",
          "744:           this.helper.setProposal(",
          "745:             {",
          "747:               values: [],",
          "749:             },",
          "750:             '<proposal description>',",
          "751:           );",
          "753:         });",
          "755:         it('mismatch #3', async function () {",
          "756:           this.helper.setProposal(",
          "757:             {",
          "760:               data: [],",
          "761:             },",
          "762:             '<proposal description>',",
          "763:           );",
          "765:         });",
          "766:       });",
          "768:       describe('frontrun protection using description suffix', function () {",
          "769:         describe('without protection', function () {",
          "770:           describe('without suffix', function () {",
          "778:           });",
          "780:           describe('with different suffix', function () {",
          "782:               this.proposal = this.helper.setProposal(",
          "783:                 [",
          "784:                   {",
          "787:                     value,",
          "788:                   },",
          "789:                 ],",
          "791:               );",
          "792:             });",
          "801:           });",
          "803:           describe('with proposer suffix but bad address part', function () {",
          "805:               this.proposal = this.helper.setProposal(",
          "806:                 [",
          "807:                   {",
          "810:                     value,",
          "811:                   },",
          "812:                 ],",
          "",
          "[Removed Lines]",
          "728:           await expectRevertCustomError(this.helper.propose(), 'GovernorInvalidProposalLength', [0, 0, 0]);",
          "735:               values: [web3.utils.toWei('0')],",
          "736:               data: [this.receiver.contract.methods.mockFunction().encodeABI()],",
          "740:           await expectRevertCustomError(this.helper.propose(), 'GovernorInvalidProposalLength', [0, 1, 1]);",
          "746:               targets: [this.receiver.address],",
          "748:               data: [this.receiver.contract.methods.mockFunction().encodeABI()],",
          "752:           await expectRevertCustomError(this.helper.propose(), 'GovernorInvalidProposalLength', [1, 1, 0]);",
          "758:               targets: [this.receiver.address],",
          "759:               values: [web3.utils.toWei('0')],",
          "764:           await expectRevertCustomError(this.helper.propose(), 'GovernorInvalidProposalLength', [1, 0, 1]);",
          "771:             it('proposer can propose', async function () {",
          "772:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "773:             });",
          "775:             it('someone else can propose', async function () {",
          "776:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "777:             });",
          "781:             beforeEach(async function () {",
          "785:                     target: this.receiver.address,",
          "786:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "790:                 `<proposal description>#wrong-suffix=${proposer}`,",
          "794:             it('proposer can propose', async function () {",
          "795:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "796:             });",
          "798:             it('someone else can propose', async function () {",
          "799:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "800:             });",
          "804:             beforeEach(async function () {",
          "808:                     target: this.receiver.address,",
          "809:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "695:           await expect(this.helper.propose())",
          "696:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidProposalLength')",
          "697:             .withArgs(0, 0, 0);",
          "704:               values: [0n],",
          "705:               data: [this.receiver.interface.encodeFunctionData('mockFunction')],",
          "709:           await expect(this.helper.propose())",
          "710:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidProposalLength')",
          "711:             .withArgs(0, 1, 1);",
          "717:               targets: [this.receiver.target],",
          "719:               data: [this.receiver.interface.encodeFunctionData('mockFunction')],",
          "723:           await expect(this.helper.propose())",
          "724:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidProposalLength')",
          "725:             .withArgs(1, 1, 0);",
          "731:               targets: [this.receiver.target],",
          "732:               values: [0n],",
          "737:           await expect(this.helper.propose())",
          "738:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidProposalLength')",
          "739:             .withArgs(1, 0, 1);",
          "744:         function shouldPropose() {",
          "745:           it('proposer can propose', async function () {",
          "746:             const txPropose = await this.helper.connect(this.proposer).propose();",
          "748:             await expect(txPropose)",
          "749:               .to.emit(this.mock, 'ProposalCreated')",
          "750:               .withArgs(",
          "751:                 this.proposal.id,",
          "752:                 this.proposer.address,",
          "753:                 this.proposal.targets,",
          "754:                 this.proposal.values,",
          "755:                 this.proposal.signatures,",
          "756:                 this.proposal.data,",
          "757:                 (await time.clockFromReceipt[mode](txPropose)) + votingDelay,",
          "758:                 (await time.clockFromReceipt[mode](txPropose)) + votingDelay + votingPeriod,",
          "759:                 this.proposal.description,",
          "760:               );",
          "761:           });",
          "763:           it('someone else can propose', async function () {",
          "764:             const txPropose = await this.helper.connect(this.voter1).propose();",
          "766:             await expect(txPropose)",
          "767:               .to.emit(this.mock, 'ProposalCreated')",
          "768:               .withArgs(",
          "769:                 this.proposal.id,",
          "770:                 this.voter1.address,",
          "771:                 this.proposal.targets,",
          "772:                 this.proposal.values,",
          "773:                 this.proposal.signatures,",
          "774:                 this.proposal.data,",
          "775:                 (await time.clockFromReceipt[mode](txPropose)) + votingDelay,",
          "776:                 (await time.clockFromReceipt[mode](txPropose)) + votingDelay + votingPeriod,",
          "777:                 this.proposal.description,",
          "778:               );",
          "779:           });",
          "780:         }",
          "784:             shouldPropose();",
          "788:             beforeEach(function () {",
          "792:                     target: this.receiver.target,",
          "793:                     data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "797:                 `<proposal description>#wrong-suffix=${this.proposer}`,",
          "801:             shouldPropose();",
          "805:             beforeEach(function () {",
          "809:                     target: this.receiver.target,",
          "810:                     data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "814:               );",
          "815:             });",
          "824:           });",
          "825:         });",
          "827:         describe('with protection via proposer suffix', function () {",
          "829:             this.proposal = this.helper.setProposal(",
          "830:               [",
          "831:                 {",
          "834:                   value,",
          "835:                 },",
          "836:               ],",
          "838:             );",
          "839:           });",
          "850:         });",
          "851:       });",
          "853:       describe('onlyGovernance updates', function () {",
          "854:         it('setVotingDelay is protected', async function () {",
          "858:         });",
          "860:         it('setVotingPeriod is protected', async function () {",
          "864:         });",
          "866:         it('setProposalThreshold is protected', async function () {",
          "872:         });",
          "874:         it('can setVotingDelay through governance', async function () {",
          "875:           this.helper.setProposal(",
          "876:             [",
          "877:               {",
          "880:               },",
          "881:             ],",
          "882:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "817:             it('propose can propose', async function () {",
          "818:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "819:             });",
          "821:             it('someone else can propose', async function () {",
          "822:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "823:             });",
          "828:           beforeEach(async function () {",
          "832:                   target: this.receiver.address,",
          "833:                   data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "837:               `<proposal description>#proposer=${proposer}`,",
          "841:           it('proposer can propose', async function () {",
          "842:             expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "843:           });",
          "845:           it('someone else cannot propose', async function () {",
          "846:             await expectRevertCustomError(this.helper.propose({ from: voter1 }), 'GovernorRestrictedProposer', [",
          "847:               voter1,",
          "848:             ]);",
          "849:           });",
          "855:           await expectRevertCustomError(this.mock.setVotingDelay('0', { from: owner }), 'GovernorOnlyExecutor', [",
          "856:             owner,",
          "857:           ]);",
          "861:           await expectRevertCustomError(this.mock.setVotingPeriod('32', { from: owner }), 'GovernorOnlyExecutor', [",
          "862:             owner,",
          "863:           ]);",
          "867:           await expectRevertCustomError(",
          "868:             this.mock.setProposalThreshold('1000000000000000000', { from: owner }),",
          "869:             'GovernorOnlyExecutor',",
          "870:             [owner],",
          "871:           );",
          "878:                 target: this.mock.address,",
          "879:                 data: this.mock.contract.methods.setVotingDelay('0').encodeABI(),",
          "",
          "[Added Lines]",
          "818:             shouldPropose();",
          "823:           beforeEach(function () {",
          "827:                   target: this.receiver.target,",
          "828:                   data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "832:               `<proposal description>#proposer=${this.proposer}`,",
          "836:           shouldPropose();",
          "842:           await expect(this.mock.connect(this.owner).setVotingDelay(0n))",
          "843:             .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "844:             .withArgs(this.owner.address);",
          "848:           await expect(this.mock.connect(this.owner).setVotingPeriod(32n))",
          "849:             .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "850:             .withArgs(this.owner.address);",
          "854:           await expect(this.mock.connect(this.owner).setProposalThreshold(1_000_000_000_000_000_000n))",
          "855:             .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "856:             .withArgs(this.owner.address);",
          "863:                 target: this.mock.target,",
          "864:                 data: this.mock.interface.encodeFunctionData('setVotingDelay', [0n]),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "885:           await this.helper.propose();",
          "886:           await this.helper.waitForSnapshot();",
          "888:           await this.helper.waitForDeadline();",
          "893:         });",
          "895:         it('can setVotingPeriod through governance', async function () {",
          "896:           this.helper.setProposal(",
          "897:             [",
          "898:               {",
          "901:               },",
          "902:             ],",
          "903:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "887:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "890:           expectEvent(await this.helper.execute(), 'VotingDelaySet', { oldVotingDelay: '4', newVotingDelay: '0' });",
          "892:           expect(await this.mock.votingDelay()).to.be.bignumber.equal('0');",
          "899:                 target: this.mock.address,",
          "900:                 data: this.mock.contract.methods.setVotingPeriod('32').encodeABI(),",
          "",
          "[Added Lines]",
          "872:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "875:           await expect(this.helper.execute()).to.emit(this.mock, 'VotingDelaySet').withArgs(4n, 0n);",
          "877:           expect(await this.mock.votingDelay()).to.equal(0n);",
          "884:                 target: this.mock.target,",
          "885:                 data: this.mock.interface.encodeFunctionData('setVotingPeriod', [32n]),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "906:           await this.helper.propose();",
          "907:           await this.helper.waitForSnapshot();",
          "909:           await this.helper.waitForDeadline();",
          "914:         });",
          "916:         it('cannot setVotingPeriod to 0 through governance', async function () {",
          "918:           this.helper.setProposal(",
          "919:             [",
          "920:               {",
          "923:               },",
          "924:             ],",
          "925:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "908:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "911:           expectEvent(await this.helper.execute(), 'VotingPeriodSet', { oldVotingPeriod: '16', newVotingPeriod: '32' });",
          "913:           expect(await this.mock.votingPeriod()).to.be.bignumber.equal('32');",
          "917:           const votingPeriod = 0;",
          "921:                 target: this.mock.address,",
          "922:                 data: this.mock.contract.methods.setVotingPeriod(votingPeriod).encodeABI(),",
          "",
          "[Added Lines]",
          "893:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "896:           await expect(this.helper.execute()).to.emit(this.mock, 'VotingPeriodSet').withArgs(16n, 32n);",
          "898:           expect(await this.mock.votingPeriod()).to.equal(32n);",
          "902:           const votingPeriod = 0n;",
          "907:                 target: this.mock.target,",
          "908:                 data: this.mock.interface.encodeFunctionData('setVotingPeriod', [votingPeriod]),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "928:           await this.helper.propose();",
          "929:           await this.helper.waitForSnapshot();",
          "931:           await this.helper.waitForDeadline();",
          "934:         });",
          "936:         it('can setProposalThreshold to 0 through governance', async function () {",
          "937:           this.helper.setProposal(",
          "938:             [",
          "939:               {",
          "942:               },",
          "943:             ],",
          "944:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "930:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "933:           await expectRevertCustomError(this.helper.execute(), 'GovernorInvalidVotingPeriod', [votingPeriod]);",
          "940:                 target: this.mock.address,",
          "941:                 data: this.mock.contract.methods.setProposalThreshold('1000000000000000000').encodeABI(),",
          "",
          "[Added Lines]",
          "916:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "919:           await expect(this.helper.execute())",
          "920:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidVotingPeriod')",
          "921:             .withArgs(votingPeriod);",
          "928:                 target: this.mock.target,",
          "929:                 data: this.mock.interface.encodeFunctionData('setProposalThreshold', [1_000_000_000_000_000_000n]),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "947:           await this.helper.propose();",
          "948:           await this.helper.waitForSnapshot();",
          "950:           await this.helper.waitForDeadline();",
          "958:         });",
          "959:       });",
          "961:       describe('safe receive', function () {",
          "962:         describe('ERC721', function () {",
          "967:           beforeEach(async function () {",
          "970:           });",
          "972:           it('can receive an ERC721 safeTransfer', async function () {",
          "974:           });",
          "975:         });",
          "977:         describe('ERC1155', function () {",
          "979:           const tokenIds = {",
          "983:           };",
          "985:           beforeEach(async function () {",
          "988:           });",
          "990:           it('can receive ERC1155 safeTransfer', async function () {",
          "994:               ...Object.entries(tokenIds)[0], // id + amount",
          "995:               '0x',",
          "997:             );",
          "998:           });",
          "1000:           it('can receive ERC1155 safeBatchTransfer', async function () {",
          "1009:           });",
          "1010:         });",
          "1011:       });",
          "",
          "[Removed Lines]",
          "949:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "952:           expectEvent(await this.helper.execute(), 'ProposalThresholdSet', {",
          "953:             oldProposalThreshold: '0',",
          "954:             newProposalThreshold: '1000000000000000000',",
          "955:           });",
          "957:           expect(await this.mock.proposalThreshold()).to.be.bignumber.equal('1000000000000000000');",
          "963:           const name = 'Non Fungible Token';",
          "964:           const symbol = 'NFT';",
          "965:           const tokenId = web3.utils.toBN(1);",
          "968:             this.token = await ERC721.new(name, symbol);",
          "969:             await this.token.$_mint(owner, tokenId);",
          "973:             await this.token.safeTransferFrom(owner, this.mock.address, tokenId, { from: owner });",
          "978:           const uri = 'https://token-cdn-domain/{id}.json';",
          "980:             1: web3.utils.toBN(1000),",
          "981:             2: web3.utils.toBN(2000),",
          "982:             3: web3.utils.toBN(3000),",
          "986:             this.token = await ERC1155.new(uri);",
          "987:             await this.token.$_mintBatch(owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "991:             await this.token.safeTransferFrom(",
          "992:               owner,",
          "993:               this.mock.address,",
          "996:               { from: owner },",
          "1001:             await this.token.safeBatchTransferFrom(",
          "1002:               owner,",
          "1003:               this.mock.address,",
          "1004:               Object.keys(tokenIds),",
          "1005:               Object.values(tokenIds),",
          "1006:               '0x',",
          "1007:               { from: owner },",
          "1008:             );",
          "",
          "[Added Lines]",
          "937:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "940:           await expect(this.helper.execute())",
          "941:             .to.emit(this.mock, 'ProposalThresholdSet')",
          "942:             .withArgs(0n, 1_000_000_000_000_000_000n);",
          "944:           expect(await this.mock.proposalThreshold()).to.equal(1_000_000_000_000_000_000n);",
          "950:           const tokenId = 1n;",
          "953:             this.token = await ethers.deployContract('$ERC721', ['Non Fungible Token', 'NFT']);",
          "954:             await this.token.$_mint(this.owner, tokenId);",
          "958:             await this.token.connect(this.owner).safeTransferFrom(this.owner, this.mock.target, tokenId);",
          "964:             1: 1000n,",
          "965:             2: 2000n,",
          "966:             3: 3000n,",
          "970:             this.token = await ethers.deployContract('$ERC1155', ['https://token-cdn-domain/{id}.json']);",
          "971:             await this.token.$_mintBatch(this.owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "975:             await this.token.connect(this.owner).safeTransferFrom(",
          "976:               this.owner,",
          "977:               this.mock.target,",
          "984:             await this.token",
          "985:               .connect(this.owner)",
          "986:               .safeBatchTransferFrom(",
          "987:                 this.owner,",
          "988:                 this.mock.target,",
          "989:                 Object.keys(tokenIds),",
          "990:                 Object.values(tokenIds),",
          "991:                 '0x',",
          "992:               );",
          "",
          "---------------"
        ],
        "test/governance/TimelockController.test.js||test/governance/TimelockController.test.js": [
          "File: test/governance/TimelockController.test.js -> test/governance/TimelockController.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: const { expect } = require('chai');",
          "7: const { shouldSupportInterfaces } = require('../utils/introspection/SupportsInterface.behavior');",
          "18: const MINDELAY = time.duration.days(1);",
          "22: function genOperation(target, value, data, predecessor, salt) {",
          "25:       ['address', 'uint256', 'bytes', 'uint256', 'bytes32'],",
          "27:     ),",
          "28:   );",
          "29:   return { id, target, value, data, predecessor, salt };",
          "30: }",
          "32: function genOperationBatch(targets, values, payloads, predecessor, salt) {",
          "35:       ['address[]', 'uint256[]', 'bytes[]', 'uint256', 'bytes32'],",
          "37:     ),",
          "38:   );",
          "39:   return { id, targets, values, payloads, predecessor, salt };",
          "40: }",
          "50:   beforeEach(async function () {",
          "61:   });",
          "63:   shouldSupportInterfaces(['ERC1155Receiver']);",
          "65:   it('initial state', async function () {",
          "73:     expect(",
          "77:     expect(",
          "81:     expect(",
          "84:   });",
          "86:   it('optional admin', async function () {",
          "91:   });",
          "93:   describe('methods', function () {",
          "",
          "[Removed Lines]",
          "1: const { BN, constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS, ZERO_BYTES32 } = constants;",
          "3: const { proposalStatesToBitMap } = require('../helpers/governance');",
          "8: const { expectRevertCustomError } = require('../helpers/customError');",
          "9: const { OperationState } = require('../helpers/enums');",
          "11: const TimelockController = artifacts.require('TimelockController');",
          "12: const CallReceiverMock = artifacts.require('CallReceiverMock');",
          "13: const Implementation2 = artifacts.require('Implementation2');",
          "14: const ERC721 = artifacts.require('$ERC721');",
          "15: const ERC1155 = artifacts.require('$ERC1155');",
          "16: const TimelockReentrant = artifacts.require('$TimelockReentrant');",
          "20: const salt = '0x025e7b0be353a74631ad648c667493c0e1cd31caa4cc2d3520fdc171ea0cc726'; // a random value",
          "23:   const id = web3.utils.keccak256(",
          "24:     web3.eth.abi.encodeParameters(",
          "26:       [target, value, data, predecessor, salt],",
          "33:   const id = web3.utils.keccak256(",
          "34:     web3.eth.abi.encodeParameters(",
          "36:       [targets, values, payloads, predecessor, salt],",
          "42: contract('TimelockController', function (accounts) {",
          "43:   const [, admin, proposer, canceller, executor, other] = accounts;",
          "45:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "46:   const PROPOSER_ROLE = web3.utils.soliditySha3('PROPOSER_ROLE');",
          "47:   const EXECUTOR_ROLE = web3.utils.soliditySha3('EXECUTOR_ROLE');",
          "48:   const CANCELLER_ROLE = web3.utils.soliditySha3('CANCELLER_ROLE');",
          "52:     this.mock = await TimelockController.new(MINDELAY, [proposer], [executor], admin);",
          "54:     expect(await this.mock.hasRole(CANCELLER_ROLE, proposer)).to.be.equal(true);",
          "55:     await this.mock.revokeRole(CANCELLER_ROLE, proposer, { from: admin });",
          "56:     await this.mock.grantRole(CANCELLER_ROLE, canceller, { from: admin });",
          "59:     this.callreceivermock = await CallReceiverMock.new({ from: admin });",
          "60:     this.implementation2 = await Implementation2.new({ from: admin });",
          "66:     expect(await this.mock.getMinDelay()).to.be.bignumber.equal(MINDELAY);",
          "68:     expect(await this.mock.DEFAULT_ADMIN_ROLE()).to.be.equal(DEFAULT_ADMIN_ROLE);",
          "69:     expect(await this.mock.PROPOSER_ROLE()).to.be.equal(PROPOSER_ROLE);",
          "70:     expect(await this.mock.EXECUTOR_ROLE()).to.be.equal(EXECUTOR_ROLE);",
          "71:     expect(await this.mock.CANCELLER_ROLE()).to.be.equal(CANCELLER_ROLE);",
          "74:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, proposer))),",
          "75:     ).to.be.deep.equal([true, false, false]);",
          "78:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, canceller))),",
          "79:     ).to.be.deep.equal([false, true, false]);",
          "82:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, executor))),",
          "83:     ).to.be.deep.equal([false, false, true]);",
          "87:     const mock = await TimelockController.new(MINDELAY, [proposer], [executor], ZERO_ADDRESS, { from: other });",
          "89:     expect(await mock.hasRole(DEFAULT_ADMIN_ROLE, admin)).to.be.equal(false);",
          "90:     expect(await mock.hasRole(DEFAULT_ADMIN_ROLE, mock.address)).to.be.equal(true);",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "4: const { PANIC_CODES } = require('@nomicfoundation/hardhat-chai-matchers/panic');",
          "6: const { GovernorHelper } = require('../helpers/governance');",
          "7: const { bigint: time } = require('../helpers/time');",
          "8: const {",
          "9:   bigint: { OperationState },",
          "10: } = require('../helpers/enums');",
          "14: const salt = '0x025e7b0be353a74631ad648c667493c0e1cd31caa4cc2d3520fdc171ea0cc726'; // a random value",
          "17: const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;",
          "18: const PROPOSER_ROLE = ethers.id('PROPOSER_ROLE');",
          "19: const EXECUTOR_ROLE = ethers.id('EXECUTOR_ROLE');",
          "20: const CANCELLER_ROLE = ethers.id('CANCELLER_ROLE');",
          "22: const getAddress = obj => obj.address ?? obj.target ?? obj;",
          "25:   const id = ethers.keccak256(",
          "26:     ethers.AbiCoder.defaultAbiCoder().encode(",
          "28:       [getAddress(target), value, data, predecessor, salt],",
          "35:   const id = ethers.keccak256(",
          "36:     ethers.AbiCoder.defaultAbiCoder().encode(",
          "38:       [targets.map(getAddress), values, payloads, predecessor, salt],",
          "44: async function fixture() {",
          "45:   const [admin, proposer, canceller, executor, other] = await ethers.getSigners();",
          "47:   const mock = await ethers.deployContract('TimelockController', [MINDELAY, [proposer], [executor], admin]);",
          "48:   const callreceivermock = await ethers.deployContract('CallReceiverMock');",
          "49:   const implementation2 = await ethers.deployContract('Implementation2');",
          "51:   expect(await mock.hasRole(CANCELLER_ROLE, proposer)).to.be.true;",
          "52:   await mock.connect(admin).revokeRole(CANCELLER_ROLE, proposer);",
          "53:   await mock.connect(admin).grantRole(CANCELLER_ROLE, canceller);",
          "55:   return {",
          "56:     admin,",
          "57:     proposer,",
          "58:     canceller,",
          "59:     executor,",
          "60:     other,",
          "61:     mock,",
          "62:     callreceivermock,",
          "63:     implementation2,",
          "64:   };",
          "65: }",
          "67: describe('TimelockController', function () {",
          "69:     Object.assign(this, await loadFixture(fixture));",
          "75:     expect(await this.mock.getMinDelay()).to.equal(MINDELAY);",
          "77:     expect(await this.mock.DEFAULT_ADMIN_ROLE()).to.equal(DEFAULT_ADMIN_ROLE);",
          "78:     expect(await this.mock.PROPOSER_ROLE()).to.equal(PROPOSER_ROLE);",
          "79:     expect(await this.mock.EXECUTOR_ROLE()).to.equal(EXECUTOR_ROLE);",
          "80:     expect(await this.mock.CANCELLER_ROLE()).to.equal(CANCELLER_ROLE);",
          "83:       await Promise.all(",
          "84:         [PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, this.proposer)),",
          "85:       ),",
          "86:     ).to.deep.equal([true, false, false]);",
          "89:       await Promise.all(",
          "90:         [PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, this.canceller)),",
          "91:       ),",
          "92:     ).to.deep.equal([false, true, false]);",
          "95:       await Promise.all(",
          "96:         [PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, this.executor)),",
          "97:       ),",
          "98:     ).to.deep.equal([false, false, true]);",
          "102:     const mock = await ethers.deployContract('TimelockController', [",
          "103:       MINDELAY,",
          "104:       [this.proposer],",
          "105:       [this.executor],",
          "106:       ethers.ZeroAddress,",
          "107:     ]);",
          "108:     expect(await mock.hasRole(DEFAULT_ADMIN_ROLE, this.admin)).to.be.false;",
          "109:     expect(await mock.hasRole(DEFAULT_ADMIN_ROLE, mock.target)).to.be.true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:             this.operation.predecessor,",
          "109:             this.operation.salt,",
          "110:           ),",
          "112:       });",
          "114:       it('hashOperationBatch', async function () {",
          "",
          "[Removed Lines]",
          "111:         ).to.be.equal(this.operation.id);",
          "",
          "[Added Lines]",
          "130:         ).to.equal(this.operation.id);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "127:             this.operation.predecessor,",
          "128:             this.operation.salt,",
          "129:           ),",
          "131:       });",
          "132:     });",
          "133:     describe('simple', function () {",
          "",
          "[Removed Lines]",
          "130:         ).to.be.equal(this.operation.id);",
          "",
          "[Added Lines]",
          "149:         ).to.equal(this.operation.id);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:         beforeEach(async function () {",
          "136:           this.operation = genOperation(",
          "137:             '0x31754f590B97fD975Eb86938f18Cc304E264D2F2',",
          "139:             '0x3bf92ccc',",
          "141:             salt,",
          "142:           );",
          "143:         });",
          "145:         it('proposer can schedule', async function () {",
          "190:               this.operation.target,",
          "191:               this.operation.value,",
          "192:               this.operation.data,",
          "193:               this.operation.predecessor,",
          "194:               this.operation.salt,",
          "195:               MINDELAY,",
          "206:               this.operation.target,",
          "207:               this.operation.value,",
          "208:               this.operation.data,",
          "209:               this.operation.predecessor,",
          "211:               MINDELAY,",
          "216:           );",
          "217:         });",
          "222:               this.operation.target,",
          "223:               this.operation.value,",
          "224:               this.operation.data,",
          "225:               this.operation.predecessor,",
          "226:               this.operation.salt,",
          "233:         });",
          "235:         it('schedule operation with salt zero', async function () {",
          "246:         });",
          "247:       });",
          "",
          "[Removed Lines]",
          "138:             0,",
          "140:             ZERO_BYTES32,",
          "146:           const receipt = await this.mock.schedule(",
          "147:             this.operation.target,",
          "148:             this.operation.value,",
          "149:             this.operation.data,",
          "150:             this.operation.predecessor,",
          "151:             this.operation.salt,",
          "152:             MINDELAY,",
          "153:             { from: proposer },",
          "154:           );",
          "155:           expectEvent(receipt, 'CallScheduled', {",
          "156:             id: this.operation.id,",
          "157:             index: web3.utils.toBN(0),",
          "158:             target: this.operation.target,",
          "159:             value: web3.utils.toBN(this.operation.value),",
          "160:             data: this.operation.data,",
          "161:             predecessor: this.operation.predecessor,",
          "162:             delay: MINDELAY,",
          "163:           });",
          "165:           expectEvent(receipt, 'CallSalt', {",
          "166:             id: this.operation.id,",
          "167:             salt: this.operation.salt,",
          "168:           });",
          "170:           const block = await web3.eth.getBlock(receipt.receipt.blockHash);",
          "172:           expect(await this.mock.getTimestamp(this.operation.id)).to.be.bignumber.equal(",
          "173:             web3.utils.toBN(block.timestamp).add(MINDELAY),",
          "174:           );",
          "175:         });",
          "177:         it('prevent overwriting active operation', async function () {",
          "178:           await this.mock.schedule(",
          "179:             this.operation.target,",
          "180:             this.operation.value,",
          "181:             this.operation.data,",
          "182:             this.operation.predecessor,",
          "183:             this.operation.salt,",
          "184:             MINDELAY,",
          "185:             { from: proposer },",
          "186:           );",
          "188:           await expectRevertCustomError(",
          "189:             this.mock.schedule(",
          "196:               { from: proposer },",
          "197:             ),",
          "198:             'TimelockUnexpectedOperationState',",
          "199:             [this.operation.id, proposalStatesToBitMap(OperationState.Unset)],",
          "200:           );",
          "201:         });",
          "203:         it('prevent non-proposer from committing', async function () {",
          "204:           await expectRevertCustomError(",
          "205:             this.mock.schedule(",
          "210:               this.operation.salt,",
          "212:               { from: other },",
          "213:             ),",
          "214:             `AccessControlUnauthorizedAccount`,",
          "215:             [other, PROPOSER_ROLE],",
          "219:         it('enforce minimum delay', async function () {",
          "220:           await expectRevertCustomError(",
          "221:             this.mock.schedule(",
          "227:               MINDELAY - 1,",
          "228:               { from: proposer },",
          "229:             ),",
          "230:             'TimelockInsufficientDelay',",
          "231:             [MINDELAY, MINDELAY - 1],",
          "232:           );",
          "236:           const { receipt } = await this.mock.schedule(",
          "237:             this.operation.target,",
          "238:             this.operation.value,",
          "239:             this.operation.data,",
          "240:             this.operation.predecessor,",
          "241:             ZERO_BYTES32,",
          "242:             MINDELAY,",
          "243:             { from: proposer },",
          "244:           );",
          "245:           expectEvent.notEmitted(receipt, 'CallSalt');",
          "",
          "[Added Lines]",
          "157:             0n,",
          "159:             ethers.ZeroHash,",
          "165:           const tx = await this.mock",
          "166:             .connect(this.proposer)",
          "167:             .schedule(",
          "174:             );",
          "176:           expect(tx)",
          "177:             .to.emit(this.mock, 'CallScheduled')",
          "178:             .withArgs(",
          "179:               this.operation.id,",
          "180:               0n,",
          "186:             )",
          "187:             .to.emit(this.mock, 'CallSalt')",
          "188:             .withArgs(this.operation.id, this.operation.salt);",
          "190:           expect(await this.mock.getTimestamp(this.operation.id)).to.equal(",
          "191:             (await time.clockFromReceipt.timestamp(tx)) + MINDELAY,",
          "195:         it('prevent overwriting active operation', async function () {",
          "196:           await this.mock",
          "197:             .connect(this.proposer)",
          "198:             .schedule(",
          "204:               MINDELAY,",
          "205:             );",
          "207:           await expect(",
          "208:             this.mock",
          "209:               .connect(this.proposer)",
          "210:               .schedule(",
          "211:                 this.operation.target,",
          "212:                 this.operation.value,",
          "213:                 this.operation.data,",
          "214:                 this.operation.predecessor,",
          "215:                 this.operation.salt,",
          "216:                 MINDELAY,",
          "217:               ),",
          "218:           )",
          "219:             .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "220:             .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Unset));",
          "221:         });",
          "223:         it('prevent non-proposer from committing', async function () {",
          "224:           await expect(",
          "225:             this.mock",
          "226:               .connect(this.other)",
          "227:               .schedule(",
          "228:                 this.operation.target,",
          "229:                 this.operation.value,",
          "230:                 this.operation.data,",
          "231:                 this.operation.predecessor,",
          "232:                 this.operation.salt,",
          "233:                 MINDELAY,",
          "234:               ),",
          "235:           )",
          "236:             .to.be.revertedWithCustomError(this.mock, 'AccessControlUnauthorizedAccount')",
          "237:             .withArgs(this.other.address, PROPOSER_ROLE);",
          "238:         });",
          "240:         it('enforce minimum delay', async function () {",
          "241:           await expect(",
          "242:             this.mock",
          "243:               .connect(this.proposer)",
          "244:               .schedule(",
          "245:                 this.operation.target,",
          "246:                 this.operation.value,",
          "247:                 this.operation.data,",
          "248:                 this.operation.predecessor,",
          "249:                 this.operation.salt,",
          "250:                 MINDELAY - 1n,",
          "251:               ),",
          "252:           )",
          "253:             .to.be.revertedWithCustomError(this.mock, 'TimelockInsufficientDelay')",
          "254:             .withArgs(MINDELAY - 1n, MINDELAY);",
          "258:           await expect(",
          "259:             this.mock",
          "260:               .connect(this.proposer)",
          "261:               .schedule(",
          "262:                 this.operation.target,",
          "263:                 this.operation.value,",
          "264:                 this.operation.data,",
          "265:                 this.operation.predecessor,",
          "266:                 ethers.ZeroHash,",
          "267:                 MINDELAY,",
          "268:               ),",
          "269:           ).to.not.emit(this.mock, 'CallSalt');",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "250:         beforeEach(async function () {",
          "251:           this.operation = genOperation(",
          "252:             '0xAe22104DCD970750610E6FE15E623468A98b15f7',",
          "254:             '0x13e414de',",
          "256:             '0xc1059ed2dc130227aa1d1d539ac94c641306905c020436c636e19e3fab56fc7f',",
          "257:           );",
          "258:         });",
          "260:         it('revert if operation is not scheduled', async function () {",
          "273:         });",
          "275:         describe('with scheduled operation', function () {",
          "276:           beforeEach(async function () {",
          "291:                 this.operation.target,",
          "292:                 this.operation.value,",
          "293:                 this.operation.data,",
          "294:                 this.operation.predecessor,",
          "295:                 this.operation.salt,",
          "301:           });",
          "303:           it('revert if execution comes too early 2/2', async function () {",
          "319:           });",
          "321:           describe('on time', function () {",
          "322:             beforeEach(async function () {",
          "325:             });",
          "327:             it('executor can reveal', async function () {",
          "343:             });",
          "345:             it('prevent non-executor from revealing', async function () {",
          "358:             });",
          "360:             it('prevents reentrancy execution', async function () {",
          "363:               const reentrantOperation = genOperation(",
          "368:                 salt,",
          "369:               );",
          "416:               await reentrant.disableReentrancy();",
          "417:               const nonReentrantOperation = reentrantOperation; // Not anymore",
          "435:             });",
          "436:           });",
          "437:         });",
          "",
          "[Removed Lines]",
          "253:             0,",
          "255:             ZERO_BYTES32,",
          "261:           await expectRevertCustomError(",
          "262:             this.mock.execute(",
          "263:               this.operation.target,",
          "264:               this.operation.value,",
          "265:               this.operation.data,",
          "266:               this.operation.predecessor,",
          "267:               this.operation.salt,",
          "268:               { from: executor },",
          "269:             ),",
          "270:             'TimelockUnexpectedOperationState',",
          "271:             [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "272:           );",
          "277:             ({ receipt: this.receipt, logs: this.logs } = await this.mock.schedule(",
          "278:               this.operation.target,",
          "279:               this.operation.value,",
          "280:               this.operation.data,",
          "281:               this.operation.predecessor,",
          "282:               this.operation.salt,",
          "283:               MINDELAY,",
          "284:               { from: proposer },",
          "285:             ));",
          "286:           });",
          "288:           it('revert if execution comes too early 1/2', async function () {",
          "289:             await expectRevertCustomError(",
          "290:               this.mock.execute(",
          "296:                 { from: executor },",
          "297:               ),",
          "298:               'TimelockUnexpectedOperationState',",
          "299:               [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "300:             );",
          "304:             const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "305:             await time.increaseTo(timestamp - 5); // -1 is too tight, test sometime fails",
          "307:             await expectRevertCustomError(",
          "308:               this.mock.execute(",
          "309:                 this.operation.target,",
          "310:                 this.operation.value,",
          "311:                 this.operation.data,",
          "312:                 this.operation.predecessor,",
          "313:                 this.operation.salt,",
          "314:                 { from: executor },",
          "315:               ),",
          "316:               'TimelockUnexpectedOperationState',",
          "317:               [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "318:             );",
          "323:               const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "324:               await time.increaseTo(timestamp);",
          "328:               const receipt = await this.mock.execute(",
          "329:                 this.operation.target,",
          "330:                 this.operation.value,",
          "331:                 this.operation.data,",
          "332:                 this.operation.predecessor,",
          "333:                 this.operation.salt,",
          "334:                 { from: executor },",
          "335:               );",
          "336:               expectEvent(receipt, 'CallExecuted', {",
          "337:                 id: this.operation.id,",
          "338:                 index: web3.utils.toBN(0),",
          "339:                 target: this.operation.target,",
          "340:                 value: web3.utils.toBN(this.operation.value),",
          "341:                 data: this.operation.data,",
          "342:               });",
          "346:               await expectRevertCustomError(",
          "347:                 this.mock.execute(",
          "348:                   this.operation.target,",
          "349:                   this.operation.value,",
          "350:                   this.operation.data,",
          "351:                   this.operation.predecessor,",
          "352:                   this.operation.salt,",
          "353:                   { from: other },",
          "354:                 ),",
          "355:                 `AccessControlUnauthorizedAccount`,",
          "356:                 [other, EXECUTOR_ROLE],",
          "357:               );",
          "362:               const reentrant = await TimelockReentrant.new();",
          "364:                 reentrant.address,",
          "365:                 0,",
          "366:                 reentrant.contract.methods.reenter().encodeABI(),",
          "367:                 ZERO_BYTES32,",
          "372:               await this.mock.schedule(",
          "373:                 reentrantOperation.target,",
          "374:                 reentrantOperation.value,",
          "375:                 reentrantOperation.data,",
          "376:                 reentrantOperation.predecessor,",
          "377:                 reentrantOperation.salt,",
          "378:                 MINDELAY,",
          "379:                 { from: proposer },",
          "380:               );",
          "383:               const timestamp = await this.mock.getTimestamp(reentrantOperation.id);",
          "384:               await time.increaseTo(timestamp);",
          "387:               await this.mock.grantRole(EXECUTOR_ROLE, reentrant.address, { from: admin });",
          "390:               const data = this.mock.contract.methods",
          "391:                 .execute(",
          "392:                   reentrantOperation.target,",
          "393:                   reentrantOperation.value,",
          "394:                   reentrantOperation.data,",
          "395:                   reentrantOperation.predecessor,",
          "396:                   reentrantOperation.salt,",
          "397:                 )",
          "398:                 .encodeABI();",
          "399:               await reentrant.enableRentrancy(this.mock.address, data);",
          "402:               await expectRevertCustomError(",
          "403:                 this.mock.execute(",
          "404:                   reentrantOperation.target,",
          "405:                   reentrantOperation.value,",
          "406:                   reentrantOperation.data,",
          "407:                   reentrantOperation.predecessor,",
          "408:                   reentrantOperation.salt,",
          "409:                   { from: executor },",
          "410:                 ),",
          "411:                 'TimelockUnexpectedOperationState',",
          "412:                 [reentrantOperation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "413:               );",
          "420:               const receipt = await this.mock.execute(",
          "421:                 nonReentrantOperation.target,",
          "422:                 nonReentrantOperation.value,",
          "423:                 nonReentrantOperation.data,",
          "424:                 nonReentrantOperation.predecessor,",
          "425:                 nonReentrantOperation.salt,",
          "426:                 { from: executor },",
          "427:               );",
          "428:               expectEvent(receipt, 'CallExecuted', {",
          "429:                 id: nonReentrantOperation.id,",
          "430:                 index: web3.utils.toBN(0),",
          "431:                 target: nonReentrantOperation.target,",
          "432:                 value: web3.utils.toBN(nonReentrantOperation.value),",
          "433:                 data: nonReentrantOperation.data,",
          "434:               });",
          "",
          "[Added Lines]",
          "277:             0n,",
          "279:             ethers.ZeroHash,",
          "285:           await expect(",
          "286:             this.mock",
          "287:               .connect(this.executor)",
          "288:               .execute(",
          "289:                 this.operation.target,",
          "290:                 this.operation.value,",
          "291:                 this.operation.data,",
          "292:                 this.operation.predecessor,",
          "293:                 this.operation.salt,",
          "294:               ),",
          "295:           )",
          "296:             .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "297:             .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "302:             await this.mock",
          "303:               .connect(this.proposer)",
          "304:               .schedule(",
          "310:                 MINDELAY,",
          "311:               );",
          "312:           });",
          "314:           it('revert if execution comes too early 1/2', async function () {",
          "315:             await expect(",
          "316:               this.mock",
          "317:                 .connect(this.executor)",
          "318:                 .execute(",
          "319:                   this.operation.target,",
          "320:                   this.operation.value,",
          "321:                   this.operation.data,",
          "322:                   this.operation.predecessor,",
          "323:                   this.operation.salt,",
          "324:                 ),",
          "325:             )",
          "326:               .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "327:               .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "332:             await this.mock.getTimestamp(this.operation.id).then(clock => time.forward.timestamp(clock - 5n));",
          "334:             await expect(",
          "335:               this.mock",
          "336:                 .connect(this.executor)",
          "337:                 .execute(",
          "338:                   this.operation.target,",
          "339:                   this.operation.value,",
          "340:                   this.operation.data,",
          "341:                   this.operation.predecessor,",
          "342:                   this.operation.salt,",
          "343:                 ),",
          "344:             )",
          "345:               .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "346:               .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "351:               await this.mock.getTimestamp(this.operation.id).then(clock => time.forward.timestamp(clock));",
          "355:               await expect(",
          "356:                 this.mock",
          "357:                   .connect(this.executor)",
          "358:                   .execute(",
          "359:                     this.operation.target,",
          "360:                     this.operation.value,",
          "361:                     this.operation.data,",
          "362:                     this.operation.predecessor,",
          "363:                     this.operation.salt,",
          "364:                   ),",
          "365:               )",
          "366:                 .to.emit(this.mock, 'CallExecuted')",
          "367:                 .withArgs(this.operation.id, 0n, this.operation.target, this.operation.value, this.operation.data);",
          "371:               await expect(",
          "372:                 this.mock",
          "373:                   .connect(this.other)",
          "374:                   .execute(",
          "375:                     this.operation.target,",
          "376:                     this.operation.value,",
          "377:                     this.operation.data,",
          "378:                     this.operation.predecessor,",
          "379:                     this.operation.salt,",
          "380:                   ),",
          "381:               )",
          "382:                 .to.be.revertedWithCustomError(this.mock, 'AccessControlUnauthorizedAccount')",
          "383:                 .withArgs(this.other.address, EXECUTOR_ROLE);",
          "388:               const reentrant = await ethers.deployContract('$TimelockReentrant');",
          "390:                 reentrant,",
          "391:                 0n,",
          "392:                 reentrant.interface.encodeFunctionData('reenter'),",
          "393:                 ethers.ZeroHash,",
          "398:               await this.mock",
          "399:                 .connect(this.proposer)",
          "400:                 .schedule(",
          "401:                   reentrantOperation.target,",
          "402:                   reentrantOperation.value,",
          "403:                   reentrantOperation.data,",
          "404:                   reentrantOperation.predecessor,",
          "405:                   reentrantOperation.salt,",
          "406:                   MINDELAY,",
          "407:                 );",
          "410:               await this.mock.getTimestamp(reentrantOperation.id).then(clock => time.forward.timestamp(clock));",
          "413:               await this.mock.connect(this.admin).grantRole(EXECUTOR_ROLE, reentrant);",
          "416:               const data = this.mock.interface.encodeFunctionData('execute', [",
          "417:                 getAddress(reentrantOperation.target),",
          "418:                 reentrantOperation.value,",
          "419:                 reentrantOperation.data,",
          "420:                 reentrantOperation.predecessor,",
          "421:                 reentrantOperation.salt,",
          "422:               ]);",
          "423:               await reentrant.enableRentrancy(this.mock, data);",
          "426:               await expect(",
          "427:                 this.mock",
          "428:                   .connect(this.executor)",
          "429:                   .execute(",
          "430:                     reentrantOperation.target,",
          "431:                     reentrantOperation.value,",
          "432:                     reentrantOperation.data,",
          "433:                     reentrantOperation.predecessor,",
          "434:                     reentrantOperation.salt,",
          "435:                   ),",
          "436:               )",
          "437:                 .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "438:                 .withArgs(reentrantOperation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "445:               await expect(",
          "446:                 this.mock",
          "447:                   .connect(this.executor)",
          "448:                   .execute(",
          "449:                     nonReentrantOperation.target,",
          "450:                     nonReentrantOperation.value,",
          "451:                     nonReentrantOperation.data,",
          "452:                     nonReentrantOperation.predecessor,",
          "453:                     nonReentrantOperation.salt,",
          "454:                   ),",
          "455:               )",
          "456:                 .to.emit(this.mock, 'CallExecuted')",
          "457:                 .withArgs(",
          "458:                   nonReentrantOperation.id,",
          "459:                   0n,",
          "460:                   getAddress(nonReentrantOperation.target),",
          "461:                   nonReentrantOperation.value,",
          "462:                   nonReentrantOperation.data,",
          "463:                 );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "443:         beforeEach(async function () {",
          "444:           this.operation = genOperationBatch(",
          "445:             Array(8).fill('0xEd912250835c812D4516BBD80BdaEA1bB63a293C'),",
          "447:             Array(8).fill('0x2fcb7a88'),",
          "449:             '0x6cf9d042ade5de78bed9ffd075eb4b2a4f6b1736932c2dc8af517d6e066f51f5',",
          "450:           );",
          "451:         });",
          "453:         it('proposer can schedule', async function () {",
          "463:           for (const i in this.operation.targets) {",
          "478:           }",
          "484:           );",
          "485:         });",
          "487:         it('prevent overwriting active operation', async function () {",
          "500:               this.operation.targets,",
          "501:               this.operation.values,",
          "502:               this.operation.payloads,",
          "503:               this.operation.predecessor,",
          "504:               this.operation.salt,",
          "505:               MINDELAY,",
          "511:         });",
          "513:         it('length of batch parameter must match #1', async function () {",
          "527:         });",
          "529:         it('length of batch parameter must match #1', async function () {",
          "543:         });",
          "545:         it('prevent non-proposer from committing', async function () {",
          "559:         });",
          "561:         it('enforce minimum delay', async function () {",
          "575:         });",
          "576:       });",
          "",
          "[Removed Lines]",
          "446:             Array(8).fill(0),",
          "448:             ZERO_BYTES32,",
          "454:           const receipt = await this.mock.scheduleBatch(",
          "455:             this.operation.targets,",
          "456:             this.operation.values,",
          "457:             this.operation.payloads,",
          "458:             this.operation.predecessor,",
          "459:             this.operation.salt,",
          "460:             MINDELAY,",
          "461:             { from: proposer },",
          "462:           );",
          "464:             expectEvent(receipt, 'CallScheduled', {",
          "465:               id: this.operation.id,",
          "466:               index: web3.utils.toBN(i),",
          "467:               target: this.operation.targets[i],",
          "468:               value: web3.utils.toBN(this.operation.values[i]),",
          "469:               data: this.operation.payloads[i],",
          "470:               predecessor: this.operation.predecessor,",
          "471:               delay: MINDELAY,",
          "472:             });",
          "474:             expectEvent(receipt, 'CallSalt', {",
          "475:               id: this.operation.id,",
          "476:               salt: this.operation.salt,",
          "477:             });",
          "480:           const block = await web3.eth.getBlock(receipt.receipt.blockHash);",
          "482:           expect(await this.mock.getTimestamp(this.operation.id)).to.be.bignumber.equal(",
          "483:             web3.utils.toBN(block.timestamp).add(MINDELAY),",
          "488:           await this.mock.scheduleBatch(",
          "489:             this.operation.targets,",
          "490:             this.operation.values,",
          "491:             this.operation.payloads,",
          "492:             this.operation.predecessor,",
          "493:             this.operation.salt,",
          "494:             MINDELAY,",
          "495:             { from: proposer },",
          "496:           );",
          "498:           await expectRevertCustomError(",
          "499:             this.mock.scheduleBatch(",
          "506:               { from: proposer },",
          "507:             ),",
          "508:             'TimelockUnexpectedOperationState',",
          "509:             [this.operation.id, proposalStatesToBitMap(OperationState.Unset)],",
          "510:           );",
          "514:           await expectRevertCustomError(",
          "515:             this.mock.scheduleBatch(",
          "516:               this.operation.targets,",
          "517:               [],",
          "518:               this.operation.payloads,",
          "519:               this.operation.predecessor,",
          "520:               this.operation.salt,",
          "521:               MINDELAY,",
          "522:               { from: proposer },",
          "523:             ),",
          "524:             'TimelockInvalidOperationLength',",
          "525:             [this.operation.targets.length, this.operation.payloads.length, 0],",
          "526:           );",
          "530:           await expectRevertCustomError(",
          "531:             this.mock.scheduleBatch(",
          "532:               this.operation.targets,",
          "533:               this.operation.values,",
          "534:               [],",
          "535:               this.operation.predecessor,",
          "536:               this.operation.salt,",
          "537:               MINDELAY,",
          "538:               { from: proposer },",
          "539:             ),",
          "540:             'TimelockInvalidOperationLength',",
          "541:             [this.operation.targets.length, 0, this.operation.payloads.length],",
          "542:           );",
          "546:           await expectRevertCustomError(",
          "547:             this.mock.scheduleBatch(",
          "548:               this.operation.targets,",
          "549:               this.operation.values,",
          "550:               this.operation.payloads,",
          "551:               this.operation.predecessor,",
          "552:               this.operation.salt,",
          "553:               MINDELAY,",
          "554:               { from: other },",
          "555:             ),",
          "556:             `AccessControlUnauthorizedAccount`,",
          "557:             [other, PROPOSER_ROLE],",
          "558:           );",
          "562:           await expectRevertCustomError(",
          "563:             this.mock.scheduleBatch(",
          "564:               this.operation.targets,",
          "565:               this.operation.values,",
          "566:               this.operation.payloads,",
          "567:               this.operation.predecessor,",
          "568:               this.operation.salt,",
          "569:               MINDELAY - 1,",
          "570:               { from: proposer },",
          "571:             ),",
          "572:             'TimelockInsufficientDelay',",
          "573:             [MINDELAY, MINDELAY - 1],",
          "574:           );",
          "",
          "[Added Lines]",
          "475:             Array(8).fill(0n),",
          "477:             ethers.ZeroHash,",
          "483:           const tx = this.mock",
          "484:             .connect(this.proposer)",
          "485:             .scheduleBatch(",
          "486:               this.operation.targets,",
          "487:               this.operation.values,",
          "488:               this.operation.payloads,",
          "489:               this.operation.predecessor,",
          "490:               this.operation.salt,",
          "491:               MINDELAY,",
          "492:             );",
          "494:             await expect(tx)",
          "495:               .to.emit(this.mock, 'CallScheduled')",
          "496:               .withArgs(",
          "497:                 this.operation.id,",
          "498:                 i,",
          "499:                 getAddress(this.operation.targets[i]),",
          "500:                 this.operation.values[i],",
          "501:                 this.operation.payloads[i],",
          "502:                 this.operation.predecessor,",
          "503:                 MINDELAY,",
          "504:               )",
          "505:               .to.emit(this.mock, 'CallSalt')",
          "506:               .withArgs(this.operation.id, this.operation.salt);",
          "509:           expect(await this.mock.getTimestamp(this.operation.id)).to.equal(",
          "510:             (await time.clockFromReceipt.timestamp(tx)) + MINDELAY,",
          "515:           await this.mock",
          "516:             .connect(this.proposer)",
          "517:             .scheduleBatch(",
          "524:             );",
          "526:           await expect(",
          "527:             this.mock",
          "528:               .connect(this.proposer)",
          "529:               .scheduleBatch(",
          "530:                 this.operation.targets,",
          "531:                 this.operation.values,",
          "532:                 this.operation.payloads,",
          "533:                 this.operation.predecessor,",
          "534:                 this.operation.salt,",
          "535:                 MINDELAY,",
          "536:               ),",
          "537:           )",
          "538:             .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "539:             .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Unset));",
          "543:           await expect(",
          "544:             this.mock",
          "545:               .connect(this.proposer)",
          "546:               .scheduleBatch(",
          "547:                 this.operation.targets,",
          "548:                 [],",
          "549:                 this.operation.payloads,",
          "550:                 this.operation.predecessor,",
          "551:                 this.operation.salt,",
          "552:                 MINDELAY,",
          "553:               ),",
          "554:           )",
          "555:             .to.be.revertedWithCustomError(this.mock, 'TimelockInvalidOperationLength')",
          "556:             .withArgs(this.operation.targets.length, this.operation.payloads.length, 0n);",
          "560:           await expect(",
          "561:             this.mock",
          "562:               .connect(this.proposer)",
          "563:               .scheduleBatch(",
          "564:                 this.operation.targets,",
          "565:                 this.operation.values,",
          "566:                 [],",
          "567:                 this.operation.predecessor,",
          "568:                 this.operation.salt,",
          "569:                 MINDELAY,",
          "570:               ),",
          "571:           )",
          "572:             .to.be.revertedWithCustomError(this.mock, 'TimelockInvalidOperationLength')",
          "573:             .withArgs(this.operation.targets.length, 0n, this.operation.payloads.length);",
          "577:           await expect(",
          "578:             this.mock",
          "579:               .connect(this.other)",
          "580:               .scheduleBatch(",
          "581:                 this.operation.targets,",
          "582:                 this.operation.values,",
          "583:                 this.operation.payloads,",
          "584:                 this.operation.predecessor,",
          "585:                 this.operation.salt,",
          "586:                 MINDELAY,",
          "587:               ),",
          "588:           )",
          "589:             .to.be.revertedWithCustomError(this.mock, 'AccessControlUnauthorizedAccount')",
          "590:             .withArgs(this.other.address, PROPOSER_ROLE);",
          "594:           await expect(",
          "595:             this.mock",
          "596:               .connect(this.proposer)",
          "597:               .scheduleBatch(",
          "598:                 this.operation.targets,",
          "599:                 this.operation.values,",
          "600:                 this.operation.payloads,",
          "601:                 this.operation.predecessor,",
          "602:                 this.operation.salt,",
          "603:                 MINDELAY - 1n,",
          "604:               ),",
          "605:           )",
          "606:             .to.be.revertedWithCustomError(this.mock, 'TimelockInsufficientDelay')",
          "607:             .withArgs(MINDELAY - 1n, MINDELAY);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "579:         beforeEach(async function () {",
          "580:           this.operation = genOperationBatch(",
          "581:             Array(8).fill('0x76E53CcEb05131Ef5248553bEBDb8F70536830b1'),",
          "583:             Array(8).fill('0x58a60f63'),",
          "585:             '0x9545eeabc7a7586689191f78a5532443698538e54211b5bd4d7dc0fc0102b5c7',",
          "586:           );",
          "587:         });",
          "589:         it('revert if operation is not scheduled', async function () {",
          "620:                 this.operation.targets,",
          "621:                 this.operation.values,",
          "622:                 this.operation.payloads,",
          "623:                 this.operation.predecessor,",
          "624:                 this.operation.salt,",
          "626:               ),",
          "658:                 this.operation.targets,",
          "659:                 this.operation.values,",
          "660:                 this.operation.payloads,",
          "661:                 this.operation.predecessor,",
          "662:                 this.operation.salt,",
          "664:               );",
          "679:                   this.operation.targets,",
          "680:                   this.operation.values,",
          "681:                   this.operation.payloads,",
          "682:                   this.operation.predecessor,",
          "683:                   this.operation.salt,",
          "685:                 ),",
          "695:                   this.operation.values,",
          "696:                   this.operation.payloads,",
          "697:                   this.operation.predecessor,",
          "698:                   this.operation.salt,",
          "700:                 ),",
          "704:             });",
          "709:                   this.operation.targets,",
          "711:                   this.operation.payloads,",
          "712:                   this.operation.predecessor,",
          "713:                   this.operation.salt,",
          "719:             });",
          "721:             it('length mismatch #3', async function () {",
          "734:             });",
          "736:             it('prevents reentrancy execution', async function () {",
          "739:               const reentrantBatchOperation = genOperationBatch(",
          "744:                 salt,",
          "745:               );",
          "792:               await reentrant.disableReentrancy();",
          "793:               const nonReentrantBatchOperation = reentrantBatchOperation; // Not anymore",
          "804:               for (const i in nonReentrantBatchOperation.targets) {",
          "812:               }",
          "813:             });",
          "814:           });",
          "",
          "[Removed Lines]",
          "582:             Array(8).fill(0),",
          "584:             ZERO_BYTES32,",
          "590:           await expectRevertCustomError(",
          "591:             this.mock.executeBatch(",
          "592:               this.operation.targets,",
          "593:               this.operation.values,",
          "594:               this.operation.payloads,",
          "595:               this.operation.predecessor,",
          "596:               this.operation.salt,",
          "597:               { from: executor },",
          "598:             ),",
          "599:             'TimelockUnexpectedOperationState',",
          "600:             [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "601:           );",
          "602:         });",
          "604:         describe('with scheduled operation', function () {",
          "605:           beforeEach(async function () {",
          "606:             ({ receipt: this.receipt, logs: this.logs } = await this.mock.scheduleBatch(",
          "607:               this.operation.targets,",
          "608:               this.operation.values,",
          "609:               this.operation.payloads,",
          "610:               this.operation.predecessor,",
          "611:               this.operation.salt,",
          "612:               MINDELAY,",
          "613:               { from: proposer },",
          "614:             ));",
          "615:           });",
          "617:           it('revert if execution comes too early 1/2', async function () {",
          "618:             await expectRevertCustomError(",
          "619:               this.mock.executeBatch(",
          "625:                 { from: executor },",
          "627:               'TimelockUnexpectedOperationState',",
          "628:               [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "629:             );",
          "630:           });",
          "632:           it('revert if execution comes too early 2/2', async function () {",
          "633:             const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "634:             await time.increaseTo(timestamp - 5); // -1 is to tight, test sometime fails",
          "636:             await expectRevertCustomError(",
          "637:               this.mock.executeBatch(",
          "638:                 this.operation.targets,",
          "639:                 this.operation.values,",
          "640:                 this.operation.payloads,",
          "641:                 this.operation.predecessor,",
          "642:                 this.operation.salt,",
          "643:                 { from: executor },",
          "644:               ),",
          "645:               'TimelockUnexpectedOperationState',",
          "646:               [this.operation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "647:             );",
          "648:           });",
          "650:           describe('on time', function () {",
          "651:             beforeEach(async function () {",
          "652:               const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "653:               await time.increaseTo(timestamp);",
          "654:             });",
          "656:             it('executor can reveal', async function () {",
          "657:               const receipt = await this.mock.executeBatch(",
          "663:                 { from: executor },",
          "665:               for (const i in this.operation.targets) {",
          "666:                 expectEvent(receipt, 'CallExecuted', {",
          "667:                   id: this.operation.id,",
          "668:                   index: web3.utils.toBN(i),",
          "669:                   target: this.operation.targets[i],",
          "670:                   value: web3.utils.toBN(this.operation.values[i]),",
          "671:                   data: this.operation.payloads[i],",
          "672:                 });",
          "673:               }",
          "674:             });",
          "676:             it('prevent non-executor from revealing', async function () {",
          "677:               await expectRevertCustomError(",
          "678:                 this.mock.executeBatch(",
          "684:                   { from: other },",
          "686:                 `AccessControlUnauthorizedAccount`,",
          "687:                 [other, EXECUTOR_ROLE],",
          "688:               );",
          "689:             });",
          "691:             it('length mismatch #1', async function () {",
          "692:               await expectRevertCustomError(",
          "693:                 this.mock.executeBatch(",
          "694:                   [],",
          "699:                   { from: executor },",
          "701:                 'TimelockInvalidOperationLength',",
          "702:                 [0, this.operation.payloads.length, this.operation.values.length],",
          "703:               );",
          "706:             it('length mismatch #2', async function () {",
          "707:               await expectRevertCustomError(",
          "708:                 this.mock.executeBatch(",
          "710:                   [],",
          "714:                   { from: executor },",
          "715:                 ),",
          "716:                 'TimelockInvalidOperationLength',",
          "717:                 [this.operation.targets.length, this.operation.payloads.length, 0],",
          "718:               );",
          "722:               await expectRevertCustomError(",
          "723:                 this.mock.executeBatch(",
          "724:                   this.operation.targets,",
          "725:                   this.operation.values,",
          "726:                   [],",
          "727:                   this.operation.predecessor,",
          "728:                   this.operation.salt,",
          "729:                   { from: executor },",
          "730:                 ),",
          "731:                 'TimelockInvalidOperationLength',",
          "732:                 [this.operation.targets.length, 0, this.operation.values.length],",
          "733:               );",
          "738:               const reentrant = await TimelockReentrant.new();",
          "740:                 [reentrant.address],",
          "741:                 [0],",
          "742:                 [reentrant.contract.methods.reenter().encodeABI()],",
          "743:                 ZERO_BYTES32,",
          "748:               await this.mock.scheduleBatch(",
          "749:                 reentrantBatchOperation.targets,",
          "750:                 reentrantBatchOperation.values,",
          "751:                 reentrantBatchOperation.payloads,",
          "752:                 reentrantBatchOperation.predecessor,",
          "753:                 reentrantBatchOperation.salt,",
          "754:                 MINDELAY,",
          "755:                 { from: proposer },",
          "756:               );",
          "759:               const timestamp = await this.mock.getTimestamp(reentrantBatchOperation.id);",
          "760:               await time.increaseTo(timestamp);",
          "763:               await this.mock.grantRole(EXECUTOR_ROLE, reentrant.address, { from: admin });",
          "766:               const data = this.mock.contract.methods",
          "767:                 .executeBatch(",
          "768:                   reentrantBatchOperation.targets,",
          "769:                   reentrantBatchOperation.values,",
          "770:                   reentrantBatchOperation.payloads,",
          "771:                   reentrantBatchOperation.predecessor,",
          "772:                   reentrantBatchOperation.salt,",
          "773:                 )",
          "774:                 .encodeABI();",
          "775:               await reentrant.enableRentrancy(this.mock.address, data);",
          "778:               await expectRevertCustomError(",
          "779:                 this.mock.executeBatch(",
          "780:                   reentrantBatchOperation.targets,",
          "781:                   reentrantBatchOperation.values,",
          "782:                   reentrantBatchOperation.payloads,",
          "783:                   reentrantBatchOperation.predecessor,",
          "784:                   reentrantBatchOperation.salt,",
          "785:                   { from: executor },",
          "786:                 ),",
          "787:                 'TimelockUnexpectedOperationState',",
          "788:                 [reentrantBatchOperation.id, proposalStatesToBitMap(OperationState.Ready)],",
          "789:               );",
          "796:               const receipt = await this.mock.executeBatch(",
          "797:                 nonReentrantBatchOperation.targets,",
          "798:                 nonReentrantBatchOperation.values,",
          "799:                 nonReentrantBatchOperation.payloads,",
          "800:                 nonReentrantBatchOperation.predecessor,",
          "801:                 nonReentrantBatchOperation.salt,",
          "802:                 { from: executor },",
          "803:               );",
          "805:                 expectEvent(receipt, 'CallExecuted', {",
          "806:                   id: nonReentrantBatchOperation.id,",
          "807:                   index: web3.utils.toBN(i),",
          "808:                   target: nonReentrantBatchOperation.targets[i],",
          "809:                   value: web3.utils.toBN(nonReentrantBatchOperation.values[i]),",
          "810:                   data: nonReentrantBatchOperation.payloads[i],",
          "811:                 });",
          "",
          "[Added Lines]",
          "615:             Array(8).fill(0n),",
          "617:             ethers.ZeroHash,",
          "623:           await expect(",
          "624:             this.mock",
          "625:               .connect(this.executor)",
          "626:               .executeBatch(",
          "633:           )",
          "634:             .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "635:             .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "636:         });",
          "638:         describe('with scheduled operation', function () {",
          "639:           beforeEach(async function () {",
          "640:             await this.mock",
          "641:               .connect(this.proposer)",
          "642:               .scheduleBatch(",
          "648:                 MINDELAY,",
          "650:           });",
          "652:           it('revert if execution comes too early 1/2', async function () {",
          "653:             await expect(",
          "654:               this.mock",
          "655:                 .connect(this.executor)",
          "656:                 .executeBatch(",
          "663:             )",
          "664:               .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "665:               .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "666:           });",
          "668:           it('revert if execution comes too early 2/2', async function () {",
          "670:             await this.mock.getTimestamp(this.operation.id).then(clock => time.forward.timestamp(clock - 5n));",
          "672:             await expect(",
          "673:               this.mock",
          "674:                 .connect(this.executor)",
          "675:                 .executeBatch(",
          "676:                   this.operation.targets,",
          "682:             )",
          "683:               .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "684:               .withArgs(this.operation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "685:           });",
          "687:           describe('on time', function () {",
          "688:             beforeEach(async function () {",
          "689:               await this.mock.getTimestamp(this.operation.id).then(clock => time.forward.timestamp(clock));",
          "692:             it('executor can reveal', async function () {",
          "693:               const tx = this.mock",
          "694:                 .connect(this.executor)",
          "695:                 .executeBatch(",
          "697:                   this.operation.values,",
          "701:                 );",
          "702:               for (const i in this.operation.targets) {",
          "703:                 expect(tx)",
          "704:                   .to.emit(this.mock, 'CallExecuted')",
          "705:                   .withArgs(",
          "706:                     this.operation.id,",
          "707:                     i,",
          "708:                     this.operation.targets[i],",
          "709:                     this.operation.values[i],",
          "710:                     this.operation.payloads[i],",
          "711:                   );",
          "712:               }",
          "713:             });",
          "715:             it('prevent non-executor from revealing', async function () {",
          "716:               await expect(",
          "717:                 this.mock",
          "718:                   .connect(this.other)",
          "719:                   .executeBatch(",
          "720:                     this.operation.targets,",
          "721:                     this.operation.values,",
          "722:                     this.operation.payloads,",
          "723:                     this.operation.predecessor,",
          "724:                     this.operation.salt,",
          "725:                   ),",
          "726:               )",
          "727:                 .to.be.revertedWithCustomError(this.mock, 'AccessControlUnauthorizedAccount')",
          "728:                 .withArgs(this.other.address, EXECUTOR_ROLE);",
          "729:             });",
          "731:             it('length mismatch #1', async function () {",
          "732:               await expect(",
          "733:                 this.mock",
          "734:                   .connect(this.executor)",
          "735:                   .executeBatch(",
          "736:                     [],",
          "737:                     this.operation.values,",
          "738:                     this.operation.payloads,",
          "739:                     this.operation.predecessor,",
          "740:                     this.operation.salt,",
          "741:                   ),",
          "742:               )",
          "743:                 .to.be.revertedWithCustomError(this.mock, 'TimelockInvalidOperationLength')",
          "744:                 .withArgs(0, this.operation.payloads.length, this.operation.values.length);",
          "745:             });",
          "747:             it('length mismatch #2', async function () {",
          "748:               await expect(",
          "749:                 this.mock",
          "750:                   .connect(this.executor)",
          "751:                   .executeBatch(",
          "752:                     this.operation.targets,",
          "753:                     [],",
          "754:                     this.operation.payloads,",
          "755:                     this.operation.predecessor,",
          "756:                     this.operation.salt,",
          "757:                   ),",
          "758:               )",
          "759:                 .to.be.revertedWithCustomError(this.mock, 'TimelockInvalidOperationLength')",
          "760:                 .withArgs(this.operation.targets.length, this.operation.payloads.length, 0n);",
          "764:               await expect(",
          "765:                 this.mock",
          "766:                   .connect(this.executor)",
          "767:                   .executeBatch(",
          "768:                     this.operation.targets,",
          "769:                     this.operation.values,",
          "770:                     [],",
          "771:                     this.operation.predecessor,",
          "772:                     this.operation.salt,",
          "773:                   ),",
          "774:               )",
          "775:                 .to.be.revertedWithCustomError(this.mock, 'TimelockInvalidOperationLength')",
          "776:                 .withArgs(this.operation.targets.length, 0n, this.operation.values.length);",
          "781:               const reentrant = await ethers.deployContract('$TimelockReentrant');",
          "783:                 [reentrant],",
          "784:                 [0n],",
          "785:                 [reentrant.interface.encodeFunctionData('reenter')],",
          "786:                 ethers.ZeroHash,",
          "791:               await this.mock",
          "792:                 .connect(this.proposer)",
          "793:                 .scheduleBatch(",
          "794:                   reentrantBatchOperation.targets,",
          "795:                   reentrantBatchOperation.values,",
          "796:                   reentrantBatchOperation.payloads,",
          "797:                   reentrantBatchOperation.predecessor,",
          "798:                   reentrantBatchOperation.salt,",
          "799:                   MINDELAY,",
          "800:                 );",
          "803:               await this.mock.getTimestamp(reentrantBatchOperation.id).then(clock => time.forward.timestamp(clock));",
          "806:               await this.mock.connect(this.admin).grantRole(EXECUTOR_ROLE, reentrant);",
          "809:               const data = this.mock.interface.encodeFunctionData('executeBatch', [",
          "810:                 reentrantBatchOperation.targets.map(getAddress),",
          "811:                 reentrantBatchOperation.values,",
          "812:                 reentrantBatchOperation.payloads,",
          "813:                 reentrantBatchOperation.predecessor,",
          "814:                 reentrantBatchOperation.salt,",
          "815:               ]);",
          "816:               await reentrant.enableRentrancy(this.mock, data);",
          "819:               await expect(",
          "820:                 this.mock",
          "821:                   .connect(this.executor)",
          "822:                   .executeBatch(",
          "823:                     reentrantBatchOperation.targets,",
          "824:                     reentrantBatchOperation.values,",
          "825:                     reentrantBatchOperation.payloads,",
          "826:                     reentrantBatchOperation.predecessor,",
          "827:                     reentrantBatchOperation.salt,",
          "828:                   ),",
          "829:               )",
          "830:                 .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "831:                 .withArgs(reentrantBatchOperation.id, GovernorHelper.proposalStatesToBitMap(OperationState.Ready));",
          "838:               const tx = this.mock",
          "839:                 .connect(this.executor)",
          "840:                 .executeBatch(",
          "841:                   nonReentrantBatchOperation.targets,",
          "842:                   nonReentrantBatchOperation.values,",
          "843:                   nonReentrantBatchOperation.payloads,",
          "844:                   nonReentrantBatchOperation.predecessor,",
          "845:                   nonReentrantBatchOperation.salt,",
          "846:                 );",
          "848:                 expect(tx)",
          "849:                   .to.emit(this.mock, 'CallExecuted')",
          "850:                   .withArgs(",
          "851:                     nonReentrantBatchOperation.id,",
          "852:                     i,",
          "853:                     nonReentrantBatchOperation.targets[i],",
          "854:                     nonReentrantBatchOperation.values[i],",
          "855:                     nonReentrantBatchOperation.payloads[i],",
          "856:                   );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "817:         it('partial execution', async function () {",
          "818:           const operation = genOperationBatch(",
          "821:             [",
          "825:             ],",
          "827:             '0x8ac04aa0d6d66b8812fb41d39638d37af0a9ab11da507afd65c509f8ed079d3e',",
          "828:           );",
          "842:               operation.targets,",
          "843:               operation.values,",
          "844:               operation.payloads,",
          "845:               operation.predecessor,",
          "846:               operation.salt,",
          "852:         });",
          "853:       });",
          "854:     });",
          "",
          "[Removed Lines]",
          "819:             [this.callreceivermock.address, this.callreceivermock.address, this.callreceivermock.address],",
          "820:             [0, 0, 0],",
          "822:               this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "823:               this.callreceivermock.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "824:               this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "826:             ZERO_BYTES32,",
          "830:           await this.mock.scheduleBatch(",
          "831:             operation.targets,",
          "832:             operation.values,",
          "833:             operation.payloads,",
          "834:             operation.predecessor,",
          "835:             operation.salt,",
          "836:             MINDELAY,",
          "837:             { from: proposer },",
          "838:           );",
          "839:           await time.increase(MINDELAY);",
          "840:           await expectRevertCustomError(",
          "841:             this.mock.executeBatch(",
          "847:               { from: executor },",
          "848:             ),",
          "849:             'FailedInnerCall',",
          "850:             [],",
          "851:           );",
          "",
          "[Added Lines]",
          "864:             [this.callreceivermock, this.callreceivermock, this.callreceivermock],",
          "865:             [0n, 0n, 0n],",
          "867:               this.callreceivermock.interface.encodeFunctionData('mockFunction'),",
          "868:               this.callreceivermock.interface.encodeFunctionData('mockFunctionRevertsNoReason'),",
          "869:               this.callreceivermock.interface.encodeFunctionData('mockFunction'),",
          "871:             ethers.ZeroHash,",
          "875:           await this.mock",
          "876:             .connect(this.proposer)",
          "877:             .scheduleBatch(",
          "883:               MINDELAY,",
          "884:             );",
          "886:           await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "888:           await expect(",
          "889:             this.mock",
          "890:               .connect(this.executor)",
          "891:               .executeBatch(",
          "892:                 operation.targets,",
          "893:                 operation.values,",
          "894:                 operation.payloads,",
          "895:                 operation.predecessor,",
          "896:                 operation.salt,",
          "897:               ),",
          "898:           ).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "857:       beforeEach(async function () {",
          "858:         this.operation = genOperation(",
          "859:           '0xC6837c44AA376dbe1d2709F13879E040CAb653ca',",
          "861:           '0x296e58dd',",
          "863:           '0xa2485763600634800df9fc9646fb2c112cf98649c55f63dd1d9c7d13a64399d9',",
          "864:         );",
          "874:       });",
          "876:       it('canceller can cancel', async function () {",
          "879:       });",
          "881:       it('cannot cancel invalid operation', async function () {",
          "887:       });",
          "889:       it('prevent non-canceller from canceling', async function () {",
          "895:       });",
          "896:     });",
          "897:   });",
          "899:   describe('maintenance', function () {",
          "900:     it('prevent unauthorized maintenance', async function () {",
          "902:     });",
          "904:     it('timelock scheduled maintenance', async function () {",
          "905:       const newDelay = time.duration.hours(6);",
          "906:       const operation = genOperation(",
          "911:         '0xf8e775b2c5f4d66fb5c7fa800f35ef518c262b6014b3c0aee6ea21bff157f108',",
          "912:       );",
          "935:     });",
          "936:   });",
          "",
          "[Removed Lines]",
          "860:           0,",
          "862:           ZERO_BYTES32,",
          "865:         ({ receipt: this.receipt, logs: this.logs } = await this.mock.schedule(",
          "866:           this.operation.target,",
          "867:           this.operation.value,",
          "868:           this.operation.data,",
          "869:           this.operation.predecessor,",
          "870:           this.operation.salt,",
          "871:           MINDELAY,",
          "872:           { from: proposer },",
          "873:         ));",
          "877:         const receipt = await this.mock.cancel(this.operation.id, { from: canceller });",
          "878:         expectEvent(receipt, 'Cancelled', { id: this.operation.id });",
          "882:         await expectRevertCustomError(",
          "883:           this.mock.cancel(constants.ZERO_BYTES32, { from: canceller }),",
          "884:           'TimelockUnexpectedOperationState',",
          "885:           [constants.ZERO_BYTES32, proposalStatesToBitMap([OperationState.Waiting, OperationState.Ready])],",
          "886:         );",
          "890:         await expectRevertCustomError(",
          "891:           this.mock.cancel(this.operation.id, { from: other }),",
          "892:           `AccessControlUnauthorizedAccount`,",
          "893:           [other, CANCELLER_ROLE],",
          "894:         );",
          "901:       await expectRevertCustomError(this.mock.updateDelay(0, { from: other }), 'TimelockUnauthorizedCaller', [other]);",
          "907:         this.mock.address,",
          "908:         0,",
          "909:         this.mock.contract.methods.updateDelay(newDelay.toString()).encodeABI(),",
          "910:         ZERO_BYTES32,",
          "914:       await this.mock.schedule(",
          "915:         operation.target,",
          "916:         operation.value,",
          "917:         operation.data,",
          "918:         operation.predecessor,",
          "919:         operation.salt,",
          "920:         MINDELAY,",
          "921:         { from: proposer },",
          "922:       );",
          "923:       await time.increase(MINDELAY);",
          "924:       const receipt = await this.mock.execute(",
          "925:         operation.target,",
          "926:         operation.value,",
          "927:         operation.data,",
          "928:         operation.predecessor,",
          "929:         operation.salt,",
          "930:         { from: executor },",
          "931:       );",
          "932:       expectEvent(receipt, 'MinDelayChange', { newDuration: newDelay.toString(), oldDuration: MINDELAY });",
          "934:       expect(await this.mock.getMinDelay()).to.be.bignumber.equal(newDelay);",
          "",
          "[Added Lines]",
          "907:           0n,",
          "909:           ethers.ZeroHash,",
          "912:         await this.mock",
          "913:           .connect(this.proposer)",
          "914:           .schedule(",
          "915:             this.operation.target,",
          "916:             this.operation.value,",
          "917:             this.operation.data,",
          "918:             this.operation.predecessor,",
          "919:             this.operation.salt,",
          "920:             MINDELAY,",
          "921:           );",
          "925:         await expect(this.mock.connect(this.canceller).cancel(this.operation.id))",
          "926:           .to.emit(this.mock, 'Cancelled')",
          "927:           .withArgs(this.operation.id);",
          "931:         await expect(this.mock.connect(this.canceller).cancel(ethers.ZeroHash))",
          "932:           .to.be.revertedWithCustomError(this.mock, 'TimelockUnexpectedOperationState')",
          "933:           .withArgs(",
          "934:             ethers.ZeroHash,",
          "935:             GovernorHelper.proposalStatesToBitMap([OperationState.Waiting, OperationState.Ready]),",
          "936:           );",
          "940:         await expect(this.mock.connect(this.other).cancel(this.operation.id))",
          "941:           .to.be.revertedWithCustomError(this.mock, 'AccessControlUnauthorizedAccount')",
          "942:           .withArgs(this.other.address, CANCELLER_ROLE);",
          "949:       await expect(this.mock.connect(this.other).updateDelay(0n))",
          "950:         .to.be.revertedWithCustomError(this.mock, 'TimelockUnauthorizedCaller')",
          "951:         .withArgs(this.other.address);",
          "957:         this.mock,",
          "958:         0n,",
          "959:         this.mock.interface.encodeFunctionData('updateDelay', [newDelay]),",
          "960:         ethers.ZeroHash,",
          "964:       await this.mock",
          "965:         .connect(this.proposer)",
          "966:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "968:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "970:       await expect(",
          "971:         this.mock",
          "972:           .connect(this.executor)",
          "973:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt),",
          "974:       )",
          "975:         .to.emit(this.mock, 'MinDelayChange')",
          "976:         .withArgs(MINDELAY, newDelay);",
          "978:       expect(await this.mock.getMinDelay()).to.equal(newDelay);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "939:     beforeEach(async function () {",
          "940:       this.operation1 = genOperation(",
          "941:         '0xdE66bD4c97304200A95aE0AadA32d6d01A867E39',",
          "943:         '0x01dc731a',",
          "945:         '0x64e932133c7677402ead2926f86205e2ca4686aebecf5a8077627092b9bb2feb',",
          "946:       );",
          "947:       this.operation2 = genOperation(",
          "948:         '0x3c7944a3F1ee7fc8c5A5134ba7c79D11c3A1FCa3',",
          "950:         '0x8f531849',",
          "951:         this.operation1.id,",
          "952:         '0x036e1311cac523f9548e6461e29fb1f8f9196b91910a41711ea22f5de48df07d',",
          "953:       );",
          "978:           this.operation2.target,",
          "979:           this.operation2.value,",
          "980:           this.operation2.data,",
          "981:           this.operation2.predecessor,",
          "982:           this.operation2.salt,",
          "988:     });",
          "990:     it('can execute after dependency', async function () {",
          "1007:     });",
          "1008:   });",
          "",
          "[Removed Lines]",
          "942:         0,",
          "944:         ZERO_BYTES32,",
          "949:         0,",
          "954:       await this.mock.schedule(",
          "955:         this.operation1.target,",
          "956:         this.operation1.value,",
          "957:         this.operation1.data,",
          "958:         this.operation1.predecessor,",
          "959:         this.operation1.salt,",
          "960:         MINDELAY,",
          "961:         { from: proposer },",
          "962:       );",
          "963:       await this.mock.schedule(",
          "964:         this.operation2.target,",
          "965:         this.operation2.value,",
          "966:         this.operation2.data,",
          "967:         this.operation2.predecessor,",
          "968:         this.operation2.salt,",
          "969:         MINDELAY,",
          "970:         { from: proposer },",
          "971:       );",
          "972:       await time.increase(MINDELAY);",
          "973:     });",
          "975:     it('cannot execute before dependency', async function () {",
          "976:       await expectRevertCustomError(",
          "977:         this.mock.execute(",
          "983:           { from: executor },",
          "984:         ),",
          "985:         'TimelockUnexecutedPredecessor',",
          "986:         [this.operation1.id],",
          "987:       );",
          "991:       await this.mock.execute(",
          "992:         this.operation1.target,",
          "993:         this.operation1.value,",
          "994:         this.operation1.data,",
          "995:         this.operation1.predecessor,",
          "996:         this.operation1.salt,",
          "997:         { from: executor },",
          "998:       );",
          "999:       await this.mock.execute(",
          "1000:         this.operation2.target,",
          "1001:         this.operation2.value,",
          "1002:         this.operation2.data,",
          "1003:         this.operation2.predecessor,",
          "1004:         this.operation2.salt,",
          "1005:         { from: executor },",
          "1006:       );",
          "",
          "[Added Lines]",
          "986:         0n,",
          "988:         ethers.ZeroHash,",
          "993:         0n,",
          "998:       await this.mock",
          "999:         .connect(this.proposer)",
          "1000:         .schedule(",
          "1001:           this.operation1.target,",
          "1002:           this.operation1.value,",
          "1003:           this.operation1.data,",
          "1004:           this.operation1.predecessor,",
          "1005:           this.operation1.salt,",
          "1006:           MINDELAY,",
          "1007:         );",
          "1008:       await this.mock",
          "1009:         .connect(this.proposer)",
          "1010:         .schedule(",
          "1016:           MINDELAY,",
          "1017:         );",
          "1019:       await this.mock.getTimestamp(this.operation2.id).then(clock => time.forward.timestamp(clock));",
          "1020:     });",
          "1022:     it('cannot execute before dependency', async function () {",
          "1023:       await expect(",
          "1024:         this.mock",
          "1025:           .connect(this.executor)",
          "1026:           .execute(",
          "1027:             this.operation2.target,",
          "1028:             this.operation2.value,",
          "1029:             this.operation2.data,",
          "1030:             this.operation2.predecessor,",
          "1031:             this.operation2.salt,",
          "1032:           ),",
          "1033:       )",
          "1034:         .to.be.revertedWithCustomError(this.mock, 'TimelockUnexecutedPredecessor')",
          "1035:         .withArgs(this.operation1.id);",
          "1039:       await this.mock",
          "1040:         .connect(this.executor)",
          "1041:         .execute(",
          "1042:           this.operation1.target,",
          "1043:           this.operation1.value,",
          "1044:           this.operation1.data,",
          "1045:           this.operation1.predecessor,",
          "1046:           this.operation1.salt,",
          "1047:         );",
          "1048:       await this.mock",
          "1049:         .connect(this.executor)",
          "1050:         .execute(",
          "1051:           this.operation2.target,",
          "1052:           this.operation2.value,",
          "1053:           this.operation2.data,",
          "1054:           this.operation2.predecessor,",
          "1055:           this.operation2.salt,",
          "1056:         );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1013:     it('call', async function () {",
          "1014:       const operation = genOperation(",
          "1019:         '0x8043596363daefc89977b25f9d9b4d06c3910959ef0c4d213557a903e1b555e2',",
          "1020:       );",
          "1042:     });",
          "1044:     it('call reverting', async function () {",
          "1045:       const operation = genOperation(",
          "1050:         '0xb1b1b276fdf1a28d1e00537ea73b04d56639128b08063c1a2f70a52e38cba693',",
          "1051:       );",
          "1070:     });",
          "1072:     it('call throw', async function () {",
          "1073:       const operation = genOperation(",
          "1078:         '0xe5ca79f295fc8327ee8a765fe19afb58f4a0cbc5053642bfdd7e73bc68e0fc67',",
          "1079:       );",
          "1097:     });",
          "1099:     it('call out of gas', async function () {",
          "1100:       const operation = genOperation(",
          "1105:         '0xf3274ce7c394c5b629d5215723563a744b817e1730cca5587c567099a14578fd',",
          "1106:       );",
          "1126:     });",
          "1128:     it('call payable with eth', async function () {",
          "1129:       const operation = genOperation(",
          "1131:         1,",
          "1134:         '0x5ab73cd33477dcd36c1e05e28362719d0ed59a7b9ff14939de63a43073dc1f44',",
          "1135:       );",
          "1162:     });",
          "1164:     it('call nonpayable with eth', async function () {",
          "1165:       const operation = genOperation(",
          "1167:         1,",
          "1170:         '0xb78edbd920c7867f187e5aa6294ae5a656cfbf0dea1ccdca3751b740d0f2bdf8',",
          "1171:       );",
          "1197:     });",
          "1199:     it('call reverting with eth', async function () {",
          "1200:       const operation = genOperation(",
          "1202:         1,",
          "1205:         '0xdedb4563ef0095db01d81d3f2decf57cf83e4a72aa792af14c43a792b56f4de6',",
          "1206:       );",
          "1232:     });",
          "1233:   });",
          "1235:   describe('safe receive', function () {",
          "1236:     describe('ERC721', function () {",
          "1241:       beforeEach(async function () {",
          "1244:       });",
          "1246:       it('can receive an ERC721 safeTransfer', async function () {",
          "1248:       });",
          "1249:     });",
          "1251:     describe('ERC1155', function () {",
          "1253:       const tokenIds = {",
          "1257:       };",
          "1259:       beforeEach(async function () {",
          "1262:       });",
          "1264:       it('can receive ERC1155 safeTransfer', async function () {",
          "1269:           '0x',",
          "1271:         );",
          "1272:       });",
          "1274:       it('can receive ERC1155 safeBatchTransfer', async function () {",
          "1283:       });",
          "1284:     });",
          "1285:   });",
          "",
          "[Removed Lines]",
          "1015:         this.implementation2.address,",
          "1016:         0,",
          "1017:         this.implementation2.contract.methods.setValue(42).encodeABI(),",
          "1018:         ZERO_BYTES32,",
          "1022:       await this.mock.schedule(",
          "1023:         operation.target,",
          "1024:         operation.value,",
          "1025:         operation.data,",
          "1026:         operation.predecessor,",
          "1027:         operation.salt,",
          "1028:         MINDELAY,",
          "1029:         { from: proposer },",
          "1030:       );",
          "1031:       await time.increase(MINDELAY);",
          "1032:       await this.mock.execute(",
          "1033:         operation.target,",
          "1034:         operation.value,",
          "1035:         operation.data,",
          "1036:         operation.predecessor,",
          "1037:         operation.salt,",
          "1038:         { from: executor },",
          "1039:       );",
          "1041:       expect(await this.implementation2.getValue()).to.be.bignumber.equal(web3.utils.toBN(42));",
          "1046:         this.callreceivermock.address,",
          "1047:         0,",
          "1048:         this.callreceivermock.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "1049:         ZERO_BYTES32,",
          "1053:       await this.mock.schedule(",
          "1054:         operation.target,",
          "1055:         operation.value,",
          "1056:         operation.data,",
          "1057:         operation.predecessor,",
          "1058:         operation.salt,",
          "1059:         MINDELAY,",
          "1060:         { from: proposer },",
          "1061:       );",
          "1062:       await time.increase(MINDELAY);",
          "1063:       await expectRevertCustomError(",
          "1064:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1065:           from: executor,",
          "1066:         }),",
          "1067:         'FailedInnerCall',",
          "1068:         [],",
          "1069:       );",
          "1074:         this.callreceivermock.address,",
          "1075:         0,",
          "1076:         this.callreceivermock.contract.methods.mockFunctionThrows().encodeABI(),",
          "1077:         ZERO_BYTES32,",
          "1081:       await this.mock.schedule(",
          "1082:         operation.target,",
          "1083:         operation.value,",
          "1084:         operation.data,",
          "1085:         operation.predecessor,",
          "1086:         operation.salt,",
          "1087:         MINDELAY,",
          "1088:         { from: proposer },",
          "1089:       );",
          "1090:       await time.increase(MINDELAY);",
          "1092:       await expectRevert.unspecified(",
          "1093:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1094:           from: executor,",
          "1095:         }),",
          "1096:       );",
          "1101:         this.callreceivermock.address,",
          "1102:         0,",
          "1103:         this.callreceivermock.contract.methods.mockFunctionOutOfGas().encodeABI(),",
          "1104:         ZERO_BYTES32,",
          "1108:       await this.mock.schedule(",
          "1109:         operation.target,",
          "1110:         operation.value,",
          "1111:         operation.data,",
          "1112:         operation.predecessor,",
          "1113:         operation.salt,",
          "1114:         MINDELAY,",
          "1115:         { from: proposer },",
          "1116:       );",
          "1117:       await time.increase(MINDELAY);",
          "1118:       await expectRevertCustomError(",
          "1119:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1120:           from: executor,",
          "1121:           gas: '100000',",
          "1122:         }),",
          "1123:         'FailedInnerCall',",
          "1124:         [],",
          "1125:       );",
          "1130:         this.callreceivermock.address,",
          "1132:         this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "1133:         ZERO_BYTES32,",
          "1137:       await this.mock.schedule(",
          "1138:         operation.target,",
          "1139:         operation.value,",
          "1140:         operation.data,",
          "1141:         operation.predecessor,",
          "1142:         operation.salt,",
          "1143:         MINDELAY,",
          "1144:         { from: proposer },",
          "1145:       );",
          "1146:       await time.increase(MINDELAY);",
          "1148:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1149:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1151:       await this.mock.execute(",
          "1152:         operation.target,",
          "1153:         operation.value,",
          "1154:         operation.data,",
          "1155:         operation.predecessor,",
          "1156:         operation.salt,",
          "1157:         { from: executor, value: 1 },",
          "1158:       );",
          "1160:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1161:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(1));",
          "1166:         this.callreceivermock.address,",
          "1168:         this.callreceivermock.contract.methods.mockFunctionNonPayable().encodeABI(),",
          "1169:         ZERO_BYTES32,",
          "1173:       await this.mock.schedule(",
          "1174:         operation.target,",
          "1175:         operation.value,",
          "1176:         operation.data,",
          "1177:         operation.predecessor,",
          "1178:         operation.salt,",
          "1179:         MINDELAY,",
          "1180:         { from: proposer },",
          "1181:       );",
          "1182:       await time.increase(MINDELAY);",
          "1184:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1185:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1187:       await expectRevertCustomError(",
          "1188:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1189:           from: executor,",
          "1190:         }),",
          "1191:         'FailedInnerCall',",
          "1192:         [],",
          "1193:       );",
          "1195:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1196:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1201:         this.callreceivermock.address,",
          "1203:         this.callreceivermock.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "1204:         ZERO_BYTES32,",
          "1208:       await this.mock.schedule(",
          "1209:         operation.target,",
          "1210:         operation.value,",
          "1211:         operation.data,",
          "1212:         operation.predecessor,",
          "1213:         operation.salt,",
          "1214:         MINDELAY,",
          "1215:         { from: proposer },",
          "1216:       );",
          "1217:       await time.increase(MINDELAY);",
          "1219:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1220:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1222:       await expectRevertCustomError(",
          "1223:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1224:           from: executor,",
          "1225:         }),",
          "1226:         'FailedInnerCall',",
          "1227:         [],",
          "1228:       );",
          "1230:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1231:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1237:       const name = 'Non Fungible Token';",
          "1238:       const symbol = 'NFT';",
          "1239:       const tokenId = new BN(1);",
          "1242:         this.token = await ERC721.new(name, symbol);",
          "1243:         await this.token.$_mint(other, tokenId);",
          "1247:         await this.token.safeTransferFrom(other, this.mock.address, tokenId, { from: other });",
          "1252:       const uri = 'https://token-cdn-domain/{id}.json';",
          "1254:         1: new BN(1000),",
          "1255:         2: new BN(2000),",
          "1256:         3: new BN(3000),",
          "1260:         this.token = await ERC1155.new(uri);",
          "1261:         await this.token.$_mintBatch(other, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "1265:         await this.token.safeTransferFrom(",
          "1266:           other,",
          "1267:           this.mock.address,",
          "1268:           ...Object.entries(tokenIds)[0], // id + amount",
          "1270:           { from: other },",
          "1275:         await this.token.safeBatchTransferFrom(",
          "1276:           other,",
          "1277:           this.mock.address,",
          "1278:           Object.keys(tokenIds),",
          "1279:           Object.values(tokenIds),",
          "1280:           '0x',",
          "1281:           { from: other },",
          "1282:         );",
          "",
          "[Added Lines]",
          "1065:         this.implementation2,",
          "1066:         0n,",
          "1067:         this.implementation2.interface.encodeFunctionData('setValue', [42n]),",
          "1068:         ethers.ZeroHash,",
          "1072:       await this.mock",
          "1073:         .connect(this.proposer)",
          "1074:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1076:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1078:       await this.mock",
          "1079:         .connect(this.executor)",
          "1080:         .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt);",
          "1082:       expect(await this.implementation2.getValue()).to.equal(42n);",
          "1087:         this.callreceivermock,",
          "1088:         0n,",
          "1089:         this.callreceivermock.interface.encodeFunctionData('mockFunctionRevertsNoReason'),",
          "1090:         ethers.ZeroHash,",
          "1094:       await this.mock",
          "1095:         .connect(this.proposer)",
          "1096:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1098:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1100:       await expect(",
          "1101:         this.mock",
          "1102:           .connect(this.executor)",
          "1103:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt),",
          "1104:       ).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "1109:         this.callreceivermock,",
          "1110:         0n,",
          "1111:         this.callreceivermock.interface.encodeFunctionData('mockFunctionThrows'),",
          "1112:         ethers.ZeroHash,",
          "1116:       await this.mock",
          "1117:         .connect(this.proposer)",
          "1118:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1120:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1123:       await expect(",
          "1124:         this.mock",
          "1125:           .connect(this.executor)",
          "1126:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt),",
          "1127:       ).to.be.revertedWithPanic(PANIC_CODES.ASSERTION_ERROR);",
          "1132:         this.callreceivermock,",
          "1133:         0n,",
          "1134:         this.callreceivermock.interface.encodeFunctionData('mockFunctionOutOfGas'),",
          "1135:         ethers.ZeroHash,",
          "1139:       await this.mock",
          "1140:         .connect(this.proposer)",
          "1141:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1143:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1145:       await expect(",
          "1146:         this.mock",
          "1147:           .connect(this.executor)",
          "1148:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1149:             gasLimit: '100000',",
          "1150:           }),",
          "1151:       ).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "1156:         this.callreceivermock,",
          "1158:         this.callreceivermock.interface.encodeFunctionData('mockFunction'),",
          "1159:         ethers.ZeroHash,",
          "1163:       await this.mock",
          "1164:         .connect(this.proposer)",
          "1165:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1167:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1169:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1170:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(0n);",
          "1172:       await this.mock",
          "1173:         .connect(this.executor)",
          "1174:         .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1175:           value: 1,",
          "1176:         });",
          "1178:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1179:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(1n);",
          "1184:         this.callreceivermock,",
          "1186:         this.callreceivermock.interface.encodeFunctionData('mockFunctionNonPayable'),",
          "1187:         ethers.ZeroHash,",
          "1191:       await this.mock",
          "1192:         .connect(this.proposer)",
          "1193:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1195:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1197:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1198:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(0n);",
          "1200:       await expect(",
          "1201:         this.mock",
          "1202:           .connect(this.executor)",
          "1203:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt),",
          "1204:       ).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "1206:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1207:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(0n);",
          "1212:         this.callreceivermock,",
          "1214:         this.callreceivermock.interface.encodeFunctionData('mockFunctionRevertsNoReason'),",
          "1215:         ethers.ZeroHash,",
          "1219:       await this.mock",
          "1220:         .connect(this.proposer)",
          "1221:         .schedule(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, MINDELAY);",
          "1223:       await this.mock.getTimestamp(operation.id).then(clock => time.forward.timestamp(clock));",
          "1225:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1226:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(0n);",
          "1228:       await expect(",
          "1229:         this.mock",
          "1230:           .connect(this.executor)",
          "1231:           .execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt),",
          "1232:       ).to.be.revertedWithCustomError(this.mock, 'FailedInnerCall');",
          "1234:       expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "1235:       expect(await ethers.provider.getBalance(this.callreceivermock)).to.equal(0n);",
          "1241:       const tokenId = 1n;",
          "1244:         this.token = await ethers.deployContract('$ERC721', ['Non Fungible Token', 'NFT']);",
          "1245:         await this.token.$_mint(this.other, tokenId);",
          "1249:         await this.token.connect(this.other).safeTransferFrom(this.other, this.mock, tokenId);",
          "1255:         1: 1000n,",
          "1256:         2: 2000n,",
          "1257:         3: 3000n,",
          "1261:         this.token = await ethers.deployContract('$ERC1155', ['https://token-cdn-domain/{id}.json']);",
          "1262:         await this.token.$_mintBatch(this.other, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "1266:         await this.token.connect(this.other).safeTransferFrom(",
          "1267:           this.other,",
          "1268:           this.mock,",
          "1269:           ...Object.entries(tokenIds)[0n], // id + amount",
          "1275:         await this.token",
          "1276:           .connect(this.other)",
          "1277:           .safeBatchTransferFrom(this.other, this.mock, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorERC721.test.js||test/governance/extensions/GovernorERC721.test.js": [
          "File: test/governance/extensions/GovernorERC721.test.js -> test/governance/extensions/GovernorERC721.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "5: const { GovernorHelper } = require('../../helpers/governance');",
          "10: const TOKENS = [",
          "13: ];",
          "33:       beforeEach(async function () {",
          "51:         this.proposal = this.helper.setProposal(",
          "52:           [",
          "53:             {",
          "55:               value,",
          "57:             },",
          "58:           ],",
          "59:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "4: const Enums = require('../../helpers/enums');",
          "7: const Governor = artifacts.require('$GovernorVoteMocks');",
          "8: const CallReceiver = artifacts.require('CallReceiverMock');",
          "11:   { Token: artifacts.require('$ERC721Votes'), mode: 'blocknumber' },",
          "12:   { Token: artifacts.require('$ERC721VotesTimestampMock'), mode: 'timestamp' },",
          "15: contract('GovernorERC721', function (accounts) {",
          "16:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "18:   const name = 'OZ-Governor';",
          "19:   const version = '1';",
          "20:   const tokenName = 'MockNFToken';",
          "21:   const tokenSymbol = 'MTKN';",
          "22:   const NFT0 = web3.utils.toBN(0);",
          "23:   const NFT1 = web3.utils.toBN(1);",
          "24:   const NFT2 = web3.utils.toBN(2);",
          "25:   const NFT3 = web3.utils.toBN(3);",
          "26:   const NFT4 = web3.utils.toBN(4);",
          "27:   const votingDelay = web3.utils.toBN(4);",
          "28:   const votingPeriod = web3.utils.toBN(16);",
          "29:   const value = web3.utils.toWei('1');",
          "31:   for (const { mode, Token } of TOKENS) {",
          "32:     describe(`using ${Token._json.contractName}`, function () {",
          "34:         this.owner = owner;",
          "35:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "36:         this.mock = await Governor.new(name, this.token.address);",
          "37:         this.receiver = await CallReceiver.new();",
          "39:         this.helper = new GovernorHelper(this.mock, mode);",
          "41:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "43:         await Promise.all([NFT0, NFT1, NFT2, NFT3, NFT4].map(tokenId => this.token.$_mint(owner, tokenId)));",
          "44:         await this.helper.delegate({ token: this.token, to: voter1, tokenId: NFT0 }, { from: owner });",
          "45:         await this.helper.delegate({ token: this.token, to: voter2, tokenId: NFT1 }, { from: owner });",
          "46:         await this.helper.delegate({ token: this.token, to: voter2, tokenId: NFT2 }, { from: owner });",
          "47:         await this.helper.delegate({ token: this.token, to: voter3, tokenId: NFT3 }, { from: owner });",
          "48:         await this.helper.delegate({ token: this.token, to: voter4, tokenId: NFT4 }, { from: owner });",
          "54:               target: this.receiver.address,",
          "56:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "6: const { bigint: Enums } = require('../../helpers/enums');",
          "9:   { Token: '$ERC721Votes', mode: 'blocknumber' },",
          "10:   { Token: '$ERC721VotesTimestampMock', mode: 'timestamp' },",
          "13: const name = 'OZ-Governor';",
          "14: const version = '1';",
          "15: const tokenName = 'MockNFToken';",
          "16: const tokenSymbol = 'MTKN';",
          "17: const NFT0 = 0n;",
          "18: const NFT1 = 1n;",
          "19: const NFT2 = 2n;",
          "20: const NFT3 = 3n;",
          "21: const NFT4 = 4n;",
          "22: const votingDelay = 4n;",
          "23: const votingPeriod = 16n;",
          "24: const value = ethers.parseEther('1');",
          "26: describe('GovernorERC721', function () {",
          "27:   for (const { Token, mode } of TOKENS) {",
          "28:     const fixture = async () => {",
          "29:       const [owner, voter1, voter2, voter3, voter4] = await ethers.getSigners();",
          "30:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "32:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "33:       const mock = await ethers.deployContract('$GovernorMock', [",
          "34:         name, // name",
          "35:         votingDelay, // initialVotingDelay",
          "36:         votingPeriod, // initialVotingPeriod",
          "37:         0n, // initialProposalThreshold",
          "38:         token, // tokenAddress",
          "39:         10n, // quorumNumeratorValue",
          "40:       ]);",
          "42:       await owner.sendTransaction({ to: mock, value });",
          "43:       await Promise.all([NFT0, NFT1, NFT2, NFT3, NFT4].map(tokenId => token.$_mint(owner, tokenId)));",
          "45:       const helper = new GovernorHelper(mock, mode);",
          "46:       await helper.connect(owner).delegate({ token, to: voter1, tokenId: NFT0 });",
          "47:       await helper.connect(owner).delegate({ token, to: voter2, tokenId: NFT1 });",
          "48:       await helper.connect(owner).delegate({ token, to: voter2, tokenId: NFT2 });",
          "49:       await helper.connect(owner).delegate({ token, to: voter3, tokenId: NFT3 });",
          "50:       await helper.connect(owner).delegate({ token, to: voter4, tokenId: NFT4 });",
          "52:       return {",
          "53:         owner,",
          "54:         voter1,",
          "55:         voter2,",
          "56:         voter3,",
          "57:         voter4,",
          "58:         receiver,",
          "59:         token,",
          "60:         mock,",
          "61:         helper,",
          "62:       };",
          "63:     };",
          "65:     describe(`using ${Token}`, function () {",
          "67:         Object.assign(this, await loadFixture(fixture));",
          "72:               target: this.receiver.target,",
          "73:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:       });",
          "63:       it('deployment check', async function () {",
          "69:       });",
          "71:       it('voting with ERC721 token', async function () {",
          "72:         await this.helper.propose();",
          "73:         await this.helper.waitForSnapshot();",
          "99:         await this.helper.waitForDeadline();",
          "100:         await this.helper.execute();",
          "113:       });",
          "114:     });",
          "115:   }",
          "",
          "[Removed Lines]",
          "64:         expect(await this.mock.name()).to.be.equal(name);",
          "65:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "66:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "67:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "68:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "75:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }), 'VoteCast', {",
          "76:           voter: voter1,",
          "77:           support: Enums.VoteType.For,",
          "78:           weight: '1',",
          "79:         });",
          "81:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 }), 'VoteCast', {",
          "82:           voter: voter2,",
          "83:           support: Enums.VoteType.For,",
          "84:           weight: '2',",
          "85:         });",
          "87:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 }), 'VoteCast', {",
          "88:           voter: voter3,",
          "89:           support: Enums.VoteType.Against,",
          "90:           weight: '1',",
          "91:         });",
          "93:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 }), 'VoteCast', {",
          "94:           voter: voter4,",
          "95:           support: Enums.VoteType.Abstain,",
          "96:           weight: '1',",
          "97:         });",
          "102:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "103:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "104:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "105:         expect(await this.mock.hasVoted(this.proposal.id, voter3)).to.be.equal(true);",
          "106:         expect(await this.mock.hasVoted(this.proposal.id, voter4)).to.be.equal(true);",
          "108:         await this.mock.proposalVotes(this.proposal.id).then(results => {",
          "109:           expect(results.forVotes).to.be.bignumber.equal('3');",
          "110:           expect(results.againstVotes).to.be.bignumber.equal('1');",
          "111:           expect(results.abstainVotes).to.be.bignumber.equal('1');",
          "112:         });",
          "",
          "[Added Lines]",
          "82:         expect(await this.mock.name()).to.equal(name);",
          "83:         expect(await this.mock.token()).to.equal(this.token.target);",
          "84:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "85:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "86:         expect(await this.mock.quorum(0n)).to.equal(0n);",
          "88:         expect(await this.token.getVotes(this.voter1)).to.equal(1n); // NFT0",
          "89:         expect(await this.token.getVotes(this.voter2)).to.equal(2n); // NFT1 & NFT2",
          "90:         expect(await this.token.getVotes(this.voter3)).to.equal(1n); // NFT3",
          "91:         expect(await this.token.getVotes(this.voter4)).to.equal(1n); // NFT4",
          "98:         await expect(this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For }))",
          "99:           .to.emit(this.mock, 'VoteCast')",
          "100:           .withArgs(this.voter1.address, this.proposal.id, Enums.VoteType.For, 1n, '');",
          "102:         await expect(this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For }))",
          "103:           .to.emit(this.mock, 'VoteCast')",
          "104:           .withArgs(this.voter2.address, this.proposal.id, Enums.VoteType.For, 2n, '');",
          "106:         await expect(this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against }))",
          "107:           .to.emit(this.mock, 'VoteCast')",
          "108:           .withArgs(this.voter3.address, this.proposal.id, Enums.VoteType.Against, 1n, '');",
          "110:         await expect(this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain }))",
          "111:           .to.emit(this.mock, 'VoteCast')",
          "112:           .withArgs(this.voter4.address, this.proposal.id, Enums.VoteType.Abstain, 1n, '');",
          "117:         expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "118:         expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.true;",
          "119:         expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.true;",
          "120:         expect(await this.mock.hasVoted(this.proposal.id, this.voter3)).to.be.true;",
          "121:         expect(await this.mock.hasVoted(this.proposal.id, this.voter4)).to.be.true;",
          "123:         expect(await this.mock.proposalVotes(this.proposal.id)).to.deep.equal([",
          "124:           1n, // againstVotes",
          "125:           3n, // forVotes",
          "126:           1n, // abstainVotes",
          "127:         ]);",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorPreventLateQuorum.test.js||test/governance/extensions/GovernorPreventLateQuorum.test.js": [
          "File: test/governance/extensions/GovernorPreventLateQuorum.test.js -> test/governance/extensions/GovernorPreventLateQuorum.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "5: const { GovernorHelper } = require('../../helpers/governance');",
          "12: const TOKENS = [",
          "15: ];",
          "33:       beforeEach(async function () {",
          "58:         this.proposal = this.helper.setProposal(",
          "59:           [",
          "60:             {",
          "62:               value,",
          "64:             },",
          "65:           ],",
          "66:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "4: const Enums = require('../../helpers/enums');",
          "6: const { clockFromReceipt } = require('../../helpers/time');",
          "7: const { expectRevertCustomError } = require('../../helpers/customError');",
          "9: const Governor = artifacts.require('$GovernorPreventLateQuorumMock');",
          "10: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "14:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "17: contract('GovernorPreventLateQuorum', function (accounts) {",
          "18:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "20:   const name = 'OZ-Governor';",
          "21:   const version = '1';",
          "22:   const tokenName = 'MockToken';",
          "23:   const tokenSymbol = 'MTKN';",
          "24:   const tokenSupply = web3.utils.toWei('100');",
          "25:   const votingDelay = web3.utils.toBN(4);",
          "26:   const votingPeriod = web3.utils.toBN(16);",
          "27:   const lateQuorumVoteExtension = web3.utils.toBN(8);",
          "28:   const quorum = web3.utils.toWei('1');",
          "29:   const value = web3.utils.toWei('1');",
          "31:   for (const { mode, Token } of TOKENS) {",
          "32:     describe(`using ${Token._json.contractName}`, function () {",
          "34:         this.owner = owner;",
          "35:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "36:         this.mock = await Governor.new(",
          "37:           name,",
          "38:           votingDelay,",
          "39:           votingPeriod,",
          "40:           0,",
          "41:           this.token.address,",
          "42:           lateQuorumVoteExtension,",
          "43:           quorum,",
          "44:         );",
          "45:         this.receiver = await CallReceiver.new();",
          "47:         this.helper = new GovernorHelper(this.mock, mode);",
          "49:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "51:         await this.token.$_mint(owner, tokenSupply);",
          "52:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "53:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "54:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "55:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "61:               target: this.receiver.address,",
          "63:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "6: const { bigint: Enums } = require('../../helpers/enums');",
          "7: const { bigint: time } = require('../../helpers/time');",
          "10:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "11:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "14: const name = 'OZ-Governor';",
          "15: const version = '1';",
          "16: const tokenName = 'MockToken';",
          "17: const tokenSymbol = 'MTKN';",
          "18: const tokenSupply = ethers.parseEther('100');",
          "19: const votingDelay = 4n;",
          "20: const votingPeriod = 16n;",
          "21: const lateQuorumVoteExtension = 8n;",
          "22: const quorum = ethers.parseEther('1');",
          "23: const value = ethers.parseEther('1');",
          "25: describe('GovernorPreventLateQuorum', function () {",
          "26:   for (const { Token, mode } of TOKENS) {",
          "27:     const fixture = async () => {",
          "28:       const [owner, proposer, voter1, voter2, voter3, voter4] = await ethers.getSigners();",
          "29:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "31:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "32:       const mock = await ethers.deployContract('$GovernorPreventLateQuorumMock', [",
          "33:         name, // name",
          "34:         votingDelay, // initialVotingDelay",
          "35:         votingPeriod, // initialVotingPeriod",
          "36:         0n, // initialProposalThreshold",
          "37:         token, // tokenAddress",
          "38:         lateQuorumVoteExtension,",
          "39:         quorum,",
          "40:       ]);",
          "42:       await owner.sendTransaction({ to: mock, value });",
          "43:       await token.$_mint(owner, tokenSupply);",
          "45:       const helper = new GovernorHelper(mock, mode);",
          "46:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "47:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "48:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "49:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "51:       return { owner, proposer, voter1, voter2, voter3, voter4, receiver, token, mock, helper };",
          "52:     };",
          "54:     describe(`using ${Token}`, function () {",
          "56:         Object.assign(this, await loadFixture(fixture));",
          "61:               target: this.receiver.target,",
          "62:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:       });",
          "70:       it('deployment check', async function () {",
          "77:       });",
          "79:       it('nominal workflow unaffected', async function () {",
          "81:         await this.helper.waitForSnapshot();",
          "86:         await this.helper.waitForDeadline();",
          "87:         await this.helper.execute();",
          "120:       });",
          "122:       it('Delay is extended to prevent last minute take-over', async function () {",
          "151:         await this.helper.waitForDeadline();",
          "158:       });",
          "160:       describe('onlyGovernance updates', function () {",
          "161:         it('setLateQuorumVoteExtension is protected', async function () {",
          "167:         });",
          "169:         it('can setLateQuorumVoteExtension through governance', async function () {",
          "170:           this.helper.setProposal(",
          "171:             [",
          "172:               {",
          "175:               },",
          "176:             ],",
          "177:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "71:         expect(await this.mock.name()).to.be.equal(name);",
          "72:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "73:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "74:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "75:         expect(await this.mock.quorum(0)).to.be.bignumber.equal(quorum);",
          "76:         expect(await this.mock.lateQuorumVoteExtension()).to.be.bignumber.equal(lateQuorumVoteExtension);",
          "80:         const txPropose = await this.helper.propose({ from: proposer });",
          "82:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "83:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "84:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "85:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "89:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "90:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "91:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "92:         expect(await this.mock.hasVoted(this.proposal.id, voter3)).to.be.equal(true);",
          "93:         expect(await this.mock.hasVoted(this.proposal.id, voter4)).to.be.equal(true);",
          "95:         await this.mock.proposalVotes(this.proposal.id).then(results => {",
          "96:           expect(results.forVotes).to.be.bignumber.equal(web3.utils.toWei('17'));",
          "97:           expect(results.againstVotes).to.be.bignumber.equal(web3.utils.toWei('5'));",
          "98:           expect(results.abstainVotes).to.be.bignumber.equal(web3.utils.toWei('2'));",
          "99:         });",
          "101:         const voteStart = web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay);",
          "102:         const voteEnd = web3.utils",
          "103:           .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "104:           .add(votingDelay)",
          "105:           .add(votingPeriod);",
          "106:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(voteStart);",
          "107:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(voteEnd);",
          "109:         expectEvent(txPropose, 'ProposalCreated', {",
          "110:           proposalId: this.proposal.id,",
          "111:           proposer,",
          "112:           targets: this.proposal.targets,",
          "114:           signatures: this.proposal.signatures,",
          "115:           calldatas: this.proposal.data,",
          "116:           voteStart,",
          "117:           voteEnd,",
          "118:           description: this.proposal.description,",
          "119:         });",
          "123:         const txPropose = await this.helper.propose({ from: proposer });",
          "126:         const startBlock = web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay);",
          "127:         const endBlock = web3.utils",
          "128:           .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "129:           .add(votingDelay)",
          "130:           .add(votingPeriod);",
          "131:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(startBlock);",
          "132:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(endBlock);",
          "135:         await this.helper.waitForDeadline(-1);",
          "136:         const txVote = await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "139:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "142:         const extendedDeadline = web3.utils",
          "143:           .toBN(await clockFromReceipt[mode](txVote.receipt))",
          "144:           .add(lateQuorumVoteExtension);",
          "145:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(startBlock);",
          "146:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(extendedDeadline);",
          "149:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter1 });",
          "152:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "153:         await this.helper.waitForDeadline(+1);",
          "154:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Defeated);",
          "157:         expectEvent(txVote, 'ProposalExtended', { proposalId: this.proposal.id, extendedDeadline });",
          "162:           await expectRevertCustomError(",
          "163:             this.mock.setLateQuorumVoteExtension(0, { from: owner }),",
          "164:             'GovernorOnlyExecutor',",
          "165:             [owner],",
          "166:           );",
          "173:                 target: this.mock.address,",
          "174:                 data: this.mock.contract.methods.setLateQuorumVoteExtension('0').encodeABI(),",
          "",
          "[Added Lines]",
          "71:         expect(await this.mock.name()).to.equal(name);",
          "72:         expect(await this.mock.token()).to.equal(this.token.target);",
          "73:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "74:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "75:         expect(await this.mock.quorum(0)).to.equal(quorum);",
          "76:         expect(await this.mock.lateQuorumVoteExtension()).to.equal(lateQuorumVoteExtension);",
          "80:         const txPropose = await this.helper.connect(this.proposer).propose();",
          "82:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "83:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "84:         await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against });",
          "85:         await this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain });",
          "89:         expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "90:         expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.true;",
          "91:         expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.true;",
          "92:         expect(await this.mock.hasVoted(this.proposal.id, this.voter3)).to.be.true;",
          "93:         expect(await this.mock.hasVoted(this.proposal.id, this.voter4)).to.be.true;",
          "95:         expect(await this.mock.proposalVotes(this.proposal.id)).to.deep.equal([",
          "96:           ethers.parseEther('5'), // againstVotes",
          "97:           ethers.parseEther('17'), // forVotes",
          "98:           ethers.parseEther('2'), // abstainVotes",
          "99:         ]);",
          "101:         const voteStart = (await time.clockFromReceipt[mode](txPropose)) + votingDelay;",
          "102:         const voteEnd = (await time.clockFromReceipt[mode](txPropose)) + votingDelay + votingPeriod;",
          "103:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.equal(voteStart);",
          "104:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.equal(voteEnd);",
          "106:         await expect(txPropose)",
          "107:           .to.emit(this.mock, 'ProposalCreated')",
          "108:           .withArgs(",
          "109:             this.proposal.id,",
          "110:             this.proposer.address,",
          "111:             this.proposal.targets,",
          "112:             this.proposal.values,",
          "113:             this.proposal.signatures,",
          "114:             this.proposal.data,",
          "115:             voteStart,",
          "116:             voteEnd,",
          "117:             this.proposal.description,",
          "118:           );",
          "122:         const txPropose = await this.helper.connect(this.proposer).propose();",
          "125:         const snapshotTimepoint = (await time.clockFromReceipt[mode](txPropose)) + votingDelay;",
          "126:         const deadlineTimepoint = (await time.clockFromReceipt[mode](txPropose)) + votingDelay + votingPeriod;",
          "127:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.equal(snapshotTimepoint);",
          "128:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.equal(deadlineTimepoint);",
          "130:         await this.helper.waitForDeadline(-1n);",
          "131:         const txVote = await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "134:         expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Active);",
          "137:         const extendedDeadline = (await time.clockFromReceipt[mode](txVote)) + lateQuorumVoteExtension;",
          "138:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.equal(snapshotTimepoint);",
          "139:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.equal(extendedDeadline);",
          "142:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.Against });",
          "145:         expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Active);",
          "146:         await this.helper.waitForDeadline(1n);",
          "147:         expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Defeated);",
          "150:         await expect(txVote).to.emit(this.mock, 'ProposalExtended').withArgs(this.proposal.id, extendedDeadline);",
          "155:           await expect(this.mock.connect(this.owner).setLateQuorumVoteExtension(0n))",
          "156:             .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "157:             .withArgs(this.owner.address);",
          "164:                 target: this.mock.target,",
          "165:                 data: this.mock.interface.encodeFunctionData('setLateQuorumVoteExtension', [0n]),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "180:           await this.helper.propose();",
          "181:           await this.helper.waitForSnapshot();",
          "183:           await this.helper.waitForDeadline();",
          "191:         });",
          "192:       });",
          "193:     });",
          "",
          "[Removed Lines]",
          "182:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "185:           expectEvent(await this.helper.execute(), 'LateQuorumVoteExtensionSet', {",
          "186:             oldVoteExtension: lateQuorumVoteExtension,",
          "187:             newVoteExtension: '0',",
          "188:           });",
          "190:           expect(await this.mock.lateQuorumVoteExtension()).to.be.bignumber.equal('0');",
          "",
          "[Added Lines]",
          "173:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "176:           await expect(this.helper.execute())",
          "177:             .to.emit(this.mock, 'LateQuorumVoteExtensionSet')",
          "178:             .withArgs(lateQuorumVoteExtension, 0n);",
          "180:           expect(await this.mock.lateQuorumVoteExtension()).to.equal(0n);",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorStorage.test.js||test/governance/extensions/GovernorStorage.test.js": [
          "File: test/governance/extensions/GovernorStorage.test.js -> test/governance/extensions/GovernorStorage.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "6: const { GovernorHelper, timelockSalt } = require('../../helpers/governance');",
          "12: const TOKENS = [",
          "15: ];",
          "36:       beforeEach(async function () {",
          "71:         this.proposal = this.helper.setProposal(",
          "72:           [",
          "73:             {",
          "75:               value,",
          "77:             },",
          "78:           ],",
          "79:           '<proposal description>',",
          "80:         );",
          "81:         this.proposal.timelockid = await this.timelock.hashOperationBatch(",
          "82:           ...this.proposal.shortProposal.slice(0, 3),",
          "85:         );",
          "86:       });",
          "88:       describe('proposal indexing', function () {",
          "89:         it('before propose', async function () {",
          "98:         });",
          "100:         it('after propose', async function () {",
          "101:           await this.helper.propose();",
          "117:         });",
          "118:       });",
          "120:       it('queue and execute by id', async function () {",
          "121:         await this.helper.propose();",
          "122:         await this.helper.waitForSnapshot();",
          "127:         await this.helper.waitForDeadline();",
          "141:       });",
          "143:       it('cancel by id', async function () {",
          "147:       });",
          "148:     });",
          "149:   }",
          "",
          "[Removed Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "4: const { expectRevertCustomError } = require('../../helpers/customError');",
          "5: const Enums = require('../../helpers/enums');",
          "8: const Timelock = artifacts.require('TimelockController');",
          "9: const Governor = artifacts.require('$GovernorStorageMock');",
          "10: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "14:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "17: contract('GovernorStorage', function (accounts) {",
          "18:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "20:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "21:   const PROPOSER_ROLE = web3.utils.soliditySha3('PROPOSER_ROLE');",
          "22:   const EXECUTOR_ROLE = web3.utils.soliditySha3('EXECUTOR_ROLE');",
          "23:   const CANCELLER_ROLE = web3.utils.soliditySha3('CANCELLER_ROLE');",
          "25:   const name = 'OZ-Governor';",
          "26:   const version = '1';",
          "27:   const tokenName = 'MockToken';",
          "28:   const tokenSymbol = 'MTKN';",
          "29:   const tokenSupply = web3.utils.toWei('100');",
          "30:   const votingDelay = web3.utils.toBN(4);",
          "31:   const votingPeriod = web3.utils.toBN(16);",
          "32:   const value = web3.utils.toWei('1');",
          "34:   for (const { mode, Token } of TOKENS) {",
          "35:     describe(`using ${Token._json.contractName}`, function () {",
          "37:         const [deployer] = await web3.eth.getAccounts();",
          "39:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "40:         this.timelock = await Timelock.new(3600, [], [], deployer);",
          "41:         this.mock = await Governor.new(",
          "42:           name,",
          "43:           votingDelay,",
          "44:           votingPeriod,",
          "45:           0,",
          "46:           this.timelock.address,",
          "47:           this.token.address,",
          "48:           0,",
          "49:         );",
          "50:         this.receiver = await CallReceiver.new();",
          "52:         this.helper = new GovernorHelper(this.mock, mode);",
          "54:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "57:         await this.timelock.grantRole(PROPOSER_ROLE, this.mock.address);",
          "58:         await this.timelock.grantRole(PROPOSER_ROLE, owner);",
          "59:         await this.timelock.grantRole(CANCELLER_ROLE, this.mock.address);",
          "60:         await this.timelock.grantRole(CANCELLER_ROLE, owner);",
          "61:         await this.timelock.grantRole(EXECUTOR_ROLE, constants.ZERO_ADDRESS);",
          "62:         await this.timelock.revokeRole(DEFAULT_ADMIN_ROLE, deployer);",
          "64:         await this.token.$_mint(owner, tokenSupply);",
          "65:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "66:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "67:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "68:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "74:               target: this.receiver.address,",
          "76:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "83:           '0x0',",
          "84:           timelockSalt(this.mock.address, this.proposal.shortProposal[3]),",
          "90:           expect(await this.mock.proposalCount()).to.be.bignumber.equal('0');",
          "93:           await expectRevert.unspecified(this.mock.proposalDetailsAt(0));",
          "95:           await expectRevertCustomError(this.mock.proposalDetails(this.proposal.id), 'GovernorNonexistentProposal', [",
          "96:             this.proposal.id,",
          "97:           ]);",
          "103:           expect(await this.mock.proposalCount()).to.be.bignumber.equal('1');",
          "105:           const proposalDetailsAt0 = await this.mock.proposalDetailsAt(0);",
          "106:           expect(proposalDetailsAt0[0]).to.be.bignumber.equal(this.proposal.id);",
          "107:           expect(proposalDetailsAt0[1]).to.be.deep.equal(this.proposal.targets);",
          "108:           expect(proposalDetailsAt0[2].map(x => x.toString())).to.be.deep.equal(this.proposal.values);",
          "109:           expect(proposalDetailsAt0[3]).to.be.deep.equal(this.proposal.fulldata);",
          "110:           expect(proposalDetailsAt0[4]).to.be.equal(this.proposal.descriptionHash);",
          "112:           const proposalDetailsForId = await this.mock.proposalDetails(this.proposal.id);",
          "113:           expect(proposalDetailsForId[0]).to.be.deep.equal(this.proposal.targets);",
          "114:           expect(proposalDetailsForId[1].map(x => x.toString())).to.be.deep.equal(this.proposal.values);",
          "115:           expect(proposalDetailsForId[2]).to.be.deep.equal(this.proposal.fulldata);",
          "116:           expect(proposalDetailsForId[3]).to.be.equal(this.proposal.descriptionHash);",
          "123:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "124:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "125:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "126:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "128:         const txQueue = await this.mock.queue(this.proposal.id);",
          "129:         await this.helper.waitForEta();",
          "130:         const txExecute = await this.mock.execute(this.proposal.id);",
          "132:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "133:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallScheduled', { id: this.proposal.timelockid });",
          "134:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallSalt', {",
          "135:           id: this.proposal.timelockid,",
          "136:         });",
          "138:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "139:         await expectEvent.inTransaction(txExecute.tx, this.timelock, 'CallExecuted', { id: this.proposal.timelockid });",
          "140:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "144:         await this.helper.propose();",
          "145:         const txCancel = await this.mock.cancel(this.proposal.id);",
          "146:         expectEvent(txCancel, 'ProposalCanceled', { proposalId: this.proposal.id });",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "4: const { anyValue } = require('@nomicfoundation/hardhat-chai-matchers/withArgs');",
          "5: const { PANIC_CODES } = require('@nomicfoundation/hardhat-chai-matchers/panic');",
          "8: const { bigint: Enums } = require('../../helpers/enums');",
          "11:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "12:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "15: const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;",
          "16: const PROPOSER_ROLE = ethers.id('PROPOSER_ROLE');",
          "17: const EXECUTOR_ROLE = ethers.id('EXECUTOR_ROLE');",
          "18: const CANCELLER_ROLE = ethers.id('CANCELLER_ROLE');",
          "20: const name = 'OZ-Governor';",
          "21: const version = '1';",
          "22: const tokenName = 'MockToken';",
          "23: const tokenSymbol = 'MTKN';",
          "24: const tokenSupply = ethers.parseEther('100');",
          "25: const votingDelay = 4n;",
          "26: const votingPeriod = 16n;",
          "27: const value = ethers.parseEther('1');",
          "28: const delay = 3600n;",
          "30: describe('GovernorStorage', function () {",
          "31:   for (const { Token, mode } of TOKENS) {",
          "32:     const fixture = async () => {",
          "33:       const [deployer, owner, proposer, voter1, voter2, voter3, voter4] = await ethers.getSigners();",
          "34:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "36:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "37:       const timelock = await ethers.deployContract('TimelockController', [delay, [], [], deployer]);",
          "38:       const mock = await ethers.deployContract('$GovernorStorageMock', [",
          "39:         name,",
          "40:         votingDelay,",
          "41:         votingPeriod,",
          "42:         0n,",
          "43:         timelock,",
          "44:         token,",
          "45:         0n,",
          "46:       ]);",
          "48:       await owner.sendTransaction({ to: timelock, value });",
          "49:       await token.$_mint(owner, tokenSupply);",
          "50:       await timelock.grantRole(PROPOSER_ROLE, mock);",
          "51:       await timelock.grantRole(PROPOSER_ROLE, owner);",
          "52:       await timelock.grantRole(CANCELLER_ROLE, mock);",
          "53:       await timelock.grantRole(CANCELLER_ROLE, owner);",
          "54:       await timelock.grantRole(EXECUTOR_ROLE, ethers.ZeroAddress);",
          "55:       await timelock.revokeRole(DEFAULT_ADMIN_ROLE, deployer);",
          "57:       const helper = new GovernorHelper(mock, mode);",
          "58:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "59:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "60:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "61:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "63:       return { deployer, owner, proposer, voter1, voter2, voter3, voter4, receiver, token, timelock, mock, helper };",
          "64:     };",
          "66:     describe(`using ${Token}`, function () {",
          "68:         Object.assign(this, await loadFixture(fixture));",
          "73:               target: this.receiver.target,",
          "74:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "82:           ethers.ZeroHash,",
          "83:           timelockSalt(this.mock.target, this.proposal.shortProposal[3]),",
          "89:           expect(await this.mock.proposalCount()).to.equal(0n);",
          "91:           await expect(this.mock.proposalDetailsAt(0n)).to.be.revertedWithPanic(PANIC_CODES.ARRAY_ACCESS_OUT_OF_BOUNDS);",
          "93:           await expect(this.mock.proposalDetails(this.proposal.id))",
          "94:             .to.be.revertedWithCustomError(this.mock, 'GovernorNonexistentProposal')",
          "95:             .withArgs(this.proposal.id);",
          "101:           expect(await this.mock.proposalCount()).to.equal(1n);",
          "103:           expect(await this.mock.proposalDetailsAt(0n)).to.deep.equal([",
          "104:             this.proposal.id,",
          "105:             this.proposal.targets,",
          "106:             this.proposal.values,",
          "107:             this.proposal.data,",
          "108:             this.proposal.descriptionHash,",
          "109:           ]);",
          "111:           expect(await this.mock.proposalDetails(this.proposal.id)).to.deep.equal([",
          "112:             this.proposal.targets,",
          "113:             this.proposal.values,",
          "114:             this.proposal.data,",
          "115:             this.proposal.descriptionHash,",
          "116:           ]);",
          "123:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "124:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "125:         await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against });",
          "126:         await this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain });",
          "129:         await expect(this.mock.queue(this.proposal.id))",
          "130:           .to.emit(this.mock, 'ProposalQueued')",
          "131:           .withArgs(this.proposal.id, anyValue)",
          "132:           .to.emit(this.timelock, 'CallScheduled')",
          "133:           .withArgs(this.proposal.timelockid, ...Array(6).fill(anyValue))",
          "134:           .to.emit(this.timelock, 'CallSalt')",
          "135:           .withArgs(this.proposal.timelockid, anyValue);",
          "137:         await this.helper.waitForEta();",
          "139:         await expect(this.mock.execute(this.proposal.id))",
          "140:           .to.emit(this.mock, 'ProposalExecuted')",
          "141:           .withArgs(this.proposal.id)",
          "142:           .to.emit(this.timelock, 'CallExecuted')",
          "143:           .withArgs(this.proposal.timelockid, ...Array(4).fill(anyValue))",
          "144:           .to.emit(this.receiver, 'MockFunctionCalled');",
          "148:         await this.helper.connect(this.proposer).propose();",
          "149:         await expect(this.mock.connect(this.proposer).cancel(this.proposal.id))",
          "150:           .to.emit(this.mock, 'ProposalCanceled')",
          "151:           .withArgs(this.proposal.id);",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorTimelockAccess.test.js||test/governance/extensions/GovernorTimelockAccess.test.js": [
          "File: test/governance/extensions/GovernorTimelockAccess.test.js -> test/governance/extensions/GovernorTimelockAccess.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "8: const { selector } = require('../../helpers/methods');",
          "9: const { hashOperation } = require('../../helpers/access-manager');",
          "16: const TOKENS = [",
          "19: ];",
          "35:       beforeEach(async function () {",
          "91:           data: '0x1234',",
          "98:       });",
          "100:       it('accepts ether transfers', async function () {",
          "102:       });",
          "104:       it('post deployment check', async function () {",
          "112:       });",
          "114:       it('sets base delay (seconds)', async function () {",
          "124:         this.proposal = await this.helper.setProposal(",
          "125:           [",
          "126:             {",
          "130:             },",
          "131:           ],",
          "132:           'descr',",
          "",
          "[Removed Lines]",
          "1: const { expectEvent, time } = require('@openzeppelin/test-helpers');",
          "4: const Enums = require('../../helpers/enums');",
          "5: const { GovernorHelper, proposalStatesToBitMap } = require('../../helpers/governance');",
          "6: const { expectRevertCustomError } = require('../../helpers/customError');",
          "7: const { clockFromReceipt } = require('../../helpers/time');",
          "11: const AccessManager = artifacts.require('$AccessManager');",
          "12: const Governor = artifacts.require('$GovernorTimelockAccessMock');",
          "13: const AccessManagedTarget = artifacts.require('$AccessManagedTarget');",
          "14: const Ownable = artifacts.require('$Ownable');",
          "17:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "18:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "21: contract('GovernorTimelockAccess', function (accounts) {",
          "22:   const [admin, voter1, voter2, voter3, voter4, other] = accounts;",
          "24:   const name = 'OZ-Governor';",
          "25:   const version = '1';",
          "26:   const tokenName = 'MockToken';",
          "27:   const tokenSymbol = 'MTKN';",
          "28:   const tokenSupply = web3.utils.toWei('100');",
          "29:   const votingDelay = web3.utils.toBN(4);",
          "30:   const votingPeriod = web3.utils.toBN(16);",
          "31:   const value = web3.utils.toWei('1');",
          "33:   for (const { mode, Token } of TOKENS) {",
          "34:     describe(`using ${Token._json.contractName}`, function () {",
          "36:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "37:         this.manager = await AccessManager.new(admin);",
          "38:         this.mock = await Governor.new(",
          "39:           name,",
          "40:           votingDelay,",
          "41:           votingPeriod,",
          "42:           0, // proposal threshold",
          "43:           this.manager.address,",
          "44:           0, // base delay",
          "45:           this.token.address,",
          "46:           0, // quorum",
          "47:         );",
          "48:         this.receiver = await AccessManagedTarget.new(this.manager.address);",
          "50:         this.helper = new GovernorHelper(this.mock, mode);",
          "52:         await web3.eth.sendTransaction({ from: admin, to: this.mock.address, value });",
          "54:         await this.token.$_mint(admin, tokenSupply);",
          "55:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: admin });",
          "56:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: admin });",
          "57:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: admin });",
          "58:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: admin });",
          "61:         this.restricted = {};",
          "62:         this.restricted.selector = this.receiver.contract.methods.fnRestricted().encodeABI();",
          "63:         this.restricted.operation = {",
          "64:           target: this.receiver.address,",
          "65:           value: '0',",
          "66:           data: this.restricted.selector,",
          "67:         };",
          "68:         this.restricted.operationId = hashOperation(",
          "69:           this.mock.address,",
          "70:           this.restricted.operation.target,",
          "71:           this.restricted.operation.data,",
          "72:         );",
          "74:         this.unrestricted = {};",
          "75:         this.unrestricted.selector = this.receiver.contract.methods.fnUnrestricted().encodeABI();",
          "76:         this.unrestricted.operation = {",
          "77:           target: this.receiver.address,",
          "78:           value: '0',",
          "79:           data: this.unrestricted.selector,",
          "80:         };",
          "81:         this.unrestricted.operationId = hashOperation(",
          "82:           this.mock.address,",
          "83:           this.unrestricted.operation.target,",
          "84:           this.unrestricted.operation.data,",
          "85:         );",
          "87:         this.fallback = {};",
          "88:         this.fallback.operation = {",
          "89:           target: this.receiver.address,",
          "90:           value: '0',",
          "92:         };",
          "93:         this.fallback.operationId = hashOperation(",
          "94:           this.mock.address,",
          "95:           this.fallback.operation.target,",
          "96:           this.fallback.operation.data,",
          "97:         );",
          "101:         await web3.eth.sendTransaction({ from: admin, to: this.mock.address, value: 1 });",
          "105:         expect(await this.mock.name()).to.be.equal(name);",
          "106:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "107:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "108:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "109:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "111:         expect(await this.mock.accessManager()).to.be.equal(this.manager.address);",
          "115:         const baseDelay = time.duration.hours(10);",
          "118:         await expectRevertCustomError(",
          "119:           this.mock.setBaseDelaySeconds(baseDelay, { from: voter1 }),",
          "120:           'GovernorOnlyExecutor',",
          "121:           [voter1],",
          "122:         );",
          "127:               target: this.mock.address,",
          "128:               value: '0',",
          "129:               data: this.mock.contract.methods.setBaseDelaySeconds(baseDelay).encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "4: const { anyValue } = require('@nomicfoundation/hardhat-chai-matchers/withArgs');",
          "6: const { GovernorHelper } = require('../../helpers/governance');",
          "7: const { bigint: Enums } = require('../../helpers/enums');",
          "8: const { bigint: time } = require('../../helpers/time');",
          "9: const { max } = require('../../helpers/math');",
          "13: function prepareOperation({ sender, target, value = 0n, data = '0x' }) {",
          "14:   return {",
          "15:     id: hashOperation(sender, target, data),",
          "16:     operation: { target, value, data },",
          "17:     selector: data.slice(0, 10).padEnd(10, '0'),",
          "18:   };",
          "19: }",
          "22:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "23:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "26: const name = 'OZ-Governor';",
          "27: const version = '1';",
          "28: const tokenName = 'MockToken';",
          "29: const tokenSymbol = 'MTKN';",
          "30: const tokenSupply = ethers.parseEther('100');",
          "31: const votingDelay = 4n;",
          "32: const votingPeriod = 16n;",
          "33: const value = ethers.parseEther('1');",
          "35: describe('GovernorTimelockAccess', function () {",
          "36:   for (const { Token, mode } of TOKENS) {",
          "37:     const fixture = async () => {",
          "38:       const [admin, voter1, voter2, voter3, voter4, other] = await ethers.getSigners();",
          "40:       const manager = await ethers.deployContract('$AccessManager', [admin]);",
          "41:       const receiver = await ethers.deployContract('$AccessManagedTarget', [manager]);",
          "43:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "44:       const mock = await ethers.deployContract('$GovernorTimelockAccessMock', [",
          "45:         name,",
          "46:         votingDelay,",
          "47:         votingPeriod,",
          "48:         0n,",
          "49:         manager,",
          "50:         0n,",
          "51:         token,",
          "52:         0n,",
          "53:       ]);",
          "55:       await admin.sendTransaction({ to: mock, value });",
          "56:       await token.$_mint(admin, tokenSupply);",
          "58:       const helper = new GovernorHelper(mock, mode);",
          "59:       await helper.connect(admin).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "60:       await helper.connect(admin).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "61:       await helper.connect(admin).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "62:       await helper.connect(admin).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "64:       return { admin, voter1, voter2, voter3, voter4, other, manager, receiver, token, mock, helper };",
          "65:     };",
          "67:     describe(`using ${Token}`, function () {",
          "69:         Object.assign(this, await loadFixture(fixture));",
          "72:         this.restricted = prepareOperation({",
          "73:           sender: this.mock.target,",
          "74:           target: this.receiver.target,",
          "75:           data: this.receiver.interface.encodeFunctionData('fnRestricted'),",
          "76:         });",
          "78:         this.unrestricted = prepareOperation({",
          "79:           sender: this.mock.target,",
          "80:           target: this.receiver.target,",
          "81:           data: this.receiver.interface.encodeFunctionData('fnUnrestricted'),",
          "82:         });",
          "84:         this.fallback = prepareOperation({",
          "85:           sender: this.mock.target,",
          "86:           target: this.receiver.target,",
          "88:         });",
          "92:         await this.admin.sendTransaction({ to: this.mock, value: 1n });",
          "96:         expect(await this.mock.name()).to.equal(name);",
          "97:         expect(await this.mock.token()).to.equal(this.token.target);",
          "98:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "99:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "100:         expect(await this.mock.quorum(0n)).to.equal(0n);",
          "102:         expect(await this.mock.accessManager()).to.equal(this.manager.target);",
          "106:         const baseDelay = time.duration.hours(10n);",
          "109:         await expect(this.mock.connect(this.voter1).setBaseDelaySeconds(baseDelay))",
          "110:           .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "111:           .withArgs(this.voter1.address);",
          "116:               target: this.mock.target,",
          "117:               data: this.mock.interface.encodeFunctionData('setBaseDelaySeconds', [baseDelay]),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:         await this.helper.propose();",
          "136:         await this.helper.waitForSnapshot();",
          "138:         await this.helper.waitForDeadline();",
          "147:       });",
          "149:       it('sets access manager ignored', async function () {",
          "150:         const selectors = ['0x12345678', '0x87654321', '0xabcdef01'];",
          "162:           [",
          "163:             {",
          "167:             },",
          "168:           ],",
          "169:           'descr',",
          "170:         );",
          "178:         for (const selector of selectors) {",
          "185:         }",
          "190:           [",
          "191:             {",
          "195:             },",
          "196:           ],",
          "197:           'descr',",
          "198:         );",
          "206:         for (const selector of selectors) {",
          "213:         }",
          "214:       });",
          "216:       it('sets access manager ignored when target is the governor', async function () {",
          "218:         const selectors = ['0x12345678', '0x87654321', '0xabcdef01'];",
          "220:         await this.helper.setProposal(",
          "221:           [",
          "222:             {",
          "226:             },",
          "227:           ],",
          "228:           'descr',",
          "",
          "[Removed Lines]",
          "137:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "139:         const receipt = await this.helper.execute();",
          "141:         expectEvent(receipt, 'BaseDelaySet', {",
          "142:           oldBaseDelaySeconds: '0',",
          "143:           newBaseDelaySeconds: baseDelay,",
          "144:         });",
          "146:         expect(await this.mock.baseDelaySeconds()).to.be.bignumber.eq(baseDelay);",
          "153:         await expectRevertCustomError(",
          "154:           this.mock.setAccessManagerIgnored(other, selectors, true, { from: voter1 }),",
          "155:           'GovernorOnlyExecutor',",
          "156:           [voter1],",
          "157:         );",
          "160:         const helperIgnore = new GovernorHelper(this.mock, mode);",
          "161:         await helperIgnore.setProposal(",
          "164:               target: this.mock.address,",
          "165:               value: '0',",
          "166:               data: this.mock.contract.methods.setAccessManagerIgnored(other, selectors, true).encodeABI(),",
          "172:         await helperIgnore.propose();",
          "173:         await helperIgnore.waitForSnapshot();",
          "174:         await helperIgnore.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "175:         await helperIgnore.waitForDeadline();",
          "176:         const ignoreReceipt = await helperIgnore.execute();",
          "179:           expectEvent(ignoreReceipt, 'AccessManagerIgnoredSet', {",
          "180:             target: other,",
          "181:             selector,",
          "182:             ignored: true,",
          "183:           });",
          "184:           expect(await this.mock.isAccessManagerIgnored(other, selector)).to.be.true;",
          "188:         const helperUnignore = new GovernorHelper(this.mock, mode);",
          "189:         await helperUnignore.setProposal(",
          "192:               target: this.mock.address,",
          "193:               value: '0',",
          "194:               data: this.mock.contract.methods.setAccessManagerIgnored(other, selectors, false).encodeABI(),",
          "200:         await helperUnignore.propose();",
          "201:         await helperUnignore.waitForSnapshot();",
          "202:         await helperUnignore.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "203:         await helperUnignore.waitForDeadline();",
          "204:         const unignoreReceipt = await helperUnignore.execute();",
          "207:           expectEvent(unignoreReceipt, 'AccessManagerIgnoredSet', {",
          "208:             target: other,",
          "209:             selector,",
          "210:             ignored: false,",
          "211:           });",
          "212:           expect(await this.mock.isAccessManagerIgnored(other, selector)).to.be.false;",
          "217:         const other = this.mock.address;",
          "223:               target: this.mock.address,",
          "224:               value: '0',",
          "225:               data: this.mock.contract.methods.setAccessManagerIgnored(other, selectors, true).encodeABI(),",
          "",
          "[Added Lines]",
          "125:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "128:         await expect(this.helper.execute()).to.emit(this.mock, 'BaseDelaySet').withArgs(0n, baseDelay);",
          "130:         expect(await this.mock.baseDelaySeconds()).to.equal(baseDelay);",
          "137:         await expect(this.mock.connect(this.voter1).setAccessManagerIgnored(this.other, selectors, true))",
          "138:           .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "139:           .withArgs(this.voter1.address);",
          "142:         await this.helper.setProposal(",
          "145:               target: this.mock.target,",
          "146:               data: this.mock.interface.encodeFunctionData('setAccessManagerIgnored', [",
          "147:                 this.other.address,",
          "148:                 selectors,",
          "149:                 true,",
          "150:               ]),",
          "155:         await this.helper.propose();",
          "156:         await this.helper.waitForSnapshot();",
          "157:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "158:         await this.helper.waitForDeadline();",
          "160:         const ignoreReceipt = this.helper.execute();",
          "162:           await expect(ignoreReceipt)",
          "163:             .to.emit(this.mock, 'AccessManagerIgnoredSet')",
          "164:             .withArgs(this.other.address, selector, true);",
          "165:           expect(await this.mock.isAccessManagerIgnored(this.other, selector)).to.be.true;",
          "169:         await this.helper.setProposal(",
          "172:               target: this.mock.target,",
          "173:               data: this.mock.interface.encodeFunctionData('setAccessManagerIgnored', [",
          "174:                 this.other.address,",
          "175:                 selectors,",
          "176:                 false,",
          "177:               ]),",
          "183:         await this.helper.propose();",
          "184:         await this.helper.waitForSnapshot();",
          "185:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "186:         await this.helper.waitForDeadline();",
          "188:         const unignoreReceipt = this.helper.execute();",
          "190:           await expect(unignoreReceipt)",
          "191:             .to.emit(this.mock, 'AccessManagerIgnoredSet')",
          "192:             .withArgs(this.other.address, selector, false);",
          "193:           expect(await this.mock.isAccessManagerIgnored(this.other, selector)).to.be.false;",
          "203:               target: this.mock.target,",
          "204:               data: this.mock.interface.encodeFunctionData('setAccessManagerIgnored', [",
          "205:                 this.mock.target,",
          "206:                 selectors,",
          "207:                 true,",
          "208:               ]),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "231:         await this.helper.propose();",
          "232:         await this.helper.waitForSnapshot();",
          "234:         await this.helper.waitForDeadline();",
          "237:         for (const selector of selectors) {",
          "244:         }",
          "245:       });",
          "247:       it('does not need to queue proposals with no delay', async function () {",
          "260:         await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "263:         await this.helper.propose();",
          "264:         expect(await this.mock.proposalNeedsQueuing(this.helper.currentProposal.id)).to.be.false;",
          "265:       });",
          "267:       it('needs to queue proposals with any delay', async function () {",
          "270:         const delays = [",
          "273:         ];",
          "275:         for (const [executionDelay, baseDelay] of delays) {",
          "283:           await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "287:             [this.restricted.operation],",
          "288:             `executionDelay=${executionDelay.toString()}}baseDelay=${baseDelay.toString()}}`,",
          "289:           );",
          "292:         }",
          "293:       });",
          "295:       describe('execution plan', function () {",
          "296:         it('returns plan for delayed operations', async function () {",
          "299:           const delays = [",
          "302:           ];",
          "304:           for (const [executionDelay, baseDelay] of delays) {",
          "312:             await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "316:               [this.restricted.operation],",
          "317:               `executionDelay=${executionDelay.toString()}}baseDelay=${baseDelay.toString()}}`,",
          "318:             );",
          "325:           }",
          "326:         });",
          "328:         it('returns plan for not delayed operations', async function () {",
          "341:           await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "343:           this.proposal = await this.helper.setProposal([this.restricted.operation], `descr`);",
          "344:           await this.helper.propose();",
          "349:         });",
          "351:         it('returns plan for an operation ignoring the manager', async function () {",
          "356:           const delays = [",
          "359:           ];",
          "361:           for (const [executionDelay, baseDelay] of delays) {",
          "369:             await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "373:               [this.restricted.operation],",
          "374:               `executionDelay=${executionDelay.toString()}}baseDelay=${baseDelay.toString()}}`,",
          "375:             );",
          "381:           }",
          "382:         });",
          "383:       });",
          "",
          "[Removed Lines]",
          "233:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "235:         const receipt = await this.helper.execute();",
          "238:           expectEvent(receipt, 'AccessManagerIgnoredSet', {",
          "239:             target: other,",
          "240:             selector,",
          "241:             ignored: true,",
          "242:           });",
          "243:           expect(await this.mock.isAccessManagerIgnored(other, selector)).to.be.true;",
          "248:         const roleId = '1';",
          "250:         const executionDelay = web3.utils.toBN(0);",
          "251:         const baseDelay = web3.utils.toBN(0);",
          "254:         await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "255:           from: admin,",
          "256:         });",
          "257:         await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "262:         this.proposal = await this.helper.setProposal([this.restricted.operation], 'descr');",
          "268:         const roleId = '1';",
          "271:           [time.duration.hours(1), time.duration.hours(2)],",
          "272:           [time.duration.hours(2), time.duration.hours(1)],",
          "277:           await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "278:             from: admin,",
          "279:           });",
          "280:           await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "285:           const helper = new GovernorHelper(this.mock, mode);",
          "286:           this.proposal = await helper.setProposal(",
          "290:           await helper.propose();",
          "291:           expect(await this.mock.proposalNeedsQueuing(helper.currentProposal.id)).to.be.true;",
          "297:           const roleId = '1';",
          "300:             [time.duration.hours(1), time.duration.hours(2)],",
          "301:             [time.duration.hours(2), time.duration.hours(1)],",
          "306:             await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "307:               from: admin,",
          "308:             });",
          "309:             await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "314:             const helper = new GovernorHelper(this.mock, mode);",
          "315:             this.proposal = await helper.setProposal(",
          "319:             await helper.propose();",
          "320:             const { delay: planDelay, indirect, withDelay } = await this.mock.proposalExecutionPlan(this.proposal.id);",
          "321:             const maxDelay = web3.utils.toBN(Math.max(baseDelay.toNumber(), executionDelay.toNumber()));",
          "322:             expect(planDelay).to.be.bignumber.eq(maxDelay);",
          "323:             expect(indirect).to.deep.eq([true]);",
          "324:             expect(withDelay).to.deep.eq([true]);",
          "329:           const roleId = '1';",
          "331:           const executionDelay = web3.utils.toBN(0);",
          "332:           const baseDelay = web3.utils.toBN(0);",
          "335:           await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "336:             from: admin,",
          "337:           });",
          "338:           await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "345:           const { delay: planDelay, indirect, withDelay } = await this.mock.proposalExecutionPlan(this.proposal.id);",
          "346:           expect(planDelay).to.be.bignumber.eq(web3.utils.toBN(0));",
          "347:           expect(indirect).to.deep.eq([true]);",
          "348:           expect(withDelay).to.deep.eq([false]);",
          "352:           await this.mock.$_setAccessManagerIgnored(this.receiver.address, this.restricted.selector, true);",
          "354:           const roleId = '1';",
          "357:             [time.duration.hours(1), time.duration.hours(2)],",
          "358:             [time.duration.hours(2), time.duration.hours(1)],",
          "363:             await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "364:               from: admin,",
          "365:             });",
          "366:             await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "371:             const helper = new GovernorHelper(this.mock, mode);",
          "372:             this.proposal = await helper.setProposal(",
          "376:             await helper.propose();",
          "377:             const { delay: planDelay, indirect, withDelay } = await this.mock.proposalExecutionPlan(this.proposal.id);",
          "378:             expect(planDelay).to.be.bignumber.eq(baseDelay);",
          "379:             expect(indirect).to.deep.eq([false]);",
          "380:             expect(withDelay).to.deep.eq([false]);",
          "",
          "[Added Lines]",
          "216:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "219:         const tx = this.helper.execute();",
          "221:           await expect(tx).to.emit(this.mock, 'AccessManagerIgnoredSet').withArgs(this.mock.target, selector, true);",
          "222:           expect(await this.mock.isAccessManagerIgnored(this.mock, selector)).to.be.true;",
          "227:         const roleId = 1n;",
          "228:         const executionDelay = 0n;",
          "229:         const baseDelay = 0n;",
          "232:         await this.manager.connect(this.admin).setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "233:         await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "238:         await this.helper.setProposal([this.restricted.operation], 'descr');",
          "244:         const roleId = 1n;",
          "246:           [time.duration.hours(1n), time.duration.hours(2n)],",
          "247:           [time.duration.hours(2n), time.duration.hours(1n)],",
          "252:           await this.manager",
          "253:             .connect(this.admin)",
          "254:             .setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "255:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "260:           await this.helper.setProposal(",
          "264:           await this.helper.propose();",
          "265:           expect(await this.mock.proposalNeedsQueuing(this.helper.currentProposal.id)).to.be.true;",
          "271:           const roleId = 1n;",
          "273:             [time.duration.hours(1n), time.duration.hours(2n)],",
          "274:             [time.duration.hours(2n), time.duration.hours(1n)],",
          "279:             await this.manager",
          "280:               .connect(this.admin)",
          "281:               .setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "282:             await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "287:             this.proposal = await this.helper.setProposal(",
          "291:             await this.helper.propose();",
          "293:             expect(await this.mock.proposalExecutionPlan(this.proposal.id)).to.deep.equal([",
          "294:               max(baseDelay, executionDelay),",
          "295:               [true],",
          "296:               [true],",
          "297:             ]);",
          "302:           const roleId = 1n;",
          "303:           const executionDelay = 0n;",
          "304:           const baseDelay = 0n;",
          "307:           await this.manager",
          "308:             .connect(this.admin)",
          "309:             .setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "310:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "318:           expect(await this.mock.proposalExecutionPlan(this.proposal.id)).to.deep.equal([0n, [true], [false]]);",
          "322:           await this.mock.$_setAccessManagerIgnored(this.receiver, this.restricted.selector, true);",
          "324:           const roleId = 1n;",
          "326:             [time.duration.hours(1n), time.duration.hours(2n)],",
          "327:             [time.duration.hours(2n), time.duration.hours(1n)],",
          "332:             await this.manager",
          "333:               .connect(this.admin)",
          "334:               .setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "335:             await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "340:             this.proposal = await this.helper.setProposal(",
          "344:             await this.helper.propose();",
          "346:             expect(await this.mock.proposalExecutionPlan(this.proposal.id)).to.deep.equal([",
          "347:               baseDelay,",
          "348:               [false],",
          "349:               [false],",
          "350:             ]);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:             this.proposal = await this.helper.setProposal([this.unrestricted.operation], 'descr');",
          "396:             await this.helper.propose();",
          "398:             await this.helper.waitForSnapshot();",
          "400:             await this.helper.waitForDeadline();",
          "401:             if (await this.mock.proposalNeedsQueuing(this.proposal.id)) {",
          "404:             }",
          "405:             if (delay > 0) {",
          "406:               await this.helper.waitForEta();",
          "407:             }",
          "411:           });",
          "412:         }",
          "413:       });",
          "415:       it('reverts when an operation is executed before eta', async function () {",
          "417:         await this.mock.$_setBaseDelaySeconds(delay);",
          "419:         this.proposal = await this.helper.setProposal([this.unrestricted.operation], 'descr');",
          "421:         await this.helper.propose();",
          "422:         await this.helper.waitForSnapshot();",
          "424:         await this.helper.waitForDeadline();",
          "425:         await this.helper.queue();",
          "430:       });",
          "432:       it('reverts with a proposal including multiple operations but one of those was cancelled in the manager', async function () {",
          "442:         const original = new GovernorHelper(this.mock, mode);",
          "",
          "[Removed Lines]",
          "399:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "402:               const txQueue = await this.helper.queue();",
          "403:               expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "408:             const txExecute = await this.helper.execute();",
          "409:             expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "410:             expectEvent.inTransaction(txExecute, this.receiver, 'CalledUnrestricted');",
          "416:         const delay = time.duration.hours(2);",
          "423:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "426:         await expectRevertCustomError(this.helper.execute(), 'GovernorUnmetDelay', [",
          "427:           this.proposal.id,",
          "428:           await this.mock.proposalEta(this.proposal.id),",
          "429:         ]);",
          "433:         const delay = time.duration.hours(2);",
          "434:         const roleId = '1';",
          "436:         await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "437:           from: admin,",
          "438:         });",
          "439:         await this.manager.grantRole(roleId, this.mock.address, delay, { from: admin });",
          "",
          "[Added Lines]",
          "368:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "371:               expect(await this.helper.queue())",
          "372:                 .to.emit(this.mock, 'ProposalQueued')",
          "373:                 .withArgs(this.proposal.id);",
          "378:             expect(await this.helper.execute())",
          "379:               .to.emit(this.mock, 'ProposalExecuted')",
          "380:               .withArgs(this.proposal.id)",
          "381:               .to.not.emit(this.receiver, 'CalledUnrestricted');",
          "387:         const delay = time.duration.hours(2n);",
          "394:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "397:         await expect(this.helper.execute())",
          "398:           .to.be.revertedWithCustomError(this.mock, 'GovernorUnmetDelay')",
          "399:           .withArgs(this.proposal.id, await this.mock.proposalEta(this.proposal.id));",
          "403:         const delay = time.duration.hours(2n);",
          "404:         const roleId = 1n;",
          "406:         await this.manager.connect(this.admin).setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "407:         await this.manager.connect(this.admin).grantRole(roleId, this.mock, delay);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "446:         await original.propose();",
          "447:         await original.waitForSnapshot();",
          "449:         await original.waitForDeadline();",
          "450:         await original.queue();",
          "451:         await original.waitForEta();",
          "459:         const rescheduled = new GovernorHelper(this.mock, mode);",
          "460:         await rescheduled.setProposal([this.restricted.operation], 'descr');",
          "461:         await rescheduled.propose();",
          "462:         await rescheduled.waitForSnapshot();",
          "464:         await rescheduled.waitForDeadline();",
          "465:         await rescheduled.queue(); // This will schedule it again in the manager",
          "466:         await rescheduled.waitForEta();",
          "474:       });",
          "476:       it('single operation with access manager delay', async function () {",
          "485:         this.proposal = await this.helper.setProposal([this.restricted.operation], 'descr');",
          "487:         await this.helper.propose();",
          "488:         await this.helper.waitForSnapshot();",
          "490:         await this.helper.waitForDeadline();",
          "491:         const txQueue = await this.helper.queue();",
          "492:         await this.helper.waitForEta();",
          "493:         const txExecute = await this.helper.execute();",
          "511:       });",
          "513:       it('bundle of varied operations', async function () {",
          "519:         await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "526:         this.proposal = await this.helper.setProposal(",
          "527:           [this.restricted.operation, this.unrestricted.operation, this.fallback.operation],",
          "",
          "[Removed Lines]",
          "448:         await original.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "454:         await this.manager.cancel(this.mock.address, this.restricted.operation.target, this.restricted.operation.data, {",
          "455:           from: admin,",
          "456:         });",
          "463:         await rescheduled.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "469:         await expectRevertCustomError(original.execute(), 'GovernorMismatchedNonce', [",
          "470:           original.currentProposal.id,",
          "471:           1,",
          "472:           2,",
          "473:         ]);",
          "477:         const delay = 1000;",
          "478:         const roleId = '1';",
          "480:         await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "481:           from: admin,",
          "482:         });",
          "483:         await this.manager.grantRole(roleId, this.mock.address, delay, { from: admin });",
          "489:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "495:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "496:         await expectEvent.inTransaction(txQueue.tx, this.manager, 'OperationScheduled', {",
          "497:           operationId: this.restricted.operationId,",
          "498:           nonce: '1',",
          "499:           schedule: web3.utils.toBN(await clockFromReceipt.timestamp(txQueue.receipt)).addn(delay),",
          "500:           caller: this.mock.address,",
          "501:           target: this.restricted.operation.target,",
          "502:           data: this.restricted.operation.data,",
          "503:         });",
          "505:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "506:         await expectEvent.inTransaction(txExecute.tx, this.manager, 'OperationExecuted', {",
          "507:           operationId: this.restricted.operationId,",
          "508:           nonce: '1',",
          "509:         });",
          "510:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'CalledRestricted');",
          "514:         const managerDelay = 1000;",
          "515:         const roleId = '1';",
          "517:         const baseDelay = managerDelay * 2;",
          "521:         await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "522:           from: admin,",
          "523:         });",
          "524:         await this.manager.grantRole(roleId, this.mock.address, managerDelay, { from: admin });",
          "",
          "[Added Lines]",
          "416:         await original.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "422:         await this.manager",
          "423:           .connect(this.admin)",
          "424:           .cancel(this.mock, this.restricted.operation.target, this.restricted.operation.data);",
          "431:         await rescheduled.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "437:         await expect(original.execute())",
          "438:           .to.be.revertedWithCustomError(this.mock, 'GovernorMismatchedNonce')",
          "439:           .withArgs(original.currentProposal.id, 1, 2);",
          "443:         const delay = 1000n;",
          "444:         const roleId = 1n;",
          "446:         await this.manager.connect(this.admin).setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "447:         await this.manager.connect(this.admin).grantRole(roleId, this.mock, delay);",
          "453:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "459:         await expect(txQueue)",
          "460:           .to.emit(this.mock, 'ProposalQueued')",
          "461:           .withArgs(this.proposal.id, anyValue)",
          "462:           .to.emit(this.manager, 'OperationScheduled')",
          "463:           .withArgs(",
          "464:             this.restricted.id,",
          "465:             1n,",
          "466:             (await time.clockFromReceipt.timestamp(txQueue)) + delay,",
          "467:             this.mock.target,",
          "468:             this.restricted.operation.target,",
          "469:             this.restricted.operation.data,",
          "470:           );",
          "472:         await expect(txExecute)",
          "473:           .to.emit(this.mock, 'ProposalExecuted')",
          "474:           .withArgs(this.proposal.id)",
          "475:           .to.emit(this.manager, 'OperationExecuted')",
          "476:           .withArgs(this.restricted.id, 1n)",
          "477:           .to.emit(this.receiver, 'CalledRestricted');",
          "481:         const managerDelay = 1000n;",
          "482:         const roleId = 1n;",
          "483:         const baseDelay = managerDelay * 2n;",
          "487:         await this.manager.connect(this.admin).setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "488:         await this.manager.connect(this.admin).grantRole(roleId, this.mock, managerDelay);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "531:         await this.helper.propose();",
          "532:         await this.helper.waitForSnapshot();",
          "534:         await this.helper.waitForDeadline();",
          "535:         const txQueue = await this.helper.queue();",
          "536:         await this.helper.waitForEta();",
          "537:         const txExecute = await this.helper.execute();",
          "557:       });",
          "559:       describe('cancel', function () {",
          "563:         beforeEach(async function () {",
          "568:         });",
          "570:         it('cancels restricted with delay after queue (internal)', async function () {",
          "",
          "[Removed Lines]",
          "533:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "539:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "540:         await expectEvent.inTransaction(txQueue.tx, this.manager, 'OperationScheduled', {",
          "541:           operationId: this.restricted.operationId,",
          "542:           nonce: '1',",
          "543:           schedule: web3.utils.toBN(await clockFromReceipt.timestamp(txQueue.receipt)).addn(baseDelay),",
          "544:           caller: this.mock.address,",
          "545:           target: this.restricted.operation.target,",
          "546:           data: this.restricted.operation.data,",
          "547:         });",
          "549:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "550:         await expectEvent.inTransaction(txExecute.tx, this.manager, 'OperationExecuted', {",
          "551:           operationId: this.restricted.operationId,",
          "552:           nonce: '1',",
          "553:         });",
          "554:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'CalledRestricted');",
          "555:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'CalledUnrestricted');",
          "556:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'CalledFallback');",
          "560:         const delay = 1000;",
          "561:         const roleId = '1';",
          "564:           await this.manager.setTargetFunctionRole(this.receiver.address, [this.restricted.selector], roleId, {",
          "565:             from: admin,",
          "566:           });",
          "567:           await this.manager.grantRole(roleId, this.mock.address, delay, { from: admin });",
          "",
          "[Added Lines]",
          "497:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "503:         await expect(txQueue)",
          "504:           .to.emit(this.mock, 'ProposalQueued')",
          "505:           .withArgs(this.proposal.id, anyValue)",
          "506:           .to.emit(this.manager, 'OperationScheduled')",
          "507:           .withArgs(",
          "508:             this.restricted.id,",
          "509:             1n,",
          "510:             (await time.clockFromReceipt.timestamp(txQueue)) + baseDelay,",
          "511:             this.mock.target,",
          "512:             this.restricted.operation.target,",
          "513:             this.restricted.operation.data,",
          "514:           );",
          "516:         await expect(txExecute)",
          "517:           .to.emit(this.mock, 'ProposalExecuted')",
          "518:           .withArgs(this.proposal.id)",
          "519:           .to.emit(this.manager, 'OperationExecuted')",
          "520:           .withArgs(this.restricted.id, 1n)",
          "521:           .to.emit(this.receiver, 'CalledRestricted')",
          "522:           .to.emit(this.receiver, 'CalledUnrestricted')",
          "523:           .to.emit(this.receiver, 'CalledFallback');",
          "527:         const delay = 1000n;",
          "528:         const roleId = 1n;",
          "531:           await this.manager",
          "532:             .connect(this.admin)",
          "533:             .setTargetFunctionRole(this.receiver, [this.restricted.selector], roleId);",
          "534:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, delay);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "573:           await this.helper.propose();",
          "574:           await this.helper.waitForSnapshot();",
          "576:           await this.helper.waitForDeadline();",
          "577:           await this.helper.queue();",
          "586:           await this.helper.waitForEta();",
          "592:         });",
          "594:         it('cancels restricted with queueing if the same operation is part of a more recent proposal (internal)', async function () {",
          "",
          "[Removed Lines]",
          "575:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "579:           const txCancel = await this.helper.cancel('internal');",
          "580:           expectEvent(txCancel, 'ProposalCanceled', { proposalId: this.proposal.id });",
          "581:           await expectEvent.inTransaction(txCancel.tx, this.manager, 'OperationCanceled', {",
          "582:             operationId: this.restricted.operationId,",
          "583:             nonce: '1',",
          "584:           });",
          "587:           await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "588:             this.proposal.id,",
          "589:             Enums.ProposalState.Canceled,",
          "590:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "591:           ]);",
          "",
          "[Added Lines]",
          "542:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "546:           await expect(this.helper.cancel('internal'))",
          "547:             .to.emit(this.mock, 'ProposalCanceled')",
          "548:             .withArgs(this.proposal.id)",
          "549:             .to.emit(this.manager, 'OperationCanceled')",
          "550:             .withArgs(this.restricted.id, 1n);",
          "554:           await expect(this.helper.execute())",
          "555:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "556:             .withArgs(",
          "557:               this.proposal.id,",
          "558:               Enums.ProposalState.Canceled,",
          "559:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "560:             );",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "600:           await original.propose();",
          "601:           await original.waitForSnapshot();",
          "603:           await original.waitForDeadline();",
          "604:           await original.queue();",
          "615:           const rescheduled = new GovernorHelper(this.mock, mode);",
          "",
          "[Removed Lines]",
          "602:           await original.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "607:           await this.manager.cancel(",
          "608:             this.mock.address,",
          "609:             this.restricted.operation.target,",
          "610:             this.restricted.operation.data,",
          "611:             { from: admin },",
          "612:           );",
          "",
          "[Added Lines]",
          "571:           await original.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "576:           await this.manager",
          "577:             .connect(this.admin)",
          "578:             .cancel(this.mock, this.restricted.operation.target, this.restricted.operation.data);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "619:           await rescheduled.propose();",
          "620:           await rescheduled.waitForSnapshot();",
          "622:           await rescheduled.waitForDeadline();",
          "623:           await rescheduled.queue(); // This will schedule it again in the manager",
          "626:           const eta = await this.mock.proposalEta(rescheduled.currentProposal.id);",
          "636:         });",
          "638:         it('cancels unrestricted with queueing (internal)', async function () {",
          "",
          "[Removed Lines]",
          "621:           await rescheduled.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "627:           const txCancel = await original.cancel('internal');",
          "628:           expectEvent(txCancel, 'ProposalCanceled', { proposalId: original.currentProposal.id });",
          "630:           await time.increase(eta); // waitForEta()",
          "631:           await expectRevertCustomError(original.execute(), 'GovernorUnexpectedProposalState', [",
          "632:             original.currentProposal.id,",
          "633:             Enums.ProposalState.Canceled,",
          "634:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "635:           ]);",
          "",
          "[Added Lines]",
          "587:           await rescheduled.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "594:           await expect(original.cancel('internal'))",
          "595:             .to.emit(this.mock, 'ProposalCanceled')",
          "596:             .withArgs(original.currentProposal.id);",
          "598:           await time.clock.timestamp().then(clock => time.forward.timestamp(max(clock + 1n, eta)));",
          "600:           await expect(original.execute())",
          "601:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "602:             .withArgs(",
          "603:               original.currentProposal.id,",
          "604:               Enums.ProposalState.Canceled,",
          "605:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "606:             );",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "641:           await this.helper.propose();",
          "642:           await this.helper.waitForSnapshot();",
          "644:           await this.helper.waitForDeadline();",
          "645:           await this.helper.queue();",
          "647:           const eta = await this.mock.proposalEta(this.proposal.id);",
          "657:         });",
          "659:         it('cancels unrestricted without queueing (internal)', async function () {",
          "",
          "[Removed Lines]",
          "643:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "648:           const txCancel = await this.helper.cancel('internal');",
          "649:           expectEvent(txCancel, 'ProposalCanceled', { proposalId: this.proposal.id });",
          "651:           await time.increase(eta); // waitForEta()",
          "652:           await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "653:             this.proposal.id,",
          "654:             Enums.ProposalState.Canceled,",
          "655:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "656:           ]);",
          "",
          "[Added Lines]",
          "614:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "620:           await expect(this.helper.cancel('internal'))",
          "621:             .to.emit(this.mock, 'ProposalCanceled')",
          "622:             .withArgs(this.proposal.id);",
          "624:           await time.clock.timestamp().then(clock => time.forward.timestamp(max(clock + 1n, eta)));",
          "626:           await expect(this.helper.execute())",
          "627:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "628:             .withArgs(",
          "629:               this.proposal.id,",
          "630:               Enums.ProposalState.Canceled,",
          "631:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "632:             );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "662:           await this.helper.propose();",
          "663:           await this.helper.waitForSnapshot();",
          "665:           await this.helper.waitForDeadline();",
          "678:         });",
          "680:         it('cancels calls already canceled by guardian', async function () {",
          "687:           const proposal1 = new GovernorHelper(this.mock, mode);",
          "688:           const proposal2 = new GovernorHelper(this.mock, mode);",
          "",
          "[Removed Lines]",
          "664:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "669:           const txCancel = await this.helper.cancel('internal');",
          "670:           expectEvent(txCancel, 'ProposalCanceled', { proposalId: this.proposal.id });",
          "673:           await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "674:             this.proposal.id,",
          "675:             Enums.ProposalState.Canceled,",
          "676:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "677:           ]);",
          "681:           const operationA = { target: this.receiver.address, data: this.restricted.selector + '00' };",
          "682:           const operationB = { target: this.receiver.address, data: this.restricted.selector + '01' };",
          "683:           const operationC = { target: this.receiver.address, data: this.restricted.selector + '02' };",
          "684:           const operationAId = hashOperation(this.mock.address, operationA.target, operationA.data);",
          "685:           const operationBId = hashOperation(this.mock.address, operationB.target, operationB.data);",
          "",
          "[Added Lines]",
          "640:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "645:           await expect(this.helper.cancel('internal'))",
          "646:             .to.emit(this.mock, 'ProposalCanceled')",
          "647:             .withArgs(this.proposal.id);",
          "650:           await expect(this.helper.execute())",
          "651:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "652:             .withArgs(",
          "653:               this.proposal.id,",
          "654:               Enums.ProposalState.Canceled,",
          "655:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "656:             );",
          "660:           const operationA = { target: this.receiver.target, data: this.restricted.selector + '00' };",
          "661:           const operationB = { target: this.receiver.target, data: this.restricted.selector + '01' };",
          "662:           const operationC = { target: this.receiver.target, data: this.restricted.selector + '02' };",
          "663:           const operationAId = hashOperation(this.mock.target, operationA.target, operationA.data);",
          "664:           const operationBId = hashOperation(this.mock.target, operationB.target, operationB.data);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "692:           for (const p of [proposal1, proposal2]) {",
          "693:             await p.propose();",
          "694:             await p.waitForSnapshot();",
          "696:             await p.waitForDeadline();",
          "697:           }",
          "",
          "[Removed Lines]",
          "695:             await p.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "",
          "[Added Lines]",
          "674:             await p.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "700:           await proposal1.queue();",
          "711:           await proposal1.waitForEta();",
          "717:           await proposal1.cancel('internal');",
          "",
          "[Removed Lines]",
          "703:           await expectRevertCustomError(proposal2.queue(), 'AccessManagerAlreadyScheduled', [operationAId]);",
          "706:           await this.manager.cancel(this.mock.address, operationB.target, operationB.data, { from: admin });",
          "709:           await expectRevertCustomError(proposal2.queue(), 'AccessManagerAlreadyScheduled', [operationAId]);",
          "714:           await expectRevertCustomError(proposal1.execute(), 'AccessManagerNotScheduled', [operationBId]);",
          "",
          "[Added Lines]",
          "682:           await expect(proposal2.queue())",
          "683:             .to.be.revertedWithCustomError(this.manager, 'AccessManagerAlreadyScheduled')",
          "684:             .withArgs(operationAId);",
          "687:           await this.manager.connect(this.admin).cancel(this.mock, operationB.target, operationB.data);",
          "690:           await expect(proposal2.queue())",
          "691:             .to.be.revertedWithCustomError(this.manager, 'AccessManagerAlreadyScheduled')",
          "692:             .withArgs(operationAId);",
          "697:           await expect(proposal1.execute())",
          "698:             .to.be.revertedWithCustomError(this.manager, 'AccessManagerNotScheduled')",
          "699:             .withArgs(operationBId);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "729:       describe('ignore AccessManager', function () {",
          "730:         it('defaults', async function () {",
          "735:         });",
          "737:         it('internal setter', async function () {",
          "747:         });",
          "749:         it('external setter', async function () {",
          "750:           const setAccessManagerIgnored = (...args) =>",
          "753:           await this.helper.setProposal(",
          "754:             [",
          "755:               {",
          "757:                 data: setAccessManagerIgnored(",
          "759:                   [this.restricted.selector, this.unrestricted.selector],",
          "760:                   true,",
          "761:                 ),",
          "763:               },",
          "764:               {",
          "768:               },",
          "769:             ],",
          "770:             'descr',",
          "",
          "[Removed Lines]",
          "731:           expect(await this.mock.isAccessManagerIgnored(this.receiver.address, this.restricted.selector)).to.equal(",
          "732:             false,",
          "733:           );",
          "734:           expect(await this.mock.isAccessManagerIgnored(this.mock.address, '0x12341234')).to.equal(true);",
          "738:           const p1 = { target: this.receiver.address, selector: this.restricted.selector, ignored: true };",
          "739:           const tx1 = await this.mock.$_setAccessManagerIgnored(p1.target, p1.selector, p1.ignored);",
          "740:           expect(await this.mock.isAccessManagerIgnored(p1.target, p1.selector)).to.equal(p1.ignored);",
          "741:           expectEvent(tx1, 'AccessManagerIgnoredSet', p1);",
          "743:           const p2 = { target: this.mock.address, selector: '0x12341234', ignored: false };",
          "744:           const tx2 = await this.mock.$_setAccessManagerIgnored(p2.target, p2.selector, p2.ignored);",
          "745:           expect(await this.mock.isAccessManagerIgnored(p2.target, p2.selector)).to.equal(p2.ignored);",
          "746:           expectEvent(tx2, 'AccessManagerIgnoredSet', p2);",
          "751:             this.mock.contract.methods.setAccessManagerIgnored(...args).encodeABI();",
          "756:                 target: this.mock.address,",
          "758:                   this.receiver.address,",
          "762:                 value: '0',",
          "765:                 target: this.mock.address,",
          "766:                 data: setAccessManagerIgnored(this.mock.address, ['0x12341234', '0x67896789'], false),",
          "767:                 value: '0',",
          "",
          "[Added Lines]",
          "716:           expect(await this.mock.isAccessManagerIgnored(this.receiver, this.restricted.selector)).to.be.false;",
          "717:           expect(await this.mock.isAccessManagerIgnored(this.mock, '0x12341234')).to.be.true;",
          "721:           await expect(this.mock.$_setAccessManagerIgnored(this.receiver, this.restricted.selector, true))",
          "722:             .to.emit(this.mock, 'AccessManagerIgnoredSet')",
          "723:             .withArgs(this.receiver.target, this.restricted.selector, true);",
          "725:           expect(await this.mock.isAccessManagerIgnored(this.receiver, this.restricted.selector)).to.be.true;",
          "727:           await expect(this.mock.$_setAccessManagerIgnored(this.mock, '0x12341234', false))",
          "728:             .to.emit(this.mock, 'AccessManagerIgnoredSet')",
          "729:             .withArgs(this.mock.target, '0x12341234', false);",
          "731:           expect(await this.mock.isAccessManagerIgnored(this.mock, '0x12341234')).to.be.false;",
          "736:             this.mock.interface.encodeFunctionData('setAccessManagerIgnored', args);",
          "741:                 target: this.mock.target,",
          "743:                   this.receiver.target,",
          "749:                 target: this.mock.target,",
          "750:                 data: setAccessManagerIgnored(this.mock.target, ['0x12341234', '0x67896789'], false),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "773:           await this.helper.propose();",
          "774:           await this.helper.waitForSnapshot();",
          "776:           await this.helper.waitForDeadline();",
          "790:         });",
          "792:         it('locked function', async function () {",
          "793:           const setAccessManagerIgnored = selector('setAccessManagerIgnored(address,bytes4[],bool)');",
          "800:         });",
          "802:         it('ignores access manager', async function () {",
          "807:           const selector = data.slice(0, 10);",
          "815:           await this.helper.propose();",
          "816:           await this.helper.waitForSnapshot();",
          "818:           await this.helper.waitForDeadline();",
          "825:           await this.mock.$_setAccessManagerIgnored(target, selector, true);",
          "828:           await this.helper.propose();",
          "829:           await this.helper.waitForSnapshot();",
          "831:           await this.helper.waitForDeadline();",
          "834:         });",
          "835:       });",
          "",
          "[Removed Lines]",
          "775:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "777:           const tx = await this.helper.execute();",
          "779:           expectEvent(tx, 'AccessManagerIgnoredSet');",
          "781:           expect(await this.mock.isAccessManagerIgnored(this.receiver.address, this.restricted.selector)).to.equal(",
          "782:             true,",
          "783:           );",
          "784:           expect(await this.mock.isAccessManagerIgnored(this.receiver.address, this.unrestricted.selector)).to.equal(",
          "785:             true,",
          "786:           );",
          "788:           expect(await this.mock.isAccessManagerIgnored(this.mock.address, '0x12341234')).to.equal(false);",
          "789:           expect(await this.mock.isAccessManagerIgnored(this.mock.address, '0x67896789')).to.equal(false);",
          "794:           await expectRevertCustomError(",
          "795:             this.mock.$_setAccessManagerIgnored(this.mock.address, setAccessManagerIgnored, true),",
          "796:             'GovernorLockedIgnore',",
          "797:             [],",
          "798:           );",
          "799:           await this.mock.$_setAccessManagerIgnored(this.receiver.address, setAccessManagerIgnored, true);",
          "803:           const amount = 100;",
          "805:           const target = this.token.address;",
          "806:           const data = this.token.contract.methods.transfer(voter4, amount).encodeABI();",
          "808:           await this.token.$_mint(this.mock.address, amount);",
          "810:           const roleId = '1';",
          "811:           await this.manager.setTargetFunctionRole(target, [selector], roleId, { from: admin });",
          "812:           await this.manager.grantRole(roleId, this.mock.address, 0, { from: admin });",
          "814:           this.proposal = await this.helper.setProposal([{ target, data, value: '0' }], '1');",
          "817:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "819:           await expectRevertCustomError(this.helper.execute(), 'ERC20InsufficientBalance', [",
          "820:             this.manager.address,",
          "821:             0,",
          "822:             amount,",
          "823:           ]);",
          "827:           await this.helper.setProposal([{ target, data, value: '0' }], '2');",
          "830:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "832:           const tx = await this.helper.execute();",
          "833:           expectEvent.inTransaction(tx, this.token, 'Transfer', { from: this.mock.address });",
          "",
          "[Added Lines]",
          "758:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "761:           await expect(this.helper.execute()).to.emit(this.mock, 'AccessManagerIgnoredSet');",
          "763:           expect(await this.mock.isAccessManagerIgnored(this.receiver, this.restricted.selector)).to.be.true;",
          "764:           expect(await this.mock.isAccessManagerIgnored(this.receiver, this.unrestricted.selector)).to.be.true;",
          "765:           expect(await this.mock.isAccessManagerIgnored(this.mock, '0x12341234')).to.be.false;",
          "766:           expect(await this.mock.isAccessManagerIgnored(this.mock, '0x67896789')).to.be.false;",
          "772:           await expect(",
          "773:             this.mock.$_setAccessManagerIgnored(this.mock, setAccessManagerIgnored, true),",
          "774:           ).to.be.revertedWithCustomError(this.mock, 'GovernorLockedIgnore');",
          "776:           await this.mock.$_setAccessManagerIgnored(this.receiver, setAccessManagerIgnored, true);",
          "780:           const amount = 100n;",
          "781:           const target = this.token.target;",
          "782:           const data = this.token.interface.encodeFunctionData('transfer', [this.voter4.address, amount]);",
          "784:           await this.token.$_mint(this.mock, amount);",
          "786:           const roleId = 1n;",
          "787:           await this.manager.connect(this.admin).setTargetFunctionRole(target, [selector], roleId);",
          "788:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, 0);",
          "790:           await this.helper.setProposal([{ target, data }], 'descr #1');",
          "793:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "796:           await expect(this.helper.execute())",
          "797:             .to.be.revertedWithCustomError(this.token, 'ERC20InsufficientBalance')",
          "798:             .withArgs(this.manager.target, 0n, amount);",
          "802:           await this.helper.setProposal([{ target, data }], 'descr #2');",
          "805:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "808:           await expect(this.helper.execute())",
          "809:             .to.emit(this.token, 'Transfer')",
          "810:             .withArgs(this.mock.target, this.voter4.address, amount);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "838:         const method = selector('$_checkOwner()');",
          "840:         beforeEach(async function () {",
          "842:           this.operation = {",
          "846:           };",
          "847:         });",
          "849:         it('succeeds with delay', async function () {",
          "861:           await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "864:           await this.helper.propose();",
          "865:           await this.helper.waitForSnapshot();",
          "867:           await this.helper.waitForDeadline();",
          "868:           await this.helper.queue();",
          "869:           await this.helper.waitForEta();",
          "",
          "[Removed Lines]",
          "841:           this.ownable = await Ownable.new(this.manager.address);",
          "843:             target: this.ownable.address,",
          "844:             value: '0',",
          "845:             data: this.ownable.contract.methods.$_checkOwner().encodeABI(),",
          "850:           const roleId = '1';",
          "851:           const executionDelay = time.duration.hours(2);",
          "852:           const baseDelay = time.duration.hours(1);",
          "855:           await this.manager.setTargetFunctionRole(this.ownable.address, [method], roleId, {",
          "856:             from: admin,",
          "857:           });",
          "858:           await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "863:           this.proposal = await this.helper.setProposal([this.operation], `descr`);",
          "866:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "",
          "[Added Lines]",
          "818:           this.ownable = await ethers.deployContract('$Ownable', [this.manager]);",
          "820:             target: this.ownable.target,",
          "821:             data: this.ownable.interface.encodeFunctionData('$_checkOwner'),",
          "826:           const roleId = 1n;",
          "827:           const executionDelay = time.duration.hours(2n);",
          "828:           const baseDelay = time.duration.hours(1n);",
          "831:           await this.manager.connect(this.admin).setTargetFunctionRole(this.ownable, [method], roleId);",
          "832:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "837:           await this.helper.setProposal([this.operation], `descr`);",
          "840:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "871:         });",
          "873:         it('succeeds without delay', async function () {",
          "885:           await this.mock.$_setBaseDelaySeconds(baseDelay);",
          "888:           await this.helper.propose();",
          "889:           await this.helper.waitForSnapshot();",
          "891:           await this.helper.waitForDeadline();",
          "892:           await this.helper.execute(); // Don't revert",
          "893:         });",
          "",
          "[Removed Lines]",
          "874:           const roleId = '1';",
          "875:           const executionDelay = web3.utils.toBN(0);",
          "876:           const baseDelay = web3.utils.toBN(0);",
          "879:           await this.manager.setTargetFunctionRole(this.ownable.address, [method], roleId, {",
          "880:             from: admin,",
          "881:           });",
          "882:           await this.manager.grantRole(roleId, this.mock.address, executionDelay, { from: admin });",
          "887:           this.proposal = await this.helper.setProposal([this.operation], `descr`);",
          "890:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "",
          "[Added Lines]",
          "848:           const roleId = 1n;",
          "849:           const executionDelay = 0n;",
          "850:           const baseDelay = 0n;",
          "853:           await this.manager.connect(this.admin).setTargetFunctionRole(this.ownable, [method], roleId);",
          "854:           await this.manager.connect(this.admin).grantRole(roleId, this.mock, executionDelay);",
          "859:           await this.helper.setProposal([this.operation], `descr`);",
          "862:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorTimelockCompound.test.js||test/governance/extensions/GovernorTimelockCompound.test.js": [
          "File: test/governance/extensions/GovernorTimelockCompound.test.js -> test/governance/extensions/GovernorTimelockCompound.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: const { expect } = require('chai');",
          "16: const TOKENS = [",
          "19: ];",
          "37:       beforeEach(async function () {",
          "69:         this.proposal = this.helper.setProposal(",
          "70:           [",
          "71:             {",
          "73:               value,",
          "75:             },",
          "76:           ],",
          "77:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { ethers } = require('ethers');",
          "2: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "5: const Enums = require('../../helpers/enums');",
          "6: const { GovernorHelper, proposalStatesToBitMap } = require('../../helpers/governance');",
          "7: const { expectRevertCustomError } = require('../../helpers/customError');",
          "8: const { clockFromReceipt } = require('../../helpers/time');",
          "10: const Timelock = artifacts.require('CompTimelock');",
          "11: const Governor = artifacts.require('$GovernorTimelockCompoundMock');",
          "12: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13: const ERC721 = artifacts.require('$ERC721');",
          "14: const ERC1155 = artifacts.require('$ERC1155');",
          "17:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "18:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "21: contract('GovernorTimelockCompound', function (accounts) {",
          "22:   const [owner, voter1, voter2, voter3, voter4, other] = accounts;",
          "24:   const name = 'OZ-Governor';",
          "25:   const version = '1';",
          "26:   const tokenName = 'MockToken';",
          "27:   const tokenSymbol = 'MTKN';",
          "28:   const tokenSupply = web3.utils.toWei('100');",
          "29:   const votingDelay = web3.utils.toBN(4);",
          "30:   const votingPeriod = web3.utils.toBN(16);",
          "31:   const value = web3.utils.toWei('1');",
          "33:   const defaultDelay = 2 * 86400;",
          "35:   for (const { mode, Token } of TOKENS) {",
          "36:     describe(`using ${Token._json.contractName}`, function () {",
          "38:         const [deployer] = await web3.eth.getAccounts();",
          "40:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "43:         const nonce = await web3.eth.getTransactionCount(deployer);",
          "44:         const predictGovernor = ethers.getCreateAddress({ from: deployer, nonce: nonce + 1 });",
          "46:         this.timelock = await Timelock.new(predictGovernor, defaultDelay);",
          "47:         this.mock = await Governor.new(",
          "48:           name,",
          "49:           votingDelay,",
          "50:           votingPeriod,",
          "51:           0,",
          "52:           this.timelock.address,",
          "53:           this.token.address,",
          "54:           0,",
          "55:         );",
          "56:         this.receiver = await CallReceiver.new();",
          "58:         this.helper = new GovernorHelper(this.mock, mode);",
          "60:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "62:         await this.token.$_mint(owner, tokenSupply);",
          "63:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "64:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "65:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "66:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "72:               target: this.receiver.address,",
          "74:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "4: const { anyValue } = require('@nomicfoundation/hardhat-chai-matchers/withArgs');",
          "6: const { GovernorHelper } = require('../../helpers/governance');",
          "7: const { bigint: Enums } = require('../../helpers/enums');",
          "8: const { bigint: time } = require('../../helpers/time');",
          "11:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "12:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "15: const name = 'OZ-Governor';",
          "16: const version = '1';",
          "17: const tokenName = 'MockToken';",
          "18: const tokenSymbol = 'MTKN';",
          "19: const tokenSupply = ethers.parseEther('100');",
          "20: const votingDelay = 4n;",
          "21: const votingPeriod = 16n;",
          "22: const value = ethers.parseEther('1');",
          "23: const defaultDelay = time.duration.days(2n);",
          "25: describe('GovernorTimelockCompound', function () {",
          "26:   for (const { Token, mode } of TOKENS) {",
          "27:     const fixture = async () => {",
          "28:       const [deployer, owner, voter1, voter2, voter3, voter4, other] = await ethers.getSigners();",
          "29:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "31:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "32:       const predictGovernor = await deployer",
          "33:         .getNonce()",
          "34:         .then(nonce => ethers.getCreateAddress({ from: deployer.address, nonce: nonce + 1 }));",
          "35:       const timelock = await ethers.deployContract('CompTimelock', [predictGovernor, defaultDelay]);",
          "36:       const mock = await ethers.deployContract('$GovernorTimelockCompoundMock', [",
          "37:         name,",
          "38:         votingDelay,",
          "39:         votingPeriod,",
          "40:         0n,",
          "41:         timelock,",
          "42:         token,",
          "43:         0n,",
          "44:       ]);",
          "46:       await owner.sendTransaction({ to: timelock, value });",
          "47:       await token.$_mint(owner, tokenSupply);",
          "49:       const helper = new GovernorHelper(mock, mode);",
          "50:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "51:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "52:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "53:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "55:       return { deployer, owner, voter1, voter2, voter3, voter4, other, receiver, token, mock, timelock, helper };",
          "56:     };",
          "58:     describe(`using ${Token}`, function () {",
          "60:         Object.assign(this, await loadFixture(fixture));",
          "66:               target: this.receiver.target,",
          "68:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:       });",
          "81:       it(\"doesn't accept ether transfers\", async function () {",
          "83:       });",
          "85:       it('post deployment check', async function () {",
          "94:       });",
          "96:       it('nominal', async function () {",
          "100:         await this.helper.propose();",
          "101:         await this.helper.waitForSnapshot();",
          "106:         await this.helper.waitForDeadline();",
          "107:         const txQueue = await this.helper.queue();",
          "113:         await this.helper.waitForEta();",
          "114:         const txExecute = await this.helper.execute();",
          "122:       });",
          "124:       describe('should revert', function () {",
          "",
          "[Removed Lines]",
          "82:         await expectRevert.unspecified(web3.eth.sendTransaction({ from: owner, to: this.mock.address, value: 1 }));",
          "86:         expect(await this.mock.name()).to.be.equal(name);",
          "87:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "88:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "89:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "90:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "92:         expect(await this.mock.timelock()).to.be.equal(this.timelock.address);",
          "93:         expect(await this.timelock.admin()).to.be.equal(this.mock.address);",
          "97:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal('0');",
          "98:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(true);",
          "102:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "103:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "104:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "105:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "109:         const eta = web3.utils.toBN(await clockFromReceipt.timestamp(txQueue.receipt)).addn(defaultDelay);",
          "110:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal(eta);",
          "111:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(true);",
          "116:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "117:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'QueueTransaction', { eta });",
          "119:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "120:         await expectEvent.inTransaction(txExecute.tx, this.timelock, 'ExecuteTransaction', { eta });",
          "121:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "",
          "[Added Lines]",
          "76:         await expect(this.owner.sendTransaction({ to: this.mock, value: 1n })).to.be.revertedWithCustomError(",
          "77:           this.mock,",
          "78:           'GovernorDisabledDeposit',",
          "79:         );",
          "83:         expect(await this.mock.name()).to.equal(name);",
          "84:         expect(await this.mock.token()).to.equal(this.token.target);",
          "85:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "86:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "87:         expect(await this.mock.quorum(0n)).to.equal(0n);",
          "89:         expect(await this.mock.timelock()).to.equal(this.timelock.target);",
          "90:         expect(await this.timelock.admin()).to.equal(this.mock.target);",
          "94:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(0n);",
          "95:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.true;",
          "99:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "100:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "101:         await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against });",
          "102:         await this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain });",
          "106:         const eta = (await time.clockFromReceipt.timestamp(txQueue)) + defaultDelay;",
          "107:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(eta);",
          "108:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.true;",
          "113:         await expect(txQueue)",
          "114:           .to.emit(this.mock, 'ProposalQueued')",
          "115:           .withArgs(this.proposal.id, eta)",
          "116:           .to.emit(this.timelock, 'QueueTransaction')",
          "117:           .withArgs(...Array(5).fill(anyValue), eta);",
          "119:         await expect(txExecute)",
          "120:           .to.emit(this.mock, 'ProposalExecuted')",
          "121:           .withArgs(this.proposal.id)",
          "122:           .to.emit(this.timelock, 'ExecuteTransaction')",
          "123:           .withArgs(...Array(5).fill(anyValue), eta)",
          "124:           .to.emit(this.receiver, 'MockFunctionCalled');",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:           it('if already queued', async function () {",
          "127:             await this.helper.propose();",
          "128:             await this.helper.waitForSnapshot();",
          "130:             await this.helper.waitForDeadline();",
          "131:             await this.helper.queue();",
          "137:           });",
          "139:           it('if proposal contains duplicate calls', async function () {",
          "140:             const action = {",
          "143:             };",
          "144:             const { id } = this.helper.setProposal([action, action], '<proposal description>');",
          "146:             await this.helper.propose();",
          "147:             await this.helper.waitForSnapshot();",
          "149:             await this.helper.waitForDeadline();",
          "152:           });",
          "153:         });",
          "",
          "[Removed Lines]",
          "129:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "132:             await expectRevertCustomError(this.helper.queue(), 'GovernorUnexpectedProposalState', [",
          "133:               this.proposal.id,",
          "134:               Enums.ProposalState.Queued,",
          "135:               proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "136:             ]);",
          "141:               target: this.token.address,",
          "142:               data: this.token.contract.methods.approve(this.receiver.address, constants.MAX_UINT256).encodeABI(),",
          "148:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "150:             await expectRevertCustomError(this.helper.queue(), 'GovernorAlreadyQueuedProposal', [id]);",
          "151:             await expectRevertCustomError(this.helper.execute(), 'GovernorNotQueuedProposal', [id]);",
          "",
          "[Added Lines]",
          "132:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "135:             await expect(this.helper.queue())",
          "136:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "137:               .withArgs(",
          "138:                 this.proposal.id,",
          "139:                 Enums.ProposalState.Queued,",
          "140:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "141:               );",
          "146:               target: this.token.target,",
          "147:               data: this.token.interface.encodeFunctionData('approve', [this.receiver.target, ethers.MaxUint256]),",
          "153:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "155:             await expect(this.helper.queue())",
          "156:               .to.be.revertedWithCustomError(this.mock, 'GovernorAlreadyQueuedProposal')",
          "157:               .withArgs(id);",
          "158:             await expect(this.helper.execute())",
          "159:               .to.be.revertedWithCustomError(this.mock, 'GovernorNotQueuedProposal')",
          "160:               .withArgs(id);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:           it('if not queued', async function () {",
          "157:             await this.helper.propose();",
          "158:             await this.helper.waitForSnapshot();",
          "165:           });",
          "167:           it('if too early', async function () {",
          "168:             await this.helper.propose();",
          "169:             await this.helper.waitForSnapshot();",
          "171:             await this.helper.waitForDeadline();",
          "172:             await this.helper.queue();",
          "178:               \"Timelock::executeTransaction: Transaction hasn't surpassed time lock\",",
          "179:             );",
          "180:           });",
          "",
          "[Removed Lines]",
          "159:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "160:             await this.helper.waitForDeadline(+1);",
          "162:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "164:             await expectRevertCustomError(this.helper.execute(), 'GovernorNotQueuedProposal', [this.proposal.id]);",
          "170:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "174:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "176:             await expectRevert(",
          "177:               this.helper.execute(),",
          "",
          "[Added Lines]",
          "168:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "169:             await this.helper.waitForDeadline(1n);",
          "171:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Succeeded);",
          "173:             await expect(this.helper.execute())",
          "174:               .to.be.revertedWithCustomError(this.mock, 'GovernorNotQueuedProposal')",
          "175:               .withArgs(this.proposal.id);",
          "181:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "185:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Queued);",
          "187:             await expect(this.helper.execute()).to.be.rejectedWith(",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "182:           it('if too late', async function () {",
          "183:             await this.helper.propose();",
          "184:             await this.helper.waitForSnapshot();",
          "186:             await this.helper.waitForDeadline();",
          "187:             await this.helper.queue();",
          "197:           });",
          "199:           it('if already executed', async function () {",
          "200:             await this.helper.propose();",
          "201:             await this.helper.waitForSnapshot();",
          "203:             await this.helper.waitForDeadline();",
          "204:             await this.helper.queue();",
          "205:             await this.helper.waitForEta();",
          "206:             await this.helper.execute();",
          "212:           });",
          "213:         });",
          "215:         describe('on safe receive', function () {",
          "216:           describe('ERC721', function () {",
          "221:             beforeEach(async function () {",
          "224:             });",
          "226:             it(\"can't receive an ERC721 safeTransfer\", async function () {",
          "232:             });",
          "233:           });",
          "235:           describe('ERC1155', function () {",
          "237:             const tokenIds = {",
          "241:             };",
          "243:             beforeEach(async function () {",
          "246:             });",
          "248:             it(\"can't receive ERC1155 safeTransfer\", async function () {",
          "253:                   ...Object.entries(tokenIds)[0], // id + amount",
          "254:                   '0x',",
          "256:                 ),",
          "260:             });",
          "262:             it(\"can't receive ERC1155 safeBatchTransfer\", async function () {",
          "275:             });",
          "276:           });",
          "277:         });",
          "",
          "[Removed Lines]",
          "185:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "188:             await this.helper.waitForEta(+30 * 86400);",
          "190:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Expired);",
          "192:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "193:               this.proposal.id,",
          "194:               Enums.ProposalState.Expired,",
          "195:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "196:             ]);",
          "202:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "207:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "208:               this.proposal.id,",
          "209:               Enums.ProposalState.Executed,",
          "210:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "211:             ]);",
          "217:             const name = 'Non Fungible Token';",
          "218:             const symbol = 'NFT';",
          "219:             const tokenId = web3.utils.toBN(1);",
          "222:               this.token = await ERC721.new(name, symbol);",
          "223:               await this.token.$_mint(owner, tokenId);",
          "227:               await expectRevertCustomError(",
          "228:                 this.token.safeTransferFrom(owner, this.mock.address, tokenId, { from: owner }),",
          "229:                 'GovernorDisabledDeposit',",
          "230:                 [],",
          "231:               );",
          "236:             const uri = 'https://token-cdn-domain/{id}.json';",
          "238:               1: web3.utils.toBN(1000),",
          "239:               2: web3.utils.toBN(2000),",
          "240:               3: web3.utils.toBN(3000),",
          "244:               this.token = await ERC1155.new(uri);",
          "245:               await this.token.$_mintBatch(owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "249:               await expectRevertCustomError(",
          "250:                 this.token.safeTransferFrom(",
          "251:                   owner,",
          "252:                   this.mock.address,",
          "255:                   { from: owner },",
          "257:                 'GovernorDisabledDeposit',",
          "258:                 [],",
          "259:               );",
          "263:               await expectRevertCustomError(",
          "264:                 this.token.safeBatchTransferFrom(",
          "265:                   owner,",
          "266:                   this.mock.address,",
          "267:                   Object.keys(tokenIds),",
          "268:                   Object.values(tokenIds),",
          "269:                   '0x',",
          "270:                   { from: owner },",
          "271:                 ),",
          "272:                 'GovernorDisabledDeposit',",
          "273:                 [],",
          "274:               );",
          "",
          "[Added Lines]",
          "195:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "198:             await this.helper.waitForEta(time.duration.days(30));",
          "200:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Expired);",
          "202:             await expect(this.helper.execute())",
          "203:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "204:               .withArgs(",
          "205:                 this.proposal.id,",
          "206:                 Enums.ProposalState.Expired,",
          "207:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "208:               );",
          "214:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "220:             await expect(this.helper.execute())",
          "221:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "222:               .withArgs(",
          "223:                 this.proposal.id,",
          "224:                 Enums.ProposalState.Executed,",
          "225:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "226:               );",
          "232:             const tokenId = 1n;",
          "235:               this.token = await ethers.deployContract('$ERC721', ['Non Fungible Token', 'NFT']);",
          "236:               await this.token.$_mint(this.owner, tokenId);",
          "240:               await expect(",
          "241:                 this.token.connect(this.owner).safeTransferFrom(this.owner, this.mock, tokenId),",
          "242:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "248:               1: 1000n,",
          "249:               2: 2000n,",
          "250:               3: 3000n,",
          "254:               this.token = await ethers.deployContract('$ERC1155', ['https://token-cdn-domain/{id}.json']);",
          "255:               await this.token.$_mintBatch(this.owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "259:               await expect(",
          "260:                 this.token.connect(this.owner).safeTransferFrom(",
          "261:                   this.owner,",
          "262:                   this.mock,",
          "266:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "270:               await expect(",
          "271:                 this.token",
          "272:                   .connect(this.owner)",
          "273:                   .safeBatchTransferFrom(this.owner, this.mock, Object.keys(tokenIds), Object.values(tokenIds), '0x'),",
          "274:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "281:         it('cancel before queue prevents scheduling', async function () {",
          "282:           await this.helper.propose();",
          "283:           await this.helper.waitForSnapshot();",
          "285:           await this.helper.waitForDeadline();",
          "295:         });",
          "297:         it('cancel after queue prevents executing', async function () {",
          "298:           await this.helper.propose();",
          "299:           await this.helper.waitForSnapshot();",
          "301:           await this.helper.waitForDeadline();",
          "302:           await this.helper.queue();",
          "312:         });",
          "313:       });",
          "315:       describe('onlyGovernance', function () {",
          "316:         describe('relay', function () {",
          "317:           beforeEach(async function () {",
          "319:           });",
          "321:           it('is protected', async function () {",
          "329:           });",
          "331:           it('can be executed through governance', async function () {",
          "332:             this.helper.setProposal(",
          "333:               [",
          "334:                 {",
          "339:                 },",
          "340:               ],",
          "341:               '<proposal description>',",
          "342:             );",
          "347:             await this.helper.propose();",
          "348:             await this.helper.waitForSnapshot();",
          "350:             await this.helper.waitForDeadline();",
          "351:             await this.helper.queue();",
          "352:             await this.helper.waitForEta();",
          "363:           });",
          "364:         });",
          "366:         describe('updateTimelock', function () {",
          "367:           beforeEach(async function () {",
          "369:           });",
          "371:           it('is protected', async function () {",
          "377:           });",
          "379:           it('can be executed through governance to', async function () {",
          "380:             this.helper.setProposal(",
          "381:               [",
          "382:                 {",
          "385:                 },",
          "386:                 {",
          "389:                 },",
          "390:               ],",
          "391:               '<proposal description>',",
          "",
          "[Removed Lines]",
          "284:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "287:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "289:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "290:           await expectRevertCustomError(this.helper.queue(), 'GovernorUnexpectedProposalState', [",
          "291:             this.proposal.id,",
          "292:             Enums.ProposalState.Canceled,",
          "293:             proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "294:           ]);",
          "300:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "304:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "306:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "307:           await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "308:             this.proposal.id,",
          "309:             Enums.ProposalState.Canceled,",
          "310:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "311:           ]);",
          "318:             await this.token.$_mint(this.mock.address, 1);",
          "322:             await expectRevertCustomError(",
          "323:               this.mock.relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI(), {",
          "324:                 from: owner,",
          "325:               }),",
          "326:               'GovernorOnlyExecutor',",
          "327:               [owner],",
          "328:             );",
          "335:                   target: this.mock.address,",
          "336:                   data: this.mock.contract.methods",
          "337:                     .relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI())",
          "338:                     .encodeABI(),",
          "344:             expect(await this.token.balanceOf(this.mock.address), 1);",
          "345:             expect(await this.token.balanceOf(other), 0);",
          "349:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "353:             const txExecute = await this.helper.execute();",
          "355:             expect(await this.token.balanceOf(this.mock.address), 0);",
          "356:             expect(await this.token.balanceOf(other), 1);",
          "358:             await expectEvent.inTransaction(txExecute.tx, this.token, 'Transfer', {",
          "359:               from: this.mock.address,",
          "360:               to: other,",
          "361:               value: '1',",
          "362:             });",
          "368:             this.newTimelock = await Timelock.new(this.mock.address, 7 * 86400);",
          "372:             await expectRevertCustomError(",
          "373:               this.mock.updateTimelock(this.newTimelock.address, { from: owner }),",
          "374:               'GovernorOnlyExecutor',",
          "375:               [owner],",
          "376:             );",
          "383:                   target: this.timelock.address,",
          "384:                   data: this.timelock.contract.methods.setPendingAdmin(owner).encodeABI(),",
          "387:                   target: this.mock.address,",
          "388:                   data: this.mock.contract.methods.updateTimelock(this.newTimelock.address).encodeABI(),",
          "",
          "[Added Lines]",
          "284:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "287:           await expect(this.helper.cancel('internal'))",
          "288:             .to.emit(this.mock, 'ProposalCanceled')",
          "289:             .withArgs(this.proposal.id);",
          "291:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "293:           await expect(this.helper.queue())",
          "294:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "295:             .withArgs(",
          "296:               this.proposal.id,",
          "297:               Enums.ProposalState.Canceled,",
          "298:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "299:             );",
          "305:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "309:           await expect(this.helper.cancel('internal'))",
          "310:             .to.emit(this.mock, 'ProposalCanceled')",
          "311:             .withArgs(this.proposal.id);",
          "313:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "315:           await expect(this.helper.execute())",
          "316:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "317:             .withArgs(",
          "318:               this.proposal.id,",
          "319:               Enums.ProposalState.Canceled,",
          "320:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "321:             );",
          "328:             await this.token.$_mint(this.mock, 1);",
          "332:             await expect(",
          "333:               this.mock",
          "334:                 .connect(this.owner)",
          "335:                 .relay(this.token, 0, this.token.interface.encodeFunctionData('transfer', [this.other.address, 1n])),",
          "336:             )",
          "337:               .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "338:               .withArgs(this.owner.address);",
          "345:                   target: this.mock.target,",
          "346:                   data: this.mock.interface.encodeFunctionData('relay', [",
          "347:                     this.token.target,",
          "348:                     0n,",
          "349:                     this.token.interface.encodeFunctionData('transfer', [this.other.address, 1n]),",
          "350:                   ]),",
          "358:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "363:             const txExecute = this.helper.execute();",
          "365:             await expect(txExecute).to.changeTokenBalances(this.token, [this.mock, this.other], [-1n, 1n]);",
          "367:             await expect(txExecute).to.emit(this.token, 'Transfer').withArgs(this.mock.target, this.other.address, 1n);",
          "373:             this.newTimelock = await ethers.deployContract('CompTimelock', [this.mock, time.duration.days(7n)]);",
          "377:             await expect(this.mock.connect(this.owner).updateTimelock(this.newTimelock))",
          "378:               .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "379:               .withArgs(this.owner.address);",
          "386:                   target: this.timelock.target,",
          "387:                   data: this.timelock.interface.encodeFunctionData('setPendingAdmin', [this.owner.address]),",
          "390:                   target: this.mock.target,",
          "391:                   data: this.mock.interface.encodeFunctionData('updateTimelock', [this.newTimelock.target]),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "394:             await this.helper.propose();",
          "395:             await this.helper.waitForSnapshot();",
          "397:             await this.helper.waitForDeadline();",
          "398:             await this.helper.queue();",
          "399:             await this.helper.waitForEta();",
          "408:           });",
          "409:         });",
          "411:         it('can transfer timelock to new governor', async function () {",
          "413:           this.helper.setProposal(",
          "414:             [",
          "415:               {",
          "418:               },",
          "419:             ],",
          "420:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "396:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "400:             const txExecute = await this.helper.execute();",
          "402:             expectEvent(txExecute, 'TimelockChange', {",
          "403:               oldTimelock: this.timelock.address,",
          "404:               newTimelock: this.newTimelock.address,",
          "405:             });",
          "407:             expect(await this.mock.timelock()).to.be.bignumber.equal(this.newTimelock.address);",
          "412:           const newGovernor = await Governor.new(name, 8, 32, 0, this.timelock.address, this.token.address, 0);",
          "416:                 target: this.timelock.address,",
          "417:                 data: this.timelock.contract.methods.setPendingAdmin(newGovernor.address).encodeABI(),",
          "",
          "[Added Lines]",
          "399:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "404:             await expect(this.helper.execute())",
          "405:               .to.emit(this.mock, 'TimelockChange')",
          "406:               .withArgs(this.timelock.target, this.newTimelock.target);",
          "408:             expect(await this.mock.timelock()).to.equal(this.newTimelock.target);",
          "413:           const newGovernor = await ethers.deployContract('$GovernorTimelockCompoundMock', [",
          "414:             name,",
          "415:             8n,",
          "416:             32n,",
          "417:             0n,",
          "418:             this.timelock,",
          "419:             this.token,",
          "420:             0n,",
          "421:           ]);",
          "426:                 target: this.timelock.target,",
          "427:                 data: this.timelock.interface.encodeFunctionData('setPendingAdmin', [newGovernor.target]),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "423:           await this.helper.propose();",
          "424:           await this.helper.waitForSnapshot();",
          "426:           await this.helper.waitForDeadline();",
          "427:           await this.helper.queue();",
          "428:           await this.helper.waitForEta();",
          "435:           await newGovernor.__acceptAdmin();",
          "437:         });",
          "438:       });",
          "439:     });",
          "",
          "[Removed Lines]",
          "425:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "429:           const txExecute = await this.helper.execute();",
          "431:           await expectEvent.inTransaction(txExecute.tx, this.timelock, 'NewPendingAdmin', {",
          "432:             newPendingAdmin: newGovernor.address,",
          "433:           });",
          "436:           expect(await this.timelock.admin()).to.be.bignumber.equal(newGovernor.address);",
          "",
          "[Added Lines]",
          "435:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "440:           await expect(this.helper.execute()).to.emit(this.timelock, 'NewPendingAdmin').withArgs(newGovernor.target);",
          "443:           expect(await this.timelock.admin()).to.equal(newGovernor.target);",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorTimelockControl.test.js||test/governance/extensions/GovernorTimelockControl.test.js": [
          "File: test/governance/extensions/GovernorTimelockControl.test.js -> test/governance/extensions/GovernorTimelockControl.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "15: const TOKENS = [",
          "18: ];",
          "41:       beforeEach(async function () {",
          "80:         this.proposal = this.helper.setProposal(",
          "81:           [",
          "82:             {",
          "84:               value,",
          "86:             },",
          "87:           ],",
          "88:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "4: const Enums = require('../../helpers/enums');",
          "5: const { GovernorHelper, proposalStatesToBitMap, timelockSalt } = require('../../helpers/governance');",
          "6: const { expectRevertCustomError } = require('../../helpers/customError');",
          "7: const { clockFromReceipt } = require('../../helpers/time');",
          "9: const Timelock = artifacts.require('TimelockController');",
          "10: const Governor = artifacts.require('$GovernorTimelockControlMock');",
          "11: const CallReceiver = artifacts.require('CallReceiverMock');",
          "12: const ERC721 = artifacts.require('$ERC721');",
          "13: const ERC1155 = artifacts.require('$ERC1155');",
          "16:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "17:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "20: contract('GovernorTimelockControl', function (accounts) {",
          "21:   const [owner, voter1, voter2, voter3, voter4, other] = accounts;",
          "23:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "24:   const PROPOSER_ROLE = web3.utils.soliditySha3('PROPOSER_ROLE');",
          "25:   const EXECUTOR_ROLE = web3.utils.soliditySha3('EXECUTOR_ROLE');",
          "26:   const CANCELLER_ROLE = web3.utils.soliditySha3('CANCELLER_ROLE');",
          "28:   const name = 'OZ-Governor';",
          "29:   const version = '1';",
          "30:   const tokenName = 'MockToken';",
          "31:   const tokenSymbol = 'MTKN';",
          "32:   const tokenSupply = web3.utils.toWei('100');",
          "33:   const votingDelay = web3.utils.toBN(4);",
          "34:   const votingPeriod = web3.utils.toBN(16);",
          "35:   const value = web3.utils.toWei('1');",
          "37:   const delay = 3600;",
          "39:   for (const { mode, Token } of TOKENS) {",
          "40:     describe(`using ${Token._json.contractName}`, function () {",
          "42:         const [deployer] = await web3.eth.getAccounts();",
          "44:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "45:         this.timelock = await Timelock.new(delay, [], [], deployer);",
          "46:         this.mock = await Governor.new(",
          "47:           name,",
          "48:           votingDelay,",
          "49:           votingPeriod,",
          "50:           0,",
          "51:           this.timelock.address,",
          "52:           this.token.address,",
          "53:           0,",
          "54:         );",
          "55:         this.receiver = await CallReceiver.new();",
          "57:         this.helper = new GovernorHelper(this.mock, mode);",
          "59:         this.PROPOSER_ROLE = await this.timelock.PROPOSER_ROLE();",
          "60:         this.EXECUTOR_ROLE = await this.timelock.EXECUTOR_ROLE();",
          "61:         this.CANCELLER_ROLE = await this.timelock.CANCELLER_ROLE();",
          "63:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "66:         await this.timelock.grantRole(PROPOSER_ROLE, this.mock.address);",
          "67:         await this.timelock.grantRole(PROPOSER_ROLE, owner);",
          "68:         await this.timelock.grantRole(CANCELLER_ROLE, this.mock.address);",
          "69:         await this.timelock.grantRole(CANCELLER_ROLE, owner);",
          "70:         await this.timelock.grantRole(EXECUTOR_ROLE, constants.ZERO_ADDRESS);",
          "71:         await this.timelock.revokeRole(DEFAULT_ADMIN_ROLE, deployer);",
          "73:         await this.token.$_mint(owner, tokenSupply);",
          "74:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "75:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "76:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "77:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "83:               target: this.receiver.address,",
          "85:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "4: const { anyValue } = require('@nomicfoundation/hardhat-chai-matchers/withArgs');",
          "6: const { GovernorHelper, timelockSalt } = require('../../helpers/governance');",
          "7: const { bigint: Enums } = require('../../helpers/enums');",
          "8: const { bigint: time } = require('../../helpers/time');",
          "11:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "12:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "15: const DEFAULT_ADMIN_ROLE = ethers.ZeroHash;",
          "16: const PROPOSER_ROLE = ethers.id('PROPOSER_ROLE');",
          "17: const EXECUTOR_ROLE = ethers.id('EXECUTOR_ROLE');",
          "18: const CANCELLER_ROLE = ethers.id('CANCELLER_ROLE');",
          "20: const name = 'OZ-Governor';",
          "21: const version = '1';",
          "22: const tokenName = 'MockToken';",
          "23: const tokenSymbol = 'MTKN';",
          "24: const tokenSupply = ethers.parseEther('100');",
          "25: const votingDelay = 4n;",
          "26: const votingPeriod = 16n;",
          "27: const value = ethers.parseEther('1');",
          "28: const delay = time.duration.hours(1n);",
          "30: describe('GovernorTimelockControl', function () {",
          "31:   for (const { Token, mode } of TOKENS) {",
          "32:     const fixture = async () => {",
          "33:       const [deployer, owner, voter1, voter2, voter3, voter4, other] = await ethers.getSigners();",
          "34:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "36:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "37:       const timelock = await ethers.deployContract('TimelockController', [delay, [], [], deployer]);",
          "38:       const mock = await ethers.deployContract('$GovernorTimelockControlMock', [",
          "39:         name,",
          "40:         votingDelay,",
          "41:         votingPeriod,",
          "42:         0n,",
          "43:         timelock,",
          "44:         token,",
          "45:         0n,",
          "46:       ]);",
          "48:       await owner.sendTransaction({ to: timelock, value });",
          "49:       await token.$_mint(owner, tokenSupply);",
          "50:       await timelock.grantRole(PROPOSER_ROLE, mock);",
          "51:       await timelock.grantRole(PROPOSER_ROLE, owner);",
          "52:       await timelock.grantRole(CANCELLER_ROLE, mock);",
          "53:       await timelock.grantRole(CANCELLER_ROLE, owner);",
          "54:       await timelock.grantRole(EXECUTOR_ROLE, ethers.ZeroAddress);",
          "55:       await timelock.revokeRole(DEFAULT_ADMIN_ROLE, deployer);",
          "57:       const helper = new GovernorHelper(mock, mode);",
          "58:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "59:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "60:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "61:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "63:       return { deployer, owner, voter1, voter2, voter3, voter4, other, receiver, token, mock, timelock, helper };",
          "64:     };",
          "66:     describe(`using ${Token}`, function () {",
          "68:         Object.assign(this, await loadFixture(fixture));",
          "74:               target: this.receiver.target,",
          "76:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:         this.proposal.timelockid = await this.timelock.hashOperationBatch(",
          "92:           ...this.proposal.shortProposal.slice(0, 3),",
          "95:         );",
          "96:       });",
          "98:       it(\"doesn't accept ether transfers\", async function () {",
          "100:       });",
          "102:       it('post deployment check', async function () {",
          "110:       });",
          "112:       it('nominal', async function () {",
          "116:         await this.helper.propose();",
          "117:         await this.helper.waitForSnapshot();",
          "122:         await this.helper.waitForDeadline();",
          "141:       });",
          "143:       describe('should revert', function () {",
          "",
          "[Removed Lines]",
          "93:           '0x0',",
          "94:           timelockSalt(this.mock.address, this.proposal.shortProposal[3]),",
          "99:         await expectRevert.unspecified(web3.eth.sendTransaction({ from: owner, to: this.mock.address, value: 1 }));",
          "103:         expect(await this.mock.name()).to.be.equal(name);",
          "104:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "105:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "106:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "107:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "109:         expect(await this.mock.timelock()).to.be.equal(this.timelock.address);",
          "113:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal('0');",
          "114:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(true);",
          "118:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "119:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "120:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "121:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "123:         const txQueue = await this.helper.queue();",
          "124:         await this.helper.waitForEta();",
          "126:         const eta = web3.utils.toBN(await clockFromReceipt.timestamp(txQueue.receipt)).addn(delay);",
          "127:         expect(await this.mock.proposalEta(this.proposal.id)).to.be.bignumber.equal(eta);",
          "128:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.equal(true);",
          "130:         const txExecute = await this.helper.execute();",
          "132:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "133:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallScheduled', { id: this.proposal.timelockid });",
          "134:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallSalt', {",
          "135:           id: this.proposal.timelockid,",
          "136:         });",
          "138:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "139:         await expectEvent.inTransaction(txExecute.tx, this.timelock, 'CallExecuted', { id: this.proposal.timelockid });",
          "140:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "",
          "[Added Lines]",
          "84:           ethers.ZeroHash,",
          "85:           timelockSalt(this.mock.target, this.proposal.shortProposal[3]),",
          "90:         await expect(this.owner.sendTransaction({ to: this.mock, value: 1n })).to.be.revertedWithCustomError(",
          "91:           this.mock,",
          "92:           'GovernorDisabledDeposit',",
          "93:         );",
          "97:         expect(await this.mock.name()).to.equal(name);",
          "98:         expect(await this.mock.token()).to.equal(this.token.target);",
          "99:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "100:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "101:         expect(await this.mock.quorum(0n)).to.equal(0n);",
          "103:         expect(await this.mock.timelock()).to.equal(this.timelock.target);",
          "107:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(0n);",
          "108:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.true;",
          "112:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "113:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "114:         await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against });",
          "115:         await this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain });",
          "118:         expect(await this.mock.proposalNeedsQueuing(this.proposal.id)).to.be.true;",
          "119:         const txQueue = await this.helper.queue();",
          "121:         const eta = (await time.clockFromReceipt.timestamp(txQueue)) + delay;",
          "122:         expect(await this.mock.proposalEta(this.proposal.id)).to.equal(eta);",
          "123:         await this.helper.waitForEta();",
          "125:         const txExecute = this.helper.execute();",
          "127:         await expect(txQueue)",
          "128:           .to.emit(this.mock, 'ProposalQueued')",
          "129:           .withArgs(this.proposal.id, anyValue)",
          "130:           .to.emit(this.timelock, 'CallScheduled')",
          "131:           .withArgs(this.proposal.timelockid, ...Array(6).fill(anyValue))",
          "132:           .to.emit(this.timelock, 'CallSalt')",
          "133:           .withArgs(this.proposal.timelockid, anyValue);",
          "135:         await expect(txExecute)",
          "136:           .to.emit(this.mock, 'ProposalExecuted')",
          "137:           .withArgs(this.proposal.id)",
          "138:           .to.emit(this.timelock, 'CallExecuted')",
          "139:           .withArgs(this.proposal.timelockid, ...Array(4).fill(anyValue))",
          "140:           .to.emit(this.receiver, 'MockFunctionCalled');",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "145:           it('if already queued', async function () {",
          "146:             await this.helper.propose();",
          "147:             await this.helper.waitForSnapshot();",
          "149:             await this.helper.waitForDeadline();",
          "150:             await this.helper.queue();",
          "156:           });",
          "157:         });",
          "",
          "[Removed Lines]",
          "148:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "151:             await expectRevertCustomError(this.helper.queue(), 'GovernorUnexpectedProposalState', [",
          "152:               this.proposal.id,",
          "153:               Enums.ProposalState.Queued,",
          "154:               proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "155:             ]);",
          "",
          "[Added Lines]",
          "148:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "151:             await expect(this.helper.queue())",
          "152:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "153:               .withArgs(",
          "154:                 this.proposal.id,",
          "155:                 Enums.ProposalState.Queued,",
          "156:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "157:               );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "160:           it('if not queued', async function () {",
          "161:             await this.helper.propose();",
          "162:             await this.helper.waitForSnapshot();",
          "172:           });",
          "174:           it('if too early', async function () {",
          "175:             await this.helper.propose();",
          "176:             await this.helper.waitForSnapshot();",
          "178:             await this.helper.waitForDeadline();",
          "179:             await this.helper.queue();",
          "187:           });",
          "189:           it('if already executed', async function () {",
          "190:             await this.helper.propose();",
          "191:             await this.helper.waitForSnapshot();",
          "193:             await this.helper.waitForDeadline();",
          "194:             await this.helper.queue();",
          "195:             await this.helper.waitForEta();",
          "196:             await this.helper.execute();",
          "202:           });",
          "204:           it('if already executed by another proposer', async function () {",
          "205:             await this.helper.propose();",
          "206:             await this.helper.waitForSnapshot();",
          "208:             await this.helper.waitForDeadline();",
          "209:             await this.helper.queue();",
          "210:             await this.helper.waitForEta();",
          "212:             await this.timelock.executeBatch(",
          "213:               ...this.proposal.shortProposal.slice(0, 3),",
          "216:             );",
          "223:           });",
          "224:         });",
          "225:       });",
          "",
          "[Removed Lines]",
          "163:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "164:             await this.helper.waitForDeadline(+1);",
          "166:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "168:             await expectRevertCustomError(this.helper.execute(), 'TimelockUnexpectedOperationState', [",
          "169:               this.proposal.timelockid,",
          "170:               proposalStatesToBitMap(Enums.OperationState.Ready),",
          "171:             ]);",
          "177:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "181:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "183:             await expectRevertCustomError(this.helper.execute(), 'TimelockUnexpectedOperationState', [",
          "184:               this.proposal.timelockid,",
          "185:               proposalStatesToBitMap(Enums.OperationState.Ready),",
          "186:             ]);",
          "192:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "197:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "198:               this.proposal.id,",
          "199:               Enums.ProposalState.Executed,",
          "200:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "201:             ]);",
          "207:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "214:               '0x0',",
          "215:               timelockSalt(this.mock.address, this.proposal.shortProposal[3]),",
          "218:             await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "219:               this.proposal.id,",
          "220:               Enums.ProposalState.Executed,",
          "221:               proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "222:             ]);",
          "",
          "[Added Lines]",
          "165:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "166:             await this.helper.waitForDeadline(1n);",
          "168:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Succeeded);",
          "170:             await expect(this.helper.execute())",
          "171:               .to.be.revertedWithCustomError(this.timelock, 'TimelockUnexpectedOperationState')",
          "172:               .withArgs(this.proposal.timelockid, GovernorHelper.proposalStatesToBitMap(Enums.OperationState.Ready));",
          "178:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "182:             expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Queued);",
          "184:             await expect(this.helper.execute())",
          "185:               .to.be.revertedWithCustomError(this.timelock, 'TimelockUnexpectedOperationState')",
          "186:               .withArgs(this.proposal.timelockid, GovernorHelper.proposalStatesToBitMap(Enums.OperationState.Ready));",
          "192:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "198:             await expect(this.helper.execute())",
          "199:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "200:               .withArgs(",
          "201:                 this.proposal.id,",
          "202:                 Enums.ProposalState.Executed,",
          "203:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "204:               );",
          "210:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "217:               ethers.ZeroHash,",
          "218:               timelockSalt(this.mock.target, this.proposal.shortProposal[3]),",
          "221:             await expect(this.helper.execute())",
          "222:               .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "223:               .withArgs(",
          "224:                 this.proposal.id,",
          "225:                 Enums.ProposalState.Executed,",
          "226:                 GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "227:               );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "228:         it('cancel before queue prevents scheduling', async function () {",
          "229:           await this.helper.propose();",
          "230:           await this.helper.waitForSnapshot();",
          "232:           await this.helper.waitForDeadline();",
          "242:         });",
          "244:         it('cancel after queue prevents executing', async function () {",
          "245:           await this.helper.propose();",
          "246:           await this.helper.waitForSnapshot();",
          "248:           await this.helper.waitForDeadline();",
          "249:           await this.helper.queue();",
          "259:         });",
          "261:         it('cancel on timelock is reflected on governor', async function () {",
          "262:           await this.helper.propose();",
          "263:           await this.helper.waitForSnapshot();",
          "265:           await this.helper.waitForDeadline();",
          "266:           await this.helper.queue();",
          "275:         });",
          "276:       });",
          "278:       describe('onlyGovernance', function () {",
          "279:         describe('relay', function () {",
          "280:           beforeEach(async function () {",
          "282:           });",
          "284:           it('is protected', async function () {",
          "292:           });",
          "294:           it('can be executed through governance', async function () {",
          "295:             this.helper.setProposal(",
          "296:               [",
          "297:                 {",
          "302:                 },",
          "303:               ],",
          "304:               '<proposal description>',",
          "305:             );",
          "310:             await this.helper.propose();",
          "311:             await this.helper.waitForSnapshot();",
          "313:             await this.helper.waitForDeadline();",
          "314:             await this.helper.queue();",
          "315:             await this.helper.waitForEta();",
          "316:             const txExecute = await this.helper.execute();",
          "326:           });",
          "328:           it('is payable and can transfer eth to EOA', async function () {",
          "332:             this.helper.setProposal(",
          "333:               [",
          "334:                 {",
          "336:                   value: t2g,",
          "338:                 },",
          "339:               ],",
          "340:               '<proposal description>',",
          "341:             );",
          "347:             await this.helper.propose();",
          "348:             await this.helper.waitForSnapshot();",
          "350:             await this.helper.waitForDeadline();",
          "351:             await this.helper.queue();",
          "352:             await this.helper.waitForEta();",
          "358:           });",
          "360:           it('protected against other proposers', async function () {",
          "375:             );",
          "376:           });",
          "377:         });",
          "379:         describe('updateTimelock', function () {",
          "380:           beforeEach(async function () {",
          "382:               delay,",
          "387:           });",
          "389:           it('is protected', async function () {",
          "395:           });",
          "397:           it('can be executed through governance to', async function () {",
          "398:             this.helper.setProposal(",
          "399:               [",
          "400:                 {",
          "403:                 },",
          "404:               ],",
          "405:               '<proposal description>',",
          "",
          "[Removed Lines]",
          "231:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "234:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "236:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "237:           await expectRevertCustomError(this.helper.queue(), 'GovernorUnexpectedProposalState', [",
          "238:             this.proposal.id,",
          "239:             Enums.ProposalState.Canceled,",
          "240:             proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "241:           ]);",
          "247:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "251:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "253:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "254:           await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "255:             this.proposal.id,",
          "256:             Enums.ProposalState.Canceled,",
          "257:             proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "258:           ]);",
          "264:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "268:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "270:           expectEvent(await this.timelock.cancel(this.proposal.timelockid, { from: owner }), 'Cancelled', {",
          "271:             id: this.proposal.timelockid,",
          "272:           });",
          "274:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "281:             await this.token.$_mint(this.mock.address, 1);",
          "285:             await expectRevertCustomError(",
          "286:               this.mock.relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI(), {",
          "287:                 from: owner,",
          "288:               }),",
          "289:               'GovernorOnlyExecutor',",
          "290:               [owner],",
          "291:             );",
          "298:                   target: this.mock.address,",
          "299:                   data: this.mock.contract.methods",
          "300:                     .relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI())",
          "301:                     .encodeABI(),",
          "307:             expect(await this.token.balanceOf(this.mock.address), 1);",
          "308:             expect(await this.token.balanceOf(other), 0);",
          "312:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "318:             expect(await this.token.balanceOf(this.mock.address), 0);",
          "319:             expect(await this.token.balanceOf(other), 1);",
          "321:             await expectEvent.inTransaction(txExecute.tx, this.token, 'Transfer', {",
          "322:               from: this.mock.address,",
          "323:               to: other,",
          "324:               value: '1',",
          "325:             });",
          "329:             const t2g = web3.utils.toBN(128); // timelock to governor",
          "330:             const g2o = web3.utils.toBN(100); // governor to eoa (other)",
          "335:                   target: this.mock.address,",
          "337:                   data: this.mock.contract.methods.relay(other, g2o, '0x').encodeABI(),",
          "343:             expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "344:             const timelockBalance = await web3.eth.getBalance(this.timelock.address).then(web3.utils.toBN);",
          "345:             const otherBalance = await web3.eth.getBalance(other).then(web3.utils.toBN);",
          "349:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "353:             await this.helper.execute();",
          "355:             expect(await web3.eth.getBalance(this.timelock.address)).to.be.bignumber.equal(timelockBalance.sub(t2g));",
          "356:             expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(t2g.sub(g2o));",
          "357:             expect(await web3.eth.getBalance(other)).to.be.bignumber.equal(otherBalance.add(g2o));",
          "361:             const target = this.mock.address;",
          "362:             const value = web3.utils.toWei('0');",
          "363:             const data = this.mock.contract.methods.relay(constants.ZERO_ADDRESS, 0, '0x').encodeABI();",
          "364:             const predecessor = constants.ZERO_BYTES32;",
          "365:             const salt = constants.ZERO_BYTES32;",
          "367:             await this.timelock.schedule(target, value, data, predecessor, salt, delay, { from: owner });",
          "369:             await time.increase(delay);",
          "371:             await expectRevertCustomError(",
          "372:               this.timelock.execute(target, value, data, predecessor, salt, { from: owner }),",
          "373:               'QueueEmpty', // Bubbled up from Governor",
          "374:               [],",
          "381:             this.newTimelock = await Timelock.new(",
          "383:               [this.mock.address],",
          "384:               [this.mock.address],",
          "385:               constants.ZERO_ADDRESS,",
          "386:             );",
          "390:             await expectRevertCustomError(",
          "391:               this.mock.updateTimelock(this.newTimelock.address, { from: owner }),",
          "392:               'GovernorOnlyExecutor',",
          "393:               [owner],",
          "394:             );",
          "401:                   target: this.mock.address,",
          "402:                   data: this.mock.contract.methods.updateTimelock(this.newTimelock.address).encodeABI(),",
          "",
          "[Added Lines]",
          "236:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "239:           await expect(this.helper.cancel('internal'))",
          "240:             .to.emit(this.mock, 'ProposalCanceled')",
          "241:             .withArgs(this.proposal.id);",
          "243:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "245:           await expect(this.helper.queue())",
          "246:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "247:             .withArgs(",
          "248:               this.proposal.id,",
          "249:               Enums.ProposalState.Canceled,",
          "250:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded]),",
          "251:             );",
          "257:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "261:           await expect(this.helper.cancel('internal'))",
          "262:             .to.emit(this.mock, 'ProposalCanceled')",
          "263:             .withArgs(this.proposal.id);",
          "265:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "267:           await expect(this.helper.execute())",
          "268:             .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "269:             .withArgs(",
          "270:               this.proposal.id,",
          "271:               Enums.ProposalState.Canceled,",
          "272:               GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "273:             );",
          "279:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "283:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Queued);",
          "285:           await expect(this.timelock.connect(this.owner).cancel(this.proposal.timelockid))",
          "286:             .to.emit(this.timelock, 'Cancelled')",
          "287:             .withArgs(this.proposal.timelockid);",
          "289:           expect(await this.mock.state(this.proposal.id)).to.equal(Enums.ProposalState.Canceled);",
          "296:             await this.token.$_mint(this.mock, 1);",
          "300:             await expect(",
          "301:               this.mock",
          "302:                 .connect(this.owner)",
          "303:                 .relay(this.token, 0n, this.token.interface.encodeFunctionData('transfer', [this.other.address, 1n])),",
          "304:             )",
          "305:               .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "306:               .withArgs(this.owner.address);",
          "313:                   target: this.mock.target,",
          "314:                   data: this.mock.interface.encodeFunctionData('relay', [",
          "315:                     this.token.target,",
          "316:                     0n,",
          "317:                     this.token.interface.encodeFunctionData('transfer', [this.other.address, 1n]),",
          "318:                   ]),",
          "326:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "333:             await expect(txExecute).to.changeTokenBalances(this.token, [this.mock, this.other], [-1n, 1n]);",
          "335:             await expect(txExecute).to.emit(this.token, 'Transfer').withArgs(this.mock.target, this.other.address, 1n);",
          "339:             const t2g = 128n; // timelock to governor",
          "340:             const g2o = 100n; // governor to eoa (other)",
          "345:                   target: this.mock.target,",
          "347:                   data: this.mock.interface.encodeFunctionData('relay', [this.other.address, g2o, '0x']),",
          "355:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "360:             await expect(this.helper.execute()).to.changeEtherBalances(",
          "361:               [this.timelock, this.mock, this.other],",
          "362:               [-t2g, t2g - g2o, g2o],",
          "363:             );",
          "367:             const call = [",
          "368:               this.mock,",
          "369:               0n,",
          "370:               this.mock.interface.encodeFunctionData('relay', [ethers.ZeroAddress, 0n, '0x']),",
          "371:               ethers.ZeroHash,",
          "372:               ethers.ZeroHash,",
          "373:             ];",
          "375:             await this.timelock.connect(this.owner).schedule(...call, delay);",
          "377:             await time.clock.timestamp().then(clock => time.forward.timestamp(clock + delay));",
          "380:             await expect(this.timelock.connect(this.owner).execute(...call)).to.be.revertedWithCustomError(",
          "381:               this.mock,",
          "382:               'QueueEmpty',",
          "389:             this.newTimelock = await ethers.deployContract('TimelockController', [",
          "391:               [this.mock],",
          "392:               [this.mock],",
          "393:               ethers.ZeroAddress,",
          "394:             ]);",
          "398:             await expect(this.mock.connect(this.owner).updateTimelock(this.newTimelock))",
          "399:               .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "400:               .withArgs(this.owner.address);",
          "407:                   target: this.mock.target,",
          "408:                   data: this.mock.interface.encodeFunctionData('updateTimelock', [this.newTimelock.target]),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "408:             await this.helper.propose();",
          "409:             await this.helper.waitForSnapshot();",
          "411:             await this.helper.waitForDeadline();",
          "412:             await this.helper.queue();",
          "413:             await this.helper.waitForEta();",
          "422:           });",
          "423:         });",
          "425:         describe('on safe receive', function () {",
          "426:           describe('ERC721', function () {",
          "431:             beforeEach(async function () {",
          "434:             });",
          "436:             it(\"can't receive an ERC721 safeTransfer\", async function () {",
          "442:             });",
          "443:           });",
          "445:           describe('ERC1155', function () {",
          "447:             const tokenIds = {",
          "451:             };",
          "453:             beforeEach(async function () {",
          "456:             });",
          "458:             it(\"can't receive ERC1155 safeTransfer\", async function () {",
          "463:                   ...Object.entries(tokenIds)[0], // id + amount",
          "464:                   '0x',",
          "466:                 ),",
          "470:             });",
          "472:             it(\"can't receive ERC1155 safeBatchTransfer\", async function () {",
          "485:             });",
          "486:           });",
          "487:         });",
          "",
          "[Removed Lines]",
          "410:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "414:             const txExecute = await this.helper.execute();",
          "416:             expectEvent(txExecute, 'TimelockChange', {",
          "417:               oldTimelock: this.timelock.address,",
          "418:               newTimelock: this.newTimelock.address,",
          "419:             });",
          "421:             expect(await this.mock.timelock()).to.be.bignumber.equal(this.newTimelock.address);",
          "427:             const name = 'Non Fungible Token';",
          "428:             const symbol = 'NFT';",
          "429:             const tokenId = web3.utils.toBN(1);",
          "432:               this.token = await ERC721.new(name, symbol);",
          "433:               await this.token.$_mint(owner, tokenId);",
          "437:               await expectRevertCustomError(",
          "438:                 this.token.safeTransferFrom(owner, this.mock.address, tokenId, { from: owner }),",
          "439:                 'GovernorDisabledDeposit',",
          "440:                 [],",
          "441:               );",
          "446:             const uri = 'https://token-cdn-domain/{id}.json';",
          "448:               1: web3.utils.toBN(1000),",
          "449:               2: web3.utils.toBN(2000),",
          "450:               3: web3.utils.toBN(3000),",
          "454:               this.token = await ERC1155.new(uri);",
          "455:               await this.token.$_mintBatch(owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "459:               await expectRevertCustomError(",
          "460:                 this.token.safeTransferFrom(",
          "461:                   owner,",
          "462:                   this.mock.address,",
          "465:                   { from: owner },",
          "467:                 'GovernorDisabledDeposit',",
          "468:                 [],",
          "469:               );",
          "473:               await expectRevertCustomError(",
          "474:                 this.token.safeBatchTransferFrom(",
          "475:                   owner,",
          "476:                   this.mock.address,",
          "477:                   Object.keys(tokenIds),",
          "478:                   Object.values(tokenIds),",
          "479:                   '0x',",
          "480:                   { from: owner },",
          "481:                 ),",
          "482:                 'GovernorDisabledDeposit',",
          "483:                 [],",
          "484:               );",
          "",
          "[Added Lines]",
          "416:             await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "421:             await expect(this.helper.execute())",
          "422:               .to.emit(this.mock, 'TimelockChange')",
          "423:               .withArgs(this.timelock.target, this.newTimelock.target);",
          "425:             expect(await this.mock.timelock()).to.equal(this.newTimelock.target);",
          "431:             const tokenId = 1n;",
          "434:               this.token = await ethers.deployContract('$ERC721', ['Non Fungible Token', 'NFT']);",
          "435:               await this.token.$_mint(this.owner, tokenId);",
          "439:               await expect(",
          "440:                 this.token.connect(this.owner).safeTransferFrom(this.owner, this.mock, tokenId),",
          "441:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "447:               1: 1000n,",
          "448:               2: 2000n,",
          "449:               3: 3000n,",
          "453:               this.token = await ethers.deployContract('$ERC1155', ['https://token-cdn-domain/{id}.json']);",
          "454:               await this.token.$_mintBatch(this.owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "458:               await expect(",
          "459:                 this.token.connect(this.owner).safeTransferFrom(",
          "460:                   this.owner,",
          "461:                   this.mock,",
          "465:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "469:               await expect(",
          "470:                 this.token",
          "471:                   .connect(this.owner)",
          "472:                   .safeBatchTransferFrom(this.owner, this.mock, Object.keys(tokenIds), Object.values(tokenIds), '0x'),",
          "473:               ).to.be.revertedWithCustomError(this.mock, 'GovernorDisabledDeposit');",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "491:         this.helper.setProposal(",
          "492:           [",
          "493:             {",
          "496:             },",
          "497:           ],",
          "498:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "494:               target: this.mock.address,",
          "495:               data: this.mock.contract.methods.nonGovernanceFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "483:               target: this.mock.target,",
          "484:               data: this.mock.interface.encodeFunctionData('nonGovernanceFunction'),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "501:         await this.helper.propose();",
          "502:         await this.helper.waitForSnapshot();",
          "504:         await this.helper.waitForDeadline();",
          "505:         await this.helper.queue();",
          "506:         await this.helper.waitForEta();",
          "",
          "[Removed Lines]",
          "503:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "",
          "[Added Lines]",
          "492:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorVotesQuorumFraction.test.js||test/governance/extensions/GovernorVotesQuorumFraction.test.js": [
          "File: test/governance/extensions/GovernorVotesQuorumFraction.test.js -> test/governance/extensions/GovernorVotesQuorumFraction.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "12: const TOKENS = [",
          "15: ];",
          "50:         this.proposal = this.helper.setProposal(",
          "51:           [",
          "52:             {",
          "54:               value,",
          "56:             },",
          "57:           ],",
          "58:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { expectEvent, time } = require('@openzeppelin/test-helpers');",
          "4: const Enums = require('../../helpers/enums');",
          "5: const { GovernorHelper, proposalStatesToBitMap } = require('../../helpers/governance');",
          "6: const { clock } = require('../../helpers/time');",
          "7: const { expectRevertCustomError } = require('../../helpers/customError');",
          "9: const Governor = artifacts.require('$GovernorMock');",
          "10: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "14:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "17: contract('GovernorVotesQuorumFraction', function (accounts) {",
          "18:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "20:   const name = 'OZ-Governor';",
          "21:   const version = '1';",
          "22:   const tokenName = 'MockToken';",
          "23:   const tokenSymbol = 'MTKN';",
          "24:   const tokenSupply = web3.utils.toBN(web3.utils.toWei('100'));",
          "25:   const ratio = web3.utils.toBN(8); // percents",
          "26:   const newRatio = web3.utils.toBN(6); // percents",
          "27:   const votingDelay = web3.utils.toBN(4);",
          "28:   const votingPeriod = web3.utils.toBN(16);",
          "29:   const value = web3.utils.toWei('1');",
          "31:   for (const { mode, Token } of TOKENS) {",
          "32:     describe(`using ${Token._json.contractName}`, function () {",
          "33:       beforeEach(async function () {",
          "34:         this.owner = owner;",
          "35:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "36:         this.mock = await Governor.new(name, votingDelay, votingPeriod, 0, this.token.address, ratio);",
          "37:         this.receiver = await CallReceiver.new();",
          "39:         this.helper = new GovernorHelper(this.mock, mode);",
          "41:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "43:         await this.token.$_mint(owner, tokenSupply);",
          "44:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "45:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "46:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "47:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "53:               target: this.receiver.address,",
          "55:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture, mine } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { GovernorHelper } = require('../../helpers/governance');",
          "6: const { bigint: Enums } = require('../../helpers/enums');",
          "7: const { bigint: time } = require('../../helpers/time');",
          "10:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "11:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "14: const name = 'OZ-Governor';",
          "15: const version = '1';",
          "16: const tokenName = 'MockToken';",
          "17: const tokenSymbol = 'MTKN';",
          "18: const tokenSupply = ethers.parseEther('100');",
          "19: const ratio = 8n; // percents",
          "20: const newRatio = 6n; // percents",
          "21: const votingDelay = 4n;",
          "22: const votingPeriod = 16n;",
          "23: const value = ethers.parseEther('1');",
          "25: describe('GovernorVotesQuorumFraction', function () {",
          "26:   for (const { Token, mode } of TOKENS) {",
          "27:     const fixture = async () => {",
          "28:       const [owner, voter1, voter2, voter3, voter4] = await ethers.getSigners();",
          "30:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "32:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "33:       const mock = await ethers.deployContract('$GovernorMock', [name, votingDelay, votingPeriod, 0n, token, ratio]);",
          "35:       await owner.sendTransaction({ to: mock, value });",
          "36:       await token.$_mint(owner, tokenSupply);",
          "38:       const helper = new GovernorHelper(mock, mode);",
          "39:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "40:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "41:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "42:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "44:       return { owner, voter1, voter2, voter3, voter4, receiver, token, mock, helper };",
          "45:     };",
          "47:     describe(`using ${Token}`, function () {",
          "48:       beforeEach(async function () {",
          "49:         Object.assign(this, await loadFixture(fixture));",
          "55:               target: this.receiver.target,",
          "57:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:       });",
          "62:       it('deployment check', async function () {",
          "72:         );",
          "73:       });",
          "75:       it('quroum reached', async function () {",
          "76:         await this.helper.propose();",
          "77:         await this.helper.waitForSnapshot();",
          "79:         await this.helper.waitForDeadline();",
          "80:         await this.helper.execute();",
          "81:       });",
          "",
          "[Removed Lines]",
          "63:         expect(await this.mock.name()).to.be.equal(name);",
          "64:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "65:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "66:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "67:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "68:         expect(await this.mock.quorumNumerator()).to.be.bignumber.equal(ratio);",
          "69:         expect(await this.mock.quorumDenominator()).to.be.bignumber.equal('100');",
          "70:         expect(await clock[mode]().then(timepoint => this.mock.quorum(timepoint - 1))).to.be.bignumber.equal(",
          "71:           tokenSupply.mul(ratio).divn(100),",
          "78:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "",
          "[Added Lines]",
          "65:         expect(await this.mock.name()).to.equal(name);",
          "66:         expect(await this.mock.token()).to.equal(this.token.target);",
          "67:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "68:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "69:         expect(await this.mock.quorum(0)).to.equal(0n);",
          "70:         expect(await this.mock.quorumNumerator()).to.equal(ratio);",
          "71:         expect(await this.mock.quorumDenominator()).to.equal(100n);",
          "72:         expect(await time.clock[mode]().then(clock => this.mock.quorum(clock - 1n))).to.equal(",
          "73:           (tokenSupply * ratio) / 100n,",
          "80:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:       it('quroum not reached', async function () {",
          "84:         await this.helper.propose();",
          "85:         await this.helper.waitForSnapshot();",
          "87:         await this.helper.waitForDeadline();",
          "93:       });",
          "95:       describe('onlyGovernance updates', function () {",
          "96:         it('updateQuorumNumerator is protected', async function () {",
          "102:         });",
          "104:         it('can updateQuorumNumerator through governance', async function () {",
          "105:           this.helper.setProposal(",
          "106:             [",
          "107:               {",
          "110:               },",
          "111:             ],",
          "112:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "86:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "88:         await expectRevertCustomError(this.helper.execute(), 'GovernorUnexpectedProposalState', [",
          "89:           this.proposal.id,",
          "90:           Enums.ProposalState.Defeated,",
          "91:           proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "92:         ]);",
          "97:           await expectRevertCustomError(",
          "98:             this.mock.updateQuorumNumerator(newRatio, { from: owner }),",
          "99:             'GovernorOnlyExecutor',",
          "100:             [owner],",
          "101:           );",
          "108:                 target: this.mock.address,",
          "109:                 data: this.mock.contract.methods.updateQuorumNumerator(newRatio).encodeABI(),",
          "",
          "[Added Lines]",
          "88:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "90:         await expect(this.helper.execute())",
          "91:           .to.be.revertedWithCustomError(this.mock, 'GovernorUnexpectedProposalState')",
          "92:           .withArgs(",
          "93:             this.proposal.id,",
          "94:             Enums.ProposalState.Defeated,",
          "95:             GovernorHelper.proposalStatesToBitMap([Enums.ProposalState.Succeeded, Enums.ProposalState.Queued]),",
          "96:           );",
          "101:           await expect(this.mock.connect(this.owner).updateQuorumNumerator(newRatio))",
          "102:             .to.be.revertedWithCustomError(this.mock, 'GovernorOnlyExecutor')",
          "103:             .withArgs(this.owner.address);",
          "110:                 target: this.mock.target,",
          "111:                 data: this.mock.interface.encodeFunctionData('updateQuorumNumerator', [newRatio]),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115:           await this.helper.propose();",
          "116:           await this.helper.waitForSnapshot();",
          "118:           await this.helper.waitForDeadline();",
          "131:           );",
          "137:           );",
          "138:         });",
          "140:         it('cannot updateQuorumNumerator over the maximum', async function () {",
          "142:           this.helper.setProposal(",
          "143:             [",
          "144:               {",
          "147:               },",
          "148:             ],",
          "149:             '<proposal description>',",
          "",
          "[Removed Lines]",
          "117:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "120:           expectEvent(await this.helper.execute(), 'QuorumNumeratorUpdated', {",
          "121:             oldQuorumNumerator: ratio,",
          "122:             newQuorumNumerator: newRatio,",
          "123:           });",
          "125:           expect(await this.mock.quorumNumerator()).to.be.bignumber.equal(newRatio);",
          "126:           expect(await this.mock.quorumDenominator()).to.be.bignumber.equal('100');",
          "129:           expect(await clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1))).to.be.bignumber.equal(",
          "130:             tokenSupply.mul(ratio).divn(100),",
          "133:           await time.advanceBlock();",
          "135:           expect(await clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1))).to.be.bignumber.equal(",
          "136:             tokenSupply.mul(newRatio).divn(100),",
          "141:           const quorumNumerator = 101;",
          "145:                 target: this.mock.address,",
          "146:                 data: this.mock.contract.methods.updateQuorumNumerator(quorumNumerator).encodeABI(),",
          "",
          "[Added Lines]",
          "119:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "122:           await expect(this.helper.execute()).to.emit(this.mock, 'QuorumNumeratorUpdated').withArgs(ratio, newRatio);",
          "124:           expect(await this.mock.quorumNumerator()).to.equal(newRatio);",
          "125:           expect(await this.mock.quorumDenominator()).to.equal(100n);",
          "128:           expect(await time.clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1n))).to.equal(",
          "129:             (tokenSupply * ratio) / 100n,",
          "132:           await mine();",
          "134:           expect(await time.clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1n))).to.equal(",
          "135:             (tokenSupply * newRatio) / 100n,",
          "140:           const quorumNumerator = 101n;",
          "144:                 target: this.mock.target,",
          "145:                 data: this.mock.interface.encodeFunctionData('updateQuorumNumerator', [quorumNumerator]),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "152:           await this.helper.propose();",
          "153:           await this.helper.waitForSnapshot();",
          "155:           await this.helper.waitForDeadline();",
          "157:           const quorumDenominator = await this.mock.quorumDenominator();",
          "163:         });",
          "164:       });",
          "165:     });",
          "",
          "[Removed Lines]",
          "154:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "159:           await expectRevertCustomError(this.helper.execute(), 'GovernorInvalidQuorumFraction', [",
          "160:             quorumNumerator,",
          "161:             quorumDenominator,",
          "162:           ]);",
          "",
          "[Added Lines]",
          "153:           await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For });",
          "158:           await expect(this.helper.execute())",
          "159:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidQuorumFraction')",
          "160:             .withArgs(quorumNumerator, quorumDenominator);",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorWithParams.test.js||test/governance/extensions/GovernorWithParams.test.js": [
          "File: test/governance/extensions/GovernorWithParams.test.js -> test/governance/extensions/GovernorWithParams.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "8: const { GovernorHelper } = require('../../helpers/governance');",
          "22: const TOKENS = [",
          "25: ];",
          "58:         this.proposal = this.helper.setProposal(",
          "59:           [",
          "60:             {",
          "62:               value,",
          "64:             },",
          "65:           ],",
          "66:           '<proposal description>',",
          "",
          "[Removed Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "3: const ethSigUtil = require('eth-sig-util');",
          "4: const Wallet = require('ethereumjs-wallet').default;",
          "6: const Enums = require('../../helpers/enums');",
          "7: const { getDomain, domainType, ExtendedBallot } = require('../../helpers/eip712');",
          "9: const { expectRevertCustomError } = require('../../helpers/customError');",
          "11: const Governor = artifacts.require('$GovernorWithParamsMock');",
          "12: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13: const ERC1271WalletMock = artifacts.require('ERC1271WalletMock');",
          "15: const rawParams = {",
          "16:   uintParam: web3.utils.toBN('42'),",
          "17:   strParam: 'These are my params',",
          "18: };",
          "20: const encodedParams = web3.eth.abi.encodeParameters(['uint256', 'string'], Object.values(rawParams));",
          "23:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "24:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "27: contract('GovernorWithParams', function (accounts) {",
          "28:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "30:   const name = 'OZ-Governor';",
          "31:   const version = '1';",
          "32:   const tokenName = 'MockToken';",
          "33:   const tokenSymbol = 'MTKN';",
          "34:   const tokenSupply = web3.utils.toWei('100');",
          "35:   const votingDelay = web3.utils.toBN(4);",
          "36:   const votingPeriod = web3.utils.toBN(16);",
          "37:   const value = web3.utils.toWei('1');",
          "39:   for (const { mode, Token } of TOKENS) {",
          "40:     describe(`using ${Token._json.contractName}`, function () {",
          "41:       beforeEach(async function () {",
          "42:         this.chainId = await web3.eth.getChainId();",
          "43:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, version);",
          "44:         this.mock = await Governor.new(name, this.token.address);",
          "45:         this.receiver = await CallReceiver.new();",
          "47:         this.helper = new GovernorHelper(this.mock, mode);",
          "49:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "51:         await this.token.$_mint(owner, tokenSupply);",
          "52:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "53:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "54:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "55:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "61:               target: this.receiver.address,",
          "63:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "6: const { bigint: Enums } = require('../../helpers/enums');",
          "7: const { getDomain, ExtendedBallot } = require('../../helpers/eip712');",
          "10:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "11:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "14: const name = 'OZ-Governor';",
          "15: const version = '1';",
          "16: const tokenName = 'MockToken';",
          "17: const tokenSymbol = 'MTKN';",
          "18: const tokenSupply = ethers.parseEther('100');",
          "19: const votingDelay = 4n;",
          "20: const votingPeriod = 16n;",
          "21: const value = ethers.parseEther('1');",
          "23: const params = {",
          "24:   decoded: [42n, 'These are my params'],",
          "25:   encoded: ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'string'], [42n, 'These are my params']),",
          "26: };",
          "28: describe('GovernorWithParams', function () {",
          "29:   for (const { Token, mode } of TOKENS) {",
          "30:     const fixture = async () => {",
          "31:       const [owner, proposer, voter1, voter2, voter3, voter4, other] = await ethers.getSigners();",
          "32:       const receiver = await ethers.deployContract('CallReceiverMock');",
          "34:       const token = await ethers.deployContract(Token, [tokenName, tokenSymbol, version]);",
          "35:       const mock = await ethers.deployContract('$GovernorWithParamsMock', [name, token]);",
          "37:       await owner.sendTransaction({ to: mock, value });",
          "38:       await token.$_mint(owner, tokenSupply);",
          "40:       const helper = new GovernorHelper(mock, mode);",
          "41:       await helper.connect(owner).delegate({ token, to: voter1, value: ethers.parseEther('10') });",
          "42:       await helper.connect(owner).delegate({ token, to: voter2, value: ethers.parseEther('7') });",
          "43:       await helper.connect(owner).delegate({ token, to: voter3, value: ethers.parseEther('5') });",
          "44:       await helper.connect(owner).delegate({ token, to: voter4, value: ethers.parseEther('2') });",
          "46:       return { owner, proposer, voter1, voter2, voter3, voter4, other, receiver, token, mock, helper };",
          "47:     };",
          "49:     describe(`using ${Token}`, function () {",
          "50:       beforeEach(async function () {",
          "51:         Object.assign(this, await loadFixture(fixture));",
          "57:               target: this.receiver.target,",
          "59:               data: this.receiver.interface.encodeFunctionData('mockFunction'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:       });",
          "70:       it('deployment check', async function () {",
          "75:       });",
          "77:       it('nominal is unaffected', async function () {",
          "79:         await this.helper.waitForSnapshot();",
          "84:         await this.helper.waitForDeadline();",
          "85:         await this.helper.execute();",
          "92:       });",
          "94:       it('Voting with params is properly supported', async function () {",
          "96:         await this.helper.waitForSnapshot();",
          "102:             support: Enums.VoteType.For,",
          "103:             reason: 'no particular reason',",
          "121:       });",
          "123:       describe('voting by signature', function () {",
          "143:         it('supports EOA signatures', async function () {",
          "151:           await this.helper.propose();",
          "152:           await this.helper.waitForSnapshot();",
          "165:             proposalId: this.proposal.id,",
          "166:             support: Enums.VoteType.For,",
          "168:             reason: 'no particular reason',",
          "175:         });",
          "177:         it('supports EIP-1271 signature signatures', async function () {",
          "190:           await this.helper.propose();",
          "191:           await this.helper.waitForSnapshot();",
          "204:             proposalId: this.proposal.id,",
          "205:             support: Enums.VoteType.For,",
          "207:             reason: 'no particular reason',",
          "214:         });",
          "216:         it('reverts if signature does not match signer', async function () {",
          "224:           await this.helper.propose();",
          "225:           await this.helper.waitForSnapshot();",
          "227:             support: Enums.VoteType.For,",
          "229:             nonce,",
          "236:             reason: 'no particular reason',",
          "238:           };",
          "241:         });",
          "243:         it('reverts if vote nonce is incorrect', async function () {",
          "249:           await this.helper.propose();",
          "250:           await this.helper.waitForSnapshot();",
          "252:             support: Enums.VoteType.For,",
          "256:             reason: 'no particular reason',",
          "258:           };",
          "266:         });",
          "267:       });",
          "268:     });",
          "",
          "[Removed Lines]",
          "71:         expect(await this.mock.name()).to.be.equal(name);",
          "72:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "73:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "74:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "78:         await this.helper.propose({ from: proposer });",
          "80:         await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 });",
          "81:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "82:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "83:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "87:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "88:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "89:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "90:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "91:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal(value);",
          "95:         await this.helper.propose({ from: proposer });",
          "98:         const weight = web3.utils.toBN(web3.utils.toWei('7')).sub(rawParams.uintParam);",
          "100:         const tx = await this.helper.vote(",
          "101:           {",
          "104:             params: encodedParams,",
          "105:           },",
          "106:           { from: voter2 },",
          "107:         );",
          "109:         expectEvent(tx, 'CountParams', { ...rawParams });",
          "110:         expectEvent(tx, 'VoteCastWithParams', {",
          "111:           voter: voter2,",
          "112:           proposalId: this.proposal.id,",
          "113:           support: Enums.VoteType.For,",
          "114:           weight,",
          "115:           reason: 'no particular reason',",
          "116:           params: encodedParams,",
          "117:         });",
          "119:         const votes = await this.mock.proposalVotes(this.proposal.id);",
          "120:         expect(votes.forVotes).to.be.bignumber.equal(weight);",
          "124:         beforeEach(async function () {",
          "125:           this.voterBySig = Wallet.generate();",
          "126:           this.voterBySig.address = web3.utils.toChecksumAddress(this.voterBySig.getAddressString());",
          "128:           this.data = (contract, message) =>",
          "129:             getDomain(contract).then(domain => ({",
          "130:               primaryType: 'ExtendedBallot',",
          "131:               types: {",
          "132:                 EIP712Domain: domainType(domain),",
          "133:                 ExtendedBallot,",
          "134:               },",
          "135:               domain,",
          "136:               message,",
          "137:             }));",
          "139:           this.sign = privateKey => async (contract, message) =>",
          "140:             ethSigUtil.signTypedMessage(privateKey, { data: await this.data(contract, message) });",
          "141:         });",
          "144:           await this.token.delegate(this.voterBySig.address, { from: voter2 });",
          "146:           const weight = web3.utils.toBN(web3.utils.toWei('7')).sub(rawParams.uintParam);",
          "148:           const nonce = await this.mock.nonces(this.voterBySig.address);",
          "153:           const tx = await this.helper.vote({",
          "154:             support: Enums.VoteType.For,",
          "155:             voter: this.voterBySig.address,",
          "156:             nonce,",
          "157:             reason: 'no particular reason',",
          "158:             params: encodedParams,",
          "159:             signature: this.sign(this.voterBySig.getPrivateKey()),",
          "160:           });",
          "162:           expectEvent(tx, 'CountParams', { ...rawParams });",
          "163:           expectEvent(tx, 'VoteCastWithParams', {",
          "164:             voter: this.voterBySig.address,",
          "167:             weight,",
          "169:             params: encodedParams,",
          "170:           });",
          "172:           const votes = await this.mock.proposalVotes(this.proposal.id);",
          "173:           expect(votes.forVotes).to.be.bignumber.equal(weight);",
          "174:           expect(await this.mock.nonces(this.voterBySig.address)).to.be.bignumber.equal(nonce.addn(1));",
          "178:           const ERC1271WalletOwner = Wallet.generate();",
          "179:           ERC1271WalletOwner.address = web3.utils.toChecksumAddress(ERC1271WalletOwner.getAddressString());",
          "181:           const wallet = await ERC1271WalletMock.new(ERC1271WalletOwner.address);",
          "183:           await this.token.delegate(wallet.address, { from: voter2 });",
          "185:           const weight = web3.utils.toBN(web3.utils.toWei('7')).sub(rawParams.uintParam);",
          "187:           const nonce = await this.mock.nonces(wallet.address);",
          "192:           const tx = await this.helper.vote({",
          "193:             support: Enums.VoteType.For,",
          "194:             voter: wallet.address,",
          "195:             nonce,",
          "196:             reason: 'no particular reason',",
          "197:             params: encodedParams,",
          "198:             signature: this.sign(ERC1271WalletOwner.getPrivateKey()),",
          "199:           });",
          "201:           expectEvent(tx, 'CountParams', { ...rawParams });",
          "202:           expectEvent(tx, 'VoteCastWithParams', {",
          "203:             voter: wallet.address,",
          "206:             weight,",
          "208:             params: encodedParams,",
          "209:           });",
          "211:           const votes = await this.mock.proposalVotes(this.proposal.id);",
          "212:           expect(votes.forVotes).to.be.bignumber.equal(weight);",
          "213:           expect(await this.mock.nonces(wallet.address)).to.be.bignumber.equal(nonce.addn(1));",
          "217:           await this.token.delegate(this.voterBySig.address, { from: voter2 });",
          "219:           const nonce = await this.mock.nonces(this.voterBySig.address);",
          "221:           const signature = this.sign(this.voterBySig.getPrivateKey());",
          "226:           const voteParams = {",
          "228:             voter: this.voterBySig.address,",
          "230:             signature: async (...params) => {",
          "231:               const sig = await signature(...params);",
          "232:               const tamperedSig = web3.utils.hexToBytes(sig);",
          "233:               tamperedSig[42] ^= 0xff;",
          "234:               return web3.utils.bytesToHex(tamperedSig);",
          "235:             },",
          "237:             params: encodedParams,",
          "240:           await expectRevertCustomError(this.helper.vote(voteParams), 'GovernorInvalidSignature', [voteParams.voter]);",
          "244:           await this.token.delegate(this.voterBySig.address, { from: voter2 });",
          "246:           const nonce = await this.mock.nonces(this.voterBySig.address);",
          "251:           const voteParams = {",
          "253:             voter: this.voterBySig.address,",
          "254:             nonce: nonce.addn(1),",
          "255:             signature: this.sign(this.voterBySig.getPrivateKey()),",
          "257:             params: encodedParams,",
          "260:           await expectRevertCustomError(",
          "261:             this.helper.vote(voteParams),",
          "263:             'GovernorInvalidSignature',",
          "264:             [voteParams.voter],",
          "265:           );",
          "",
          "[Added Lines]",
          "67:         expect(await this.mock.name()).to.equal(name);",
          "68:         expect(await this.mock.token()).to.equal(this.token.target);",
          "69:         expect(await this.mock.votingDelay()).to.equal(votingDelay);",
          "70:         expect(await this.mock.votingPeriod()).to.equal(votingPeriod);",
          "74:         await this.helper.connect(this.proposer).propose();",
          "76:         await this.helper.connect(this.voter1).vote({ support: Enums.VoteType.For, reason: 'This is nice' });",
          "77:         await this.helper.connect(this.voter2).vote({ support: Enums.VoteType.For });",
          "78:         await this.helper.connect(this.voter3).vote({ support: Enums.VoteType.Against });",
          "79:         await this.helper.connect(this.voter4).vote({ support: Enums.VoteType.Abstain });",
          "83:         expect(await this.mock.hasVoted(this.proposal.id, this.owner)).to.be.false;",
          "84:         expect(await this.mock.hasVoted(this.proposal.id, this.voter1)).to.be.true;",
          "85:         expect(await this.mock.hasVoted(this.proposal.id, this.voter2)).to.be.true;",
          "86:         expect(await ethers.provider.getBalance(this.mock)).to.equal(0n);",
          "87:         expect(await ethers.provider.getBalance(this.receiver)).to.equal(value);",
          "91:         await this.helper.connect(this.proposer).propose();",
          "94:         const weight = ethers.parseEther('7') - params.decoded[0];",
          "96:         await expect(",
          "97:           this.helper.connect(this.voter2).vote({",
          "100:             params: params.encoded,",
          "101:           }),",
          "102:         )",
          "103:           .to.emit(this.mock, 'CountParams')",
          "104:           .withArgs(...params.decoded)",
          "105:           .to.emit(this.mock, 'VoteCastWithParams')",
          "106:           .withArgs(",
          "107:             this.voter2.address,",
          "108:             this.proposal.id,",
          "109:             Enums.VoteType.For,",
          "110:             weight,",
          "111:             'no particular reason',",
          "112:             params.encoded,",
          "113:           );",
          "115:         expect(await this.mock.proposalVotes(this.proposal.id)).to.deep.equal([0n, weight, 0n]);",
          "120:           await this.token.connect(this.voter2).delegate(this.other);",
          "127:           const weight = ethers.parseEther('7') - params.decoded[0];",
          "128:           const nonce = await this.mock.nonces(this.other);",
          "129:           const data = {",
          "132:             voter: this.other.address,",
          "133:             nonce,",
          "135:             params: params.encoded,",
          "136:             signature: (contract, message) =>",
          "137:               getDomain(contract).then(domain => this.other.signTypedData(domain, { ExtendedBallot }, message)),",
          "138:           };",
          "141:           await expect(this.helper.vote(data))",
          "142:             .to.emit(this.mock, 'CountParams')",
          "143:             .withArgs(...params.decoded)",
          "144:             .to.emit(this.mock, 'VoteCastWithParams')",
          "145:             .withArgs(data.voter, data.proposalId, data.support, weight, data.reason, data.params);",
          "147:           expect(await this.mock.proposalVotes(this.proposal.id)).to.deep.equal([0n, weight, 0n]);",
          "148:           expect(await this.mock.nonces(this.other)).to.equal(nonce + 1n);",
          "152:           const wallet = await ethers.deployContract('ERC1271WalletMock', [this.other]);",
          "153:           await this.token.connect(this.voter2).delegate(wallet);",
          "160:           const weight = ethers.parseEther('7') - params.decoded[0];",
          "161:           const nonce = await this.mock.nonces(this.other);",
          "162:           const data = {",
          "165:             voter: wallet.target,",
          "166:             nonce,",
          "168:             params: params.encoded,",
          "169:             signature: (contract, message) =>",
          "170:               getDomain(contract).then(domain => this.other.signTypedData(domain, { ExtendedBallot }, message)),",
          "171:           };",
          "174:           await expect(this.helper.vote(data))",
          "175:             .to.emit(this.mock, 'CountParams')",
          "176:             .withArgs(...params.decoded)",
          "177:             .to.emit(this.mock, 'VoteCastWithParams')",
          "178:             .withArgs(data.voter, data.proposalId, data.support, weight, data.reason, data.params);",
          "180:           expect(await this.mock.proposalVotes(this.proposal.id)).to.deep.equal([0n, weight, 0n]);",
          "181:           expect(await this.mock.nonces(wallet)).to.equal(nonce + 1n);",
          "185:           await this.token.connect(this.voter2).delegate(this.other);",
          "192:           const nonce = await this.mock.nonces(this.other);",
          "193:           const data = {",
          "194:             proposalId: this.proposal.id,",
          "196:             voter: this.other.address,",
          "199:             params: params.encoded,",
          "201:             signature: (contract, message) =>",
          "202:               getDomain(contract)",
          "203:                 .then(domain => this.other.signTypedData(domain, { ExtendedBallot }, message))",
          "204:                 .then(signature => {",
          "205:                   const tamperedSig = ethers.toBeArray(signature);",
          "206:                   tamperedSig[42] ^= 0xff;",
          "207:                   return ethers.hexlify(tamperedSig);",
          "208:                 }),",
          "212:           await expect(this.helper.vote(data))",
          "213:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidSignature')",
          "214:             .withArgs(data.voter);",
          "218:           await this.token.connect(this.voter2).delegate(this.other);",
          "225:           const nonce = await this.mock.nonces(this.other);",
          "226:           const data = {",
          "227:             proposalId: this.proposal.id,",
          "229:             voter: this.other.address,",
          "230:             nonce: nonce + 1n,",
          "232:             params: params.encoded,",
          "233:             signature: (contract, message) =>",
          "234:               getDomain(contract).then(domain => this.other.signTypedData(domain, { ExtendedBallot }, message)),",
          "238:           await expect(this.helper.vote(data))",
          "239:             .to.be.revertedWithCustomError(this.mock, 'GovernorInvalidSignature')",
          "240:             .withArgs(data.voter);",
          "",
          "---------------"
        ],
        "test/governance/utils/ERC6372.behavior.js||test/governance/utils/ERC6372.behavior.js": [
          "File: test/governance/utils/ERC6372.behavior.js -> test/governance/utils/ERC6372.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: function shouldBehaveLikeERC6372(mode = 'blocknumber') {",
          "5:     beforeEach(async function () {",
          "6:       this.mock = this.mock ?? this.token ?? this.votes;",
          "7:     });",
          "9:     it('clock is correct', async function () {",
          "11:     });",
          "13:     it('CLOCK_MODE is correct', async function () {",
          "14:       const params = new URLSearchParams(await this.mock.CLOCK_MODE());",
          "17:     });",
          "18:   });",
          "19: }",
          "",
          "[Removed Lines]",
          "1: const { clock } = require('../../helpers/time');",
          "4:   describe('should implement ERC6372', function () {",
          "10:       expect(await this.mock.clock()).to.be.bignumber.equal(await clock[mode]().then(web3.utils.toBN));",
          "15:       expect(params.get('mode')).to.be.equal(mode);",
          "16:       expect(params.get('from')).to.be.equal(mode == 'blocknumber' ? 'default' : null);",
          "",
          "[Added Lines]",
          "1: const { bigint: time } = require('../../helpers/time');",
          "4:   describe('should implement ERC-6372', function () {",
          "10:       expect(await this.mock.clock()).to.equal(await time.clock[mode]());",
          "15:       expect(params.get('mode')).to.equal(mode);",
          "16:       expect(params.get('from')).to.equal(mode == 'blocknumber' ? 'default' : null);",
          "",
          "---------------"
        ],
        "test/governance/utils/Votes.behavior.js||test/governance/utils/Votes.behavior.js": [
          "File: test/governance/utils/Votes.behavior.js -> test/governance/utils/Votes.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: const { shouldBehaveLikeERC6372 } = require('./ERC6372.behavior');",
          "25:   shouldBehaveLikeERC6372(mode);",
          "29:   describe('run votes workflow', function () {",
          "30:     it('initial nonce is 0', async function () {",
          "32:     });",
          "34:     describe('delegation with signature', function () {",
          "35:       const token = tokens[0];",
          "37:       it('delegation without tokens', async function () {",
          "49:       });",
          "51:       it('delegation with tokens', async function () {",
          "53:         const weight = getWeight(token);",
          "76:       });",
          "78:       it('delegation update', async function () {",
          "81:         const weight = getWeight(token);",
          "115:       });",
          "117:       describe('with signature', function () {",
          "123:         it('accept signed delegation', async function () {",
          "125:           const weight = getWeight(token);",
          "159:         });",
          "161:         it('rejects reused signature', async function () {",
          "179:         });",
          "181:         it('rejects bad delegatee', async function () {",
          "190:           );",
          "197:         });",
          "199:         it('rejects bad nonce', async function () {",
          "215:         });",
          "217:         it('rejects expired permit', async function () {",
          "234:         });",
          "235:       });",
          "236:     });",
          "238:     describe('getPastTotalSupply', function () {",
          "239:       beforeEach(async function () {",
          "241:       });",
          "243:       it('reverts if block number >= current block', async function () {",
          "244:         const timepoint = 5e10;",
          "245:         const clock = await this.votes.clock();",
          "250:       });",
          "252:       it('returns 0 if there are no checkpoints', async function () {",
          "254:       });",
          "256:       it('returns the correct checkpointed total supply', async function () {",
          "257:         const weight = tokens.map(token => getWeight(token));",
          "301:       });",
          "302:     });",
          "",
          "[Removed Lines]",
          "1: const { constants, expectEvent, time } = require('@openzeppelin/test-helpers');",
          "3: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "5: const { fromRpcSig } = require('ethereumjs-util');",
          "6: const ethSigUtil = require('eth-sig-util');",
          "7: const Wallet = require('ethereumjs-wallet').default;",
          "10: const { getDomain, domainType, Delegation } = require('../../helpers/eip712');",
          "11: const { clockFromReceipt } = require('../../helpers/time');",
          "12: const { expectRevertCustomError } = require('../../helpers/customError');",
          "14: const buildAndSignDelegation = (contract, message, pk) =>",
          "15:   getDomain(contract)",
          "16:     .then(domain => ({",
          "17:       primaryType: 'Delegation',",
          "18:       types: { EIP712Domain: domainType(domain), Delegation },",
          "19:       domain,",
          "20:       message,",
          "21:     }))",
          "22:     .then(data => fromRpcSig(ethSigUtil.signTypedMessage(pk, { data })));",
          "24: function shouldBehaveLikeVotes(accounts, tokens, { mode = 'blocknumber', fungible = true }) {",
          "27:   const getWeight = token => web3.utils.toBN(fungible ? token : 1);",
          "31:       expect(await this.votes.nonces(accounts[0])).to.be.bignumber.equal('0');",
          "38:         expect(await this.votes.delegates(accounts[1])).to.be.equal(ZERO_ADDRESS);",
          "40:         const { receipt } = await this.votes.delegate(accounts[1], { from: accounts[1] });",
          "41:         expectEvent(receipt, 'DelegateChanged', {",
          "42:           delegator: accounts[1],",
          "43:           fromDelegate: ZERO_ADDRESS,",
          "44:           toDelegate: accounts[1],",
          "45:         });",
          "46:         expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "48:         expect(await this.votes.delegates(accounts[1])).to.be.equal(accounts[1]);",
          "52:         await this.votes.$_mint(accounts[1], token);",
          "55:         expect(await this.votes.delegates(accounts[1])).to.be.equal(ZERO_ADDRESS);",
          "57:         const { receipt } = await this.votes.delegate(accounts[1], { from: accounts[1] });",
          "58:         const timepoint = await clockFromReceipt[mode](receipt);",
          "60:         expectEvent(receipt, 'DelegateChanged', {",
          "61:           delegator: accounts[1],",
          "62:           fromDelegate: ZERO_ADDRESS,",
          "63:           toDelegate: accounts[1],",
          "64:         });",
          "65:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "66:           delegate: accounts[1],",
          "67:           previousVotes: '0',",
          "68:           newVotes: weight,",
          "69:         });",
          "71:         expect(await this.votes.delegates(accounts[1])).to.be.equal(accounts[1]);",
          "72:         expect(await this.votes.getVotes(accounts[1])).to.be.bignumber.equal(weight);",
          "73:         expect(await this.votes.getPastVotes(accounts[1], timepoint - 1)).to.be.bignumber.equal('0');",
          "74:         await time.advanceBlock();",
          "75:         expect(await this.votes.getPastVotes(accounts[1], timepoint)).to.be.bignumber.equal(weight);",
          "79:         await this.votes.delegate(accounts[1], { from: accounts[1] });",
          "80:         await this.votes.$_mint(accounts[1], token);",
          "83:         expect(await this.votes.delegates(accounts[1])).to.be.equal(accounts[1]);",
          "84:         expect(await this.votes.getVotes(accounts[1])).to.be.bignumber.equal(weight);",
          "85:         expect(await this.votes.getVotes(accounts[2])).to.be.bignumber.equal('0');",
          "87:         const { receipt } = await this.votes.delegate(accounts[2], { from: accounts[1] });",
          "88:         const timepoint = await clockFromReceipt[mode](receipt);",
          "90:         expectEvent(receipt, 'DelegateChanged', {",
          "91:           delegator: accounts[1],",
          "92:           fromDelegate: accounts[1],",
          "93:           toDelegate: accounts[2],",
          "94:         });",
          "95:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "96:           delegate: accounts[1],",
          "97:           previousVotes: weight,",
          "98:           newVotes: '0',",
          "99:         });",
          "100:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "101:           delegate: accounts[2],",
          "102:           previousVotes: '0',",
          "103:           newVotes: weight,",
          "104:         });",
          "106:         expect(await this.votes.delegates(accounts[1])).to.be.equal(accounts[2]);",
          "107:         expect(await this.votes.getVotes(accounts[1])).to.be.bignumber.equal('0');",
          "108:         expect(await this.votes.getVotes(accounts[2])).to.be.bignumber.equal(weight);",
          "110:         expect(await this.votes.getPastVotes(accounts[1], timepoint - 1)).to.be.bignumber.equal(weight);",
          "111:         expect(await this.votes.getPastVotes(accounts[2], timepoint - 1)).to.be.bignumber.equal('0');",
          "112:         await time.advanceBlock();",
          "113:         expect(await this.votes.getPastVotes(accounts[1], timepoint)).to.be.bignumber.equal('0');",
          "114:         expect(await this.votes.getPastVotes(accounts[2], timepoint)).to.be.bignumber.equal(weight);",
          "118:         const delegator = Wallet.generate();",
          "119:         const [delegatee, other] = accounts;",
          "120:         const nonce = 0;",
          "121:         delegator.address = web3.utils.toChecksumAddress(delegator.getAddressString());",
          "124:           await this.votes.$_mint(delegator.address, token);",
          "127:           const { v, r, s } = await buildAndSignDelegation(",
          "128:             this.votes,",
          "129:             {",
          "130:               delegatee,",
          "131:               nonce,",
          "132:               expiry: MAX_UINT256,",
          "133:             },",
          "134:             delegator.getPrivateKey(),",
          "135:           );",
          "137:           expect(await this.votes.delegates(delegator.address)).to.be.equal(ZERO_ADDRESS);",
          "139:           const { receipt } = await this.votes.delegateBySig(delegatee, nonce, MAX_UINT256, v, r, s);",
          "140:           const timepoint = await clockFromReceipt[mode](receipt);",
          "142:           expectEvent(receipt, 'DelegateChanged', {",
          "143:             delegator: delegator.address,",
          "144:             fromDelegate: ZERO_ADDRESS,",
          "145:             toDelegate: delegatee,",
          "146:           });",
          "147:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "148:             delegate: delegatee,",
          "149:             previousVotes: '0',",
          "150:             newVotes: weight,",
          "151:           });",
          "153:           expect(await this.votes.delegates(delegator.address)).to.be.equal(delegatee);",
          "154:           expect(await this.votes.getVotes(delegator.address)).to.be.bignumber.equal('0');",
          "155:           expect(await this.votes.getVotes(delegatee)).to.be.bignumber.equal(weight);",
          "156:           expect(await this.votes.getPastVotes(delegatee, timepoint - 1)).to.be.bignumber.equal('0');",
          "157:           await time.advanceBlock();",
          "158:           expect(await this.votes.getPastVotes(delegatee, timepoint)).to.be.bignumber.equal(weight);",
          "162:           const { v, r, s } = await buildAndSignDelegation(",
          "163:             this.votes,",
          "164:             {",
          "165:               delegatee,",
          "166:               nonce,",
          "167:               expiry: MAX_UINT256,",
          "168:             },",
          "169:             delegator.getPrivateKey(),",
          "170:           );",
          "172:           await this.votes.delegateBySig(delegatee, nonce, MAX_UINT256, v, r, s);",
          "174:           await expectRevertCustomError(",
          "175:             this.votes.delegateBySig(delegatee, nonce, MAX_UINT256, v, r, s),",
          "176:             'InvalidAccountNonce',",
          "177:             [delegator.address, nonce + 1],",
          "178:           );",
          "182:           const { v, r, s } = await buildAndSignDelegation(",
          "183:             this.votes,",
          "184:             {",
          "185:               delegatee,",
          "186:               nonce,",
          "187:               expiry: MAX_UINT256,",
          "188:             },",
          "189:             delegator.getPrivateKey(),",
          "192:           const receipt = await this.votes.delegateBySig(other, nonce, MAX_UINT256, v, r, s);",
          "193:           const { args } = receipt.logs.find(({ event }) => event === 'DelegateChanged');",
          "194:           expect(args.delegator).to.not.be.equal(delegator.address);",
          "195:           expect(args.fromDelegate).to.be.equal(ZERO_ADDRESS);",
          "196:           expect(args.toDelegate).to.be.equal(other);",
          "200:           const { v, r, s } = await buildAndSignDelegation(",
          "201:             this.votes,",
          "202:             {",
          "203:               delegatee,",
          "204:               nonce: nonce + 1,",
          "205:               expiry: MAX_UINT256,",
          "206:             },",
          "207:             delegator.getPrivateKey(),",
          "208:           );",
          "210:           await expectRevertCustomError(",
          "211:             this.votes.delegateBySig(delegatee, nonce + 1, MAX_UINT256, v, r, s),",
          "212:             'InvalidAccountNonce',",
          "213:             [delegator.address, 0],",
          "214:           );",
          "218:           const expiry = (await time.latest()) - time.duration.weeks(1);",
          "219:           const { v, r, s } = await buildAndSignDelegation(",
          "220:             this.votes,",
          "221:             {",
          "222:               delegatee,",
          "223:               nonce,",
          "224:               expiry,",
          "225:             },",
          "226:             delegator.getPrivateKey(),",
          "227:           );",
          "229:           await expectRevertCustomError(",
          "230:             this.votes.delegateBySig(delegatee, nonce, expiry, v, r, s),",
          "231:             'VotesExpiredSignature',",
          "232:             [expiry],",
          "233:           );",
          "240:         await this.votes.delegate(accounts[1], { from: accounts[1] });",
          "246:         await expectRevertCustomError(this.votes.getPastTotalSupply(timepoint), 'ERC5805FutureLookup', [",
          "247:           timepoint,",
          "248:           clock,",
          "249:         ]);",
          "253:         expect(await this.votes.getPastTotalSupply(0)).to.be.bignumber.equal('0');",
          "260:         const t0 = await this.votes.$_mint(accounts[1], tokens[0]);",
          "261:         await time.advanceBlock();",
          "263:         const t1 = await this.votes.$_mint(accounts[1], tokens[1]);",
          "264:         await time.advanceBlock();",
          "266:         const t2 = await this.votes.$_burn(...(fungible ? [accounts[1]] : []), tokens[1]);",
          "267:         await time.advanceBlock();",
          "269:         const t3 = await this.votes.$_mint(accounts[1], tokens[2]);",
          "270:         await time.advanceBlock();",
          "272:         const t4 = await this.votes.$_burn(...(fungible ? [accounts[1]] : []), tokens[0]);",
          "273:         await time.advanceBlock();",
          "275:         const t5 = await this.votes.$_burn(...(fungible ? [accounts[1]] : []), tokens[2]);",
          "276:         await time.advanceBlock();",
          "278:         t0.timepoint = await clockFromReceipt[mode](t0.receipt);",
          "279:         t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "280:         t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "281:         t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "282:         t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "283:         t5.timepoint = await clockFromReceipt[mode](t5.receipt);",
          "285:         expect(await this.votes.getPastTotalSupply(t0.timepoint - 1)).to.be.bignumber.equal('0');",
          "286:         expect(await this.votes.getPastTotalSupply(t0.timepoint)).to.be.bignumber.equal(weight[0]);",
          "287:         expect(await this.votes.getPastTotalSupply(t0.timepoint + 1)).to.be.bignumber.equal(weight[0]);",
          "288:         expect(await this.votes.getPastTotalSupply(t1.timepoint)).to.be.bignumber.equal(weight[0].add(weight[1]));",
          "289:         expect(await this.votes.getPastTotalSupply(t1.timepoint + 1)).to.be.bignumber.equal(weight[0].add(weight[1]));",
          "290:         expect(await this.votes.getPastTotalSupply(t2.timepoint)).to.be.bignumber.equal(weight[0]);",
          "291:         expect(await this.votes.getPastTotalSupply(t2.timepoint + 1)).to.be.bignumber.equal(weight[0]);",
          "292:         expect(await this.votes.getPastTotalSupply(t3.timepoint)).to.be.bignumber.equal(weight[0].add(weight[2]));",
          "293:         expect(await this.votes.getPastTotalSupply(t3.timepoint + 1)).to.be.bignumber.equal(weight[0].add(weight[2]));",
          "294:         expect(await this.votes.getPastTotalSupply(t4.timepoint)).to.be.bignumber.equal(weight[2]);",
          "295:         expect(await this.votes.getPastTotalSupply(t4.timepoint + 1)).to.be.bignumber.equal(weight[2]);",
          "296:         expect(await this.votes.getPastTotalSupply(t5.timepoint)).to.be.bignumber.equal('0');",
          "297:         await expectRevertCustomError(this.votes.getPastTotalSupply(t5.timepoint + 1), 'ERC5805FutureLookup', [",
          "298:           t5.timepoint + 1, // timepoint",
          "299:           t5.timepoint + 1, // clock",
          "300:         ]);",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "2: const { expect } = require('chai');",
          "3: const { mine } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { bigint: time } = require('../../helpers/time');",
          "6: const { getDomain, Delegation } = require('../../helpers/eip712');",
          "10: function shouldBehaveLikeVotes(tokens, { mode = 'blocknumber', fungible = true }) {",
          "11:   beforeEach(async function () {",
          "12:     [this.delegator, this.delegatee, this.alice, this.bob, this.other] = this.accounts;",
          "13:     this.domain = await getDomain(this.votes);",
          "14:   });",
          "18:   const getWeight = token => (fungible ? token : 1n);",
          "22:       expect(await this.votes.nonces(this.alice)).to.equal(0n);",
          "29:         expect(await this.votes.delegates(this.alice)).to.equal(ethers.ZeroAddress);",
          "31:         await expect(this.votes.connect(this.alice).delegate(this.alice))",
          "32:           .to.emit(this.votes, 'DelegateChanged')",
          "33:           .withArgs(this.alice.address, ethers.ZeroAddress, this.alice.address)",
          "34:           .to.not.emit(this.votes, 'DelegateVotesChanged');",
          "36:         expect(await this.votes.delegates(this.alice)).to.equal(this.alice.address);",
          "40:         await this.votes.$_mint(this.alice, token);",
          "43:         expect(await this.votes.delegates(this.alice)).to.equal(ethers.ZeroAddress);",
          "45:         const tx = await this.votes.connect(this.alice).delegate(this.alice);",
          "46:         const timepoint = await time.clockFromReceipt[mode](tx);",
          "48:         await expect(tx)",
          "49:           .to.emit(this.votes, 'DelegateChanged')",
          "50:           .withArgs(this.alice.address, ethers.ZeroAddress, this.alice.address)",
          "51:           .to.emit(this.votes, 'DelegateVotesChanged')",
          "52:           .withArgs(this.alice.address, 0n, weight);",
          "54:         expect(await this.votes.delegates(this.alice)).to.equal(this.alice.address);",
          "55:         expect(await this.votes.getVotes(this.alice)).to.equal(weight);",
          "56:         expect(await this.votes.getPastVotes(this.alice, timepoint - 1n)).to.equal(0n);",
          "57:         await mine();",
          "58:         expect(await this.votes.getPastVotes(this.alice, timepoint)).to.equal(weight);",
          "62:         await this.votes.connect(this.alice).delegate(this.alice);",
          "63:         await this.votes.$_mint(this.alice, token);",
          "66:         expect(await this.votes.delegates(this.alice)).to.equal(this.alice.address);",
          "67:         expect(await this.votes.getVotes(this.alice)).to.equal(weight);",
          "68:         expect(await this.votes.getVotes(this.bob)).to.equal(0);",
          "70:         const tx = await this.votes.connect(this.alice).delegate(this.bob);",
          "71:         const timepoint = await time.clockFromReceipt[mode](tx);",
          "73:         await expect(tx)",
          "74:           .to.emit(this.votes, 'DelegateChanged')",
          "75:           .withArgs(this.alice.address, this.alice.address, this.bob.address)",
          "76:           .to.emit(this.votes, 'DelegateVotesChanged')",
          "77:           .withArgs(this.alice.address, weight, 0)",
          "78:           .to.emit(this.votes, 'DelegateVotesChanged')",
          "79:           .withArgs(this.bob.address, 0, weight);",
          "81:         expect(await this.votes.delegates(this.alice)).to.equal(this.bob.address);",
          "82:         expect(await this.votes.getVotes(this.alice)).to.equal(0n);",
          "83:         expect(await this.votes.getVotes(this.bob)).to.equal(weight);",
          "85:         expect(await this.votes.getPastVotes(this.alice, timepoint - 1n)).to.equal(weight);",
          "86:         expect(await this.votes.getPastVotes(this.bob, timepoint - 1n)).to.equal(0n);",
          "87:         await mine();",
          "88:         expect(await this.votes.getPastVotes(this.alice, timepoint)).to.equal(0n);",
          "89:         expect(await this.votes.getPastVotes(this.bob, timepoint)).to.equal(weight);",
          "93:         const nonce = 0n;",
          "96:           await this.votes.$_mint(this.delegator.address, token);",
          "99:           const { r, s, v } = await this.delegator",
          "100:             .signTypedData(",
          "101:               this.domain,",
          "102:               { Delegation },",
          "103:               {",
          "104:                 delegatee: this.delegatee.address,",
          "105:                 nonce,",
          "106:                 expiry: ethers.MaxUint256,",
          "107:               },",
          "108:             )",
          "109:             .then(ethers.Signature.from);",
          "111:           expect(await this.votes.delegates(this.delegator.address)).to.equal(ethers.ZeroAddress);",
          "113:           const tx = await this.votes.delegateBySig(this.delegatee, nonce, ethers.MaxUint256, v, r, s);",
          "114:           const timepoint = await time.clockFromReceipt[mode](tx);",
          "116:           await expect(tx)",
          "117:             .to.emit(this.votes, 'DelegateChanged')",
          "118:             .withArgs(this.delegator.address, ethers.ZeroAddress, this.delegatee.address)",
          "119:             .to.emit(this.votes, 'DelegateVotesChanged')",
          "120:             .withArgs(this.delegatee.address, 0, weight);",
          "122:           expect(await this.votes.delegates(this.delegator.address)).to.equal(this.delegatee.address);",
          "123:           expect(await this.votes.getVotes(this.delegator.address)).to.equal(0n);",
          "124:           expect(await this.votes.getVotes(this.delegatee)).to.equal(weight);",
          "125:           expect(await this.votes.getPastVotes(this.delegatee, timepoint - 1n)).to.equal(0n);",
          "126:           await mine();",
          "127:           expect(await this.votes.getPastVotes(this.delegatee, timepoint)).to.equal(weight);",
          "131:           const { r, s, v } = await this.delegator",
          "132:             .signTypedData(",
          "133:               this.domain,",
          "134:               { Delegation },",
          "135:               {",
          "136:                 delegatee: this.delegatee.address,",
          "137:                 nonce,",
          "138:                 expiry: ethers.MaxUint256,",
          "139:               },",
          "140:             )",
          "141:             .then(ethers.Signature.from);",
          "143:           await this.votes.delegateBySig(this.delegatee, nonce, ethers.MaxUint256, v, r, s);",
          "145:           await expect(this.votes.delegateBySig(this.delegatee, nonce, ethers.MaxUint256, v, r, s))",
          "146:             .to.be.revertedWithCustomError(this.votes, 'InvalidAccountNonce')",
          "147:             .withArgs(this.delegator.address, nonce + 1n);",
          "151:           const { r, s, v } = await this.delegator",
          "152:             .signTypedData(",
          "153:               this.domain,",
          "154:               { Delegation },",
          "155:               {",
          "156:                 delegatee: this.delegatee.address,",
          "157:                 nonce,",
          "158:                 expiry: ethers.MaxUint256,",
          "159:               },",
          "160:             )",
          "161:             .then(ethers.Signature.from);",
          "163:           const tx = await this.votes.delegateBySig(this.other, nonce, ethers.MaxUint256, v, r, s);",
          "164:           const receipt = await tx.wait();",
          "166:           const [delegateChanged] = receipt.logs.filter(",
          "167:             log => this.votes.interface.parseLog(log)?.name === 'DelegateChanged',",
          "169:           const { args } = this.votes.interface.parseLog(delegateChanged);",
          "170:           expect(args.delegator).to.not.be.equal(this.delegator.address);",
          "171:           expect(args.fromDelegate).to.equal(ethers.ZeroAddress);",
          "172:           expect(args.toDelegate).to.equal(this.other.address);",
          "176:           const { r, s, v } = await this.delegator",
          "177:             .signTypedData(",
          "178:               this.domain,",
          "179:               { Delegation },",
          "180:               {",
          "181:                 delegatee: this.delegatee.address,",
          "182:                 nonce: nonce + 1n,",
          "183:                 expiry: ethers.MaxUint256,",
          "184:               },",
          "185:             )",
          "186:             .then(ethers.Signature.from);",
          "188:           await expect(this.votes.delegateBySig(this.delegatee, nonce + 1n, ethers.MaxUint256, v, r, s))",
          "189:             .to.be.revertedWithCustomError(this.votes, 'InvalidAccountNonce')",
          "190:             .withArgs(this.delegator.address, 0);",
          "194:           const expiry = (await time.clock.timestamp()) - 1n;",
          "195:           const { r, s, v } = await this.delegator",
          "196:             .signTypedData(",
          "197:               this.domain,",
          "198:               { Delegation },",
          "199:               {",
          "200:                 delegatee: this.delegatee.address,",
          "201:                 nonce,",
          "202:                 expiry,",
          "203:               },",
          "204:             )",
          "205:             .then(ethers.Signature.from);",
          "207:           await expect(this.votes.delegateBySig(this.delegatee, nonce, expiry, v, r, s))",
          "208:             .to.be.revertedWithCustomError(this.votes, 'VotesExpiredSignature')",
          "209:             .withArgs(expiry);",
          "216:         await this.votes.connect(this.alice).delegate(this.alice);",
          "222:         await expect(this.votes.getPastTotalSupply(timepoint))",
          "223:           .to.be.revertedWithCustomError(this.votes, 'ERC5805FutureLookup')",
          "224:           .withArgs(timepoint, clock);",
          "228:         expect(await this.votes.getPastTotalSupply(0n)).to.equal(0n);",
          "235:         const t0 = await this.votes.$_mint(this.alice, tokens[0]);",
          "236:         await mine();",
          "238:         const t1 = await this.votes.$_mint(this.alice, tokens[1]);",
          "239:         await mine();",
          "241:         const t2 = await this.votes.$_burn(...(fungible ? [this.alice] : []), tokens[1]);",
          "242:         await mine();",
          "244:         const t3 = await this.votes.$_mint(this.alice, tokens[2]);",
          "245:         await mine();",
          "247:         const t4 = await this.votes.$_burn(...(fungible ? [this.alice] : []), tokens[0]);",
          "248:         await mine();",
          "250:         const t5 = await this.votes.$_burn(...(fungible ? [this.alice] : []), tokens[2]);",
          "251:         await mine();",
          "253:         t0.timepoint = await time.clockFromReceipt[mode](t0);",
          "254:         t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "255:         t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "256:         t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "257:         t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "258:         t5.timepoint = await time.clockFromReceipt[mode](t5);",
          "260:         expect(await this.votes.getPastTotalSupply(t0.timepoint - 1n)).to.equal(0);",
          "261:         expect(await this.votes.getPastTotalSupply(t0.timepoint)).to.equal(weight[0]);",
          "262:         expect(await this.votes.getPastTotalSupply(t0.timepoint + 1n)).to.equal(weight[0]);",
          "263:         expect(await this.votes.getPastTotalSupply(t1.timepoint)).to.equal(weight[0] + weight[1]);",
          "264:         expect(await this.votes.getPastTotalSupply(t1.timepoint + 1n)).to.equal(weight[0] + weight[1]);",
          "265:         expect(await this.votes.getPastTotalSupply(t2.timepoint)).to.equal(weight[0]);",
          "266:         expect(await this.votes.getPastTotalSupply(t2.timepoint + 1n)).to.equal(weight[0]);",
          "267:         expect(await this.votes.getPastTotalSupply(t3.timepoint)).to.equal(weight[0] + weight[2]);",
          "268:         expect(await this.votes.getPastTotalSupply(t3.timepoint + 1n)).to.equal(weight[0] + weight[2]);",
          "269:         expect(await this.votes.getPastTotalSupply(t4.timepoint)).to.equal(weight[2]);",
          "270:         expect(await this.votes.getPastTotalSupply(t4.timepoint + 1n)).to.equal(weight[2]);",
          "271:         expect(await this.votes.getPastTotalSupply(t5.timepoint)).to.equal(0);",
          "272:         await expect(this.votes.getPastTotalSupply(t5.timepoint + 1n))",
          "273:           .to.be.revertedWithCustomError(this.votes, 'ERC5805FutureLookup')",
          "274:           .withArgs(t5.timepoint + 1n, t5.timepoint + 1n);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306:     describe('Compound test suite', function () {",
          "307:       beforeEach(async function () {",
          "311:       });",
          "313:       describe('getPastVotes', function () {",
          "314:         it('reverts if block number >= current block', async function () {",
          "315:           const clock = await this.votes.clock();",
          "316:           const timepoint = 5e10; // far in the future",
          "321:         });",
          "323:         it('returns 0 if there are no checkpoints', async function () {",
          "325:         });",
          "327:         it('returns the latest block if >= last checkpoint block', async function () {",
          "336:         });",
          "338:         it('returns zero if < first checkpoint block', async function () {",
          "346:         });",
          "347:       });",
          "348:     });",
          "",
          "[Removed Lines]",
          "308:         await this.votes.$_mint(accounts[1], tokens[0]);",
          "309:         await this.votes.$_mint(accounts[1], tokens[1]);",
          "310:         await this.votes.$_mint(accounts[1], tokens[2]);",
          "317:           await expectRevertCustomError(this.votes.getPastVotes(accounts[2], timepoint), 'ERC5805FutureLookup', [",
          "318:             timepoint,",
          "319:             clock,",
          "320:           ]);",
          "324:           expect(await this.votes.getPastVotes(accounts[2], 0)).to.be.bignumber.equal('0');",
          "328:           const { receipt } = await this.votes.delegate(accounts[2], { from: accounts[1] });",
          "329:           const timepoint = await clockFromReceipt[mode](receipt);",
          "330:           await time.advanceBlock();",
          "331:           await time.advanceBlock();",
          "333:           const latest = await this.votes.getVotes(accounts[2]);",
          "334:           expect(await this.votes.getPastVotes(accounts[2], timepoint)).to.be.bignumber.equal(latest);",
          "335:           expect(await this.votes.getPastVotes(accounts[2], timepoint + 1)).to.be.bignumber.equal(latest);",
          "339:           await time.advanceBlock();",
          "340:           const { receipt } = await this.votes.delegate(accounts[2], { from: accounts[1] });",
          "341:           const timepoint = await clockFromReceipt[mode](receipt);",
          "342:           await time.advanceBlock();",
          "343:           await time.advanceBlock();",
          "345:           expect(await this.votes.getPastVotes(accounts[2], timepoint - 1)).to.be.bignumber.equal('0');",
          "",
          "[Added Lines]",
          "282:         await this.votes.$_mint(this.alice, tokens[0]);",
          "283:         await this.votes.$_mint(this.alice, tokens[1]);",
          "284:         await this.votes.$_mint(this.alice, tokens[2]);",
          "291:           await expect(this.votes.getPastVotes(this.bob, timepoint))",
          "292:             .to.be.revertedWithCustomError(this.votes, 'ERC5805FutureLookup')",
          "293:             .withArgs(timepoint, clock);",
          "297:           expect(await this.votes.getPastVotes(this.bob, 0n)).to.equal(0n);",
          "301:           const delegate = await this.votes.connect(this.alice).delegate(this.bob);",
          "302:           const timepoint = await time.clockFromReceipt[mode](delegate);",
          "303:           await mine(2);",
          "305:           const latest = await this.votes.getVotes(this.bob);",
          "306:           expect(await this.votes.getPastVotes(this.bob, timepoint)).to.equal(latest);",
          "307:           expect(await this.votes.getPastVotes(this.bob, timepoint + 1n)).to.equal(latest);",
          "311:           await mine();",
          "312:           const delegate = await this.votes.connect(this.alice).delegate(this.bob);",
          "313:           const timepoint = await time.clockFromReceipt[mode](delegate);",
          "314:           await mine(2);",
          "316:           expect(await this.votes.getPastVotes(this.bob, timepoint - 1n)).to.equal(0n);",
          "",
          "---------------"
        ],
        "test/governance/utils/Votes.test.js||test/governance/utils/Votes.test.js": [
          "File: test/governance/utils/Votes.test.js -> test/governance/utils/Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: const { expect } = require('chai');",
          "9: const { shouldBehaveLikeVotes } = require('./Votes.behavior');",
          "11: const MODES = {",
          "14: };",
          "27:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "28:     describe(`vote with ${mode}`, function () {",
          "29:       beforeEach(async function () {",
          "31:       });",
          "35:       it('starts with zero votes', async function () {",
          "37:       });",
          "39:       describe('performs voting operations', function () {",
          "40:         beforeEach(async function () {",
          "41:           this.txs = [];",
          "43:             this.txs.push(await this.votes.$_mint(account, amount));",
          "44:           }",
          "45:         });",
          "47:         it('reverts if block number >= current block', async function () {",
          "49:           const clock = await this.votes.clock();",
          "54:         });",
          "56:         it('delegates', async function () {",
          "75:         });",
          "77:         it('cross delegates', async function () {",
          "83:         });",
          "85:         it('returns total amount of votes', async function () {",
          "88:         });",
          "89:       });",
          "90:     });",
          "",
          "[Removed Lines]",
          "1: const { constants } = require('@openzeppelin/test-helpers');",
          "3: const { clockFromReceipt } = require('../../helpers/time');",
          "4: const { BNsum } = require('../../helpers/math');",
          "5: const { expectRevertCustomError } = require('../../helpers/customError');",
          "7: require('array.prototype.at/auto');",
          "12:   blocknumber: artifacts.require('$VotesMock'),",
          "13:   timestamp: artifacts.require('$VotesTimestampMock'),",
          "16: contract('Votes', function (accounts) {",
          "17:   const [account1, account2, account3] = accounts;",
          "18:   const amounts = {",
          "19:     [account1]: web3.utils.toBN('10000000000000000000000000'),",
          "20:     [account2]: web3.utils.toBN('10'),",
          "21:     [account3]: web3.utils.toBN('20'),",
          "22:   };",
          "24:   const name = 'My Vote';",
          "25:   const version = '1';",
          "30:         this.votes = await artifact.new(name, version);",
          "33:       shouldBehaveLikeVotes(accounts, Object.values(amounts), { mode, fungible: true });",
          "36:         expect(await this.votes.getTotalSupply()).to.be.bignumber.equal('0');",
          "42:           for (const [account, amount] of Object.entries(amounts)) {",
          "48:           const lastTxTimepoint = await clockFromReceipt[mode](this.txs.at(-1).receipt);",
          "50:           await expectRevertCustomError(this.votes.getPastTotalSupply(lastTxTimepoint + 1), 'ERC5805FutureLookup', [",
          "51:             lastTxTimepoint + 1,",
          "52:             clock,",
          "53:           ]);",
          "57:           expect(await this.votes.getVotes(account1)).to.be.bignumber.equal('0');",
          "58:           expect(await this.votes.getVotes(account2)).to.be.bignumber.equal('0');",
          "59:           expect(await this.votes.delegates(account1)).to.be.equal(constants.ZERO_ADDRESS);",
          "60:           expect(await this.votes.delegates(account2)).to.be.equal(constants.ZERO_ADDRESS);",
          "62:           await this.votes.delegate(account1, account1);",
          "64:           expect(await this.votes.getVotes(account1)).to.be.bignumber.equal(amounts[account1]);",
          "65:           expect(await this.votes.getVotes(account2)).to.be.bignumber.equal('0');",
          "66:           expect(await this.votes.delegates(account1)).to.be.equal(account1);",
          "67:           expect(await this.votes.delegates(account2)).to.be.equal(constants.ZERO_ADDRESS);",
          "69:           await this.votes.delegate(account2, account1);",
          "71:           expect(await this.votes.getVotes(account1)).to.be.bignumber.equal(amounts[account1].add(amounts[account2]));",
          "72:           expect(await this.votes.getVotes(account2)).to.be.bignumber.equal('0');",
          "73:           expect(await this.votes.delegates(account1)).to.be.equal(account1);",
          "74:           expect(await this.votes.delegates(account2)).to.be.equal(account1);",
          "78:           await this.votes.delegate(account1, account2);",
          "79:           await this.votes.delegate(account2, account1);",
          "81:           expect(await this.votes.getVotes(account1)).to.be.bignumber.equal(amounts[account2]);",
          "82:           expect(await this.votes.getVotes(account2)).to.be.bignumber.equal(amounts[account1]);",
          "86:           const totalSupply = BNsum(...Object.values(amounts));",
          "87:           expect(await this.votes.getTotalSupply()).to.be.bignumber.equal(totalSupply);",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { bigint: time } = require('../../helpers/time');",
          "6: const { sum } = require('../../helpers/math');",
          "7: const { zip } = require('../../helpers/iterate');",
          "12:   blocknumber: '$VotesMock',",
          "13:   timestamp: '$VotesTimestampMock',",
          "16: const AMOUNTS = [ethers.parseEther('10000000'), 10n, 20n];",
          "18: describe('Votes', function () {",
          "20:     const fixture = async () => {",
          "21:       const accounts = await ethers.getSigners();",
          "23:       const amounts = Object.fromEntries(",
          "24:         zip(",
          "25:           accounts.slice(0, AMOUNTS.length).map(({ address }) => address),",
          "26:           AMOUNTS,",
          "27:         ),",
          "28:       );",
          "30:       const name = 'My Vote';",
          "31:       const version = '1';",
          "32:       const votes = await ethers.deployContract(artifact, [name, version]);",
          "34:       return { accounts, amounts, votes, name, version };",
          "35:     };",
          "39:         Object.assign(this, await loadFixture(fixture));",
          "42:       shouldBehaveLikeVotes(AMOUNTS, { mode, fungible: true });",
          "45:         expect(await this.votes.getTotalSupply()).to.equal(0n);",
          "51:           for (const [account, amount] of Object.entries(this.amounts)) {",
          "57:           const lastTxTimepoint = await time.clockFromReceipt[mode](this.txs.at(-1));",
          "59:           await expect(this.votes.getPastTotalSupply(lastTxTimepoint))",
          "60:             .to.be.revertedWithCustomError(this.votes, 'ERC5805FutureLookup')",
          "61:             .withArgs(lastTxTimepoint, clock);",
          "65:           expect(await this.votes.getVotes(this.accounts[0])).to.equal(0n);",
          "66:           expect(await this.votes.getVotes(this.accounts[1])).to.equal(0n);",
          "67:           expect(await this.votes.delegates(this.accounts[0])).to.equal(ethers.ZeroAddress);",
          "68:           expect(await this.votes.delegates(this.accounts[1])).to.equal(ethers.ZeroAddress);",
          "70:           await this.votes.delegate(this.accounts[0], ethers.Typed.address(this.accounts[0]));",
          "72:           expect(await this.votes.getVotes(this.accounts[0])).to.equal(this.amounts[this.accounts[0].address]);",
          "73:           expect(await this.votes.getVotes(this.accounts[1])).to.equal(0n);",
          "74:           expect(await this.votes.delegates(this.accounts[0])).to.equal(this.accounts[0].address);",
          "75:           expect(await this.votes.delegates(this.accounts[1])).to.equal(ethers.ZeroAddress);",
          "77:           await this.votes.delegate(this.accounts[1], ethers.Typed.address(this.accounts[0]));",
          "79:           expect(await this.votes.getVotes(this.accounts[0])).to.equal(",
          "80:             this.amounts[this.accounts[0].address] + this.amounts[this.accounts[1].address],",
          "81:           );",
          "82:           expect(await this.votes.getVotes(this.accounts[1])).to.equal(0n);",
          "83:           expect(await this.votes.delegates(this.accounts[0])).to.equal(this.accounts[0].address);",
          "84:           expect(await this.votes.delegates(this.accounts[1])).to.equal(this.accounts[0].address);",
          "88:           await this.votes.delegate(this.accounts[0], ethers.Typed.address(this.accounts[1].address));",
          "89:           await this.votes.delegate(this.accounts[1], ethers.Typed.address(this.accounts[0].address));",
          "91:           expect(await this.votes.getVotes(this.accounts[0])).to.equal(this.amounts[this.accounts[1].address]);",
          "92:           expect(await this.votes.getVotes(this.accounts[1])).to.equal(this.amounts[this.accounts[0].address]);",
          "96:           const totalSupply = sum(...Object.values(this.amounts));",
          "97:           expect(await this.votes.getTotalSupply()).to.equal(totalSupply);",
          "",
          "---------------"
        ],
        "test/helpers/governance.js||test/helpers/governance.js": [
          "File: test/helpers/governance.js -> test/helpers/governance.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: const { ProposalState } = require('./enums');",
          "19: const timelockSalt = (address, descriptionHash) =>",
          "22: class GovernorHelper {",
          "23:   constructor(governor, mode = 'blocknumber') {",
          "",
          "[Removed Lines]",
          "1: const { web3 } = require('hardhat');",
          "2: const { forward } = require('../helpers/time');",
          "5: function zip(...args) {",
          "6:   return Array(Math.max(...args.map(array => array.length)))",
          "7:     .fill()",
          "8:     .map((_, i) => args.map(array => array[i]));",
          "9: }",
          "11: function concatHex(...args) {",
          "12:   return web3.utils.bytesToHex([].concat(...args.map(h => web3.utils.hexToBytes(h || '0x'))));",
          "13: }",
          "15: function concatOpts(args, opts = null) {",
          "16:   return opts ? args.concat(opts) : args;",
          "17: }",
          "20:   '0x' + web3.utils.toBN(address).shln(96).xor(web3.utils.toBN(descriptionHash)).toString(16, 64);",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "2: const { forward } = require('./time');",
          "4: const { unique } = require('./iterate');",
          "7:   ethers.toBeHex((ethers.toBigInt(address) << 96n) ^ ethers.toBigInt(descriptionHash), 32);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25:     this.mode = mode;",
          "26:   }",
          "29:     return Promise.all([",
          "33:         delegation.token",
          "34:           .ownerOf(delegation.tokenId)",
          "35:           .then(owner =>",
          "37:           ),",
          "38:     ]);",
          "39:   }",
          "49:   }",
          "59:   }",
          "69:   }",
          "74:     switch (visibility) {",
          "75:       case 'external':",
          "83:       case 'internal':",
          "87:       default:",
          "88:         throw new Error(`unsupported visibility \"${visibility}\"`);",
          "89:     }",
          "90:   }",
          "132:     }",
          "135:   }",
          "141:   }",
          "147:   }",
          "153:   }",
          "172:     }",
          "209:   }",
          "237:     }",
          "247: }",
          "249: module.exports = {",
          "250:   GovernorHelper,",
          "252:   timelockSalt,",
          "253: };",
          "",
          "[Removed Lines]",
          "28:   delegate(delegation = {}, opts = null) {",
          "30:       delegation.token.delegate(delegation.to, { from: delegation.to }),",
          "31:       delegation.value && delegation.token.transfer(...concatOpts([delegation.to, delegation.value]), opts),",
          "32:       delegation.tokenId &&",
          "36:             delegation.token.transferFrom(...concatOpts([owner, delegation.to, delegation.tokenId], opts)),",
          "41:   propose(opts = null) {",
          "42:     const proposal = this.currentProposal;",
          "44:     return this.governor.methods[",
          "45:       proposal.useCompatibilityInterface",
          "46:         ? 'propose(address[],uint256[],string[],bytes[],string)'",
          "47:         : 'propose(address[],uint256[],bytes[],string)'",
          "48:     ](...concatOpts(proposal.fullProposal, opts));",
          "51:   queue(opts = null) {",
          "52:     const proposal = this.currentProposal;",
          "54:     return proposal.useCompatibilityInterface",
          "55:       ? this.governor.methods['queue(uint256)'](...concatOpts([proposal.id], opts))",
          "56:       : this.governor.methods['queue(address[],uint256[],bytes[],bytes32)'](",
          "57:           ...concatOpts(proposal.shortProposal, opts),",
          "58:         );",
          "61:   execute(opts = null) {",
          "62:     const proposal = this.currentProposal;",
          "64:     return proposal.useCompatibilityInterface",
          "65:       ? this.governor.methods['execute(uint256)'](...concatOpts([proposal.id], opts))",
          "66:       : this.governor.methods['execute(address[],uint256[],bytes[],bytes32)'](",
          "67:           ...concatOpts(proposal.shortProposal, opts),",
          "68:         );",
          "71:   cancel(visibility = 'external', opts = null) {",
          "72:     const proposal = this.currentProposal;",
          "76:         if (proposal.useCompatibilityInterface) {",
          "77:           return this.governor.methods['cancel(uint256)'](...concatOpts([proposal.id], opts));",
          "78:         } else {",
          "79:           return this.governor.methods['cancel(address[],uint256[],bytes[],bytes32)'](",
          "80:             ...concatOpts(proposal.shortProposal, opts),",
          "81:           );",
          "82:         }",
          "84:         return this.governor.methods['$_cancel(address[],uint256[],bytes[],bytes32)'](",
          "85:           ...concatOpts(proposal.shortProposal, opts),",
          "86:         );",
          "92:   vote(vote = {}, opts = null) {",
          "93:     const proposal = this.currentProposal;",
          "95:     return vote.signature",
          "96:       ? // if signature, and either params or reason \u2192",
          "97:         vote.params || vote.reason",
          "98:         ? this.sign(vote).then(signature =>",
          "99:             this.governor.castVoteWithReasonAndParamsBySig(",
          "100:               ...concatOpts(",
          "101:                 [proposal.id, vote.support, vote.voter, vote.reason || '', vote.params || '', signature],",
          "102:                 opts,",
          "103:               ),",
          "104:             ),",
          "105:           )",
          "106:         : this.sign(vote).then(signature =>",
          "107:             this.governor.castVoteBySig(...concatOpts([proposal.id, vote.support, vote.voter, signature], opts)),",
          "108:           )",
          "109:       : vote.params",
          "110:       ? // otherwise if params",
          "111:         this.governor.castVoteWithReasonAndParams(",
          "112:           ...concatOpts([proposal.id, vote.support, vote.reason || '', vote.params], opts),",
          "113:         )",
          "114:       : vote.reason",
          "115:       ? // otherwise if reason",
          "116:         this.governor.castVoteWithReason(...concatOpts([proposal.id, vote.support, vote.reason], opts))",
          "117:       : this.governor.castVote(...concatOpts([proposal.id, vote.support], opts));",
          "118:   }",
          "120:   sign(vote = {}) {",
          "121:     return vote.signature(this.governor, this.forgeMessage(vote));",
          "122:   }",
          "124:   forgeMessage(vote = {}) {",
          "125:     const proposal = this.currentProposal;",
          "127:     const message = { proposalId: proposal.id, support: vote.support, voter: vote.voter, nonce: vote.nonce };",
          "129:     if (vote.params || vote.reason) {",
          "130:       message.reason = vote.reason || '';",
          "131:       message.params = vote.params || '';",
          "134:     return message;",
          "137:   async waitForSnapshot(offset = 0) {",
          "138:     const proposal = this.currentProposal;",
          "139:     const timepoint = await this.governor.proposalSnapshot(proposal.id);",
          "140:     return forward[this.mode](timepoint.addn(offset));",
          "143:   async waitForDeadline(offset = 0) {",
          "144:     const proposal = this.currentProposal;",
          "145:     const timepoint = await this.governor.proposalDeadline(proposal.id);",
          "146:     return forward[this.mode](timepoint.addn(offset));",
          "149:   async waitForEta(offset = 0) {",
          "150:     const proposal = this.currentProposal;",
          "151:     const timestamp = await this.governor.proposalEta(proposal.id);",
          "152:     return forward.timestamp(timestamp.addn(offset));",
          "160:   setProposal(actions, description) {",
          "161:     let targets, values, signatures, data, useCompatibilityInterface;",
          "163:     if (Array.isArray(actions)) {",
          "164:       useCompatibilityInterface = actions.some(a => 'signature' in a);",
          "165:       targets = actions.map(a => a.target);",
          "166:       values = actions.map(a => a.value || '0');",
          "167:       signatures = actions.map(a => a.signature || '');",
          "168:       data = actions.map(a => a.data || '0x');",
          "169:     } else {",
          "170:       useCompatibilityInterface = Array.isArray(actions.signatures);",
          "171:       ({ targets, values, signatures = [], data } = actions);",
          "174:     const fulldata = zip(",
          "175:       signatures.map(s => s && web3.eth.abi.encodeFunctionSignature(s)),",
          "176:       data,",
          "177:     ).map(hexs => concatHex(...hexs));",
          "179:     const descriptionHash = web3.utils.keccak256(description);",
          "182:     const shortProposal = [targets, values, fulldata, descriptionHash];",
          "185:     const fullProposal = [targets, values, ...(useCompatibilityInterface ? [signatures] : []), data, description];",
          "188:     const id = web3.utils.toBN(",
          "189:       web3.utils.keccak256(",
          "190:         web3.eth.abi.encodeParameters(['address[]', 'uint256[]', 'bytes[]', 'bytes32'], shortProposal),",
          "191:       ),",
          "192:     );",
          "194:     this.currentProposal = {",
          "195:       id,",
          "196:       targets,",
          "197:       values,",
          "198:       signatures,",
          "199:       data,",
          "200:       fulldata,",
          "201:       description,",
          "202:       descriptionHash,",
          "203:       shortProposal,",
          "204:       fullProposal,",
          "205:       useCompatibilityInterface,",
          "206:     };",
          "208:     return this.currentProposal;",
          "210: }",
          "224: function proposalStatesToBitMap(proposalStates, options = {}) {",
          "225:   if (!Array.isArray(proposalStates)) {",
          "226:     proposalStates = [proposalStates];",
          "227:   }",
          "228:   const statesCount = Object.keys(ProposalState).length;",
          "229:   let result = 0;",
          "231:   const uniqueProposalStates = new Set(proposalStates.map(bn => bn.toNumber())); // Remove duplicates",
          "232:   for (const state of uniqueProposalStates) {",
          "233:     if (state < 0 || state >= statesCount) {",
          "234:       expect.fail(`ProposalState ${state} out of possible states (0...${statesCount}-1)`);",
          "235:     } else {",
          "236:       result |= 1 << state;",
          "238:   }",
          "240:   if (options.inverted) {",
          "241:     const mask = 2 ** statesCount - 1;",
          "242:     result = result ^ mask;",
          "243:   }",
          "245:   const hex = web3.utils.numberToHex(result);",
          "246:   return web3.utils.padLeft(hex, 64);",
          "251:   proposalStatesToBitMap,",
          "",
          "[Added Lines]",
          "15:   connect(account) {",
          "16:     this.governor = this.governor.connect(account);",
          "17:     return this;",
          "18:   }",
          "26:   setProposal(actions, description) {",
          "27:     if (Array.isArray(actions)) {",
          "28:       this.targets = actions.map(a => a.target);",
          "29:       this.values = actions.map(a => a.value || 0n);",
          "30:       this.data = actions.map(a => a.data || '0x');",
          "31:     } else {",
          "32:       ({ targets: this.targets, values: this.values, data: this.data } = actions);",
          "33:     }",
          "34:     this.description = description;",
          "35:     return this;",
          "36:   }",
          "38:   get id() {",
          "39:     return ethers.keccak256(",
          "40:       ethers.AbiCoder.defaultAbiCoder().encode(['address[]', 'uint256[]', 'bytes[]', 'bytes32'], this.shortProposal),",
          "41:     );",
          "42:   }",
          "45:   get signatures() {",
          "46:     return this.data.map(() => '');",
          "47:   }",
          "49:   get descriptionHash() {",
          "50:     return ethers.id(this.description);",
          "51:   }",
          "54:   get shortProposal() {",
          "55:     return [this.targets, this.values, this.data, this.descriptionHash];",
          "56:   }",
          "59:   get fullProposal() {",
          "60:     return [this.targets, this.values, this.data, this.description];",
          "61:   }",
          "63:   get currentProposal() {",
          "64:     return this;",
          "65:   }",
          "68:   delegate(delegation) {",
          "70:       delegation.token.connect(delegation.to).delegate(delegation.to),",
          "71:       delegation.value === undefined ||",
          "72:         delegation.token.connect(this.governor.runner).transfer(delegation.to, delegation.value),",
          "73:       delegation.tokenId === undefined ||",
          "77:             delegation.token.connect(this.governor.runner).transferFrom(owner, delegation.to, delegation.tokenId),",
          "82:   propose() {",
          "83:     return this.governor.propose(...this.fullProposal);",
          "86:   queue() {",
          "87:     return this.governor.queue(...this.shortProposal);",
          "90:   execute() {",
          "91:     return this.governor.execute(...this.shortProposal);",
          "94:   cancel(visibility = 'external') {",
          "97:         return this.governor.cancel(...this.shortProposal);",
          "100:         return this.governor.$_cancel(...this.shortProposal);",
          "107:   async vote(vote = {}) {",
          "108:     let method = 'castVote'; // default",
          "109:     let args = [this.id, vote.support]; // base",
          "111:     if (vote.signature) {",
          "112:       const sign = await vote.signature(this.governor, this.forgeMessage(vote));",
          "113:       if (vote.params || vote.reason) {",
          "114:         method = 'castVoteWithReasonAndParamsBySig';",
          "115:         args.push(vote.voter, vote.reason ?? '', vote.params ?? '0x', sign);",
          "116:       } else {",
          "117:         method = 'castVoteBySig';",
          "118:         args.push(vote.voter, sign);",
          "119:       }",
          "120:     } else if (vote.params) {",
          "121:       method = 'castVoteWithReasonAndParams';",
          "122:       args.push(vote.reason ?? '', vote.params);",
          "123:     } else if (vote.reason) {",
          "124:       method = 'castVoteWithReason';",
          "125:       args.push(vote.reason);",
          "128:     return await this.governor[method](...args);",
          "132:   async waitForSnapshot(offset = 0n) {",
          "133:     const timepoint = await this.governor.proposalSnapshot(this.id);",
          "134:     return forward[this.mode](timepoint + offset);",
          "137:   async waitForDeadline(offset = 0n) {",
          "138:     const timepoint = await this.governor.proposalDeadline(this.id);",
          "139:     return forward[this.mode](timepoint + offset);",
          "142:   async waitForEta(offset = 0n) {",
          "143:     const timestamp = await this.governor.proposalEta(this.id);",
          "144:     return forward.timestamp(timestamp + offset);",
          "148:   forgeMessage(vote = {}) {",
          "149:     const message = { proposalId: this.id, support: vote.support, voter: vote.voter, nonce: vote.nonce };",
          "151:     if (vote.params || vote.reason) {",
          "152:       message.reason = vote.reason ?? '';",
          "153:       message.params = vote.params ?? '0x';",
          "156:     return message;",
          "171:   static proposalStatesToBitMap(proposalStates, options = {}) {",
          "172:     if (!Array.isArray(proposalStates)) {",
          "173:       proposalStates = [proposalStates];",
          "174:     }",
          "175:     const statesCount = BigInt(Object.keys(ProposalState).length);",
          "176:     let result = 0n;",
          "178:     for (const state of unique(...proposalStates)) {",
          "179:       if (state < 0n || state >= statesCount) {",
          "180:         expect.fail(`ProposalState ${state} out of possible states (0...${statesCount}-1)`);",
          "181:       } else {",
          "182:         result |= 1n << state;",
          "183:       }",
          "186:     if (options.inverted) {",
          "187:       const mask = 2n ** statesCount - 1n;",
          "188:       result = result ^ mask;",
          "189:     }",
          "191:     return ethers.toBeHex(result, 32);",
          "192:   }",
          "",
          "---------------"
        ],
        "test/helpers/iterate.js||test/helpers/iterate.js": [
          "File: test/helpers/iterate.js -> test/helpers/iterate.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: const product = (...arrays) => arrays.reduce((a, b) => a.flatMap(ai => b.map(bi => [...ai, bi])), [[]]);",
          "7: module.exports = {",
          "8:   mapValues,",
          "9:   product,",
          "10: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: const unique = (...array) => array.filter((obj, i) => array.indexOf(obj) === i);",
          "7: const zip = (...args) =>",
          "8:   Array(Math.max(...args.map(array => array.length)))",
          "9:     .fill()",
          "10:     .map((_, i) => args.map(array => array[i]));",
          "15:   unique,",
          "16:   zip,",
          "",
          "---------------"
        ],
        "test/helpers/time.js||test/helpers/time.js": [
          "File: test/helpers/time.js -> test/helpers/time.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: const { time, mineUpTo } = require('@nomicfoundation/hardhat-network-helpers');",
          "2: const { mapValues } = require('./iterate');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8:   },",
          "9:   clockFromReceipt: {",
          "10:     blocknumber: receipt => Promise.resolve(receipt.blockNumber),",
          "14:   },",
          "15:   forward: {",
          "16:     blocknumber: mineUpTo,",
          "",
          "[Removed Lines]",
          "11:     timestamp: receipt => web3.eth.getBlock(receipt.blockNumber).then(block => block.timestamp),",
          "",
          "[Added Lines]",
          "12:     timestamp: receipt => ethers.provider.getBlock(receipt.blockNumber).then(block => block.timestamp),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "23: module.exports.bigint = {",
          "26:   forward: module.exports.forward,",
          "28: };",
          "",
          "[Removed Lines]",
          "24:   clock: mapValues(module.exports.clock, fn => () => fn().then(BigInt)),",
          "25:   clockFromReceipt: mapValues(module.exports.clockFromReceipt, fn => receipt => fn(receipt).then(BigInt)),",
          "27:   duration: mapValues(module.exports.duration, fn => n => BigInt(fn(n))),",
          "",
          "[Added Lines]",
          "23:   clock: mapValues(module.exports.clock, fn => () => fn().then(ethers.toBigInt)),",
          "24:   clockFromReceipt: mapValues(module.exports.clockFromReceipt, fn => receipt => fn(receipt).then(ethers.toBigInt)),",
          "26:   duration: mapValues(module.exports.duration, fn => n => ethers.toBigInt(fn(ethers.toNumber(n)))),",
          "",
          "---------------"
        ],
        "test/helpers/txpool.js||test/helpers/txpool.js": [
          "File: test/helpers/txpool.js -> test/helpers/txpool.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: const { network } = require('hardhat');",
          "10: async function batchInBlock(txs) {",
          "11:   try {",
          "13:     await network.provider.send('evm_setAutomine', [false]);",
          "28:     return receipts;",
          "29:   } finally {",
          "",
          "[Removed Lines]",
          "2: const { promisify } = require('util');",
          "4: const queue = promisify(setImmediate);",
          "6: async function countPendingTransactions() {",
          "7:   return parseInt(await network.provider.send('eth_getBlockTransactionCountByNumber', ['pending']));",
          "8: }",
          "15:     const promises = txs.map(fn => fn());",
          "17:     while (txs.length > (await countPendingTransactions())) {",
          "18:       await queue();",
          "19:     }",
          "21:     await network.provider.send('evm_mine');",
          "23:     const receipts = await Promise.all(promises);",
          "25:     const minedBlocks = new Set(receipts.map(({ receipt }) => receipt.blockNumber));",
          "26:     expect(minedBlocks.size).to.equal(1);",
          "",
          "[Added Lines]",
          "2: const { mine } = require('@nomicfoundation/hardhat-network-helpers');",
          "3: const { unique } = require('./iterate');",
          "10:     const responses = await Promise.all(txs.map(fn => fn()));",
          "12:     await mine();",
          "14:     const receipts = await Promise.all(responses.map(response => response.wait()));",
          "16:     expect(unique(receipts.map(receipt => receipt.blockNumber))).to.have.lengthOf(1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: }",
          "35: module.exports = {",
          "37:   batchInBlock,",
          "38: };",
          "",
          "[Removed Lines]",
          "36:   countPendingTransactions,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Permit.test.js||test/token/ERC20/extensions/ERC20Permit.test.js": [
          "File: test/token/ERC20/extensions/ERC20Permit.test.js -> test/token/ERC20/extensions/ERC20Permit.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: const { loadFixture } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { getDomain, domainSeparator, Permit } = require('../../../helpers/eip712');",
          "10: const name = 'My Token';",
          "11: const symbol = 'MTKN';",
          "",
          "[Removed Lines]",
          "6: const {",
          "7:   bigint: { clock, duration },",
          "8: } = require('../../../helpers/time');",
          "",
          "[Added Lines]",
          "6: const { bigint: time } = require('../../../helpers/time');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:     });",
          "99:     it('rejects expired permit', async function () {",
          "102:       const { v, r, s } = await this.buildData(this.token, deadline)",
          "103:         .then(({ domain, types, message }) => this.owner.signTypedData(domain, types, message))",
          "",
          "[Removed Lines]",
          "100:       const deadline = (await clock.timestamp()) - duration.weeks(1);",
          "",
          "[Added Lines]",
          "98:       const deadline = (await time.clock.timestamp()) - time.duration.weeks(1);",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Votes.test.js||test/token/ERC20/extensions/ERC20Votes.test.js": [
          "File: test/token/ERC20/extensions/ERC20Votes.test.js -> test/token/ERC20/extensions/ERC20Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: const { expect } = require('chai');",
          "7: const { shouldBehaveLikeVotes } = require('../../../governance/utils/Votes.behavior');",
          "31:     describe(`vote with ${mode}`, function () {",
          "32:       beforeEach(async function () {",
          "34:         this.votes = this.token;",
          "35:       });",
          "40:       it('initial nonce is 0', async function () {",
          "42:       });",
          "44:       it('minting restriction', async function () {",
          "50:       });",
          "52:       it('recent checkpoints', async function () {",
          "54:         for (let i = 0; i < 6; i++) {",
          "56:         }",
          "63:       });",
          "65:       describe('set delegation', function () {",
          "66:         describe('call', function () {",
          "67:           it('delegation with balance', async function () {",
          "91:           });",
          "93:           it('delegation without balance', async function () {",
          "105:           });",
          "106:         });",
          "108:         describe('with signature', function () {",
          "121:           beforeEach(async function () {",
          "123:           });",
          "125:           it('accept signed delegation', async function () {",
          "154:           });",
          "156:           it('rejects reused signature', async function () {",
          "170:           });",
          "172:           it('rejects bad delegatee', async function () {",
          "184:           });",
          "186:           it('rejects bad nonce', async function () {",
          "206:             );",
          "207:           });",
          "209:           it('rejects expired permit', async function () {",
          "222:           });",
          "223:         });",
          "224:       });",
          "226:       describe('change delegation', function () {",
          "227:         beforeEach(async function () {",
          "230:         });",
          "232:         it('call', async function () {",
          "263:         });",
          "264:       });",
          "266:       describe('transfers', function () {",
          "267:         beforeEach(async function () {",
          "269:         });",
          "271:         it('no delegation', async function () {",
          "278:         });",
          "280:         it('sender delegation', async function () {",
          "300:         });",
          "302:         it('receiver delegation', async function () {",
          "318:         });",
          "320:         it('full delegation', async function () {",
          "342:         });",
          "344:         afterEach(async function () {",
          "353:         });",
          "354:       });",
          "357:       describe('Compound test suite', function () {",
          "358:         beforeEach(async function () {",
          "360:         });",
          "362:         describe('balanceOf', function () {",
          "363:           it('grants to initial account', async function () {",
          "365:           });",
          "366:         });",
          "368:         describe('numCheckpoints', function () {",
          "369:           it('returns the number of checkpoints for a delegate', async function () {",
          "399:           });",
          "401:           it('does not add more than one checkpoint in a block', async function () {",
          "405:             const [t1, t2, t3] = await batchInBlock([",
          "409:             ]);",
          "422:           });",
          "423:         });",
          "425:         describe('getPastVotes', function () {",
          "426:           it('reverts if block number >= current block', async function () {",
          "427:             const clock = await this.token.clock();",
          "429:           });",
          "431:           it('returns 0 if there are no checkpoints', async function () {",
          "433:           });",
          "435:           it('returns the latest block if >= last checkpoint block', async function () {",
          "447:           });",
          "449:           it('returns zero if < first checkpoint block', async function () {",
          "460:           });",
          "462:           it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "506:           });",
          "507:         });",
          "508:       });",
          "510:       describe('getPastTotalSupply', function () {",
          "511:         beforeEach(async function () {",
          "513:         });",
          "515:         it('reverts if block number >= current block', async function () {",
          "516:           const clock = await this.token.clock();",
          "518:         });",
          "520:         it('returns 0 if there are no checkpoints', async function () {",
          "522:         });",
          "524:         it('returns the latest block if >= last checkpoint block', async function () {",
          "532:         });",
          "534:         it('returns zero if < first checkpoint block', async function () {",
          "545:         });",
          "547:         it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "583:         });",
          "584:       });",
          "585:     });",
          "",
          "[Removed Lines]",
          "3: const { BN, constants, expectEvent, time } = require('@openzeppelin/test-helpers');",
          "5: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "8: const { fromRpcSig } = require('ethereumjs-util');",
          "9: const ethSigUtil = require('eth-sig-util');",
          "10: const Wallet = require('ethereumjs-wallet').default;",
          "12: const { batchInBlock } = require('../../../helpers/txpool');",
          "13: const { getDomain, domainType, Delegation } = require('../../../helpers/eip712');",
          "14: const { clock, clockFromReceipt } = require('../../../helpers/time');",
          "15: const { expectRevertCustomError } = require('../../../helpers/customError');",
          "17: const MODES = {",
          "18:   blocknumber: artifacts.require('$ERC20Votes'),",
          "19:   timestamp: artifacts.require('$ERC20VotesTimestampMock'),",
          "20: };",
          "22: contract('ERC20Votes', function (accounts) {",
          "23:   const [holder, recipient, holderDelegatee, other1, other2] = accounts;",
          "25:   const name = 'My Token';",
          "26:   const symbol = 'MTKN';",
          "27:   const version = '1';",
          "28:   const supply = new BN('10000000000000000000000000');",
          "30:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "33:         this.token = await artifact.new(name, symbol, name, version);",
          "38:       shouldBehaveLikeVotes(accounts, [1, 17, 42], { mode, fungible: true });",
          "41:         expect(await this.token.nonces(holder)).to.be.bignumber.equal('0');",
          "45:         const value = web3.utils.toBN(1).shln(208);",
          "46:         await expectRevertCustomError(this.token.$_mint(holder, value), 'ERC20ExceededSafeSupply', [",
          "47:           value,",
          "48:           value.subn(1),",
          "49:         ]);",
          "53:         await this.token.delegate(holder, { from: holder });",
          "55:           await this.token.$_mint(holder, 1);",
          "57:         const timepoint = await clock[mode]();",
          "58:         expect(await this.token.numCheckpoints(holder)).to.be.bignumber.equal('6');",
          "60:         expect(await this.token.getPastVotes(holder, timepoint - 1)).to.be.bignumber.equal('5');",
          "62:         expect(await this.token.getPastVotes(holder, timepoint - 6)).to.be.bignumber.equal('0');",
          "68:             await this.token.$_mint(holder, supply);",
          "69:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "71:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "72:             const timepoint = await clockFromReceipt[mode](receipt);",
          "74:             expectEvent(receipt, 'DelegateChanged', {",
          "75:               delegator: holder,",
          "76:               fromDelegate: ZERO_ADDRESS,",
          "77:               toDelegate: holder,",
          "78:             });",
          "79:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "80:               delegate: holder,",
          "81:               previousVotes: '0',",
          "82:               newVotes: supply,",
          "83:             });",
          "85:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "87:             expect(await this.token.getVotes(holder)).to.be.bignumber.equal(supply);",
          "88:             expect(await this.token.getPastVotes(holder, timepoint - 1)).to.be.bignumber.equal('0');",
          "89:             await time.advanceBlock();",
          "90:             expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal(supply);",
          "94:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "96:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "97:             expectEvent(receipt, 'DelegateChanged', {",
          "98:               delegator: holder,",
          "99:               fromDelegate: ZERO_ADDRESS,",
          "100:               toDelegate: holder,",
          "101:             });",
          "102:             expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "104:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "109:           const delegator = Wallet.generate();",
          "110:           const delegatorAddress = web3.utils.toChecksumAddress(delegator.getAddressString());",
          "111:           const nonce = 0;",
          "113:           const buildData = (contract, message) =>",
          "114:             getDomain(contract).then(domain => ({",
          "115:               primaryType: 'Delegation',",
          "116:               types: { EIP712Domain: domainType(domain), Delegation },",
          "117:               domain,",
          "118:               message,",
          "119:             }));",
          "122:             await this.token.$_mint(delegatorAddress, supply);",
          "126:             const { v, r, s } = await buildData(this.token, {",
          "127:               delegatee: delegatorAddress,",
          "128:               nonce,",
          "129:               expiry: MAX_UINT256,",
          "130:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "132:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(ZERO_ADDRESS);",
          "134:             const { receipt } = await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "135:             const timepoint = await clockFromReceipt[mode](receipt);",
          "137:             expectEvent(receipt, 'DelegateChanged', {",
          "138:               delegator: delegatorAddress,",
          "139:               fromDelegate: ZERO_ADDRESS,",
          "140:               toDelegate: delegatorAddress,",
          "141:             });",
          "142:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "143:               delegate: delegatorAddress,",
          "144:               previousVotes: '0',",
          "145:               newVotes: supply,",
          "146:             });",
          "148:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(delegatorAddress);",
          "150:             expect(await this.token.getVotes(delegatorAddress)).to.be.bignumber.equal(supply);",
          "151:             expect(await this.token.getPastVotes(delegatorAddress, timepoint - 1)).to.be.bignumber.equal('0');",
          "152:             await time.advanceBlock();",
          "153:             expect(await this.token.getPastVotes(delegatorAddress, timepoint)).to.be.bignumber.equal(supply);",
          "157:             const { v, r, s } = await buildData(this.token, {",
          "158:               delegatee: delegatorAddress,",
          "159:               nonce,",
          "160:               expiry: MAX_UINT256,",
          "161:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "163:             await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "165:             await expectRevertCustomError(",
          "166:               this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s),",
          "167:               'InvalidAccountNonce',",
          "168:               [delegatorAddress, nonce + 1],",
          "169:             );",
          "173:             const { v, r, s } = await buildData(this.token, {",
          "174:               delegatee: delegatorAddress,",
          "175:               nonce,",
          "176:               expiry: MAX_UINT256,",
          "177:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "179:             const receipt = await this.token.delegateBySig(holderDelegatee, nonce, MAX_UINT256, v, r, s);",
          "180:             const { args } = receipt.logs.find(({ event }) => event == 'DelegateChanged');",
          "181:             expect(args.delegator).to.not.be.equal(delegatorAddress);",
          "182:             expect(args.fromDelegate).to.be.equal(ZERO_ADDRESS);",
          "183:             expect(args.toDelegate).to.be.equal(holderDelegatee);",
          "187:             const sig = await buildData(this.token, {",
          "188:               delegatee: delegatorAddress,",
          "189:               nonce,",
          "190:               expiry: MAX_UINT256,",
          "191:             }).then(data => ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data }));",
          "192:             const { r, s, v } = fromRpcSig(sig);",
          "194:             const domain = await getDomain(this.token);",
          "195:             const typedMessage = {",
          "196:               primaryType: 'Delegation',",
          "197:               types: { EIP712Domain: domainType(domain), Delegation },",
          "198:               domain,",
          "199:               message: { delegatee: delegatorAddress, nonce: nonce + 1, expiry: MAX_UINT256 },",
          "200:             };",
          "202:             await expectRevertCustomError(",
          "203:               this.token.delegateBySig(delegatorAddress, nonce + 1, MAX_UINT256, v, r, s),",
          "204:               'InvalidAccountNonce',",
          "205:               [ethSigUtil.recoverTypedSignature({ data: typedMessage, sig }), nonce],",
          "210:             const expiry = (await time.latest()) - time.duration.weeks(1);",
          "211:             const { v, r, s } = await buildData(this.token, {",
          "212:               delegatee: delegatorAddress,",
          "213:               nonce,",
          "214:               expiry,",
          "215:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "217:             await expectRevertCustomError(",
          "218:               this.token.delegateBySig(delegatorAddress, nonce, expiry, v, r, s),",
          "219:               'VotesExpiredSignature',",
          "220:               [expiry],",
          "221:             );",
          "228:           await this.token.$_mint(holder, supply);",
          "229:           await this.token.delegate(holder, { from: holder });",
          "233:           expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "235:           const { receipt } = await this.token.delegate(holderDelegatee, { from: holder });",
          "236:           const timepoint = await clockFromReceipt[mode](receipt);",
          "238:           expectEvent(receipt, 'DelegateChanged', {",
          "239:             delegator: holder,",
          "240:             fromDelegate: holder,",
          "241:             toDelegate: holderDelegatee,",
          "242:           });",
          "243:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "244:             delegate: holder,",
          "245:             previousVotes: supply,",
          "246:             newVotes: '0',",
          "247:           });",
          "248:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "249:             delegate: holderDelegatee,",
          "250:             previousVotes: '0',",
          "251:             newVotes: supply,",
          "252:           });",
          "254:           expect(await this.token.delegates(holder)).to.be.equal(holderDelegatee);",
          "256:           expect(await this.token.getVotes(holder)).to.be.bignumber.equal('0');",
          "257:           expect(await this.token.getVotes(holderDelegatee)).to.be.bignumber.equal(supply);",
          "258:           expect(await this.token.getPastVotes(holder, timepoint - 1)).to.be.bignumber.equal(supply);",
          "259:           expect(await this.token.getPastVotes(holderDelegatee, timepoint - 1)).to.be.bignumber.equal('0');",
          "260:           await time.advanceBlock();",
          "261:           expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal('0');",
          "262:           expect(await this.token.getPastVotes(holderDelegatee, timepoint)).to.be.bignumber.equal(supply);",
          "268:           await this.token.$_mint(holder, supply);",
          "272:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "273:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "274:           expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "276:           this.holderVotes = '0';",
          "277:           this.recipientVotes = '0';",
          "281:           await this.token.delegate(holder, { from: holder });",
          "283:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "284:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "285:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "286:             delegate: holder,",
          "287:             previousVotes: supply,",
          "288:             newVotes: supply.subn(1),",
          "289:           });",
          "291:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "292:           expect(",
          "293:             receipt.logs",
          "294:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "295:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "296:           ).to.be.equal(true);",
          "298:           this.holderVotes = supply.subn(1);",
          "299:           this.recipientVotes = '0';",
          "303:           await this.token.delegate(recipient, { from: recipient });",
          "305:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "306:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "307:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousVotes: '0', newVotes: '1' });",
          "309:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "310:           expect(",
          "311:             receipt.logs",
          "312:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "313:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "314:           ).to.be.equal(true);",
          "316:           this.holderVotes = '0';",
          "317:           this.recipientVotes = '1';",
          "321:           await this.token.delegate(holder, { from: holder });",
          "322:           await this.token.delegate(recipient, { from: recipient });",
          "324:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "325:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "326:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "327:             delegate: holder,",
          "328:             previousVotes: supply,",
          "329:             newVotes: supply.subn(1),",
          "330:           });",
          "331:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousVotes: '0', newVotes: '1' });",
          "333:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "334:           expect(",
          "335:             receipt.logs",
          "336:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "337:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "338:           ).to.be.equal(true);",
          "340:           this.holderVotes = supply.subn(1);",
          "341:           this.recipientVotes = '1';",
          "345:           expect(await this.token.getVotes(holder)).to.be.bignumber.equal(this.holderVotes);",
          "346:           expect(await this.token.getVotes(recipient)).to.be.bignumber.equal(this.recipientVotes);",
          "349:           const timepoint = await clock[mode]();",
          "350:           await time.advanceBlock();",
          "351:           expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal(this.holderVotes);",
          "352:           expect(await this.token.getPastVotes(recipient, timepoint)).to.be.bignumber.equal(this.recipientVotes);",
          "359:           await this.token.$_mint(holder, supply);",
          "364:             expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('10000000000000000000000000');",
          "370:             await this.token.transfer(recipient, '100', { from: holder }); //give an account a few tokens for readability",
          "371:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "373:             const t1 = await this.token.delegate(other1, { from: recipient });",
          "374:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "375:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "377:             const t2 = await this.token.transfer(other2, 10, { from: recipient });",
          "378:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "379:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "381:             const t3 = await this.token.transfer(other2, 10, { from: recipient });",
          "382:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "383:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('3');",
          "385:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "386:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "387:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('4');",
          "389:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '100']);",
          "390:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t2.timepoint.toString(), '90']);",
          "391:             expect(await this.token.checkpoints(other1, 2)).to.be.deep.equal([t3.timepoint.toString(), '80']);",
          "392:             expect(await this.token.checkpoints(other1, 3)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "394:             await time.advanceBlock();",
          "395:             expect(await this.token.getPastVotes(other1, t1.timepoint)).to.be.bignumber.equal('100');",
          "396:             expect(await this.token.getPastVotes(other1, t2.timepoint)).to.be.bignumber.equal('90');",
          "397:             expect(await this.token.getPastVotes(other1, t3.timepoint)).to.be.bignumber.equal('80');",
          "398:             expect(await this.token.getPastVotes(other1, t4.timepoint)).to.be.bignumber.equal('100');",
          "402:             await this.token.transfer(recipient, '100', { from: holder });",
          "403:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "406:               () => this.token.delegate(other1, { from: recipient, gas: 200000 }),",
          "407:               () => this.token.transfer(other2, 10, { from: recipient, gas: 200000 }),",
          "408:               () => this.token.transfer(other2, 10, { from: recipient, gas: 200000 }),",
          "410:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "411:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "412:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "414:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "415:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '80']);",
          "417:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "418:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "420:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "421:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "428:             await expectRevertCustomError(this.token.getPastVotes(other1, 5e10), 'ERC5805FutureLookup', [5e10, clock]);",
          "432:             expect(await this.token.getPastVotes(other1, 0)).to.be.bignumber.equal('0');",
          "436:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "437:             const timepoint = await clockFromReceipt[mode](receipt);",
          "438:             await time.advanceBlock();",
          "439:             await time.advanceBlock();",
          "441:             expect(await this.token.getPastVotes(other1, timepoint)).to.be.bignumber.equal(",
          "442:               '10000000000000000000000000',",
          "443:             );",
          "444:             expect(await this.token.getPastVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "445:               '10000000000000000000000000',",
          "446:             );",
          "450:             await time.advanceBlock();",
          "451:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "452:             const timepoint = await clockFromReceipt[mode](receipt);",
          "453:             await time.advanceBlock();",
          "454:             await time.advanceBlock();",
          "456:             expect(await this.token.getPastVotes(other1, timepoint - 1)).to.be.bignumber.equal('0');",
          "457:             expect(await this.token.getPastVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "458:               '10000000000000000000000000',",
          "459:             );",
          "463:             const t1 = await this.token.delegate(other1, { from: holder });",
          "464:             await time.advanceBlock();",
          "465:             await time.advanceBlock();",
          "466:             const t2 = await this.token.transfer(other2, 10, { from: holder });",
          "467:             await time.advanceBlock();",
          "468:             await time.advanceBlock();",
          "469:             const t3 = await this.token.transfer(other2, 10, { from: holder });",
          "470:             await time.advanceBlock();",
          "471:             await time.advanceBlock();",
          "472:             const t4 = await this.token.transfer(holder, 20, { from: other2 });",
          "473:             await time.advanceBlock();",
          "474:             await time.advanceBlock();",
          "476:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "477:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "478:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "479:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "481:             expect(await this.token.getPastVotes(other1, t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "482:             expect(await this.token.getPastVotes(other1, t1.timepoint)).to.be.bignumber.equal(",
          "483:               '10000000000000000000000000',",
          "484:             );",
          "485:             expect(await this.token.getPastVotes(other1, t1.timepoint + 1)).to.be.bignumber.equal(",
          "486:               '10000000000000000000000000',",
          "487:             );",
          "488:             expect(await this.token.getPastVotes(other1, t2.timepoint)).to.be.bignumber.equal(",
          "489:               '9999999999999999999999990',",
          "490:             );",
          "491:             expect(await this.token.getPastVotes(other1, t2.timepoint + 1)).to.be.bignumber.equal(",
          "492:               '9999999999999999999999990',",
          "493:             );",
          "494:             expect(await this.token.getPastVotes(other1, t3.timepoint)).to.be.bignumber.equal(",
          "495:               '9999999999999999999999980',",
          "496:             );",
          "497:             expect(await this.token.getPastVotes(other1, t3.timepoint + 1)).to.be.bignumber.equal(",
          "498:               '9999999999999999999999980',",
          "499:             );",
          "500:             expect(await this.token.getPastVotes(other1, t4.timepoint)).to.be.bignumber.equal(",
          "501:               '10000000000000000000000000',",
          "502:             );",
          "503:             expect(await this.token.getPastVotes(other1, t4.timepoint + 1)).to.be.bignumber.equal(",
          "504:               '10000000000000000000000000',",
          "505:             );",
          "512:           await this.token.delegate(holder, { from: holder });",
          "517:           await expectRevertCustomError(this.token.getPastTotalSupply(5e10), 'ERC5805FutureLookup', [5e10, clock]);",
          "521:           expect(await this.token.getPastTotalSupply(0)).to.be.bignumber.equal('0');",
          "525:           const { receipt } = await this.token.$_mint(holder, supply);",
          "526:           const timepoint = await clockFromReceipt[mode](receipt);",
          "527:           await time.advanceBlock();",
          "528:           await time.advanceBlock();",
          "530:           expect(await this.token.getPastTotalSupply(timepoint)).to.be.bignumber.equal(supply);",
          "531:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(supply);",
          "535:           await time.advanceBlock();",
          "536:           const { receipt } = await this.token.$_mint(holder, supply);",
          "537:           const timepoint = await clockFromReceipt[mode](receipt);",
          "538:           await time.advanceBlock();",
          "539:           await time.advanceBlock();",
          "541:           expect(await this.token.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('0');",
          "542:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(",
          "543:             '10000000000000000000000000',",
          "544:           );",
          "548:           const t1 = await this.token.$_mint(holder, supply);",
          "549:           await time.advanceBlock();",
          "550:           await time.advanceBlock();",
          "551:           const t2 = await this.token.$_burn(holder, 10);",
          "552:           await time.advanceBlock();",
          "553:           await time.advanceBlock();",
          "554:           const t3 = await this.token.$_burn(holder, 10);",
          "555:           await time.advanceBlock();",
          "556:           await time.advanceBlock();",
          "557:           const t4 = await this.token.$_mint(holder, 20);",
          "558:           await time.advanceBlock();",
          "559:           await time.advanceBlock();",
          "561:           t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "562:           t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "563:           t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "564:           t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "566:           expect(await this.token.getPastTotalSupply(t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "567:           expect(await this.token.getPastTotalSupply(t1.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "568:           expect(await this.token.getPastTotalSupply(t1.timepoint + 1)).to.be.bignumber.equal(",
          "569:             '10000000000000000000000000',",
          "570:           );",
          "571:           expect(await this.token.getPastTotalSupply(t2.timepoint)).to.be.bignumber.equal('9999999999999999999999990');",
          "572:           expect(await this.token.getPastTotalSupply(t2.timepoint + 1)).to.be.bignumber.equal(",
          "573:             '9999999999999999999999990',",
          "574:           );",
          "575:           expect(await this.token.getPastTotalSupply(t3.timepoint)).to.be.bignumber.equal('9999999999999999999999980');",
          "576:           expect(await this.token.getPastTotalSupply(t3.timepoint + 1)).to.be.bignumber.equal(",
          "577:             '9999999999999999999999980',",
          "578:           );",
          "579:           expect(await this.token.getPastTotalSupply(t4.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "580:           expect(await this.token.getPastTotalSupply(t4.timepoint + 1)).to.be.bignumber.equal(",
          "581:             '10000000000000000000000000',",
          "582:           );",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture, mine } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { getDomain, Delegation } = require('../../../helpers/eip712');",
          "6: const { batchInBlock } = require('../../../helpers/txpool');",
          "7: const { bigint: time } = require('../../../helpers/time');",
          "11: const TOKENS = [",
          "12:   { Token: '$ERC20Votes', mode: 'blocknumber' },",
          "13:   { Token: '$ERC20VotesTimestampMock', mode: 'timestamp' },",
          "14: ];",
          "16: const name = 'My Token';",
          "17: const symbol = 'MTKN';",
          "18: const version = '1';",
          "19: const supply = ethers.parseEther('10000000');",
          "21: describe('ERC20Votes', function () {",
          "22:   for (const { Token, mode } of TOKENS) {",
          "23:     const fixture = async () => {",
          "25:       const accounts = await ethers.getSigners();",
          "26:       const [holder, recipient, delegatee, other1, other2] = accounts;",
          "28:       const token = await ethers.deployContract(Token, [name, symbol, name, version]);",
          "29:       const domain = await getDomain(token);",
          "31:       return { accounts, holder, recipient, delegatee, other1, other2, token, domain };",
          "32:     };",
          "36:         Object.assign(this, await loadFixture(fixture));",
          "41:       shouldBehaveLikeVotes([1, 17, 42], { mode, fungible: true });",
          "44:         expect(await this.token.nonces(this.holder)).to.equal(0n);",
          "48:         const value = 2n ** 208n;",
          "49:         await expect(this.token.$_mint(this.holder, value))",
          "50:           .to.be.revertedWithCustomError(this.token, 'ERC20ExceededSafeSupply')",
          "51:           .withArgs(value, value - 1n);",
          "55:         await this.token.connect(this.holder).delegate(this.holder);",
          "57:           await this.token.$_mint(this.holder, 1n);",
          "59:         const timepoint = await time.clock[mode]();",
          "60:         expect(await this.token.numCheckpoints(this.holder)).to.equal(6n);",
          "62:         expect(await this.token.getPastVotes(this.holder, timepoint - 1n)).to.equal(5n);",
          "64:         expect(await this.token.getPastVotes(this.holder, timepoint - 6n)).to.equal(0n);",
          "70:             await this.token.$_mint(this.holder, supply);",
          "71:             expect(await this.token.delegates(this.holder)).to.equal(ethers.ZeroAddress);",
          "73:             const tx = await this.token.connect(this.holder).delegate(this.holder);",
          "74:             const timepoint = await time.clockFromReceipt[mode](tx);",
          "76:             await expect(tx)",
          "77:               .to.emit(this.token, 'DelegateChanged')",
          "78:               .withArgs(this.holder.address, ethers.ZeroAddress, this.holder.address)",
          "79:               .to.emit(this.token, 'DelegateVotesChanged')",
          "80:               .withArgs(this.holder.address, 0n, supply);",
          "82:             expect(await this.token.delegates(this.holder)).to.equal(this.holder.address);",
          "83:             expect(await this.token.getVotes(this.holder)).to.equal(supply);",
          "84:             expect(await this.token.getPastVotes(this.holder, timepoint - 1n)).to.equal(0n);",
          "85:             await mine();",
          "86:             expect(await this.token.getPastVotes(this.holder, timepoint)).to.equal(supply);",
          "90:             expect(await this.token.delegates(this.holder)).to.equal(ethers.ZeroAddress);",
          "92:             await expect(this.token.connect(this.holder).delegate(this.holder))",
          "93:               .to.emit(this.token, 'DelegateChanged')",
          "94:               .withArgs(this.holder.address, ethers.ZeroAddress, this.holder.address)",
          "95:               .to.not.emit(this.token, 'DelegateVotesChanged');",
          "97:             expect(await this.token.delegates(this.holder)).to.equal(this.holder.address);",
          "102:           const nonce = 0n;",
          "105:             await this.token.$_mint(this.holder, supply);",
          "109:             const { r, s, v } = await this.holder",
          "110:               .signTypedData(",
          "111:                 this.domain,",
          "112:                 { Delegation },",
          "113:                 {",
          "114:                   delegatee: this.holder.address,",
          "115:                   nonce,",
          "116:                   expiry: ethers.MaxUint256,",
          "117:                 },",
          "118:               )",
          "119:               .then(ethers.Signature.from);",
          "121:             expect(await this.token.delegates(this.holder)).to.equal(ethers.ZeroAddress);",
          "123:             const tx = await this.token.delegateBySig(this.holder, nonce, ethers.MaxUint256, v, r, s);",
          "124:             const timepoint = await time.clockFromReceipt[mode](tx);",
          "126:             await expect(tx)",
          "127:               .to.emit(this.token, 'DelegateChanged')",
          "128:               .withArgs(this.holder.address, ethers.ZeroAddress, this.holder.address)",
          "129:               .to.emit(this.token, 'DelegateVotesChanged')",
          "130:               .withArgs(this.holder.address, 0n, supply);",
          "132:             expect(await this.token.delegates(this.holder)).to.equal(this.holder.address);",
          "134:             expect(await this.token.getVotes(this.holder)).to.equal(supply);",
          "135:             expect(await this.token.getPastVotes(this.holder, timepoint - 1n)).to.equal(0n);",
          "136:             await mine();",
          "137:             expect(await this.token.getPastVotes(this.holder, timepoint)).to.equal(supply);",
          "141:             const { r, s, v } = await this.holder",
          "142:               .signTypedData(",
          "143:                 this.domain,",
          "144:                 { Delegation },",
          "145:                 {",
          "146:                   delegatee: this.holder.address,",
          "147:                   nonce,",
          "148:                   expiry: ethers.MaxUint256,",
          "149:                 },",
          "150:               )",
          "151:               .then(ethers.Signature.from);",
          "153:             await this.token.delegateBySig(this.holder, nonce, ethers.MaxUint256, v, r, s);",
          "155:             await expect(this.token.delegateBySig(this.holder, nonce, ethers.MaxUint256, v, r, s))",
          "156:               .to.be.revertedWithCustomError(this.token, 'InvalidAccountNonce')",
          "157:               .withArgs(this.holder.address, nonce + 1n);",
          "161:             const { r, s, v } = await this.holder",
          "162:               .signTypedData(",
          "163:                 this.domain,",
          "164:                 { Delegation },",
          "165:                 {",
          "166:                   delegatee: this.holder.address,",
          "167:                   nonce,",
          "168:                   expiry: ethers.MaxUint256,",
          "169:                 },",
          "170:               )",
          "171:               .then(ethers.Signature.from);",
          "173:             const tx = await this.token.delegateBySig(this.delegatee, nonce, ethers.MaxUint256, v, r, s);",
          "175:             const { args } = await tx",
          "176:               .wait()",
          "177:               .then(receipt => receipt.logs.find(event => event.fragment.name == 'DelegateChanged'));",
          "178:             expect(args[0]).to.not.equal(this.holder.address);",
          "179:             expect(args[1]).to.equal(ethers.ZeroAddress);",
          "180:             expect(args[2]).to.equal(this.delegatee.address);",
          "184:             const { r, s, v, serialized } = await this.holder",
          "185:               .signTypedData(",
          "186:                 this.domain,",
          "187:                 { Delegation },",
          "188:                 {",
          "189:                   delegatee: this.holder.address,",
          "190:                   nonce,",
          "191:                   expiry: ethers.MaxUint256,",
          "192:                 },",
          "193:               )",
          "194:               .then(ethers.Signature.from);",
          "196:             const recovered = ethers.verifyTypedData(",
          "197:               this.domain,",
          "198:               { Delegation },",
          "199:               {",
          "200:                 delegatee: this.holder.address,",
          "201:                 nonce: nonce + 1n,",
          "202:                 expiry: ethers.MaxUint256,",
          "203:               },",
          "204:               serialized,",
          "207:             await expect(this.token.delegateBySig(this.holder, nonce + 1n, ethers.MaxUint256, v, r, s))",
          "208:               .to.be.revertedWithCustomError(this.token, 'InvalidAccountNonce')",
          "209:               .withArgs(recovered, nonce);",
          "213:             const expiry = (await time.clock.timestamp()) - time.duration.weeks(1);",
          "215:             const { r, s, v } = await this.holder",
          "216:               .signTypedData(",
          "217:                 this.domain,",
          "218:                 { Delegation },",
          "219:                 {",
          "220:                   delegatee: this.holder.address,",
          "221:                   nonce,",
          "222:                   expiry,",
          "223:                 },",
          "224:               )",
          "225:               .then(ethers.Signature.from);",
          "227:             await expect(this.token.delegateBySig(this.holder, nonce, expiry, v, r, s))",
          "228:               .to.be.revertedWithCustomError(this.token, 'VotesExpiredSignature')",
          "229:               .withArgs(expiry);",
          "236:           await this.token.$_mint(this.holder, supply);",
          "237:           await this.token.connect(this.holder).delegate(this.holder);",
          "241:           expect(await this.token.delegates(this.holder)).to.equal(this.holder.address);",
          "243:           const tx = await this.token.connect(this.holder).delegate(this.delegatee);",
          "244:           const timepoint = await time.clockFromReceipt[mode](tx);",
          "246:           await expect(tx)",
          "247:             .to.emit(this.token, 'DelegateChanged')",
          "248:             .withArgs(this.holder.address, this.holder.address, this.delegatee.address)",
          "249:             .to.emit(this.token, 'DelegateVotesChanged')",
          "250:             .withArgs(this.holder.address, supply, 0n)",
          "251:             .to.emit(this.token, 'DelegateVotesChanged')",
          "252:             .withArgs(this.delegatee.address, 0n, supply);",
          "254:           expect(await this.token.delegates(this.holder)).to.equal(this.delegatee.address);",
          "256:           expect(await this.token.getVotes(this.holder)).to.equal(0n);",
          "257:           expect(await this.token.getVotes(this.delegatee)).to.equal(supply);",
          "258:           expect(await this.token.getPastVotes(this.holder, timepoint - 1n)).to.equal(supply);",
          "259:           expect(await this.token.getPastVotes(this.delegatee, timepoint - 1n)).to.equal(0n);",
          "260:           await mine();",
          "261:           expect(await this.token.getPastVotes(this.holder, timepoint)).to.equal(0n);",
          "262:           expect(await this.token.getPastVotes(this.delegatee, timepoint)).to.equal(supply);",
          "268:           await this.token.$_mint(this.holder, supply);",
          "272:           await expect(this.token.connect(this.holder).transfer(this.recipient, 1n))",
          "273:             .to.emit(this.token, 'Transfer')",
          "274:             .withArgs(this.holder.address, this.recipient.address, 1n)",
          "275:             .to.not.emit(this.token, 'DelegateVotesChanged');",
          "277:           this.holderVotes = 0n;",
          "278:           this.recipientVotes = 0n;",
          "282:           await this.token.connect(this.holder).delegate(this.holder);",
          "284:           const tx = await this.token.connect(this.holder).transfer(this.recipient, 1n);",
          "285:           await expect(tx)",
          "286:             .to.emit(this.token, 'Transfer')",
          "287:             .withArgs(this.holder.address, this.recipient.address, 1n)",
          "288:             .to.emit(this.token, 'DelegateVotesChanged')",
          "289:             .withArgs(this.holder.address, supply, supply - 1n);",
          "291:           const { logs } = await tx.wait();",
          "292:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "293:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "294:             expect(event.index).to.lt(index);",
          "295:           }",
          "297:           this.holderVotes = supply - 1n;",
          "298:           this.recipientVotes = 0n;",
          "302:           await this.token.connect(this.recipient).delegate(this.recipient);",
          "304:           const tx = await this.token.connect(this.holder).transfer(this.recipient, 1n);",
          "305:           await expect(tx)",
          "306:             .to.emit(this.token, 'Transfer')",
          "307:             .withArgs(this.holder.address, this.recipient.address, 1n)",
          "308:             .to.emit(this.token, 'DelegateVotesChanged')",
          "309:             .withArgs(this.recipient.address, 0n, 1n);",
          "311:           const { logs } = await tx.wait();",
          "312:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "313:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "314:             expect(event.index).to.lt(index);",
          "315:           }",
          "317:           this.holderVotes = 0n;",
          "318:           this.recipientVotes = 1n;",
          "322:           await this.token.connect(this.holder).delegate(this.holder);",
          "323:           await this.token.connect(this.recipient).delegate(this.recipient);",
          "325:           const tx = await this.token.connect(this.holder).transfer(this.recipient, 1n);",
          "326:           await expect(tx)",
          "327:             .to.emit(this.token, 'Transfer')",
          "328:             .withArgs(this.holder.address, this.recipient.address, 1n)",
          "329:             .to.emit(this.token, 'DelegateVotesChanged')",
          "330:             .withArgs(this.holder.address, supply, supply - 1n)",
          "331:             .to.emit(this.token, 'DelegateVotesChanged')",
          "332:             .withArgs(this.recipient.address, 0n, 1n);",
          "334:           const { logs } = await tx.wait();",
          "335:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "336:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "337:             expect(event.index).to.lt(index);",
          "338:           }",
          "340:           this.holderVotes = supply - 1n;",
          "341:           this.recipientVotes = 1n;",
          "345:           expect(await this.token.getVotes(this.holder)).to.equal(this.holderVotes);",
          "346:           expect(await this.token.getVotes(this.recipient)).to.equal(this.recipientVotes);",
          "349:           const timepoint = await time.clock[mode]();",
          "350:           await mine();",
          "351:           expect(await this.token.getPastVotes(this.holder, timepoint)).to.equal(this.holderVotes);",
          "352:           expect(await this.token.getPastVotes(this.recipient, timepoint)).to.equal(this.recipientVotes);",
          "359:           await this.token.$_mint(this.holder, supply);",
          "364:             expect(await this.token.balanceOf(this.holder)).to.equal(supply);",
          "370:             await this.token.connect(this.holder).transfer(this.recipient, 100n); //give an account a few tokens for readability",
          "371:             expect(await this.token.numCheckpoints(this.other1)).to.equal(0n);",
          "373:             const t1 = await this.token.connect(this.recipient).delegate(this.other1);",
          "374:             t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "375:             expect(await this.token.numCheckpoints(this.other1)).to.equal(1n);",
          "377:             const t2 = await this.token.connect(this.recipient).transfer(this.other2, 10);",
          "378:             t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "379:             expect(await this.token.numCheckpoints(this.other1)).to.equal(2n);",
          "381:             const t3 = await this.token.connect(this.recipient).transfer(this.other2, 10);",
          "382:             t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "383:             expect(await this.token.numCheckpoints(this.other1)).to.equal(3n);",
          "385:             const t4 = await this.token.connect(this.holder).transfer(this.recipient, 20);",
          "386:             t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "387:             expect(await this.token.numCheckpoints(this.other1)).to.equal(4n);",
          "389:             expect(await this.token.checkpoints(this.other1, 0n)).to.deep.equal([t1.timepoint, 100n]);",
          "390:             expect(await this.token.checkpoints(this.other1, 1n)).to.deep.equal([t2.timepoint, 90n]);",
          "391:             expect(await this.token.checkpoints(this.other1, 2n)).to.deep.equal([t3.timepoint, 80n]);",
          "392:             expect(await this.token.checkpoints(this.other1, 3n)).to.deep.equal([t4.timepoint, 100n]);",
          "393:             await mine();",
          "394:             expect(await this.token.getPastVotes(this.other1, t1.timepoint)).to.equal(100n);",
          "395:             expect(await this.token.getPastVotes(this.other1, t2.timepoint)).to.equal(90n);",
          "396:             expect(await this.token.getPastVotes(this.other1, t3.timepoint)).to.equal(80n);",
          "397:             expect(await this.token.getPastVotes(this.other1, t4.timepoint)).to.equal(100n);",
          "401:             await this.token.connect(this.holder).transfer(this.recipient, 100n);",
          "402:             expect(await this.token.numCheckpoints(this.other1)).to.equal(0n);",
          "405:               () => this.token.connect(this.recipient).delegate(this.other1, { gasLimit: 200000 }),",
          "406:               () => this.token.connect(this.recipient).transfer(this.other2, 10n, { gasLimit: 200000 }),",
          "407:               () => this.token.connect(this.recipient).transfer(this.other2, 10n, { gasLimit: 200000 }),",
          "409:             t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "410:             t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "411:             t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "413:             expect(await this.token.numCheckpoints(this.other1)).to.equal(1);",
          "414:             expect(await this.token.checkpoints(this.other1, 0n)).to.be.deep.equal([t1.timepoint, 80n]);",
          "416:             const t4 = await this.token.connect(this.holder).transfer(this.recipient, 20n);",
          "417:             t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "419:             expect(await this.token.numCheckpoints(this.other1)).to.equal(2n);",
          "420:             expect(await this.token.checkpoints(this.other1, 1n)).to.be.deep.equal([t4.timepoint, 100n]);",
          "427:             await expect(this.token.getPastVotes(this.other1, 50_000_000_000n))",
          "428:               .to.be.revertedWithCustomError(this.token, 'ERC5805FutureLookup')",
          "429:               .withArgs(50_000_000_000n, clock);",
          "433:             expect(await this.token.getPastVotes(this.other1, 0n)).to.equal(0n);",
          "437:             const tx = await this.token.connect(this.holder).delegate(this.other1);",
          "438:             const timepoint = await time.clockFromReceipt[mode](tx);",
          "439:             await mine(2);",
          "441:             expect(await this.token.getPastVotes(this.other1, timepoint)).to.equal(supply);",
          "442:             expect(await this.token.getPastVotes(this.other1, timepoint + 1n)).to.equal(supply);",
          "446:             await mine();",
          "447:             const tx = await this.token.connect(this.holder).delegate(this.other1);",
          "448:             const timepoint = await time.clockFromReceipt[mode](tx);",
          "449:             await mine(2);",
          "451:             expect(await this.token.getPastVotes(this.other1, timepoint - 1n)).to.equal(0n);",
          "452:             expect(await this.token.getPastVotes(this.other1, timepoint + 1n)).to.equal(supply);",
          "456:             const t1 = await this.token.connect(this.holder).delegate(this.other1);",
          "457:             await mine(2);",
          "458:             const t2 = await this.token.connect(this.holder).transfer(this.other2, 10);",
          "459:             await mine(2);",
          "460:             const t3 = await this.token.connect(this.holder).transfer(this.other2, 10);",
          "461:             await mine(2);",
          "462:             const t4 = await this.token.connect(this.other2).transfer(this.holder, 20);",
          "463:             await mine(2);",
          "465:             t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "466:             t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "467:             t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "468:             t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "470:             expect(await this.token.getPastVotes(this.other1, t1.timepoint - 1n)).to.equal(0n);",
          "471:             expect(await this.token.getPastVotes(this.other1, t1.timepoint)).to.equal(supply);",
          "472:             expect(await this.token.getPastVotes(this.other1, t1.timepoint + 1n)).to.equal(supply);",
          "473:             expect(await this.token.getPastVotes(this.other1, t2.timepoint)).to.equal(supply - 10n);",
          "474:             expect(await this.token.getPastVotes(this.other1, t2.timepoint + 1n)).to.equal(supply - 10n);",
          "475:             expect(await this.token.getPastVotes(this.other1, t3.timepoint)).to.equal(supply - 20n);",
          "476:             expect(await this.token.getPastVotes(this.other1, t3.timepoint + 1n)).to.equal(supply - 20n);",
          "477:             expect(await this.token.getPastVotes(this.other1, t4.timepoint)).to.equal(supply);",
          "478:             expect(await this.token.getPastVotes(this.other1, t4.timepoint + 1n)).to.equal(supply);",
          "485:           await this.token.connect(this.holder).delegate(this.holder);",
          "490:           await expect(this.token.getPastTotalSupply(50_000_000_000n))",
          "491:             .to.be.revertedWithCustomError(this.token, 'ERC5805FutureLookup')",
          "492:             .withArgs(50_000_000_000n, clock);",
          "496:           expect(await this.token.getPastTotalSupply(0n)).to.equal(0n);",
          "500:           const tx = await this.token.$_mint(this.holder, supply);",
          "501:           const timepoint = await time.clockFromReceipt[mode](tx);",
          "502:           await mine(2);",
          "504:           expect(await this.token.getPastTotalSupply(timepoint)).to.equal(supply);",
          "505:           expect(await this.token.getPastTotalSupply(timepoint + 1n)).to.equal(supply);",
          "509:           await mine();",
          "510:           const tx = await this.token.$_mint(this.holder, supply);",
          "511:           const timepoint = await time.clockFromReceipt[mode](tx);",
          "512:           await mine(2);",
          "514:           expect(await this.token.getPastTotalSupply(timepoint - 1n)).to.equal(0n);",
          "515:           expect(await this.token.getPastTotalSupply(timepoint + 1n)).to.equal(supply);",
          "519:           const t1 = await this.token.$_mint(this.holder, supply);",
          "520:           await mine(2);",
          "521:           const t2 = await this.token.$_burn(this.holder, 10n);",
          "522:           await mine(2);",
          "523:           const t3 = await this.token.$_burn(this.holder, 10n);",
          "524:           await mine(2);",
          "525:           const t4 = await this.token.$_mint(this.holder, 20n);",
          "526:           await mine(2);",
          "528:           t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "529:           t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "530:           t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "531:           t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "533:           expect(await this.token.getPastTotalSupply(t1.timepoint - 1n)).to.equal(0n);",
          "534:           expect(await this.token.getPastTotalSupply(t1.timepoint)).to.equal(supply);",
          "535:           expect(await this.token.getPastTotalSupply(t1.timepoint + 1n)).to.equal(supply);",
          "536:           expect(await this.token.getPastTotalSupply(t2.timepoint)).to.equal(supply - 10n);",
          "537:           expect(await this.token.getPastTotalSupply(t2.timepoint + 1n)).to.equal(supply - 10n);",
          "538:           expect(await this.token.getPastTotalSupply(t3.timepoint)).to.equal(supply - 20n);",
          "539:           expect(await this.token.getPastTotalSupply(t3.timepoint + 1n)).to.equal(supply - 20n);",
          "540:           expect(await this.token.getPastTotalSupply(t4.timepoint)).to.equal(supply);",
          "541:           expect(await this.token.getPastTotalSupply(t4.timepoint + 1n)).to.equal(supply);",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Votes.test.js||test/token/ERC721/extensions/ERC721Votes.test.js": [
          "File: test/token/ERC721/extensions/ERC721Votes.test.js -> test/token/ERC721/extensions/ERC721Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: const { expect } = require('chai');",
          "8: const { shouldBehaveLikeVotes } = require('../../../governance/utils/Votes.behavior');",
          "24:     describe(`vote with ${mode}`, function () {",
          "25:       beforeEach(async function () {",
          "27:       });",
          "32:       describe('balanceOf', function () {",
          "33:         beforeEach(async function () {",
          "38:         });",
          "40:         it('grants to initial account', async function () {",
          "42:         });",
          "43:       });",
          "45:       describe('transfers', function () {",
          "46:         beforeEach(async function () {",
          "48:         });",
          "50:         it('no delegation', async function () {",
          "57:         });",
          "59:         it('sender delegation', async function () {",
          "75:         });",
          "77:         it('receiver delegation', async function () {",
          "93:         });",
          "95:         it('full delegation', async function () {",
          "113:         });",
          "115:         it('returns the same total supply on transfers', async function () {",
          "129:         });",
          "131:         it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "168:         });",
          "170:         afterEach(async function () {",
          "179:         });",
          "180:       });",
          "181:     });",
          "",
          "[Removed Lines]",
          "3: const { expectEvent, time } = require('@openzeppelin/test-helpers');",
          "6: const { clock, clockFromReceipt } = require('../../../helpers/time');",
          "10: const MODES = {",
          "11:   blocknumber: artifacts.require('$ERC721Votes'),",
          "13: };",
          "15: contract('ERC721Votes', function (accounts) {",
          "16:   const [account1, account2, other1, other2] = accounts;",
          "18:   const name = 'My Vote';",
          "19:   const symbol = 'MTKN';",
          "20:   const version = '1';",
          "21:   const tokens = ['10000000000000000000000000', '10', '20', '30'].map(n => web3.utils.toBN(n));",
          "23:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "26:         this.votes = await artifact.new(name, symbol, name, version);",
          "30:       shouldBehaveLikeVotes(accounts, tokens, { mode, fungible: false });",
          "34:           await this.votes.$_mint(account1, tokens[0]);",
          "35:           await this.votes.$_mint(account1, tokens[1]);",
          "36:           await this.votes.$_mint(account1, tokens[2]);",
          "37:           await this.votes.$_mint(account1, tokens[3]);",
          "41:           expect(await this.votes.balanceOf(account1)).to.be.bignumber.equal('4');",
          "47:           await this.votes.$_mint(account1, tokens[0]);",
          "51:           const { receipt } = await this.votes.transferFrom(account1, account2, tokens[0], { from: account1 });",
          "52:           expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: tokens[0] });",
          "53:           expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "55:           this.account1Votes = '0';",
          "56:           this.account2Votes = '0';",
          "60:           await this.votes.delegate(account1, { from: account1 });",
          "62:           const { receipt } = await this.votes.transferFrom(account1, account2, tokens[0], { from: account1 });",
          "63:           expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: tokens[0] });",
          "64:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: account1, previousVotes: '1', newVotes: '0' });",
          "66:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "67:           expect(",
          "68:             receipt.logs",
          "69:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "70:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "71:           ).to.be.equal(true);",
          "73:           this.account1Votes = '0';",
          "74:           this.account2Votes = '0';",
          "78:           await this.votes.delegate(account2, { from: account2 });",
          "80:           const { receipt } = await this.votes.transferFrom(account1, account2, tokens[0], { from: account1 });",
          "81:           expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: tokens[0] });",
          "82:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: account2, previousVotes: '0', newVotes: '1' });",
          "84:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "85:           expect(",
          "86:             receipt.logs",
          "87:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "88:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "89:           ).to.be.equal(true);",
          "91:           this.account1Votes = '0';",
          "92:           this.account2Votes = '1';",
          "96:           await this.votes.delegate(account1, { from: account1 });",
          "97:           await this.votes.delegate(account2, { from: account2 });",
          "99:           const { receipt } = await this.votes.transferFrom(account1, account2, tokens[0], { from: account1 });",
          "100:           expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: tokens[0] });",
          "101:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: account1, previousVotes: '1', newVotes: '0' });",
          "102:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: account2, previousVotes: '0', newVotes: '1' });",
          "104:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "105:           expect(",
          "106:             receipt.logs",
          "107:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "108:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "109:           ).to.be.equal(true);",
          "111:           this.account1Votes = '0';",
          "112:           this.account2Votes = '1';",
          "116:           await this.votes.delegate(account1, { from: account1 });",
          "118:           const { receipt } = await this.votes.transferFrom(account1, account2, tokens[0], { from: account1 });",
          "119:           const timepoint = await clockFromReceipt[mode](receipt);",
          "121:           await time.advanceBlock();",
          "122:           await time.advanceBlock();",
          "124:           expect(await this.votes.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('1');",
          "125:           expect(await this.votes.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal('1');",
          "127:           this.account1Votes = '0';",
          "128:           this.account2Votes = '0';",
          "132:           await this.votes.$_mint(account1, tokens[1]);",
          "133:           await this.votes.$_mint(account1, tokens[2]);",
          "134:           await this.votes.$_mint(account1, tokens[3]);",
          "136:           const total = await this.votes.balanceOf(account1);",
          "138:           const t1 = await this.votes.delegate(other1, { from: account1 });",
          "139:           await time.advanceBlock();",
          "140:           await time.advanceBlock();",
          "141:           const t2 = await this.votes.transferFrom(account1, other2, tokens[0], { from: account1 });",
          "142:           await time.advanceBlock();",
          "143:           await time.advanceBlock();",
          "144:           const t3 = await this.votes.transferFrom(account1, other2, tokens[2], { from: account1 });",
          "145:           await time.advanceBlock();",
          "146:           await time.advanceBlock();",
          "147:           const t4 = await this.votes.transferFrom(other2, account1, tokens[2], { from: other2 });",
          "148:           await time.advanceBlock();",
          "149:           await time.advanceBlock();",
          "151:           t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "152:           t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "153:           t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "154:           t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "156:           expect(await this.votes.getPastVotes(other1, t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "157:           expect(await this.votes.getPastVotes(other1, t1.timepoint)).to.be.bignumber.equal(total);",
          "158:           expect(await this.votes.getPastVotes(other1, t1.timepoint + 1)).to.be.bignumber.equal(total);",
          "159:           expect(await this.votes.getPastVotes(other1, t2.timepoint)).to.be.bignumber.equal('3');",
          "160:           expect(await this.votes.getPastVotes(other1, t2.timepoint + 1)).to.be.bignumber.equal('3');",
          "161:           expect(await this.votes.getPastVotes(other1, t3.timepoint)).to.be.bignumber.equal('2');",
          "162:           expect(await this.votes.getPastVotes(other1, t3.timepoint + 1)).to.be.bignumber.equal('2');",
          "163:           expect(await this.votes.getPastVotes(other1, t4.timepoint)).to.be.bignumber.equal('3');",
          "164:           expect(await this.votes.getPastVotes(other1, t4.timepoint + 1)).to.be.bignumber.equal('3');",
          "166:           this.account1Votes = '0';",
          "167:           this.account2Votes = '0';",
          "171:           expect(await this.votes.getVotes(account1)).to.be.bignumber.equal(this.account1Votes);",
          "172:           expect(await this.votes.getVotes(account2)).to.be.bignumber.equal(this.account2Votes);",
          "175:           const timepoint = await clock[mode]();",
          "176:           await time.advanceBlock();",
          "177:           expect(await this.votes.getPastVotes(account1, timepoint)).to.be.bignumber.equal(this.account1Votes);",
          "178:           expect(await this.votes.getPastVotes(account2, timepoint)).to.be.bignumber.equal(this.account2Votes);",
          "",
          "[Added Lines]",
          "1: const { ethers } = require('hardhat');",
          "3: const { loadFixture, mine } = require('@nomicfoundation/hardhat-network-helpers');",
          "5: const { bigint: time } = require('../../../helpers/time');",
          "9: const TOKENS = [",
          "10:   { Token: '$ERC721Votes', mode: 'blocknumber' },",
          "12: ];",
          "14: const name = 'My Vote';",
          "15: const symbol = 'MTKN';",
          "16: const version = '1';",
          "17: const tokens = [ethers.parseEther('10000000'), 10n, 20n, 30n];",
          "19: describe('ERC721Votes', function () {",
          "20:   for (const { Token, mode } of TOKENS) {",
          "21:     const fixture = async () => {",
          "23:       const accounts = await ethers.getSigners();",
          "24:       const [holder, recipient, other1, other2] = accounts;",
          "26:       const token = await ethers.deployContract(Token, [name, symbol, name, version]);",
          "28:       return { accounts, holder, recipient, other1, other2, token };",
          "29:     };",
          "33:         Object.assign(this, await loadFixture(fixture));",
          "34:         this.votes = this.token;",
          "38:       shouldBehaveLikeVotes(tokens, { mode, fungible: false });",
          "42:           await this.votes.$_mint(this.holder, tokens[0]);",
          "43:           await this.votes.$_mint(this.holder, tokens[1]);",
          "44:           await this.votes.$_mint(this.holder, tokens[2]);",
          "45:           await this.votes.$_mint(this.holder, tokens[3]);",
          "49:           expect(await this.votes.balanceOf(this.holder)).to.equal(4n);",
          "55:           await this.votes.$_mint(this.holder, tokens[0]);",
          "59:           await expect(this.votes.connect(this.holder).transferFrom(this.holder, this.recipient, tokens[0]))",
          "60:             .to.emit(this.token, 'Transfer')",
          "61:             .withArgs(this.holder.address, this.recipient.address, tokens[0])",
          "62:             .to.not.emit(this.token, 'DelegateVotesChanged');",
          "64:           this.holderVotes = 0n;",
          "65:           this.recipientVotes = 0n;",
          "69:           await this.votes.connect(this.holder).delegate(this.holder);",
          "71:           const tx = await this.votes.connect(this.holder).transferFrom(this.holder, this.recipient, tokens[0]);",
          "72:           await expect(tx)",
          "73:             .to.emit(this.token, 'Transfer')",
          "74:             .withArgs(this.holder.address, this.recipient.address, tokens[0])",
          "75:             .to.emit(this.token, 'DelegateVotesChanged')",
          "76:             .withArgs(this.holder.address, 1n, 0n);",
          "78:           const { logs } = await tx.wait();",
          "79:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "80:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "81:             expect(event.index).to.lt(index);",
          "82:           }",
          "84:           this.holderVotes = 0n;",
          "85:           this.recipientVotes = 0n;",
          "89:           await this.votes.connect(this.recipient).delegate(this.recipient);",
          "91:           const tx = await this.votes.connect(this.holder).transferFrom(this.holder, this.recipient, tokens[0]);",
          "92:           await expect(tx)",
          "93:             .to.emit(this.token, 'Transfer')",
          "94:             .withArgs(this.holder.address, this.recipient.address, tokens[0])",
          "95:             .to.emit(this.token, 'DelegateVotesChanged')",
          "96:             .withArgs(this.recipient.address, 0n, 1n);",
          "98:           const { logs } = await tx.wait();",
          "99:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "100:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "101:             expect(event.index).to.lt(index);",
          "102:           }",
          "104:           this.holderVotes = 0n;",
          "105:           this.recipientVotes = 1n;",
          "109:           await this.votes.connect(this.holder).delegate(this.holder);",
          "110:           await this.votes.connect(this.recipient).delegate(this.recipient);",
          "112:           const tx = await this.votes.connect(this.holder).transferFrom(this.holder, this.recipient, tokens[0]);",
          "113:           await expect(tx)",
          "114:             .to.emit(this.token, 'Transfer')",
          "115:             .withArgs(this.holder.address, this.recipient.address, tokens[0])",
          "116:             .to.emit(this.token, 'DelegateVotesChanged')",
          "117:             .withArgs(this.holder.address, 1n, 0n)",
          "118:             .to.emit(this.token, 'DelegateVotesChanged')",
          "119:             .withArgs(this.recipient.address, 0n, 1n);",
          "121:           const { logs } = await tx.wait();",
          "122:           const { index } = logs.find(event => event.fragment.name == 'DelegateVotesChanged');",
          "123:           for (const event of logs.filter(event => event.fragment.name == 'Transfer')) {",
          "124:             expect(event.index).to.lt(index);",
          "125:           }",
          "127:           this.holderVotes = 0;",
          "128:           this.recipientVotes = 1n;",
          "132:           await this.votes.connect(this.holder).delegate(this.holder);",
          "134:           const tx = await this.votes.connect(this.holder).transferFrom(this.holder, this.recipient, tokens[0]);",
          "135:           const timepoint = await time.clockFromReceipt[mode](tx);",
          "137:           await mine(2);",
          "139:           expect(await this.votes.getPastTotalSupply(timepoint - 1n)).to.equal(1n);",
          "140:           expect(await this.votes.getPastTotalSupply(timepoint + 1n)).to.equal(1n);",
          "142:           this.holderVotes = 0n;",
          "143:           this.recipientVotes = 0n;",
          "147:           await this.votes.$_mint(this.holder, tokens[1]);",
          "148:           await this.votes.$_mint(this.holder, tokens[2]);",
          "149:           await this.votes.$_mint(this.holder, tokens[3]);",
          "151:           const total = await this.votes.balanceOf(this.holder);",
          "153:           const t1 = await this.votes.connect(this.holder).delegate(this.other1);",
          "154:           await mine(2);",
          "155:           const t2 = await this.votes.connect(this.holder).transferFrom(this.holder, this.other2, tokens[0]);",
          "156:           await mine(2);",
          "157:           const t3 = await this.votes.connect(this.holder).transferFrom(this.holder, this.other2, tokens[2]);",
          "158:           await mine(2);",
          "159:           const t4 = await this.votes.connect(this.other2).transferFrom(this.other2, this.holder, tokens[2]);",
          "160:           await mine(2);",
          "162:           t1.timepoint = await time.clockFromReceipt[mode](t1);",
          "163:           t2.timepoint = await time.clockFromReceipt[mode](t2);",
          "164:           t3.timepoint = await time.clockFromReceipt[mode](t3);",
          "165:           t4.timepoint = await time.clockFromReceipt[mode](t4);",
          "167:           expect(await this.votes.getPastVotes(this.other1, t1.timepoint - 1n)).to.equal(0n);",
          "168:           expect(await this.votes.getPastVotes(this.other1, t1.timepoint)).to.equal(total);",
          "169:           expect(await this.votes.getPastVotes(this.other1, t1.timepoint + 1n)).to.equal(total);",
          "170:           expect(await this.votes.getPastVotes(this.other1, t2.timepoint)).to.equal(3n);",
          "171:           expect(await this.votes.getPastVotes(this.other1, t2.timepoint + 1n)).to.equal(3n);",
          "172:           expect(await this.votes.getPastVotes(this.other1, t3.timepoint)).to.equal(2n);",
          "173:           expect(await this.votes.getPastVotes(this.other1, t3.timepoint + 1n)).to.equal(2n);",
          "174:           expect(await this.votes.getPastVotes(this.other1, t4.timepoint)).to.equal('3');",
          "175:           expect(await this.votes.getPastVotes(this.other1, t4.timepoint + 1n)).to.equal(3n);",
          "177:           this.holderVotes = 0n;",
          "178:           this.recipientVotes = 0n;",
          "182:           expect(await this.votes.getVotes(this.holder)).to.equal(this.holderVotes);",
          "183:           expect(await this.votes.getVotes(this.recipient)).to.equal(this.recipientVotes);",
          "186:           const timepoint = await time.clock[mode]();",
          "187:           await mine();",
          "188:           expect(await this.votes.getPastVotes(this.holder, timepoint)).to.equal(this.holderVotes);",
          "189:           expect(await this.votes.getPastVotes(this.recipient, timepoint)).to.equal(this.recipientVotes);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "87456e335892537ed6ec651d49adabaf451fe4b9",
      "candidate_info": {
        "commit_hash": "87456e335892537ed6ec651d49adabaf451fe4b9",
        "repo": "OpenZeppelin/openzeppelin-contracts",
        "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/87456e335892537ed6ec651d49adabaf451fe4b9",
        "files": [
          ".changeset/swift-bags-divide.md",
          "contracts/governance/Governor.sol",
          "docs/modules/api/pages/governance.adoc",
          "test/governance/Governor.t.sol",
          "test/governance/Governor.test.js"
        ],
        "message": "Update docs",
        "before_after_code_files": [
          "contracts/governance/Governor.sol||contracts/governance/Governor.sol",
          "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
          "test/governance/Governor.test.js||test/governance/Governor.test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "contracts/governance/Governor.sol||contracts/governance/Governor.sol",
            "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ],
          "candidate": [
            "contracts/governance/Governor.sol||contracts/governance/Governor.sol",
            "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ]
        }
      },
      "candidate_diff": {
        "contracts/governance/Governor.sol||contracts/governance/Governor.sol": [
          "File: contracts/governance/Governor.sol -> contracts/governance/Governor.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:         string memory description",
          "273:     ) public virtual override returns (uint256) {",
          "274:         address proposer = _msgSender();",
          "277:         require(",
          "278:             getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
          "279:             \"Governor: proposer votes below proposal threshold\"",
          "",
          "[Removed Lines]",
          "275:         uint256 currentTimepoint = clock();",
          "",
          "[Added Lines]",
          "275:         require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");",
          "277:         uint256 currentTimepoint = clock();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "634:     ) public virtual override returns (bytes4) {",
          "635:         return this.onERC1155BatchReceived.selector;",
          "636:     }",
          "637: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656:     function _isValidDescriptionForProposer(",
          "657:         address proposer,",
          "658:         string memory description",
          "659:     ) internal view virtual returns (bool) {",
          "660:         uint256 len = bytes(description).length;",
          "663:         if (len < 52) {",
          "664:             return true;",
          "665:         }",
          "668:         bytes12 marker;",
          "669:         assembly {",
          "676:             marker := mload(add(description, sub(len, 20)))",
          "677:         }",
          "680:         if (marker != bytes12(\"#proposer=0x\")) {",
          "681:             return true;",
          "682:         }",
          "685:         uint160 recovered = 0;",
          "686:         for (uint256 i = len - 40; i < len; ++i) {",
          "687:             (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);",
          "689:             if (!isHex) {",
          "690:                 return true;",
          "691:             }",
          "692:             recovered = (recovered << 4) | value;",
          "693:         }",
          "695:         return recovered == uint160(proposer);",
          "696:     }",
          "702:     function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {",
          "703:         uint8 c = uint8(char);",
          "704:         unchecked {",
          "706:             if (47 < c && c < 58) {",
          "707:                 return (true, c - 48);",
          "708:             }",
          "710:             else if (64 < c && c < 71) {",
          "711:                 return (true, c - 55);",
          "712:             }",
          "714:             else if (96 < c && c < 103) {",
          "715:                 return (true, c - 87);",
          "716:             }",
          "718:             else {",
          "719:                 return (false, 0);",
          "720:             }",
          "721:         }",
          "722:     }",
          "",
          "---------------"
        ],
        "test/governance/Governor.t.sol||test/governance/Governor.t.sol": [
          "File: test/governance/Governor.t.sol -> test/governance/Governor.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.19;",
          "5: import \"forge-std/Test.sol\";",
          "6: import \"../../contracts/utils/Strings.sol\";",
          "7: import \"../../contracts/governance/Governor.sol\";",
          "9: contract GovernorInternalTest is Test, Governor {",
          "10:     constructor() Governor(\"\") {}",
          "12:     function testValidDescriptionForProposer(string memory description, address proposer, bool includeProposer) public {",
          "13:         if (includeProposer) {",
          "14:             description = string.concat(description, \"#proposer=\", Strings.toHexString(proposer));",
          "15:         }",
          "16:         assertTrue(_isValidDescriptionForProposer(proposer, description));",
          "17:     }",
          "19:     function testInvalidDescriptionForProposer(",
          "20:         string memory description,",
          "21:         address commitProposer,",
          "22:         address actualProposer",
          "23:     ) public {",
          "24:         vm.assume(commitProposer != actualProposer);",
          "25:         description = string.concat(description, \"#proposer=\", Strings.toHexString(commitProposer));",
          "26:         assertFalse(_isValidDescriptionForProposer(actualProposer, description));",
          "27:     }",
          "32:     function clock() public pure override returns (uint48) {}",
          "35:     function CLOCK_MODE() public pure override returns (string memory) {}",
          "38:     function COUNTING_MODE() public pure virtual override returns (string memory) {}",
          "40:     function votingDelay() public pure virtual override returns (uint256) {}",
          "42:     function votingPeriod() public pure virtual override returns (uint256) {}",
          "44:     function quorum(uint256) public pure virtual override returns (uint256) {}",
          "46:     function hasVoted(uint256, address) public pure virtual override returns (bool) {}",
          "48:     function _quorumReached(uint256) internal pure virtual override returns (bool) {}",
          "50:     function _voteSucceeded(uint256) internal pure virtual override returns (bool) {}",
          "52:     function _getVotes(address, uint256, bytes memory) internal pure virtual override returns (uint256) {}",
          "54:     function _countVote(uint256, address, uint8, uint256, bytes memory) internal virtual override {}",
          "55: }",
          "",
          "---------------"
        ],
        "test/governance/Governor.test.js||test/governance/Governor.test.js": [
          "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "544:         });",
          "545:       });",
          "547:       describe('onlyGovernance updates', function () {",
          "548:         it('setVotingDelay is protected', async function () {",
          "549:           await expectRevert(this.mock.setVotingDelay('0'), 'Governor: onlyGovernance');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "547:       describe('frontrun protection using description suffix', function () {",
          "548:         describe('without protection', function () {",
          "549:           describe('without suffix', function () {",
          "550:             it('proposer can propose', async function () {",
          "551:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "552:             });",
          "554:             it('someone else can propose', async function () {",
          "555:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "556:             });",
          "557:           });",
          "559:           describe('with different suffix', function () {",
          "560:             beforeEach(async function () {",
          "561:               this.proposal = this.helper.setProposal(",
          "562:                 [",
          "563:                   {",
          "564:                     target: this.receiver.address,",
          "565:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "566:                     value,",
          "567:                   },",
          "568:                 ],",
          "569:                 `<proposal description>#wrong-suffix=${proposer}`,",
          "570:               );",
          "571:             });",
          "573:             it('proposer can propose', async function () {",
          "574:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "575:             });",
          "577:             it('someone else can propose', async function () {",
          "578:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "579:             });",
          "580:           });",
          "582:           describe('with proposer suffix but bad address part', function () {",
          "583:             beforeEach(async function () {",
          "584:               this.proposal = this.helper.setProposal(",
          "585:                 [",
          "586:                   {",
          "587:                     target: this.receiver.address,",
          "588:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "589:                     value,",
          "590:                   },",
          "591:                 ],",
          "592:                 `<proposal description>#proposer=0x3C44CdDdB6a900fa2b585dd299e03d12FA429XYZ`, // XYZ are not a valid hex char",
          "593:               );",
          "594:             });",
          "596:             it('propose can propose', async function () {",
          "597:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "598:             });",
          "600:             it('someone else can propose', async function () {",
          "601:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "602:             });",
          "603:           });",
          "604:         });",
          "606:         describe('with protection via proposer suffix', function () {",
          "607:           beforeEach(async function () {",
          "608:             this.proposal = this.helper.setProposal(",
          "609:               [",
          "610:                 {",
          "611:                   target: this.receiver.address,",
          "612:                   data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "613:                   value,",
          "614:                 },",
          "615:               ],",
          "616:               `<proposal description>#proposer=${proposer}`,",
          "617:             );",
          "618:           });",
          "620:           it('proposer can propose', async function () {",
          "621:             expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "622:           });",
          "624:           it('someone else cannot propose', async function () {",
          "625:             await expectRevert(this.helper.propose({ from: voter1 }), 'Governor: proposer restricted');",
          "626:           });",
          "627:         });",
          "628:       });",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-40640",
  "cve_desc": "vodozemac is an open source implementation of Olm and Megolm in pure Rust.  Versions before 0.7.0 of vodozemac use a non-constant time base64 implementation for importing key material for Megolm group sessions and `PkDecryption` Ed25519 secret keys. This flaw might allow an attacker to infer some information about the secret key material through a side-channel attack. The use of a non-constant time base64 implementation might allow an attacker to observe timing variations in the encoding and decoding operations of the secret key material. This could potentially provide insights into the underlying secret key material. The impact of this vulnerability is considered low because exploiting the attacker is required to have access to high precision timing measurements, as well as repeated access to the base64 encoding or decoding processes.  Additionally, the estimated leakage amount is bounded and low according to the referenced paper. This has been patched in commit 734b6c6948d4b2bdee3dd8b4efa591d93a61d272 which has been included in release version 0.7.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n",
  "repo": "matrix-org/vodozemac",
  "patch_hash": "734b6c6948d4b2bdee3dd8b4efa591d93a61d272",
  "patch_info": {
    "commit_hash": "734b6c6948d4b2bdee3dd8b4efa591d93a61d272",
    "repo": "matrix-org/vodozemac",
    "commit_url": "https://github.com/matrix-org/vodozemac/commit/734b6c6948d4b2bdee3dd8b4efa591d93a61d272",
    "files": [
      "Cargo.toml",
      "src/megolm/session_keys.rs",
      "src/types/ed25519.rs",
      "src/types/mod.rs"
    ],
    "message": "fix: Use a constant-time Base64 encoder for secret key material\n\nThis patch fixes a security issue around a side-channel vulnerability[1]\nwhen decoding secret key material using Base64.\n\nIn some circumstances an attacker can obtain information about secret\nsecret key material via a controlled-channel and side-channel attack.\n\nThis patch avoids the side-channel by switching to the base64ct crate\nfor the encoding, and more importantly, the decoding of secret key\nmaterial.\n\n[1]: https://arxiv.org/abs/2108.04600",
    "before_after_code_files": [
      "src/megolm/session_keys.rs||src/megolm/session_keys.rs",
      "src/types/ed25519.rs||src/types/ed25519.rs",
      "src/types/mod.rs||src/types/mod.rs"
    ]
  },
  "patch_diff": {
    "src/megolm/session_keys.rs||src/megolm/session_keys.rs": [
      "File: src/megolm/session_keys.rs -> src/megolm/session_keys.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: use std::io::{Cursor, Read};",
      "17: use serde::{Deserialize, Serialize};",
      "18: use thiserror::Error;",
      "19: use zeroize::Zeroize;",
      "21: use super::ratchet::Ratchet;",
      "",
      "[Removed Lines]",
      "22: use crate::{",
      "23:     utilities::{base64_decode, base64_encode},",
      "24:     Ed25519PublicKey, Ed25519Signature, SignatureError,",
      "25: };",
      "",
      "[Added Lines]",
      "17: use base64ct::Encoding;",
      "23: use crate::{Ed25519PublicKey, Ed25519Signature, SignatureError};",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "36:     Read(#[from] std::io::Error),",
      "38:     #[error(\"The session key wasn't valid base64: {0}\")]",
      "41:     #[error(\"The signature on the session key was invalid: {0}\")]",
      "42:     Signature(#[from] SignatureError),",
      "",
      "[Removed Lines]",
      "39:     Base64(#[from] base64::DecodeError),",
      "",
      "[Added Lines]",
      "37:     Base64(#[from] base64ct::Error),",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "93:     pub fn to_base64(&self) -> String {",
      "94:         let mut bytes = self.to_bytes();",
      "98:         bytes.zeroize();",
      "",
      "[Removed Lines]",
      "96:         let ret = base64_encode(&bytes);",
      "",
      "[Added Lines]",
      "94:         let ret = base64ct::Base64Unpadded::encode_string(&bytes);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "104:     pub fn from_base64(key: &str) -> Result<Self, SessionKeyDecodeError> {",
      "106:         let ret = Self::from_bytes(&bytes);",
      "108:         bytes.zeroize();",
      "",
      "[Removed Lines]",
      "105:         let mut bytes = base64_decode(key)?;",
      "",
      "[Added Lines]",
      "103:         let mut bytes = base64ct::Base64Unpadded::decode_vec(key)?;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "269:     pub fn to_base64(&self) -> String {",
      "270:         let mut bytes = self.to_bytes();",
      "273:         bytes.zeroize();",
      "",
      "[Removed Lines]",
      "271:         let ret = base64_encode(&bytes);",
      "",
      "[Added Lines]",
      "269:         let ret = base64ct::Base64Unpadded::encode_string(&bytes);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "279:     pub fn from_base64(key: &str) -> Result<Self, SessionKeyDecodeError> {",
      "281:         let ret = Self::from_bytes(&bytes);",
      "283:         bytes.zeroize();",
      "",
      "[Removed Lines]",
      "280:         let mut bytes = base64_decode(key)?;",
      "",
      "[Added Lines]",
      "278:         let mut bytes = base64ct::Base64Unpadded::decode_vec(key)?;",
      "",
      "---------------"
    ],
    "src/types/ed25519.rs||src/types/ed25519.rs": [
      "File: src/types/ed25519.rs -> src/types/ed25519.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: use std::fmt::Display;",
      "17: use base64::decoded_len_estimate;",
      "18: use curve25519_dalek::EdwardsPoint;",
      "19: #[cfg(not(fuzzing))]",
      "20: use ed25519_dalek::Verifier;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: use base64ct::Encoding;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "227:     pub fn to_base64(&self) -> String {",
      "228:         let mut bytes = self.to_bytes();",
      "231:         bytes.zeroize();",
      "",
      "[Removed Lines]",
      "229:         let ret = base64_encode(bytes.as_ref());",
      "",
      "[Added Lines]",
      "230:         let ret = base64ct::Base64Unpadded::encode_string(bytes.as_ref());",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "242:                 length: decoded_len_estimate(input.len()),",
      "243:             })",
      "244:         } else {",
      "248:             key_bytes.copy_from_slice(&bytes);",
      "249:             let key = Self::from_slice(&key_bytes);",
      "",
      "[Removed Lines]",
      "245:             let mut bytes = base64_decode(input)?;",
      "246:             let mut key_bytes = [0u8; 32];",
      "",
      "[Added Lines]",
      "249:             let mut bytes = if let Ok(bytes) = base64ct::Base64Unpadded::decode_vec(input) {",
      "250:                 bytes",
      "251:             } else {",
      "252:                 base64ct::Base64::decode_vec(input)?",
      "253:             };",
      "255:             let mut key_bytes = [0u8; 32];",
      "",
      "---------------"
    ],
    "src/types/mod.rs||src/types/mod.rs": [
      "File: src/types/mod.rs -> src/types/mod.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: pub enum KeyError {",
      "47:     #[error(\"Failed decoding a public key from base64: {}\", .0)]",
      "48:     Base64Error(#[from] base64::DecodeError),",
      "49:     #[error(",
      "50:         \"Failed decoding {key_type} key from base64: \\",
      "51:         Invalid number of bytes for {key_type}, expected {expected_length}, got {length}.\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49:     #[error(\"Failed to decode a private key from base64: {}\", .0)]",
      "50:     Base64PrivateKey(#[from] base64ct::Error),",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "77765dace11266ef9523301624a01265c6e0f790",
      "candidate_info": {
        "commit_hash": "77765dace11266ef9523301624a01265c6e0f790",
        "repo": "matrix-org/vodozemac",
        "commit_url": "https://github.com/matrix-org/vodozemac/commit/77765dace11266ef9523301624a01265c6e0f790",
        "files": [
          "Cargo.toml",
          "src/megolm/session_keys.rs",
          "src/types/ed25519.rs",
          "src/types/mod.rs"
        ],
        "message": "fix: Use a constant-time Base64 encoder for secret key material\n\nThis patch fixes a security issue around a side-channel vulnerability[1]\nwhen decoding secret key material using Base64.\n\nIn some circumstances an attacker can obtain information about secret\nsecret key material via a controlled-channel and side-channel attack.\n\nThis patch avoids the side-channel by switching to the base64ct crate\nfor the encoding, and more importantly, the decoding of secret key\nmaterial.\n\n[1]: https://arxiv.org/abs/2108.04600",
        "before_after_code_files": [
          "src/megolm/session_keys.rs||src/megolm/session_keys.rs",
          "src/types/ed25519.rs||src/types/ed25519.rs",
          "src/types/mod.rs||src/types/mod.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/megolm/session_keys.rs||src/megolm/session_keys.rs",
            "src/types/ed25519.rs||src/types/ed25519.rs",
            "src/types/mod.rs||src/types/mod.rs"
          ],
          "candidate": [
            "src/megolm/session_keys.rs||src/megolm/session_keys.rs",
            "src/types/ed25519.rs||src/types/ed25519.rs",
            "src/types/mod.rs||src/types/mod.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/megolm/session_keys.rs||src/megolm/session_keys.rs": [
          "File: src/megolm/session_keys.rs -> src/megolm/session_keys.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: use std::io::{Cursor, Read};",
          "17: use serde::{Deserialize, Serialize};",
          "18: use thiserror::Error;",
          "19: use zeroize::Zeroize;",
          "21: use super::ratchet::Ratchet;",
          "",
          "[Removed Lines]",
          "22: use crate::{",
          "23:     utilities::{base64_decode, base64_encode},",
          "24:     Ed25519PublicKey, Ed25519Signature, SignatureError,",
          "25: };",
          "",
          "[Added Lines]",
          "17: use base64ct::Encoding;",
          "23: use crate::{Ed25519PublicKey, Ed25519Signature, SignatureError};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     Read(#[from] std::io::Error),",
          "38:     #[error(\"The session key wasn't valid base64: {0}\")]",
          "41:     #[error(\"The signature on the session key was invalid: {0}\")]",
          "42:     Signature(#[from] SignatureError),",
          "",
          "[Removed Lines]",
          "39:     Base64(#[from] base64::DecodeError),",
          "",
          "[Added Lines]",
          "37:     Base64(#[from] base64ct::Error),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:     pub fn to_base64(&self) -> String {",
          "94:         let mut bytes = self.to_bytes();",
          "98:         bytes.zeroize();",
          "",
          "[Removed Lines]",
          "96:         let ret = base64_encode(&bytes);",
          "",
          "[Added Lines]",
          "94:         let ret = base64ct::Base64Unpadded::encode_string(&bytes);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "104:     pub fn from_base64(key: &str) -> Result<Self, SessionKeyDecodeError> {",
          "106:         let ret = Self::from_bytes(&bytes);",
          "108:         bytes.zeroize();",
          "",
          "[Removed Lines]",
          "105:         let mut bytes = base64_decode(key)?;",
          "",
          "[Added Lines]",
          "103:         let mut bytes = base64ct::Base64Unpadded::decode_vec(key)?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "269:     pub fn to_base64(&self) -> String {",
          "270:         let mut bytes = self.to_bytes();",
          "273:         bytes.zeroize();",
          "",
          "[Removed Lines]",
          "271:         let ret = base64_encode(&bytes);",
          "",
          "[Added Lines]",
          "269:         let ret = base64ct::Base64Unpadded::encode_string(&bytes);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "279:     pub fn from_base64(key: &str) -> Result<Self, SessionKeyDecodeError> {",
          "281:         let ret = Self::from_bytes(&bytes);",
          "283:         bytes.zeroize();",
          "",
          "[Removed Lines]",
          "280:         let mut bytes = base64_decode(key)?;",
          "",
          "[Added Lines]",
          "278:         let mut bytes = base64ct::Base64Unpadded::decode_vec(key)?;",
          "",
          "---------------"
        ],
        "src/types/ed25519.rs||src/types/ed25519.rs": [
          "File: src/types/ed25519.rs -> src/types/ed25519.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: use std::fmt::Display;",
          "17: use base64::decoded_len_estimate;",
          "18: use curve25519_dalek::EdwardsPoint;",
          "19: #[cfg(not(fuzzing))]",
          "20: use ed25519_dalek::Verifier;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: use base64ct::Encoding;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "227:     pub fn to_base64(&self) -> String {",
          "228:         let mut bytes = self.to_bytes();",
          "231:         bytes.zeroize();",
          "",
          "[Removed Lines]",
          "229:         let ret = base64_encode(bytes.as_ref());",
          "",
          "[Added Lines]",
          "230:         let ret = base64ct::Base64Unpadded::encode_string(bytes.as_ref());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:                 length: decoded_len_estimate(input.len()),",
          "243:             })",
          "244:         } else {",
          "248:             key_bytes.copy_from_slice(&bytes);",
          "249:             let key = Self::from_slice(&key_bytes);",
          "",
          "[Removed Lines]",
          "245:             let mut bytes = base64_decode(input)?;",
          "246:             let mut key_bytes = [0u8; 32];",
          "",
          "[Added Lines]",
          "249:             let mut bytes = if let Ok(bytes) = base64ct::Base64Unpadded::decode_vec(input) {",
          "250:                 bytes",
          "251:             } else {",
          "252:                 base64ct::Base64::decode_vec(input)?",
          "253:             };",
          "255:             let mut key_bytes = [0u8; 32];",
          "",
          "---------------"
        ],
        "src/types/mod.rs||src/types/mod.rs": [
          "File: src/types/mod.rs -> src/types/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: pub enum KeyError {",
          "47:     #[error(\"Failed decoding a public key from base64: {}\", .0)]",
          "48:     Base64Error(#[from] base64::DecodeError),",
          "49:     #[error(",
          "50:         \"Failed decoding {key_type} key from base64: \\",
          "51:         Invalid number of bytes for {key_type}, expected {expected_length}, got {length}.\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49:     #[error(\"Failed to decode a private key from base64: {}\", .0)]",
          "50:     Base64PrivateKey(#[from] base64ct::Error),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
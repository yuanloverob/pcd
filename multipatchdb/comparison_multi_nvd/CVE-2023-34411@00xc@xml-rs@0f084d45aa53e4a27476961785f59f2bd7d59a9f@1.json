{
  "cve_id": "CVE-2023-34411",
  "cve_desc": "The xml-rs crate before 0.8.14 for Rust and Crab allows a denial of service (panic) via an invalid <! token (such as <!DOCTYPEs/%<!A nesting) in an XML document. The earliest affected version is 0.8.9.",
  "repo": "00xc/xml-rs",
  "patch_hash": "0f084d45aa53e4a27476961785f59f2bd7d59a9f",
  "patch_info": {
    "commit_hash": "0f084d45aa53e4a27476961785f59f2bd7d59a9f",
    "repo": "00xc/xml-rs",
    "commit_url": "https://github.com/00xc/xml-rs/commit/0f084d45aa53e4a27476961785f59f2bd7d59a9f",
    "files": [
      "README.md",
      "src/reader/lexer.rs",
      "src/reader/parser/inside_cdata.rs",
      "src/reader/parser/inside_doctype.rs",
      "src/reader/parser/inside_processing_instruction.rs",
      "src/reader/parser/mod.rs",
      "src/reader/parser/outside_tag.rs",
      "tests/xmlconf.rs"
    ],
    "message": "Parse DOCTYPE markup declarations",
    "before_after_code_files": [
      "src/reader/lexer.rs||src/reader/lexer.rs",
      "src/reader/parser/inside_cdata.rs||src/reader/parser/inside_cdata.rs",
      "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
      "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs",
      "src/reader/parser/mod.rs||src/reader/parser/mod.rs",
      "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
      "tests/xmlconf.rs||tests/xmlconf.rs"
    ]
  },
  "patch_diff": {
    "src/reader/lexer.rs||src/reader/lexer.rs": [
      "File: src/reader/lexer.rs -> src/reader/lexer.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:     ReferenceStart,",
      "56:     ReferenceEnd,",
      "57: }",
      "59: impl fmt::Display for Token {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:     MarkupDeclarationStart,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "143:     }",
      "144: }",
      "146: enum State {",
      "148:     Normal,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "148: #[derive(Copy, Clone)]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "154:     CommentStarted,",
      "156:     DoctypeStarted(DoctypeStartedSubstate),",
      "160:     CDataStarted(CDataStartedSubstate),",
      "",
      "[Removed Lines]",
      "158:     DoctypeFinishing(u8),",
      "",
      "[Added Lines]",
      "161:     InsideMarkupDeclaration,",
      "163:     InsideDoctype,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "174:     InsideCdata,",
      "176:     InsideProcessingInstruction,",
      "177: }",
      "179: #[derive(Copy, Clone)]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "183:     InsideMarkupDeclarationQuotedString(QuoteStyle),",
      "184: }",
      "186: #[derive(Copy, Clone, Eq, PartialEq)]",
      "187: enum QuoteStyle {",
      "188:     Single, Double",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "229:     head_pos: TextPosition,",
      "230:     char_queue: VecDeque<char>,",
      "231:     st: State,",
      "232:     skip_errors: bool,",
      "233:     inside_token: bool,",
      "234:     eof_handled: bool",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "245:     normal_state: State,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "248:             head_pos: TextPosition::new(),",
      "249:             char_queue: VecDeque::with_capacity(4),  // TODO: check size",
      "250:             st: State::Normal,",
      "251:             skip_errors: false,",
      "252:             inside_token: false,",
      "253:             eof_handled: false",
      "254:         }",
      "255:     }",
      "268:     #[inline]",
      "",
      "[Removed Lines]",
      "259:     #[inline]",
      "260:     pub fn enable_errors(&mut self) { self.skip_errors = false; }",
      "264:     #[inline]",
      "265:     pub fn disable_errors(&mut self) { self.skip_errors = true; }",
      "",
      "[Added Lines]",
      "265:             normal_state: State::Normal,",
      "274:     pub(crate) fn disable_errors(&mut self) { self.skip_errors = true; }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "326:             State::TagStarted | State::CommentOrCDataOrDoctypeStarted |",
      "327:             State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |",
      "328:             State::CommentClosing(ClosingSubstate::Second) |",
      "330:             State::InsideProcessingInstruction | State::ProcessingInstructionClosing |",
      "332:                 Err(self.error(\"Unexpected end of stream\")),",
      "333:             State::EmptyTagClosing =>",
      "334:                 Ok(Some(Token::Character('/'))),",
      "",
      "[Removed Lines]",
      "329:             State::InsideComment |",
      "331:             State::DoctypeFinishing(_) =>",
      "",
      "[Added Lines]",
      "338:             State::InsideComment | State::InsideMarkupDeclaration |",
      "340:             State::InsideDoctype | State::InsideMarkupDeclarationQuotedString(_) =>",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "369:             State::CommentStarted                 => self.comment_started(c),",
      "370:             State::CDataStarted(s)                => self.cdata_started(c, s),",
      "371:             State::DoctypeStarted(s)              => self.doctype_started(c, s),",
      "373:             State::EmptyTagClosing                => self.empty_element_closing(c),",
      "374:             State::CommentClosing(s)              => self.comment_closing(c, s),",
      "375:             State::CDataClosing(s)                => self.cdata_closing(c, s),",
      "",
      "[Removed Lines]",
      "372:             State::DoctypeFinishing(d)            => self.doctype_finishing(c, d),",
      "",
      "[Added Lines]",
      "381:             State::InsideDoctype                  => self.inside_doctype(c),",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "378:             State::InsideCdata                    => self.inside_cdata(c),",
      "379:             State::InsideProcessingInstruction    => self.inside_processing_instruction(c),",
      "380:             State::ProcessingInstructionClosing   => self.processing_instruction_closing(c),",
      "381:         }",
      "382:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "390:             State::InsideMarkupDeclaration       => self.markup_declaration(c),",
      "391:             State::InsideMarkupDeclarationQuotedString(q) => self.markup_declaration_string(c, q),",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "393:         Ok(Some(token))",
      "394:     }",
      "396:     #[inline]",
      "397:     fn move_to_with_unread(&mut self, st: State, cs: &[char], token: Token) -> Result {",
      "398:         self.char_queue.extend(cs.iter().copied());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "407:     #[inline]",
      "408:     fn move_to_and_reset_normal(&mut self, st: State, token: Token) -> Result {",
      "409:         self.normal_state = st;",
      "410:         self.st = st;",
      "411:         Ok(Some(token))",
      "412:     }",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "461:     fn tag_opened(&mut self, c: char) -> Result {",
      "462:         match c {",
      "463:             '?'                        => self.move_to_with(State::InsideProcessingInstruction, Token::ProcessingInstructionStart),",
      "465:             '!'                        => self.move_to(State::CommentOrCDataOrDoctypeStarted),",
      "468:             _                          => self.handle_error(\"<\", c)",
      "469:         }",
      "470:     }",
      "",
      "[Removed Lines]",
      "464:             '/'                        => self.move_to_with(State::Normal, Token::ClosingTagStart),",
      "466:             _ if is_whitespace_char(c) => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),",
      "467:             _ if is_name_char(c)       => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),",
      "",
      "[Added Lines]",
      "483:             '/'                        => self.move_to_with(self.normal_state, Token::ClosingTagStart),",
      "485:             _ if is_whitespace_char(c) => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),",
      "486:             _ if is_name_char(c)       => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "475:             '-' => self.move_to(State::CommentStarted),",
      "476:             '[' => self.move_to(State::CDataStarted(CDataStartedSubstate::E)),",
      "477:             'D' => self.move_to(State::DoctypeStarted(DoctypeStartedSubstate::D)),",
      "478:             _ => self.handle_error(\"<!\", c),",
      "479:         }",
      "480:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "497:             'E' | 'A' | 'N' if matches!(self.normal_state, State::InsideDoctype) => self.move_to_with(State::InsideMarkupDeclaration, Token::MarkupDeclarationStart),",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "500:         )",
      "501:     }",
      "504:     fn doctype_started(&mut self, c: char, s: DoctypeStartedSubstate) -> Result {",
      "505:         use self::DoctypeStartedSubstate::{D, DO, DOC, DOCT, DOCTY, DOCTYP};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "524:     fn markup_declaration(&mut self, c: char) -> Result {",
      "525:         match c {",
      "526:             '<'                        => self.handle_error(\"<!\", c),",
      "527:             '>'                        => self.move_to_with(self.normal_state, Token::TagEnd),",
      "528:             '&'                        => Ok(Some(Token::ReferenceStart)),",
      "529:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
      "530:             '\"'                        => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Double), Token::DoubleQuote),",
      "531:             '\\''                       => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Single), Token::SingleQuote),",
      "532:             _ => Ok(None),",
      "533:         }",
      "534:     }",
      "536:     fn markup_declaration_string(&mut self, c: char, q: QuoteStyle) -> Result {",
      "537:         match c {",
      "538:             '\"' if q == QuoteStyle::Double  => self.move_to_with(State::InsideMarkupDeclaration, Token::DoubleQuote),",
      "539:             '\\'' if q == QuoteStyle::Single => self.move_to_with(State::InsideMarkupDeclaration, Token::SingleQuote),",
      "540:             _ => Ok(None),",
      "541:         }",
      "542:     }",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "509:             DOC    ; 'T' ; DOCT   ; \"<!DOC\",",
      "510:             DOCT   ; 'Y' ; DOCTY  ; \"<!DOCT\",",
      "511:             DOCTY  ; 'P' ; DOCTYP ; \"<!DOCTY\";",
      "513:         )",
      "514:     }",
      "518:         match c {",
      "522:             _ => Ok(None),",
      "523:         }",
      "524:     }",
      "",
      "[Removed Lines]",
      "512:             DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_with(State::DoctypeFinishing(1), Token::DoctypeStart)",
      "517:     fn doctype_finishing(&mut self, c: char, d: u8) -> Result {",
      "519:             '<' => self.move_to(State::DoctypeFinishing(d + 1)),",
      "520:             '>' if d == 1 => self.move_to_with(State::Normal, Token::TagEnd),",
      "521:             '>' => self.move_to(State::DoctypeFinishing(d - 1)),",
      "",
      "[Added Lines]",
      "553:             DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_and_reset_normal(State::InsideDoctype, Token::DoctypeStart)",
      "558:     fn inside_doctype(&mut self, c: char) -> Result {",
      "560:             '>' => self.move_to_and_reset_normal(State::Normal, Token::TagEnd),",
      "561:             '<'                        => self.move_to(State::TagStarted),",
      "562:             '&'                        => Ok(Some(Token::ReferenceStart)),",
      "563:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "527:     fn processing_instruction_closing(&mut self, c: char) -> Result {",
      "528:         match c {",
      "530:             _ => self.move_to_with_unread(State::InsideProcessingInstruction, &[c], Token::Character('?')),",
      "531:         }",
      "532:     }",
      "",
      "[Removed Lines]",
      "529:             '>' => self.move_to_with(State::Normal, Token::ProcessingInstructionEnd),",
      "",
      "[Added Lines]",
      "571:             '>' => self.move_to_with(self.normal_state, Token::ProcessingInstructionEnd),",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "535:     fn empty_element_closing(&mut self, c: char) -> Result {",
      "536:         match c {",
      "539:         }",
      "540:     }",
      "",
      "[Removed Lines]",
      "537:             '>' => self.move_to_with(State::Normal, Token::EmptyTagEnd),",
      "538:             _ => self.move_to_with_unread(State::Normal, &[c], Token::Character('/')),",
      "",
      "[Added Lines]",
      "579:             '>' => self.move_to_with(self.normal_state, Token::EmptyTagEnd),",
      "580:             _ => self.move_to_with_unread(self.normal_state, &[c], Token::Character('/')),",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "547:                 _ => self.move_to_with_unread(State::InsideComment, &[c], Token::Character('-')),",
      "548:             },",
      "549:             ClosingSubstate::Second => match c {",
      "552:                 _ => self.handle_error(\"--\", c),",
      "553:             },",
      "",
      "[Removed Lines]",
      "550:                 '>' => self.move_to_with(State::Normal, Token::CommentEnd),",
      "",
      "[Added Lines]",
      "592:                 '>' => self.move_to_with(self.normal_state, Token::CommentEnd),",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "576:                 _ => self.move_to_with_unread(State::Normal, &[c], Token::Character(']')),",
      "577:             },",
      "578:             ClosingSubstate::Second => match c {",
      "580:                 _ => self.move_to_with_unread(State::Normal, &[']', c], Token::Character(']')),",
      "581:             },",
      "582:         }",
      "",
      "[Removed Lines]",
      "579:                 '>' => self.move_to_with(State::Normal, Token::CDataEnd),",
      "",
      "[Added Lines]",
      "621:                 '>' => self.move_to_with(self.normal_state, Token::CDataEnd),",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "825:     #[test]",
      "826:     fn doctype_with_internal_subset_test() {",
      "827:         let (mut lex, mut buf) = make_lex_and_buf(",
      "829:         );",
      "830:         assert_oks!(for lex and buf ;",
      "831:             Token::OpeningTagStart",
      "832:             Token::Character('a')",
      "833:             Token::TagEnd",
      "834:             Token::DoctypeStart",
      "835:             Token::TagEnd",
      "836:             Token::Whitespace(' ')",
      "837:         );",
      "838:         assert_none!(for lex and buf);",
      "839:     }",
      "841:     #[test]",
      "842:     fn end_of_stream_handling_ok() {",
      "843:         macro_rules! eof_check(",
      "",
      "[Removed Lines]",
      "828:             r#\"<a><!DOCTYPE ab[<!ELEMENT ba> ]> \"#",
      "",
      "[Added Lines]",
      "870:             r#\"<a><!DOCTYPE ab[<!ELEMENT ba \">>>>>\"> ]> \"#",
      "877:             Token::MarkupDeclarationStart",
      "878:             Token::DoubleQuote",
      "879:             Token::DoubleQuote",
      "880:             Token::TagEnd",
      "881:             Token::TagEnd",
      "882:             Token::Whitespace(' ')",
      "883:         );",
      "884:         assert_none!(for lex and buf);",
      "885:     }",
      "887:     #[test]",
      "888:     fn doctype_internal_pi_comment() {",
      "889:         let (mut lex, mut buf) = make_lex_and_buf(",
      "890:             \"<!DOCTYPE a [\\n<!ELEMENT leopard ANY> <!-- <?non?>--> <?pi > ?> \\n]>\"",
      "891:         );",
      "892:         assert_oks!(for lex and buf ;",
      "893:             Token::DoctypeStart",
      "894:             Token::MarkupDeclarationStart",
      "896:             Token::CommentStart",
      "898:             Token::Character('<')",
      "899:             Token::Character('?')",
      "900:             Token::Character('n')",
      "901:             Token::Character('o')",
      "902:             Token::Character('n')",
      "903:             Token::Character('?')",
      "904:             Token::Character('>')",
      "905:             Token::CommentEnd",
      "906:             Token::ProcessingInstructionStart",
      "907:             Token::Character('p')",
      "908:             Token::Character('i')",
      "909:             Token::Whitespace(' ')",
      "910:             Token::TagEnd // not really",
      "911:             Token::Whitespace(' ')",
      "912:             Token::ProcessingInstructionEnd",
      "913:             Token::TagEnd // DTD",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_cdata.rs||src/reader/parser/inside_cdata.rs": [
      "File: src/reader/parser/inside_cdata.rs -> src/reader/parser/inside_cdata.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "7:     pub fn inside_cdata(&mut self, t: Token) -> Option<Result> {",
      "8:         match t {",
      "9:             Token::CDataEnd => {",
      "11:                 let event = if self.config.cdata_to_characters {",
      "12:                     None",
      "13:                 } else {",
      "",
      "[Removed Lines]",
      "10:                 self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs": [
      "File: src/reader/parser/inside_doctype.rs -> src/reader/parser/inside_doctype.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "6:     pub fn inside_doctype(&mut self, t: Token) -> Option<Result> {",
      "7:         match t {",
      "8:             Token::TagEnd => {",
      "10:                 self.into_state_continue(State::OutsideTag)",
      "11:             }",
      "13:             _ => None,",
      "14:         }",
      "15:     }",
      "",
      "[Removed Lines]",
      "9:                 self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "12:             Token::MarkupDeclarationStart => {",
      "13:                 self.into_state_continue(State::InsideDoctypeMarkupDeclaration)",
      "14:             },",
      "16:             _ => None,",
      "17:         }",
      "18:     }",
      "20:     pub fn inside_doctype_markup_declaration(&mut self, t: Token) -> Option<Result> {",
      "21:         match t {",
      "22:             Token::TagEnd => {",
      "23:                 self.into_state_continue(State::InsideDoctype)",
      "24:             }",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs": [
      "File: src/reader/parser/inside_processing_instruction.rs -> src/reader/parser/inside_processing_instruction.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "69:             ProcessingInstructionSubstate::PIInsideData => match t {",
      "70:                 Token::ProcessingInstructionEnd => {",
      "72:                     let name = self.data.take_name();",
      "73:                     let data = self.take_buf();",
      "74:                     self.into_state_emit(",
      "",
      "[Removed Lines]",
      "71:                     self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/reader/parser/mod.rs||src/reader/parser/mod.rs": [
      "File: src/reader/parser/mod.rs -> src/reader/parser/mod.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     InsideCData,",
      "140:     InsideDeclaration(DeclarationSubstate),",
      "141:     InsideDoctype,",
      "142:     InsideReference(Box<State>),",
      "143: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "142:     InsideDoctypeMarkupDeclaration,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "337:             State::InsideProcessingInstruction(s) => self.inside_processing_instruction(t, s),",
      "338:             State::InsideDeclaration(s)           => self.inside_declaration(t, s),",
      "339:             State::InsideDoctype                  => self.inside_doctype(t),",
      "340:             State::InsideOpeningTag(s)            => self.inside_opening_tag(t, s),",
      "341:             State::InsideClosingTag(s)            => self.inside_closing_tag_name(t, s),",
      "342:             State::InsideComment                  => self.inside_comment(t),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "341:             State::InsideDoctypeMarkupDeclaration => self.inside_doctype_markup_declaration(t),",
      "",
      "---------------"
    ],
    "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs": [
      "File: src/reader/parser/outside_tag.rs -> src/reader/parser/outside_tag.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "83:                         self.next_pos();",
      "85:                         self.into_state(State::InsideDoctype, next_event)",
      "86:                     }",
      "",
      "[Removed Lines]",
      "84:                         self.lexer.disable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "tests/xmlconf.rs||tests/xmlconf.rs": [
      "File: tests/xmlconf.rs -> tests/xmlconf.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
      "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
      "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
      "120:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
      "121:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
      "122:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
      "",
      "[Removed Lines]",
      "119:         \"rmt-e2e-24\", // Either the built-in entity or a character reference can be used to represent greater-than after two close-square-brackets",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "279: #[test] fn oasis() {",
      "280:     run_suite(\"oasis/oasis.xml\", &[",
      "285:         \"o-p01fail1\", // S cannot occur before the prolog",
      "286:         \"o-p01fail2\", // comments cannot occur before the prolog",
      "287:         \"o-p01fail3\", // only one document element",
      "288:         \"o-p09fail1\", // EntityValue excludes '%'",
      "289:         \"o-p09fail2\", // EntityValue excludes '&'",
      "290:         \"o-p09fail3\", // incomplete character reference",
      "296:         \"o-p12fail2\", // '\\' excluded",
      "297:         \"o-p12fail3\", // entity references excluded",
      "298:         \"o-p12fail6\", // built-in entity refs excluded",
      "299:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
      "300:         \"o-p14fail3\", // \"]]>\" excluded",
      "",
      "[Removed Lines]",
      "281:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
      "282:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
      "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
      "284:         \"o-p05pass1\", // various valid Name constructions",
      "291:         \"o-p09fail4\", // quote types must match",
      "292:         \"o-p09fail5\", // quote types must match",
      "293:         \"o-p11fail1\", // quote types must match",
      "294:         \"o-p11fail2\", // cannot contain delimiting quotes",
      "295:         \"o-p12fail1\", // '\"' excluded",
      "",
      "[Added Lines]",
      "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
      "284:         \"o-p05pass1\", // various valid Name constructions",
      "288:         \"o-p11pass1\", // p11pass1.xml       system literals may not contain     URI fragments",
      "289:         \"o-p12fail1\", // p12fail1.xml       '\"' excluded",
      "292:         \"o-p12fail4\", // p12fail4.xml       '>' excluded",
      "293:         \"o-p12fail5\", // p12fail5.xml       '<' excluded",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "303:         \"o-p22fail2\", // prolog must start with XML decl",
      "304:         \"o-p23fail1\", // \"xml\" must be lower-case",
      "305:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
      "307:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
      "308:         \"o-p31fail1\", // external subset excludes doctypedecl",
      "309:         \"o-p32fail3\", // initial S is required",
      "310:         \"o-p40fail1\", // S is required between attributes",
      "311:         \"o-p44fail4\", // Whitespace required between attributes.",
      "313:         \"o-p45fail2\", // S before contentspec is required.",
      "314:         \"o-p45fail3\", // only one content spec",
      "315:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
      "",
      "[Removed Lines]",
      "306:         \"o-p29fail1\", // A processor must not pass unknown declaration types.",
      "312:         \"o-p45fail1\", // ELEMENT must be upper case.",
      "",
      "[Added Lines]",
      "306:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "371:         \"o-p64fail1\", // section delimiters must balance",
      "372:         \"o-p64fail2\", // section delimiters must balance",
      "373:         \"o-p66fail5\", // no references to non-characters",
      "374:         \"o-p69fail1\", // terminating ';' is required",
      "375:         \"o-p69fail2\", // no S after '%'",
      "376:         \"o-p69fail3\", // no S before ';'",
      "377:         \"o-p70fail1\", // This is neither",
      "378:         \"o-p71fail1\", // S is required before EntityDef",
      "379:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
      "381:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
      "382:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
      "383:         \"o-p72fail2\", // S is required after '%'",
      "384:         \"o-p72fail3\", // S is required after name",
      "385:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
      "386:         \"o-p73fail1\", // No typed replacement text",
      "387:         \"o-p73fail2\", // Only one replacement value",
      "",
      "[Removed Lines]",
      "380:         \"o-p71fail3\", // no S after \"<!\"",
      "",
      "[Added Lines]",
      "369:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
      "380:         \"o-p76fail4\", // p76fail4.xml       notation names are Names",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "438:         \"content02\", // No whitespace before \"*\" in content model",
      "439:         \"content03\", // No whitespace before \"+\" in content model",
      "440:         \"decl01\", // External entities may not have standalone decls.",
      "443:         \"dtd02\", // PE name immediately after \"%\"",
      "444:         \"dtd03\", // PE name immediately followed by \";\"",
      "445:         \"dtd04\", // PUBLIC literal must be quoted",
      "",
      "[Removed Lines]",
      "441:         \"nwf-dtd00\", // Comma mandatory in content model",
      "442:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "451:         \"encoding04\", // Illegal character \":\" in encoding name",
      "452:         \"encoding05\", // Illegal character \"@\" in encoding name",
      "453:         \"encoding06\", // Illegal character \"+\" in encoding name",
      "454:         \"pubid01\", // Illegal entity ref in public ID",
      "455:         \"pubid02\", // Illegal characters in public ID",
      "456:         \"pubid03\", // Illegal characters in public ID",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "448:         \"nwf-dtd00\", // Comma mandatory in content model",
      "449:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
      "450:         \"pi\", // pi.xml      No space between PI target name and data",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "502:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
      "503:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
      "504:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
      "506:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
      "507:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
      "508:         \"not-wf-sa-066\", // Required whitespace is missing.",
      "",
      "[Removed Lines]",
      "505:         \"not-wf-sa-063\", // Conditional sections may only appear in the external     DTD subset.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "523:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
      "524:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
      "525:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
      "527:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
      "528:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
      "529:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
      "",
      "[Removed Lines]",
      "526:         \"not-wf-sa-107\", // Invalid document type declaration.  CDATA alone is invalid.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "566:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
      "567:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
      "568:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
      "570:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
      "571:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
      "572:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
      "",
      "[Removed Lines]",
      "569:         \"not-wf-sa-179\", // Invalid syntax matching double quote is missing.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "43413df7c85b9730b80fc7a415a14c00a6beb9cb",
      "candidate_info": {
        "commit_hash": "43413df7c85b9730b80fc7a415a14c00a6beb9cb",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/43413df7c85b9730b80fc7a415a14c00a6beb9cb",
        "files": [
          "src/reader/lexer.rs",
          "src/reader/parser/inside_comment.rs",
          "src/reader/parser/mod.rs",
          "src/reader/parser/outside_tag.rs",
          "tests/xmlconf.rs"
        ],
        "message": "Make lexer comment-aware\n\nFixes #220",
        "before_after_code_files": [
          "src/reader/lexer.rs||src/reader/lexer.rs",
          "src/reader/parser/inside_comment.rs||src/reader/parser/inside_comment.rs",
          "src/reader/parser/mod.rs||src/reader/parser/mod.rs",
          "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/reader/lexer.rs||src/reader/lexer.rs",
            "src/reader/parser/mod.rs||src/reader/parser/mod.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "src/reader/lexer.rs||src/reader/lexer.rs",
            "src/reader/parser/mod.rs||src/reader/parser/mod.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/reader/lexer.rs||src/reader/lexer.rs": [
          "File: src/reader/lexer.rs -> src/reader/lexer.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "144: }",
          "146: enum State {",
          "148:     TagStarted,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "148:     Normal,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:     CommentClosing(ClosingSubstate),",
          "166:     CDataClosing(ClosingSubstate),",
          "169: }",
          "171: #[derive(Copy, Clone)]",
          "",
          "[Removed Lines]",
          "168:     Normal,",
          "",
          "[Added Lines]",
          "170:     InsideComment,",
          "172:     InsideCdata,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "222:     char_queue: VecDeque<char>,",
          "223:     st: State,",
          "224:     skip_errors: bool,",
          "226:     inside_token: bool,",
          "227:     eof_handled: bool",
          "228: }",
          "",
          "[Removed Lines]",
          "225:     inside_comment: bool,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "242:             char_queue: VecDeque::with_capacity(4),  // TODO: check size",
          "243:             st: State::Normal,",
          "244:             skip_errors: false,",
          "246:             inside_token: false,",
          "247:             eof_handled: false",
          "248:         }",
          "",
          "[Removed Lines]",
          "245:             inside_comment: false,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "263:     #[inline]",
          "267:     #[inline]",
          "271:     #[inline]",
          "",
          "[Removed Lines]",
          "264:     pub fn inside_comment(&mut self) { self.inside_comment = true; }",
          "268:     pub fn outside_comment(&mut self) { self.inside_comment = false; }",
          "",
          "[Added Lines]",
          "266:     #[deprecated]",
          "267:     pub fn inside_comment(&mut self) { self.st = State::InsideComment; }",
          "271:     #[deprecated]",
          "272:     pub fn outside_comment(&mut self) { self.st = State::Normal; }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:             State::TagStarted | State::CommentOrCDataOrDoctypeStarted |",
          "328:             State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |",
          "329:             State::CommentClosing(ClosingSubstate::Second) |",
          "330:             State::DoctypeFinishing(_) =>",
          "331:                 Err(self.error(\"Unexpected end of stream\")),",
          "332:             State::ProcessingInstructionClosing =>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334:             State::InsideComment | State::InsideCdata |",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "340:             State::CDataClosing(ClosingSubstate::Second) =>",
          "341:                 Ok(Some(Token::Chunk(\"]]\"))),",
          "342:             State::Normal =>",
          "344:         }",
          "345:     }",
          "",
          "[Removed Lines]",
          "343:                 Ok(None)",
          "",
          "[Added Lines]",
          "348:                 Ok(None),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "374:             State::ProcessingInstructionClosing   => self.processing_instruction_closing(c),",
          "375:             State::EmptyTagClosing                => self.empty_element_closing(c),",
          "376:             State::CommentClosing(s)              => self.comment_closing(c, s),",
          "378:         }",
          "379:     }",
          "",
          "[Removed Lines]",
          "377:             State::CDataClosing(s)                => self.cdata_closing(c, s)",
          "",
          "[Added Lines]",
          "382:             State::CDataClosing(s)                => self.cdata_closing(c, s),",
          "383:             State::InsideComment                  => self.inside_comment_state(c),",
          "384:             State::InsideCdata                    => self.inside_cdata(c),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "399:     fn handle_error(&mut self, chunk: &'static str, c: char) -> Result {",
          "400:         self.char_queue.push_back(c);",
          "402:             self.move_to_with(State::Normal, Token::Chunk(chunk))",
          "403:         } else {",
          "404:             Err(self.error(format!(\"Unexpected token '{chunk}' before '{c}'\")))",
          "",
          "[Removed Lines]",
          "401:         if self.skip_errors || (self.inside_comment && chunk != \"--\") {  // FIXME: looks hacky",
          "",
          "[Added Lines]",
          "408:         if self.skip_errors {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "415:             '\"'                        => Ok(Some(Token::DoubleQuote)),",
          "416:             '\\''                       => Ok(Some(Token::SingleQuote)),",
          "417:             '?'                        => self.move_to(State::ProcessingInstructionClosing),",
          "419:             ']'                        => self.move_to(State::CDataClosing(ClosingSubstate::First)),",
          "420:             '&'                        => Ok(Some(Token::ReferenceStart)),",
          "421:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
          "",
          "[Removed Lines]",
          "418:             '-'                        => self.move_to(State::CommentClosing(ClosingSubstate::First)),",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "424:         }",
          "425:     }",
          "428:     fn tag_opened(&mut self, c: char) -> Result {",
          "429:         match c {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433:     fn inside_cdata(&mut self, c: char) -> Result {",
          "434:         match c {",
          "435:             ']'                        => self.move_to(State::CDataClosing(ClosingSubstate::First)),",
          "436:             _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),",
          "437:             _                          => Ok(Some(Token::Character(c)))",
          "438:         }",
          "439:     }",
          "441:     fn inside_comment_state(&mut self, c: char) -> Result {",
          "442:         match c {",
          "443:             '-'                        => self.move_to(State::CommentClosing(ClosingSubstate::First)),",
          "444:             _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),",
          "445:             _                          => Ok(Some(Token::Character(c)))",
          "446:         }",
          "447:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "450:     fn comment_started(&mut self, c: char) -> Result {",
          "451:         match c {",
          "453:             _ => self.handle_error(\"<!-\", c),",
          "454:         }",
          "455:     }",
          "",
          "[Removed Lines]",
          "452:             '-' => self.move_to_with(State::Normal, Token::CommentStart),",
          "",
          "[Added Lines]",
          "474:             '-' => self.move_to_with(State::InsideComment, Token::CommentStart),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "463:             CD    ; 'A' ; CDA   ; \"<![CD\",",
          "464:             CDA   ; 'T' ; CDAT  ; \"<![CDA\",",
          "465:             CDAT  ; 'A' ; CDATA ; \"<![CDAT\";",
          "467:         )",
          "468:     }",
          "",
          "[Removed Lines]",
          "466:             CDATA ; '[' ; \"<![CDATA\" ; self.move_to_with(State::Normal, Token::CDataStart)",
          "",
          "[Added Lines]",
          "488:             CDATA ; '[' ; \"<![CDATA\" ; self.move_to_with(State::InsideCdata, Token::CDataStart)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "511:         match s {",
          "512:             ClosingSubstate::First => match c {",
          "513:                 '-' => self.move_to(State::CommentClosing(ClosingSubstate::Second)),",
          "515:             },",
          "516:             ClosingSubstate::Second => match c {",
          "517:                 '>' => self.move_to_with(State::Normal, Token::CommentEnd),",
          "525:             },",
          "526:         }",
          "527:     }",
          "",
          "[Removed Lines]",
          "514:                 _ => self.move_to_with_unread(State::Normal, &[c], Token::Character('-')),",
          "519:                 _ if self.inside_comment => self.handle_error(\"--\", c),",
          "524:                 _ => self.move_to_with_unread(State::Normal, &[c], Token::Chunk(\"--\")),",
          "",
          "[Added Lines]",
          "536:                 _ => self.move_to_with_unread(State::InsideComment, &[c], Token::Character('-')),",
          "541:                 _ => self.handle_error(\"--\", c),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "706:         assert_none!(for lex and buf);",
          "707:     }",
          "709:     #[test]",
          "710:     fn doctype_with_internal_subset_test() {",
          "711:         let (mut lex, mut buf) = make_lex_and_buf(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "726:     #[test]",
          "727:     fn tricky_comments() {",
          "728:         let (mut lex, mut buf) = make_lex_and_buf(",
          "729:             r#\"<a><!-- C ->--></a>\"#",
          "730:         );",
          "731:         assert_oks!(for lex and buf ;",
          "732:             Token::OpeningTagStart",
          "733:             Token::Character('a')",
          "734:             Token::TagEnd",
          "735:             Token::CommentStart",
          "736:             Token::Whitespace(' ')",
          "737:             Token::Character('C')",
          "738:             Token::Whitespace(' ')",
          "739:             Token::Character('-')",
          "740:             Token::Character('>')",
          "741:             Token::CommentEnd",
          "742:             Token::ClosingTagStart",
          "743:             Token::Character('a')",
          "744:             Token::TagEnd",
          "745:         );",
          "746:         assert_none!(for lex and buf);",
          "747:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "756:         eof_check!(\"<![CDA\"   ; 0, 6);",
          "757:         eof_check!(\"<![CDAT\"  ; 0, 7);",
          "758:         eof_check!(\"<![CDATA\" ; 0, 8);",
          "760:     }",
          "762:     #[test]",
          "",
          "[Removed Lines]",
          "759:         eof_check!(\"--\"       ; 0, 2);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "794:     #[test]",
          "795:     fn error_in_comment_two_dashes_not_at_end() {",
          "796:         let (mut lex, mut buf) = make_lex_and_buf(\"--x\");",
          "798:         assert_err!(for lex and buf expect row 0; 0,",
          "799:             \"Unexpected token '--' before 'x'\"",
          "800:         );",
          "802:         let (mut lex, mut buf) = make_lex_and_buf(\"--x\");",
          "803:         assert_oks!(for lex and buf ;",
          "805:             Token::Character('x')",
          "806:         );",
          "807:     }",
          "",
          "[Removed Lines]",
          "797:         lex.inside_comment();",
          "804:             Token::Chunk(\"--\")",
          "",
          "[Added Lines]",
          "837:         lex.st = super::State::InsideComment;",
          "844:             Token::Character('-')",
          "845:             Token::Character('-')",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_comment.rs||src/reader/parser/inside_comment.rs": [
          "File: src/reader/parser/inside_comment.rs -> src/reader/parser/inside_comment.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:             }",
          "14:             Token::CommentEnd if self.config.ignore_comments => {",
          "16:                 self.into_state_continue(State::OutsideTag)",
          "17:             }",
          "19:             Token::CommentEnd => {",
          "21:                 let data = self.take_buf();",
          "22:                 self.into_state_emit(State::OutsideTag, Ok(XmlEvent::Comment(data)))",
          "23:             }",
          "",
          "[Removed Lines]",
          "15:                 self.lexer.outside_comment();",
          "20:                 self.lexer.outside_comment();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/reader/parser/mod.rs||src/reader/parser/mod.rs": [
          "File: src/reader/parser/mod.rs -> src/reader/parser/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:         expect_event!(r, p, Ok(XmlEvent::EndDocument));",
          "602:     }",
          "604:     #[test]",
          "605:     fn opening_tag_in_attribute_value() {",
          "606:         let (mut r, mut p) = test_data!(r#\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "604:     #[test]",
          "605:     fn issue_220_comment() {",
          "606:         let (mut r, mut p) = test_data!(r#\"<x><!-- <!--></x>\"#);",
          "607:         expect_event!(r, p, Ok(XmlEvent::StartDocument { .. }));",
          "608:         expect_event!(r, p, Ok(XmlEvent::StartElement { .. }));",
          "609:         expect_event!(r, p, Ok(XmlEvent::EndElement { .. }));",
          "610:         expect_event!(r, p, Ok(XmlEvent::EndDocument));",
          "612:         let (mut r, mut p) = test_data!(r#\"<x><!-- <!---></x>\"#);",
          "613:         expect_event!(r, p, Ok(XmlEvent::StartDocument { .. }));",
          "614:         expect_event!(r, p, Ok(XmlEvent::StartElement { .. }));",
          "615:         expect_event!(r, p, Err(_)); // ---> is forbidden in comments",
          "617:         let (mut r, mut p) = test_data!(r#\"<x><!--<text&x;> <!--></x>\"#);",
          "618:         p.config.ignore_comments = false;",
          "619:         expect_event!(r, p, Ok(XmlEvent::StartDocument { .. }));",
          "620:         expect_event!(r, p, Ok(XmlEvent::StartElement { .. }));",
          "621:         expect_event!(r, p, Ok(XmlEvent::Comment(s)) => s == \"<text&x;> <!\");",
          "622:         expect_event!(r, p, Ok(XmlEvent::EndElement { .. }));",
          "623:         expect_event!(r, p, Ok(XmlEvent::EndDocument));",
          "624:     }",
          "",
          "---------------"
        ],
        "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs": [
          "File: src/reader/parser/outside_tag.rs -> src/reader/parser/outside_tag.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:             Token::CommentStart if self.config.coalesce_characters && self.config.ignore_comments => {",
          "49:                 self.into_state_continue(State::InsideComment)",
          "50:             }",
          "",
          "[Removed Lines]",
          "48:                 self.lexer.inside_comment();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:                     Token::CommentStart => {",
          "116:                         self.into_state(State::InsideComment, next_event)",
          "117:                     }",
          "",
          "[Removed Lines]",
          "115:                         self.lexer.inside_comment();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
          "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
          "284:         \"o-p05pass1\", // various valid Name constructions",
          "286:         \"o-p16pass1\", // Valid form of Processing Instruction. Shows that whitespace character data is valid before end of processing instruction.",
          "287:         \"o-p01fail1\", // S cannot occur before the prolog",
          "288:         \"o-p01fail2\", // comments cannot occur before the prolog",
          "",
          "[Removed Lines]",
          "285:         \"o-p15pass1\", // valid comments",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "47f5afceb3cc1b2a67900ca9dc480643ed47537f",
      "candidate_info": {
        "commit_hash": "47f5afceb3cc1b2a67900ca9dc480643ed47537f",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/47f5afceb3cc1b2a67900ca9dc480643ed47537f",
        "files": [
          "src/reader/lexer.rs"
        ],
        "message": "Don't end CDATA state on ]",
        "before_after_code_files": [
          "src/reader/lexer.rs||src/reader/lexer.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/reader/lexer.rs||src/reader/lexer.rs"
          ],
          "candidate": [
            "src/reader/lexer.rs||src/reader/lexer.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/reader/lexer.rs||src/reader/lexer.rs": [
          "File: src/reader/lexer.rs -> src/reader/lexer.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:     EmptyTagClosing,",
          "166:     CommentClosing(ClosingSubstate),",
          "168:     CDataClosing(ClosingSubstate),",
          "170:     InsideComment,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170:     InvalidCDataClosing(ClosingSubstate),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319:         self.eof_handled = true;",
          "320:         self.pos = self.head_pos;",
          "321:         match self.st {",
          "322:             State::TagStarted | State::CommentOrCDataOrDoctypeStarted |",
          "323:             State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |",
          "324:             State::CommentClosing(ClosingSubstate::Second) |",
          "326:             State::InsideProcessingInstruction | State::ProcessingInstructionClosing |",
          "327:             State::DoctypeFinishing(_) =>",
          "328:                 Err(self.error(\"Unexpected end of stream\")),",
          "",
          "[Removed Lines]",
          "325:             State::InsideComment | State::InsideCdata |",
          "",
          "[Added Lines]",
          "324:             State::InsideCdata | State::CDataClosing(_) => Err(self.error(\"Unclosed CDATA\")),",
          "329:             State::InsideComment |",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330:                 Ok(Some(Token::Character('/'))),",
          "331:             State::CommentClosing(ClosingSubstate::First) =>",
          "332:                 Ok(Some(Token::Character('-'))),",
          "334:                 Ok(Some(Token::Character(']'))),",
          "336:                 Ok(Some(Token::Chunk(\"]]\"))),",
          "337:             State::Normal =>",
          "338:                 Ok(None),",
          "",
          "[Removed Lines]",
          "333:             State::CDataClosing(ClosingSubstate::First) =>",
          "335:             State::CDataClosing(ClosingSubstate::Second) =>",
          "",
          "[Added Lines]",
          "337:             State::InvalidCDataClosing(ClosingSubstate::First) =>",
          "339:             State::InvalidCDataClosing(ClosingSubstate::Second) =>",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "369:             State::EmptyTagClosing                => self.empty_element_closing(c),",
          "370:             State::CommentClosing(s)              => self.comment_closing(c, s),",
          "371:             State::CDataClosing(s)                => self.cdata_closing(c, s),",
          "372:             State::InsideComment                  => self.inside_comment_state(c),",
          "373:             State::InsideCdata                    => self.inside_cdata(c),",
          "374:             State::InsideProcessingInstruction    => self.inside_processing_instruction(c),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "376:             State::InvalidCDataClosing(s)         => self.invalid_cdata_closing(c, s),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "412:             '='                        => Ok(Some(Token::EqualsSign)),",
          "413:             '\"'                        => Ok(Some(Token::DoubleQuote)),",
          "414:             '\\''                       => Ok(Some(Token::SingleQuote)),",
          "416:             '&'                        => Ok(Some(Token::ReferenceStart)),",
          "417:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
          "418:             _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),",
          "",
          "[Removed Lines]",
          "415:             ']'                        => self.move_to(State::CDataClosing(ClosingSubstate::First)),",
          "",
          "[Added Lines]",
          "420:             ']'                        => self.move_to(State::InvalidCDataClosing(ClosingSubstate::First)),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "554:         match s {",
          "555:             ClosingSubstate::First => match c {",
          "556:                 ']' => self.move_to(State::CDataClosing(ClosingSubstate::Second)),",
          "557:                 _ => self.move_to_with_unread(State::Normal, &[c], Token::Character(']')),",
          "558:             },",
          "559:             ClosingSubstate::Second => match c {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "562:                 _ => self.move_to_with_unread(State::InsideCdata, &[c], Token::Character(']')),",
          "563:             },",
          "564:             ClosingSubstate::Second => match c {",
          "565:                 '>' => self.move_to_with(State::Normal, Token::CDataEnd),",
          "566:                 _ => self.move_to_with_unread(State::InsideCdata, &[']', c], Token::Character(']')),",
          "567:             },",
          "568:         }",
          "569:     }",
          "572:     fn invalid_cdata_closing(&mut self, c: char, s: ClosingSubstate) -> Result {",
          "573:         match s {",
          "574:             ClosingSubstate::First => match c {",
          "575:                 ']' => self.move_to(State::InvalidCDataClosing(ClosingSubstate::Second)),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "737:         assert_none!(for lex and buf);",
          "738:     }",
          "740:     #[test]",
          "741:     fn doctype_test() {",
          "742:         let (mut lex, mut buf) = make_lex_and_buf(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "759:     #[test]",
          "760:     fn cdata_closers_test() {",
          "761:         let (mut lex, mut buf) = make_lex_and_buf(",
          "762:             r#\"<![CDATA[] > ]> ]]><!---->]]<a>\"#",
          "763:         );",
          "765:         assert_oks!(for lex and buf ;",
          "766:             Token::CDataStart",
          "767:             Token::Character(']')",
          "768:             Token::Whitespace(' ')",
          "769:             Token::Character('>')",
          "770:             Token::Whitespace(' ')",
          "771:             Token::Character(']')",
          "772:             Token::Character('>')",
          "773:             Token::Whitespace(' ')",
          "774:             Token::CDataEnd",
          "775:             Token::CommentStart",
          "776:             Token::CommentEnd",
          "777:             Token::Character(']')",
          "778:             Token::Character(']')",
          "779:             Token::OpeningTagStart",
          "780:             Token::Character('a')",
          "781:             Token::TagEnd",
          "782:         );",
          "783:         assert_none!(for lex and buf);",
          "784:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64d877d1b4604bd297c97a62aba1a1d61e359925",
      "candidate_info": {
        "commit_hash": "64d877d1b4604bd297c97a62aba1a1d61e359925",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/64d877d1b4604bd297c97a62aba1a1d61e359925",
        "files": [
          "tests/errata1e.fail.txt",
          "tests/errata2e.fail.txt",
          "tests/errata3e.fail.txt",
          "tests/errata4e.fail.txt",
          "tests/ht-bh.fail.txt",
          "tests/ibm_oasis_valid.fail.txt",
          "tests/ibm_valid.fail.txt",
          "tests/oasis.fail.txt",
          "tests/rmt-ns10.fail.txt",
          "tests/rmt-ns11.fail.txt",
          "tests/sun-not-wf.fail.txt",
          "tests/sun-valid.fail.txt",
          "tests/xml11.fail.txt",
          "tests/xmlconf.rs",
          "tests/xmltest.fail.txt"
        ],
        "message": "Store test results in external files",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::collections::HashSet;",
          "5: use std::path::Path;",
          "6: use std::collections::HashMap;",
          "7: use std::fs::File;",
          "",
          "[Removed Lines]",
          "4: use std::ffi::OsStr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27: }",
          "29: #[track_caller]",
          "31:     ensure_unzipped();",
          "35:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "36:     let root = suite_path.parent().unwrap();",
          "37:     let mut parsed = 0;",
          "",
          "[Removed Lines]",
          "30: fn run_suite(suite_rel_path: &str, known_broken_tests: &[&str]) {",
          "33:     let known_broken_tests = known_broken_tests.iter().map(|name| name.as_ref()).collect::<HashSet<&OsStr>>();",
          "",
          "[Added Lines]",
          "29: fn run_suite(suite_rel_path: &str) {",
          "33:     let known_failures_file_path = Path::new(\"tests\").join(suite_path.with_extension(\"fail.txt\").file_name().unwrap());",
          "34:     let mut new_known_failures_file = if std::env::var(\"PRINT_SPEC\").map_or(false, |val| val == \"1\") { Some(String::new()) } else { None };",
          "36:     let known_broken_test_ids: HashSet<_> = std::fs::read_to_string(&known_failures_file_path).unwrap_or_default().lines()",
          "37:         .map(|l| l.trim().split(' ').next().unwrap().to_string()).collect();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45:         let e = e.expect(\"testsuite validity\");",
          "46:         match e {",
          "47:             XmlEvent::Characters(chr) => {",
          "49:             },",
          "50:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "51:                 let path = root.join(&attr[\"URI\"]);",
          "",
          "[Removed Lines]",
          "48:                 desc.push_str(&chr.replace('\\n', \" \"));",
          "",
          "[Added Lines]",
          "51:                 desc.push_str(&chr.replace('\\n', \" \").replace(\"  \", \" \").replace(\"  \", \" \"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "53:                 let id = attr[\"ID\"].as_str();",
          "55:                 let res = match test_type {",
          "59:                     other => unimplemented!(\"{other}?? type\"),",
          "60:                 };",
          "70:                 parsed += 1;",
          "71:             },",
          "72:             XmlEvent::StartElement { name, attributes, namespace: _ } if name.local_name == \"TEST\" => {",
          "",
          "[Removed Lines]",
          "56:                     \"valid\" => expect_well_formed(&path, &desc, id),",
          "57:                     \"invalid\" => expect_well_formed(&path, &desc, id), // invalid is still well-formed",
          "58:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc, id),",
          "62:                 let known_bad = known_broken_tests.contains::<OsStr>(id.as_ref());",
          "64:                 match res {",
          "65:                     Err(_) if known_bad => {},",
          "66:                     Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "67:                     Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\\n{desc}\", path.display()),",
          "68:                     Ok(()) => {},",
          "69:                 };",
          "",
          "[Added Lines]",
          "59:                     \"valid\" => expect_well_formed(&path, &desc),",
          "60:                     \"invalid\" => expect_well_formed(&path, &desc), // invalid is still well-formed",
          "61:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc),",
          "65:                 if let Some(out) = new_known_failures_file.as_mut() {",
          "66:                     if let Err(e) = res {",
          "67:                         use std::fmt::Write;",
          "68:                         write!(out, \"{id} {e}\").unwrap();",
          "69:                     }",
          "70:                 } else {",
          "71:                     let known_bad = known_broken_test_ids.contains(id);",
          "72:                     match res {",
          "73:                         Err(_) if known_bad => {},",
          "74:                         Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "75:                         Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\\n{desc}\", path.display()),",
          "76:                         Ok(()) => {},",
          "77:                     };",
          "78:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "78:         }",
          "79:     }",
          "80:     assert!(parsed > 0);",
          "81: }",
          "83: #[track_caller]",
          "85:     let f = BufReader::new(File::open(xml_path)?);",
          "86:     let r = EventReader::new(f);",
          "87:     let mut seen_any = false;",
          "88:     for e in r {",
          "90:         if let XmlEvent::EndElement { .. } = e {",
          "91:             seen_any = true;",
          "92:         }",
          "",
          "[Removed Lines]",
          "84: fn expect_well_formed(xml_path: &Path, msg: &str, id: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "89:         let e = e.map_err(|e| format!(\"\\\"{id}\\\", // {} {msg}; {e}\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?;",
          "",
          "[Added Lines]",
          "90:     if let Some(out) = new_known_failures_file {",
          "91:         std::fs::write(known_failures_file_path, out).unwrap();",
          "92:     }",
          "97: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "102:         let e = e.map_err(|e| format!(\"{} {msg}; {e}\\n\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "96: }",
          "98: #[track_caller]",
          "100:     let f = BufReader::new(File::open(xml_path)?);",
          "101:     let r = EventReader::new(f);",
          "102:     for e in r {",
          "",
          "[Removed Lines]",
          "99: fn expect_ill_formed(xml_path: &Path, msg: &str, id: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "",
          "[Added Lines]",
          "112: fn expect_ill_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "104:             return Ok(());",
          "105:         }",
          "106:     }",
          "108: }",
          "110: #[test] fn eduni_errata_2e() {",
          "125: }",
          "127: #[test] fn eduni_errata_3e() {",
          "132: }",
          "134: #[test] fn eduni_errata_4e() {",
          "149: }",
          "151: #[test] fn eduni_misc_ht() {",
          "153: }",
          "155: #[test] fn eduni_namespaces_10() {",
          "170: }",
          "172: #[test] fn eduni_namespaces_11() {",
          "179: }",
          "181: #[test] fn eduni_namespaces_errata() {",
          "186: }",
          "188: #[test] fn eduni_xml_11() {",
          "220: }",
          "222: #[test] fn ibm_oasis_valid() {",
          "245: }",
          "247: #[test] fn ibm_xml_11() {",
          "276: }",
          "278: #[test] fn oasis() {",
          "400: }",
          "402: #[test] fn sun_valid() {",
          "416: }",
          "418: #[test] fn sun_ill_formed() {",
          "468: }",
          "470: #[ignore]",
          "471: #[test] fn japanese() {",
          "475: }",
          "477: #[test] fn xmltest() {",
          "612: }",
          "",
          "[Removed Lines]",
          "107:     Err(format!(\"\\\"{id}\\\", // {} {msg}\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?",
          "111:     run_suite(\"eduni/errata-2e/errata2e.xml\", &[",
          "112:         \"rmt-e2e-15a\", // Empty content can't contain an entity reference",
          "113:         \"rmt-e2e-15e\", // Element content can contain entity reference if replacement text is whitespace",
          "114:         \"rmt-e2e-15f\", // Element content can contain entity reference if replacement text is whitespace, even if it came from a character reference in the literal entity value",
          "115:         \"rmt-e2e-15h\", // Element content can't contain entity reference if replacement text is character reference to whitespace",
          "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
          "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
          "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
          "119:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
          "120:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
          "121:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
          "122:         \"rmt-e2e-57\", // A value other than preserve or default for xml:space is an error",
          "123:         \"rmt-e2e-61\", // (From John Cowan) An encoding declaration in ASCII specifying an encoding that is not compatible with ASCII (so the document is not in its declared encoding).  It should generate a fatal error.",
          "124:     ]);",
          "128:     run_suite(\"eduni/errata-3e/errata3e.xml\", &[",
          "129:         \"rmt-e3e-12\", // E12.xml Default values for attributes may not contain references to external entities.",
          "130:         \"rmt-e3e-13\", // E13.xml Even internal parameter entity references are enough to make undeclared entities into mere validity errors rather than well-formedness errors.",
          "131:     ]);",
          "135:     run_suite(\"eduni/errata-4e/errata4e.xml\", &[",
          "136:         \"invalid-bo-1\", // inclbom_be.xml Byte order mark in general entity should go away (big-endian)",
          "137:         \"invalid-bo-2\", // inclbom_le.xml Byte order mark in general entity should go away (little-endian)",
          "138:         \"invalid-bo-3\", // incl8bom.xml Byte order mark in general entity should go away (utf-8)",
          "139:         \"invalid-bo-4\", // inclbombom_be.xml Two byte order marks in general entity produce only one (big-endian)",
          "140:         \"invalid-bo-5\", // inclbombom_le.xml Two byte order marks in general entity produce only one (little-endian)",
          "141:         \"invalid-bo-6\", // incl8bombom.xml Two byte order marks in general entity produce only one (utf-8)",
          "142:         \"invalid-sa-140\", // 140.xml Character '&#x309a;' is a CombiningChar, not a Letter, but as of 5th edition, may begin a name (c.f. xmltest/not-wf/sa/140.xml).",
          "143:         \"invalid-sa-141\", // 141.xml As of 5th edition, character #x0E5C is legal in XML names (c.f. xmltest/not-wf/sa/141.xml).",
          "144:         \"x-rmt-008b\", // 008.xml a document with version=1.7, legal in XML 1.0 from 5th edition",
          "145:         \"x-ibm-1-0.5-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal characters for production 04.",
          "146:         \"x-ibm-1-0.5-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "147:         \"x-ibm-1-0.5-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "148:     ]);",
          "152:     run_suite(\"eduni/misc/ht-bh.xml\", &[]);",
          "156:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\", &[",
          "157:         \"rmt-ns10-004\", // Namespace name test: a relative URI (deprecated)",
          "158:         \"rmt-ns10-005\", // Namespace name test: a same-document relative URI (deprecated)",
          "159:         \"rmt-ns10-009\", // Namespace equality test: plain repetition",
          "160:         \"rmt-ns10-010\", // Namespace equality test: use of character reference",
          "161:         \"rmt-ns10-012\", // Namespace inequality test: equal after attribute value normalization",
          "162:         \"rmt-ns10-030\", // Reserved prefixes and namespaces: binding another prefix to the xml namespace",
          "163:         \"rmt-ns10-033\", // Reserved prefixes and namespaces: binding another prefix to the xmlns namespace",
          "164:         \"rmt-ns10-036\", // Attribute uniqueness: repeated attribute with different prefixes",
          "165:         \"rmt-ns10-042\", // Colon in PI name",
          "166:         \"rmt-ns10-043\", // Colon in entity name",
          "167:         \"rmt-ns10-044\", // Colon in entity name",
          "168:         \"ht-ns10-047\", // Reserved name: _not_ an error",
          "169:     ]);",
          "173:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\", &[",
          "174:         \"rmt-ns11-001\", // 001.xml Namespace name test: a perfectly good http IRI that is not a URI",
          "175:         \"rmt-ns11-002\", // 002.xml Namespace inequality test: different escaping of non-ascii letter",
          "176:         \"rmt-ns11-003\", // 003.xml 1.1 style prefix unbinding",
          "177:         \"rmt-ns11-004\", // 004.xml 1.1 style prefix unbinding and rebinding",
          "178:     ]);",
          "182:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\", &[",
          "183:         \"rmt-ns-e1.0-13a\", // NE13a.xml The xml namespace must not be declared as the default namespace.",
          "184:         \"rmt-ns-e1.0-13b\", // NE13b.xml The xmlns namespace must not be declared as the default namespace.",
          "185:     ]);",
          "189:     run_suite(\"eduni/xml-1.1/xml11.xml\", &[",
          "190:         \"rmt-001\", // 001.xml External subset has later version number",
          "191:         \"rmt-002\", // 002.xml External PE has later version number",
          "192:         \"rmt-006\", // 006.xml Second-level external general entity has later version number than first-level, but not later than document, so not an error.",
          "193:         \"rmt-010\", // 010.xml Contains a C1 control, legal in XML 1.0, illegal in XML 1.1",
          "194:         \"rmt-013\", // 013.xml Contains a DEL, legal in XML 1.0, illegal in XML 1.1",
          "195:         \"rmt-014\", // 014.xml Has a \"long s\" in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "196:         \"rmt-016\", // 016.xml Has a Byzantine Musical Symbol Kratimata in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "197:         \"rmt-019\", // 019.xml Has the last legal namechar in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "198:         \"rmt-022\", // 022.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "199:         \"rmt-023\", // 023.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "200:         \"rmt-026\", // 026.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "201:         \"rmt-027\", // 027.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "202:         \"rmt-030\", // 030.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "203:         \"rmt-031\", // 031.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "204:         \"rmt-034\", // 034.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "205:         \"rmt-035\", // 035.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "206:         \"rmt-036\", // 036.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "207:         \"rmt-037\", // 037.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "208:         \"rmt-038\", // 038.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "209:         \"rmt-039\", // 039.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "210:         \"rmt-040\", // 040.xml Contains a C1 control character (partial line up), legal in XML 1.0 but not 1.1",
          "211:         \"rmt-042\", // 042.xml Contains a character reference to a C0 control character (form-feed), legal in XML 1.1 but not 1.0",
          "212:         \"rmt-046\", // 046.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "213:         \"rmt-047\", // 047.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "214:         \"rmt-050\", // 050.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "215:         \"rmt-051\", // 051.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "216:         \"rmt-052\", // 052.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "217:         \"rmt-053\", // 053.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "218:         \"rmt-054\", // 054.xml Contains a character reference to a C0 control character (form-feed) in an entity value.  This will be legal (in XML 1.1) when the entity declaration is parsed, but what about when it is used?",
          "219:     ]);",
          "223:     run_suite(\"ibm/ibm_oasis_valid.xml\", &[",
          "224:         \"ibm-valid-P09-ibm09v01.xml\", // ibm09v01.xml Empty EntityValue is legal",
          "225:         \"ibm-valid-P09-ibm09v02.xml\", // ibm09v02.xml Tests a normal EnitityValue",
          "226:         \"ibm-valid-P09-ibm09v03.xml\", // ibm09v03.xml Tests EnitityValue referencing a Parameter Entity",
          "227:         \"ibm-valid-P09-ibm09v04.xml\", // ibm09v04.xml Tests EnitityValue referencing a General Entity",
          "228:         \"ibm-valid-P09-ibm09v05.xml\", // ibm09v05.xml Tests EnitityValue with combination of GE, PE and text, the GE used is      declared in the student.dtd",
          "229:         \"ibm-valid-P10-ibm10v01.xml\", // ibm10v01.xml Tests empty AttValue with double quotes as the delimiters",
          "230:         \"ibm-valid-P10-ibm10v02.xml\", // ibm10v02.xml Tests empty AttValue with single quotes as the delimiters",
          "231:         \"ibm-valid-P10-ibm10v03.xml\", // ibm10v03.xml Test AttValue with double quotes as the delimiters and single quote inside",
          "232:         \"ibm-valid-P10-ibm10v04.xml\", // ibm10v04.xml Test AttValue with single quotes as the delimiters and double quote inside",
          "233:         \"ibm-valid-P10-ibm10v05.xml\", // ibm10v05.xml Test AttValue with a GE reference and double quotes as the delimiters",
          "234:         \"ibm-valid-P10-ibm10v06.xml\", // ibm10v06.xml Test AttValue with a GE reference and single quotes as the delimiters",
          "235:         \"ibm-valid-P10-ibm10v07.xml\", // ibm10v07.xml testing AttValue with mixed references and text content in double quotes",
          "236:         \"ibm-valid-P10-ibm10v08.xml\", // ibm10v08.xml testing AttValue with mixed references and text content in single quotes",
          "237:         \"ibm-valid-P28-ibm28v02.xml\", // ibm28v02.xml Tests doctypedecl with external subset and combinations of different markup     declarations and PEReferences",
          "238:         \"ibm-valid-P29-ibm29v01.xml\", // ibm29v01.xml Tests markupdecl with combinations of elementdecl, AttlistDecl,EntityDecl,      NotationDecl, PI and comment",
          "239:         \"ibm-valid-P29-ibm29v02.xml\", // ibm29v02.xml Tests WFC: PE in internal subset as a positive test",
          "240:         \"ibm-valid-P32-ibm32v02.xml\", // ibm32v02.xml Tests VC: Standalone Document Declaration with external entity reference     and standalone is no",
          "241:         \"ibm-valid-P43-ibm43v01.xml\", // ibm43v01.xml Tests content with all possible constructs: element, CharData, Reference,      CDSect, Comment",
          "242:         \"ibm-valid-P67-ibm67v01.xml\", // ibm67v01.xml Tests Reference could be EntityRef or CharRef.",
          "243:         \"ibm-valid-P78-ibm78v01.xml\", // ibm78v01.xml Tests ExtParsedEnt, also TextDecl in P77 and EncodingDecl in P80",
          "244:     ]);",
          "248:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\", &[",
          "249:         \"ibm-1-1-valid-P02-ibm02v04.xml\", // ibm02v04.xml This test case contains embeded whitespace characters                   some form the range 1 - 1F.",
          "250:         \"ibm-1-1-valid-P03-ibm03v01.xml\", // ibm03v01.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "251:         \"ibm-1-1-valid-P03-ibm03v02.xml\", // ibm03v02.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "252:         \"ibm-1-1-valid-P03-ibm03v03.xml\", // ibm03v03.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "253:         \"ibm-1-1-valid-P03-ibm03v04.xml\", // ibm03v04.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "254:         \"ibm-1-1-valid-P03-ibm03v05.xml\", // ibm03v05.xml The two character sequence #x0D #x85 in a document entity must be normalized to a          single newline.",
          "255:         \"ibm-1-1-valid-P03-ibm03v06.xml\", // ibm03v06.xml The single character sequence #x85 in a document entity must be normalized to a          single newline.",
          "256:         \"ibm-1-1-valid-P03-ibm03v07.xml\", // ibm03v07.xml The single character sequence #x2028 in a document entity must be normalized to a          single newline.",
          "257:         \"ibm-1-1-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal          characters for production 04.",
          "258:         \"ibm-1-1-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "259:         \"ibm-1-1-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "260:         \"ibm-1-1-valid-P77-ibm77v04.xml\", // ibm77v04.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xD6 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "261:         \"ibm-1-1-valid-P77-ibm77v05.xml\", // ibm77v05.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #x1FFF which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "262:         \"ibm-1-1-valid-P77-ibm77v06.xml\", // ibm77v06.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xF901 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "263:         \"ibm-1-1-valid-P77-ibm77v10.xml\", // ibm77v10.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF6.",
          "264:         \"ibm-1-1-valid-P77-ibm77v11.xml\", // ibm77v11.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #x1FFF.",
          "265:         \"ibm-1-1-valid-P77-ibm77v12.xml\", // ibm77v12.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF901.",
          "266:         \"ibm-1-1-valid-P77-ibm77v16.xml\", // ibm77v16.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x2FF.",
          "267:         \"ibm-1-1-valid-P77-ibm77v17.xml\", // ibm77v17.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x1FFF.",
          "268:         \"ibm-1-1-valid-P77-ibm77v18.xml\", // ibm77v18.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #xF901.",
          "269:         \"ibm-1-1-valid-P77-ibm77v22.xml\", // ibm77v22.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x7F.",
          "270:         \"ibm-1-1-valid-P77-ibm77v23.xml\", // ibm77v23.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x80.",
          "271:         \"ibm-1-1-valid-P77-ibm77v24.xml\", // ibm77v24.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x9F.",
          "272:         \"ibm-1-1-valid-P77-ibm77v28.xml\", // ibm77v28.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x7F, #x80, #x9F.",
          "273:         \"ibm-1-1-valid-P77-ibm77v29.xml\", // ibm77v29.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x85, #x8F.",
          "274:         \"ibm-1-1-valid-P77-ibm77v30.xml\", // ibm77v30.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.",
          "275:     ]);",
          "279:     run_suite(\"oasis/oasis.xml\", &[",
          "280:         \"o-p01fail1\", // S cannot occur before the prolog",
          "281:         \"o-p01fail2\", // comments cannot occur before the prolog",
          "282:         \"o-p01fail3\", // only one document element",
          "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
          "284:         \"o-p05pass1\", // various valid Name constructions",
          "285:         \"o-p09fail1\", // EntityValue excludes '%'",
          "286:         \"o-p09fail2\", // EntityValue excludes '&'",
          "287:         \"o-p09fail3\", // incomplete character reference",
          "288:         \"o-p11pass1\", // p11pass1.xml       system literals may not contain     URI fragments",
          "289:         \"o-p12fail1\", // p12fail1.xml       '\"' excluded",
          "290:         \"o-p12fail2\", // '\\' excluded",
          "291:         \"o-p12fail3\", // entity references excluded",
          "292:         \"o-p12fail4\", // p12fail4.xml       '>' excluded",
          "293:         \"o-p12fail5\", // p12fail5.xml       '<' excluded",
          "294:         \"o-p12fail6\", // built-in entity refs excluded",
          "295:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
          "296:         \"o-p14fail3\", // \"]]>\" excluded",
          "297:         \"o-p18fail3\", // CDSect's can't nest",
          "298:         \"o-p22fail1\", // prolog must start with XML decl",
          "299:         \"o-p22fail2\", // prolog must start with XML decl",
          "300:         \"o-p23fail1\", // \"xml\" must be lower-case",
          "301:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
          "302:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
          "303:         \"o-p31fail1\", // external subset excludes doctypedecl",
          "304:         \"o-p32fail3\", // initial S is required",
          "305:         \"o-p40fail1\", // S is required between attributes",
          "306:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
          "307:         \"o-p44fail4\", // Whitespace required between attributes.",
          "308:         \"o-p45fail2\", // S before contentspec is required.",
          "309:         \"o-p45fail3\", // only one content spec",
          "310:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
          "311:         \"o-p46fail1\", // no parens on declared content",
          "312:         \"o-p46fail2\", // no inclusions (contrast with SGML)",
          "313:         \"o-p46fail3\", // no exclusions (contrast with SGML)",
          "314:         \"o-p46fail4\", // no space before occurrence",
          "315:         \"o-p46fail5\", // single group",
          "316:         \"o-p46fail6\", // can't be both declared and modeled",
          "317:         \"o-p47fail1\", // Invalid operator '|' must match previous operator ','",
          "318:         \"o-p47fail2\", // Illegal character '-' in Element-content model",
          "319:         \"o-p47fail3\", // Optional character must follow a name or list",
          "320:         \"o-p47fail4\", // Illegal space before optional character",
          "321:         \"o-p48fail1\", // Illegal space before optional character",
          "322:         \"o-p48fail2\", // Illegal space before optional character",
          "323:         \"o-p51fail1\", // occurrence on #PCDATA group must be *",
          "324:         \"o-p51fail2\", // occurrence on #PCDATA group must be *",
          "325:         \"o-p51fail3\", // #PCDATA must come first",
          "326:         \"o-p51fail4\", // occurrence on #PCDATA group must be *",
          "327:         \"o-p51fail5\", // only '|' connectors",
          "328:         \"o-p51fail6\", // Only '|' connectors and occurrence on #PCDATA group must be *",
          "329:         \"o-p51fail7\", // no nested groups",
          "330:         \"o-p52fail1\", // A name is required",
          "331:         \"o-p52fail2\", // A name is required",
          "332:         \"o-p53fail1\", // S is required before default",
          "333:         \"o-p53fail2\", // S is required before type",
          "334:         \"o-p53fail3\", // type is required",
          "335:         \"o-p53fail4\", // default is required",
          "336:         \"o-p53fail5\", // name is requried",
          "337:         \"o-p54fail1\", // don't pass unknown attribute types",
          "338:         \"o-p55fail1\", // must be upper case",
          "339:         \"o-p56fail1\", // no IDS type",
          "340:         \"o-p56fail2\", // no NUMBER type",
          "341:         \"o-p56fail3\", // no NAME type",
          "342:         \"o-p56fail4\", // no ENTITYS type - types must be upper case",
          "343:         \"o-p56fail5\", // types must be upper case",
          "344:         \"o-p57fail1\", // no keyword for NMTOKEN enumeration",
          "345:         \"o-p58fail1\", // at least one value required",
          "346:         \"o-p58fail2\", // separator must be '|'",
          "347:         \"o-p58fail3\", // notations are NAMEs, not NMTOKENs -- note:     Leaving the invalid           notation undeclared would cause a validating parser to fail without           checking the name syntax, so the notation is declared with an           invalid name.  A parser that reports error positions should report           an error at the AttlistDecl on line 6, before reaching the notation           declaration.",
          "348:         \"o-p58fail4\", // NOTATION must be upper case",
          "349:         \"o-p58fail5\", // S after keyword is required",
          "350:         \"o-p58fail6\", // parentheses are require",
          "351:         \"o-p58fail7\", // values are unquoted",
          "352:         \"o-p58fail8\", // values are unquoted",
          "353:         \"o-p59fail1\", // at least one required",
          "354:         \"o-p59fail2\", // separator must be \",\"",
          "355:         \"o-p59fail3\", // values are unquoted",
          "356:         \"o-p60fail1\", // keywords must be upper case",
          "357:         \"o-p60fail2\", // S is required after #FIXED",
          "358:         \"o-p60fail3\", // only #FIXED has both keyword and value",
          "359:         \"o-p60fail4\", // #FIXED required value",
          "360:         \"o-p60fail5\", // only one default type",
          "361:         \"o-p61fail1\", // no other types, including TEMP, which is valid in SGML",
          "362:         \"o-p62fail1\", // INCLUDE must be upper case",
          "363:         \"o-p62fail2\", // no spaces in terminating delimiter",
          "364:         \"o-p63fail1\", // IGNORE must be upper case",
          "365:         \"o-p63fail2\", // delimiters must be balanced",
          "366:         \"o-p64fail1\", // section delimiters must balance",
          "367:         \"o-p64fail2\", // section delimiters must balance",
          "368:         \"o-p66fail5\", // no references to non-characters",
          "369:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
          "370:         \"o-p69fail1\", // terminating ';' is required",
          "371:         \"o-p69fail2\", // no S after '%'",
          "372:         \"o-p69fail3\", // no S before ';'",
          "373:         \"o-p70fail1\", // This is neither",
          "374:         \"o-p71fail1\", // S is required before EntityDef",
          "375:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
          "376:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
          "377:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
          "378:         \"o-p72fail2\", // S is required after '%'",
          "379:         \"o-p72fail3\", // S is required after name",
          "380:         \"o-p76fail4\", // p76fail4.xml       notation names are Names",
          "381:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
          "382:         \"o-p73fail1\", // No typed replacement text",
          "383:         \"o-p73fail2\", // Only one replacement value",
          "384:         \"o-p73fail3\", // No NDataDecl on replacement text",
          "385:         \"o-p73fail4\", // Value is required",
          "386:         \"o-p73fail5\", // No NDataDecl without value",
          "387:         \"o-p74fail1\", // no NDataDecls on parameter entities",
          "388:         \"o-p74fail2\", // value is required",
          "389:         \"o-p74fail3\", // only one value",
          "390:         \"o-p75fail1\", // S required after \"PUBLIC\"",
          "391:         \"o-p75fail2\", // S required after \"SYSTEM\"",
          "392:         \"o-p75fail3\", // S required between literals",
          "393:         \"o-p75fail4\", // \"SYSTEM\" implies only one literal",
          "394:         \"o-p75fail5\", // only one keyword",
          "395:         \"o-p75fail6\", // \"PUBLIC\" requires two literals (contrast with SGML)",
          "396:         \"o-p76fail1\", // S is required before \"NDATA\"",
          "397:         \"o-p76fail2\", // \"NDATA\" is upper-case",
          "398:         \"o-p76fail3\", // notation name is required",
          "399:     ]);",
          "403:     run_suite(\"sun/sun-valid.xml\", &[",
          "404:         \"ext01\", // Tests use of external parsed entities with and without content.",
          "405:         \"ext02\", // Tests use of external parsed entities with different    encodings than the base document.",
          "406:         \"not-sa02\", // A non-standalone document is valid if declared as such.",
          "407:         \"not-sa03\", // A non-standalone document is valid if declared as such.",
          "408:         \"not-sa04\", // A non-standalone document is valid if declared as such.",
          "409:         \"sa02\", // A document may be marked 'standalone' if any     attributes that need normalization are  defined within the internal DTD subset.",
          "410:         \"sa03\", // A document may be marked 'standalone' if any     the defined entities need expanding are internal,     and no attributes need defaulting or normalization.     On output, requires notations to be correctly reported.",
          "411:         \"sa04\", // Like sa03 but relies on attribute     defaulting defined in the internal subset.     On output, requires notations to be correctly reported.",
          "412:         \"v-pe00\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "413:         \"v-pe03\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "414:         \"v-pe02\", // Tests construction of internal entity replacement text, using     a complex example in the XML specification.",
          "415:     ]);",
          "419:     run_suite(\"sun/sun-not-wf.xml\", &[",
          "420:         \"attlist01\", // SGML's NUTOKEN is not allowed.",
          "421:         \"attlist02\", // SGML's NUTOKENS attribute type is not allowed.",
          "422:         \"attlist03\", // Comma doesn't separate enumerations, unlike in SGML.",
          "423:         \"attlist04\", // SGML's NUMBER attribute type is not allowed.",
          "424:         \"attlist05\", // SGML's NUMBERS attribute type is not allowed.",
          "425:         \"attlist06\", // SGML's NAME attribute type is not allowed.",
          "426:         \"attlist07\", // SGML's NAMES attribute type is not allowed.",
          "427:         \"attlist08\", // SGML's #CURRENT is not allowed.",
          "428:         \"attlist09\", // SGML's #CONREF is not allowed.",
          "429:         \"attlist10\", // Whitespace required between attributes",
          "430:         \"attlist11\", // Whitespace required between attributes",
          "431:         \"cond01\", // Only INCLUDE and IGNORE are conditional section keywords",
          "432:         \"cond02\", // Must have keyword in conditional sections",
          "433:         \"content01\", // No whitespace before \"?\" in content model",
          "434:         \"content02\", // No whitespace before \"*\" in content model",
          "435:         \"content03\", // No whitespace before \"+\" in content model",
          "436:         \"decl01\", // External entities may not have standalone decls.",
          "437:         \"dtd02\", // PE name immediately after \"%\"",
          "438:         \"dtd03\", // PE name immediately followed by \";\"",
          "439:         \"dtd04\", // PUBLIC literal must be quoted",
          "440:         \"dtd05\", // SYSTEM identifier must be quoted",
          "441:         \"dtd07\", // Text declarations (which optionally begin any external entity)     are required to have \"encoding=...\".",
          "442:         \"encoding01\", // Illegal character \" \" in encoding name",
          "443:         \"encoding02\", // Illegal character \"/\" in encoding name",
          "444:         \"encoding03\", // Illegal character reference in encoding name",
          "445:         \"encoding04\", // Illegal character \":\" in encoding name",
          "446:         \"encoding05\", // Illegal character \"@\" in encoding name",
          "447:         \"encoding06\", // Illegal character \"+\" in encoding name",
          "448:         \"nwf-dtd00\", // Comma mandatory in content model",
          "449:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
          "450:         \"pi\", // pi.xml      No space between PI target name and data",
          "451:         \"pubid01\", // Illegal entity ref in public ID",
          "452:         \"pubid02\", // Illegal characters in public ID",
          "453:         \"pubid03\", // Illegal characters in public ID",
          "454:         \"pubid04\", // Illegal characters in public ID",
          "455:         \"pubid05\", // SGML-ism:  public ID without system ID",
          "456:         \"sgml02\", // XML declaration must be at the very beginning of a document;   it\"s not a processing instruction",
          "457:         \"sgml04\", // ATTLIST declarations apply to only one element, unlike SGML",
          "458:         \"sgml05\", // ELEMENT declarations apply to only one element, unlike SGML",
          "459:         \"sgml06\", // ATTLIST declarations are never global, unlike in SGML",
          "460:         \"sgml07\", // SGML Tag minimization specifications are not allowed",
          "461:         \"sgml08\", // SGML Tag minimization specifications are not allowed",
          "462:         \"sgml09\", // SGML Content model exception specifications are not allowed",
          "463:         \"sgml10\", // SGML Content model exception specifications are not allowed",
          "464:         \"sgml11\", // CDATA is not a valid content model spec",
          "465:         \"sgml12\", // RCDATA is not a valid content model spec",
          "466:         \"sgml13\", // SGML Unordered content models not allowed",
          "467:     ]);",
          "472:     run_suite(\"japanese/japanese.xml\", &[",
          "473:         \"pr-xml-little-endian.xml\"  // needs DTD",
          "474:     ]);",
          "478:     run_suite(\"xmltest/xmltest.xml\", &[",
          "479:         \"not-wf-sa-003\", // Processing Instruction target name is required.",
          "480:         \"not-wf-sa-025\", // Text may not contain a literal ']]>' sequence.",
          "481:         \"not-wf-sa-026\", // Text may not contain a literal ']]>' sequence.",
          "482:         \"not-wf-sa-029\", // Text may not contain a literal ']]>' sequence.",
          "483:         \"not-wf-sa-030\", // A form feed is not a legal XML character.",
          "484:         \"not-wf-sa-031\", // A form feed is not a legal XML character.",
          "485:         \"not-wf-sa-032\", // A form feed is not a legal XML character.",
          "486:         \"not-wf-sa-033\", // An ESC (octal 033) is not a legal XML character.",
          "487:         \"not-wf-sa-037\", // Character references may not appear after the root element.",
          "488:         \"not-wf-sa-040\", // Provides two document elements.",
          "489:         \"not-wf-sa-041\", // Provides two document elements.",
          "490:         \"not-wf-sa-044\", // Provides two document elements.",
          "491:         \"not-wf-sa-048\", // Provides a CDATA section after the root element.",
          "492:         \"not-wf-sa-051\", // CDATA is invalid at top level of document.",
          "493:         \"not-wf-sa-052\", // Invalid character reference.",
          "494:         \"not-wf-sa-054\", // PUBLIC requires two literals.",
          "495:         \"not-wf-sa-056\", // Invalid Document Type Definition format - misplaced comment.",
          "496:         \"not-wf-sa-057\", // This isn't SGML; comments can't exist in declarations.",
          "497:         \"not-wf-sa-058\", // Invalid character , in ATTLIST enumeration",
          "498:         \"not-wf-sa-059\", // String literal must be in quotes.",
          "499:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
          "500:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
          "501:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
          "502:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "503:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
          "504:         \"not-wf-sa-066\", // Required whitespace is missing.",
          "505:         \"not-wf-sa-067\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "506:         \"not-wf-sa-068\", // Space is required between NOTATION keyword and list of     enumerated choices in <!ATTLIST...> declarations.",
          "507:         \"not-wf-sa-069\", // Space is required before an NDATA entity annotation.",
          "508:         \"not-wf-sa-078\", // Undefined ENTITY foo.",
          "509:         \"not-wf-sa-079\", // ENTITY can't reference itself directly or indirectly.",
          "510:         \"not-wf-sa-080\", // ENTITY can't reference itself directly or indirectly.",
          "511:         \"not-wf-sa-082\", // This tests the No External Entity References WFC,     since the entity is referred to within an attribute.",
          "512:         \"not-wf-sa-084\", // Tests the Parsed Entity WFC by referring to an     unparsed entity.  (This precedes the error of not declaring     that entity's notation, which may be detected any time before     the DTD parsing is completed.)",
          "513:         \"not-wf-sa-085\", // Public IDs may not contain \"[\".",
          "514:         \"not-wf-sa-086\", // Public IDs may not contain \"[\".",
          "515:         \"not-wf-sa-087\", // Public IDs may not contain \"[\".",
          "516:         \"not-wf-sa-089\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "517:         \"not-wf-sa-091\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "518:         \"not-wf-sa-096\", // Space is required before the standalone declaration.",
          "519:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
          "520:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
          "521:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
          "522:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
          "523:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
          "524:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
          "525:         \"not-wf-sa-122\", // Invalid syntax mixed connectors are used.",
          "526:         \"not-wf-sa-123\", // Invalid syntax mismatched parenthesis.",
          "527:         \"not-wf-sa-124\", // Invalid format of Mixed-content declaration.",
          "528:         \"not-wf-sa-125\", // Invalid syntax extra set of parenthesis not necessary.",
          "529:         \"not-wf-sa-126\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "530:         \"not-wf-sa-127\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "531:         \"not-wf-sa-128\", // Invalid CDATA syntax.",
          "532:         \"not-wf-sa-129\", // Invalid syntax for Element Type Declaration.",
          "533:         \"not-wf-sa-130\", // Invalid syntax for Element Type Declaration.",
          "534:         \"not-wf-sa-131\", // Invalid syntax for Element Type Declaration.",
          "535:         \"not-wf-sa-132\", // Invalid syntax mixed connectors used.",
          "536:         \"not-wf-sa-133\", // Illegal whitespace before optional character causes syntax error.",
          "537:         \"not-wf-sa-134\", // Illegal whitespace before optional character causes syntax error.",
          "538:         \"not-wf-sa-135\", // Invalid character used as connector.",
          "539:         \"not-wf-sa-136\", // Tag omission is invalid in XML.",
          "540:         \"not-wf-sa-137\", // Space is required before a content model.",
          "541:         \"not-wf-sa-138\", // Invalid syntax for content particle.",
          "542:         \"not-wf-sa-139\", // The element-content model should not be empty.",
          "543:         \"not-wf-sa-143\", // Character #x001F is not legal anywhere in an XML document.",
          "544:         \"not-wf-sa-144\", // Character #xFFFF is not legal anywhere in an XML document.",
          "545:         \"not-wf-sa-147\", // XML Declaration may not be preceded by whitespace.",
          "546:         \"not-wf-sa-148\", // XML Declaration may not be preceded by comments or whitespace.",
          "547:         \"not-wf-sa-149\", // XML Declaration may not be within a DTD.",
          "548:         \"not-wf-sa-154\", // '<?XML ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "549:         \"not-wf-sa-155\", // '<?xmL ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "550:         \"not-wf-sa-158\", // SGML-ism:  \"#NOTATION gif\" can't have attributes.",
          "551:         \"not-wf-sa-160\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "552:         \"not-wf-sa-161\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "553:         \"not-wf-sa-162\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "554:         \"not-wf-sa-164\", // Invalid placement of Parameter entity reference.",
          "555:         \"not-wf-sa-165\", // Parameter entity declarations must have a space before     the '%'.",
          "556:         \"not-wf-sa-166\", // Character FFFF is not legal anywhere in an XML document.",
          "557:         \"not-wf-sa-167\", // Character FFFE is not legal anywhere in an XML document.",
          "558:         \"not-wf-sa-171\", // Character FFFF is not legal anywhere in an XML document.",
          "559:         \"not-wf-sa-172\", // Character FFFF is not legal anywhere in an XML document.",
          "560:         \"not-wf-sa-173\", // Character FFFF is not legal anywhere in an XML document.",
          "561:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
          "562:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
          "563:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
          "564:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
          "565:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
          "566:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
          "567:         \"not-wf-sa-186\", // Whitespace is required between attribute/value pairs.",
          "568:         \"not-wf-not-sa-001\", // Conditional sections must be properly terminated (\"]>\" used     instead of \"]]>\").",
          "569:         \"not-wf-not-sa-002\", // Processing instruction target names may not be \"XML\"      in any combination of cases.",
          "570:         \"not-wf-not-sa-003\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "571:         \"not-wf-not-sa-004\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "572:         \"not-wf-not-sa-005\", // Tests the Entity Declared VC by referring to an     undefined parameter entity within an external entity.",
          "573:         \"not-wf-not-sa-006\", // Conditional sections need a '[' after the INCLUDE or IGNORE.",
          "574:         \"not-wf-not-sa-007\", // A <!DOCTYPE ...> declaration may not begin any external     entity; it's only found once, in the document entity.",
          "575:         \"not-wf-not-sa-008\", // In DTDs, the '%' character must be part of a parameter     entity reference.",
          "576:         \"not-wf-not-sa-009\", // This test violates WFC:PE Between Declarations in Production 28a.       The last character of a markup declaration is not contained in the same      parameter-entity text replacement.",
          "577:         \"valid-sa-012\", // Uses a legal XML 1.0 name consisting of a single colon     character (disallowed by the latest XML Namespaces draft).",
          "578:         \"valid-sa-023\", // Test demonstrates that Entity References are valid element content.",
          "579:         \"valid-sa-024\", // Test demonstrates that Entity References are valid element content and also demonstrates a valid Entity Declaration.",
          "580:         \"valid-sa-049\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "581:         \"valid-sa-050\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "582:         \"valid-sa-051\", // The document is encoded in UTF-16 and uses some name     characters well outside of the normal ASCII range.",
          "583:         \"valid-sa-053\", // Tests inclusion of a well-formed internal entity, which     holds an element required by the content model.",
          "584:         \"valid-sa-066\", // Expands a CDATA attribute with a character reference.",
          "585:         \"valid-sa-068\", // Tests definition of an internal entity holding a carriage return character     reference, which must not be normalized before reporting to the application.  Line      break normalization only occurs when parsing external parsed entities.",
          "586:         \"valid-sa-085\", // Parameter and General entities use different namespaces,     so there can be an entity of each type with a given name.",
          "587:         \"valid-sa-086\", // Tests whether entities may be declared more than once,     with the first declaration being the binding one.",
          "588:         \"valid-sa-087\", // Tests whether character references in internal entities are     expanded early enough, by relying on correct handling to     make the entity be well formed.",
          "589:         \"valid-sa-088\", // Tests whether entity references in internal entities are     expanded late enough, by relying on correct handling to     make the expanded text be valid.  (If it's expanded too     early, the entity will parse as an element that's not     valid in that context.)",
          "590:         \"valid-sa-089\", // Tests entity expansion of three legal character references,     which each expand to a Unicode surrogate pair.",
          "591:         \"valid-sa-108\", // This tests normalization of end-of-line characters (CRLF)     within entities to LF, primarily as an output test.",
          "592:         \"valid-sa-110\", // Basically an output test, this requires that a CDATA     attribute with a CRLF be normalized to one space.",
          "593:         \"valid-sa-114\", // Test demonstrates that all text within a valid CDATA section is considered text and not recognized as markup.",
          "594:         \"valid-sa-115\", // Test demonstrates that an entity reference is processed by recursively processing the replacement text of the entity.",
          "595:         \"valid-sa-117\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "596:         \"valid-sa-118\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "597:         \"valid-not-sa-031\", // Expands a general entity which contains a CDATA section with     what looks like a markup declaration (but is just text since     it's in a CDATA section).",
          "598:         \"valid-ext-sa-001\", // A combination of carriage return line feed in an external entity must     be normalized to a single newline.",
          "599:         \"valid-ext-sa-002\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "600:         \"valid-ext-sa-003\", // Test demonstrates that the content of an element can be empty. In this case the external entity is an empty file.",
          "601:         \"valid-ext-sa-004\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "602:         \"valid-ext-sa-005\", // Test demonstrates the use of optional character and content particles within an element content.  The test also show the use of external entity.",
          "603:         \"valid-ext-sa-006\", // Test demonstrates the use of optional character and content particles within mixed element content.  The test also shows the use of an external entity and that a carriage control line feed in an external entity must be normalized to a single newline.",
          "604:         \"valid-ext-sa-007\", // Test demonstrates the use of external entity and how replacement  text is retrieved and processed.",
          "605:         \"valid-ext-sa-008\", // Test demonstrates the use of external  entity and how replacement text is retrieved and processed.  Also tests the use of an  EncodingDecl of UTF-16.",
          "606:         \"valid-ext-sa-009\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "607:         \"valid-ext-sa-011\", // Test demonstrates the use of a public identifier with and external entity.   The test also show that a carriage control line feed combination in an external  entity must be normalized to a single newline.",
          "608:         \"valid-ext-sa-012\", // Test demonstrates both internal and external entities and that processing of entity references may be required to produce the correct replacement text.",
          "609:         \"valid-ext-sa-013\", // Test demonstrates that whitespace is handled by adding a single whitespace to the normalized value in the attribute list.",
          "610:         \"valid-ext-sa-014\", // Test demonstrates use of characters outside of normal ASCII range.",
          "611:     ]);",
          "",
          "[Added Lines]",
          "120:     Err(format!(\"{} {msg}\\n\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?",
          "124:     run_suite(\"eduni/errata-2e/errata2e.xml\");",
          "128:     run_suite(\"eduni/errata-3e/errata3e.xml\");",
          "132:     run_suite(\"eduni/errata-4e/errata4e.xml\");",
          "136:     run_suite(\"eduni/misc/ht-bh.xml\");",
          "140:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\");",
          "144:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\");",
          "148:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\");",
          "152:     run_suite(\"eduni/xml-1.1/xml11.xml\");",
          "156:     run_suite(\"ibm/ibm_oasis_valid.xml\");",
          "160:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\");",
          "164:     run_suite(\"oasis/oasis.xml\");",
          "168:     run_suite(\"sun/sun-valid.xml\");",
          "172:     run_suite(\"sun/sun-not-wf.xml\");",
          "177:     run_suite(\"japanese/japanese.xml\");",
          "181:     run_suite(\"xmltest/xmltest.xml\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00d53d5b4de6278eef047f2f68fe9125ede36e24",
      "candidate_info": {
        "commit_hash": "00d53d5b4de6278eef047f2f68fe9125ede36e24",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/00d53d5b4de6278eef047f2f68fe9125ede36e24",
        "files": [
          "tests/cases/quote.xml",
          "tests/cases/xmlnsquote.xml",
          "tests/ht-bh.fail.txt",
          "tests/tests.xml",
          "tests/xmlconf.rs"
        ],
        "message": "Custom tests",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: fn run_suite(suite_rel_path: &str) {",
          "31:     ensure_unzipped();",
          "34:     let known_failures_file_path = Path::new(\"tests\").join(suite_path.with_extension(\"fail.txt\").file_name().unwrap());",
          "35:     let mut new_known_failures_file = if std::env::var(\"PRINT_SPEC\").map_or(false, |val| val == \"1\") { Some(String::new()) } else { None };",
          "",
          "[Removed Lines]",
          "33:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "",
          "[Added Lines]",
          "33:     let suite_path = Path::new(\"tests\").join(suite_rel_path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "55:                 let path = root.join(&attr[\"URI\"]);",
          "56:                 let test_type = attr[\"TYPE\"].as_str();",
          "59:                 let res = match test_type {",
          "60:                     \"valid\" => expect_well_formed(&path, &desc),",
          "",
          "[Removed Lines]",
          "57:                 let id = attr[\"ID\"].as_str();",
          "",
          "[Added Lines]",
          "57:                 let id = attr.get(\"ID\").map(|a| a.as_str()).unwrap_or_else(|| path.file_stem().unwrap().to_str().unwrap());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:         }",
          "90:     }",
          "91:     if let Some(out) = new_known_failures_file {",
          "93:     }",
          "94:     assert!(parsed > 0);",
          "95: }",
          "97: #[track_caller]",
          "98: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "100:     let r = EventReader::new(f);",
          "101:     let mut seen_any = false;",
          "102:     for e in r {",
          "",
          "[Removed Lines]",
          "92:         std::fs::write(known_failures_file_path, out).unwrap();",
          "99:     let f = BufReader::new(File::open(xml_path)?);",
          "",
          "[Added Lines]",
          "92:         if out.is_empty() {",
          "93:             let _ = std::fs::remove_file(known_failures_file_path);",
          "94:         } else {",
          "95:             std::fs::write(known_failures_file_path, out).unwrap();",
          "96:         }",
          "103:     let f = BufReader::new(File::open(xml_path).expect(\"testcase\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122: }",
          "124: #[test] fn eduni_errata_2e() {",
          "126: }",
          "128: #[test] fn eduni_errata_3e() {",
          "130: }",
          "132: #[test] fn eduni_errata_4e() {",
          "134: }",
          "136: #[test] fn eduni_misc_ht() {",
          "138: }",
          "140: #[test] fn eduni_namespaces_10() {",
          "142: }",
          "144: #[test] fn eduni_namespaces_11() {",
          "146: }",
          "148: #[test] fn eduni_namespaces_errata() {",
          "150: }",
          "152: #[test] fn eduni_xml_11() {",
          "154: }",
          "156: #[test] fn ibm_oasis_valid() {",
          "158: }",
          "160: #[test] fn ibm_xml_11() {",
          "162: }",
          "164: #[test] fn oasis() {",
          "166: }",
          "168: #[test] fn sun_valid() {",
          "170: }",
          "172: #[test] fn sun_ill_formed() {",
          "174: }",
          "176: #[ignore]",
          "177: #[test] fn japanese() {",
          "179: }",
          "181: #[test] fn xmltest() {",
          "183: }",
          "",
          "[Removed Lines]",
          "125:     run_suite(\"eduni/errata-2e/errata2e.xml\");",
          "129:     run_suite(\"eduni/errata-3e/errata3e.xml\");",
          "133:     run_suite(\"eduni/errata-4e/errata4e.xml\");",
          "137:     run_suite(\"eduni/misc/ht-bh.xml\");",
          "141:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\");",
          "145:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\");",
          "149:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\");",
          "153:     run_suite(\"eduni/xml-1.1/xml11.xml\");",
          "157:     run_suite(\"ibm/ibm_oasis_valid.xml\");",
          "161:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\");",
          "165:     run_suite(\"oasis/oasis.xml\");",
          "169:     run_suite(\"sun/sun-valid.xml\");",
          "173:     run_suite(\"sun/sun-not-wf.xml\");",
          "178:     run_suite(\"japanese/japanese.xml\");",
          "182:     run_suite(\"xmltest/xmltest.xml\");",
          "",
          "[Added Lines]",
          "129:     run_suite(\"xmlconf/eduni/errata-2e/errata2e.xml\");",
          "133:     run_suite(\"xmlconf/eduni/errata-3e/errata3e.xml\");",
          "137:     run_suite(\"xmlconf/eduni/errata-4e/errata4e.xml\");",
          "141:     run_suite(\"xmlconf/eduni/misc/ht-bh.xml\");",
          "145:     run_suite(\"xmlconf/eduni/namespaces/1.0/rmt-ns10.xml\");",
          "149:     run_suite(\"xmlconf/eduni/namespaces/1.1/rmt-ns11.xml\");",
          "153:     run_suite(\"xmlconf/eduni/namespaces/errata-1e/errata1e.xml\");",
          "157:     run_suite(\"xmlconf/eduni/xml-1.1/xml11.xml\");",
          "161:     run_suite(\"xmlconf/ibm/ibm_oasis_valid.xml\");",
          "165:     run_suite(\"xmlconf/ibm/xml-1.1/ibm_valid.xml\");",
          "169:     run_suite(\"xmlconf/oasis/oasis.xml\");",
          "173:     run_suite(\"xmlconf/sun/sun-valid.xml\");",
          "177:     run_suite(\"xmlconf/sun/sun-not-wf.xml\");",
          "182:     run_suite(\"xmlconf/japanese/japanese.xml\");",
          "186:     run_suite(\"xmlconf/xmltest/xmltest.xml\");",
          "187: }",
          "189: #[test] fn own_tests() {",
          "190:     run_suite(\"tests.xml\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
      "candidate_info": {
        "commit_hash": "3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
        "files": [
          ".gitignore",
          "tests/xmlconf.rs",
          "tests/xmlts20130923.zip"
        ],
        "message": "XML conformance suite",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use std::collections::HashSet;",
          "4: use std::ffi::OsStr;",
          "5: use std::path::Path;",
          "6: use std::collections::HashMap;",
          "7: use std::fs::File;",
          "8: use std::io::BufReader;",
          "9: use std::process::Command;",
          "10: use std::sync::Mutex;",
          "12: use xml::EventReader;",
          "13: use xml::reader::XmlEvent;",
          "15: static UNZIP: Mutex<()> = Mutex::new(());",
          "17: fn ensure_unzipped() {",
          "18:     let _g = UNZIP.lock().expect(\"unzip already failed\");",
          "21:     if !Path::new(\"tests/xmlconf\").exists() {",
          "22:         assert!(Command::new(\"unzip\")",
          "23:             .current_dir(\"tests\")",
          "24:             .arg(\"xmlts20130923.zip\")",
          "25:             .status().unwrap().success(), \"must unzip\");",
          "26:     }",
          "27: }",
          "29: #[track_caller]",
          "30: fn run_suite(suite_rel_path: &str, known_broken_tests: &[&str]) {",
          "31:     ensure_unzipped();",
          "33:     let known_broken_tests = known_broken_tests.iter().map(|name| name.as_ref()).collect::<HashSet<&OsStr>>();",
          "35:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "36:     let root = suite_path.parent().unwrap();",
          "37:     let mut parsed = 0;",
          "39:     let f = BufReader::new(File::open(&suite_path)",
          "40:         .map_err(|e| format!(\"{}: {e}\", suite_path.display())).unwrap());",
          "41:     let r = EventReader::new(f);",
          "42:     let mut desc = String::new();",
          "43:     let mut attr = HashMap::<String, String>::new();",
          "44:     for e in r {",
          "45:         let e = e.expect(\"testsuite validity\");",
          "46:         match e {",
          "47:             XmlEvent::Characters(chr) => {",
          "48:                 desc.push_str(&chr.replace('\\n', \" \"));",
          "49:             },",
          "50:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "51:                 let path = root.join(&attr[\"URI\"]);",
          "52:                 let test_type = attr[\"TYPE\"].as_str();",
          "54:                 let res = match test_type {",
          "55:                     \"valid\" => expect_well_formed(&path, &desc),",
          "56:                     \"invalid\" => expect_well_formed(&path, &desc), // invalid is still well-formed",
          "57:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc),",
          "58:                     other => unimplemented!(\"{other}?? type\"),",
          "59:                 };",
          "61:                 let id = attr[\"ID\"].as_str();",
          "62:                 let known_bad = known_broken_tests.contains::<OsStr>(id.as_ref());",
          "64:                 match res {",
          "65:                     Err(_) if known_bad => {},",
          "66:                     Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "67:                     Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\", path.display()),",
          "68:                     Ok(()) => {},",
          "69:                 };",
          "70:                 parsed += 1;",
          "71:             },",
          "72:             XmlEvent::StartElement { name, attributes, namespace: _ } if name.local_name == \"TEST\" => {",
          "73:                 desc.clear();",
          "74:                 attr = attributes.into_iter().map(|a| (a.name.local_name, a.value)).collect();",
          "75:             },",
          "76:             _ => {},",
          "78:         }",
          "79:     }",
          "80:     assert!(parsed > 0);",
          "81: }",
          "83: #[track_caller]",
          "84: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "85:     let f = BufReader::new(File::open(xml_path)?);",
          "86:     let r = EventReader::new(f);",
          "87:     let mut seen_any = false;",
          "88:     for e in r {",
          "89:         let e = e.map_err(|e| format!(\"\\\"{}\\\", // {msg}; {e}\", xml_path.display()))?;",
          "90:         if let XmlEvent::EndElement { .. } = e {",
          "91:             seen_any = true;",
          "92:         }",
          "93:     }",
          "94:     if !seen_any { Err(\"no elements found\")? }",
          "95:     Ok(())",
          "96: }",
          "98: #[track_caller]",
          "99: fn expect_ill_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "100:     let f = BufReader::new(File::open(xml_path)?);",
          "101:     let r = EventReader::new(f);",
          "102:     for e in r {",
          "103:         if let Err(_) = e {",
          "104:             return Ok(());",
          "105:         }",
          "106:     }",
          "107:     Err(format!(\"\\\"{}\\\", // {msg}\", xml_path.display()))?",
          "108: }",
          "110: #[test] fn eduni_errata_2e() {",
          "111:     run_suite(\"eduni/errata-2e/errata2e.xml\", &[",
          "112:         \"rmt-e2e-15a\", // Empty content can't contain an entity reference",
          "113:         \"rmt-e2e-15e\", // Element content can contain entity reference if replacement text is whitespace",
          "114:         \"rmt-e2e-15f\", // Element content can contain entity reference if replacement text is whitespace, even if it came from a character reference in the literal entity value",
          "115:         \"rmt-e2e-15h\", // Element content can't contain entity reference if replacement text is character reference to whitespace",
          "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
          "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
          "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
          "119:         \"rmt-e2e-24\", // Either the built-in entity or a character reference can be used to represent greater-than after two close-square-brackets",
          "120:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
          "121:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
          "122:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
          "123:         \"rmt-e2e-57\", // A value other than preserve or default for xml:space is an error",
          "124:         \"rmt-e2e-61\", // (From John Cowan) An encoding declaration in ASCII specifying an encoding that is not compatible with ASCII (so the document is not in its declared encoding).  It should generate a fatal error.",
          "125:     ]);",
          "126: }",
          "128: #[test] fn eduni_errata_3e() {",
          "129:     run_suite(\"eduni/errata-3e/errata3e.xml\", &[",
          "130:         \"rmt-e3e-12\", // E12.xml Default values for attributes may not contain references to external entities.",
          "131:         \"rmt-e3e-13\", // E13.xml Even internal parameter entity references are enough to make undeclared entities into mere validity errors rather than well-formedness errors.",
          "132:     ]);",
          "133: }",
          "135: #[test] fn eduni_errata_4e() {",
          "136:     run_suite(\"eduni/errata-4e/errata4e.xml\", &[",
          "137:         \"invalid-bo-1\", // inclbom_be.xml Byte order mark in general entity should go away (big-endian)",
          "138:         \"invalid-bo-2\", // inclbom_le.xml Byte order mark in general entity should go away (little-endian)",
          "139:         \"invalid-bo-3\", // incl8bom.xml Byte order mark in general entity should go away (utf-8)",
          "140:         \"invalid-bo-4\", // inclbombom_be.xml Two byte order marks in general entity produce only one (big-endian)",
          "141:         \"invalid-bo-5\", // inclbombom_le.xml Two byte order marks in general entity produce only one (little-endian)",
          "142:         \"invalid-bo-6\", // incl8bombom.xml Two byte order marks in general entity produce only one (utf-8)",
          "143:         \"invalid-sa-140\", // 140.xml Character '&#x309a;' is a CombiningChar, not a Letter, but as of 5th edition, may begin a name (c.f. xmltest/not-wf/sa/140.xml).",
          "144:         \"invalid-sa-141\", // 141.xml As of 5th edition, character #x0E5C is legal in XML names (c.f. xmltest/not-wf/sa/141.xml).",
          "145:         \"x-rmt-008b\", // 008.xml a document with version=1.7, legal in XML 1.0 from 5th edition",
          "146:         \"x-ibm-1-0.5-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal characters for production 04.",
          "147:         \"x-ibm-1-0.5-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "148:         \"x-ibm-1-0.5-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "149:     ]);",
          "150: }",
          "152: #[test] fn eduni_misc_ht() {",
          "153:     run_suite(\"eduni/misc/ht-bh.xml\", &[]);",
          "154: }",
          "156: #[test] fn eduni_namespaces_10() {",
          "157:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\", &[",
          "158:         \"rmt-ns10-004\", // Namespace name test: a relative URI (deprecated)",
          "159:         \"rmt-ns10-005\", // Namespace name test: a same-document relative URI (deprecated)",
          "160:         \"rmt-ns10-009\", // Namespace equality test: plain repetition",
          "161:         \"rmt-ns10-010\", // Namespace equality test: use of character reference",
          "162:         \"rmt-ns10-012\", // Namespace inequality test: equal after attribute value normalization",
          "163:         \"rmt-ns10-030\", // Reserved prefixes and namespaces: binding another prefix to the xml namespace",
          "164:         \"rmt-ns10-033\", // Reserved prefixes and namespaces: binding another prefix to the xmlns namespace",
          "165:         \"rmt-ns10-036\", // Attribute uniqueness: repeated attribute with different prefixes",
          "166:         \"rmt-ns10-042\", // Colon in PI name",
          "167:         \"rmt-ns10-043\", // Colon in entity name",
          "168:         \"rmt-ns10-044\", // Colon in entity name",
          "169:         \"ht-ns10-047\", // Reserved name: _not_ an error",
          "170:     ]);",
          "171: }",
          "173: #[test] fn eduni_namespaces_11() {",
          "174:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\", &[",
          "175:         \"rmt-ns11-001\", // 001.xml Namespace name test: a perfectly good http IRI that is not a URI",
          "176:         \"rmt-ns11-002\", // 002.xml Namespace inequality test: different escaping of non-ascii letter",
          "177:         \"rmt-ns11-003\", // 003.xml 1.1 style prefix unbinding",
          "178:         \"rmt-ns11-004\", // 004.xml 1.1 style prefix unbinding and rebinding",
          "179:     ]);",
          "180: }",
          "182: #[test] fn eduni_namespaces_errata() {",
          "183:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\", &[",
          "184:         \"rmt-ns-e1.0-13a\", // NE13a.xml The xml namespace must not be declared as the default namespace.",
          "185:         \"rmt-ns-e1.0-13b\", // NE13b.xml The xmlns namespace must not be declared as the default namespace.",
          "186:     ]);",
          "187: }",
          "189: #[test] fn eduni_xml_11() {",
          "190:     run_suite(\"eduni/xml-1.1/xml11.xml\", &[",
          "191:         \"rmt-001\", // 001.xml External subset has later version number",
          "192:         \"rmt-002\", // 002.xml External PE has later version number",
          "193:         \"rmt-006\", // 006.xml Second-level external general entity has later version number than first-level, but not later than document, so not an error.",
          "194:         \"rmt-010\", // 010.xml Contains a C1 control, legal in XML 1.0, illegal in XML 1.1",
          "195:         \"rmt-013\", // 013.xml Contains a DEL, legal in XML 1.0, illegal in XML 1.1",
          "196:         \"rmt-014\", // 014.xml Has a \"long s\" in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "197:         \"rmt-016\", // 016.xml Has a Byzantine Musical Symbol Kratimata in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "198:         \"rmt-019\", // 019.xml Has the last legal namechar in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "199:         \"rmt-022\", // 022.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "200:         \"rmt-023\", // 023.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "201:         \"rmt-026\", // 026.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "202:         \"rmt-027\", // 027.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "203:         \"rmt-030\", // 030.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "204:         \"rmt-031\", // 031.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "205:         \"rmt-034\", // 034.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "206:         \"rmt-035\", // 035.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "207:         \"rmt-036\", // 036.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "208:         \"rmt-037\", // 037.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "209:         \"rmt-038\", // 038.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "210:         \"rmt-039\", // 039.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "211:         \"rmt-040\", // 040.xml Contains a C1 control character (partial line up), legal in XML 1.0 but not 1.1",
          "212:         \"rmt-042\", // 042.xml Contains a character reference to a C0 control character (form-feed), legal in XML 1.1 but not 1.0",
          "213:         \"rmt-046\", // 046.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "214:         \"rmt-047\", // 047.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "215:         \"rmt-050\", // 050.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "216:         \"rmt-051\", // 051.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "217:         \"rmt-052\", // 052.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "218:         \"rmt-053\", // 053.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "219:         \"rmt-054\", // 054.xml Contains a character reference to a C0 control character (form-feed) in an entity value.  This will be legal (in XML 1.1) when the entity declaration is parsed, but what about when it is used?",
          "220:     ]);",
          "221: }",
          "223: #[test] fn ibm_oasis_valid() {",
          "224:     run_suite(\"ibm/ibm_oasis_valid.xml\", &[",
          "225:         \"ibm-valid-P09-ibm09v01.xml\", // ibm09v01.xml Empty EntityValue is legal",
          "226:         \"ibm-valid-P09-ibm09v02.xml\", // ibm09v02.xml Tests a normal EnitityValue",
          "227:         \"ibm-valid-P09-ibm09v03.xml\", // ibm09v03.xml Tests EnitityValue referencing a Parameter Entity",
          "228:         \"ibm-valid-P09-ibm09v04.xml\", // ibm09v04.xml Tests EnitityValue referencing a General Entity",
          "229:         \"ibm-valid-P09-ibm09v05.xml\", // ibm09v05.xml Tests EnitityValue with combination of GE, PE and text, the GE used is      declared in the student.dtd",
          "230:         \"ibm-valid-P10-ibm10v01.xml\", // ibm10v01.xml Tests empty AttValue with double quotes as the delimiters",
          "231:         \"ibm-valid-P10-ibm10v02.xml\", // ibm10v02.xml Tests empty AttValue with single quotes as the delimiters",
          "232:         \"ibm-valid-P10-ibm10v03.xml\", // ibm10v03.xml Test AttValue with double quotes as the delimiters and single quote inside",
          "233:         \"ibm-valid-P10-ibm10v04.xml\", // ibm10v04.xml Test AttValue with single quotes as the delimiters and double quote inside",
          "234:         \"ibm-valid-P10-ibm10v05.xml\", // ibm10v05.xml Test AttValue with a GE reference and double quotes as the delimiters",
          "235:         \"ibm-valid-P10-ibm10v06.xml\", // ibm10v06.xml Test AttValue with a GE reference and single quotes as the delimiters",
          "236:         \"ibm-valid-P10-ibm10v07.xml\", // ibm10v07.xml testing AttValue with mixed references and text content in double quotes",
          "237:         \"ibm-valid-P10-ibm10v08.xml\", // ibm10v08.xml testing AttValue with mixed references and text content in single quotes",
          "238:         \"ibm-valid-P28-ibm28v02.xml\", // ibm28v02.xml Tests doctypedecl with external subset and combinations of different markup     declarations and PEReferences",
          "239:         \"ibm-valid-P29-ibm29v01.xml\", // ibm29v01.xml Tests markupdecl with combinations of elementdecl, AttlistDecl,EntityDecl,      NotationDecl, PI and comment",
          "240:         \"ibm-valid-P29-ibm29v02.xml\", // ibm29v02.xml Tests WFC: PE in internal subset as a positive test",
          "241:         \"ibm-valid-P32-ibm32v02.xml\", // ibm32v02.xml Tests VC: Standalone Document Declaration with external entity reference     and standalone is no",
          "242:         \"ibm-valid-P43-ibm43v01.xml\", // ibm43v01.xml Tests content with all possible constructs: element, CharData, Reference,      CDSect, Comment",
          "243:         \"ibm-valid-P67-ibm67v01.xml\", // ibm67v01.xml Tests Reference could be EntityRef or CharRef.",
          "244:         \"ibm-valid-P78-ibm78v01.xml\", // ibm78v01.xml Tests ExtParsedEnt, also TextDecl in P77 and EncodingDecl in P80",
          "245:     ]);",
          "246: }",
          "248: #[test] fn ibm_xml_11() {",
          "249:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\", &[",
          "250:         \"ibm-1-1-valid-P02-ibm02v04.xml\", // ibm02v04.xml This test case contains embeded whitespace characters                   some form the range 1 - 1F.",
          "251:         \"ibm-1-1-valid-P03-ibm03v01.xml\", // ibm03v01.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "252:         \"ibm-1-1-valid-P03-ibm03v02.xml\", // ibm03v02.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "253:         \"ibm-1-1-valid-P03-ibm03v03.xml\", // ibm03v03.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "254:         \"ibm-1-1-valid-P03-ibm03v04.xml\", // ibm03v04.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "255:         \"ibm-1-1-valid-P03-ibm03v05.xml\", // ibm03v05.xml The two character sequence #x0D #x85 in a document entity must be normalized to a          single newline.",
          "256:         \"ibm-1-1-valid-P03-ibm03v06.xml\", // ibm03v06.xml The single character sequence #x85 in a document entity must be normalized to a          single newline.",
          "257:         \"ibm-1-1-valid-P03-ibm03v07.xml\", // ibm03v07.xml The single character sequence #x2028 in a document entity must be normalized to a          single newline.",
          "258:         \"ibm-1-1-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal          characters for production 04.",
          "259:         \"ibm-1-1-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "260:         \"ibm-1-1-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "261:         \"ibm-1-1-valid-P77-ibm77v04.xml\", // ibm77v04.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xD6 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "262:         \"ibm-1-1-valid-P77-ibm77v05.xml\", // ibm77v05.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #x1FFF which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "263:         \"ibm-1-1-valid-P77-ibm77v06.xml\", // ibm77v06.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xF901 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "264:         \"ibm-1-1-valid-P77-ibm77v10.xml\", // ibm77v10.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF6.",
          "265:         \"ibm-1-1-valid-P77-ibm77v11.xml\", // ibm77v11.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #x1FFF.",
          "266:         \"ibm-1-1-valid-P77-ibm77v12.xml\", // ibm77v12.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF901.",
          "267:         \"ibm-1-1-valid-P77-ibm77v16.xml\", // ibm77v16.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x2FF.",
          "268:         \"ibm-1-1-valid-P77-ibm77v17.xml\", // ibm77v17.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x1FFF.",
          "269:         \"ibm-1-1-valid-P77-ibm77v18.xml\", // ibm77v18.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #xF901.",
          "270:         \"ibm-1-1-valid-P77-ibm77v22.xml\", // ibm77v22.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x7F.",
          "271:         \"ibm-1-1-valid-P77-ibm77v23.xml\", // ibm77v23.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x80.",
          "272:         \"ibm-1-1-valid-P77-ibm77v24.xml\", // ibm77v24.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x9F.",
          "273:         \"ibm-1-1-valid-P77-ibm77v28.xml\", // ibm77v28.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x7F, #x80, #x9F.",
          "274:         \"ibm-1-1-valid-P77-ibm77v29.xml\", // ibm77v29.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x85, #x8F.",
          "275:         \"ibm-1-1-valid-P77-ibm77v30.xml\", // ibm77v30.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.",
          "276:     ]);",
          "277: }",
          "279: #[test] fn oasis() {",
          "280:     run_suite(\"oasis/oasis.xml\", &[",
          "281:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
          "282:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
          "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
          "284:         \"o-p05pass1\", // various valid Name constructions",
          "285:         \"o-p15pass1\", // valid comments",
          "286:         \"o-p16pass1\", // Valid form of Processing Instruction. Shows that whitespace character data is valid before end of processing instruction.",
          "287:         \"o-p01fail1\", // S cannot occur before the prolog",
          "288:         \"o-p01fail2\", // comments cannot occur before the prolog",
          "289:         \"o-p01fail3\", // only one document element",
          "290:         \"o-p09fail1\", // EntityValue excludes '%'",
          "291:         \"o-p09fail2\", // EntityValue excludes '&'",
          "292:         \"o-p09fail3\", // incomplete character reference",
          "293:         \"o-p09fail4\", // quote types must match",
          "294:         \"o-p09fail5\", // quote types must match",
          "295:         \"o-p11fail1\", // quote types must match",
          "296:         \"o-p11fail2\", // cannot contain delimiting quotes",
          "297:         \"o-p12fail1\", // '\"' excluded",
          "298:         \"o-p12fail2\", // '\\' excluded",
          "299:         \"o-p12fail3\", // entity references excluded",
          "300:         \"o-p12fail6\", // built-in entity refs excluded",
          "301:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
          "302:         \"o-p14fail3\", // \"]]>\" excluded",
          "303:         \"o-p18fail3\", // CDSect's can't nest",
          "304:         \"o-p22fail1\", // prolog must start with XML decl",
          "305:         \"o-p22fail2\", // prolog must start with XML decl",
          "306:         \"o-p23fail1\", // \"xml\" must be lower-case",
          "307:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
          "308:         \"o-p29fail1\", // A processor must not pass unknown declaration types.",
          "309:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
          "310:         \"o-p31fail1\", // external subset excludes doctypedecl",
          "311:         \"o-p32fail3\", // initial S is required",
          "312:         \"o-p40fail1\", // S is required between attributes",
          "313:         \"o-p44fail4\", // Whitespace required between attributes.",
          "314:         \"o-p45fail1\", // ELEMENT must be upper case.",
          "315:         \"o-p45fail2\", // S before contentspec is required.",
          "316:         \"o-p45fail3\", // only one content spec",
          "317:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
          "318:         \"o-p46fail1\", // no parens on declared content",
          "319:         \"o-p46fail2\", // no inclusions (contrast with SGML)",
          "320:         \"o-p46fail3\", // no exclusions (contrast with SGML)",
          "321:         \"o-p46fail4\", // no space before occurrence",
          "322:         \"o-p46fail5\", // single group",
          "323:         \"o-p46fail6\", // can't be both declared and modeled",
          "324:         \"o-p47fail1\", // Invalid operator '|' must match previous operator ','",
          "325:         \"o-p47fail2\", // Illegal character '-' in Element-content model",
          "326:         \"o-p47fail3\", // Optional character must follow a name or list",
          "327:         \"o-p47fail4\", // Illegal space before optional character",
          "328:         \"o-p48fail1\", // Illegal space before optional character",
          "329:         \"o-p48fail2\", // Illegal space before optional character",
          "330:         \"o-p51fail1\", // occurrence on #PCDATA group must be *",
          "331:         \"o-p51fail2\", // occurrence on #PCDATA group must be *",
          "332:         \"o-p51fail3\", // #PCDATA must come first",
          "333:         \"o-p51fail4\", // occurrence on #PCDATA group must be *",
          "334:         \"o-p51fail5\", // only '|' connectors",
          "335:         \"o-p51fail6\", // Only '|' connectors and occurrence on #PCDATA group must be *",
          "336:         \"o-p51fail7\", // no nested groups",
          "337:         \"o-p52fail1\", // A name is required",
          "338:         \"o-p52fail2\", // A name is required",
          "339:         \"o-p53fail1\", // S is required before default",
          "340:         \"o-p53fail2\", // S is required before type",
          "341:         \"o-p53fail3\", // type is required",
          "342:         \"o-p53fail4\", // default is required",
          "343:         \"o-p53fail5\", // name is requried",
          "344:         \"o-p54fail1\", // don't pass unknown attribute types",
          "345:         \"o-p55fail1\", // must be upper case",
          "346:         \"o-p56fail1\", // no IDS type",
          "347:         \"o-p56fail2\", // no NUMBER type",
          "348:         \"o-p56fail3\", // no NAME type",
          "349:         \"o-p56fail4\", // no ENTITYS type - types must be upper case",
          "350:         \"o-p56fail5\", // types must be upper case",
          "351:         \"o-p57fail1\", // no keyword for NMTOKEN enumeration",
          "352:         \"o-p58fail1\", // at least one value required",
          "353:         \"o-p58fail2\", // separator must be '|'",
          "354:         \"o-p58fail3\", // notations are NAMEs, not NMTOKENs -- note:     Leaving the invalid           notation undeclared would cause a validating parser to fail without           checking the name syntax, so the notation is declared with an           invalid name.  A parser that reports error positions should report           an error at the AttlistDecl on line 6, before reaching the notation           declaration.",
          "355:         \"o-p58fail4\", // NOTATION must be upper case",
          "356:         \"o-p58fail5\", // S after keyword is required",
          "357:         \"o-p58fail6\", // parentheses are require",
          "358:         \"o-p58fail7\", // values are unquoted",
          "359:         \"o-p58fail8\", // values are unquoted",
          "360:         \"o-p59fail1\", // at least one required",
          "361:         \"o-p59fail2\", // separator must be \",\"",
          "362:         \"o-p59fail3\", // values are unquoted",
          "363:         \"o-p60fail1\", // keywords must be upper case",
          "364:         \"o-p60fail2\", // S is required after #FIXED",
          "365:         \"o-p60fail3\", // only #FIXED has both keyword and value",
          "366:         \"o-p60fail4\", // #FIXED required value",
          "367:         \"o-p60fail5\", // only one default type",
          "368:         \"o-p61fail1\", // no other types, including TEMP, which is valid in SGML",
          "369:         \"o-p62fail1\", // INCLUDE must be upper case",
          "370:         \"o-p62fail2\", // no spaces in terminating delimiter",
          "371:         \"o-p63fail1\", // IGNORE must be upper case",
          "372:         \"o-p63fail2\", // delimiters must be balanced",
          "373:         \"o-p64fail1\", // section delimiters must balance",
          "374:         \"o-p64fail2\", // section delimiters must balance",
          "375:         \"o-p66fail5\", // no references to non-characters",
          "376:         \"o-p69fail1\", // terminating ';' is required",
          "377:         \"o-p69fail2\", // no S after '%'",
          "378:         \"o-p69fail3\", // no S before ';'",
          "379:         \"o-p70fail1\", // This is neither",
          "380:         \"o-p71fail1\", // S is required before EntityDef",
          "381:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
          "382:         \"o-p71fail3\", // no S after \"<!\"",
          "383:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
          "384:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
          "385:         \"o-p72fail2\", // S is required after '%'",
          "386:         \"o-p72fail3\", // S is required after name",
          "387:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
          "388:         \"o-p73fail1\", // No typed replacement text",
          "389:         \"o-p73fail2\", // Only one replacement value",
          "390:         \"o-p73fail3\", // No NDataDecl on replacement text",
          "391:         \"o-p73fail4\", // Value is required",
          "392:         \"o-p73fail5\", // No NDataDecl without value",
          "393:         \"o-p74fail1\", // no NDataDecls on parameter entities",
          "394:         \"o-p74fail2\", // value is required",
          "395:         \"o-p74fail3\", // only one value",
          "396:         \"o-p75fail1\", // S required after \"PUBLIC\"",
          "397:         \"o-p75fail2\", // S required after \"SYSTEM\"",
          "398:         \"o-p75fail3\", // S required between literals",
          "399:         \"o-p75fail4\", // \"SYSTEM\" implies only one literal",
          "400:         \"o-p75fail5\", // only one keyword",
          "401:         \"o-p75fail6\", // \"PUBLIC\" requires two literals (contrast with SGML)",
          "402:         \"o-p76fail1\", // S is required before \"NDATA\"",
          "403:         \"o-p76fail2\", // \"NDATA\" is upper-case",
          "404:         \"o-p76fail3\", // notation name is required",
          "405:     ]);",
          "406: }",
          "408: #[test] fn sun_valid() {",
          "409:     run_suite(\"sun/sun-valid.xml\", &[",
          "410:         \"ext01\", // Tests use of external parsed entities with and without content.",
          "411:         \"ext02\", // Tests use of external parsed entities with different    encodings than the base document.",
          "412:         \"not-sa02\", // A non-standalone document is valid if declared as such.",
          "413:         \"not-sa03\", // A non-standalone document is valid if declared as such.",
          "414:         \"not-sa04\", // A non-standalone document is valid if declared as such.",
          "415:         \"sa02\", // A document may be marked 'standalone' if any     attributes that need normalization are  defined within the internal DTD subset.",
          "416:         \"sa03\", // A document may be marked 'standalone' if any     the defined entities need expanding are internal,     and no attributes need defaulting or normalization.     On output, requires notations to be correctly reported.",
          "417:         \"sa04\", // Like sa03 but relies on attribute     defaulting defined in the internal subset.     On output, requires notations to be correctly reported.",
          "418:         \"v-pe00\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "419:         \"v-pe03\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "420:         \"v-pe02\", // Tests construction of internal entity replacement text, using     a complex example in the XML specification.",
          "421:     ]);",
          "422: }",
          "424: #[test] fn sun_ill_formed() {",
          "425:     run_suite(\"sun/sun-not-wf.xml\", &[",
          "426:         \"attlist01\", // SGML's NUTOKEN is not allowed.",
          "427:         \"attlist02\", // SGML's NUTOKENS attribute type is not allowed.",
          "428:         \"attlist03\", // Comma doesn't separate enumerations, unlike in SGML.",
          "429:         \"attlist04\", // SGML's NUMBER attribute type is not allowed.",
          "430:         \"attlist05\", // SGML's NUMBERS attribute type is not allowed.",
          "431:         \"attlist06\", // SGML's NAME attribute type is not allowed.",
          "432:         \"attlist07\", // SGML's NAMES attribute type is not allowed.",
          "433:         \"attlist08\", // SGML's #CURRENT is not allowed.",
          "434:         \"attlist09\", // SGML's #CONREF is not allowed.",
          "435:         \"attlist10\", // Whitespace required between attributes",
          "436:         \"attlist11\", // Whitespace required between attributes",
          "437:         \"cond01\", // Only INCLUDE and IGNORE are conditional section keywords",
          "438:         \"cond02\", // Must have keyword in conditional sections",
          "439:         \"content01\", // No whitespace before \"?\" in content model",
          "440:         \"content02\", // No whitespace before \"*\" in content model",
          "441:         \"content03\", // No whitespace before \"+\" in content model",
          "442:         \"decl01\", // External entities may not have standalone decls.",
          "443:         \"nwf-dtd00\", // Comma mandatory in content model",
          "444:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
          "445:         \"dtd02\", // PE name immediately after \"%\"",
          "446:         \"dtd03\", // PE name immediately followed by \";\"",
          "447:         \"dtd04\", // PUBLIC literal must be quoted",
          "448:         \"dtd05\", // SYSTEM identifier must be quoted",
          "449:         \"dtd07\", // Text declarations (which optionally begin any external entity)     are required to have \"encoding=...\".",
          "450:         \"encoding01\", // Illegal character \" \" in encoding name",
          "451:         \"encoding02\", // Illegal character \"/\" in encoding name",
          "452:         \"encoding03\", // Illegal character reference in encoding name",
          "453:         \"encoding04\", // Illegal character \":\" in encoding name",
          "454:         \"encoding05\", // Illegal character \"@\" in encoding name",
          "455:         \"encoding06\", // Illegal character \"+\" in encoding name",
          "456:         \"pubid01\", // Illegal entity ref in public ID",
          "457:         \"pubid02\", // Illegal characters in public ID",
          "458:         \"pubid03\", // Illegal characters in public ID",
          "459:         \"pubid04\", // Illegal characters in public ID",
          "460:         \"pubid05\", // SGML-ism:  public ID without system ID",
          "461:         \"sgml02\", // XML declaration must be at the very beginning of a document;   it\"s not a processing instruction",
          "462:         \"sgml04\", // ATTLIST declarations apply to only one element, unlike SGML",
          "463:         \"sgml05\", // ELEMENT declarations apply to only one element, unlike SGML",
          "464:         \"sgml06\", // ATTLIST declarations are never global, unlike in SGML",
          "465:         \"sgml07\", // SGML Tag minimization specifications are not allowed",
          "466:         \"sgml08\", // SGML Tag minimization specifications are not allowed",
          "467:         \"sgml09\", // SGML Content model exception specifications are not allowed",
          "468:         \"sgml10\", // SGML Content model exception specifications are not allowed",
          "469:         \"sgml11\", // CDATA is not a valid content model spec",
          "470:         \"sgml12\", // RCDATA is not a valid content model spec",
          "471:         \"sgml13\", // SGML Unordered content models not allowed",
          "472:     ]);",
          "473: }",
          "475: #[ignore]",
          "476: #[test] fn japanese() {",
          "477:     run_suite(\"japanese/japanese.xml\", &[",
          "478:         \"pr-xml-little-endian.xml\"  // needs DTD",
          "479:     ]);",
          "480: }",
          "482: #[test] fn xmltest() {",
          "483:     run_suite(\"xmltest/xmltest.xml\", &[",
          "484:         \"not-wf-sa-003\", // Processing Instruction target name is required.",
          "485:         \"not-wf-sa-025\", // Text may not contain a literal ']]>' sequence.",
          "486:         \"not-wf-sa-026\", // Text may not contain a literal ']]>' sequence.",
          "487:         \"not-wf-sa-029\", // Text may not contain a literal ']]>' sequence.",
          "488:         \"not-wf-sa-030\", // A form feed is not a legal XML character.",
          "489:         \"not-wf-sa-031\", // A form feed is not a legal XML character.",
          "490:         \"not-wf-sa-032\", // A form feed is not a legal XML character.",
          "491:         \"not-wf-sa-033\", // An ESC (octal 033) is not a legal XML character.",
          "492:         \"not-wf-sa-037\", // Character references may not appear after the root element.",
          "493:         \"not-wf-sa-040\", // Provides two document elements.",
          "494:         \"not-wf-sa-041\", // Provides two document elements.",
          "495:         \"not-wf-sa-044\", // Provides two document elements.",
          "496:         \"not-wf-sa-048\", // Provides a CDATA section after the root element.",
          "497:         \"not-wf-sa-051\", // CDATA is invalid at top level of document.",
          "498:         \"not-wf-sa-052\", // Invalid character reference.",
          "499:         \"not-wf-sa-054\", // PUBLIC requires two literals.",
          "500:         \"not-wf-sa-056\", // Invalid Document Type Definition format - misplaced comment.",
          "501:         \"not-wf-sa-057\", // This isn't SGML; comments can't exist in declarations.",
          "502:         \"not-wf-sa-058\", // Invalid character , in ATTLIST enumeration",
          "503:         \"not-wf-sa-059\", // String literal must be in quotes.",
          "504:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
          "505:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
          "506:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
          "507:         \"not-wf-sa-063\", // Conditional sections may only appear in the external     DTD subset.",
          "508:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "509:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
          "510:         \"not-wf-sa-066\", // Required whitespace is missing.",
          "511:         \"not-wf-sa-067\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "512:         \"not-wf-sa-068\", // Space is required between NOTATION keyword and list of     enumerated choices in <!ATTLIST...> declarations.",
          "513:         \"not-wf-sa-069\", // Space is required before an NDATA entity annotation.",
          "514:         \"not-wf-sa-078\", // Undefined ENTITY foo.",
          "515:         \"not-wf-sa-079\", // ENTITY can't reference itself directly or indirectly.",
          "516:         \"not-wf-sa-080\", // ENTITY can't reference itself directly or indirectly.",
          "517:         \"not-wf-sa-082\", // This tests the No External Entity References WFC,     since the entity is referred to within an attribute.",
          "518:         \"not-wf-sa-084\", // Tests the Parsed Entity WFC by referring to an     unparsed entity.  (This precedes the error of not declaring     that entity's notation, which may be detected any time before     the DTD parsing is completed.)",
          "519:         \"not-wf-sa-085\", // Public IDs may not contain \"[\".",
          "520:         \"not-wf-sa-086\", // Public IDs may not contain \"[\".",
          "521:         \"not-wf-sa-087\", // Public IDs may not contain \"[\".",
          "522:         \"not-wf-sa-089\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "523:         \"not-wf-sa-091\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "524:         \"not-wf-sa-096\", // Space is required before the standalone declaration.",
          "525:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
          "526:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
          "527:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
          "528:         \"not-wf-sa-107\", // Invalid document type declaration.  CDATA alone is invalid.",
          "529:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
          "530:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
          "531:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
          "532:         \"not-wf-sa-122\", // Invalid syntax mixed connectors are used.",
          "533:         \"not-wf-sa-123\", // Invalid syntax mismatched parenthesis.",
          "534:         \"not-wf-sa-124\", // Invalid format of Mixed-content declaration.",
          "535:         \"not-wf-sa-125\", // Invalid syntax extra set of parenthesis not necessary.",
          "536:         \"not-wf-sa-126\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "537:         \"not-wf-sa-127\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "538:         \"not-wf-sa-128\", // Invalid CDATA syntax.",
          "539:         \"not-wf-sa-129\", // Invalid syntax for Element Type Declaration.",
          "540:         \"not-wf-sa-130\", // Invalid syntax for Element Type Declaration.",
          "541:         \"not-wf-sa-131\", // Invalid syntax for Element Type Declaration.",
          "542:         \"not-wf-sa-132\", // Invalid syntax mixed connectors used.",
          "543:         \"not-wf-sa-133\", // Illegal whitespace before optional character causes syntax error.",
          "544:         \"not-wf-sa-134\", // Illegal whitespace before optional character causes syntax error.",
          "545:         \"not-wf-sa-135\", // Invalid character used as connector.",
          "546:         \"not-wf-sa-136\", // Tag omission is invalid in XML.",
          "547:         \"not-wf-sa-137\", // Space is required before a content model.",
          "548:         \"not-wf-sa-138\", // Invalid syntax for content particle.",
          "549:         \"not-wf-sa-139\", // The element-content model should not be empty.",
          "550:         \"not-wf-sa-143\", // Character #x001F is not legal anywhere in an XML document.",
          "551:         \"not-wf-sa-144\", // Character #xFFFF is not legal anywhere in an XML document.",
          "552:         \"not-wf-sa-147\", // XML Declaration may not be preceded by whitespace.",
          "553:         \"not-wf-sa-148\", // XML Declaration may not be preceded by comments or whitespace.",
          "554:         \"not-wf-sa-149\", // XML Declaration may not be within a DTD.",
          "555:         \"not-wf-sa-154\", // '<?XML ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "556:         \"not-wf-sa-155\", // '<?xmL ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "557:         \"not-wf-sa-158\", // SGML-ism:  \"#NOTATION gif\" can't have attributes.",
          "558:         \"not-wf-sa-160\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "559:         \"not-wf-sa-161\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "560:         \"not-wf-sa-162\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "561:         \"not-wf-sa-164\", // Invalid placement of Parameter entity reference.",
          "562:         \"not-wf-sa-165\", // Parameter entity declarations must have a space before     the '%'.",
          "563:         \"not-wf-sa-166\", // Character FFFF is not legal anywhere in an XML document.",
          "564:         \"not-wf-sa-167\", // Character FFFE is not legal anywhere in an XML document.",
          "565:         \"not-wf-sa-171\", // Character FFFF is not legal anywhere in an XML document.",
          "566:         \"not-wf-sa-172\", // Character FFFF is not legal anywhere in an XML document.",
          "567:         \"not-wf-sa-173\", // Character FFFF is not legal anywhere in an XML document.",
          "568:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
          "569:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
          "570:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
          "571:         \"not-wf-sa-179\", // Invalid syntax matching double quote is missing.",
          "572:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
          "573:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
          "574:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
          "575:         \"not-wf-sa-186\", // Whitespace is required between attribute/value pairs.",
          "576:         \"not-wf-not-sa-001\", // Conditional sections must be properly terminated (\"]>\" used     instead of \"]]>\").",
          "577:         \"not-wf-not-sa-002\", // Processing instruction target names may not be \"XML\"      in any combination of cases.",
          "578:         \"not-wf-not-sa-003\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "579:         \"not-wf-not-sa-004\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "580:         \"not-wf-not-sa-005\", // Tests the Entity Declared VC by referring to an     undefined parameter entity within an external entity.",
          "581:         \"not-wf-not-sa-006\", // Conditional sections need a '[' after the INCLUDE or IGNORE.",
          "582:         \"not-wf-not-sa-007\", // A <!DOCTYPE ...> declaration may not begin any external     entity; it's only found once, in the document entity.",
          "583:         \"not-wf-not-sa-008\", // In DTDs, the '%' character must be part of a parameter     entity reference.",
          "584:         \"not-wf-not-sa-009\", // This test violates WFC:PE Between Declarations in Production 28a.       The last character of a markup declaration is not contained in the same      parameter-entity text replacement.",
          "585:         \"valid-sa-012\", // Uses a legal XML 1.0 name consisting of a single colon     character (disallowed by the latest XML Namespaces draft).",
          "586:         \"valid-sa-023\", // Test demonstrates that Entity References are valid element content.",
          "587:         \"valid-sa-024\", // Test demonstrates that Entity References are valid element content and also demonstrates a valid Entity Declaration.",
          "588:         \"valid-sa-049\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "589:         \"valid-sa-050\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "590:         \"valid-sa-051\", // The document is encoded in UTF-16 and uses some name     characters well outside of the normal ASCII range.",
          "591:         \"valid-sa-053\", // Tests inclusion of a well-formed internal entity, which     holds an element required by the content model.",
          "592:         \"valid-sa-066\", // Expands a CDATA attribute with a character reference.",
          "593:         \"valid-sa-068\", // Tests definition of an internal entity holding a carriage return character     reference, which must not be normalized before reporting to the application.  Line      break normalization only occurs when parsing external parsed entities.",
          "594:         \"valid-sa-085\", // Parameter and General entities use different namespaces,     so there can be an entity of each type with a given name.",
          "595:         \"valid-sa-086\", // Tests whether entities may be declared more than once,     with the first declaration being the binding one.",
          "596:         \"valid-sa-087\", // Tests whether character references in internal entities are     expanded early enough, by relying on correct handling to     make the entity be well formed.",
          "597:         \"valid-sa-088\", // Tests whether entity references in internal entities are     expanded late enough, by relying on correct handling to     make the expanded text be valid.  (If it's expanded too     early, the entity will parse as an element that's not     valid in that context.)",
          "598:         \"valid-sa-089\", // Tests entity expansion of three legal character references,     which each expand to a Unicode surrogate pair.",
          "599:         \"valid-sa-108\", // This tests normalization of end-of-line characters (CRLF)     within entities to LF, primarily as an output test.",
          "600:         \"valid-sa-110\", // Basically an output test, this requires that a CDATA     attribute with a CRLF be normalized to one space.",
          "601:         \"valid-sa-114\", // Test demonstrates that all text within a valid CDATA section is considered text and not recognized as markup.",
          "602:         \"valid-sa-115\", // Test demonstrates that an entity reference is processed by recursively processing the replacement text of the entity.",
          "603:         \"valid-sa-117\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "604:         \"valid-sa-118\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "605:         \"valid-not-sa-031\", // Expands a general entity which contains a CDATA section with     what looks like a markup declaration (but is just text since     it's in a CDATA section).",
          "606:         \"valid-ext-sa-001\", // A combination of carriage return line feed in an external entity must     be normalized to a single newline.",
          "607:         \"valid-ext-sa-002\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "608:         \"valid-ext-sa-003\", // Test demonstrates that the content of an element can be empty. In this case the external entity is an empty file.",
          "609:         \"valid-ext-sa-004\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "610:         \"valid-ext-sa-005\", // Test demonstrates the use of optional character and content particles within an element content.  The test also show the use of external entity.",
          "611:         \"valid-ext-sa-006\", // Test demonstrates the use of optional character and content particles within mixed element content.  The test also shows the use of an external entity and that a carriage control line feed in an external entity must be normalized to a single newline.",
          "612:         \"valid-ext-sa-007\", // Test demonstrates the use of external entity and how replacement  text is retrieved and processed.",
          "613:         \"valid-ext-sa-008\", // Test demonstrates the use of external  entity and how replacement text is retrieved and processed.  Also tests the use of an  EncodingDecl of UTF-16.",
          "614:         \"valid-ext-sa-009\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "615:         \"valid-ext-sa-011\", // Test demonstrates the use of a public identifier with and external entity.   The test also show that a carriage control line feed combination in an external  entity must be normalized to a single newline.",
          "616:         \"valid-ext-sa-012\", // Test demonstrates both internal and external entities and that processing of entity references may be required to produce the correct replacement text.",
          "617:         \"valid-ext-sa-013\", // Test demonstrates that whitespace is handled by adding a single whitespace to the normalized value in the attribute list.",
          "618:         \"valid-ext-sa-014\", // Test demonstrates use of characters outside of normal ASCII range.",
          "619:     ]);",
          "620: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
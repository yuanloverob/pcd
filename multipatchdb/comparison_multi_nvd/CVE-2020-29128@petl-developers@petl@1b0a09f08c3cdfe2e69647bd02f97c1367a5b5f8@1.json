{
  "cve_id": "CVE-2020-29128",
  "cve_desc": "petl before 1.68, in some configurations, allows resolution of entities in an XML document.",
  "repo": "petl-developers/petl",
  "patch_hash": "1b0a09f08c3cdfe2e69647bd02f97c1367a5b5f8",
  "patch_info": {
    "commit_hash": "1b0a09f08c3cdfe2e69647bd02f97c1367a5b5f8",
    "repo": "petl-developers/petl",
    "commit_url": "https://github.com/petl-developers/petl/pull/527/commits/1b0a09f08c3cdfe2e69647bd02f97c1367a5b5f8",
    "files": [
      "petl/io/xml.py"
    ],
    "message": "allow using a custom/restricted xml parser",
    "before_after_code_files": [
      "petl/io/xml.py||petl/io/xml.py"
    ]
  },
  "patch_diff": {
    "petl/io/xml.py||petl/io/xml.py": [
      "File: petl/io/xml.py -> petl/io/xml.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "133:     or list of paths can be provided, e.g.,",
      "134:     ``fromxml('example.html', './/tr', ('th', 'td'))``.",
      "136:     \"\"\"",
      "138:     source = read_source_from_arg(source)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "136:     Optionally a custom parser can be provided, e.g.,",
      "137:     ``etl.fromxml('example1.xml', 'tr', 'td', parser=my_parser)``.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "162:         else:",
      "163:             assert False, 'bad parameters'",
      "164:         self.missing = kwargs.get('missing', None)",
      "166:     def __iter__(self):",
      "167:         vmatch = self.vmatch",
      "168:         vdict = self.vdict",
      "170:         with self.source.open('rb') as xmlf:",
      "173:             if not hasattr(tree, 'iterfind'):",
      "174:                 # Python 2.6 compatibility",
      "175:                 tree.iterfind = tree.findall",
      "",
      "[Removed Lines]",
      "172:             tree = etree.parse(xmlf)",
      "",
      "[Added Lines]",
      "168:         self.user_parser = kwargs.get('parser', None)",
      "175:             parser2 = _create_xml_parser(self.user_parser)",
      "176:             tree = etree.parse(xmlf, parser=parser2)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "219:                                 for f in flds)",
      "222: def element_text_getter(missing):",
      "223:     def _get(v):",
      "224:         if len(v) > 1:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226: def _create_xml_parser(user_parser):",
      "227:     if user_parser is not None:",
      "228:         return user_parser",
      "229:     try:",
      "230:         # Default lxml parser.",
      "231:         # This will throw an error if parser is not set and lxml could not be imported",
      "232:         # because Python's built XML parser doesn't like the `resolve_entities` kwarg.",
      "233:         # return etree.XMLParser(resolve_entities=False)",
      "234:         return etree.XMLParser(resolve_entities=False)",
      "235:     except TypeError:",
      "236:         # lxml not available",
      "237:         return None",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "07420ef8463cc387aea84e2d6241cf556574e2a5",
      "candidate_info": {
        "commit_hash": "07420ef8463cc387aea84e2d6241cf556574e2a5",
        "repo": "petl-developers/petl",
        "commit_url": "https://github.com/petl-developers/petl/commit/07420ef8463cc387aea84e2d6241cf556574e2a5",
        "files": [
          "petl/io/xml.py"
        ],
        "message": "allow using a custom/restricted xml parser",
        "before_after_code_files": [
          "petl/io/xml.py||petl/io/xml.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "petl/io/xml.py||petl/io/xml.py"
          ],
          "candidate": [
            "petl/io/xml.py||petl/io/xml.py"
          ]
        }
      },
      "candidate_diff": {
        "petl/io/xml.py||petl/io/xml.py": [
          "File: petl/io/xml.py -> petl/io/xml.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:     or list of paths can be provided, e.g.,",
          "134:     ``fromxml('example.html', './/tr', ('th', 'td'))``.",
          "136:     \"\"\"",
          "138:     source = read_source_from_arg(source)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:     Optionally a custom parser can be provided, e.g.,",
          "137:     ``etl.fromxml('example1.xml', 'tr', 'td', parser=my_parser)``.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:         else:",
          "163:             assert False, 'bad parameters'",
          "164:         self.missing = kwargs.get('missing', None)",
          "166:     def __iter__(self):",
          "167:         vmatch = self.vmatch",
          "168:         vdict = self.vdict",
          "170:         with self.source.open('rb') as xmlf:",
          "173:             if not hasattr(tree, 'iterfind'):",
          "174:                 # Python 2.6 compatibility",
          "175:                 tree.iterfind = tree.findall",
          "",
          "[Removed Lines]",
          "172:             tree = etree.parse(xmlf)",
          "",
          "[Added Lines]",
          "168:         self.user_parser = kwargs.get('parser', None)",
          "175:             parser2 = _create_xml_parser(self.user_parser)",
          "176:             tree = etree.parse(xmlf, parser=parser2)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "219:                                 for f in flds)",
          "222: def element_text_getter(missing):",
          "223:     def _get(v):",
          "224:         if len(v) > 1:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226: def _create_xml_parser(user_parser):",
          "227:     if user_parser is not None:",
          "228:         return user_parser",
          "229:     try:",
          "230:         # Default lxml parser.",
          "231:         # This will throw an error if parser is not set and lxml could not be imported",
          "232:         # because Python's built XML parser doesn't like the `resolve_entities` kwarg.",
          "233:         # return etree.XMLParser(resolve_entities=False)",
          "234:         return etree.XMLParser(resolve_entities=False)",
          "235:     except TypeError:",
          "236:         # lxml not available",
          "237:         return None",
          "",
          "---------------"
        ]
      }
    }
  ]
}
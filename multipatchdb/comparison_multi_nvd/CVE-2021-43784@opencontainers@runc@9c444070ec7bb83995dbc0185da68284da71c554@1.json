{
  "cve_id": "CVE-2021-43784",
  "cve_desc": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.",
  "repo": "opencontainers/runc",
  "patch_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
  "patch_info": {
    "commit_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
    "repo": "opencontainers/runc",
    "commit_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554",
    "files": [
      "libcontainer/configs/mount.go",
      "libcontainer/container_linux.go",
      "libcontainer/factory_linux.go",
      "libcontainer/init_linux.go",
      "libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go"
    ],
    "message": "Open bind mount sources from the host userns\n\nThe source of the bind mount might not be accessible in a different user\nnamespace because a component of the source path might not be traversed\nunder the users and groups mapped inside the user namespace. This caused\nerrors such as the following:\n\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\n  starting container process caused: process_linux.go:459:\n  container init caused: rootfs_linux.go:58:\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\n\nTo solve this problem, this patch performs the following:\n\n1. in nsexec.c, it opens the source path in the host userns (so we have\n   the right permissions to open it) but in the container mntns (so the\n   kernel cross mntns mount check let us mount it later:\n   https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\n\n2. in nsexec.c, it passes the file descriptors of the source to the\n   child process with SCM_RIGHTS.\n\n3. In runc-init in Golang, it finishes the mounts while inside the\n   userns even without access to the some components of the source\n   paths.\n\nPassing the fds with SCM_RIGHTS is necessary because once the child\nprocess is in the container mntns, it is already in the container userns\nso it cannot temporarily join the host mntns.\n\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment\nvariables to pass the file descriptors from runc to runc init.\n\nThis patch uses the existing mechanism with the Netlink-style bootstrap\nto pass information about the list of source mounts to nsexec.c.\n\nRootless containers don't use this bind mount sources fdpassing\nmechanism because we can't setns() to the target mntns in a rootless\ncontainer (we don't have the privileges when we are in the host userns).\n\nThis patch takes care of using O_CLOEXEC on mount fds, and close them\nearly.\n\nFixes: #2484.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
    "before_after_code_files": [
      "libcontainer/configs/mount.go||libcontainer/configs/mount.go",
      "libcontainer/container_linux.go||libcontainer/container_linux.go",
      "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
      "libcontainer/init_linux.go||libcontainer/init_linux.go",
      "libcontainer/message_linux.go||libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
    ]
  },
  "patch_diff": {
    "libcontainer/configs/mount.go||libcontainer/configs/mount.go": [
      "File: libcontainer/configs/mount.go -> libcontainer/configs/mount.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: package configs",
      "3: const (",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: import \"golang.org/x/sys/unix\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:  PostmountCmds []Command `json:\"postmount_cmds\"`",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "43: func (m *Mount) IsBind() bool {",
      "44:  return m.Flags&unix.MS_BIND != 0",
      "45: }",
      "",
      "---------------"
    ],
    "libcontainer/container_linux.go||libcontainer/container_linux.go": [
      "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "521:  return cmd",
      "522: }",
      "524: func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {",
      "525:  cmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))",
      "526:  nsMaps := make(map[configs.NamespaceType]string)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "527: func (c *linuxContainer) shouldSendMountSources() bool {",
      "530:  if !c.config.Namespaces.Contains(configs.NEWUSER) ||",
      "531:   !c.config.Namespaces.Contains(configs.NEWNS) {",
      "532:   return false",
      "533:  }",
      "537:  if c.config.RootlessEUID {",
      "538:   return false",
      "539:  }",
      "542:  for _, m := range c.config.Mounts {",
      "543:   if m.IsBind() {",
      "544:    return true",
      "545:   }",
      "546:  }",
      "548:  return false",
      "549: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "530:   }",
      "531:  }",
      "532:  _, sharePidns := nsMaps[configs.NEWPID]",
      "534:  if err != nil {",
      "535:   return nil, err",
      "536:  }",
      "537:  init := &initProcess{",
      "538:   cmd:             cmd,",
      "539:   messageSockPair: messageSockPair,",
      "",
      "[Removed Lines]",
      "533:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)",
      "",
      "[Added Lines]",
      "560:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)",
      "565:  if c.shouldSendMountSources() {",
      "568:   mountFds := make([]int, len(c.config.Mounts))",
      "569:   for i, m := range c.config.Mounts {",
      "570:    if !m.IsBind() {",
      "572:     mountFds[i] = -1",
      "573:     continue",
      "574:    }",
      "580:    cmd.ExtraFiles = append(cmd.ExtraFiles, messageSockPair.child)",
      "581:    mountFds[i] = stdioFdCount + len(cmd.ExtraFiles) - 1",
      "582:   }",
      "584:   mountFdsJson, err := json.Marshal(mountFds)",
      "585:   if err != nil {",
      "586:    return nil, fmt.Errorf(\"Error creating _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "587:   }",
      "589:   cmd.Env = append(cmd.Env,",
      "590:    \"_LIBCONTAINER_MOUNT_FDS=\"+string(mountFdsJson),",
      "591:   )",
      "592:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "558:  }",
      "562:  if err != nil {",
      "563:   return nil, err",
      "564:  }",
      "",
      "[Removed Lines]",
      "561:  data, err := c.bootstrapData(0, state.NamespacePaths)",
      "",
      "[Added Lines]",
      "618:  data, err := c.bootstrapData(0, state.NamespacePaths, initSetns)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1213:  case \"bind\":",
      "1217:    return err",
      "1218:   }",
      "1219:  default:",
      "",
      "[Removed Lines]",
      "1216:   if err := prepareBindMount(m, c.config.Rootfs); err != nil {",
      "",
      "[Added Lines]",
      "1275:   if err := prepareBindMount(m, c.config.Rootfs, nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2055:  r := nl.NewNetlinkRequest(int(InitMsg), 0)",
      "",
      "[Removed Lines]",
      "2053: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {",
      "",
      "[Added Lines]",
      "2112: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2132:   Value: c.config.RootlessEUID,",
      "2133:  })",
      "2135:  return bytes.NewReader(r.Serialize()), nil",
      "2136: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2195:  if it == initStandard && c.shouldSendMountSources() {",
      "2196:   var mounts []byte",
      "2197:   for _, m := range c.config.Mounts {",
      "2198:    if m.IsBind() {",
      "2199:     mounts = append(mounts, []byte(m.Source)...)",
      "2200:    }",
      "2201:    mounts = append(mounts, byte(0))",
      "2202:   }",
      "2204:   r.AddData(&Bytemsg{",
      "2205:    Type:  MountSourcesAttr,",
      "2206:    Value: mounts,",
      "2207:   })",
      "2208:  }",
      "",
      "---------------"
    ],
    "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
      "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "295:   return fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)",
      "296:  }",
      "300:  os.Clearenv()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "299:  mountFds, err := parseMountFds()",
      "300:  if err != nil {",
      "301:   return err",
      "302:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "305:   }",
      "306:  }()",
      "309:  if err != nil {",
      "310:   return err",
      "311:  }",
      "",
      "[Removed Lines]",
      "308:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)",
      "",
      "[Added Lines]",
      "314:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "359:   return nil",
      "360:  }",
      "361: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "369: func parseMountFds() ([]int, error) {",
      "370:  fdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
      "371:  if fdsJson == \"\" {",
      "373:   return nil, nil",
      "374:  }",
      "376:  var mountFds []int",
      "377:  if err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {",
      "378:   return nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "379:  }",
      "381:  return mountFds, nil",
      "382: }",
      "",
      "---------------"
    ],
    "libcontainer/init_linux.go||libcontainer/init_linux.go": [
      "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "76:  Init() error",
      "77: }",
      "80:  var config *initConfig",
      "81:  if err := json.NewDecoder(pipe).Decode(&config); err != nil {",
      "82:   return nil, err",
      "",
      "[Removed Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {",
      "",
      "[Added Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int, mountFds []int) (initer, error) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "86:  }",
      "87:  switch t {",
      "88:  case initSetns:",
      "89:   return &linuxSetnsInit{",
      "90:    pipe:          pipe,",
      "91:    consoleSocket: consoleSocket,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "90:   if mountFds != nil {",
      "91:    return nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100:    config:        config,",
      "101:    fifoFd:        fifoFd,",
      "102:    logFd:         logFd,",
      "103:   }, nil",
      "104:  }",
      "105:  return nil, fmt.Errorf(\"unknown init type %q\", t)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "108:    mountFds:      mountFds,",
      "",
      "---------------"
    ],
    "libcontainer/message_linux.go||libcontainer/message_linux.go": [
      "File: libcontainer/message_linux.go -> libcontainer/message_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "18:  RootlessEUIDAttr uint16 = 27287",
      "19:  UidmapPathAttr   uint16 = 27288",
      "20:  GidmapPathAttr   uint16 = 27289",
      "21: )",
      "23: type Int32msg struct {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21:  MountSourcesAttr uint16 = 27290",
      "",
      "---------------"
    ],
    "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
      "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: #include <errno.h>",
      "5: #include <fcntl.h>",
      "6: #include <grp.h>",
      "7: #include <sched.h>",
      "8: #include <setjmp.h>",
      "9: #include <signal.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:  size_t uidmappath_len;",
      "88:  char *gidmappath;",
      "89:  size_t gidmappath_len;",
      "90: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "95:  char *mountsources;",
      "96:  size_t mountsources_len;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "119: #define ROOTLESS_EUID_ATTR 27287",
      "120: #define UIDMAPPATH_ATTR  27288",
      "121: #define GIDMAPPATH_ATTR  27289",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "129: #define MOUNT_SOURCES_ATTR 27290",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "542:   case SETGROUP_ATTR:",
      "543:    config->is_setgroup = readint8(current);",
      "544:    break;",
      "545:   default:",
      "546:    bail(\"unknown netlink message type %d\", nlattr->nla_type);",
      "547:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "553:   case MOUNT_SOURCES_ATTR:",
      "554:    config->mountsources = current;",
      "555:    config->mountsources_len = payload_len;",
      "556:    break;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "633:   return 0;",
      "634: }",
      "636: void nsexec(void)",
      "637: {",
      "638:  int pipenum;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648: void receive_fd(int sockfd, int new_fd)",
      "649: {",
      "650:  int bytes_read;",
      "651:  struct msghdr msg = { };",
      "652:  struct cmsghdr *cmsg;",
      "653:  struct iovec iov = { };",
      "654:  char null_byte = '\\0';",
      "655:  int ret;",
      "656:  int fd_count;",
      "657:  int *fd_payload;",
      "659:  iov.iov_base = &null_byte;",
      "660:  iov.iov_len = 1;",
      "662:  msg.msg_iov = &iov;",
      "663:  msg.msg_iovlen = 1;",
      "665:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "666:  msg.msg_control = malloc(msg.msg_controllen);",
      "667:  if (msg.msg_control == NULL) {",
      "668:   bail(\"Can't allocate memory to receive fd.\");",
      "669:  }",
      "671:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "673:  bytes_read = recvmsg(sockfd, &msg, 0);",
      "674:  if (bytes_read != 1)",
      "675:   bail(\"failed to receive fd from unix socket %d\", sockfd);",
      "676:  if (msg.msg_flags & MSG_CTRUNC)",
      "677:   bail(\"received truncated control message from unix socket %d\", sockfd);",
      "679:  cmsg = CMSG_FIRSTHDR(&msg);",
      "680:  if (!cmsg)",
      "681:   bail(\"received message from unix socket %d without control message\", sockfd);",
      "683:  if (cmsg->cmsg_level != SOL_SOCKET)",
      "684:   bail(\"received unknown control message from unix socket %d: cmsg_level=%d\", sockfd, cmsg->cmsg_level);",
      "686:  if (cmsg->cmsg_type != SCM_RIGHTS)",
      "687:   bail(\"received unknown control message from unix socket %d: cmsg_type=%d\", sockfd, cmsg->cmsg_type);",
      "689:  fd_count = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);",
      "690:  if (fd_count != 1)",
      "691:   bail(\"received control message from unix socket %d with too many fds: %d\", sockfd, fd_count);",
      "693:  fd_payload = (int *)CMSG_DATA(cmsg);",
      "694:  ret = dup3(*fd_payload, new_fd, O_CLOEXEC);",
      "695:  if (ret < 0)",
      "696:   bail(\"cannot dup3 fd %d to %d\", *fd_payload, new_fd);",
      "698:  free(msg.msg_control);",
      "700:  ret = close(*fd_payload);",
      "701:  if (ret < 0)",
      "702:   bail(\"cannot close fd %d\", *fd_payload);",
      "703: }",
      "705: void send_fd(int sockfd, int fd)",
      "706: {",
      "707:  int bytes_written;",
      "708:  struct msghdr msg = { };",
      "709:  struct cmsghdr *cmsg;",
      "710:  struct iovec iov[1] = { };",
      "711:  char null_byte = '\\0';",
      "713:  iov[0].iov_base = &null_byte;",
      "714:  iov[0].iov_len = 1;",
      "716:  msg.msg_iov = iov;",
      "717:  msg.msg_iovlen = 1;",
      "721:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "722:  msg.msg_control = malloc(msg.msg_controllen);",
      "723:  if (msg.msg_control == NULL) {",
      "724:   bail(\"Can't allocate memory to send fd.\");",
      "725:  }",
      "727:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "729:  cmsg = CMSG_FIRSTHDR(&msg);",
      "730:  cmsg->cmsg_level = SOL_SOCKET;",
      "731:  cmsg->cmsg_type = SCM_RIGHTS;",
      "732:  cmsg->cmsg_len = CMSG_LEN(sizeof(int));",
      "733:  memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));",
      "735:  bytes_written = sendmsg(sockfd, &msg, 0);",
      "737:  free(msg.msg_control);",
      "739:  if (bytes_written != 1)",
      "740:   bail(\"failed to send fd %d via unix socket %d\", fd, sockfd);",
      "741: }",
      "743: void receive_mountsources(int sockfd)",
      "744: {",
      "745:  char *mount_fds, *endp;",
      "746:  long new_fd;",
      "749:  mount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");",
      "751:  if (mount_fds[0] != '[') {",
      "752:   bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");",
      "753:  }",
      "754:  mount_fds++;",
      "756:  for (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {",
      "757:   new_fd = strtol(mount_fds, &endp, 10);",
      "758:   if (endp == mount_fds) {",
      "759:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");",
      "760:   }",
      "761:   if (*endp == '\\0') {",
      "762:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");",
      "763:   }",
      "765:   if (new_fd == -1) {",
      "766:    continue;",
      "767:   }",
      "769:   if (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {",
      "770:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");",
      "771:   }",
      "773:   receive_fd(sockfd, new_fd);",
      "774:  }",
      "775: }",
      "777: void send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)",
      "778: {",
      "779:  char proc_path[PATH_MAX];",
      "780:  int host_mntns_fd;",
      "781:  int container_mntns_fd;",
      "782:  int fd;",
      "783:  int ret;",
      "787:  if (mountsources == NULL)",
      "788:   return;",
      "790:  host_mntns_fd = open(\"/proc/self/ns/mnt\", O_RDONLY | O_CLOEXEC);",
      "791:  if (host_mntns_fd == -1)",
      "792:   bail(\"failed to get current mount namespace\");",
      "794:  if (snprintf(proc_path, PATH_MAX, \"/proc/%d/ns/mnt\", child) < 0)",
      "795:   bail(\"failed to get mount namespace path\");",
      "797:  container_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);",
      "798:  if (container_mntns_fd == -1)",
      "799:   bail(\"failed to get container mount namespace\");",
      "801:  if (setns(container_mntns_fd, CLONE_NEWNS) < 0)",
      "802:   bail(\"failed to setns to container mntns\");",
      "804:  char *mountsources_end = mountsources + mountsources_len;",
      "805:  while (mountsources < mountsources_end) {",
      "806:   if (mountsources[0] == '\\0') {",
      "807:    mountsources++;",
      "808:    continue;",
      "809:   }",
      "811:   fd = open(mountsources, O_PATH | O_CLOEXEC);",
      "812:   if (fd < 0)",
      "813:    bail(\"failed to open mount source %s\", mountsources);",
      "815:   send_fd(sockfd, fd);",
      "817:   ret = close(fd);",
      "818:   if (ret != 0)",
      "819:    bail(\"failed to close mount source fd %d\", fd);",
      "821:   mountsources += strlen(mountsources) + 1;",
      "822:  }",
      "824:  if (setns(host_mntns_fd, CLONE_NEWNS) < 0)",
      "825:   bail(\"failed to setns to host mntns\");",
      "827:  ret = close(host_mntns_fd);",
      "828:  if (ret != 0)",
      "829:   bail(\"failed to close host mount namespace fd %d\", host_mntns_fd);",
      "830:  ret = close(container_mntns_fd);",
      "831:  if (ret != 0)",
      "832:   bail(\"failed to close container mount namespace fd %d\", container_mntns_fd);",
      "833: }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "865:       bail(\"failed to sync with runc: write(pid-JSON)\");",
      "866:      }",
      "867:      break;",
      "868:     case SYNC_CHILD_FINISH:",
      "869:      write_log(DEBUG, \"stage-1 complete\");",
      "870:      stage1_complete = true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1067:     case SYNC_MOUNTSOURCES_PLS:",
      "1068:      send_mountsources(syncfd, stage1_pid, config.mountsources,",
      "1069:          config.mountsources_len);",
      "1071:      s = SYNC_MOUNTSOURCES_ACK;",
      "1072:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1073:       kill(stage1_pid, SIGKILL);",
      "1074:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
      "1075:      }",
      "1076:      break;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1019:    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)",
      "1020:     bail(\"failed to unshare remaining namespaces (except cgroupns)\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1232:    if (config.mountsources) {",
      "1233:     s = SYNC_MOUNTSOURCES_PLS;",
      "1234:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1235:      kill(stage2_pid, SIGKILL);",
      "1236:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
      "1237:     }",
      "1240:     receive_mountsources(syncfd);",
      "1243:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1244:      kill(stage2_pid, SIGKILL);",
      "1245:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
      "1246:     }",
      "1247:     if (s != SYNC_MOUNTSOURCES_ACK) {",
      "1248:      kill(stage2_pid, SIGKILL);",
      "1249:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
      "1250:     }",
      "1251:    }",
      "",
      "---------------"
    ],
    "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
      "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:  cgroup2Path     string",
      "37:  rootlessCgroups bool",
      "38:  cgroupns        bool",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39:  fd              *int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55:  config := iConfig.Config",
      "56:  if err := prepareRoot(config); err != nil {",
      "57:   return fmt.Errorf(\"error preparing rootfs: %w\", err)",
      "58:  }",
      "60:  mountConfig := &mountConfig{",
      "61:   root:            config.Rootfs,",
      "62:   label:           config.MountLabel,",
      "",
      "[Removed Lines]",
      "54: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {",
      "",
      "[Added Lines]",
      "55: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {",
      "61:  if mountFds != nil && len(mountFds) != len(config.Mounts) {",
      "62:   return fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)",
      "63:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "65:   cgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),",
      "66:  }",
      "67:  setupDev := needsSetupDev(config)",
      "69:   for _, precmd := range m.PremountCmds {",
      "70:    if err := mountCmd(precmd); err != nil {",
      "71:     return fmt.Errorf(\"error running premount command: %w\", err)",
      "72:    }",
      "73:   }",
      "74:   if err := mountToRootfs(m, mountConfig); err != nil {",
      "75:    return fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)",
      "76:   }",
      "",
      "[Removed Lines]",
      "68:  for _, m := range config.Mounts {",
      "",
      "[Added Lines]",
      "73:  for i, m := range config.Mounts {",
      "82:   if mountFds != nil && mountFds[i] != -1 {",
      "83:    mountConfig.fd = &mountFds[i]",
      "84:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "210:  return nil",
      "211: }",
      "215:  if err != nil {",
      "",
      "[Removed Lines]",
      "213: func prepareBindMount(m *configs.Mount, rootfs string) error {",
      "214:  stat, err := os.Stat(m.Source)",
      "",
      "[Added Lines]",
      "225: func prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "226:  source := m.Source",
      "227:  if mountFd != nil {",
      "228:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "229:  }",
      "231:  stat, err := os.Stat(source)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "225:  if dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {",
      "226:   return err",
      "227:  }",
      "229:   return err",
      "230:  }",
      "231:  if err := createIfNotExists(dest, stat.IsDir()); err != nil {",
      "",
      "[Removed Lines]",
      "228:  if err := checkProcMount(rootfs, dest, m.Source); err != nil {",
      "",
      "[Added Lines]",
      "245:  if err := checkProcMount(rootfs, dest, source); err != nil {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:  oldDest := m.Destination",
      "349:  m.Destination = tmpDir",
      "351:  m.Destination = oldDest",
      "352:  if err != nil {",
      "353:   return err",
      "",
      "[Removed Lines]",
      "350:  err = mountPropagate(m, \"/\", mountLabel)",
      "",
      "[Added Lines]",
      "369:  err = mountPropagate(m, \"/\", mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "378: func mountToRootfs(m *configs.Mount, c *mountConfig) error {",
      "379:  rootfs := c.root",
      "380:  mountLabel := c.label",
      "381:  dest, err := securejoin.SecureJoin(rootfs, m.Destination)",
      "382:  if err != nil {",
      "383:   return err",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:  mountFd := c.fd",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "401:    return err",
      "402:   }",
      "405:  case \"mqueue\":",
      "406:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "407:    return err",
      "408:   }",
      "410:    return err",
      "411:   }",
      "412:   return label.SetFileLabel(dest, mountLabel)",
      "",
      "[Removed Lines]",
      "404:   return mountPropagate(m, rootfs, \"\")",
      "409:   if err := mountPropagate(m, rootfs, \"\"); err != nil {",
      "",
      "[Added Lines]",
      "424:   return mountPropagate(m, rootfs, \"\", nil)",
      "429:   if err := mountPropagate(m, rootfs, \"\", nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "421:   if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {",
      "422:    err = doTmpfsCopyUp(m, rootfs, mountLabel)",
      "423:   } else {",
      "425:   }",
      "426:   if err != nil {",
      "427:    return err",
      "428:   }",
      "429:   if stat != nil {",
      "430:    if err = os.Chmod(dest, stat.Mode()); err != nil {",
      "431:     return err",
      "",
      "[Removed Lines]",
      "424:    err = mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "444:    err = mountPropagate(m, rootfs, mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "433:   }",
      "435:   if m.Flags&unix.MS_RDONLY != 0 {",
      "437:     return err",
      "438:    }",
      "439:   }",
      "440:   return nil",
      "441:  case \"bind\":",
      "443:    return err",
      "444:   }",
      "446:    return err",
      "447:   }",
      "450:   if m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {",
      "453:     return err",
      "454:    }",
      "455:   }",
      "",
      "[Removed Lines]",
      "436:    if err := remount(m, rootfs); err != nil {",
      "442:   if err := prepareBindMount(m, rootfs); err != nil {",
      "445:   if err := mountPropagate(m, rootfs, mountLabel); err != nil {",
      "452:    if err := remount(m, rootfs); err != nil {",
      "",
      "[Added Lines]",
      "458:    if err := remount(m, rootfs, mountFd); err != nil {",
      "464:   if err := prepareBindMount(m, rootfs, mountFd); err != nil {",
      "467:   if err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {",
      "474:    if err := remount(m, rootfs, mountFd); err != nil {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "475:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "476:    return err",
      "477:   }",
      "479:  }",
      "480:  return nil",
      "481: }",
      "",
      "[Removed Lines]",
      "478:   return mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "500:   return mountPropagate(m, rootfs, mountLabel, mountFd)",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1037:  return ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)",
      "1038: }",
      "1041:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1043:  })",
      "1044: }",
      "1049:  var (",
      "1050:   data  = label.FormatMountLabel(m.Data, mountLabel)",
      "1051:   flags = m.Flags",
      "",
      "[Removed Lines]",
      "1040: func remount(m *configs.Mount, rootfs string) error {",
      "1042:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1048: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {",
      "",
      "[Added Lines]",
      "1062: func remount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "1063:  source := m.Source",
      "1064:  if mountFd != nil {",
      "1065:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1066:  }",
      "1069:   return mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1075: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1065:  if err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1067:  }); err != nil {",
      "1068:   return err",
      "1069:  }",
      "",
      "[Removed Lines]",
      "1066:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "[Added Lines]",
      "1092:  source := m.Source",
      "1093:  if mountFd != nil {",
      "1094:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1095:  }",
      "1098:   return mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "---------------"
    ],
    "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go": [
      "File: libcontainer/standard_init_linux.go -> libcontainer/standard_init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "26:  parentPid     int",
      "27:  fifoFd        int",
      "28:  logFd         int",
      "29:  config        *initConfig",
      "30: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29:  mountFds      []int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "89:  selinux.GetEnabled()",
      "91:   return err",
      "92:  }",
      "",
      "[Removed Lines]",
      "90:  if err := prepareRootfs(l.pipe, l.config); err != nil {",
      "",
      "[Added Lines]",
      "93:  err := prepareRootfs(l.pipe, l.config, l.mountFds)",
      "94:  for _, m := range l.mountFds {",
      "95:   if m == -1 {",
      "96:    continue",
      "97:   }",
      "99:   if err := unix.Close(m); err != nil {",
      "100:    return fmt.Errorf(\"Unable to close mountFds fds: %w\", err)",
      "101:   }",
      "102:  }",
      "104:  if err != nil {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "485e6c84e7ef783c126c392af072a974c9fb88ce",
      "candidate_info": {
        "commit_hash": "485e6c84e7ef783c126c392af072a974c9fb88ce",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/485e6c84e7ef783c126c392af072a974c9fb88ce",
        "files": [
          "libcontainer/factory_linux.go",
          "libcontainer/init_linux.go",
          "notify_socket.go"
        ],
        "message": "Fix some revive warnings\n\nThis is needed since the future commits will touch this code, and then\nthe lint-extra CI job complains.\n\n> libcontainer/factory.go#L245\n> var-naming: var fdsJson should be fdsJSON (revive)\n\nand\n\n> libcontainer/init_linux.go#L181\n> error-strings: error strings should not be capitalized or end with punctuation or a newline (revive)\n\nand\n\n> notify_socket.go#L94\n> receiver-naming: receiver name n should be consistent with previous receiver name s for notifySocket (revive)\n\nSigned-off-by: Kir Kolyshkin <kolyshkin@gmail.com>",
        "before_after_code_files": [
          "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
          "libcontainer/init_linux.go||libcontainer/init_linux.go",
          "notify_socket.go||notify_socket.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go"
          ],
          "candidate": [
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
          "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "400: }",
          "402: func parseMountFds() ([]int, error) {",
          "406:   return nil, nil",
          "407:  }",
          "409:  var mountFds []int",
          "411:   return nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)",
          "412:  }",
          "",
          "[Removed Lines]",
          "403:  fdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
          "404:  if fdsJson == \"\" {",
          "410:  if err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {",
          "",
          "[Added Lines]",
          "403:  fdsJSON := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
          "404:  if fdsJSON == \"\" {",
          "410:  if err := json.Unmarshal([]byte(fdsJSON), &mountFds); err != nil {",
          "",
          "---------------"
        ],
        "libcontainer/init_linux.go||libcontainer/init_linux.go": [
          "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  case initSetns:",
          "89:   if mountFds != nil {",
          "91:   }",
          "93:   return &linuxSetnsInit{",
          "",
          "[Removed Lines]",
          "90:    return nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")",
          "",
          "[Added Lines]",
          "90:    return nil, errors.New(\"mountFds must be nil; can't mount from exec\")",
          "",
          "---------------"
        ],
        "notify_socket.go||notify_socket.go": [
          "File: notify_socket.go -> notify_socket.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:  return notifySocket, nil",
          "92: }",
          "96:  if err != nil {",
          "97:   return err",
          "98:  }",
          "100: }",
          "102: func (n *notifySocket) run(pid1 int) error {",
          "",
          "[Removed Lines]",
          "94: func (n *notifySocket) waitForContainer(container libcontainer.Container) error {",
          "95:  s, err := container.State()",
          "99:  return n.run(s.InitProcessPid)",
          "",
          "[Added Lines]",
          "94: func (s *notifySocket) waitForContainer(container libcontainer.Container) error {",
          "95:  state, err := container.State()",
          "99:  return s.run(state.InitProcessPid)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "35e6c3bf794326ad7844aa2e25efd4946a7addbe",
      "candidate_info": {
        "commit_hash": "35e6c3bf794326ad7844aa2e25efd4946a7addbe",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/35e6c3bf794326ad7844aa2e25efd4946a7addbe",
        "files": [
          "libcontainer/nsenter/nsexec.c"
        ],
        "message": "libct/nsenter: switch to sane_kill()\n\nSigned-off-by: guodong <guodong9211@gmail.com>",
        "before_after_code_files": [
          "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ],
          "candidate": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
          "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1069:      s = SYNC_MOUNTSOURCES_ACK;",
          "1070:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1072:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
          "1073:      }",
          "1074:      break;",
          "",
          "[Removed Lines]",
          "1071:       kill(stage1_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1071:       sane_kill(stage1_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1230:    if (config.mountsources) {",
          "1231:     s = SYNC_MOUNTSOURCES_PLS;",
          "1232:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1234:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
          "1235:     }",
          "",
          "[Removed Lines]",
          "1233:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1233:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1241:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1243:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
          "1244:     }",
          "1245:     if (s != SYNC_MOUNTSOURCES_ACK) {",
          "1247:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
          "1248:     }",
          "1249:    }",
          "",
          "[Removed Lines]",
          "1242:      kill(stage2_pid, SIGKILL);",
          "1246:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1242:      sane_kill(stage2_pid, SIGKILL);",
          "1246:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50105de1d87ed0994c32cc9fd57efd0a0f6ef544",
      "candidate_info": {
        "commit_hash": "50105de1d87ed0994c32cc9fd57efd0a0f6ef544",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/50105de1d87ed0994c32cc9fd57efd0a0f6ef544",
        "files": [
          ".cirrus.yml",
          ".github/workflows/test.yml",
          "Dockerfile",
          "Vagrantfile.fedora",
          "libcontainer/rootfs_linux.go",
          "tests/integration/mounts_sshfs.bats"
        ],
        "message": "Fix failure with rw bind mount of a ro fuse\n\nAs reported in [1], in a case where read-only fuse (sshfs) mount\nis used as a volume without specifying ro flag, the kernel fails\nto remount it (when adding various flags such as nosuid and nodev),\nreturning EPERM.\n\nHere's the relevant strace line:\n\n> [pid 333966] mount(\"/tmp/bats-run-PRVfWc/runc.RbNv8g/bundle/mnt\", \"/proc/self/fd/7\", 0xc0001e9164, MS_NOSUID|MS_NODEV|MS_REMOUNT|MS_BIND|MS_REC, NULL) = -1 EPERM (Operation not permitted)\n\nI was not able to reproduce it with other read-only mounts as the source\n(tried tmpfs, read-only bind mount, and an ext2 mount), so somehow this\nmight be specific to fuse.\n\nThe fix is to check whether the source has RDONLY flag, and retry the\nremount with this flag added.\n\nA test case (which was kind of hard to write) is added, and it fails\nwithout the fix. Note that rootless user need to be able to ssh to\nrootless@localhost in order to sshfs to work -- amend setup scripts\nto make it work, and skip the test if the setup is not working.\n\n[1] https://github.com/containers/podman/issues/12205\n\nSigned-off-by: Kir Kolyshkin <kolyshkin@gmail.com>",
        "before_after_code_files": [
          "Vagrantfile.fedora||Vagrantfile.fedora",
          "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
          "tests/integration/mounts_sshfs.bats||tests/integration/mounts_sshfs.bats"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ],
          "candidate": [
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "Vagrantfile.fedora||Vagrantfile.fedora": [
          "File: Vagrantfile.fedora -> Vagrantfile.fedora",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       cat << EOF | dnf -y --exclude=kernel,kernel-core,systemd,systemd-* shell && break",
          "28: config install_weak_deps false",
          "29: update",
          "31: ts run",
          "32: EOF",
          "33:     done",
          "",
          "[Removed Lines]",
          "30: install iptables gcc make golang-go glibc-static libseccomp-devel bats jq git-core criu",
          "",
          "[Added Lines]",
          "30: install iptables gcc make golang-go glibc-static libseccomp-devel bats jq git-core criu fuse-sshfs",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     # Add a user for rootless tests",
          "37:     useradd -u2000 -m -d/home/rootless -s/bin/bash rootless",
          "40:     ssh-keygen -t ecdsa -N \"\" -f /root/rootless.key",
          "41:     mkdir -m 0700 -p /home/rootless/.ssh",
          "42:     cat /root/rootless.key.pub >> /home/rootless/.ssh/authorized_keys",
          "43:     chown -R rootless.rootless /home/rootless",
          "",
          "[Removed Lines]",
          "39:     # Allow root to execute `ssh rootless@localhost` in tests/rootless.sh",
          "",
          "[Added Lines]",
          "39:     # Allow root and rootless itself to execute `ssh rootless@localhost` in tests/rootless.sh",
          "42:     cp /root/rootless.key /home/rootless/.ssh/id_ecdsa",
          "",
          "---------------"
        ],
        "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
          "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1065:  }",
          "1067:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
          "1069:  })",
          "1070: }",
          "",
          "[Removed Lines]",
          "1068:   return mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
          "",
          "[Added Lines]",
          "1068:   flags := uintptr(m.Flags | unix.MS_REMOUNT)",
          "1069:   err := mount(source, m.Destination, procfd, m.Device, flags, \"\")",
          "1070:   if err == nil {",
          "1071:    return nil",
          "1072:   }",
          "1074:   var s unix.Statfs_t",
          "1075:   if err := unix.Statfs(source, &s); err != nil {",
          "1076:    return &os.PathError{Op: \"statfs\", Path: source, Err: err}",
          "1077:   }",
          "1078:   if s.Flags&unix.MS_RDONLY != unix.MS_RDONLY {",
          "1079:    return err",
          "1080:   }",
          "1082:   flags |= unix.MS_RDONLY",
          "1083:   return mount(source, m.Destination, procfd, m.Device, flags, \"\")",
          "",
          "---------------"
        ],
        "tests/integration/mounts_sshfs.bats||tests/integration/mounts_sshfs.bats": [
          "File: tests/integration/mounts_sshfs.bats -> tests/integration/mounts_sshfs.bats",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bats",
          "3: load helpers",
          "5: function setup() {",
          "6:  # Create a ro fuse-sshfs mount; skip the test if it's not working.",
          "7:  local sshfs=\"sshfs",
          "8:   -o UserKnownHostsFile=/dev/null",
          "9:   -o StrictHostKeyChecking=no",
          "10:   -o PasswordAuthentication=no\"",
          "12:  DIR=\"$BATS_RUN_TMPDIR/fuse-sshfs\"",
          "13:  mkdir -p \"$DIR\"",
          "15:  if ! $sshfs -o ro rootless@localhost: \"$DIR\"; then",
          "16:   skip \"test requires working sshfs mounts\"",
          "17:  fi",
          "19:  setup_hello",
          "20: }",
          "22: function teardown() {",
          "23:  # New distros (Fedora 35) do not have fusermount installed",
          "24:  # as a dependency of fuse-sshfs, and good ol' umount works.",
          "25:  fusermount -u \"$DIR\" || umount \"$DIR\"",
          "27:  teardown_bundle",
          "28: }",
          "30: @test \"runc run [rw bind mount of a ro fuse sshfs mount]\" {",
          "31:  update_config '   .mounts += [{",
          "32:      type: \"bind\",",
          "33:      source: \"'\"$DIR\"'\",",
          "34:      destination: \"/mnt\",",
          "35:      options: [\"rw\", \"rprivate\", \"nosuid\", \"nodev\", \"rbind\"]",
          "36:     }]'",
          "38:  runc run test_busybox",
          "39:  [ \"$status\" -eq 0 ]",
          "40: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-21368",
  "cve_desc": "msgpack5 is a msgpack v5 implementation for node.js and the browser. In msgpack5 before versions 3.6.1, 4.5.1, and 5.2.1 there is a \"Prototype Poisoning\" vulnerability. When msgpack5 decodes a map containing a key \"__proto__\", it assigns the decoded value to __proto__. Object.prototype.__proto__ is an accessor property for the receiver's prototype. If the value corresponding to the key __proto__ decodes to an object or null, msgpack5 sets the decoded object's prototype to that value. An attacker who can submit crafted MessagePack data to a service can use this to produce values that appear to be of other types; may have unexpected prototype properties and methods (for example length, numeric properties, and push et al if __proto__'s value decodes to an Array); and/or may throw unexpected exceptions when used (for example if the __proto__ value decodes to a Map or Date). Other unexpected behavior might be produced for other types. There is no effect on the global prototype. This \"prototype poisoning\" is sort of a very limited inversion of a prototype pollution attack. Only the decoded value's prototype is affected, and it can only be set to msgpack5 values (though if the victim makes use of custom codecs, anything could be a msgpack5 value). We have not found a way to escalate this to true prototype pollution (absent other bugs in the consumer's code). This has been fixed in msgpack5 version 3.6.1, 4.5.1, and 5.2.1. See the referenced GitHub Security Advisory for an example and more details.",
  "repo": "mcollina/msgpack5",
  "patch_hash": "d4e6cb956ae51c8bb2828e71c7c1107c340cf1e8",
  "patch_info": {
    "commit_hash": "d4e6cb956ae51c8bb2828e71c7c1107c340cf1e8",
    "repo": "mcollina/msgpack5",
    "commit_url": "https://github.com/mcollina/msgpack5/commit/d4e6cb956ae51c8bb2828e71c7c1107c340cf1e8",
    "files": [
      "README.md",
      "index.js",
      "lib/decoder.js",
      "test/object-prototype-poisoning.js"
    ],
    "message": "Merge pull request from GHSA-gmjw-49p4-pcfm\n\nCo-authored-by: Simone Busoli <simone.busoli@gmail.com>",
    "before_after_code_files": [
      "index.js||index.js",
      "lib/decoder.js||lib/decoder.js",
      "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
    ]
  },
  "patch_diff": {
    "index.js||index.js": [
      "File: index.js -> index.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "21:     disableTimestampEncoding: false,",
      "23:   }",
      "25:   decodingTypes.set(DateCodec.type, DateCodec.decode)",
      "",
      "[Removed Lines]",
      "22:     preferMap: false",
      "",
      "[Added Lines]",
      "22:     preferMap: false,",
      "24:     protoAction: 'error'",
      "",
      "---------------"
    ],
    "lib/decoder.js||lib/decoder.js": [
      "File: lib/decoder.js -> lib/decoder.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "187:       for (let i = 0; i < 2 * length; i += 2) {",
      "188:         const key = result[i]",
      "189:         const val = result[i + 1]",
      "190:         object[key] = val",
      "191:       }",
      "192:       return [object, consumedBytes]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "191:         if (key === '__proto__') {",
      "192:           if (options.protoAction === 'error') {",
      "193:             throw new SyntaxError('Object contains forbidden prototype property')",
      "194:           }",
      "196:           if (options.protoAction === 'remove') {",
      "197:             continue",
      "198:           }",
      "199:         }",
      "",
      "---------------"
    ],
    "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js": [
      "File: test/object-prototype-poisoning.js -> test/object-prototype-poisoning.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: 'use strict'",
      "3: var test = require('tape').test",
      "4: var msgpack = require('../')",
      "6: test('decode throws when object has forbidden __proto__ property', function (t) {",
      "7:   const encoder = msgpack()",
      "9:   const payload = { hello: 'world' }",
      "10:   Object.defineProperty(payload, '__proto__', {",
      "11:     value: { polluted: true },",
      "12:     enumerable: true",
      "13:   })",
      "15:   const encoded = encoder.encode(payload)",
      "17:   t.throws(() => encoder.decode(encoded), /Object contains forbidden prototype property/)",
      "18:   t.end()",
      "19: })",
      "21: test('decode ignores forbidden __proto__ property if protoAction is \"ignore\"', function (t) {",
      "22:   const encoder = msgpack({ protoAction: 'ignore' })",
      "24:   const payload = { hello: 'world' }",
      "25:   Object.defineProperty(payload, '__proto__', {",
      "26:     value: { polluted: true },",
      "27:     enumerable: true",
      "28:   })",
      "30:   const decoded = encoder.decode(encoder.encode(payload))",
      "32:   t.equal(decoded.polluted, true)",
      "33:   t.end()",
      "34: })",
      "36: test('decode removes forbidden __proto__ property if protoAction is \"remove\"', function (t) {",
      "37:   const encoder = msgpack({ protoAction: 'remove' })",
      "39:   const payload = { hello: 'world' }",
      "40:   Object.defineProperty(payload, '__proto__', {",
      "41:     value: { polluted: true },",
      "42:     enumerable: true",
      "43:   })",
      "45:   const decoded = encoder.decode(encoder.encode(payload))",
      "47:   t.equal(decoded.polluted, undefined)",
      "48:   t.end()",
      "49: })",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "76bd44f6ef77b206cd9c6b1d2ef1afe9fff0c829",
      "candidate_info": {
        "commit_hash": "76bd44f6ef77b206cd9c6b1d2ef1afe9fff0c829",
        "repo": "mcollina/msgpack5",
        "commit_url": "https://github.com/mcollina/msgpack5/commit/76bd44f6ef77b206cd9c6b1d2ef1afe9fff0c829",
        "files": [
          "lib/decoder.js",
          "test/nested-containers.js"
        ],
        "message": "Move most functions out of closure (#101)\n\n* Move most functions out of closure\n\n* Fix regression\n\n* Add possible regression test",
        "before_after_code_files": [
          "lib/decoder.js||lib/decoder.js",
          "test/nested-containers.js||test/nested-containers.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/decoder.js||lib/decoder.js"
          ],
          "candidate": [
            "lib/decoder.js||lib/decoder.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/decoder.js||lib/decoder.js": [
          "File: lib/decoder.js -> lib/decoder.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: }",
          "40: module.exports = function buildDecode (decodingTypes, options) {",
          "41:   return decode",
          "43:   function decode (buf) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41:   const context = { decodingTypes, options, decode }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:       buf = bl().append(buf)",
          "47:     }",
          "51:     if (!result) throw new IncompleteBufferError()",
          "53:     buf.consume(result[1])",
          "54:     return result[0]",
          "55:   }",
          "100:     }",
          "127:     }",
          "148:     }",
          "152:   }",
          "212:     }",
          "213:   }",
          "269:   }",
          "270: }",
          "",
          "[Removed Lines]",
          "49:     const result = tryDecode(buf, 0)",
          "57:   function tryDecode (buf, initialOffset) {",
          "58:     if (buf.length <= initialOffset) return null",
          "60:     const bufLength = buf.length - initialOffset",
          "61:     let offset = initialOffset",
          "63:     const first = buf.readUInt8(offset)",
          "64:     offset += 1",
          "66:     const size = SIZES[first] || -1",
          "67:     if (bufLength < size) return null",
          "69:     const inRange = (start, end) => first >= start && first <= end",
          "71:     if (first < 0x80) return [first, 1] // 7-bits positive ints",
          "72:     if ((first & 0xf0) === 0x80) {",
          "73:       const length = first & 0x0f",
          "74:       const headerSize = offset - initialOffset",
          "76:       return decodeMap(buf, offset, length, headerSize, options)",
          "77:     }",
          "78:     if ((first & 0xf0) === 0x90) {",
          "79:       const length = first & 0x0f",
          "80:       const headerSize = offset - initialOffset",
          "82:       return decodeArray(buf, offset, length, headerSize)",
          "83:     }",
          "85:     if ((first & 0xe0) === 0xa0) {",
          "87:       const length = first & 0x1f",
          "88:       if (!isValidDataSize(length, bufLength, 1)) return null",
          "89:       const result = buf.toString('utf8', offset, offset + length)",
          "90:       return [result, length + 1]",
          "91:     }",
          "92:     if (inRange(0xc0, 0xc3)) return decodeConstants(first)",
          "93:     if (inRange(0xc4, 0xc6)) {",
          "94:       const length = buf.readUIntBE(offset, size - 1)",
          "95:       offset += size - 1",
          "97:       if (!isValidDataSize(length, bufLength, size)) return null",
          "98:       const result = buf.slice(offset, offset + length)",
          "99:       return [result, size + length]",
          "101:     if (inRange(0xc7, 0xc9)) {",
          "102:       const length = buf.readUIntBE(offset, size - 2)",
          "103:       offset += size - 2",
          "105:       const type = buf.readInt8(offset)",
          "106:       offset += 1",
          "108:       if (!isValidDataSize(length, bufLength, size)) return null",
          "109:       return decodeExt(buf, offset, type, length, size)",
          "110:     }",
          "111:     if (inRange(0xca, 0xcb)) return decodeFloat(buf, offset, size - 1)",
          "112:     if (inRange(0xcc, 0xcf)) return decodeUnsignedInt(buf, offset, size - 1)",
          "113:     if (inRange(0xd0, 0xd3)) return decodeSigned(buf, offset, size - 1)",
          "114:     if (inRange(0xd4, 0xd8)) {",
          "115:       const type = buf.readInt8(offset) // Signed",
          "116:       offset += 1",
          "117:       return decodeExt(buf, offset, type, size - 2, 2)",
          "118:     }",
          "120:     if (inRange(0xd9, 0xdb)) {",
          "121:       const length = buf.readUIntBE(offset, size - 1)",
          "122:       offset += size - 1",
          "124:       if (!isValidDataSize(length, bufLength, size)) return null",
          "125:       const result = buf.toString('utf8', offset, offset + length)",
          "126:       return [result, size + length]",
          "128:     if (inRange(0xdc, 0xdd)) {",
          "129:       const length = buf.readUIntBE(offset, size - 1)",
          "130:       offset += size - 1",
          "131:       return decodeArray(buf, offset, length, size)",
          "132:     }",
          "133:     if (inRange(0xde, 0xdf)) {",
          "134:       let length",
          "135:       switch (first) {",
          "136:         case 0xde:",
          "138:           length = buf.readUInt16BE(offset)",
          "139:           offset += 2",
          "141:           return decodeMap(buf, offset, length, 3, options)",
          "143:         case 0xdf:",
          "144:           length = buf.readUInt32BE(offset)",
          "145:           offset += 4",
          "146:           return decodeMap(buf, offset, length, 5, options)",
          "147:       }",
          "149:     if (first >= 0xe0) return [first - 0x100, 1] // 5 bits negative ints",
          "151:     throw new Error('not implemented yet')",
          "154:   function decodeArray (buf, initialOffset, length, headerLength) {",
          "155:     let offset = initialOffset",
          "156:     const result = []",
          "157:     let i = 0",
          "159:     while (i++ < length) {",
          "160:       const decodeResult = tryDecode(buf, offset)",
          "161:       if (!decodeResult) return null",
          "163:       result.push(decodeResult[0])",
          "164:       offset += decodeResult[1]",
          "165:     }",
          "166:     return [result, headerLength + offset - initialOffset]",
          "167:   }",
          "169:   function decodeMap (buf, offset, length, headerLength, options) {",
          "170:     const _temp = decodeArray(buf, offset, 2 * length, headerLength)",
          "171:     if (!_temp) return null",
          "172:     const [result, consumedBytes] = _temp",
          "174:     let isPlainObject = !options.preferMap",
          "176:     if (isPlainObject) {",
          "177:       for (let i = 0; i < 2 * length; i += 2) {",
          "178:         if (typeof result[i] !== 'string') {",
          "179:           isPlainObject = false",
          "180:           break",
          "181:         }",
          "182:       }",
          "183:     }",
          "185:     if (isPlainObject) {",
          "186:       const object = {}",
          "187:       for (let i = 0; i < 2 * length; i += 2) {",
          "188:         const key = result[i]",
          "189:         const val = result[i + 1]",
          "191:         if (key === '__proto__') {",
          "192:           if (options.protoAction === 'error') {",
          "193:             throw new SyntaxError('Object contains forbidden prototype property')",
          "194:           }",
          "196:           if (options.protoAction === 'remove') {",
          "197:             continue",
          "198:           }",
          "199:         }",
          "201:         object[key] = val",
          "202:       }",
          "203:       return [object, consumedBytes]",
          "204:     } else {",
          "205:       const mapping = new Map()",
          "206:       for (let i = 0; i < 2 * length; i += 2) {",
          "207:         const key = result[i]",
          "208:         const val = result[i + 1]",
          "209:         mapping.set(key, val)",
          "210:       }",
          "211:       return [mapping, consumedBytes]",
          "215:   function readInt64BE (buf, offset) {",
          "216:     var negate = (buf[offset] & 0x80) == 0x80; // eslint-disable-line",
          "218:     if (negate) {",
          "219:       let carry = 1",
          "220:       for (let i = offset + 7; i >= offset; i--) {",
          "221:         const v = (buf[i] ^ 0xff) + carry",
          "222:         buf[i] = v & 0xff",
          "223:         carry = v >> 8",
          "224:       }",
          "225:     }",
          "227:     const hi = buf.readUInt32BE(offset + 0)",
          "228:     const lo = buf.readUInt32BE(offset + 4)",
          "229:     return (hi * 4294967296 + lo) * (negate ? -1 : +1)",
          "230:   }",
          "232:   function decodeUnsignedInt (buf, offset, size) {",
          "233:     const maxOffset = offset + size",
          "234:     let result = 0",
          "235:     while (offset < maxOffset) { result += buf.readUInt8(offset++) * Math.pow(256, maxOffset - offset) }",
          "236:     return [result, size + 1]",
          "237:   }",
          "239:   function decodeConstants (first) {",
          "240:     if (first === 0xc0) return [null, 1]",
          "241:     if (first === 0xc2) return [false, 1]",
          "242:     if (first === 0xc3) return [true, 1]",
          "243:   }",
          "245:   function decodeSigned (buf, offset, size) {",
          "246:     let result",
          "247:     if (size === 1) result = buf.readInt8(offset)",
          "248:     if (size === 2) result = buf.readInt16BE(offset)",
          "249:     if (size === 4) result = buf.readInt32BE(offset)",
          "250:     if (size === 8) result = readInt64BE(buf.slice(offset, offset + 8), 0)",
          "251:     return [result, size + 1]",
          "252:   }",
          "254:   function decodeFloat (buf, offset, size) {",
          "255:     let result",
          "256:     if (size === 4) result = buf.readFloatBE(offset)",
          "257:     if (size === 8) result = buf.readDoubleBE(offset)",
          "258:     return [result, size + 1]",
          "259:   }",
          "261:   function decodeExt (buf, offset, type, size, headerSize) {",
          "262:     const toDecode = buf.slice(offset, offset + size)",
          "264:     const decode = decodingTypes.get(type)",
          "265:     if (!decode) throw new Error('unable to find ext type ' + type)",
          "267:     const value = decode(toDecode)",
          "268:     return [value, headerSize + size]",
          "",
          "[Added Lines]",
          "50:     const result = tryDecode(buf, 0, context)",
          "57: }",
          "59: function decodeArray (buf, initialOffset, length, headerLength, context) {",
          "60:   let offset = initialOffset",
          "61:   const result = []",
          "62:   let i = 0",
          "64:   while (i++ < length) {",
          "65:     const decodeResult = tryDecode(buf, offset, context)",
          "66:     if (!decodeResult) return null",
          "68:     result.push(decodeResult[0])",
          "69:     offset += decodeResult[1]",
          "70:   }",
          "71:   return [result, headerLength + offset - initialOffset]",
          "72: }",
          "74: function decodeMap (buf, offset, length, headerLength, context) {",
          "75:   const _temp = decodeArray(buf, offset, 2 * length, headerLength, context)",
          "76:   if (!_temp) return null",
          "77:   const [result, consumedBytes] = _temp",
          "79:   let isPlainObject = !context.options.preferMap",
          "81:   if (isPlainObject) {",
          "82:     for (let i = 0; i < 2 * length; i += 2) {",
          "83:       if (typeof result[i] !== 'string') {",
          "84:         isPlainObject = false",
          "85:         break",
          "86:       }",
          "88:   }",
          "90:   if (isPlainObject) {",
          "91:     const object = {}",
          "92:     for (let i = 0; i < 2 * length; i += 2) {",
          "93:       const key = result[i]",
          "94:       const val = result[i + 1]",
          "96:       if (key === '__proto__') {",
          "97:         if (context.options.protoAction === 'error') {",
          "98:           throw new SyntaxError('Object contains forbidden prototype property')",
          "99:         }",
          "101:         if (context.options.protoAction === 'remove') {",
          "102:           continue",
          "103:         }",
          "104:       }",
          "106:       object[key] = val",
          "108:     return [object, consumedBytes]",
          "109:   } else {",
          "110:     const mapping = new Map()",
          "111:     for (let i = 0; i < 2 * length; i += 2) {",
          "112:       const key = result[i]",
          "113:       const val = result[i + 1]",
          "114:       mapping.set(key, val)",
          "116:     return [mapping, consumedBytes]",
          "118: }",
          "120: function tryDecode (buf, initialOffset, context) {",
          "121:   if (buf.length <= initialOffset) return null",
          "123:   const bufLength = buf.length - initialOffset",
          "124:   let offset = initialOffset",
          "126:   const first = buf.readUInt8(offset)",
          "127:   offset += 1",
          "129:   const size = SIZES[first] || -1",
          "130:   if (bufLength < size) return null",
          "132:   if (first < 0x80) return [first, 1] // 7-bits positive ints",
          "133:   if ((first & 0xf0) === 0x80) {",
          "134:     const length = first & 0x0f",
          "135:     const headerSize = offset - initialOffset",
          "137:     return decodeMap(buf, offset, length, headerSize, context)",
          "138:   }",
          "139:   if ((first & 0xf0) === 0x90) {",
          "140:     const length = first & 0x0f",
          "141:     const headerSize = offset - initialOffset",
          "143:     return decodeArray(buf, offset, length, headerSize, context)",
          "144:   }",
          "146:   if ((first & 0xe0) === 0xa0) {",
          "148:     const length = first & 0x1f",
          "149:     if (!isValidDataSize(length, bufLength, 1)) return null",
          "150:     const result = buf.toString('utf8', offset, offset + length)",
          "151:     return [result, length + 1]",
          "152:   }",
          "153:   if (first >= 0xc0 && first <= 0xc3) return decodeConstants(first)",
          "154:   if (first >= 0xc4 && first <= 0xc6) {",
          "155:     const length = buf.readUIntBE(offset, size - 1)",
          "156:     offset += size - 1",
          "158:     if (!isValidDataSize(length, bufLength, size)) return null",
          "159:     const result = buf.slice(offset, offset + length)",
          "160:     return [result, size + length]",
          "161:   }",
          "162:   if (first >= 0xc7 && first <= 0xc9) {",
          "163:     const length = buf.readUIntBE(offset, size - 2)",
          "164:     offset += size - 2",
          "166:     const type = buf.readInt8(offset)",
          "167:     offset += 1",
          "169:     if (!isValidDataSize(length, bufLength, size)) return null",
          "170:     return decodeExt(buf, offset, type, length, size, context)",
          "171:   }",
          "172:   if (first >= 0xca && first <= 0xcb) return decodeFloat(buf, offset, size - 1)",
          "173:   if (first >= 0xcc && first <= 0xcf) return decodeUnsignedInt(buf, offset, size - 1)",
          "174:   if (first >= 0xd0 && first <= 0xd3) return decodeSigned(buf, offset, size - 1)",
          "175:   if (first >= 0xd4 && first <= 0xd8) {",
          "176:     const type = buf.readInt8(offset) // Signed",
          "177:     offset += 1",
          "178:     return decodeExt(buf, offset, type, size - 2, 2, context)",
          "179:   }",
          "181:   if (first >= 0xd9 && first <= 0xdb) {",
          "182:     const length = buf.readUIntBE(offset, size - 1)",
          "183:     offset += size - 1",
          "185:     if (!isValidDataSize(length, bufLength, size)) return null",
          "186:     const result = buf.toString('utf8', offset, offset + length)",
          "187:     return [result, size + length]",
          "188:   }",
          "189:   if (first >= 0xdc && first <= 0xdd) {",
          "190:     const length = buf.readUIntBE(offset, size - 1)",
          "191:     offset += size - 1",
          "192:     return decodeArray(buf, offset, length, size, context)",
          "193:   }",
          "194:   if (first >= 0xde && first <= 0xdf) {",
          "195:     let length",
          "196:     switch (first) {",
          "197:       case 0xde:",
          "199:         length = buf.readUInt16BE(offset)",
          "200:         offset += 2",
          "202:         return decodeMap(buf, offset, length, 3, context)",
          "204:       case 0xdf:",
          "205:         length = buf.readUInt32BE(offset)",
          "206:         offset += 4",
          "207:         return decodeMap(buf, offset, length, 5, context)",
          "210:   if (first >= 0xe0) return [first - 0x100, 1] // 5 bits negative ints",
          "212:   throw new Error('not implemented yet')",
          "213: }",
          "215: function decodeSigned (buf, offset, size) {",
          "216:   let result",
          "217:   if (size === 1) result = buf.readInt8(offset)",
          "218:   if (size === 2) result = buf.readInt16BE(offset)",
          "219:   if (size === 4) result = buf.readInt32BE(offset)",
          "220:   if (size === 8) result = readInt64BE(buf.slice(offset, offset + 8), 0)",
          "221:   return [result, size + 1]",
          "222: }",
          "224: function decodeExt (buf, offset, type, size, headerSize, context) {",
          "225:   const toDecode = buf.slice(offset, offset + size)",
          "227:   const decode = context.decodingTypes.get(type)",
          "228:   if (!decode) throw new Error('unable to find ext type ' + type)",
          "230:   const value = decode(toDecode)",
          "231:   return [value, headerSize + size]",
          "232: }",
          "234: function decodeUnsignedInt (buf, offset, size) {",
          "235:   const maxOffset = offset + size",
          "236:   let result = 0",
          "237:   while (offset < maxOffset) { result += buf.readUInt8(offset++) * Math.pow(256, maxOffset - offset) }",
          "238:   return [result, size + 1]",
          "239: }",
          "241: function decodeConstants (first) {",
          "242:   if (first === 0xc0) return [null, 1]",
          "243:   if (first === 0xc2) return [false, 1]",
          "244:   if (first === 0xc3) return [true, 1]",
          "245: }",
          "247: function decodeFloat (buf, offset, size) {",
          "248:   let result",
          "249:   if (size === 4) result = buf.readFloatBE(offset)",
          "250:   if (size === 8) result = buf.readDoubleBE(offset)",
          "251:   return [result, size + 1]",
          "252: }",
          "254: function readInt64BE (buf, offset) {",
          "255:   var negate = (buf[offset] & 0x80) == 0x80; // eslint-disable-line",
          "257:   if (negate) {",
          "258:     let carry = 1",
          "259:     for (let i = offset + 7; i >= offset; i--) {",
          "260:       const v = (buf[i] ^ 0xff) + carry",
          "261:       buf[i] = v & 0xff",
          "262:       carry = v >> 8",
          "263:     }",
          "266:   const hi = buf.readUInt32BE(offset + 0)",
          "267:   const lo = buf.readUInt32BE(offset + 4)",
          "268:   return (hi * 4294967296 + lo) * (negate ? -1 : +1)",
          "",
          "---------------"
        ],
        "test/nested-containers.js||test/nested-containers.js": [
          "File: test/nested-containers.js -> test/nested-containers.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: 'use strict'",
          "3: const test = require('tape').test",
          "4: const msgpack = require('../')",
          "6: test('encode/decode nested containers (map/array)', function (t) {",
          "7:   const encoder = msgpack()",
          "9:   function doEncodeDecode (value) {",
          "10:     return encoder.decode(encoder.encode(value))",
          "11:   }",
          "13:   function preserveTest (A, message = 'works') {",
          "14:     const B = doEncodeDecode(A)",
          "15:     t.deepEqual(A, B, message)",
          "16:   }",
          "18:   preserveTest({",
          "19:     hello: 'world',",
          "20:     digit: 111,",
          "21:     array: [1, 2, 3, 4, 'string', { hello: 'world' }]",
          "22:   })",
          "24:   preserveTest([",
          "25:     [",
          "26:       {",
          "27:         hello: 'world',",
          "28:         array: [1, 2, 3, 4, 'string', { hello: 'world' }]",
          "29:       },",
          "30:       {",
          "31:         digit: 111",
          "32:       }",
          "33:     ],",
          "34:     [",
          "35:       {",
          "36:         hello: 'world',",
          "37:         digit: 111,",
          "38:         array: [1, 2, 3, 4, 'string', { hello: 'world' }]",
          "39:       }",
          "40:     ]",
          "41:   ])",
          "43:   t.end()",
          "44: })",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0ee5af9c4ef16b756beed23b131ff5ed9b8588e",
      "candidate_info": {
        "commit_hash": "f0ee5af9c4ef16b756beed23b131ff5ed9b8588e",
        "repo": "mcollina/msgpack5",
        "commit_url": "https://github.com/mcollina/msgpack5/commit/f0ee5af9c4ef16b756beed23b131ff5ed9b8588e",
        "files": [
          "README.md",
          "index.js",
          "lib/decoder.js",
          "test/object-prototype-poisoning.js"
        ],
        "message": "fix: prevent object prototype poisoning (#97)",
        "before_after_code_files": [
          "index.js||index.js",
          "lib/decoder.js||lib/decoder.js",
          "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "index.js||index.js",
            "lib/decoder.js||lib/decoder.js",
            "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
          ],
          "candidate": [
            "index.js||index.js",
            "lib/decoder.js||lib/decoder.js",
            "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
          ]
        }
      },
      "candidate_diff": {
        "index.js||index.js": [
          "File: index.js -> index.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:   options = options || {",
          "15:     forceFloat64: false,",
          "17:   }",
          "19:   function registerEncoder (check, encode) {",
          "",
          "[Removed Lines]",
          "16:     compatibilityMode: false",
          "",
          "[Added Lines]",
          "16:     compatibilityMode: false,",
          "18:     protoAction: 'error'",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:   return {",
          "70:     encode: buildEncode(encodingTypes, options.forceFloat64, options.compatibilityMode),",
          "72:     register: register,",
          "73:     registerEncoder: registerEncoder,",
          "74:     registerDecoder: registerDecoder,",
          "",
          "[Removed Lines]",
          "71:     decode: buildDecode(decodingTypes),",
          "",
          "[Added Lines]",
          "73:     decode: buildDecode(decodingTypes, options),",
          "",
          "---------------"
        ],
        "lib/decoder.js||lib/decoder.js": [
          "File: lib/decoder.js -> lib/decoder.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: util.inherits(IncompleteBufferError, Error)",
          "16:   return decode",
          "18:   function getSize (first) {",
          "",
          "[Removed Lines]",
          "15: module.exports = function buildDecode (decodingTypes) {",
          "",
          "[Added Lines]",
          "15: module.exports = function buildDecode (decodingTypes, options) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "358:         var valueResult = tryDecode(buf, offset)",
          "359:         if (valueResult) {",
          "360:           key = keyResult.value",
          "361:           result[key] = valueResult.value",
          "362:           offset += valueResult.bytesConsumed",
          "363:           totalBytesConsumed += (keyResult.bytesConsumed + valueResult.bytesConsumed)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:           if (key === '__proto__') {",
          "363:             if (options.protoAction === 'error') {",
          "364:               throw new SyntaxError('Object contains forbidden prototype property')",
          "365:             }",
          "367:             if (options.protoAction === 'remove') {",
          "368:               continue",
          "369:             }",
          "370:           }",
          "",
          "---------------"
        ],
        "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js": [
          "File: test/object-prototype-poisoning.js -> test/object-prototype-poisoning.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: 'use strict'",
          "3: var test = require('tape').test",
          "4: var msgpack = require('../')",
          "6: test('decode throws when object has forbidden __proto__ property', function (t) {",
          "7:   const encoder = msgpack()",
          "9:   const payload = { hello: 'world' }",
          "10:   Object.defineProperty(payload, '__proto__', {",
          "11:     value: { polluted: true },",
          "12:     enumerable: true",
          "13:   })",
          "15:   const encoded = encoder.encode(payload)",
          "17:   t.throws(() => encoder.decode(encoded), /Object contains forbidden prototype property/)",
          "18:   t.end()",
          "19: })",
          "21: test('decode ignores forbidden __proto__ property if protoAction is \"ignore\"', function (t) {",
          "22:   const encoder = msgpack({ protoAction: 'ignore' })",
          "24:   const payload = { hello: 'world' }",
          "25:   Object.defineProperty(payload, '__proto__', {",
          "26:     value: { polluted: true },",
          "27:     enumerable: true",
          "28:   })",
          "30:   const decoded = encoder.decode(encoder.encode(payload))",
          "32:   t.equal(decoded.polluted, true)",
          "33:   t.end()",
          "34: })",
          "36: test('decode removes forbidden __proto__ property if protoAction is \"remove\"', function (t) {",
          "37:   const encoder = msgpack({ protoAction: 'remove' })",
          "39:   const payload = { hello: 'world' }",
          "40:   Object.defineProperty(payload, '__proto__', {",
          "41:     value: { polluted: true },",
          "42:     enumerable: true",
          "43:   })",
          "45:   const decoded = encoder.decode(encoder.encode(payload))",
          "47:   t.equal(decoded.polluted, undefined)",
          "48:   t.end()",
          "49: })",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f3ade7a0bbb315d467141409bc956fa8742ab3f",
      "candidate_info": {
        "commit_hash": "2f3ade7a0bbb315d467141409bc956fa8742ab3f",
        "repo": "mcollina/msgpack5",
        "commit_url": "https://github.com/mcollina/msgpack5/commit/2f3ade7a0bbb315d467141409bc956fa8742ab3f",
        "files": [
          "README.md",
          "index.js",
          "lib/decoder.js",
          "test/object-prototype-poisoning.js"
        ],
        "message": "fix: prevent object prototype poisoning (#99)",
        "before_after_code_files": [
          "index.js||index.js",
          "lib/decoder.js||lib/decoder.js",
          "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "index.js||index.js",
            "lib/decoder.js||lib/decoder.js",
            "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
          ],
          "candidate": [
            "index.js||index.js",
            "lib/decoder.js||lib/decoder.js",
            "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js"
          ]
        }
      },
      "candidate_diff": {
        "index.js||index.js": [
          "File: index.js -> index.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:   options = options || {",
          "15:     forceFloat64: false,",
          "16:     compatibilityMode: false,",
          "18:   }",
          "20:   function registerEncoder (check, encode) {",
          "",
          "[Removed Lines]",
          "17:     disableTimestampEncoding: false // if true, skips encoding Dates using the msgpack timestamp ext format (-1)",
          "",
          "[Added Lines]",
          "17:     disableTimestampEncoding: false, // if true, skips encoding Dates using the msgpack timestamp ext format (-1)",
          "19:     protoAction: 'error'",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:   return {",
          "71:     encode: buildEncode(encodingTypes, options.forceFloat64, options.compatibilityMode, options.disableTimestampEncoding),",
          "73:     register: register,",
          "74:     registerEncoder: registerEncoder,",
          "75:     registerDecoder: registerDecoder,",
          "",
          "[Removed Lines]",
          "72:     decode: buildDecode(decodingTypes),",
          "",
          "[Added Lines]",
          "74:     decode: buildDecode(decodingTypes, options),",
          "",
          "---------------"
        ],
        "lib/decoder.js||lib/decoder.js": [
          "File: lib/decoder.js -> lib/decoder.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: util.inherits(IncompleteBufferError, Error)",
          "18:   return decode",
          "20:   function getSize (first) {",
          "",
          "[Removed Lines]",
          "17: module.exports = function buildDecode (decodingTypes) {",
          "",
          "[Added Lines]",
          "17: module.exports = function buildDecode (decodingTypes, options) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "361:         var valueResult = tryDecode(buf, offset)",
          "362:         if (valueResult) {",
          "363:           key = keyResult.value",
          "364:           result[key] = valueResult.value",
          "365:           offset += valueResult.bytesConsumed",
          "366:           totalBytesConsumed += (keyResult.bytesConsumed + valueResult.bytesConsumed)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "365:           if (key === '__proto__') {",
          "366:             if (options.protoAction === 'error') {",
          "367:               throw new SyntaxError('Object contains forbidden prototype property')",
          "368:             }",
          "370:             if (options.protoAction === 'remove') {",
          "371:               continue",
          "372:             }",
          "373:           }",
          "",
          "---------------"
        ],
        "test/object-prototype-poisoning.js||test/object-prototype-poisoning.js": [
          "File: test/object-prototype-poisoning.js -> test/object-prototype-poisoning.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: 'use strict'",
          "3: var test = require('tape').test",
          "4: var msgpack = require('../')",
          "6: test('decode throws when object has forbidden __proto__ property', function (t) {",
          "7:   const encoder = msgpack()",
          "9:   const payload = { hello: 'world' }",
          "10:   Object.defineProperty(payload, '__proto__', {",
          "11:     value: { polluted: true },",
          "12:     enumerable: true",
          "13:   })",
          "15:   const encoded = encoder.encode(payload)",
          "17:   t.throws(() => encoder.decode(encoded), /Object contains forbidden prototype property/)",
          "18:   t.end()",
          "19: })",
          "21: test('decode ignores forbidden __proto__ property if protoAction is \"ignore\"', function (t) {",
          "22:   const encoder = msgpack({ protoAction: 'ignore' })",
          "24:   const payload = { hello: 'world' }",
          "25:   Object.defineProperty(payload, '__proto__', {",
          "26:     value: { polluted: true },",
          "27:     enumerable: true",
          "28:   })",
          "30:   const decoded = encoder.decode(encoder.encode(payload))",
          "32:   t.equal(decoded.polluted, true)",
          "33:   t.end()",
          "34: })",
          "36: test('decode removes forbidden __proto__ property if protoAction is \"remove\"', function (t) {",
          "37:   const encoder = msgpack({ protoAction: 'remove' })",
          "39:   const payload = { hello: 'world' }",
          "40:   Object.defineProperty(payload, '__proto__', {",
          "41:     value: { polluted: true },",
          "42:     enumerable: true",
          "43:   })",
          "45:   const decoded = encoder.decode(encoder.encode(payload))",
          "47:   t.equal(decoded.polluted, undefined)",
          "48:   t.end()",
          "49: })",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-4410",
  "cve_desc": "The Moped::BSON::ObjecId.legal? method in rubygem-moped before commit dd5a7c14b5d2e466f7875d079af71ad19774609b allows remote attackers to cause a denial of service (worker resource consumption) or perform a cross-site scripting (XSS) attack via a crafted string.",
  "repo": "mongoid/moped",
  "patch_hash": "dd5a7c14b5d2e466f7875d079af71ad19774609b",
  "patch_info": {
    "commit_hash": "dd5a7c14b5d2e466f7875d079af71ad19774609b",
    "repo": "mongoid/moped",
    "commit_url": "https://github.com/mongoid/moped/commit/dd5a7c14b5d2e466f7875d079af71ad19774609b",
    "files": [
      ".gitignore",
      "README.md",
      "lib/moped.rb",
      "lib/moped/bson/object_id.rb",
      "lib/moped/cluster.rb",
      "lib/moped/collection.rb",
      "lib/moped/connection.rb",
      "lib/moped/cursor.rb",
      "lib/moped/database.rb",
      "lib/moped/errors.rb",
      "lib/moped/node.rb",
      "lib/moped/protocol/command.rb",
      "lib/moped/query.rb",
      "lib/moped/server.rb",
      "lib/moped/session.rb",
      "lib/moped/session/context.rb",
      "lib/moped/socket.rb",
      "lib/moped/threaded.rb",
      "perf/cases.rb",
      "spec/integration/protocol/authentication_spec.rb",
      "spec/integration/protocol/protocol_spec.rb",
      "spec/integration_spec.rb",
      "spec/moped/bson/object_id_spec.rb",
      "spec/moped/cluster_spec.rb",
      "spec/moped/collection_spec.rb",
      "spec/moped/cursor_spec.rb",
      "spec/moped/database_spec.rb",
      "spec/moped/errors_spec.rb",
      "spec/moped/indexes_spec.rb",
      "spec/moped/logging_spec.rb",
      "spec/moped/node_spec.rb",
      "spec/moped/query_spec.rb",
      "spec/moped/server_spec.rb",
      "spec/moped/session_spec.rb",
      "spec/moped/socket_spec.rb",
      "spec/moped_spec.rb",
      "spec/replset_spec.rb",
      "spec/spec_helper.rb",
      "spec/support/mock_connection.rb",
      "spec/support/mongohq.rb",
      "spec/support/replica_set_simulator.rb",
      "spec/support/stats.rb"
    ],
    "message": "Merge Replica Set Refactor\n\n* Removes Server, and Socket; replaced with Node, and Connection.\n\n  Replica sets are now much more robustly supported, including failover\n  and discovery.\n\n* Refactors specs.\n\n  Internal APIs are now tested with integration specs through the public\n  APIs.\n\n* More documentation.",
    "before_after_code_files": [
      "lib/moped.rb||lib/moped.rb",
      "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb",
      "lib/moped/cluster.rb||lib/moped/cluster.rb",
      "lib/moped/collection.rb||lib/moped/collection.rb",
      "lib/moped/connection.rb||lib/moped/connection.rb",
      "lib/moped/cursor.rb||lib/moped/cursor.rb",
      "lib/moped/database.rb||lib/moped/database.rb",
      "lib/moped/errors.rb||lib/moped/errors.rb",
      "lib/moped/node.rb||lib/moped/node.rb",
      "lib/moped/protocol/command.rb||lib/moped/protocol/command.rb",
      "lib/moped/query.rb||lib/moped/query.rb",
      "lib/moped/server.rb||lib/moped/server.rb",
      "lib/moped/session.rb||lib/moped/session.rb",
      "lib/moped/session/context.rb||lib/moped/session/context.rb",
      "lib/moped/socket.rb||lib/moped/socket.rb",
      "lib/moped/threaded.rb||lib/moped/threaded.rb",
      "perf/cases.rb||perf/cases.rb",
      "spec/integration/protocol/authentication_spec.rb||spec/integration/protocol/authentication_spec.rb",
      "spec/integration/protocol/protocol_spec.rb||spec/integration/protocol/protocol_spec.rb",
      "spec/integration_spec.rb||spec/integration_spec.rb",
      "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb",
      "spec/moped/cluster_spec.rb||spec/moped/cluster_spec.rb",
      "spec/moped/collection_spec.rb||spec/moped/collection_spec.rb",
      "spec/moped/cursor_spec.rb||spec/moped/cursor_spec.rb",
      "spec/moped/database_spec.rb||spec/moped/database_spec.rb",
      "spec/moped/errors_spec.rb||spec/moped/errors_spec.rb",
      "spec/moped/indexes_spec.rb||spec/moped/indexes_spec.rb",
      "spec/moped/logging_spec.rb||spec/moped/logging_spec.rb",
      "spec/moped/node_spec.rb||spec/moped/node_spec.rb",
      "spec/moped/query_spec.rb||spec/moped/query_spec.rb",
      "spec/moped/server_spec.rb||spec/moped/server_spec.rb",
      "spec/moped/session_spec.rb||spec/moped/session_spec.rb",
      "spec/moped/socket_spec.rb||spec/moped/socket_spec.rb",
      "spec/moped_spec.rb||spec/moped_spec.rb",
      "spec/replset_spec.rb||spec/replset_spec.rb",
      "spec/spec_helper.rb||spec/spec_helper.rb",
      "spec/support/mock_connection.rb||spec/support/mock_connection.rb",
      "spec/support/mongohq.rb||spec/support/mongohq.rb",
      "spec/support/replica_set_simulator.rb||spec/support/replica_set_simulator.rb",
      "spec/support/stats.rb||spec/support/stats.rb"
    ]
  },
  "patch_diff": {
    "lib/moped.rb||lib/moped.rb": [
      "File: lib/moped.rb -> lib/moped.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "6: require \"moped/bson\"",
      "7: require \"moped/cluster\"",
      "8: require \"moped/collection\"",
      "9: require \"moped/cursor\"",
      "10: require \"moped/database\"",
      "11: require \"moped/errors\"",
      "12: require \"moped/indexes\"",
      "13: require \"moped/logging\"",
      "14: require \"moped/protocol\"",
      "15: require \"moped/query\"",
      "17: require \"moped/session\"",
      "19: require \"moped/version\"",
      "",
      "[Removed Lines]",
      "16: require \"moped/server\"",
      "18: require \"moped/socket\"",
      "",
      "[Added Lines]",
      "9: require \"moped/connection\"",
      "15: require \"moped/node\"",
      "19: require \"moped/session/context\"",
      "20: require \"moped/threaded\"",
      "",
      "---------------"
    ],
    "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb": [
      "File: lib/moped/bson/object_id.rb -> lib/moped/bson/object_id.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "8:       # Formatting string for outputting an ObjectId.",
      "9:       @@string_format = (\"%02x\" * 12).freeze",
      "13:       class << self",
      "14:         def from_string(string)",
      "15:           raise Errors::InvalidObjectId.new(string) unless legal?(string)",
      "17:           12.times { |i| data << string[i*2, 2].to_i(16) }",
      "19:         end",
      "21:         def legal?(str)",
      "23:         end",
      "33:         end",
      "34:       end",
      "36:       def ==(other)",
      "37:         BSON::ObjectId === other && data == other.data",
      "38:       end",
      "",
      "[Removed Lines]",
      "11:       attr_reader :data",
      "16:           data = []",
      "18:           new data",
      "22:           !!str.match(/^[0-9a-f]{24}$/i)",
      "24:       end",
      "26:       def initialize(data = nil, time = nil)",
      "27:         if data",
      "28:           @data = data",
      "29:         elsif time",
      "30:           @data = @@generator.generate(time.to_i)",
      "31:         else",
      "32:           @data = @@generator.next",
      "",
      "[Added Lines]",
      "14:           data = \"\"",
      "16:           from_data data",
      "17:         end",
      "19:         def from_time(time)",
      "20:           from_data @@generator.generate(time.to_i)",
      "24:           !!str.match(/\\A\\h{24}\\Z/i)",
      "27:         def from_data(data)",
      "28:           id = allocate",
      "29:           id.instance_variable_set :@data, data",
      "30:           id",
      "34:       def data",
      "35:         @data ||= @@generator.next",
      "36:       end",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "43:       end",
      "45:       def to_s",
      "47:       end",
      "49:       # Return the UTC time at which this ObjectId was generated. This may",
      "50:       # be used instread of a created_at timestamp since this information",
      "51:       # is always encoded in the object id.",
      "52:       def generation_time",
      "54:       end",
      "56:       class << self",
      "57:         def __bson_load__(io)",
      "59:         end",
      "61:       end",
      "63:       def __bson_dump__(io, key)",
      "64:         io << Types::OBJECT_ID",
      "65:         io << key",
      "66:         io << NULL_BYTE",
      "68:       end",
      "70:       # @api private",
      "",
      "[Removed Lines]",
      "46:         @@string_format % data",
      "53:         Time.at(@data.pack(\"C4\").unpack(\"N\")[0]).utc",
      "58:           new io.read(12).unpack('C*')",
      "67:         io << data.pack('C12')",
      "",
      "[Added Lines]",
      "48:         @@string_format % data.unpack(\"C12\")",
      "55:         Time.at(data.unpack(\"N\")[0]).utc",
      "60:           from_data(io.read(12))",
      "68:         io << data",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "72:         def initialize",
      "73:           # Generate and cache 3 bytes of identifying information from the current",
      "74:           # machine.",
      "77:           @mutex = Mutex.new",
      "79:           @counter = 0",
      "80:         end",
      "84:         def next",
      "95:           end",
      "98:         end",
      "118:         end",
      "119:       end",
      "",
      "[Removed Lines]",
      "75:           @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(\"C3\")",
      "78:           @last_timestamp = nil",
      "82:         # Return object id data based on the current time, incrementing a",
      "83:         # counter for object ids generated in the same second.",
      "85:           now = Time.new.to_i",
      "87:           counter = @mutex.synchronize do",
      "88:             last_timestamp, @last_timestamp = @last_timestamp, now",
      "90:             if last_timestamp == now",
      "91:               @counter += 1",
      "92:             else",
      "93:               @counter = 0",
      "94:             end",
      "97:           generate(now, counter)",
      "100:         # Generate object id data for a given time using the provided +inc+.",
      "101:         def generate(time, inc = 0)",
      "102:           pid = Process.pid % 0xFFFF",
      "104:           [",
      "105:             time >> 24 & 0xFF, # 4 bytes time (network order)",
      "106:             time >> 16 & 0xFF,",
      "107:             time >> 8  & 0xFF,",
      "108:             time       & 0xFF,",
      "109:             @machine_id[0],   # 3 bytes machine",
      "110:             @machine_id[1],",
      "111:             @machine_id[2],",
      "112:             pid  >> 8  & 0xFF, # 2 bytes process id",
      "113:             pid        & 0xFF,",
      "114:             inc  >> 16 & 0xFF, # 3 bytes increment",
      "115:             inc  >> 8  & 0xFF,",
      "116:             inc        & 0xFF,",
      "117:           ]",
      "",
      "[Added Lines]",
      "76:           @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(\"N\")[0]",
      "82:         # Return object id data based on the current time, incrementing the",
      "83:         # object id counter.",
      "85:           @mutex.lock",
      "86:           begin",
      "87:             counter = @counter = (@counter + 1) % 0xFFFFFF",
      "88:           ensure",
      "89:             @mutex.unlock rescue nil",
      "92:           generate(Time.new.to_i, counter)",
      "95:         # Generate object id data for a given time using the provided +counter+.",
      "96:         def generate(time, counter = 0)",
      "97:           [time, @machine_id, Process.pid, counter << 8].pack(\"N NX lXX NX\")",
      "",
      "---------------"
    ],
    "lib/moped/cluster.rb||lib/moped/cluster.rb": [
      "File: lib/moped/cluster.rb -> lib/moped/cluster.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: module Moped",
      "12:   class Cluster",
      "15:     attr_reader :seeds",
      "59:     end",
      "80:         end",
      "81:       end",
      "92:     end",
      "119:           end",
      "123:         end",
      "134:       else",
      "136:       end",
      "137:     end",
      "161:         end",
      "162:       end",
      "166:       end",
      "171:     end",
      "173:     # @return [Hash] the cached authentication credentials for this cluster.",
      "",
      "[Removed Lines]",
      "3:   # @api private",
      "4:   #",
      "5:   # The internal class managing connections to both a single node and replica",
      "6:   # sets.",
      "7:   #",
      "8:   # @note Though the socket class itself *is* threadsafe, the cluster presently",
      "9:   #   is not. This means that in the course of normal operations sessions can be",
      "10:   #   shared across threads, but in failure modes (when a resync is required),",
      "11:   #   things can possibly go wrong.",
      "14:     # @return [Array] the user supplied seeds",
      "17:     # @return [Boolean] whether this is a direct connection",
      "18:     attr_reader :direct",
      "20:     # @return [Array] all available nodes",
      "21:     attr_reader :servers",
      "23:     # @return [Array] seeds gathered from cluster discovery",
      "24:     attr_reader :dynamic_seeds",
      "26:     # @param [Array] seeds an array of host:port pairs",
      "27:     # @param [Boolean] direct (false) whether to connect directly to the hosts",
      "28:     # provided or to find additional available nodes.",
      "29:     def initialize(seeds, direct = false)",
      "30:       @seeds  = seeds",
      "31:       @direct = direct",
      "33:       @servers = []",
      "34:       @dynamic_seeds = []",
      "35:     end",
      "37:     # @return [Array] available secondary nodes",
      "38:     def secondaries",
      "39:       servers.select(&:secondary?)",
      "40:     end",
      "42:     # @return [Array] available primary nodes",
      "43:     def primaries",
      "44:       servers.select(&:primary?)",
      "45:     end",
      "47:     # @return [Array] all known addresses from user supplied seeds, dynamically",
      "48:     # discovered seeds, and active servers.",
      "49:     def known_addresses",
      "50:       [].tap do |addresses|",
      "51:         addresses.concat seeds",
      "52:         addresses.concat dynamic_seeds",
      "53:         addresses.concat servers.map { |server| server.address }",
      "54:       end.uniq",
      "55:     end",
      "57:     def remove(server)",
      "58:       servers.delete(server)",
      "61:     def reconnect",
      "62:       @servers = servers.map { |server| Server.new(server.address) }",
      "63:     end",
      "65:     def sync",
      "66:       known = known_addresses.shuffle",
      "67:       seen  = {}",
      "69:       sync_seed = ->(seed) do",
      "70:         server = Server.new seed",
      "72:         unless seen[server.resolved_address]",
      "73:           seen[server.resolved_address] = true",
      "75:           hosts = sync_server(server)",
      "77:           hosts.each do |host|",
      "78:             sync_seed[host]",
      "79:           end",
      "83:       known.each do |seed|",
      "84:         sync_seed[seed]",
      "85:       end",
      "87:       unless servers.empty?",
      "88:         @dynamic_seeds = servers.map(&:address)",
      "89:       end",
      "91:       true",
      "94:     def sync_server(server)",
      "95:       [].tap do |hosts|",
      "96:         socket = server.socket",
      "98:         if socket.connect",
      "99:           info = socket.simple_query Protocol::Command.new(:admin, ismaster: 1)",
      "101:           if info[\"ismaster\"]",
      "102:             server.primary = true",
      "103:           end",
      "105:           if info[\"secondary\"]",
      "106:             server.secondary = true",
      "107:           end",
      "109:           if info[\"primary\"]",
      "110:             hosts.push info[\"primary\"]",
      "111:           end",
      "113:           if info[\"hosts\"]",
      "114:             hosts.concat info[\"hosts\"]",
      "115:           end",
      "117:           if info[\"passives\"]",
      "118:             hosts.concat info[\"passives\"]",
      "121:           merge(server)",
      "124:       end.uniq",
      "125:     end",
      "127:     def merge(server)",
      "128:       previous = servers.find { |other| other == server }",
      "129:       primary = server.primary?",
      "130:       secondary = server.secondary?",
      "132:       if previous",
      "133:         previous.merge(server)",
      "135:         servers << server",
      "139:     # @param [:read, :write] mode the type of socket to return",
      "140:     # @return [Socket] a socket valid for +mode+ operations",
      "141:     def socket_for(mode)",
      "142:       sync unless primaries.any? || (secondaries.any? && mode == :read)",
      "144:       server = nil",
      "145:       while primaries.any? || (secondaries.any? && mode == :read)",
      "146:         if mode == :write || secondaries.empty?",
      "147:           server = primaries.sample",
      "148:         else",
      "149:           server = secondaries.sample",
      "150:         end",
      "152:         if server",
      "153:           socket = server.socket",
      "154:           socket.connect unless socket.connection",
      "156:           if socket.alive?",
      "157:             break server",
      "158:           else",
      "159:             remove server",
      "160:           end",
      "164:       unless server",
      "165:         raise Errors::ConnectionFailure.new(\"Could not connect to any primary or secondary servers\")",
      "168:       socket = server.socket",
      "169:       socket.apply_auth auth",
      "170:       socket",
      "",
      "[Added Lines]",
      "5:     # @return [Array<String>] the seeds the replica set was initialized with",
      "8:     # @option options :down_interval number of seconds to wait before attempting",
      "9:     # to reconnect to a down node. (30)",
      "10:     #",
      "11:     # @option options :refresh_interval number of seconds to cache information",
      "12:     # about a node. (300)",
      "13:     def initialize(hosts, options)",
      "14:       @options = {",
      "15:         down_interval: 30,",
      "16:         refresh_interval: 300",
      "17:       }.merge(options)",
      "19:       @seeds = hosts",
      "20:       @nodes = hosts.map { |host| Node.new(host) }",
      "23:     # Refreshes information for each of the nodes provided. The node list",
      "24:     # defaults to the list of all known nodes.",
      "25:     #",
      "26:     # If a node is successfully refreshed, any newly discovered peers will also",
      "27:     # be refreshed.",
      "28:     #",
      "29:     # @return [Array<Node>] the available nodes",
      "30:     def refresh(nodes_to_refresh = @nodes)",
      "31:       refreshed_nodes = []",
      "32:       seen = {}",
      "34:       # Set up a recursive lambda function for refreshing a node and it's peers.",
      "35:       refresh_node = ->(node) do",
      "36:         return if seen[node]",
      "37:         seen[node] = true",
      "39:         # Add the node to the global list of known nodes.",
      "40:         @nodes << node unless @nodes.include?(node)",
      "42:         begin",
      "43:           node.refresh",
      "45:           # This node is good, so add it to the list of nodes to return.",
      "46:           refreshed_nodes << node unless refreshed_nodes.include?(node)",
      "48:           # Now refresh any newly discovered peer nodes.",
      "49:           (node.peers - @nodes).each &refresh_node",
      "50:         rescue Errors::ConnectionFailure",
      "51:           # We couldn't connect to the node, so don't do anything with it.",
      "55:       nodes_to_refresh.each &refresh_node",
      "56:       refreshed_nodes.to_a",
      "59:     # Returns the list of available nodes, refreshing 1) any nodes which were",
      "60:     # down and ready to be checked again and 2) any nodes whose information is",
      "61:     # out of date.",
      "62:     #",
      "63:     # @return [Array<Node>] the list of available nodes.",
      "64:     def nodes",
      "65:       # Find the nodes that were down but are ready to be refreshed, or those",
      "66:       # with stale connection information.",
      "67:       needs_refresh, available = @nodes.partition do |node|",
      "68:         (node.down? && node.down_at < (Time.new - @options[:down_interval])) ||",
      "69:           node.needs_refresh?(Time.new - @options[:refresh_interval])",
      "70:       end",
      "72:       # Refresh those nodes.",
      "73:       available.concat refresh(needs_refresh)",
      "75:       # Now return all the nodes that are available.",
      "76:       available.reject &:down?",
      "77:     end",
      "79:     # Yields the replica set's primary node to the provided block. This method",
      "80:     # will retry the block in case of connection errors or replica set",
      "81:     # reconfiguration.",
      "82:     #",
      "83:     # @raises ConnectionFailure when no primary node can be found",
      "84:     def with_primary(retry_on_failure = true, &block)",
      "85:       if node = nodes.find(&:primary?)",
      "86:         begin",
      "87:           node.ensure_primary do",
      "88:             return yield node.apply_auth(auth)",
      "90:         rescue Errors::ConnectionFailure, Errors::ReplicaSetReconfigured",
      "91:           # Fall through to the code below if our connection was dropped or the",
      "92:           # node is no longer the primary.",
      "94:       end",
      "96:       if retry_on_failure",
      "97:         # We couldn't find a primary node, so refresh the list and try again.",
      "98:         refresh",
      "99:         with_primary(false, &block)",
      "101:         raise Errors::ConnectionFailure, \"Could not connect to a primary node for replica set #{inspect}\"",
      "105:     # Yields a secondary node if available, otherwise the primary node. This",
      "106:     # method will retry the block in case of connection errors.",
      "107:     #",
      "108:     # @raises ConnectionError when no secondary or primary node can be found",
      "109:     def with_secondary(retry_on_failure = true, &block)",
      "110:       available_nodes = nodes.shuffle!.partition(&:secondary?).flatten",
      "112:       while node = available_nodes.shift",
      "113:         begin",
      "114:           return yield node.apply_auth(auth)",
      "115:         rescue Errors::ConnectionFailure",
      "116:           # That node's no good, so let's try the next one.",
      "117:           next",
      "121:       if retry_on_failure",
      "122:         # We couldn't find a secondary or primary node, so refresh the list and",
      "123:         # try again.",
      "124:         refresh",
      "125:         with_secondary(false, &block)",
      "126:       else",
      "127:         raise Errors::ConnectionFailure, \"Could not connect to any secondary or primary nodes for replica set #{inspect}\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "175:       @auth ||= {}",
      "176:     end",
      "189:     end",
      "191:   end",
      "193: end",
      "",
      "[Removed Lines]",
      "178:     # Log in to +database+ with +username+ and +password+. Does not perform the",
      "179:     # actual log in, but saves the credentials for later authentication on a",
      "180:     # socket.",
      "181:     def login(database, username, password)",
      "182:       auth[database.to_s] = [username, password]",
      "183:     end",
      "185:     # Log out of +database+. Does not perform the actual log out, but will log",
      "186:     # out when the socket is used next.",
      "187:     def logout(database)",
      "188:       auth.delete(database.to_s)",
      "",
      "[Added Lines]",
      "136:     private",
      "138:     def initialize_copy(_)",
      "139:       @nodes = @nodes.map &:dup",
      "",
      "---------------"
    ],
    "lib/moped/collection.rb||lib/moped/collection.rb": [
      "File: lib/moped/collection.rb -> lib/moped/collection.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "56:     #   @param [Array<Hash>] documents the documents to insert",
      "57:     def insert(documents)",
      "58:       documents = [documents] unless documents.is_a? Array",
      "61:       database.session.with(consistency: :strong) do |session|",
      "63:       end",
      "65:     end",
      "66:   end",
      "67: end",
      "",
      "[Removed Lines]",
      "59:       insert = Protocol::Insert.new(database.name, name, documents)",
      "62:         session.execute insert",
      "",
      "[Added Lines]",
      "61:         session.context.insert(database.name, name, documents)",
      "",
      "---------------"
    ],
    "lib/moped/connection.rb||lib/moped/connection.rb": [
      "File: lib/moped/connection.rb -> lib/moped/connection.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: require \"timeout\"",
      "3: module Moped",
      "4:   class Connection",
      "6:     class TCPSocket < ::TCPSocket",
      "7:       def self.connect(host, port, timeout)",
      "8:         Timeout::timeout(timeout) do",
      "9:           new(host, port).tap do |sock|",
      "10:             sock.set_encoding 'binary'",
      "11:           end",
      "12:         end",
      "13:       end",
      "15:       def alive?",
      "16:         if Kernel::select([self], nil, nil, 0)",
      "17:           !eof? rescue false",
      "18:         else",
      "19:           true",
      "20:         end",
      "21:       end",
      "23:       def write(*args)",
      "24:         raise Errors::ConnectionFailure, \"Socket connection was closed by remote host\" unless alive?",
      "25:         super",
      "26:       end",
      "27:     end",
      "29:     def initialize",
      "30:       @sock = nil",
      "31:       @request_id = 0",
      "32:     end",
      "34:     def connect(host, port, timeout)",
      "35:       @sock = TCPSocket.connect host, port, timeout",
      "36:     end",
      "38:     def alive?",
      "39:       connected? ? @sock.alive? : false",
      "40:     end",
      "42:     def connected?",
      "43:       !!@sock",
      "44:     end",
      "46:     def disconnect",
      "47:       @sock.close",
      "48:     rescue",
      "49:     ensure",
      "50:       @sock = nil",
      "51:     end",
      "53:     def write(operations)",
      "54:       buf = \"\"",
      "56:       operations.each do |operation|",
      "57:         operation.request_id = (@request_id += 1)",
      "58:         operation.serialize(buf)",
      "59:       end",
      "61:       @sock.write buf",
      "62:     end",
      "64:     def receive_replies(operations)",
      "65:       operations.map do |operation|",
      "66:         read if operation.is_a?(Protocol::Query) || operation.is_a?(Protocol::GetMore)",
      "67:       end",
      "68:     end",
      "70:     def read",
      "71:       reply = Protocol::Reply.allocate",
      "73:       reply.length,",
      "74:         reply.request_id,",
      "75:         reply.response_to,",
      "76:         reply.op_code,",
      "77:         reply.flags,",
      "78:         reply.cursor_id,",
      "79:         reply.offset,",
      "80:         reply.count = @sock.read(36).unpack('l5<q<l2<')",
      "82:       if reply.count == 0",
      "83:         reply.documents = []",
      "84:       else",
      "85:         buffer = StringIO.new(@sock.read(reply.length - 36))",
      "87:         reply.documents = reply.count.times.map do",
      "88:           BSON::Document.deserialize(buffer)",
      "89:         end",
      "90:       end",
      "92:       reply",
      "93:     end",
      "94:   end",
      "95: end",
      "",
      "---------------"
    ],
    "lib/moped/cursor.rb||lib/moped/cursor.rb": [
      "File: lib/moped/cursor.rb -> lib/moped/cursor.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:     def initialize(session, query_operation)",
      "12:       @session = session",
      "23:     end",
      "25:     def each",
      "27:       documents.each { |doc| yield doc }",
      "29:       while more?",
      "33:         documents.each { |doc| yield doc }",
      "34:       end",
      "35:     end",
      "44:       reply.documents",
      "45:     end",
      "47:     def limited?",
      "49:     end",
      "51:     def more?",
      "53:     end",
      "55:     def kill",
      "57:     end",
      "58:   end",
      "",
      "[Removed Lines]",
      "13:       @query_op = query_operation.dup",
      "15:       @get_more_op = Protocol::GetMore.new(",
      "16:         @query_op.database,",
      "17:         @query_op.collection,",
      "18:         0,",
      "19:         @query_op.limit",
      "20:       )",
      "22:       @kill_cursor_op = Protocol::KillCursors.new([0])",
      "26:       documents = query @query_op",
      "30:         return kill if limited? && @get_more_op.limit <= 0",
      "32:         documents = query @get_more_op",
      "37:     def query(operation)",
      "38:       reply = session.query operation",
      "40:       @get_more_op.limit -= reply.count if limited?",
      "41:       @get_more_op.cursor_id = reply.cursor_id",
      "42:       @kill_cursor_op.cursor_ids = [reply.cursor_id]",
      "48:       @query_op.limit > 0",
      "52:       @get_more_op.cursor_id != 0",
      "56:       session.execute kill_cursor_op",
      "",
      "[Added Lines]",
      "14:       @database    = query_operation.database",
      "15:       @collection  = query_operation.collection",
      "16:       @selector    = query_operation.selector",
      "18:       @cursor_id = 0",
      "19:       @limit = query_operation.limit",
      "20:       @limited = @limit > 0",
      "22:       @options = {",
      "23:         request_id: query_operation.request_id,",
      "24:         flags: query_operation.flags,",
      "25:         limit: query_operation.limit,",
      "26:         skip: query_operation.skip,",
      "27:         fields: query_operation.fields",
      "28:       }",
      "32:       documents = load",
      "36:         return kill if limited? && @limit <= 0",
      "38:         documents = get_more",
      "43:     def load",
      "44:       consistency = session.consistency",
      "45:       @options[:flags] |= [:slave_ok] if consistency == :eventual",
      "47:       reply, @node = session.context.with_node do |node|",
      "48:         [node.query(@database, @collection, @selector, @options), node]",
      "49:       end",
      "51:       @limit -= reply.count if limited?",
      "52:       @cursor_id = reply.cursor_id",
      "58:       @limited",
      "62:       @cursor_id != 0",
      "63:     end",
      "65:     def get_more",
      "66:       reply = @node.get_more @database, @collection, @cursor_id, @limit",
      "68:       @limit -= reply.count if limited?",
      "69:       @cursor_id = reply.cursor_id",
      "71:       reply.documents",
      "75:       @node.kill_cursors [@cursor_id]",
      "",
      "---------------"
    ],
    "lib/moped/database.rb||lib/moped/database.rb": [
      "File: lib/moped/database.rb -> lib/moped/database.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "30:     # Drop the database.",
      "31:     def drop",
      "33:     end",
      "35:     # Log in with +username+ and +password+ on the current database.",
      "",
      "[Removed Lines]",
      "32:       command dropDatabase: 1",
      "",
      "[Added Lines]",
      "32:       session.with(consistency: :strong) do |session|",
      "33:         session.context.command name, dropDatabase: 1",
      "34:       end",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "37:     # @param [String] username the username",
      "38:     # @param [String] password the password",
      "39:     def login(username, password)",
      "41:     end",
      "43:     # Log out from the current database.",
      "44:     def logout",
      "46:     end",
      "48:     # Run +command+ on the database.",
      "",
      "[Removed Lines]",
      "40:       session.cluster.login(name, username, password)",
      "45:       session.cluster.logout(name)",
      "",
      "[Added Lines]",
      "42:       session.context.login(name, username, password)",
      "47:       session.context.logout(name)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "54:     # @param [Hash] command the command to run",
      "55:     # @return [Hash] the result of the command",
      "56:     def command(command)",
      "68:     end",
      "70:     # @param [Symbol, String] collection the collection name",
      "",
      "[Removed Lines]",
      "57:       operation = Protocol::Command.new(name, command)",
      "59:       result = session.with(consistency: :strong) do |session|",
      "60:         session.simple_query(operation)",
      "61:       end",
      "63:       raise Errors::OperationFailure.new(",
      "64:         operation, result",
      "65:       ) unless result[\"ok\"] == 1.0",
      "67:       result",
      "",
      "[Added Lines]",
      "59:       session.context.command name, command",
      "",
      "---------------"
    ],
    "lib/moped/errors.rb||lib/moped/errors.rb": [
      "File: lib/moped/errors.rb -> lib/moped/errors.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: module Moped",
      "4:   module Errors",
      "6:     # Mongo's exceptions are sparsely documented, but this is the most accurate",
      "",
      "[Removed Lines]",
      "3:   # The namespace for all errors generated by Moped.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "10:     # Generic error class for exceptions related to connection failures.",
      "11:     class ConnectionFailure < StandardError; end",
      "20:     # Generic error class for exceptions generated on the remote MongoDB",
      "21:     # server.",
      "28:       # @return the command that generated the error",
      "29:       attr_reader :command",
      "",
      "[Removed Lines]",
      "13:     # Raised when providing an invalid string from an object id.",
      "14:     class InvalidObjectId < StandardError",
      "15:       def initialize(string)",
      "16:         super(\"'#{string}' is not a valid object id.\")",
      "17:       end",
      "18:     end",
      "22:     class MongoError < StandardError; end",
      "24:     # Exception class for exceptions generated as a direct result of an",
      "25:     # operation, such as a failed insert or an invalid command.",
      "26:     class OperationFailure < MongoError",
      "",
      "[Added Lines]",
      "11:     # Tag applied to unhandled exceptions on a node.",
      "12:     module SocketError end",
      "16:     class MongoError < StandardError",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "60:       end",
      "61:     end",
      "67:   end",
      "68: end",
      "",
      "[Removed Lines]",
      "63:     # A special kind of OperationFailure, raised when Mongo sets the",
      "64:     # :query_failure flag on a query response.",
      "65:     class QueryFailure < OperationFailure; end",
      "",
      "[Added Lines]",
      "52:     # Exception class for exceptions generated as a direct result of an",
      "53:     # operation, such as a failed insert or an invalid command.",
      "54:     class OperationFailure < MongoError; end",
      "56:     # Exception raised on invalid queries.",
      "57:     class QueryFailure < MongoError; end",
      "59:     # Exception raised when authentication fails.",
      "60:     class AuthenticationFailure < MongoError; end",
      "62:     # Raised when providing an invalid string from an object id.",
      "63:     class InvalidObjectId < StandardError",
      "64:       def initialize(string)",
      "65:         super(\"'#{string}' is not a valid object id.\")",
      "66:       end",
      "67:     end",
      "69:     # @api private",
      "70:     #",
      "71:     # Internal exception raised by Node#ensure_primary and captured by",
      "72:     # Cluster#with_primary.",
      "73:     class ReplicaSetReconfigured < StandardError; end",
      "",
      "---------------"
    ],
    "lib/moped/node.rb||lib/moped/node.rb": [
      "File: lib/moped/node.rb -> lib/moped/node.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Moped",
      "2:   class Node",
      "4:     attr_reader :address",
      "5:     attr_reader :resolved_address",
      "6:     attr_reader :ip_address",
      "7:     attr_reader :port",
      "9:     attr_reader :peers",
      "10:     attr_reader :timeout",
      "12:     def initialize(address)",
      "13:       @address = address",
      "15:       host, port = address.split(\":\")",
      "16:       @ip_address = ::Socket.getaddrinfo(host, nil, ::Socket::AF_INET, ::Socket::SOCK_STREAM).first[3]",
      "17:       @port = port.to_i",
      "18:       @resolved_address = \"#{@ip_address}:#{@port}\"",
      "20:       @timeout = 5",
      "21:     end",
      "23:     def command(database, cmd, options = {})",
      "24:       operation = Protocol::Command.new(database, cmd, options)",
      "26:       process(operation) do |reply|",
      "27:         result = reply.documents[0]",
      "29:         raise Errors::OperationFailure.new(",
      "30:           operation, result",
      "31:         ) if result[\"ok\"] != 1 || result[\"err\"] || result[\"errmsg\"]",
      "33:         result",
      "34:       end",
      "35:     end",
      "37:     def kill_cursors(cursor_ids)",
      "38:       process Protocol::KillCursors.new(cursor_ids)",
      "39:     end",
      "41:     def get_more(database, collection, cursor_id, limit)",
      "42:       process Protocol::GetMore.new(database, collection, cursor_id, limit)",
      "43:     end",
      "45:     def remove(database, collection, selector, options = {})",
      "46:       process Protocol::Delete.new(database, collection, selector, options)",
      "47:     end",
      "49:     def update(database, collection, selector, change, options = {})",
      "50:       process Protocol::Update.new(database, collection, selector, change, options)",
      "51:     end",
      "53:     def insert(database, collection, documents)",
      "54:       process Protocol::Insert.new(database, collection, documents)",
      "55:     end",
      "57:     def query(database, collection, selector, options = {})",
      "58:       operation = Protocol::Query.new(database, collection, selector, options)",
      "60:       process operation do |reply|",
      "61:         if reply.flags.include? :query_failure",
      "62:           raise Errors::QueryFailure.new(operation, reply.documents.first)",
      "63:         end",
      "65:         reply",
      "66:       end",
      "67:     end",
      "69:     # @return [true/false] whether the node needs to be refreshed.",
      "70:     def needs_refresh?(time)",
      "71:       !@refreshed_at || @refreshed_at < time",
      "72:     end",
      "74:     def primary?",
      "75:       @primary",
      "76:     end",
      "78:     def secondary?",
      "79:       @secondary",
      "80:     end",
      "82:     # Refresh information about the node, such as it's status in the replica",
      "83:     # set and it's known peers.",
      "84:     #",
      "85:     # Returns nothing.",
      "86:     # Raises Errors::ConnectionFailure if the node cannot be reached",
      "87:     # Raises Errors::ReplicaSetReconfigured if the node is no longer a primary node and",
      "88:     #   refresh was called within an +#ensure_primary+ block.",
      "89:     def refresh",
      "90:       info = command \"admin\", ismaster: 1",
      "92:       @refreshed_at = Time.now",
      "93:       primary = true if info[\"ismaster\"]",
      "94:       secondary = true if info[\"secondary\"]",
      "96:       peers = []",
      "97:       peers.push info[\"primary\"] if info[\"primary\"]",
      "98:       peers.concat info[\"hosts\"] if info[\"hosts\"]",
      "99:       peers.concat info[\"passives\"] if info[\"passives\"]",
      "100:       peers.concat info[\"arbiters\"] if info[\"arbiters\"]",
      "102:       @peers = peers.map { |peer| Node.new(peer) }",
      "103:       @primary, @secondary = primary, secondary",
      "105:       if !primary && Threaded.executing?(:ensure_primary)",
      "106:         raise Errors::ReplicaSetReconfigured, \"#{inspect} is no longer the primary node.\"",
      "107:       end",
      "108:     end",
      "110:     attr_reader :down_at",
      "112:     def down?",
      "113:       @down_at",
      "114:     end",
      "116:     # Set a flag on the node for the duration of provided block so that an",
      "117:     # exception is raised if the node is no longer the primary node.",
      "118:     #",
      "119:     # Returns nothing.",
      "120:     def ensure_primary",
      "121:       Threaded.begin :ensure_primary",
      "122:       yield",
      "123:     ensure",
      "124:       Threaded.end :ensure_primary",
      "125:     end",
      "127:     # Yields the block if a connection can be established, retrying when a",
      "128:     # connection error is raised.",
      "129:     #",
      "130:     # @raises ConnectionFailure when a connection cannot be established.",
      "131:     def ensure_connected",
      "132:       # Don't run the reconnection login if we're already inside an",
      "133:       # +ensure_connected+ block.",
      "134:       return yield if Threaded.executing? :connection",
      "135:       Threaded.begin :connection",
      "137:       retry_on_failure = true",
      "139:       begin",
      "140:         connect unless connected?",
      "141:         yield",
      "142:       rescue Errors::ReplicaSetReconfigured",
      "143:         # Someone else wrapped this in an #ensure_primary block, so let the",
      "144:         # reconfiguration exception bubble up.",
      "145:         raise",
      "146:       rescue Errors::OperationFailure, Errors::AuthenticationFailure, Errors::QueryFailure",
      "147:         # These exceptions are \"expected\" in the normal course of events, and",
      "148:         # don't necessitate disconnecting.",
      "149:         raise",
      "150:       rescue Errors::ConnectionFailure",
      "151:         disconnect",
      "153:         if retry_on_failure",
      "154:           # Maybe there was a hiccup -- try reconnecting one more time",
      "155:           retry_on_failure = false",
      "156:           retry",
      "157:         else",
      "158:           # Nope, we failed to connect twice. Flag the node as down and re-raise",
      "159:           # the exception.",
      "160:           down!",
      "161:           raise",
      "162:         end",
      "163:       rescue",
      "164:         # Looks like we got an unexpected error, so we'll clean up the connection",
      "165:         # and re-raise the exception.",
      "166:         disconnect",
      "167:         raise $!.extend(Errors::SocketError)",
      "168:       end",
      "169:     ensure",
      "170:       Threaded.end :connection",
      "171:     end",
      "173:     def pipeline",
      "174:       Threaded.begin :pipeline",
      "176:       begin",
      "177:         yield",
      "178:       ensure",
      "179:         Threaded.end :pipeline",
      "180:       end",
      "182:       flush unless Threaded.executing? :pipeline",
      "183:     end",
      "185:     def apply_auth(credentials)",
      "186:       unless auth == credentials",
      "187:         logouts = auth.keys - credentials.keys",
      "189:         logouts.each do |database|",
      "190:           logout database",
      "191:         end",
      "193:         credentials.each do |database, (username, password)|",
      "194:           login(database, username, password) unless auth[database] == [username, password]",
      "195:         end",
      "196:       end",
      "198:       self",
      "199:     end",
      "201:     def ==(other)",
      "202:       resolved_address == other.resolved_address",
      "203:     end",
      "204:     alias eql? ==",
      "206:     def hash",
      "207:       [ip_address, port].hash",
      "208:     end",
      "210:     private",
      "212:     def auth",
      "213:       @auth ||= {}",
      "214:     end",
      "216:     def login(database, username, password)",
      "217:       getnonce = Protocol::Command.new(database, getnonce: 1)",
      "218:       connection.write [getnonce]",
      "219:       result = connection.read.documents.first",
      "220:       raise Errors::OperationFailure.new(getnonce, result) unless result[\"ok\"] == 1",
      "222:       authenticate = Protocol::Commands::Authenticate.new(database, username, password, result[\"nonce\"])",
      "223:       connection.write [authenticate]",
      "224:       result = connection.read.documents.first",
      "225:       raise Errors::AuthenticationFailure.new(authenticate, result) unless result[\"ok\"] == 1",
      "227:       auth[database] = [username, password]",
      "228:     end",
      "230:     def logout(database)",
      "231:       command = Protocol::Command.new(database, logout: 1)",
      "232:       connection.write [command]",
      "233:       result = connection.read.documents.first",
      "234:       raise Errors::OperationFailure.new(command, result) unless result[\"ok\"] == 1",
      "236:       auth.delete(database)",
      "237:     end",
      "239:     def initialize_copy(_)",
      "240:       @connection = nil",
      "241:     end",
      "243:     def connection",
      "244:       @connection ||= Connection.new",
      "245:     end",
      "247:     def disconnect",
      "248:       auth.clear",
      "249:       connection.disconnect",
      "250:     end",
      "252:     def connected?",
      "253:       connection.connected?",
      "254:     end",
      "256:     # Mark the node as down.",
      "257:     #",
      "258:     # Returns nothing.",
      "259:     def down!",
      "260:       @down_at = Time.new",
      "262:       disconnect",
      "263:     end",
      "265:     # Connect to the node.",
      "266:     #",
      "267:     # Returns nothing.",
      "268:     # Raises Moped::ConnectionError if the connection times out.",
      "269:     # Raises Moped::ConnectionError if the server is unavailable.",
      "270:     def connect",
      "271:       connection.connect ip_address, port, timeout",
      "272:       @down_at = nil",
      "274:       refresh",
      "275:     rescue Timeout::Error",
      "276:       raise Errors::ConnectionFailure, \"Timed out connection to Mongo on #{address}\"",
      "277:     rescue Errno::ECONNREFUSED",
      "278:       raise Errors::ConnectionFailure, \"Could not connect to Mongo on #{address}\"",
      "279:     end",
      "281:     def process(operation, &callback)",
      "282:       if Threaded.executing? :pipeline",
      "283:         queue.push [operation, callback]",
      "284:       else",
      "285:         flush([[operation, callback]])",
      "286:       end",
      "287:     end",
      "289:     def queue",
      "290:       Threaded.stack(:pipelined_operations)",
      "291:     end",
      "293:     def flush(ops = queue)",
      "294:       operations, callbacks = ops.transpose",
      "296:       logging(operations) do",
      "297:         ensure_connected do",
      "298:           connection.write operations",
      "299:           replies = connection.receive_replies(operations)",
      "301:           replies.zip(callbacks).map do |reply, callback|",
      "302:             callback ? callback[reply] : reply",
      "303:           end.last",
      "304:         end",
      "305:       end",
      "306:     ensure",
      "307:       ops.clear",
      "308:     end",
      "310:     def logging(operations)",
      "311:       instrument_start = (logger = Moped.logger) && logger.debug? && Time.new",
      "312:       yield",
      "313:     ensure",
      "314:       log_operations(logger, operations, Time.new - instrument_start) if instrument_start && !$!",
      "315:     end",
      "317:     def log_operations(logger, ops, duration)",
      "318:       prefix  = \"  MOPED: #{address} \"",
      "319:       indent  = \" \"*prefix.length",
      "320:       runtime = (\" (%.1fms)\" % duration)",
      "322:       if ops.length == 1",
      "323:         logger.debug prefix + ops.first.log_inspect + runtime",
      "324:       else",
      "325:         first, *middle, last = ops",
      "327:         logger.debug prefix + first.log_inspect",
      "328:         middle.each { |m| logger.debug indent + m.log_inspect }",
      "329:         logger.debug indent + last.log_inspect + runtime",
      "330:       end",
      "331:     end",
      "333:   end",
      "334: end",
      "",
      "---------------"
    ],
    "lib/moped/protocol/command.rb||lib/moped/protocol/command.rb": [
      "File: lib/moped/protocol/command.rb -> lib/moped/protocol/command.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "12:       # @param [String, Symbol] database the database to run this command on",
      "13:       # @param [Hash] command the command to run",
      "16:       end",
      "18:       def log_inspect",
      "",
      "[Removed Lines]",
      "14:       def initialize(database, command)",
      "15:         super database, :$cmd, command, limit: -1",
      "",
      "[Added Lines]",
      "14:       # @param [Hash] additional query options",
      "15:       def initialize(database, command, options = {})",
      "16:         super database, :$cmd, command, options.merge(limit: -1)",
      "",
      "---------------"
    ],
    "lib/moped/query.rb||lib/moped/query.rb": [
      "File: lib/moped/query.rb -> lib/moped/query.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "100:     # @return [Hash] the first document that matches the selector.",
      "101:     def first",
      "103:     end",
      "104:     alias one first",
      "",
      "[Removed Lines]",
      "102:       session.simple_query(operation)",
      "",
      "[Added Lines]",
      "102:       limit(-1).each.first",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "107:     #",
      "108:     # @yieldparam [Hash] document each matching document",
      "109:     def each",
      "111:       cursor.to_enum.tap do |enum|",
      "112:         enum.each do |document|",
      "113:           yield document",
      "",
      "[Removed Lines]",
      "110:       cursor = Cursor.new(session.with(retain_socket: true), operation)",
      "",
      "[Added Lines]",
      "110:       cursor = Cursor.new(session, operation)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "151:     # @param [Array] flags an array of operation flags. Valid values are:",
      "152:     #   +:multi+ and +:upsert+",
      "153:     def update(change, flags = nil)",
      "162:       session.with(consistency: :strong) do |session|",
      "164:       end",
      "165:     end",
      "",
      "[Removed Lines]",
      "154:       update = Protocol::Update.new(",
      "155:         operation.database,",
      "156:         operation.collection,",
      "157:         operation.selector,",
      "158:         change,",
      "159:         flags: flags",
      "160:       )",
      "163:         session.execute update",
      "",
      "[Added Lines]",
      "156:         session.context.update operation.database,",
      "157:           operation.collection,",
      "158:           operation.selector,",
      "159:           change,",
      "160:           flags: flags",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "193:     # @example",
      "194:     #   db[:people].find(name: \"John\").remove",
      "195:     def remove",
      "203:       session.with(consistency: :strong) do |session|",
      "205:       end",
      "206:     end",
      "",
      "[Removed Lines]",
      "196:       delete = Protocol::Delete.new(",
      "197:         operation.database,",
      "198:         operation.collection,",
      "199:         operation.selector,",
      "200:         flags: [:remove_first]",
      "201:       )",
      "204:         session.execute delete",
      "",
      "[Added Lines]",
      "194:         session.context.remove operation.database,",
      "195:           operation.collection,",
      "196:           operation.selector,",
      "197:           flags: [:remove_first]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "210:     # @example",
      "211:     #   db[:people].find(name: \"John\").remove_all",
      "212:     def remove_all",
      "219:       session.with(consistency: :strong) do |session|",
      "221:       end",
      "222:     end",
      "",
      "[Removed Lines]",
      "213:       delete = Protocol::Delete.new(",
      "214:         operation.database,",
      "215:         operation.collection,",
      "216:         operation.selector",
      "217:       )",
      "220:         session.execute delete",
      "",
      "[Added Lines]",
      "207:         session.context.remove operation.database,",
      "208:           operation.collection,",
      "209:           operation.selector",
      "",
      "---------------"
    ],
    "lib/moped/server.rb||lib/moped/server.rb": [
      "File: lib/moped/server.rb -> lib/moped/server.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "lib/moped/session.rb||lib/moped/session.rb": [
      "File: lib/moped/session.rb -> lib/moped/session.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "37:     # @return [Cluster] this session's cluster",
      "38:     attr_reader :cluster",
      "40:     # @param [Array] seeds an of host:port pairs",
      "41:     # @param [Hash] options",
      "42:     # @option options [Boolean] :safe (false) ensure writes are persisted",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "40:     # @private",
      "41:     # @return [Context] this session's context",
      "42:     attr_reader :context",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "45:     # @option options [Symbol, String] :database the database to use",
      "46:     # @option options [:strong, :eventual] :consistency (:eventual)",
      "47:     def initialize(seeds, options = {})",
      "49:       @options = options",
      "50:       @options[:consistency] ||= :eventual",
      "51:     end",
      "",
      "[Removed Lines]",
      "48:       @cluster = Cluster.new(seeds)",
      "",
      "[Added Lines]",
      "52:       @cluster = Cluster.new(seeds, {})",
      "53:       @context = Context.new(self)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "55:       !!safety",
      "56:     end",
      "58:     # Switch the session's current database.",
      "59:     #",
      "60:     # @example",
      "61:     #   session.use :moped",
      "63:     #",
      "64:     # @param [String] database the database to use",
      "65:     def use(database)",
      "",
      "[Removed Lines]",
      "62:     #   session[:people].     john, mary = session[:people].find.one # => { :name => \"John\" }",
      "",
      "[Added Lines]",
      "63:     # @return [:strong, :eventual] the session's consistency",
      "64:     def consistency",
      "65:       options[:consistency]",
      "66:     end",
      "72:     #   session[:people].find.one # => { :name => \"John\" }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "111:     # @return [Moped::Session] the new session",
      "112:     def new(options = {})",
      "113:       session = with(options)",
      "116:       if block_given?",
      "117:         yield session",
      "",
      "[Removed Lines]",
      "114:       session.cluster.reconnect",
      "",
      "[Added Lines]",
      "124:       session.instance_variable_set(:@cluster, cluster.dup)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "155:     # @raise (see Moped::Database#login)",
      "156:     delegate :logout => :current_database",
      "216:     # @return [Boolean, Hash] the safety level for this session",
      "217:     def safety",
      "218:       safe = options[:safe]",
      "",
      "[Removed Lines]",
      "158:     # @private",
      "159:     def current_database",
      "160:       return @current_database if defined? @current_database",
      "162:       if database = options[:database]",
      "163:         set_current_database(database)",
      "164:       else",
      "165:         raise \"No database set for session. Call #use or #with before accessing the database\"",
      "166:       end",
      "167:     end",
      "169:     # @private",
      "170:     def simple_query(query)",
      "171:       query.limit = -1",
      "173:       query(query).documents.first",
      "174:     end",
      "176:     # @private",
      "177:     def query(query)",
      "178:       if options[:consistency] == :eventual",
      "179:         query.flags |= [:slave_ok] if query.respond_to? :flags",
      "180:         mode = :read",
      "181:       else",
      "182:         mode = :write",
      "183:       end",
      "185:       reply = socket_for(mode).execute(query)",
      "187:       reply.tap do |reply|",
      "188:         if reply.flags.include?(:query_failure)",
      "189:           raise Errors::QueryFailure.new(query, reply.documents.first)",
      "190:         end",
      "191:       end",
      "192:     end",
      "194:     # @private",
      "195:     def execute(op)",
      "196:       mode = options[:consistency] == :eventual ? :read : :write",
      "197:       socket = socket_for(mode)",
      "199:       if safe?",
      "200:         last_error = Protocol::Command.new(",
      "201:           \"admin\", { getlasterror: 1 }.merge(safety)",
      "202:         )",
      "204:         socket.execute(op, last_error).documents.first.tap do |result|",
      "205:           raise Errors::OperationFailure.new(",
      "206:             op, result",
      "207:           ) if result[\"err\"] || result[\"errmsg\"]",
      "208:         end",
      "209:       else",
      "210:         socket.execute(op)",
      "211:       end",
      "212:     end",
      "214:     private",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "227:       end",
      "228:     end",
      "233:       else",
      "235:       end",
      "236:     end",
      "",
      "[Removed Lines]",
      "230:     def socket_for(mode)",
      "231:       if options[:retain_socket]",
      "232:         @socket ||= cluster.socket_for(mode)",
      "234:         cluster.socket_for(mode)",
      "",
      "[Added Lines]",
      "182:     private",
      "184:     def current_database",
      "185:       return @current_database if defined? @current_database",
      "187:       if database = options[:database]",
      "188:         set_current_database(database)",
      "190:         raise \"No database set for session. Call #use or #with before accessing the database\"",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "239:       @current_database = Database.new(self, database)",
      "240:     end",
      "246:       if defined? @current_database",
      "248:       end",
      "251:     end",
      "252:   end",
      "253: end",
      "",
      "[Removed Lines]",
      "242:     def dup",
      "243:       session = super",
      "244:       session.instance_variable_set :@options, options.dup",
      "247:         session.send(:remove_instance_variable, :@current_database)",
      "250:       session",
      "",
      "[Added Lines]",
      "198:     def initialize_copy(_)",
      "199:       @context = Context.new(self)",
      "200:       @options = @options.dup",
      "203:         remove_instance_variable :@current_database",
      "",
      "---------------"
    ],
    "lib/moped/session/context.rb||lib/moped/session/context.rb": [
      "File: lib/moped/session/context.rb -> lib/moped/session/context.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Moped",
      "2:   class Session",
      "4:     # @api private",
      "5:     class Context",
      "6:       extend Forwardable",
      "8:       def initialize(session)",
      "9:         @session = session",
      "10:       end",
      "12:       delegate :safety => :@session",
      "13:       delegate :safe?  => :@session",
      "14:       delegate :consistency  => :@session",
      "15:       delegate :cluster  => :@session",
      "17:       def login(database, username, password)",
      "18:         cluster.auth[database.to_s] = [username, password]",
      "19:       end",
      "21:       def logout(database)",
      "22:         cluster.auth.delete database.to_s",
      "23:       end",
      "25:       def query(database, collection, selector, options = {})",
      "26:         if consistency == :eventual",
      "27:           options[:flags] ||= []",
      "28:           options[:flags] |= [:slave_ok]",
      "29:         end",
      "31:         with_node do |node|",
      "32:           node.query(database, collection, selector, options)",
      "33:         end",
      "34:       end",
      "36:       def command(database, command)",
      "37:         options = consistency == :eventual ? { :flags => [:slave_ok] } : {}",
      "38:         with_node do |node|",
      "39:           node.command(database, command, options)",
      "40:         end",
      "41:       end",
      "43:       def insert(database, collection, documents)",
      "44:         with_node do |node|",
      "45:           if safe?",
      "46:             node.pipeline do",
      "47:               node.insert(database, collection, documents)",
      "48:               node.command(\"admin\", { getlasterror: 1 }.merge(safety))",
      "49:             end",
      "50:           else",
      "51:             node.insert(database, collection, documents)",
      "52:           end",
      "53:         end",
      "54:       end",
      "56:       def update(database, collection, selector, change, options = {})",
      "57:         with_node do |node|",
      "58:           if safe?",
      "59:             node.pipeline do",
      "60:               node.update(database, collection, selector, change, options)",
      "61:               node.command(\"admin\", { getlasterror: 1 }.merge(safety))",
      "62:             end",
      "63:           else",
      "64:             node.update(database, collection, selector, change, options)",
      "65:           end",
      "66:         end",
      "67:       end",
      "69:       def remove(database, collection, selector, options = {})",
      "70:         with_node do |node|",
      "71:           if safe?",
      "72:             node.pipeline do",
      "73:               node.remove(database, collection, selector, options)",
      "74:               node.command(\"admin\", { getlasterror: 1 }.merge(safety))",
      "75:             end",
      "76:           else",
      "77:             node.remove(database, collection, selector, options)",
      "78:           end",
      "79:         end",
      "80:       end",
      "82:       def get_more(*args)",
      "83:         raise NotImplementedError, \"#get_more cannot be called on Context; it must be called directly on a node\"",
      "84:       end",
      "86:       def kill_cursors(*args)",
      "87:         raise NotImplementedError, \"#kill_cursors cannot be called on Context; it must be called directly on a node\"",
      "88:       end",
      "90:       def with_node",
      "91:         if consistency == :eventual",
      "92:           cluster.with_secondary do |node|",
      "93:             yield node",
      "94:           end",
      "95:         else",
      "96:           cluster.with_primary do |node|",
      "97:             yield node",
      "98:           end",
      "99:         end",
      "100:       end",
      "102:     end",
      "104:   end",
      "105: end",
      "",
      "---------------"
    ],
    "lib/moped/socket.rb||lib/moped/socket.rb": [
      "File: lib/moped/socket.rb -> lib/moped/socket.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "lib/moped/threaded.rb||lib/moped/threaded.rb": [
      "File: lib/moped/threaded.rb -> lib/moped/threaded.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Moped",
      "3:   # This module contains logic for easy access to objects that have a lifecycle",
      "4:   # on the current thread.",
      "5:   #",
      "6:   # Extracted from Mongoid's +Threaded+ module.",
      "7:   #",
      "8:   # @api private",
      "9:   module Threaded",
      "10:     extend self",
      "12:     # Begin a thread-local stack for +name+.",
      "13:     def begin(name)",
      "14:       stack(name).push true",
      "15:     end",
      "17:     # @return [Boolean] whether the stack is being executed",
      "18:     def executing?(name)",
      "19:       !stack(name).empty?",
      "20:     end",
      "22:     # End the thread-local stack for +name+.",
      "23:     def end(name)",
      "24:       stack(name).pop",
      "25:     end",
      "27:     # @return [Array] a named, thread-local stack.",
      "28:     def stack(name)",
      "29:       Thread.current[\"[moped]:#{name}-stack\"] ||= []",
      "30:     end",
      "31:   end",
      "32: end",
      "",
      "---------------"
    ],
    "perf/cases.rb||perf/cases.rb": [
      "File: perf/cases.rb -> perf/cases.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "57: profile \"Insert and find one (1000x, 2 threads)\" do",
      "58:   2.times.map do",
      "59:     Thread.new do",
      "63:       end",
      "64:     end",
      "65:   end.each &:join",
      "",
      "[Removed Lines]",
      "60:       1000.times do",
      "61:         session[:people].insert(name: \"John\")",
      "62:         session[:people].find.one",
      "",
      "[Added Lines]",
      "60:       session.new do |session|",
      "61:         1000.times do",
      "62:           session[:people].insert(name: \"John\")",
      "63:           session[:people].find.one",
      "64:         end",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "68: profile \"Insert and find one (1000x, 5 threads)\" do",
      "69:   5.times.map do |i|",
      "70:     Thread.new do",
      "74:       end",
      "75:     end",
      "76:   end.each &:join",
      "",
      "[Removed Lines]",
      "71:       1000.times do",
      "72:         session[:people].insert(name: \"John\")",
      "73:         session[:people].find.one",
      "",
      "[Added Lines]",
      "73:       session.new do |session|",
      "74:         1000.times do",
      "75:           session[:people].insert(name: \"John\")",
      "76:           session[:people].find.one",
      "77:         end",
      "",
      "---------------"
    ],
    "spec/integration/protocol/authentication_spec.rb||spec/integration/protocol/authentication_spec.rb": [
      "File: spec/integration/protocol/authentication_spec.rb -> spec/integration/protocol/authentication_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/integration/protocol/protocol_spec.rb||spec/integration/protocol/protocol_spec.rb": [
      "File: spec/integration/protocol/protocol_spec.rb -> spec/integration/protocol/protocol_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/integration_spec.rb||spec/integration_spec.rb": [
      "File: spec/integration_spec.rb -> spec/integration_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb": [
      "File: spec/moped/bson/object_id_spec.rb -> spec/moped/bson/object_id_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: describe Moped::BSON::ObjectId do",
      "4:   let(:bytes) do",
      "6:   end",
      "8:   describe \".from_string\" do",
      "10:     context \"when the string is valid\" do",
      "14:         Moped::BSON::ObjectId.from_string \"4e4d66343b39b68407000001\"",
      "15:       end",
      "16:     end",
      "",
      "[Removed Lines]",
      "5:     [78, 77, 102, 52, 59, 57, 182, 132, 7, 0, 0, 1]",
      "12:       it \"initializes with the strings bytes\" do",
      "13:         Moped::BSON::ObjectId.should_receive(:new).with(bytes)",
      "",
      "[Added Lines]",
      "5:     [78, 77, 102, 52, 59, 57, 182, 132, 7, 0, 0, 1].pack(\"C12\")",
      "12:       it \"initializes with the string's bytes\" do",
      "13:         Moped::BSON::ObjectId.should_receive(:from_data).with(bytes)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "48:   end",
      "56:     end",
      "58:     context \"with no data\" do",
      "59:       it \"increments the id on each call\" do",
      "60:         Moped::BSON::ObjectId.new.should_not eq Moped::BSON::ObjectId.new",
      "",
      "[Removed Lines]",
      "50:   describe \"#initialize\" do",
      "52:     context \"with data\" do",
      "53:       it \"sets the object id's data\" do",
      "54:         Moped::BSON::ObjectId.new(bytes).data.should == bytes",
      "55:       end",
      "",
      "[Added Lines]",
      "50:   describe \"#from_time\" do",
      "51:     it \"sets the generation time\" do",
      "52:       time = Time.at((Time.now.utc - 64800).to_i).utc",
      "53:       Moped::BSON::ObjectId.from_time(time).generation_time.should == time",
      "55:   end",
      "57:   describe \"#initialize\" do",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "65:         ids[0].value.should_not eq ids[1].value",
      "66:       end",
      "67:     end",
      "76:   end",
      "78:   describe \"#==\" do",
      "80:     context \"when data is identical\" do",
      "81:       it \"returns true\" do",
      "83:       end",
      "84:     end",
      "",
      "[Removed Lines]",
      "69:     context \"with a time\" do",
      "70:       it \"sets the generation time\" do",
      "71:         time = Time.at((Time.now.utc - 64800).to_i).utc",
      "72:         Moped::BSON::ObjectId.new(nil, time).generation_time.should == time",
      "73:       end",
      "74:     end",
      "82:         Moped::BSON::ObjectId.new(bytes).should == Moped::BSON::ObjectId.new(bytes)",
      "",
      "[Added Lines]",
      "74:         Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "96:     context \"when data is identical\" do",
      "97:       it \"returns true\" do",
      "99:       end",
      "100:     end",
      "",
      "[Removed Lines]",
      "98:         Moped::BSON::ObjectId.new(bytes).should eql Moped::BSON::ObjectId.new(bytes)",
      "",
      "[Added Lines]",
      "90:         Moped::BSON::ObjectId.from_data(bytes).should eql Moped::BSON::ObjectId.from_data(bytes)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "112:     context \"when data is identical\" do",
      "113:       it \"returns the same hash\" do",
      "115:       end",
      "116:     end",
      "",
      "[Removed Lines]",
      "114:         Moped::BSON::ObjectId.new(bytes).hash.should eq Moped::BSON::ObjectId.new(bytes).hash",
      "",
      "[Added Lines]",
      "106:         Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "126:   describe \"#to_s\" do",
      "128:     it \"returns a hex string representation of the id\" do",
      "130:     end",
      "132:   end",
      "",
      "[Removed Lines]",
      "129:       Moped::BSON::ObjectId.new(bytes).to_s.should eq \"4e4d66343b39b68407000001\"",
      "",
      "[Added Lines]",
      "121:       Moped::BSON::ObjectId.from_data(bytes).to_s.should eq \"4e4d66343b39b68407000001\"",
      "",
      "---------------"
    ],
    "spec/moped/cluster_spec.rb||spec/moped/cluster_spec.rb": [
      "File: spec/moped/cluster_spec.rb -> spec/moped/cluster_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"spec_helper\"",
      "45:   end",
      "68:     end",
      "75:       end",
      "76:     end",
      "79:       before do",
      "90:       end",
      "109:         end",
      "110:       end",
      "126:         end",
      "127:       end",
      "152:         end",
      "156:         end",
      "157:       end",
      "176:         end",
      "180:         end",
      "181:       end",
      "183:     end",
      "184:   end",
      "189:     end",
      "194:       end",
      "195:     end",
      "200:       end",
      "201:     end",
      "207:         end",
      "208:       end",
      "213:         end",
      "214:       end",
      "216:       before do",
      "220:       end",
      "225:       end",
      "229:       end",
      "230:     end",
      "233:       before do",
      "235:       end",
      "241:           end",
      "243:         end",
      "248:         end",
      "255:       end",
      "260:         end",
      "265:         end",
      "269:         end",
      "274:         end",
      "275:       end",
      "276:     end",
      "289:         end",
      "295:         end",
      "296:       end",
      "313:         end",
      "328:         end",
      "329:       end",
      "330:     end",
      "331:   end",
      "341:     end",
      "342:   end",
      "347:     end",
      "349:     before do",
      "351:     end",
      "356:     end",
      "357:   end",
      "358: end",
      "",
      "[Removed Lines]",
      "3: describe Moped::Cluster do",
      "5:   let(:master) do",
      "6:     TCPServer.new \"127.0.0.1\", 0",
      "7:   end",
      "9:   let(:secondary_1) do",
      "10:     TCPServer.new \"127.0.0.1\", 0",
      "11:   end",
      "13:   let(:secondary_2) do",
      "14:     TCPServer.new \"127.0.0.1\", 0",
      "15:   end",
      "17:   describe \"initialize\" do",
      "18:     let(:cluster) do",
      "19:       Moped::Cluster.new([\"127.0.0.1:27017\",\"127.0.0.1:27018\"], true)",
      "20:     end",
      "22:     it \"stores the list of seeds\" do",
      "23:       cluster.seeds.should eq [\"127.0.0.1:27017\", \"127.0.0.1:27018\"]",
      "24:     end",
      "26:     it \"stores whether the connection is direct\" do",
      "27:       cluster.direct.should be_true",
      "28:     end",
      "30:     it \"has an empty list of primaries\" do",
      "31:       cluster.primaries.should be_empty",
      "32:     end",
      "34:     it \"has an empty list of secondaries\" do",
      "35:       cluster.secondaries.should be_empty",
      "36:     end",
      "38:     it \"has an empty list of servers\" do",
      "39:       cluster.servers.should be_empty",
      "40:     end",
      "42:     it \"has an empty list of dynamic seeds\" do",
      "43:       cluster.dynamic_seeds.should be_empty",
      "44:     end",
      "47:   describe \"#sync\" do",
      "48:     let(:cluster) { Moped::Cluster.new([\"127.0.0.1:27017\"]) }",
      "50:     it \"syncs each seed node\" do",
      "51:       server = Moped::Server.allocate",
      "52:       Moped::Server.should_receive(:new).with(\"127.0.0.1:27017\").and_return(server)",
      "54:       cluster.should_receive(:sync_server).with(server).and_return([])",
      "55:       cluster.sync",
      "56:     end",
      "57:   end",
      "59:   describe \"#sync_server\" do",
      "60:     let(:cluster) { Moped::Cluster.new [\"\"], false }",
      "61:     let(:server) { Moped::Server.new(\"localhost:27017\") }",
      "62:     let(:socket) { Moped::Socket.new \"\", 99999 }",
      "63:     let(:connection) { Support::MockConnection.new }",
      "65:     before do",
      "66:       socket.stub(connection: connection, alive?: true)",
      "67:       server.stub(socket: socket)",
      "70:     context \"when node is not running\" do",
      "71:       it \"returns nothing\" do",
      "72:         socket.stub(connect: false)",
      "74:         cluster.sync_server(server).should be_empty",
      "78:     context \"when talking to a single node\" do",
      "80:         connection.pending_replies << Hash[",
      "81:           \"ismaster\" => true,",
      "82:           \"maxBsonObjectSize\" => 16777216,",
      "83:           \"ok\" => 1.0",
      "84:         ]",
      "85:       end",
      "87:       it \"adds the node to the master set\" do",
      "88:         cluster.sync_server server",
      "89:         cluster.primaries.should include server",
      "91:     end",
      "93:     context \"when talking to a replica set node\" do",
      "95:       context \"that is not configured\" do",
      "96:         before do",
      "97:           connection.pending_replies << Hash[",
      "98:             \"ismaster\" => false,",
      "99:             \"secondary\" => false,",
      "100:             \"info\" => \"can't get local.system.replset config from self or any seed (EMPTYCONFIG)\",",
      "101:             \"isreplicaset\" => true,",
      "102:             \"maxBsonObjectSize\" => 16777216,",
      "103:             \"ok\" => 1.0",
      "104:           ]",
      "105:         end",
      "107:         it \"returns nothing\" do",
      "108:           cluster.sync_server(server).should be_empty",
      "112:       context \"that is being initiated\" do",
      "113:         before do",
      "114:           connection.pending_replies << Hash[",
      "115:             \"ismaster\" => false,",
      "116:             \"secondary\" => false,",
      "117:             \"info\" => \"Received replSetInitiate - should come online shortly.\",",
      "118:             \"isreplicaset\" => true,",
      "119:             \"maxBsonObjectSize\" => 16777216,",
      "120:             \"ok\" => 1.0",
      "121:           ]",
      "122:         end",
      "124:         it \"raises a connection failure exception\" do",
      "125:           cluster.sync_server(server).should be_empty",
      "129:       context \"that is ready but not elected\" do",
      "130:         before do",
      "131:           connection.pending_replies << Hash[",
      "132:             \"setName\" => \"3fef4842b608\",",
      "133:             \"ismaster\" => false,",
      "134:             \"secondary\" => false,",
      "135:             \"hosts\" => [\"localhost:61085\", \"localhost:61086\", \"localhost:61084\"],",
      "136:             \"primary\" => \"localhost:61084\",",
      "137:             \"me\" => \"localhost:61085\",",
      "138:             \"maxBsonObjectSize\" => 16777216,",
      "139:             \"ok\" => 1.0",
      "140:           ]",
      "141:         end",
      "143:         it \"raises no exception\" do",
      "144:           lambda do",
      "145:             cluster.sync_server server",
      "146:           end.should_not raise_exception",
      "147:         end",
      "149:         it \"adds the server to the list\" do",
      "150:           cluster.sync_server server",
      "151:           cluster.servers.should include server",
      "154:         it \"returns all other known hosts\" do",
      "155:           cluster.sync_server(server).should =~ [\"localhost:61085\", \"localhost:61086\", \"localhost:61084\"]",
      "159:       context \"that is ready\" do",
      "160:         before do",
      "161:           connection.pending_replies << Hash[",
      "162:             \"setName\" => \"3ff029114780\",",
      "163:             \"ismaster\" => true,",
      "164:             \"secondary\" => false,",
      "165:             \"hosts\" => [\"localhost:59246\", \"localhost:59248\", \"localhost:59247\"],",
      "166:             \"primary\" => \"localhost:59246\",",
      "167:             \"me\" => \"localhost:59246\",",
      "168:             \"maxBsonObjectSize\" => 16777216,",
      "169:             \"ok\" => 1.0",
      "170:           ]",
      "171:         end",
      "173:         it \"adds the node to the master set\" do",
      "174:           cluster.sync_server server",
      "175:           cluster.primaries.should include server",
      "178:         it \"returns all other known hosts\" do",
      "179:           cluster.sync_server(server).should =~ [\"localhost:59246\", \"localhost:59248\", \"localhost:59247\"]",
      "186:   describe \"#socket_for\" do",
      "187:     let(:cluster) do",
      "188:       Moped::Cluster.new \"\"",
      "191:     let(:server) do",
      "192:       Moped::Server.new(\"localhost:27017\").tap do |server|",
      "193:         server.stub(socket: socket)",
      "197:     let(:socket) do",
      "198:       Moped::Socket.new(\"127.0.0.1\", 27017).tap do |socket|",
      "199:         socket.connect",
      "203:     context \"when socket is dead\" do",
      "204:       let(:dead_server) do",
      "205:         Moped::Server.allocate.tap do |server|",
      "206:           server.stub(socket: dead_socket)",
      "210:       let(:dead_socket) do",
      "211:         Moped::Socket.new(\"127.0.0.1\", 27017).tap do |socket|",
      "212:           socket.stub(:alive? => false)",
      "217:         primaries = [server, dead_server]",
      "218:         primaries.stub(:sample).and_return(dead_server, server)",
      "219:         cluster.stub(primaries: primaries)",
      "222:       it \"removes the socket\" do",
      "223:         cluster.should_receive(:remove).with(dead_server)",
      "224:         cluster.socket_for :write",
      "227:       it \"returns the living socket\" do",
      "228:         cluster.socket_for(:write).should eq socket",
      "232:     context \"when mode is write\" do",
      "234:         server.primary = true",
      "237:       context \"and the cluster is not synced\" do",
      "238:         it \"syncs the cluster\" do",
      "239:           cluster.should_receive(:sync) do",
      "240:             cluster.servers << server",
      "242:           cluster.socket_for :write",
      "245:         it \"returns the socket\" do",
      "246:           cluster.stub(:sync) { cluster.servers << server }",
      "247:           cluster.socket_for(:write).should eq socket",
      "250:         it \"applies the cached authentication\" do",
      "251:           cluster.stub(:sync) { cluster.servers << server }",
      "252:           socket.should_receive(:apply_auth).with(cluster.auth)",
      "253:           cluster.socket_for(:write)",
      "254:         end",
      "257:       context \"and the cluster is synced\" do",
      "258:         before do",
      "259:           cluster.servers << server",
      "262:         it \"does not re-sync the cluster\" do",
      "263:           cluster.should_receive(:sync).never",
      "264:           cluster.socket_for :write",
      "267:         it \"returns the socket\" do",
      "268:           cluster.socket_for(:write).should eq socket",
      "271:         it \"applies the cached authentication\" do",
      "272:           socket.should_receive(:apply_auth).with(cluster.auth)",
      "273:           cluster.socket_for(:write)",
      "278:     context \"when mode is read\" do",
      "279:       context \"and the cluster is not synced\" do",
      "280:         before do",
      "281:           server.primary = true",
      "282:         end",
      "284:         it \"syncs the cluster\" do",
      "285:           cluster.should_receive(:sync) do",
      "286:             cluster.servers << server",
      "287:           end",
      "288:           cluster.socket_for :read",
      "291:         it \"applies the cached authentication\" do",
      "292:           cluster.stub(:sync) { cluster.servers << server }",
      "293:           socket.should_receive(:apply_auth).with(cluster.auth)",
      "294:           cluster.socket_for(:read)",
      "298:       context \"and the cluster is synced\" do",
      "299:         context \"and no secondaries are found\" do",
      "300:           before do",
      "301:             server.primary = true",
      "302:             cluster.servers << server",
      "303:           end",
      "305:           it \"returns the master connection\" do",
      "306:             cluster.socket_for(:read).should eq socket",
      "307:           end",
      "309:           it \"applies the cached authentication\" do",
      "310:             socket.should_receive(:apply_auth).with(cluster.auth)",
      "311:             cluster.socket_for(:read)",
      "312:           end",
      "315:         context \"and a slave is found\" do",
      "316:           it \"returns a random slave connection\" do",
      "317:             secondaries = [server]",
      "318:             cluster.stub(secondaries: secondaries)",
      "319:             secondaries.should_receive(:sample).and_return(server)",
      "320:             cluster.socket_for(:read).should eq socket",
      "321:           end",
      "323:           it \"applies the cached authentication\" do",
      "324:             cluster.stub(secondaries: [server])",
      "325:             socket.should_receive(:apply_auth).with(cluster.auth)",
      "326:             cluster.socket_for(:read)",
      "327:           end",
      "333:   describe \"#login\" do",
      "334:     let(:cluster) do",
      "335:       Moped::Cluster.allocate",
      "336:     end",
      "338:     it \"adds the credentials to the auth cache\" do",
      "339:       cluster.login(\"admin\", \"username\", \"password\")",
      "340:       cluster.auth.should eq(\"admin\" => [\"username\", \"password\"])",
      "344:   describe \"#logout\" do",
      "345:     let(:cluster) do",
      "346:       Moped::Cluster.allocate",
      "350:       cluster.login(\"admin\", \"username\", \"password\")",
      "353:     it \"removes the stored credentials\" do",
      "354:       cluster.logout :admin",
      "355:       cluster.auth.should be_empty",
      "",
      "[Added Lines]",
      "3: describe Moped::Cluster, replica_set: true do",
      "4:   let(:replica_set) do",
      "5:     Moped::Cluster.new(seeds, {})",
      "8:   context \"when the replica set hasn't connected yet\" do",
      "9:     describe \"#with_primary\" do",
      "10:       it \"connects and yields the primary node\" do",
      "11:         replica_set.with_primary do |node|",
      "12:           node.address.should eq @primary.address",
      "13:         end",
      "14:       end",
      "17:     describe \"#with_secondary\" do",
      "18:       it \"connects and yields a secondary node\" do",
      "19:         replica_set.with_secondary do |node|",
      "20:           @secondaries.map(&:address).should include node.address",
      "21:         end",
      "25:     context \"and the primary is down\" do",
      "27:         @primary.stop",
      "30:       describe \"#with_primary\" do",
      "31:         it \"raises a connection error\" do",
      "32:           lambda do",
      "33:             replica_set.with_primary do |node|",
      "34:               node.command \"admin\", ping: 1",
      "35:             end",
      "36:           end.should raise_exception(Moped::Errors::ConnectionFailure)",
      "40:       describe \"#with_secondary\" do",
      "41:         it \"connects and yields a secondary node\" do",
      "42:           replica_set.with_secondary do |node|",
      "43:             @secondaries.map(&:address).should include node.address",
      "44:           end",
      "47:     end",
      "49:     context \"and a single secondary is down\" do",
      "50:       before do",
      "51:         @secondaries.first.stop",
      "52:       end",
      "54:       describe \"#with_primary\" do",
      "55:         it \"connects and yields the primary node\" do",
      "56:           replica_set.with_primary do |node|",
      "57:             node.address.should eq @primary.address",
      "58:           end",
      "60:       end",
      "62:       describe \"#with_secondary\" do",
      "63:         it \"connects and yields a secondary node\" do",
      "64:           replica_set.with_secondary do |node|",
      "65:             node.address.should eq @secondaries.last.address",
      "66:           end",
      "69:     end",
      "71:     context \"and all secondaries are down\" do",
      "72:       before do",
      "73:         @secondaries.each &:stop",
      "74:       end",
      "76:       describe \"#with_primary\" do",
      "77:         it \"connects and yields the primary node\" do",
      "78:           replica_set.with_primary do |node|",
      "79:             node.address.should eq @primary.address",
      "80:           end",
      "82:       end",
      "84:       describe \"#with_secondary\" do",
      "85:         it \"connects and yields the primary node\" do",
      "86:           replica_set.with_secondary do |node|",
      "87:             node.address.should eq @primary.address",
      "88:           end",
      "94:   context \"when the replica set is connected\" do",
      "95:     before do",
      "96:       replica_set.refresh",
      "99:     describe \"#with_primary\" do",
      "100:       it \"connects and yields the primary node\" do",
      "101:         replica_set.with_primary do |node|",
      "102:           node.address.should eq @primary.address",
      "103:         end",
      "107:     describe \"#with_secondary\" do",
      "108:       it \"connects and yields a secondary node\" do",
      "109:         replica_set.with_secondary do |node|",
      "110:           @secondaries.map(&:address).should include node.address",
      "111:         end",
      "115:     context \"and the primary is down\" do",
      "116:       before do",
      "117:         @primary.stop",
      "118:       end",
      "120:       describe \"#with_primary\" do",
      "121:         it \"raises a connection error\" do",
      "122:           lambda do",
      "123:             replica_set.with_primary do |node|",
      "124:               node.command \"admin\", ping: 1",
      "125:             end",
      "126:           end.should raise_exception(Moped::Errors::ConnectionFailure)",
      "130:       describe \"#with_secondary\" do",
      "131:         it \"connects and yields a secondary node\" do",
      "132:           replica_set.with_secondary do |node|",
      "133:             @secondaries.map(&:address).should include node.address",
      "134:           end",
      "137:     end",
      "139:     context \"and a single secondary is down\" do",
      "141:         @secondaries.first.stop",
      "144:       describe \"#with_primary\" do",
      "145:         it \"connects and yields the primary node\" do",
      "146:           replica_set.with_primary do |node|",
      "147:             node.address.should eq @primary.address",
      "148:           end",
      "149:         end",
      "152:       describe \"#with_secondary\" do",
      "153:         it \"connects and yields a secondary node\" do",
      "154:           replica_set.with_secondary do |node|",
      "155:             node.command \"admin\", ping: 1",
      "156:             node.address.should eq @secondaries.last.address",
      "157:           end",
      "158:         end",
      "162:     context \"and all secondaries are down\" do",
      "164:         @secondaries.each &:stop",
      "167:       describe \"#with_primary\" do",
      "168:         it \"connects and yields the primary node\" do",
      "169:           replica_set.with_primary do |node|",
      "170:             node.address.should eq @primary.address",
      "173:       end",
      "175:       describe \"#with_secondary\" do",
      "176:         it \"connects and yields the primary node\" do",
      "177:           replica_set.with_secondary do |node|",
      "178:             node.command \"admin\", ping: 1",
      "179:             node.address.should eq @primary.address",
      "180:           end",
      "182:       end",
      "183:     end",
      "184:   end",
      "186:   context \"with down interval\" do",
      "187:     let(:replica_set) do",
      "188:       Moped::Cluster.new(seeds, { down_interval: 5 })",
      "189:     end",
      "191:     context \"and all secondaries are down\" do",
      "192:       before do",
      "193:         replica_set.refresh",
      "194:         @secondaries.each &:stop",
      "195:         replica_set.refresh",
      "198:       describe \"#with_secondary\" do",
      "199:         it \"connects and yields the primary node\" do",
      "200:           replica_set.with_secondary do |node|",
      "201:             node.command \"admin\", ping: 1",
      "202:             node.address.should eq @primary.address",
      "203:           end",
      "205:       end",
      "207:       context \"when a secondary node comes back up\" do",
      "208:         before do",
      "209:           @secondaries.each &:restart",
      "212:         describe \"#with_secondary\" do",
      "213:           it \"connects and yields the primary node\" do",
      "214:             replica_set.with_secondary do |node|",
      "215:               node.command \"admin\", ping: 1",
      "216:               node.address.should eq @primary.address",
      "217:             end",
      "218:           end",
      "221:         context \"and the node is ready to be retried\" do",
      "222:           it \"connects and yields the secondary node\" do",
      "223:             Time.stub(:new).and_return(Time.now + 10)",
      "224:             replica_set.with_secondary do |node|",
      "225:               node.command \"admin\", ping: 1",
      "226:               @secondaries.map(&:address).should include node.address",
      "227:             end",
      "228:           end",
      "232:   end",
      "234:   context \"with only primary provided as a seed\" do",
      "235:     let(:replica_set) do",
      "236:       Moped::Cluster.new([@primary.address], {})",
      "237:     end",
      "239:     describe \"#with_primary\" do",
      "240:       it \"connects and yields the primary node\" do",
      "241:         replica_set.with_primary do |node|",
      "242:           node.address.should eq @primary.address",
      "244:       end",
      "245:     end",
      "247:     describe \"#with_secondary\" do",
      "248:       it \"connects and yields a secondary node\" do",
      "249:         replica_set.with_secondary do |node|",
      "250:           @secondaries.map(&:address).should include node.address",
      "253:     end",
      "254:   end",
      "256:   context \"with only primary provided as a seed\" do",
      "257:     let(:replica_set) do",
      "258:       Moped::Cluster.new([@secondaries[0].address], {})",
      "259:     end",
      "261:     describe \"#with_primary\" do",
      "262:       it \"connects and yields the primary node\" do",
      "263:         replica_set.with_primary do |node|",
      "264:           node.address.should eq @primary.address",
      "266:       end",
      "267:     end",
      "269:     describe \"#with_secondary\" do",
      "270:       it \"connects and yields a secondary node\" do",
      "271:         replica_set.with_secondary do |node|",
      "272:           @secondaries.map(&:address).should include node.address",
      "277: end",
      "279: describe Moped::Cluster, \"authentication\", mongohq: :auth do",
      "280:   let(:session) do",
      "281:     Support::MongoHQ.auth_session(false)",
      "282:   end",
      "284:   describe \"logging in with valid credentials\" do",
      "285:     it \"logs in and processes commands\" do",
      "286:       session.login *Support::MongoHQ.auth_credentials",
      "287:       session.command(ping: 1).should eq(\"ok\" => 1)",
      "291:   describe \"logging in with invalid credentials\" do",
      "292:     it \"raises an AuthenticationFailure exception\" do",
      "293:       session.login \"invalid-user\", \"invalid-password\"",
      "295:       lambda do",
      "296:         session.command(ping: 1)",
      "297:       end.should raise_exception(Moped::Errors::AuthenticationFailure)",
      "299:   end",
      "301:   describe \"logging in with valid credentials and then logging out\" do",
      "303:       session.login *Support::MongoHQ.auth_credentials",
      "304:       session.command(ping: 1).should eq(\"ok\" => 1)",
      "307:     it \"logs out\" do",
      "308:       lambda do",
      "309:         session.command dbStats: 1",
      "310:       end.should_not raise_exception",
      "312:       session.logout",
      "314:       lambda do",
      "315:         session.command dbStats: 1",
      "316:       end.should raise_exception(Moped::Errors::OperationFailure)",
      "",
      "---------------"
    ],
    "spec/moped/collection_spec.rb||spec/moped/collection_spec.rb": [
      "File: spec/moped/collection_spec.rb -> spec/moped/collection_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"spec_helper\"",
      "3: describe Moped::Collection do",
      "5:   let(:session) do",
      "15:   end",
      "34:   describe \"#drop\" do",
      "56:     end",
      "62:     end",
      "63:   end",
      "65:   describe \"#insert\" do",
      "80:     end",
      "90:     end",
      "91:   end",
      "92: end",
      "",
      "[Removed Lines]",
      "6:     mock(Moped::Session)",
      "7:   end",
      "9:   let(:database) do",
      "10:     mock(Moped::Database, session: session, name: \"moped\")",
      "11:   end",
      "13:   let(:collection) do",
      "14:     described_class.new database, :users",
      "17:   describe \"#initialize\" do",
      "19:     it \"stores the database\" do",
      "20:       collection.database.should eq database",
      "21:     end",
      "23:     it \"stores the collection name\" do",
      "24:       collection.name.should eq :users",
      "25:     end",
      "26:   end",
      "28:   describe \"#indexes\" do",
      "29:     it \"returns a new indexes instance\" do",
      "30:       collection.indexes.should be_an_instance_of Moped::Indexes",
      "31:     end",
      "32:   end",
      "36:     it \"drops the collection\" do",
      "37:       database.should_receive(:command).with(drop: :users)",
      "38:       collection.drop",
      "39:     end",
      "40:   end",
      "42:   describe \"#find\" do",
      "44:     let(:selector) do",
      "45:       Hash[ a: 1 ]",
      "46:     end",
      "48:     let(:query) do",
      "49:       mock(Moped::Query)",
      "50:     end",
      "52:     it \"returns a new Query\" do",
      "53:       Moped::Query.should_receive(:new).",
      "54:         with(collection, selector).and_return(query)",
      "55:       collection.find(selector).should eq query",
      "58:     it \"defaults to an empty selector\" do",
      "59:       Moped::Query.should_receive(:new).",
      "60:         with(collection, {}).and_return(query)",
      "61:       collection.find.should eq query",
      "67:     before do",
      "68:       session.should_receive(:with, :consistency => :strong).and_yield(session)",
      "69:       session.stub safe?: false",
      "70:     end",
      "72:     context \"when passed a single document\" do",
      "74:       it \"inserts the document\" do",
      "75:         session.should_receive(:execute).with do |insert|",
      "76:           insert.documents.should eq [{a: 1}]",
      "77:         end",
      "78:         collection.insert(a: 1)",
      "79:       end",
      "82:     context \"when passed multiple documents\" do",
      "84:       it \"inserts the documents\" do",
      "85:         session.should_receive(:execute).with do |insert|",
      "86:           insert.documents.should eq [{a: 1}, {b: 2}]",
      "87:         end",
      "88:         collection.insert([{a: 1}, {b: 2}])",
      "89:       end",
      "",
      "[Added Lines]",
      "5:     Moped::Session.new %w[127.0.0.1:27017], database: \"moped_test\"",
      "8:   let(:scope) { object_id }",
      "11:     before do",
      "12:       session.drop",
      "13:       session.command create: \"users\"",
      "16:     it \"drops the collection\" do",
      "17:       result = session[:users].drop",
      "18:       result[\"ns\"].should eq \"moped_test.users\"",
      "23:     it \"inserts a single document\" do",
      "24:       document = { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope }",
      "25:       session[:users].insert(document)",
      "26:       session[:users].find(document).one.should eq document",
      "29:     it \"insert multiple documents\" do",
      "30:       documents = [",
      "31:         { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope },",
      "32:         { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope }",
      "33:       ]",
      "35:       session[:users].insert(documents)",
      "36:       session[:users].find(scope: scope).entries.should eq documents",
      "",
      "---------------"
    ],
    "spec/moped/cursor_spec.rb||spec/moped/cursor_spec.rb": [
      "File: spec/moped/cursor_spec.rb -> spec/moped/cursor_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/database_spec.rb||spec/moped/database_spec.rb": [
      "File: spec/moped/database_spec.rb -> spec/moped/database_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/errors_spec.rb||spec/moped/errors_spec.rb": [
      "File: spec/moped/errors_spec.rb -> spec/moped/errors_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/indexes_spec.rb||spec/moped/indexes_spec.rb": [
      "File: spec/moped/indexes_spec.rb -> spec/moped/indexes_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"spec_helper\"",
      "3: describe Moped::Indexes do",
      "11:   end",
      "22:   end",
      "32:   end",
      "34:   describe \"#create\" do",
      "64:       end",
      "65:     end",
      "71:       end",
      "72:     end",
      "88:   end",
      "90:   describe \"#drop\" do",
      "104:       end",
      "105:     end",
      "113:         indexes[name: 1].should be_nil",
      "124:       end",
      "125:     end",
      "126:   end",
      "",
      "[Removed Lines]",
      "4:   let(:session) { Moped::Session.new [\"127.0.0.1:27017\"], database: \"moped_test\" }",
      "5:   let(:indexes) do",
      "6:     described_class.new(session.current_database, :users)",
      "7:   end",
      "9:   after do",
      "10:     session.command(deleteIndexes: \"users\", index: \"*\")",
      "13:   describe \"#each\" do",
      "14:     before do",
      "15:       session[:\"system.indexes\"].insert(ns: \"moped_test.users\", key: { name: 1 }, name: \"name_1\")",
      "16:     end",
      "18:     it \"yields all indexes on the collection\" do",
      "19:       indexes.to_a.should eq \\",
      "20:         session[:\"system.indexes\"].find(ns: \"moped_test.users\").to_a",
      "21:     end",
      "24:   describe \"#[]\" do",
      "25:     before do",
      "26:       session[:\"system.indexes\"].insert(ns: \"moped_test.users\", key: { name: 1 }, name: \"name_1\")",
      "27:     end",
      "29:     it \"returns the index with the provided key\" do",
      "30:       indexes[name: 1][\"name\"].should eq \"name_1\"",
      "31:     end",
      "35:     let(:key) do",
      "36:       Hash[\"location.latlong\" => \"2d\", \"name\" => 1, \"age\" => -1]",
      "37:     end",
      "39:     context \"with no options\" do",
      "40:       it \"creates an index with a generated name\" do",
      "41:         indexes.create(key)",
      "42:         indexes[key][\"name\"].should eq \"location.latlong_2d_name_1_age_-1\"",
      "43:       end",
      "44:     end",
      "46:     context \"with a name provided\" do",
      "47:       it \"creates an index with the provided name\" do",
      "48:         indexes.create(key, name: \"custom_index_name\")",
      "49:         indexes[key][\"name\"].should eq \"custom_index_name\"",
      "50:       end",
      "51:     end",
      "53:     context \"with background: true\" do",
      "54:       it \"creates an index\" do",
      "55:         indexes.create(key, background: true)",
      "56:         indexes[key][\"background\"].should eq true",
      "57:       end",
      "58:     end",
      "60:     context \"with dropDups: true\" do",
      "61:       it \"creates an index\" do",
      "62:         indexes.create(key, dropDups: true)",
      "63:         indexes[key][\"dropDups\"].should eq true",
      "67:     context \"with unique: true\" do",
      "68:       it \"creates an index\" do",
      "69:         indexes.create(key, unique: true)",
      "70:         indexes[key][\"unique\"].should eq true",
      "74:     context \"with sparse: true\" do",
      "75:       it \"creates an index\" do",
      "76:         indexes.create(key, sparse: true)",
      "77:         indexes[key][\"sparse\"].should eq true",
      "78:       end",
      "79:     end",
      "81:     context \"with v: 0\" do",
      "82:       it \"creates an index\" do",
      "83:         indexes.create(key, v: 0)",
      "84:         indexes[key][\"v\"].should eq 0",
      "85:       end",
      "86:     end",
      "91:     before do",
      "92:       indexes.create name: 1",
      "93:       indexes.create age: -1",
      "94:     end",
      "96:     context \"with no key\" do",
      "97:       before do",
      "98:         indexes.drop",
      "99:       end",
      "101:       it \"drops all indexes for the collection\" do",
      "102:         indexes[name: 1].should be_nil",
      "103:         indexes[age: -1].should be_nil",
      "107:     context \"with a key\" do",
      "108:       before do",
      "109:         indexes.drop(name: 1)",
      "110:       end",
      "112:       it \"drops the index that matches the key\" do",
      "114:       end",
      "116:       it \"does not drop other indexes\" do",
      "117:         indexes[age: -1].should_not be_nil",
      "118:       end",
      "119:     end",
      "121:     context \"with a key that doesn't exist\" do",
      "122:       it \"returns false\" do",
      "123:         indexes.drop(other: 1).should be_false",
      "",
      "[Added Lines]",
      "4:   let(:session) do",
      "5:     Moped::Session.new %w[127.0.0.1:27017], database: \"moped_test\"",
      "8:   let(:indexes) do",
      "9:     session[:users].indexes",
      "12:   before do",
      "13:     indexes.drop",
      "17:     context \"when called without extra options\" do",
      "18:       it \"creates an index with no options\" do",
      "19:         indexes.create name: 1",
      "20:         indexes[name: 1].should_not be_nil",
      "24:     context \"when called with extra options\" do",
      "25:       it \"creates an index with the extra options\" do",
      "26:         indexes.create({name: 1}, {unique: true, dropDups: true})",
      "27:         index = indexes[name: 1]",
      "28:         index[\"unique\"].should be_true",
      "29:         index[\"dropDups\"].should be_true",
      "35:     context \"when provided a key\" do",
      "36:       it \"drops the index\" do",
      "37:         indexes.create name: 1",
      "38:         indexes.drop(name: 1).should be_true",
      "42:     context \"when not provided a key\" do",
      "43:       it \"drops all indexes\" do",
      "44:         indexes.create name: 1",
      "45:         indexes.create age: 1",
      "46:         indexes.drop",
      "48:         indexes[age: 1].should be_nil",
      "",
      "---------------"
    ],
    "spec/moped/logging_spec.rb||spec/moped/logging_spec.rb": [
      "File: spec/moped/logging_spec.rb -> spec/moped/logging_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/node_spec.rb||spec/moped/node_spec.rb": [
      "File: spec/moped/node_spec.rb -> spec/moped/node_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: require \"spec_helper\"",
      "3: describe Moped::Node, replica_set: true do",
      "4:   let(:replica_set_node) do",
      "5:     @replica_set.nodes.first",
      "6:   end",
      "8:   let(:node) do",
      "9:     Moped::Node.new(replica_set_node.address)",
      "10:   end",
      "12:   describe \"#ensure_connected\" do",
      "13:     context \"when node is running\" do",
      "14:       it \"processes the block\" do",
      "15:         node.ensure_connected do",
      "16:           node.command(\"admin\", ping: 1)",
      "17:         end.should eq(\"ok\" => 1)",
      "18:       end",
      "19:     end",
      "21:     context \"when node is not running\" do",
      "22:       before do",
      "23:         replica_set_node.stop",
      "24:       end",
      "26:       it \"raises a connection error\" do",
      "27:         lambda do",
      "28:           node.ensure_connected do",
      "29:             node.command(\"admin\", ping: 1)",
      "30:           end",
      "31:         end.should raise_exception(Moped::Errors::ConnectionFailure)",
      "32:       end",
      "34:       it \"marks the node as down\" do",
      "35:         node.ensure_connected {} rescue nil",
      "36:         node.should be_down",
      "37:       end",
      "38:     end",
      "40:     context \"when node is connected but connection is dropped\" do",
      "41:       before do",
      "42:         node.ensure_connected do",
      "43:           node.command(\"admin\", ping: 1)",
      "44:         end",
      "46:         replica_set_node.hiccup",
      "47:       end",
      "49:       it \"reconnects without raising an exception\" do",
      "50:         node.ensure_connected do",
      "51:           node.command(\"admin\", ping: 1)",
      "52:         end.should eq(\"ok\" => 1)",
      "53:       end",
      "54:     end",
      "55:   end",
      "57: end",
      "",
      "---------------"
    ],
    "spec/moped/query_spec.rb||spec/moped/query_spec.rb": [
      "File: spec/moped/query_spec.rb -> spec/moped/query_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"spec_helper\"",
      "3: describe Moped::Query do",
      "37:     end",
      "41:     end",
      "49:     end",
      "53:     end",
      "61:     end",
      "65:     end",
      "73:     end",
      "90:       end",
      "91:     end",
      "102:       end",
      "103:     end",
      "120:       end",
      "141:       end",
      "142:     end",
      "150:     end",
      "162:     end",
      "174:     end",
      "180:     end",
      "181:   end",
      "187:     end",
      "212:     end",
      "213:   end",
      "219:     end",
      "225:   end",
      "240:   end",
      "254:     end",
      "259:     before do",
      "262:     end",
      "279:     end",
      "286:     end",
      "287:   end",
      "288: end",
      "",
      "[Removed Lines]",
      "5:   let(:session) do",
      "6:     mock(Moped::Session)",
      "7:   end",
      "9:   let(:database) do",
      "10:     mock(",
      "11:       Moped::Database,",
      "12:       name: \"moped\",",
      "13:       session: session",
      "14:     )",
      "15:   end",
      "17:   let(:collection) do",
      "18:     mock(",
      "19:       Moped::Collection,",
      "20:       database: database,",
      "21:       name: \"users\"",
      "22:     )",
      "23:   end",
      "25:   let(:selector) do",
      "26:     Hash[ a: 1 ]",
      "27:   end",
      "29:   let(:query) do",
      "30:     described_class.new collection, selector",
      "31:   end",
      "33:   describe \"#initialize\" do",
      "35:     it \"stores the collection\" do",
      "36:       query.collection.should eq collection",
      "39:     it \"stores the selector\" do",
      "40:       query.selector.should eq selector",
      "42:   end",
      "44:   describe \"#limit\" do",
      "46:     it \"sets the query operation's limit field\" do",
      "47:       query.limit(5)",
      "48:       query.operation.limit.should eq 5",
      "51:     it \"returns the query\" do",
      "52:       query.limit(5).should eql query",
      "54:   end",
      "56:   describe \"#skip\" do",
      "58:     it \"sets the query operation's skip field\" do",
      "59:       query.skip(5)",
      "60:       query.operation.skip.should eq 5",
      "63:     it \"returns the query\" do",
      "64:       query.skip(5).should eql query",
      "66:   end",
      "68:   describe \"#select\" do",
      "70:     it \"sets the query operation's fields\" do",
      "71:       query.select(a: 1)",
      "72:       query.operation.fields.should eq(a: 1)",
      "75:     it \"returns the query\" do",
      "76:       query.select(a: 1).should eql query",
      "77:     end",
      "78:   end",
      "80:   describe \"#sort\" do",
      "82:     context \"when called for the first time\" do",
      "84:       it \"updates the selector to mongo's advanced selector\" do",
      "85:         query.sort(a: 1)",
      "86:         query.operation.selector.should eq(",
      "87:           \"$query\" => selector,",
      "88:           \"$orderby\" => { a: 1 }",
      "89:         )",
      "93:     context \"when called again\" do",
      "95:       it \"changes the $orderby\" do",
      "96:         query.sort(a: 1)",
      "97:         query.sort(a: 2)",
      "98:         query.operation.selector.should eq(",
      "99:           \"$query\" => selector,",
      "100:           \"$orderby\" => { a: 2 }",
      "101:         )",
      "105:     it \"returns the query\" do",
      "106:       query.sort(a: 1).should eql query",
      "107:     end",
      "108:   end",
      "110:   describe \"#explain\" do",
      "112:     before do",
      "113:       session.should_receive(:simple_query).with(query.operation)",
      "114:     end",
      "116:     context \"when a sort exists\" do",
      "118:       before do",
      "119:         query.sort(_id: 1)",
      "122:       it \"updates to a mongo advanced selector\" do",
      "123:         query.explain",
      "124:         query.operation.selector.should eq(",
      "125:           \"$query\" => selector,",
      "126:           \"$explain\" => true,",
      "127:           \"$orderby\" => { _id: 1 }",
      "128:         )",
      "129:       end",
      "130:     end",
      "132:     context \"when no sort exists\" do",
      "134:       it \"updates to a mongo advanced selector\" do",
      "135:         query.explain",
      "136:         query.operation.selector.should eq(",
      "137:           \"$query\" => selector,",
      "138:           \"$explain\" => true,",
      "139:           \"$orderby\" => {}",
      "140:         )",
      "143:   end",
      "145:   describe \"#one\" do",
      "147:     it \"executes a simple query\" do",
      "148:       session.should_receive(:simple_query).with(query.operation)",
      "149:       query.one",
      "151:   end",
      "153:   describe \"#distinct\" do",
      "155:     it \"executes a distinct command\" do",
      "156:       database.should_receive(:command).with(",
      "157:         distinct: collection.name,",
      "158:         key: \"name\",",
      "159:         query: selector",
      "160:       ).and_return(\"values\" => [ \"durran\", \"bernerd\" ])",
      "161:       query.distinct(:name)",
      "163:   end",
      "165:   describe \"#count\" do",
      "167:     it \"executes a count command\" do",
      "168:       database.should_receive(:command).with(",
      "169:         count: collection.name,",
      "170:         query: selector",
      "171:       ).and_return(\"n\" => 4)",
      "173:       query.count",
      "176:     it \"returns the count\" do",
      "177:       database.stub(command: { \"n\" => 4 })",
      "179:       query.count.should eq 4",
      "183:   describe \"#update\" do",
      "185:     let(:change) do",
      "186:       Hash[ a: 1 ]",
      "189:     it \"updates the record matching selector with change\" do",
      "190:       session.should_receive(:with, :consistency => :strong).",
      "191:         and_yield(session)",
      "193:       session.should_receive(:execute).with do |update|",
      "194:         update.flags.should eq []",
      "195:         update.selector.should eq query.operation.selector",
      "196:         update.update.should eq change",
      "197:       end",
      "199:       query.update change",
      "200:     end",
      "201:   end",
      "203:   describe \"#update_all\" do",
      "205:     let(:change) do",
      "206:       Hash[ a: 1 ]",
      "207:     end",
      "209:     it \"updates all records matching selector with change\" do",
      "210:       query.should_receive(:update).with(change, [:multi])",
      "211:       query.update_all change",
      "215:   describe \"#upsert\" do",
      "217:     let(:change) do",
      "218:       Hash[ a: 1 ]",
      "221:     it \"upserts the record matching selector with change\" do",
      "222:       query.should_receive(:update).with(change, [:upsert])",
      "223:       query.upsert change",
      "224:     end",
      "227:   describe \"#remove\" do",
      "229:     it \"removes the first matching document\" do",
      "230:       session.should_receive(:with, :consistency => :strong).",
      "231:         and_yield(session)",
      "233:       session.should_receive(:execute).with do |delete|",
      "234:         delete.flags.should eq [:remove_first]",
      "235:         delete.selector.should eq query.operation.selector",
      "236:       end",
      "238:       query.remove",
      "239:     end",
      "242:   describe \"#remove_all\" do",
      "244:     it \"removes all matching documents\" do",
      "245:       session.should_receive(:with, :consistency => :strong).",
      "246:         and_yield(session)",
      "248:       session.should_receive(:execute).with do |delete|",
      "249:         delete.flags.should eq []",
      "250:         delete.selector.should eq query.operation.selector",
      "251:       end",
      "253:       query.remove_all",
      "255:   end",
      "257:   describe \"#each\" do",
      "260:       session.should_receive(:with).",
      "261:         with(retain_socket: true).and_return(session)",
      "264:     it \"creates a new cursor\" do",
      "265:       cursor = mock(Moped::Cursor, next: nil)",
      "266:       Moped::Cursor.should_receive(:new).",
      "267:         with(session, query.operation).and_return(cursor)",
      "269:       query.each",
      "270:     end",
      "272:     it \"yields all documents in the cursor\" do",
      "273:       cursor = Moped::Cursor.allocate",
      "274:       cursor.stub(:to_enum).and_return([1, 2].to_enum)",
      "276:       Moped::Cursor.stub(new: cursor)",
      "278:       query.to_a.should eq [1, 2]",
      "281:     it \"returns an enumerator\" do",
      "282:       cursor = mock(Moped::Cursor)",
      "283:       Moped::Cursor.stub(new: cursor)",
      "285:       query.each.should be_a Enumerator",
      "",
      "[Added Lines]",
      "4:   shared_examples_for \"Query\" do",
      "5:     let(:scope) do",
      "6:       object_id",
      "7:     end",
      "9:     before do",
      "10:       users.find.remove_all",
      "13:     let(:documents) do",
      "14:       [",
      "15:         { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope },",
      "16:         { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope }",
      "17:       ]",
      "20:     it \"raises a query failure exception for invalid queries\" do",
      "21:       lambda do",
      "22:         users.find(\"age\" => { \"$in\" => nil }).first",
      "23:       end.should raise_exception(Moped::Errors::QueryFailure)",
      "24:     end",
      "26:     describe \"#limit\" do",
      "27:       it \"limits the query\" do",
      "28:         users.insert(documents)",
      "29:         users.find(scope: scope).limit(1).to_a.should eq [documents.first]",
      "30:       end",
      "33:     describe \"#skip\" do",
      "34:       it \"skips +n+ documents\" do",
      "35:         users.insert(documents)",
      "36:         users.find(scope: scope).skip(1).to_a.should eq [documents.last]",
      "37:       end",
      "40:     describe \"#sort\" do",
      "41:       let(:documents) do",
      "42:         [",
      "43:           { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope, \"n\" => 0 },",
      "44:           { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope, \"n\" => 1 }",
      "45:         ]",
      "46:       end",
      "48:       it \"sorts the results\" do",
      "49:         users.insert(documents)",
      "50:         users.find(scope: scope).sort(n: -1).to_a.should eq documents.reverse",
      "51:       end",
      "54:     describe \"#distinct\" do",
      "55:       let(:documents) do",
      "56:         [",
      "57:           { count: 0, scope: scope },",
      "58:           { count: 1, scope: scope },",
      "59:           { count: 1, scope: scope }",
      "60:         ]",
      "61:       end",
      "63:       it \"returns distinct values for +key+\" do",
      "64:         users.insert(documents)",
      "65:         users.find(scope: scope).distinct(:count).should =~ [0, 1]",
      "66:       end",
      "69:     describe \"#select\" do",
      "70:       let(:documents) do",
      "71:         [",
      "72:           { \"scope\" => scope, \"n\" => 0 },",
      "73:           { \"scope\" => scope, \"n\" => 1 }",
      "74:         ]",
      "75:       end",
      "77:       it \"changes the fields returned\" do",
      "78:         users.insert(documents)",
      "79:         users.find(scope: scope).select(_id: 0).to_a.should eq documents",
      "80:       end",
      "83:     describe \"#one\" do",
      "84:       before do",
      "85:         users.insert(documents)",
      "86:       end",
      "88:       it \"returns the first matching document\" do",
      "89:         users.find(scope: scope).one.should eq documents.first",
      "90:       end",
      "92:       it \"respects #skip\" do",
      "93:         users.find(scope: scope).skip(1).one.should eq documents.last",
      "94:       end",
      "96:       it \"respects #sort\" do",
      "97:         users.find(scope: scope).sort(_id: -1).one.should eq documents.last",
      "101:     describe \"#explain\" do",
      "102:       context \"when a sort exists\" do",
      "103:         it \"updates to a mongo advanced selector\" do",
      "104:           stats = Support::Stats.collect do",
      "105:             users.find(scope: scope).sort(_id: 1).explain",
      "106:           end",
      "108:           operation = stats[node_for_reads].grep(Moped::Protocol::Query).last",
      "109:           operation.selector.should eq(",
      "110:             \"$query\" => { scope: scope },",
      "111:             \"$explain\" => true,",
      "112:             \"$orderby\" => { _id: 1 }",
      "113:           )",
      "114:         end",
      "115:       end",
      "117:       context \"when no sort exists\" do",
      "118:         it \"updates to a mongo advanced selector\" do",
      "119:           stats = Support::Stats.collect do",
      "120:             users.find(scope: scope).explain",
      "121:           end",
      "123:           operation = stats[node_for_reads].grep(Moped::Protocol::Query).last",
      "124:           operation.selector.should eq(",
      "125:             \"$query\" => { scope: scope },",
      "126:             \"$explain\" => true,",
      "127:             \"$orderby\" => {}",
      "128:           )",
      "129:         end",
      "133:     describe \"#each\" do",
      "134:       it \"yields each document\" do",
      "135:         users.insert(documents)",
      "136:         users.find(scope: scope).each.with_index do |document, index|",
      "137:           document.should eq documents[index]",
      "138:         end",
      "139:       end",
      "141:       context \"with a limit\" do",
      "142:         it \"closes open cursors\" do",
      "143:           users.insert(100.times.map { Hash[\"scope\" => scope] })",
      "145:           stats = Support::Stats.collect do",
      "146:             users.find(scope: scope).limit(5).entries",
      "147:           end",
      "149:           stats[node_for_reads].grep(Moped::Protocol::KillCursors).count.should eq 1",
      "150:         end",
      "154:       context \"without a limit\" do",
      "155:         it \"fetches more\" do",
      "156:           users.insert(102.times.map { Hash[\"scope\" => scope] })",
      "158:           stats = Support::Stats.collect do",
      "159:             users.find(scope: scope).entries",
      "160:           end",
      "162:           stats[node_for_reads].grep(Moped::Protocol::GetMore).count.should eq 1",
      "163:         end",
      "167:     describe \"#count\" do",
      "168:       let(:documents) do",
      "169:         [",
      "170:           { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope },",
      "171:           { \"_id\" => Moped::BSON::ObjectId.new, \"scope\" => scope },",
      "172:           { \"_id\" => Moped::BSON::ObjectId.new }",
      "173:         ]",
      "174:       end",
      "176:       it \"returns the number of matching document\" do",
      "177:         users.insert(documents)",
      "178:         users.find(scope: scope).count.should eq 2",
      "179:       end",
      "182:     describe \"#update\" do",
      "183:       it \"updates the first matching document\" do",
      "184:         users.insert(documents)",
      "185:         users.find(scope: scope).update(\"$set\" => { \"updated\" => true })",
      "186:         users.find(scope: scope, updated: true).count.should eq 1",
      "187:       end",
      "188:     end",
      "190:     describe \"#update_all\" do",
      "191:       it \"updates all matching documents\" do",
      "192:         users.insert(documents)",
      "193:         users.find(scope: scope).update_all(\"$set\" => { \"updated\" => true })",
      "194:         users.find(scope: scope, updated: true).count.should eq 2",
      "195:       end",
      "198:     describe \"#upsert\" do",
      "199:       context \"when a document exists\" do",
      "200:         before do",
      "201:           users.insert(scope: scope, counter: 1)",
      "202:         end",
      "204:         it \"updates the document\" do",
      "205:           users.find(scope: scope).upsert(\"$inc\" => { counter: 1 })",
      "206:           users.find(scope: scope).one[\"counter\"].should eq 2",
      "207:         end",
      "208:       end",
      "210:       context \"when no document exists\" do",
      "211:         it \"inserts a document\" do",
      "212:           users.find(scope: scope).upsert(\"$inc\" => { counter: 1 })",
      "213:           users.find(scope: scope).one[\"counter\"].should eq 1",
      "214:         end",
      "215:       end",
      "218:     describe \"#remove\" do",
      "219:       it \"removes the first matching document\" do",
      "220:         users.insert(documents)",
      "221:         users.find(scope: scope).remove",
      "222:         users.find(scope: scope).count.should eq 1",
      "223:       end",
      "224:     end",
      "226:     describe \"#remove_all\" do",
      "227:       it \"removes all matching documents\" do",
      "228:         users.insert(documents)",
      "229:         users.find(scope: scope).remove_all",
      "230:         users.find(scope: scope).count.should eq 0",
      "231:       end",
      "235:   context \"with a local connection\" do",
      "236:     let(:session) do",
      "237:       Moped::Session.new %w[127.0.0.1:27017], database: \"moped_test\"",
      "240:     let(:users) { session[:users] }",
      "241:     let(:node_for_reads) { :primary }",
      "243:     include_examples \"Query\"",
      "245:     describe \"#each\" do",
      "246:       context \"with a limit and large result set\" do",
      "247:         it \"gets more and closes cursors\" do",
      "248:           11.times do",
      "249:             users.insert(scope: scope, large_field: \"a\"*1_000_000)",
      "250:           end",
      "252:           stats = Support::Stats.collect do",
      "253:             users.find(scope: scope).limit(10).entries",
      "254:           end",
      "256:           stats[:primary].grep(Moped::Protocol::GetMore).count.should eq 1",
      "257:           stats[:primary].grep(Moped::Protocol::KillCursors).count.should eq 1",
      "258:         end",
      "259:       end",
      "263:   context \"with a remote connection\", mongohq: :auth do",
      "264:     before :all do",
      "265:       @session = Support::MongoHQ.auth_session",
      "268:     let(:users) { @session[:users] }",
      "269:     let(:node_for_reads) { :primary }",
      "271:     include_examples \"Query\"",
      "274:   context \"with a remote replica set connection with eventual consistency\", mongohq: :replica_set do",
      "275:     before :all do",
      "276:       @session = Support::MongoHQ.replica_set_session.with(safe: true, consistency: :eventual)",
      "277:       @session.command ping: 1",
      "278:     end",
      "280:     let(:users) { @session[:users] }",
      "281:     let(:node_for_reads) { :secondary }",
      "283:     include_examples \"Query\"",
      "286:   context \"with a remote replica set connection with strong consistency\", mongohq: :replica_set do",
      "287:     before :all do",
      "288:       @session = Support::MongoHQ.replica_set_session.with(safe: true, consistency: :strong)",
      "289:     end",
      "291:     let(:users) { @session[:users] }",
      "292:     let(:node_for_reads) { :primary }",
      "294:     include_examples \"Query\"",
      "295:   end",
      "297:   context \"with a local replica set w/ failover\", replica_set: true do",
      "298:     let(:session) do",
      "299:       Moped::Session.new seeds, database: \"moped_test\"",
      "302:     let(:scope) do",
      "303:       object_id",
      "304:     end",
      "307:       # Force connection before recording stats",
      "308:       session.command ping: 1",
      "311:     context \"and running with eventual consistency\" do",
      "312:       it \"queries a secondary node\" do",
      "313:         stats = Support::Stats.collect do",
      "314:           session.with(consistency: :eventual)[:users].find(scope: scope).entries",
      "315:         end",
      "317:         stats[:secondary].grep(Moped::Protocol::Query).count.should eq 1",
      "318:         stats[:primary].should be_empty",
      "319:       end",
      "321:       it \"sets the slave ok flag\" do",
      "322:         stats = Support::Stats.collect do",
      "323:           session.with(consistency: :eventual)[:users].find(scope: scope).one",
      "324:         end",
      "326:         query = stats[:secondary].grep(Moped::Protocol::Query).first",
      "327:         query.flags.should include :slave_ok",
      "328:       end",
      "330:       context \"and no secondaries are available\" do",
      "331:         before do",
      "332:           @secondaries.each &:stop",
      "333:         end",
      "335:         it \"queries the primary node\" do",
      "336:           stats = Support::Stats.collect do",
      "337:             session.with(consistency: :eventual)[:users].find(scope: scope).entries",
      "338:           end",
      "340:           stats[:primary].grep(Moped::Protocol::Query).count.should eq 1",
      "341:         end",
      "342:       end",
      "345:     context \"and running with strong consistency\" do",
      "346:       it \"queries the primary node\" do",
      "347:         stats = Support::Stats.collect do",
      "348:           session.with(consistency: :strong)[:users].find(scope: scope).entries",
      "349:         end",
      "351:         stats[:primary].grep(Moped::Protocol::Query).count.should eq 1",
      "352:         stats[:secondary].should be_empty",
      "353:       end",
      "355:       it \"does not set the slave ok flag\" do",
      "356:         stats = Support::Stats.collect do",
      "357:           session.with(consistency: :strong)[:users].find(scope: scope).one",
      "358:         end",
      "360:         query = stats[:primary].grep(Moped::Protocol::Query).first",
      "361:         query.flags.should_not include :slave_ok",
      "362:       end",
      "",
      "---------------"
    ],
    "spec/moped/server_spec.rb||spec/moped/server_spec.rb": [
      "File: spec/moped/server_spec.rb -> spec/moped/server_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped/session_spec.rb||spec/moped/session_spec.rb": [
      "File: spec/moped/session_spec.rb -> spec/moped/session_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"spec_helper\"",
      "3: describe Moped::Session do",
      "13:   let(:session) do",
      "108:   end",
      "110:   describe \"#use\" do",
      "123:     end",
      "124:   end",
      "126:   describe \"#with\" do",
      "132:     context \"when called with a block\" do",
      "138:       end",
      "143:         end",
      "144:       end",
      "167:         end",
      "168:       end",
      "169:     end",
      "171:     context \"when called without a block\" do",
      "225:       end",
      "233:       end",
      "234:     end",
      "235:   end",
      "237:   describe \"#drop\" do",
      "317:       end",
      "318:     end",
      "337:   end",
      "420:       end",
      "421:     end",
      "422:   end",
      "548: end",
      "",
      "[Removed Lines]",
      "5:   let(:seeds) do",
      "6:     \"127.0.0.1:27017\"",
      "7:   end",
      "9:   let(:options) do",
      "10:     Hash[database: \"test\", safe: true, consistency: :eventual]",
      "11:   end",
      "14:     described_class.new seeds, options",
      "15:   end",
      "17:   describe \"#initialize\" do",
      "19:     it \"stores the options provided\" do",
      "20:       session.options.should eq(options)",
      "21:     end",
      "23:     it \"stores the cluster\" do",
      "24:       session.cluster.should be_a(Moped::Cluster)",
      "25:     end",
      "26:   end",
      "28:   describe \"#current_database\" do",
      "30:     context \"when no database option has been set\" do",
      "32:       let(:session) do",
      "33:         described_class.new seeds, {}",
      "34:       end",
      "36:       it \"raises an exception\" do",
      "37:         expect { session.current_database }.to raise_exception",
      "38:       end",
      "39:     end",
      "41:     context \"when a database option is set\" do",
      "43:       let(:database) do",
      "44:         stub",
      "45:       end",
      "47:       before do",
      "48:         Moped::Database.should_receive(:new).",
      "49:           with(session, options[:database]).and_return(database)",
      "50:       end",
      "52:       it \"returns the database from the options\" do",
      "53:         session.current_database.should eq(database)",
      "54:       end",
      "56:       it \"memoizes the database\" do",
      "57:         database = session.current_database",
      "58:         session.current_database.should equal(database)",
      "59:       end",
      "60:     end",
      "61:   end",
      "63:   describe \"#safe?\" do",
      "65:     context \"when :safe is not present\" do",
      "67:       before do",
      "68:         session.options.delete(:safe)",
      "69:       end",
      "71:       it \"returns false\" do",
      "72:         session.should_not be_safe",
      "73:       end",
      "74:     end",
      "76:     context \"when :safe is present but false\" do",
      "78:       before do",
      "79:         session.options[:safe] = false",
      "80:       end",
      "82:       it \"returns false\" do",
      "83:         session.should_not be_safe",
      "84:       end",
      "85:     end",
      "87:     context \"when :safe is true\" do",
      "89:       before do",
      "90:         session.options[:safe] = true",
      "91:       end",
      "93:       it \"returns true\" do",
      "94:         session.should be_safe",
      "95:       end",
      "96:     end",
      "98:     context \"when :safe is a hash\" do",
      "100:       before do",
      "101:         session.options[:safe] = { fsync: true }",
      "102:       end",
      "104:       it \"returns true\" do",
      "105:         session.should be_safe",
      "106:       end",
      "107:     end",
      "112:     it \"sets the :database option\" do",
      "113:       session.use :admin",
      "114:       session.options[:database].should eq(:admin)",
      "115:     end",
      "117:     context \"when there is not already a current database\" do",
      "119:       it \"sets the current database\" do",
      "120:         session.should_receive(:set_current_database).with(:admin)",
      "121:         session.use :admin",
      "122:       end",
      "128:     let(:new_options) do",
      "129:       Hash[database: \"test-2\"]",
      "130:     end",
      "134:       it \"yields a session\" do",
      "135:         session.with(new_options) do |new_session|",
      "136:           new_session.should be_a Moped::Session",
      "137:         end",
      "140:       it \"yields a new session\" do",
      "141:         session.with(new_options) do |new_session|",
      "142:           new_session.should_not eql session",
      "146:       it \"returns the result of the block\" do",
      "147:         session.with(new_options) { false }.should eq false",
      "148:       end",
      "150:       it \"merges the old and new session's options\" do",
      "151:         session.with(new_options) do |new_session|",
      "152:           new_session.options.should eq options.merge(new_options)",
      "153:         end",
      "154:       end",
      "156:       it \"does not change the original session's options\" do",
      "157:         original_options = options.dup",
      "158:         session.with(new_options) do |new_session|",
      "159:           session.options.should eql original_options",
      "160:         end",
      "161:       end",
      "163:       it \"unmemoizes the current database\" do",
      "164:         db = session.current_database",
      "165:         session.with(new_options) do |new_session|",
      "166:           new_session.current_database.should_not eql db",
      "173:       it \"returns a session\" do",
      "174:         session.with(new_options).should be_a Moped::Session",
      "175:       end",
      "177:       it \"returns a new session\" do",
      "178:         session.with(new_options).should_not eql session",
      "179:       end",
      "181:       it \"merges the old and new session's options\" do",
      "182:         session.with(new_options).options.should eq options.merge(new_options)",
      "183:       end",
      "185:       it \"does not change the original session's options\" do",
      "186:         original_options = options.dup",
      "187:         session.with(new_options)",
      "188:         session.options.should eql original_options",
      "189:       end",
      "190:     end",
      "191:   end",
      "193:   describe \"#new\" do",
      "195:     let(:new_options) do",
      "196:       Hash[database: \"test-2\"]",
      "197:     end",
      "199:     let(:new_session) do",
      "200:       described_class.new seeds, options",
      "201:     end",
      "203:     before do",
      "204:       new_session.cluster.stub(:reconnect)",
      "205:     end",
      "207:     it \"delegates to #with\" do",
      "208:       session.should_receive(:with).with(new_options).and_return(new_session)",
      "209:       session.new(new_options)",
      "210:     end",
      "212:     it \"instructs the cluster to reconnect\" do",
      "213:       session.stub(with: new_session)",
      "214:       new_session.cluster.should_receive(:reconnect)",
      "215:       session.new(new_options)",
      "216:     end",
      "218:     context \"when called with a block\" do",
      "220:       it \"yields the new session\" do",
      "221:         session.stub(with: new_session)",
      "222:         session.new(new_options) do |session|",
      "223:           session.should eql new_session",
      "224:         end",
      "226:     end",
      "228:     context \"when called without a block\" do",
      "230:       it \"returns the new session\" do",
      "231:         session.stub(with: new_session)",
      "232:         session.new(new_options).should eql new_session",
      "239:     it \"delegates to the current database\" do",
      "240:       database = mock(Moped::Database)",
      "241:       session.should_receive(:current_database).and_return(database)",
      "242:       database.should_receive(:drop)",
      "243:       session.drop",
      "244:     end",
      "245:   end",
      "247:   describe \"#command\" do",
      "249:     let(:command) do",
      "250:       Hash[ismaster: 1]",
      "251:     end",
      "253:     it \"delegates to the current database\" do",
      "254:       database = mock(Moped::Database)",
      "255:       session.should_receive(:current_database).and_return(database)",
      "256:       database.should_receive(:command).with(command)",
      "257:       session.command command",
      "258:     end",
      "259:   end",
      "261:   describe \"#login\" do",
      "263:     it \"delegates to the current database\" do",
      "264:       database = mock(Moped::Database)",
      "265:       session.should_receive(:current_database).and_return(database)",
      "266:       database.should_receive(:login).with(\"username\", \"password\")",
      "267:       session.login(\"username\", \"password\")",
      "268:     end",
      "269:   end",
      "271:   describe \"#logout\" do",
      "273:     it \"delegates to the current database\" do",
      "274:       database = mock(Moped::Database)",
      "275:       session.should_receive(:current_database).and_return(database)",
      "276:       database.should_receive(:logout)",
      "277:       session.logout",
      "278:     end",
      "279:   end",
      "281:   describe \"#socket_for\" do",
      "283:     it \"delegates to the cluster\" do",
      "284:       session.cluster.should_receive(:socket_for).with(:read)",
      "285:       session.send(:socket_for, :read)",
      "286:     end",
      "288:     context \"when retain socket option is set\" do",
      "290:       before do",
      "291:         session.options[:retain_socket] = true",
      "292:       end",
      "294:       it \"only aquires the socket once\" do",
      "295:         session.cluster.should_receive(:socket_for).",
      "296:           with(:read).once.and_return(mock(Moped::Socket))",
      "298:         session.send(:socket_for, :read)",
      "299:         session.send(:socket_for, :read)",
      "300:       end",
      "301:     end",
      "302:   end",
      "304:   describe \"#simple_query\" do",
      "306:     let(:query) do",
      "307:       Moped::Protocol::Query.allocate",
      "308:     end",
      "310:     let(:socket) do",
      "311:       mock(Moped::Socket)",
      "312:     end",
      "314:     let(:reply) do",
      "315:       Moped::Protocol::Reply.allocate.tap do |reply|",
      "316:         reply.documents = [{a: 1}]",
      "320:     before do",
      "321:       session.stub(socket_for: socket)",
      "322:       session.stub(query: reply)",
      "323:     end",
      "325:     it \"limits the query\" do",
      "326:       session.should_receive(:query) do |query|",
      "327:         query.limit.should eq(-1)",
      "328:         reply",
      "329:       end",
      "331:       session.simple_query(query)",
      "332:     end",
      "334:     it \"returns the document\" do",
      "335:       session.simple_query(query).should eq(a: 1)",
      "336:     end",
      "339:   describe \"#query\" do",
      "341:     let(:query) do",
      "342:       Moped::Protocol::Query.allocate",
      "343:     end",
      "345:     let(:socket) do",
      "346:       mock(Moped::Socket)",
      "347:     end",
      "349:     let(:reply) do",
      "350:       Moped::Protocol::Reply.allocate.tap do |reply|",
      "351:         reply.documents = [{a: 1}]",
      "352:       end",
      "353:     end",
      "355:     before do",
      "356:       session.stub(socket_for: socket)",
      "357:       socket.stub(:execute).and_return(reply)",
      "358:     end",
      "360:     context \"when consistency is strong\" do",
      "362:       before do",
      "363:         session.options[:consistency] = :strong",
      "364:       end",
      "366:       it \"queries the master node\" do",
      "367:         session.should_receive(:socket_for).with(:write).",
      "368:           and_return(socket)",
      "369:         session.query(query)",
      "370:       end",
      "371:     end",
      "373:     context \"when consistency is eventual\" do",
      "375:       before do",
      "376:         session.options[:consistency] = :eventual",
      "377:       end",
      "379:       it \"queries a slave node\" do",
      "380:         session.should_receive(:socket_for).with(:read).",
      "381:           and_return(socket)",
      "382:         session.query(query)",
      "383:       end",
      "385:       context \"and query accepts flags\" do",
      "387:         it \"sets slave_ok on the query flags\" do",
      "388:           session.stub(socket_for: socket)",
      "389:           socket.should_receive(:execute) do |query|",
      "390:             query.flags.should include :slave_ok",
      "391:           end",
      "393:           session.query(query)",
      "394:         end",
      "395:       end",
      "397:       context \"and query does not accept flags\" do",
      "399:         let(:query) do",
      "400:           Moped::Protocol::GetMore.allocate",
      "401:         end",
      "403:         it \"doesn't try to set flags\" do",
      "404:           session.stub(socket_for: socket)",
      "405:           expect { session.query(query) }.not_to raise_exception",
      "406:         end",
      "407:       end",
      "408:     end",
      "410:     context \"when reply has :query_failure flag\" do",
      "412:       before do",
      "413:         reply.flags = [:query_failure]",
      "414:       end",
      "416:       it \"raises a QueryFailure exception\" do",
      "417:         expect {",
      "418:           session.query(query)",
      "419:         }.to raise_exception(Moped::Errors::QueryFailure)",
      "424:   describe \"#execute\" do",
      "426:     let(:operation) do",
      "427:       Moped::Protocol::Insert.allocate",
      "428:     end",
      "430:     let(:socket) do",
      "431:       mock(Moped::Socket)",
      "432:     end",
      "434:     context \"when session is not in safe mode\" do",
      "436:       before do",
      "437:         session.options[:safe] = false",
      "438:       end",
      "440:       context \"when consistency is strong\" do",
      "442:         before do",
      "443:           session.options[:consistency] = :strong",
      "444:         end",
      "446:         it \"executes the operation on the master node\" do",
      "447:           session.should_receive(:socket_for).with(:write).",
      "448:             and_return(socket)",
      "449:           socket.should_receive(:execute).with(operation)",
      "451:           session.execute(operation)",
      "452:         end",
      "453:       end",
      "455:       context \"when consistency is eventual\" do",
      "457:         before do",
      "458:           session.options[:consistency] = :eventual",
      "459:         end",
      "461:         it \"executes the operation on a slave node\" do",
      "462:           session.should_receive(:socket_for).with(:read).",
      "463:             and_return(socket)",
      "464:           socket.should_receive(:execute).with(operation)",
      "466:           session.execute(operation)",
      "467:         end",
      "468:       end",
      "469:     end",
      "471:     context \"when session is in safe mode\" do",
      "473:       let(:reply) do",
      "474:         Moped::Protocol::Reply.allocate.tap do |reply|",
      "475:           reply.documents = [{a: 1}]",
      "476:         end",
      "477:       end",
      "479:       before do",
      "480:         session.options[:safe] = { w: 2 }",
      "481:       end",
      "483:       context \"when the operation fails\" do",
      "485:         let(:reply) do",
      "486:           Moped::Protocol::Reply.allocate.tap do |reply|",
      "487:             reply.documents = [{",
      "488:               \"err\"=>\"document to insert can't have $ fields\",",
      "489:               \"code\"=>13511,",
      "490:               \"n\"=>0,",
      "491:               \"connectionId\"=>894,",
      "492:               \"ok\"=>1.0",
      "493:             }]",
      "494:           end",
      "495:         end",
      "497:         it \"raises an OperationFailure exception\" do",
      "498:           session.stub(socket_for: socket)",
      "499:           socket.stub(execute: reply)",
      "501:           expect {",
      "502:             session.execute(operation)",
      "503:           }.to raise_exception(Moped::Errors::OperationFailure)",
      "504:         end",
      "505:       end",
      "507:       context \"when consistency is strong\" do",
      "509:         before do",
      "510:           session.options[:consistency] = :strong",
      "511:         end",
      "513:         it \"executes the operation on the master node\" do",
      "514:           session.should_receive(:socket_for).with(:write).",
      "515:             and_return(socket)",
      "517:           socket.should_receive(:execute) do |op, query|",
      "518:             op.should eq operation",
      "519:             query.selector.should eq(getlasterror: 1, w: 2)",
      "520:             reply",
      "521:           end",
      "523:           session.execute(operation)",
      "524:         end",
      "525:       end",
      "527:       context \"when consistency is eventual\" do",
      "529:         before do",
      "530:           session.options[:consistency] = :eventual",
      "531:         end",
      "533:         it \"executes the operation on a slave node\" do",
      "534:           session.should_receive(:socket_for).with(:read).",
      "535:             and_return(socket)",
      "537:           socket.should_receive(:execute) do |op, query|",
      "538:             op.should eq operation",
      "539:             query.selector.should eq(getlasterror: 1, w: 2)",
      "540:             reply",
      "541:           end",
      "543:           session.execute(operation)",
      "544:         end",
      "545:       end",
      "546:     end",
      "547:   end",
      "",
      "[Added Lines]",
      "5:     Moped::Session.new %w[127.0.0.1:27017], database: \"moped_test\"",
      "9:     it \"changes the current database\" do",
      "10:       session.use \"moped_test_2\"",
      "11:       session.command(dbStats: 1)[\"db\"].should eq \"moped_test_2\"",
      "17:       it \"returns the value from the block\" do",
      "18:         session.with { :value }.should eq :value",
      "21:       it \"yields a session with the provided options\" do",
      "22:         session.with(safe: true) do |safe|",
      "23:           safe.options[:safe].should eq true",
      "27:       it \"does not modify the original session\" do",
      "28:         session.with(database: \"other\") do |safe|",
      "29:           session.options[:database].should eq \"moped_test\"",
      "35:       it \"returns a session with the provided options\" do",
      "36:         safe = session.with(safe: true)",
      "37:         safe.options[:safe].should eq true",
      "40:       it \"does not modify the original session\" do",
      "41:         other = session.with(database: \"other\")",
      "42:         session.options[:database].should eq \"moped_test\"",
      "48:     it \"drops the current database\" do",
      "49:       session.with(database: \"moped_test_2\") do |session|",
      "50:         session.drop.should eq(\"dropped\" => \"moped_test_2\", \"ok\" => 1)",
      "55:   describe \"#command\" do",
      "56:     it \"runs the command on the current database\" do",
      "57:       session.with(database: \"moped_test_2\") do |session|",
      "58:         session.command(dbStats: 1)[\"db\"].should eq \"moped_test_2\"",
      "",
      "---------------"
    ],
    "spec/moped/socket_spec.rb||spec/moped/socket_spec.rb": [
      "File: spec/moped/socket_spec.rb -> spec/moped/socket_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/moped_spec.rb||spec/moped_spec.rb": [
      "File: spec/moped_spec.rb -> spec/moped_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/replset_spec.rb||spec/replset_spec.rb": [
      "File: spec/replset_spec.rb -> spec/replset_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/spec_helper.rb||spec/spec_helper.rb": [
      "File: spec/spec_helper.rb -> spec/spec_helper.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: require \"java\" if RUBY_PLATFORM == \"java\"",
      "5: $:.unshift((Pathname(__FILE__).dirname.parent + \"lib\").to_s)",
      "7: require \"moped\"",
      "",
      "[Removed Lines]",
      "2: require \"bundler\"",
      "3: Bundler.require",
      "9: require \"support/mock_connection\"",
      "",
      "[Added Lines]",
      "2: require \"rspec\"",
      "7: require \"support/mongohq\"",
      "8: require \"support/replica_set_simulator\"",
      "9: require \"support/stats\"",
      "11: RSpec.configure do |config|",
      "12:   Support::Stats.install!",
      "14:   config.include Support::ReplicaSetSimulator::Helpers, replica_set: true",
      "16:   config.filter_run_excluding mongohq: ->(value) do",
      "17:     return true if value == :replica_set && !Support::MongoHQ.replica_set_configured?",
      "18:     return true if value == :auth && !Support::MongoHQ.auth_node_configured?",
      "19:   end",
      "21:   unless Support::MongoHQ.replica_set_configured? || Support::MongoHQ.auth_node_configured?",
      "22:     $stderr.puts Support::MongoHQ.message",
      "23:   end",
      "24: end",
      "",
      "---------------"
    ],
    "spec/support/mock_connection.rb||spec/support/mock_connection.rb": [
      "File: spec/support/mock_connection.rb -> spec/support/mock_connection.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "spec/support/mongohq.rb||spec/support/mongohq.rb": [
      "File: spec/support/mongohq.rb -> spec/support/mongohq.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Support",
      "2:   module MongoHQ",
      "3:     extend self",
      "5:     def replica_set_configured?",
      "6:       ENV[\"MONGOHQ_REPL_PASS\"]",
      "7:     end",
      "9:     def replica_set_seeds",
      "10:       [ENV[\"MONGOHQ_REPL_1_URL\"], ENV[\"MONGOHQ_REPL_2_URL\"]]",
      "11:     end",
      "13:     def replica_set_credentials",
      "14:       [ENV[\"MONGOHQ_REPL_USER\"], ENV[\"MONGOHQ_REPL_PASS\"]]",
      "15:     end",
      "17:     def replica_set_database",
      "18:       ENV[\"MONGOHQ_REPL_NAME\"]",
      "19:     end",
      "21:     def replica_set_session(auth = true)",
      "22:       session = Moped::Session.new replica_set_seeds, database: replica_set_database",
      "23:       session.login *replica_set_credentials if auth",
      "24:       session",
      "25:     end",
      "27:     def auth_seeds",
      "28:       [ENV[\"MONGOHQ_SINGLE_URL\"]]",
      "29:     end",
      "31:     def auth_node_configured?",
      "32:       ENV[\"MONGOHQ_SINGLE_PASS\"]",
      "33:     end",
      "35:     def auth_credentials",
      "36:       [ENV[\"MONGOHQ_SINGLE_USER\"], ENV[\"MONGOHQ_SINGLE_PASS\"]]",
      "37:     end",
      "39:     def auth_database",
      "40:       ENV[\"MONGOHQ_SINGLE_NAME\"]",
      "41:     end",
      "43:     def auth_session(auth = true)",
      "44:       session = Moped::Session.new auth_seeds, database: auth_database",
      "45:       session.login *auth_credentials if auth",
      "46:       session",
      "47:     end",
      "49:     def message",
      "50:       %Q{",
      "51:       ---------------------------------------------------------------------",
      "52:       Moped runs specs for authentication and replica sets against MongoHQ.",
      "54:       If you want to run these specs and need the credentials, contact",
      "55:       durran at gmail dot com.",
      "56:       ---------------------------------------------------------------------",
      "57:       }",
      "58:     end",
      "60:   end",
      "61: end",
      "",
      "---------------"
    ],
    "spec/support/replica_set_simulator.rb||spec/support/replica_set_simulator.rb": [
      "File: spec/support/replica_set_simulator.rb -> spec/support/replica_set_simulator.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Support",
      "3:   # This is a helper class for testing replica sets. It works by starting up a",
      "4:   # TCP server socket for each desired node. It then proxies all traffic",
      "5:   # between a real mongo instance and the client app, with the exception of",
      "6:   # ismaster commands, which it returns simulated responses for.",
      "7:   class ReplicaSetSimulator",
      "9:     module Helpers",
      "10:       def self.included(context)",
      "11:         context.before :all do",
      "12:           @replica_set = ReplicaSetSimulator.new",
      "13:           @replica_set.start",
      "15:           @primary, @secondaries = @replica_set.initiate",
      "16:         end",
      "18:         context.after :all do",
      "19:           @replica_set.stop",
      "20:         end",
      "22:         context.after :each do",
      "23:           @replica_set.nodes.each &:restart",
      "24:         end",
      "26:         context.let :seeds do",
      "27:           @replica_set.nodes.map &:address",
      "28:         end",
      "29:       end",
      "30:     end",
      "32:     attr_reader :nodes",
      "33:     attr_reader :manager",
      "35:     def initialize(nodes = 3)",
      "36:       @nodes = nodes.times.map { Node.new(self) }",
      "37:       @manager = ConnectionManager.new(@nodes)",
      "38:       @mongo = TCPSocket.new \"127.0.0.1\", 27017",
      "39:     end",
      "41:     # Start the mock replica set.",
      "42:     def start",
      "43:       @nodes.each &:start",
      "44:       @worker = Thread.start do",
      "45:         Thread.abort_on_exception = true",
      "46:         catch(:shutdown) do",
      "47:           loop do",
      "48:             Moped.logger.debug \"replica_set: waiting for next client\"",
      "49:             server, client = @manager.next_client",
      "51:             if server",
      "52:               Moped.logger.debug \"replica_set: proxying incoming request to mongo\"",
      "53:               server.proxy(client, @mongo)",
      "54:             else",
      "55:               Moped.logger.debug \"replica_set: no requests; passing\"",
      "56:               Thread.pass",
      "57:             end",
      "58:           end",
      "59:         end",
      "60:       end",
      "61:     end",
      "63:     # Pick a node to be master, and mark the rest as secondary",
      "64:     def initiate",
      "65:       primary, *secondaries = @nodes.shuffle",
      "67:       primary.promote",
      "68:       secondaries.each &:demote",
      "70:       return primary, secondaries",
      "71:     end",
      "73:     # Shut down the mock replica set.",
      "74:     def stop",
      "75:       @manager.shutdown",
      "76:       @nodes.each &:stop",
      "77:     end",
      "79:     class Node",
      "81:       attr_reader :port",
      "82:       attr_reader :host",
      "84:       def initialize(set)",
      "85:         @set = set",
      "86:         @primary = false",
      "87:         @secondary = false",
      "89:         server = TCPServer.new 0",
      "90:         @host = Socket.gethostname",
      "91:         @port = server.addr[1]",
      "92:         server.close",
      "93:       end",
      "95:       def ==(other)",
      "96:         @host == other.host && @port == other.port",
      "97:       end",
      "99:       def address",
      "100:         \"#{@host}:#{@port}\"",
      "101:       end",
      "103:       def primary?",
      "104:         @primary",
      "105:       end",
      "107:       def secondary?",
      "108:         @secondary",
      "109:       end",
      "111:       def status",
      "112:         {",
      "113:           \"ismaster\" => @primary,",
      "114:           \"secondary\" => @secondary,",
      "115:           \"hosts\" => @set.nodes.map(&:address),",
      "116:           \"me\" => address,",
      "117:           \"maxBsonObjectSize\" => 16777216,",
      "118:           \"ok\" => 1.0",
      "119:         }",
      "120:       end",
      "122:       def status_reply",
      "123:         reply = Moped::Protocol::Reply.new",
      "124:         reply.count = 1",
      "125:         reply.documents = [status]",
      "126:         reply",
      "127:       end",
      "129:       OP_QUERY = 2004",
      "130:       OP_GETMORE = 2005",
      "132:       # Stop and start the node.",
      "133:       def restart",
      "134:         stop",
      "135:         start",
      "136:       end",
      "138:       # Start the node.",
      "139:       def start",
      "140:         @server = TCPServer.new @port",
      "141:       end",
      "143:       # Stop the node.",
      "144:       def stop",
      "145:         if @server",
      "146:           hiccup",
      "148:           @server.close",
      "149:           @server = nil",
      "150:         end",
      "151:       end",
      "152:       alias close stop",
      "154:       def accept",
      "155:         to_io.accept",
      "156:       end",
      "158:       def closed?",
      "159:         !@server || @server.closed?",
      "160:       end",
      "162:       def to_io",
      "163:         @server",
      "164:       end",
      "166:       # Mark this node as secondary.",
      "167:       def demote",
      "168:         @primary = false",
      "169:         @secondary = true",
      "171:         hiccup",
      "172:       end",
      "174:       def hiccup",
      "175:         @set.manager.close_clients_for(self)",
      "176:       end",
      "178:       # Mark this node as primary. This also closes any open connections.",
      "179:       def promote",
      "180:         @primary = true",
      "181:         @secondary = false",
      "183:         hiccup",
      "184:       end",
      "186:       # Proxies a single message from client to the mongo connection.",
      "187:       def proxy(client, mongo)",
      "188:         incoming_message = client.read(16)",
      "189:         length, op_code = incoming_message.unpack(\"l<x8l<\")",
      "190:         incoming_message << client.read(length - 16)",
      "192:         if op_code == OP_QUERY && ismaster_command?(incoming_message)",
      "193:           # Intercept the ismaster command and send our own reply.",
      "194:           client.write status_reply",
      "195:         else",
      "196:           # This is a normal command, so proxy it to the real mongo instance.",
      "197:           mongo.write incoming_message",
      "199:           if op_code == OP_QUERY || op_code == OP_GETMORE",
      "200:             outgoing_message = mongo.read(4)",
      "201:             length, = outgoing_message.unpack('l<')",
      "202:             outgoing_message << mongo.read(length - 4)",
      "204:             client.write outgoing_message",
      "205:           end",
      "206:         end",
      "207:       end",
      "209:       private",
      "211:       # Checks a message to see if it's an `ismaster` query.",
      "212:       def ismaster_command?(incoming_message)",
      "213:         data = StringIO.new(incoming_message)",
      "214:         data.read(20) # header and flags",
      "215:         data.gets(\"\\x00\") # collection name",
      "216:         data.read(8) # skip/limit",
      "218:         selector = Moped::BSON::Document.deserialize(data)",
      "219:         selector == { \"ismaster\" => 1 }",
      "220:       end",
      "221:     end",
      "223:     class ConnectionManager",
      "225:       def initialize(servers)",
      "226:         @timeout = 0.1",
      "227:         @servers = servers",
      "228:         @clients = []",
      "229:       end",
      "231:       def shutdown",
      "232:         @servers.each &:close",
      "233:         @clients.each &:close",
      "234:         @shutdown = true",
      "235:       end",
      "237:       def next_client",
      "238:         throw :shutdown if @shutdown",
      "240:         begin",
      "241:           servers = @servers.reject &:closed?",
      "242:           clients =  @clients.reject &:closed?",
      "243:           Moped.logger.debug \"replica_set: selecting on connections\"",
      "244:           readable, _, errors = Kernel.select(servers + clients, nil, clients, @timeout)",
      "245:         rescue IOError, Errno::EBADF, TypeError",
      "246:           # Looks like we hit a bad file descriptor or closed connection.",
      "247:           Moped.logger.debug \"replica_set: io error, retrying\"",
      "248:           retry",
      "249:         end",
      "251:         return unless readable || errors",
      "253:         errors.each do |client|",
      "254:           client.close",
      "255:           @clients.delete client",
      "256:         end",
      "258:         clients, servers = readable.partition { |s| s.class == TCPSocket }",
      "260:         servers.each do |server|",
      "261:           Moped.logger.debug \"replica_set: accepting new client for #{server.port}\"",
      "262:           @clients << server.accept",
      "263:         end",
      "265:         Moped.logger.debug \"replica_set: closing dead clients\"",
      "266:         closed, open = clients.partition &:eof?",
      "267:         closed.each { |client| @clients.delete client }",
      "269:         if client = open.shift",
      "270:           Moped.logger.debug \"replica_set: finding server for client\"",
      "271:           server = lookup_server(client)",
      "273:           Moped.logger.debug \"replica_set: sending client #{client.inspect} to #{server.port}\"",
      "274:           return server, client",
      "275:         else",
      "276:           nil",
      "277:         end",
      "278:       end",
      "280:       def close_clients_for(server)",
      "281:         Moped.logger.debug \"replica_set: closing open clients on #{server.port}\"",
      "283:         @clients.reject! do |client|",
      "284:           port = client.addr(false)[1]",
      "286:           if port == server.port",
      "287:             client.close",
      "288:             true",
      "289:           else",
      "290:             false",
      "291:           end",
      "292:         end",
      "293:       end",
      "295:       def lookup_server(client)",
      "296:         port = client.addr(false)[1]",
      "298:         @servers.find do |server|",
      "299:           server.to_io && server.to_io.addr[1] == port",
      "300:         end",
      "301:       end",
      "303:     end",
      "305:   end",
      "306: end",
      "",
      "---------------"
    ],
    "spec/support/stats.rb||spec/support/stats.rb": [
      "File: spec/support/stats.rb -> spec/support/stats.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: module Support",
      "3:   # Module for recording operations.",
      "4:   #",
      "5:   #   Support::Stats.install!",
      "6:   #",
      "7:   #   stats = Support::Stats.collect do",
      "8:   #     session.with(safe: true)[:users].insert({})",
      "9:   #   end",
      "10:   #",
      "11:   #   ops = stats[\"127.0.0.1:27017\"]",
      "12:   #   ops.size # => 2",
      "13:   #   ops[0].class # => Moped::Protocol::Insert",
      "14:   #   ops[1].class # => Moped::Protocol::Command",
      "15:   #",
      "16:   module Stats",
      "17:     extend self",
      "19:     def record(node, operations)",
      "20:       key = if node.primary?",
      "21:         :primary",
      "22:       elsif node.secondary?",
      "23:         :secondary",
      "24:       else",
      "25:         :other",
      "26:       end",
      "28:       @stats[key].concat(operations) if @stats",
      "29:     end",
      "31:     def collect",
      "32:       @stats = Hash.new { |hash, key| hash[key] = [] }",
      "33:       yield",
      "34:       @stats",
      "35:     ensure",
      "36:       @stats = nil",
      "37:     end",
      "39:     def install!",
      "40:       Moped::Node.class_eval <<-EOS",
      "41:         alias _logging logging",
      "43:         def logging(operations, &block)",
      "44:           Support::Stats.record(self, operations)",
      "45:           _logging(operations, &block)",
      "46:         end",
      "47:       EOS",
      "48:     end",
      "50:   end",
      "51: end",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cd51e0c1f311327b85fbd592256cb13da2a1963c",
      "candidate_info": {
        "commit_hash": "cd51e0c1f311327b85fbd592256cb13da2a1963c",
        "repo": "mongoid/moped",
        "commit_url": "https://github.com/mongoid/moped/commit/cd51e0c1f311327b85fbd592256cb13da2a1963c",
        "files": [
          "lib/moped/node.rb"
        ],
        "message": "moped is not as fast as it says",
        "before_after_code_files": [
          "lib/moped/node.rb||lib/moped/node.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ],
          "candidate": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/moped/node.rb||lib/moped/node.rb": [
          "File: lib/moped/node.rb -> lib/moped/node.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "531:       instrument_start = (logger = Moped.logger) && logger.debug? && Time.new",
          "532:       yield",
          "533:     ensure",
          "535:     end",
          "538:       prefix  = \"  MOPED: #{resolved_address} \"",
          "539:       indent  = \" \"*prefix.length",
          "542:       if ops.length == 1",
          "543:         logger.debug prefix + ops.first.log_inspect + runtime",
          "",
          "[Removed Lines]",
          "534:       log_operations(logger, operations, Time.new - instrument_start) if instrument_start",
          "537:     def log_operations(logger, ops, duration)",
          "540:       runtime = (\" (%.4fms)\" % duration)",
          "",
          "[Added Lines]",
          "534:       log_operations(logger, operations, 1000 * (Time.new.to_f - instrument_start.to_f)) if instrument_start",
          "537:     def log_operations(logger, ops, duration_ms)",
          "540:       runtime = (\" (%.4fms)\" % duration_ms)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7de7c508f1c95b48c13a4e6dcc26828cabd8d115",
      "candidate_info": {
        "commit_hash": "7de7c508f1c95b48c13a4e6dcc26828cabd8d115",
        "repo": "mongoid/moped",
        "commit_url": "https://github.com/mongoid/moped/commit/7de7c508f1c95b48c13a4e6dcc26828cabd8d115",
        "files": [
          "CHANGELOG.md",
          "lib/moped/bson/object_id.rb",
          "spec/moped/bson/object_id_spec.rb"
        ],
        "message": "legal checks on object ids support other object ids. [ fix #87 ]",
        "before_after_code_files": [
          "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb",
          "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb",
            "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb"
          ],
          "candidate": [
            "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb",
            "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/moped/bson/object_id.rb||lib/moped/bson/object_id.rb": [
          "File: lib/moped/bson/object_id.rb -> lib/moped/bson/object_id.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:         end",
          "19:         def legal?(str)",
          "21:         end",
          "23:         def from_data(data)",
          "",
          "[Removed Lines]",
          "20:           /\\A\\h{24}\\Z/ === str",
          "",
          "[Added Lines]",
          "20:           /\\A\\h{24}\\Z/ === str.to_s",
          "",
          "---------------"
        ],
        "spec/moped/bson/object_id_spec.rb||spec/moped/bson/object_id_spec.rb": [
          "File: spec/moped/bson/object_id_spec.rb -> spec/moped/bson/object_id_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:   end",
          "28:   describe \"unmarshalling\" do",
          "29:     let(:marshal_data) do",
          "31:     end",
          "33:     it \"does not attempt to repair the id\" do",
          "",
          "[Removed Lines]",
          "30:       Marshal.dump(Moped::BSON::ObjectId.from_data(bytes))",
          "",
          "[Added Lines]",
          "31:       Marshal.dump(described_class.from_data(bytes))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:     context \"when the string is valid\" do",
          "68:       it \"initializes with the string's bytes\" do",
          "71:       end",
          "72:     end",
          "",
          "[Removed Lines]",
          "69:         Moped::BSON::ObjectId.should_receive(:from_data).with(bytes)",
          "70:         Moped::BSON::ObjectId.from_string \"4e4d66343b39b68407000001\"",
          "",
          "[Added Lines]",
          "70:         described_class.should_receive(:from_data).with(bytes)",
          "71:         described_class.from_string \"4e4d66343b39b68407000001\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:       it \"raises an error\" do",
          "77:         expect {",
          "79:         }.to raise_error(Moped::Errors::InvalidObjectId)",
          "80:       end",
          "81:     end",
          "",
          "[Removed Lines]",
          "78:           Moped::BSON::ObjectId.from_string(\"asadsf\")",
          "",
          "[Added Lines]",
          "79:           described_class.from_string(\"asadsf\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "86:     context \"when the string is too short to be an object id\" do",
          "87:       it \"returns false\" do",
          "89:       end",
          "90:     end",
          "92:     context \"when the string contains invalid hex characters\" do",
          "93:       it \"returns false\" do",
          "95:       end",
          "96:     end",
          "98:     context \"when the string is a valid object id\" do",
          "99:       it \"returns true\" do",
          "101:       end",
          "102:     end",
          "104:   end",
          "106:   describe \".from_time\" do",
          "107:     it \"sets the generation time\" do",
          "108:       time = Time.at((Time.now.utc - 64800).to_i).utc",
          "110:     end",
          "112:     it \"does not include process or sequence information\" do",
          "114:       id.to_s.should =~ /\\A\\h{8}0{16}\\Z/",
          "115:     end",
          "116:   end",
          "",
          "[Removed Lines]",
          "88:         Moped::BSON::ObjectId.legal?(\"a\" * 23).should be_false",
          "94:         Moped::BSON::ObjectId.legal?(\"y\" + \"a\" * 23).should be_false",
          "100:         Moped::BSON::ObjectId.legal?(\"a\" * 24).should be_true",
          "109:       Moped::BSON::ObjectId.from_time(time).generation_time.should == time",
          "113:       id = Moped::BSON::ObjectId.from_time(Time.now)",
          "",
          "[Added Lines]",
          "89:         described_class.legal?(\"a\" * 23).should be_false",
          "95:         described_class.legal?(\"y\" + \"a\" * 23).should be_false",
          "101:         described_class.legal?(\"a\" * 24).should be_true",
          "105:     context \"when checking against another object id\" do",
          "107:       let(:object_id) do",
          "108:         described_class.new",
          "109:       end",
          "111:       it \"returns true\" do",
          "112:         described_class.legal?(object_id).should be_true",
          "113:       end",
          "114:     end",
          "120:       described_class.from_time(time).generation_time.should == time",
          "124:       id = described_class.from_time(Time.now)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "118:   describe \"#initialize\" do",
          "119:     context \"with no data\" do",
          "120:       it \"increments the id on each call\" do",
          "122:       end",
          "124:       it \"increments the id safely across threads\" do",
          "126:         ids[0].value.should_not eq ids[1].value",
          "127:       end",
          "128:     end",
          "",
          "[Removed Lines]",
          "121:         Moped::BSON::ObjectId.new.should_not eq Moped::BSON::ObjectId.new",
          "125:         ids = 2.times.map { Thread.new { Moped::BSON::ObjectId.new } }",
          "",
          "[Added Lines]",
          "132:         described_class.new.should_not eq described_class.new",
          "136:         ids = 2.times.map { Thread.new { described_class.new } }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "133:     context \"when data is identical\" do",
          "134:       it \"returns true\" do",
          "136:       end",
          "137:     end",
          "139:     context \"when other is not an object id\" do",
          "140:       it \"returns false\" do",
          "142:       end",
          "143:     end",
          "",
          "[Removed Lines]",
          "135:         Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes)",
          "141:         Moped::BSON::ObjectId.new.should_not == nil",
          "",
          "[Added Lines]",
          "146:         described_class.from_data(bytes).should == described_class.from_data(bytes)",
          "152:         described_class.new.should_not == nil",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "149:     context \"when data is identical\" do",
          "150:       it \"returns true\" do",
          "152:       end",
          "153:     end",
          "155:     context \"when other is not an object id\" do",
          "156:       it \"returns false\" do",
          "158:       end",
          "159:     end",
          "",
          "[Removed Lines]",
          "151:         Moped::BSON::ObjectId.from_data(bytes).should eql Moped::BSON::ObjectId.from_data(bytes)",
          "157:         Moped::BSON::ObjectId.new.should_not eql nil",
          "",
          "[Added Lines]",
          "162:         described_class.from_data(bytes).should eql described_class.from_data(bytes)",
          "168:         described_class.new.should_not eql nil",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "165:     context \"when data is identical\" do",
          "166:       it \"returns the same hash\" do",
          "168:       end",
          "169:     end",
          "171:     context \"when other is not an object id\" do",
          "172:       it \"returns a different hash\" do",
          "174:       end",
          "175:     end",
          "",
          "[Removed Lines]",
          "167:         Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash",
          "173:         Moped::BSON::ObjectId.new.hash.should_not eql Moped::BSON::ObjectId.new.hash",
          "",
          "[Added Lines]",
          "178:         described_class.from_data(bytes).hash.should eq described_class.from_data(bytes).hash",
          "184:         described_class.new.hash.should_not eql described_class.new.hash",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "179:   describe \"#to_s\" do",
          "181:     it \"returns a hex string representation of the id\" do",
          "183:     end",
          "185:   end",
          "",
          "[Removed Lines]",
          "182:       Moped::BSON::ObjectId.from_data(bytes).to_s.should eq \"4e4d66343b39b68407000001\"",
          "",
          "[Added Lines]",
          "193:       described_class.from_data(bytes).to_s.should eq \"4e4d66343b39b68407000001\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "187:   describe \"#inspect\" do",
          "189:     it \"returns a sane representation of the id\" do",
          "191:     end",
          "193:   end",
          "",
          "[Removed Lines]",
          "190:       Moped::BSON::ObjectId.from_data(bytes).inspect.should eq '\"4e4d66343b39b68407000001\"'",
          "",
          "[Added Lines]",
          "201:       described_class.from_data(bytes).inspect.should eq '\"4e4d66343b39b68407000001\"'",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "195:   describe \"#to_json\" do",
          "197:     it \"returns a json representation of the id\" do",
          "199:     end",
          "201:   end",
          "203:   describe \"#repair!\" do",
          "206:     context \"when the data is a 12-element array\" do",
          "207:       it \"sets the id's data to the byte string\" do",
          "",
          "[Removed Lines]",
          "198:       Moped::BSON::ObjectId.from_data(bytes).to_json.should eq('{\"$oid\": \"4e4d66343b39b68407000001\"}')",
          "204:     let(:id) { Moped::BSON::ObjectId.allocate }",
          "",
          "[Added Lines]",
          "209:       described_class.from_data(bytes).to_json.should eq('{\"$oid\": \"4e4d66343b39b68407000001\"}')",
          "215:     let(:id) { described_class.allocate }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b41a98482cd3e3107827e95291fb0b7b7c6eb802",
      "candidate_info": {
        "commit_hash": "b41a98482cd3e3107827e95291fb0b7b7c6eb802",
        "repo": "mongoid/moped",
        "commit_url": "https://github.com/mongoid/moped/commit/b41a98482cd3e3107827e95291fb0b7b7c6eb802",
        "files": [
          "lib/moped/node.rb"
        ],
        "message": "Cleanup node",
        "before_after_code_files": [
          "lib/moped/node.rb||lib/moped/node.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ],
          "candidate": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/moped/node.rb||lib/moped/node.rb": [
          "File: lib/moped/node.rb -> lib/moped/node.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "69:     #",
          "70:     # @since 1.0.0",
          "71:     def command(database, cmd, options = {})",
          "74:     end",
          "76:     # Connect the node on the underlying connection.",
          "",
          "[Removed Lines]",
          "72:       operation = Protocol::Command.new(database, cmd, options)",
          "73:       Operation::Read.new(operation).execute(self)",
          "",
          "[Added Lines]",
          "72:       read(Protocol::Command.new(database, cmd, options))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:     #",
          "213:     # @since 1.0.0",
          "214:     def get_more(database, collection, cursor_id, limit)",
          "217:     end",
          "219:     # Get the hash identifier for the node.",
          "",
          "[Removed Lines]",
          "215:       operation = Protocol::GetMore.new(database, collection, cursor_id, limit)",
          "216:       Operation::Read.new(operation).execute(self)",
          "",
          "[Added Lines]",
          "214:       read(Protocol::GetMore.new(database, collection, cursor_id, limit))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "262:     #",
          "263:     # @since 1.0.0",
          "264:     def insert(database, collection, documents, concern, options = {})",
          "267:     end",
          "269:     # Kill all provided cursors on the node.",
          "",
          "[Removed Lines]",
          "265:       operation = Protocol::Insert.new(database, collection, documents, options)",
          "266:       Operation::Write.new(operation, concern).execute(self)",
          "",
          "[Added Lines]",
          "263:       write(Protocol::Insert.new(database, collection, documents, options), concern)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:     #",
          "402:     # @since 1.0.0",
          "403:     def query(database, collection, selector, options = {})",
          "406:     end",
          "408:     # Refresh information about the node, such as it's status in the replica",
          "",
          "[Removed Lines]",
          "404:       operation = Protocol::Query.new(database, collection, selector, options)",
          "405:       Operation::Read.new(operation).execute(self)",
          "",
          "[Added Lines]",
          "401:       read(Protocol::Query.new(database, collection, selector, options))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "451:     #",
          "452:     # @since 1.0.0",
          "453:     def remove(database, collection, selector, concern, options = {})",
          "456:     end",
          "458:     # Is the node a replica set secondary?",
          "",
          "[Removed Lines]",
          "454:       operation = Protocol::Delete.new(database, collection, selector, options)",
          "455:       Operation::Write.new(operation, concern).execute(self)",
          "",
          "[Added Lines]",
          "450:       write(Protocol::Delete.new(database, collection, selector, options), concern)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "494:     #",
          "495:     # @since 1.0.0",
          "496:     def update(database, collection, selector, change, concern, options = {})",
          "499:     end",
          "501:     # Get the node as a nice formatted string.",
          "",
          "[Removed Lines]",
          "497:       operation = Protocol::Update.new(database, collection, selector, change, options)",
          "498:       Operation::Write.new(operation, concern).execute(self)",
          "",
          "[Added Lines]",
          "492:       write(Protocol::Update.new(database, collection, selector, change, options), concern)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "561:       end",
          "562:     end",
          "564:     def queue",
          "565:       Threaded.stack(:pipelined_operations)",
          "566:     end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "558:     def read(operation)",
          "559:       Operation::Read.new(operation).execute(self)",
          "560:     end",
          "562:     def write(operation, concern)",
          "563:       Operation::Write.new(operation, concern).execute(self)",
          "564:     end",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a14f23906614fd59e4d3894f8f2f2ff79d1372a",
      "candidate_info": {
        "commit_hash": "5a14f23906614fd59e4d3894f8f2f2ff79d1372a",
        "repo": "mongoid/moped",
        "commit_url": "https://github.com/mongoid/moped/commit/5a14f23906614fd59e4d3894f8f2f2ff79d1372a",
        "files": [
          "lib/moped/node.rb",
          "spec/moped/node_spec.rb"
        ],
        "message": "Make appropriate methods in node public",
        "before_after_code_files": [
          "lib/moped/node.rb||lib/moped/node.rb",
          "spec/moped/node_spec.rb||spec/moped/node_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/moped/node.rb||lib/moped/node.rb",
            "spec/moped/node_spec.rb||spec/moped/node_spec.rb"
          ],
          "candidate": [
            "lib/moped/node.rb||lib/moped/node.rb",
            "spec/moped/node_spec.rb||spec/moped/node_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/moped/node.rb||lib/moped/node.rb": [
          "File: lib/moped/node.rb -> lib/moped/node.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:     # @attribute [r] address The address of the node.",
          "16:     # @attribute [r] down_at The time the server node went down.",
          "17:     # @attribute [r] ip_address The node's ip.",
          "19:     # @attribute [r] port The connection port.",
          "20:     # @attribute [r] resolved_address The host/port pair.",
          "21:     # @attribute [r] timeout The connection timeout.",
          "22:     # @attribute [r] options Additional options for the node (ssl).",
          "25:     # Is this node equal to another?",
          "26:     #",
          "",
          "[Removed Lines]",
          "18:     # @attribute [r] peers Other peers in the replica set.",
          "23:     attr_reader :address, :down_at, :ip_address, :peers, :port, :resolved_address, :timeout, :options",
          "",
          "[Added Lines]",
          "22:     attr_reader :address, :down_at, :ip_address, :port, :resolved_address, :timeout, :options",
          "24:     # forward instrument in this class to @instrumenter.",
          "25:     def_delegator :@instrumenter, :instrument",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:       Operation::Read.new(operation).execute(self)",
          "102:     end",
          "104:     # Force the node to disconnect from the server.",
          "105:     #",
          "106:     # @example Disconnect the node.",
          "107:     #   node.disconnect",
          "108:     #",
          "110:     #",
          "111:     # @since 1.2.0",
          "112:     def disconnect",
          "113:       auth.clear",
          "114:       connection.disconnect",
          "115:     end",
          "117:     # Is the node down?",
          "",
          "[Removed Lines]",
          "109:     # @return [ nil ] nil.",
          "",
          "[Added Lines]",
          "106:     # Connect the node on the underlying connection.",
          "107:     #",
          "108:     # @example Connect the node.",
          "109:     #   node.connect",
          "110:     #",
          "111:     # @raise [ Errors::ConnectionFailure ] If connection failed.",
          "112:     #",
          "113:     # @return [ true ] If the connection suceeded.",
          "114:     #",
          "115:     # @since 2.0.0",
          "116:     def connect",
          "117:       connection.connect",
          "118:       @down_at = nil",
          "119:       true",
          "120:     end",
          "122:     # Is the node currently connected?",
          "123:     #",
          "124:     # @example Is the node connected?",
          "125:     #   node.connected?",
          "126:     #",
          "127:     # @return [ true, false ] If the node is connected or not.",
          "128:     #",
          "129:     # @since 2.0.0",
          "130:     def connected?",
          "131:       connection.connected?",
          "132:     end",
          "134:     # Get the underlying connection for the node.",
          "135:     #",
          "136:     # @example Get the node's connection.",
          "137:     #   node.connection",
          "138:     #",
          "139:     # @return [ Connection ] The connection.",
          "140:     #",
          "141:     # @since 2.0.0",
          "142:     def connection",
          "143:       @connection ||= Connection.new(ip_address, port, timeout, options)",
          "144:     end",
          "151:     # @return [ true ] If the disconnection succeeded.",
          "157:       true",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "170:     #",
          "171:     # @example Ensure this node is primary.",
          "172:     #   node.ensure_primary do",
          "174:     #   end",
          "175:     #",
          "176:     # @return [ nil ] nil.",
          "",
          "[Removed Lines]",
          "173:     #     #...",
          "",
          "[Added Lines]",
          "216:     #     node.command(ismaster: 1)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "214:       resolved_address.hash",
          "215:     end",
          "221:     # Creat the new node.",
          "222:     #",
          "223:     # @example Create the new node.",
          "",
          "[Removed Lines]",
          "217:     # forward instrument in this class to @instrumenter, for those unfamilier",
          "218:     # with forwardable.",
          "219:     def_delegator :@instrumenter, :instrument",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "295:       !!@passive",
          "296:     end",
          "298:     # Execute a pipeline of commands, for example a safe mode persist.",
          "299:     #",
          "300:     # @example Execute a pipeline.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "337:     # Get all the other nodes in the replica set according to the server",
          "338:     # information.",
          "339:     #",
          "340:     # @example Get the node's peers.",
          "341:     #   node.peers",
          "342:     #",
          "343:     # @return [ Array<Node> ] The peers.",
          "344:     #",
          "345:     # @since 2.0.0",
          "346:     def peers",
          "347:       @peers ||= []",
          "348:     end",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "388:         begin",
          "389:           info = command(\"admin\", ismaster: 1)",
          "390:           @refreshed_at = Time.now",
          "400:             raise Errors::ReplicaSetReconfigured.new(\"#{inspect} is no longer the primary node.\", {})",
          "402:             # not primary or secondary so mark it as down, since it's probably",
          "403:             # a recovering node withing the replica set",
          "404:             down!",
          "405:           end",
          "406:         rescue Timeout::Error",
          "408:           down!",
          "409:         end",
          "410:       end",
          "",
          "[Removed Lines]",
          "391:           primary = true   if info[\"ismaster\"]",
          "392:           secondary = true if info[\"secondary\"]",
          "393:           generate_peers(info)",
          "395:           @primary, @secondary = primary, secondary",
          "396:           @arbiter = info[\"arbiterOnly\"]",
          "397:           @passive = info[\"passive\"]",
          "399:           if !primary && Threaded.executing?(:ensure_primary)",
          "401:           elsif !primary && !secondary",
          "407:           @peers = []",
          "",
          "[Added Lines]",
          "443:           configure(info)",
          "444:           if !primary? && Threaded.executing?(:ensure_primary)",
          "446:           elsif !primary? && !secondary?",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "492:     private",
          "518:     def flush(ops = queue)",
          "519:       operations, callbacks = ops.transpose",
          "",
          "[Removed Lines]",
          "494:     # Connect to the node.",
          "495:     #",
          "496:     # Returns nothing.",
          "497:     # Raises Moped::ConnectionError if the connection times out.",
          "498:     # Raises Moped::ConnectionError if the server is unavailable.",
          "499:     def connect",
          "500:       connection.connect",
          "501:       @down_at = nil",
          "502:     end",
          "504:     def connection",
          "505:       @connection ||= Connection.new(ip_address, port, timeout, options)",
          "506:     end",
          "508:     def connected?",
          "509:       connection.connected?",
          "510:     end",
          "512:     def discover(peer)",
          "513:       Node.new(peer, options).tap do |node|",
          "514:         node.send(:auth).merge!(auth)",
          "515:       end",
          "516:     end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "532:       ops.clear",
          "533:     end",
          "542:     end",
          "544:     def initialize_copy(_)",
          "",
          "[Removed Lines]",
          "535:     def generate_peers(info)",
          "536:       peers = []",
          "537:       peers.push(info[\"primary\"]) if info[\"primary\"]",
          "538:       peers.concat(info[\"hosts\"]) if info[\"hosts\"]",
          "539:       peers.concat(info[\"passives\"]) if info[\"passives\"]",
          "540:       peers.concat(info[\"arbiters\"]) if info[\"arbiters\"]",
          "541:       @peers = peers.map{ |peer| discover(peer) }.uniq",
          "",
          "[Added Lines]",
          "555:     # @todo Move into refresh operation.",
          "556:     def configure(settings)",
          "557:       @arbiter = settings[\"arbiterOnly\"]",
          "558:       @passive = settings[\"passive\"]",
          "559:       @primary = settings[\"ismaster\"]",
          "560:       @secondary = settings[\"secondary\"]",
          "561:       configure_peers(settings)",
          "562:     end",
          "564:     # @todo Move into refresh operation.",
          "565:     def configure_peers(info)",
          "566:       discover(info[\"primary\"])",
          "567:       discover(info[\"hosts\"])",
          "568:       discover(info[\"passives\"])",
          "569:       discover(info[\"arbiters\"])",
          "570:     end",
          "572:     def discover(*nodes)",
          "573:       nodes.flatten.compact.each do |peer|",
          "574:         node = Node.new(peer, options)",
          "575:         if self != node && !peers.include?(node)",
          "576:           node.auth.merge!(auth)",
          "577:           peers.push(node)",
          "578:         end",
          "579:       end",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "551:       end",
          "552:     end",
          "554:     def parse_address",
          "555:       host, port = address.split(\":\")",
          "556:       @port = (port || 27017).to_i",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "592:     def queue",
          "593:       Threaded.stack(:pipelined_operations)",
          "594:     end",
          "596:     # @todo: Move address parsing out of node.",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "558:       @resolved_address = \"#{@ip_address}:#{@port}\"",
          "559:     end",
          "565:     def resolve_address",
          "566:       unless ip_address",
          "567:         begin",
          "",
          "[Removed Lines]",
          "561:     def queue",
          "562:       Threaded.stack(:pipelined_operations)",
          "563:     end",
          "",
          "[Added Lines]",
          "604:     # @todo: Move address parsing out of node.",
          "",
          "---------------"
        ],
        "spec/moped/node_spec.rb||spec/moped/node_spec.rb": [
          "File: spec/moped/node_spec.rb -> spec/moped/node_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:          \"setName\"   => \"moped_dev\",",
          "36:          \"ismaster\"  => true,",
          "37:          \"secondary\" => false,",
          "39:          \"primary\"   => \"127.0.0.1:27017\",",
          "40:          \"me\"        => \"127.0.0.1:27017\",",
          "41:          \"ok\"        => 1.0",
          "",
          "[Removed Lines]",
          "38:          \"hosts\"     => [ \"127.0.0.1:27017\", \"localhost:27017\" ],",
          "",
          "[Added Lines]",
          "38:          \"hosts\"     => [ \"127.0.0.1:27017\", \"localhost:27018\" ],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "45ff0834e396454e39aa288342a5a814a4ca6460",
      "candidate_info": {
        "commit_hash": "45ff0834e396454e39aa288342a5a814a4ca6460",
        "repo": "mongoid/moped",
        "commit_url": "https://github.com/mongoid/moped/commit/45ff0834e396454e39aa288342a5a814a4ca6460",
        "files": [
          "CHANGELOG.md",
          "lib/moped/node.rb",
          "lib/moped/protocol/reply.rb",
          "spec/moped/protocol/reply_spec.rb"
        ],
        "message": "Fix reauthorization on failed commands.\n\nMongo in its glorious inconsistency does not always supply a \"code\" in\nthe error message of 10057 when a query or command is unauthorized, but\nsometimes puts this value in \"assertionCode\" instead. This change now\nchecks for both and handles retries on commands accordingly.\n\n[ fix #109 ]",
        "before_after_code_files": [
          "lib/moped/node.rb||lib/moped/node.rb",
          "lib/moped/protocol/reply.rb||lib/moped/protocol/reply.rb",
          "spec/moped/protocol/reply_spec.rb||spec/moped/protocol/reply_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ],
          "candidate": [
            "lib/moped/node.rb||lib/moped/node.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/moped/node.rb||lib/moped/node.rb": [
          "File: lib/moped/node.rb -> lib/moped/node.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "69:       operation = Protocol::Command.new(database, cmd, options)",
          "71:       process(operation) do |reply|",
          "76:         result",
          "77:       end",
          "78:     end",
          "",
          "[Removed Lines]",
          "72:         result = reply.documents[0]",
          "73:         raise Errors::OperationFailure.new(",
          "74:           operation, result",
          "75:         ) if result[\"ok\"] != 1 || result[\"err\"] || result[\"errmsg\"]",
          "",
          "[Added Lines]",
          "72:         result = reply.documents.first",
          "73:         if reply.command_failure?",
          "74:           if reply.unauthorized? && auth.has_key?(database)",
          "75:             login(database, *auth[database])",
          "76:             command(database, cmd, options)",
          "77:           else",
          "78:             raise Errors::OperationFailure.new(operation, result)",
          "79:           end",
          "80:         end",
          "",
          "---------------"
        ],
        "lib/moped/protocol/reply.rb||lib/moped/protocol/reply.rb": [
          "File: lib/moped/protocol/reply.rb -> lib/moped/protocol/reply.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:       finalize",
          "58:       def cursor_not_found?",
          "59:         flags.include?(:cursor_not_found)",
          "60:       end",
          "62:       def query_failed?",
          "63:         flags.include?(:query_failure)",
          "64:       end",
          "66:       def unauthorized?",
          "68:       end",
          "70:       class << self",
          "",
          "[Removed Lines]",
          "67:         documents.first[\"code\"] == UNAUTHORIZED",
          "",
          "[Added Lines]",
          "58:       # Is the reply the result of a command failure?",
          "59:       #",
          "60:       # @example Did the command fail?",
          "61:       #   reply.command_failure?",
          "62:       #",
          "63:       # @note This is when ok is not 1, or \"err\" or \"errmsg\" are present.",
          "64:       #",
          "65:       # @return [ true, false ] If the command failed.",
          "66:       #",
          "67:       # @since 1.2.10",
          "68:       def command_failure?",
          "69:         result = documents[0]",
          "70:         result[\"ok\"] != 1 || result[\"err\"] || result[\"errmsg\"]",
          "71:       end",
          "73:       # Was the provided cursor id not found on the server?",
          "74:       #",
          "75:       # @example Is the cursor not on the server?",
          "76:       #   reply.cursor_not_found?",
          "77:       #",
          "78:       # @return [ true, false ] If the cursor went missing.",
          "79:       #",
          "80:       # @since 1.2.0",
          "85:       # Did the query fail on the server?",
          "86:       #",
          "87:       # @example Did the query fail?",
          "88:       #   reply.query_failed?",
          "89:       #",
          "90:       # @return [ true, false ] If the query failed.",
          "91:       #",
          "92:       # @since 1.2.0",
          "97:       # Is the reply an error message that we are not authorized for the query",
          "98:       # or command?",
          "99:       #",
          "100:       # @example Was the query unauthorized.",
          "101:       #   reply.unauthorized?",
          "102:       #",
          "103:       # @note So far this can be a \"code\" of 10057 in the error message or an",
          "104:       #   \"assertionCode\" of 10057.",
          "105:       #",
          "106:       # @return [ true, false ] If we had an authorization error.",
          "107:       #",
          "108:       # @since 1.2.10",
          "110:         result = documents[0]",
          "111:         result[\"code\"] == UNAUTHORIZED || result[\"assertionCode\"] == UNAUTHORIZED",
          "",
          "---------------"
        ],
        "spec/moped/protocol/reply_spec.rb||spec/moped/protocol/reply_spec.rb": [
          "File: spec/moped/protocol/reply_spec.rb -> spec/moped/protocol/reply_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     it \"sets the documents\" do",
          "74:       reply.documents.should == [{\"a\" => \"b\"}, {\"a\" => \"b\"}]",
          "75:     end",
          "77:   end",
          "79: end",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:   end",
          "78:   describe \"#command_failed?\" do",
          "80:     context \"when ok is not 1\" do",
          "82:       let(:error) do",
          "83:         { \"ok\" => 0 }",
          "84:       end",
          "86:       let(:reply) do",
          "87:         described_class.new",
          "88:       end",
          "90:       before do",
          "91:         reply.documents = [ error ]",
          "92:       end",
          "94:       it \"returns true\" do",
          "95:         reply.should be_command_failure",
          "96:       end",
          "97:     end",
          "99:     context \"when an err message is present\" do",
          "101:       let(:error) do",
          "102:         { \"err\" => \"message\" }",
          "103:       end",
          "105:       let(:reply) do",
          "106:         described_class.new",
          "107:       end",
          "109:       before do",
          "110:         reply.documents = [ error ]",
          "111:       end",
          "113:       it \"returns true\" do",
          "114:         reply.should be_command_failure",
          "115:       end",
          "116:     end",
          "118:     context \"when an errmsg message is present\" do",
          "120:       let(:error) do",
          "121:         { \"errmsg\" => \"message\" }",
          "122:       end",
          "124:       let(:reply) do",
          "125:         described_class.new",
          "126:       end",
          "128:       before do",
          "129:         reply.documents = [ error ]",
          "130:       end",
          "132:       it \"returns true\" do",
          "133:         reply.should be_command_failure",
          "134:       end",
          "135:     end",
          "137:     context \"when no errors exist\" do",
          "139:       let(:error) do",
          "140:         { \"ok\" => 1 }",
          "141:       end",
          "143:       let(:reply) do",
          "144:         described_class.new",
          "145:       end",
          "147:       before do",
          "148:         reply.documents = [ error ]",
          "149:       end",
          "151:       it \"returns false\" do",
          "152:         reply.should_not be_command_failure",
          "153:       end",
          "154:     end",
          "157:   describe \"#unauthorized?\" do",
          "159:     context \"when the code is unauthorized\" do",
          "161:       let(:error) do",
          "162:         { \"ok\" => 0, \"err\" => \"message\", \"code\" => 10057 }",
          "163:       end",
          "165:       let(:reply) do",
          "166:         described_class.new",
          "167:       end",
          "169:       before do",
          "170:         reply.documents = [ error ]",
          "171:       end",
          "173:       it \"returns true\" do",
          "174:         reply.should be_unauthorized",
          "175:       end",
          "176:     end",
          "178:     context \"when the assertion code is unauthorized\" do",
          "180:       let(:error) do",
          "181:         { \"ok\" => 0, \"err\" => \"message\", \"assertionCode\" => 10057 }",
          "182:       end",
          "184:       let(:reply) do",
          "185:         described_class.new",
          "186:       end",
          "188:       before do",
          "189:         reply.documents = [ error ]",
          "190:       end",
          "192:       it \"returns true\" do",
          "193:         reply.should be_unauthorized",
          "194:       end",
          "195:     end",
          "197:     context \"when no auth errors exist\" do",
          "199:       let(:error) do",
          "200:         { \"ok\" => 1 }",
          "201:       end",
          "203:       let(:reply) do",
          "204:         described_class.new",
          "205:       end",
          "207:       before do",
          "208:         reply.documents = [ error ]",
          "209:       end",
          "211:       it \"returns false\" do",
          "212:         reply.should_not be_unauthorized",
          "213:       end",
          "214:     end",
          "215:   end",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8747",
  "cve_desc": "The multifilesystem storage backend in Radicale before 1.1 allows remote attackers to read or write to arbitrary files via a crafted component name.",
  "repo": "Unrud/Radicale",
  "patch_hash": "bcaf452e516c02c9bed584a73736431c5e8831f1",
  "patch_info": {
    "commit_hash": "bcaf452e516c02c9bed584a73736431c5e8831f1",
    "repo": "Unrud/Radicale",
    "commit_url": "https://github.com/Unrud/Radicale/commit/bcaf452e516c02c9bed584a73736431c5e8831f1",
    "files": [
      "radicale/storage/multifilesystem.py"
    ],
    "message": "Convert component names safely to filenames Component names are controlled by the user and without this checks access to arbitrary files is possible if the multifilesystem backend is used.",
    "before_after_code_files": [
      "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py"
    ]
  },
  "patch_diff": {
    "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py": [
      "File: radicale/storage/multifilesystem.py -> radicale/storage/multifilesystem.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "53:             name = (",
      "54:                 component.name if sys.version_info[0] >= 3 else",
      "55:                 component.name.encode(filesystem.FILESYSTEM_ENCODING))",
      "56:             filesystem_path = os.path.join(self._filesystem_path, name)",
      "57:             with filesystem.open(filesystem_path, \"w\") as fd:",
      "58:                 fd.write(text)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "56:             if not pathutils.is_safe_filesystem_path_component(name):",
      "57:                 log.LOGGER.debug(",
      "58:                     \"Can't tranlate name safely to filesystem, \"",
      "59:                     \"skipping component: %s\", name)",
      "60:                 continue",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62:         os.remove(self._props_path)",
      "64:     def remove(self, name):",
      "65:         filesystem_path = os.path.join(self._filesystem_path, name)",
      "66:         if os.path.exists(filesystem_path):",
      "67:             os.remove(filesystem_path)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "70:         if not pathutils.is_safe_filesystem_path_component(name):",
      "71:             log.LOGGER.debug(",
      "72:                 \"Can't tranlate name safely to filesystem, \"",
      "73:                 \"skipping component: %s\", name)",
      "74:             return",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6b7e79a368be86d266c51cf50915324490a1b728",
      "candidate_info": {
        "commit_hash": "6b7e79a368be86d266c51cf50915324490a1b728",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/6b7e79a368be86d266c51cf50915324490a1b728",
        "files": [
          "radicale/ical.py"
        ],
        "message": "Use sanitize_path instead of normpath See a7b47f075499a1e1b40539bc1fa872a3ab77a204 The check for \".\" is now needless because the sane path is always absolute. ```path.replace(os.sep, \"/\")``` is only relevant for the (multi)filesystem backend and should be there.",
        "before_after_code_files": [
          "radicale/ical.py||radicale/ical.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/ical.py||radicale/ical.py": [
          "File: radicale/ical.py -> radicale/ical.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: \"\"\"",
          "28: import os",
          "30: import hashlib",
          "31: import re",
          "32: from uuid import uuid4",
          "33: from random import randint",
          "34: from contextlib import contextmanager",
          "37: def serialize(tag, headers=(), items=()):",
          "38:     \"\"\"Return a text corresponding to given collection ``tag``.",
          "",
          "[Removed Lines]",
          "29: import posixpath",
          "",
          "[Added Lines]",
          "35: from . import pathutils",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:         \"\"\"",
          "185:         self.encoding = \"utf-8\"",
          "188:         if principal and split_path and self.is_node(self.path):",
          "189:             # Already existing principal collection",
          "190:             self.owner = split_path[0]",
          "",
          "[Removed Lines]",
          "186:         split_path = path.split(\"/\")",
          "187:         self.path = path if path != \".\" else \"\"",
          "",
          "[Added Lines]",
          "187:         # path should already be sanitized",
          "188:         self.path = pathutils.sanitize_path(path).strip(\"/\")",
          "189:         split_path = self.path.split(\"/\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215:         if path is None:",
          "216:             return []",
          "220:         attributes = sane_path.split(\"/\")",
          "221:         if not attributes:",
          "222:             return []",
          "",
          "[Removed Lines]",
          "218:         # First do normpath and then strip, to prevent access to FOLDER/../",
          "219:         sane_path = posixpath.normpath(path.replace(os.sep, \"/\")).strip(\"/\")",
          "",
          "[Added Lines]",
          "220:         # path should already be sanitized",
          "221:         sane_path = pathutils.sanitize_path(path).strip(\"/\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed44830447224d13fb2d2639cf1297e41ec5c511",
      "candidate_info": {
        "commit_hash": "ed44830447224d13fb2d2639cf1297e41ec5c511",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/ed44830447224d13fb2d2639cf1297e41ec5c511",
        "files": [
          "radicale/__init__.py"
        ],
        "message": "Error message if path not starting with prefix Before the program crashed implicitly",
        "before_after_code_files": [
          "radicale/__init__.py||radicale/__init__.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/__init__.py||radicale/__init__.py": [
          "File: radicale/__init__.py -> radicale/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:             # Request path not starting with base_prefix, not allowed",
          "266:             log.LOGGER.debug(",
          "267:                 \"Path not starting with prefix: %s\", environ[\"PATH_INFO\"])",
          "270:         # Sanitize request URI",
          "271:         environ[\"PATH_INFO\"] = self.sanitize_uri(environ[\"PATH_INFO\"])",
          "",
          "[Removed Lines]",
          "268:             environ[\"PATH_INFO\"] = None",
          "",
          "[Added Lines]",
          "268:             status, headers, _ = NOT_ALLOWED",
          "269:             start_response(status, list(headers.items()))",
          "270:             return []",
          "",
          "---------------"
        ]
      }
    }
  ]
}
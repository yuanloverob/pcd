{
  "cve_id": "CVE-2021-32840",
  "cve_desc": "SharpZipLib (or #ziplib) is a Zip, GZip, Tar and BZip2 library. Prior to version 1.3.3, a TAR file entry `../evil.txt` may be extracted in the parent directory of `destFolder`. This leads to arbitrary file write that may lead to code execution. The vulnerability was patched in version 1.3.3.",
  "repo": "icsharpcode/SharpZipLib",
  "patch_hash": "a0e96de70b5264f4c919b09253b1522bc7a221cc",
  "patch_info": {
    "commit_hash": "a0e96de70b5264f4c919b09253b1522bc7a221cc",
    "repo": "icsharpcode/SharpZipLib",
    "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/a0e96de70b5264f4c919b09253b1522bc7a221cc",
    "files": [
      "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
      "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
    ],
    "message": "test: add tests for tar path traversal",
    "before_after_code_files": [
      "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
      "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
    ]
  },
  "patch_diff": {
    "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj": [
      "File: test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj -> test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
      "--- Hunk 1 ---",
      "[Context before]",
      "5:   <TargetFrameworks>netcoreapp3.1;net46</TargetFrameworks>",
      "6:     <ApplicationIcon />",
      "7:     <StartupObject />",
      "8:   </PropertyGroup>",
      "10:   <ItemGroup>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8:   <LangVersion>8</LangVersion>",
      "",
      "---------------"
    ],
    "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs": [
      "File: test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: \ufeffusing System.IO;",
      "2: using System.Text;",
      "3: using ICSharpCode.SharpZipLib.Core;",
      "4: using ICSharpCode.SharpZipLib.Tar;",
      "5: using static ICSharpCode.SharpZipLib.Tests.TestSupport.Utils;",
      "6: using NUnit.Framework;",
      "8: namespace ICSharpCode.SharpZipLib.Tests.Tar",
      "9: {",
      "10:  [TestFixture]",
      "11:  public class TarArchiveTests",
      "12:  {",
      "13:   [Test]",
      "14:   [Category(\"Tar\")]",
      "15:   [Category(\"CreatesTempFile\")]",
      "16:   public void ExtractingContentsWithNonTraversalPathSucceeds()",
      "17:   {",
      "18:    Assert.DoesNotThrow(() => ExtractTarOK(\"output\", \"test-good\", allowTraverse: false));",
      "19:   }",
      "21:   [Test]",
      "22:   [Category(\"Tar\")]",
      "23:   [Category(\"CreatesTempFile\")]",
      "24:   public void ExtractingContentsWithExplicitlyAllowedTraversalPathSucceeds()",
      "25:   {",
      "26:    Assert.DoesNotThrow(() => ExtractTarOK(\"output\", \"../file\", allowTraverse: true));",
      "27:   }",
      "29:   [Test]",
      "30:   [Category(\"Tar\")]",
      "31:   [Category(\"CreatesTempFile\")]",
      "32:   [TestCase(\"output\", \"../file\")]",
      "33:   [TestCase(\"output\", \"../output.txt\")]",
      "34:   public void ExtractingContentsWithDisallowedPathsFails(string outputDir, string fileName)",
      "35:   {",
      "36:    Assert.Throws<InvalidNameException>(() => ExtractTarOK(outputDir, fileName, allowTraverse: false));",
      "37:   }",
      "39:   public void ExtractTarOK(string outputDir, string fileName, bool allowTraverse)",
      "40:   {",
      "41:    var fileContent = Encoding.UTF8.GetBytes(\"file content\");",
      "42:    using var tempDir = new TempDir();",
      "44:    var tempPath = tempDir.Fullpath;",
      "45:    var extractPath = Path.Combine(tempPath, outputDir);",
      "46:    var expectedOutputFile = Path.Combine(extractPath, fileName);",
      "48:    using var archiveStream = new MemoryStream();",
      "50:    Directory.CreateDirectory(extractPath);",
      "52:    using (var tos = new TarOutputStream(archiveStream, Encoding.UTF8){IsStreamOwner = false})",
      "53:    {",
      "54:     var entry = TarEntry.CreateTarEntry(fileName);",
      "55:     entry.Size = fileContent.Length;",
      "56:     tos.PutNextEntry(entry);",
      "57:     tos.Write(fileContent, 0, fileContent.Length);",
      "58:     tos.CloseEntry();",
      "59:    }",
      "61:    archiveStream.Position = 0;",
      "63:    using (var ta = TarArchive.CreateInputTarArchive(archiveStream, Encoding.UTF8))",
      "64:    {",
      "65:     ta.ProgressMessageEvent += (archive, entry, message)",
      "66:      => TestContext.WriteLine($\"{entry.Name} {entry.Size} {message}\");",
      "67:     ta.ExtractContents(extractPath, allowTraverse);",
      "68:    }",
      "70:    Assert.That(File.Exists(expectedOutputFile));",
      "71:   }",
      "72:  }",
      "73: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5c3b293de5d65b108e7f2cd0ea8f81c1b8273f78",
      "candidate_info": {
        "commit_hash": "5c3b293de5d65b108e7f2cd0ea8f81c1b8273f78",
        "repo": "icsharpcode/SharpZipLib",
        "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/5c3b293de5d65b108e7f2cd0ea8f81c1b8273f78",
        "files": [
          "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs"
        ],
        "message": "fix: specialized tar extract traversal",
        "before_after_code_files": [
          "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs||src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/icsharpcode/SharpZipLib/pull/664"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs||src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs": [
          "File: src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs -> src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "658:    name = name.Replace('/', Path.DirectorySeparatorChar);",
          "660:    string destFile = Path.Combine(destDir, name);",
          "663:    {",
          "664:     throw new InvalidNameException(\"Parent traversal in paths is not allowed\");",
          "665:    }",
          "",
          "[Removed Lines]",
          "662:    if (!allowParentTraversal && !Path.GetFullPath(destFile).StartsWith(destDir, StringComparison.InvariantCultureIgnoreCase))",
          "",
          "[Added Lines]",
          "661:    var destFileDir = Path.GetDirectoryName(Path.GetFullPath(destFile)) ?? \"\";",
          "663:    if (!allowParentTraversal && !destFileDir.StartsWith(destDir, StringComparison.InvariantCultureIgnoreCase))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "641f292ae8820b9eb56876f0eed5b4c05473f237",
      "candidate_info": {
        "commit_hash": "641f292ae8820b9eb56876f0eed5b4c05473f237",
        "repo": "icsharpcode/SharpZipLib",
        "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/641f292ae8820b9eb56876f0eed5b4c05473f237",
        "files": [
          "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj"
        ],
        "message": "update csproj for v1.3.3 release",
        "before_after_code_files": [
          "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj||src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/icsharpcode/SharpZipLib/pull/664"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj||src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj": [
          "File: src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj -> src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:   <!-- Nuget specific tags -->",
          "13:   <PropertyGroup>",
          "17:     <PackageId>SharpZipLib</PackageId>",
          "18:     <Company>ICSharpCode</Company>",
          "19:     <Authors>ICSharpCode</Authors>",
          "",
          "[Removed Lines]",
          "14:     <AssemblyVersion>1.3.2.10</AssemblyVersion>",
          "15:     <FileVersion>1.3.2.10</FileVersion>",
          "16:     <Version>1.3.2</Version>",
          "",
          "[Added Lines]",
          "14:     <Version>1.3.3</Version>",
          "15:     <FileVersion>$(Version).11</FileVersion>",
          "16:     <AssemblyVersion>$(FileVersion)</AssemblyVersion>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:     <PackageTags>Compression Library Zip GZip BZip2 LZW Tar</PackageTags>",
          "27:     <NeutralLanguage>en-US</NeutralLanguage>",
          "28:     <PackageReleaseNotes>",
          "30:     <PackageProjectUrl>https://github.com/icsharpcode/SharpZipLib</PackageProjectUrl>",
          "31:   </PropertyGroup>",
          "",
          "[Removed Lines]",
          "29: Please see https://github.com/icsharpcode/SharpZipLib/wiki/Release-1.3.2 for more information.</PackageReleaseNotes>",
          "",
          "[Added Lines]",
          "29: Please see https://github.com/icsharpcode/SharpZipLib/wiki/Release-1.3.3 for more information.</PackageReleaseNotes>",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d31fac3dc924d22733b42df3868064cb88735611",
      "candidate_info": {
        "commit_hash": "d31fac3dc924d22733b42df3868064cb88735611",
        "repo": "icsharpcode/SharpZipLib",
        "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/d31fac3dc924d22733b42df3868064cb88735611",
        "files": [
          "test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs"
        ],
        "message": "test: repeatability and refactoring (#671)",
        "before_after_code_files": [
          "test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs||test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs||test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs||test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
          ],
          "candidate": [
            "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
          ]
        }
      },
      "candidate_diff": {
        "test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs||test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs -> test/ICSharpCode.SharpZipLib.Tests/BZip2/Bzip2Tests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: using ICSharpCode.SharpZipLib.BZip2;",
          "2: using ICSharpCode.SharpZipLib.Tests.TestSupport;",
          "3: using NUnit.Framework;",
          "5: using System.IO;",
          "7: namespace ICSharpCode.SharpZipLib.Tests.BZip2",
          "",
          "[Removed Lines]",
          "4: using System;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24:   {",
          "25:    var ms = new MemoryStream();",
          "26:    var outStream = new BZip2OutputStream(ms);",
          "33:    outStream.Close();",
          "34:    ms = new MemoryStream(ms.GetBuffer());",
          "38:    {",
          "42:     {",
          "49:     }",
          "55:    }",
          "56:   }",
          "",
          "[Removed Lines]",
          "28:    byte[] buf = new byte[10000];",
          "29:    var rnd = new Random(RandomSeed);",
          "30:    rnd.NextBytes(buf);",
          "32:    outStream.Write(buf, 0, buf.Length);",
          "35:    ms.Seek(0, SeekOrigin.Begin);",
          "37:    using (BZip2InputStream inStream = new BZip2InputStream(ms))",
          "39:     byte[] buf2 = new byte[buf.Length];",
          "40:     int pos = 0;",
          "41:     while (true)",
          "43:      int numRead = inStream.Read(buf2, pos, 4096);",
          "44:      if (numRead <= 0)",
          "45:      {",
          "46:       break;",
          "47:      }",
          "48:      pos += numRead;",
          "51:     for (int i = 0; i < buf.Length; ++i)",
          "52:     {",
          "53:      Assert.AreEqual(buf2[i], buf[i]);",
          "54:     }",
          "",
          "[Added Lines]",
          "27:    var buf = Utils.GetDummyBytes(size: 10000, RandomSeed);",
          "29:    outStream.Write(buf, offset: 0, buf.Length);",
          "32:    ms.Seek(offset: 0, SeekOrigin.Begin);",
          "34:    using BZip2InputStream inStream = new BZip2InputStream(ms);",
          "35:    var buf2 = new byte[buf.Length];",
          "36:    var pos = 0;",
          "37:    while (true)",
          "39:     var numRead = inStream.Read(buf2, pos, count: 4096);",
          "40:     if (numRead <= 0)",
          "42:      break;",
          "44:     pos += numRead;",
          "45:    }",
          "47:    for (var i = 0; i < buf.Length; ++i)",
          "48:    {",
          "49:     Assert.AreEqual(buf2[i], buf[i]);",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs||test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:    return memoryStream;",
          "61:   }",
          "72:   private void RandomDeflateInflate(int size, int level, bool zlib)",
          "73:   {",
          "77:    Inflate(ms, buffer, level, zlib);",
          "78:   }",
          "",
          "[Removed Lines]",
          "63:   private static byte[] GetRandomTestData(int size)",
          "64:   {",
          "65:    byte[] buffer = new byte[size];",
          "66:    var rnd = new Random(RandomSeed);",
          "67:    rnd.NextBytes(buffer);",
          "69:    return buffer;",
          "70:   }",
          "74:    byte[] buffer = GetRandomTestData(size);",
          "76:    MemoryStream ms = Deflate(buffer, level, zlib);",
          "",
          "[Added Lines]",
          "65:    var buffer =  Utils.GetDummyBytes(size, RandomSeed);",
          "66:    var ms = Deflate(buffer, level, zlib);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:   private async Task RandomDeflateInflateAsync(int size, int level, bool zlib)",
          "132:   {",
          "136:    await InflateAsync(ms, buffer, level, zlib);",
          "137:   }",
          "",
          "[Removed Lines]",
          "133:    byte[] buffer = GetRandomTestData(size);",
          "135:    MemoryStream ms = await DeflateAsync(buffer, level, zlib);",
          "",
          "[Added Lines]",
          "123:    var buffer = Utils.GetDummyBytes(size, RandomSeed);",
          "124:    var ms = await DeflateAsync(buffer, level, zlib);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "179:   [Category(\"Async\")]",
          "180:   public async Task InflateDeflateZlibAsync([Range(0, 9)] int level)",
          "181:   {",
          "183:   }",
          "185:   private delegate void RunCompress(byte[] buffer);",
          "192:   private void DeflateAndInflate(byte[] buffer)",
          "193:   {",
          "197:   }",
          "200:   {",
          "201:    int worker = 0;",
          "202:    while (worker <= 255)",
          "",
          "[Removed Lines]",
          "182:    await RandomDeflateInflateAsync(100000, level, true);",
          "187:   private int runLevel;",
          "188:   private bool runZlib;",
          "189:   private long runCount;",
          "190:   private readonly Random runRandom = new Random(RandomSeed);",
          "194:    ++runCount;",
          "195:    MemoryStream ms = Deflate(buffer, runLevel, runZlib);",
          "196:    Inflate(ms, buffer, runLevel, runZlib);",
          "199:   private void TryVariants(RunCompress test, byte[] buffer, int index)",
          "",
          "[Added Lines]",
          "171:    await RandomDeflateInflateAsync(size: 100000, level, zlib: true);",
          "176:   private int _runLevel;",
          "177:   private bool _runZlib;",
          "181:    var ms = Deflate(buffer, _runLevel, _runZlib);",
          "182:    Inflate(ms, buffer, _runLevel, _runZlib);",
          "185:   private void TryVariants(RunCompress test, byte[] buffer, Random random, int index)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "204:     buffer[index] = (byte)worker;",
          "205:     if (index < buffer.Length - 1)",
          "206:     {",
          "208:     }",
          "209:     else",
          "210:     {",
          "211:      test(buffer);",
          "212:     }",
          "215:    }",
          "216:   }",
          "218:   private void TryManyVariants(int level, bool zlib, RunCompress test, byte[] buffer)",
          "219:   {",
          "223:   }",
          "",
          "[Removed Lines]",
          "207:      TryVariants(test, buffer, index + 1);",
          "214:     worker += runRandom.Next(256);",
          "220:    runLevel = level;",
          "221:    runZlib = zlib;",
          "222:    TryVariants(test, buffer, 0);",
          "",
          "[Added Lines]",
          "193:      TryVariants(test, buffer, random, index + 1);",
          "200:     worker += random.Next(maxValue: 256);",
          "206:    var random = new Random(RandomSeed);",
          "207:    _runLevel = level;",
          "208:    _runZlib = zlib;",
          "209:    TryVariants(test, buffer, random, 0);",
          "213:   [Test]",
          "214:   [Category(\"Base\")]",
          "215:   [Explicit(\"Long-running\")]",
          "216:   public void SmallBlocks()",
          "217:   {",
          "218:    var buffer = new byte[10];",
          "219:    TryManyVariants(level: 0, zlib: false, DeflateAndInflate, buffer);",
          "220:   }",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs||test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs -> test/ICSharpCode.SharpZipLib.Tests/GZip/GZipTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:    var ms = new MemoryStream();",
          "24:    var outStream = new GZipOutputStream(ms);",
          "30:    outStream.Write(buf, 0, buf.Length);",
          "31:    outStream.Flush();",
          "",
          "[Removed Lines]",
          "26:    byte[] buf = new byte[100000];",
          "27:    var rnd = new Random();",
          "28:    rnd.NextBytes(buf);",
          "",
          "[Added Lines]",
          "26:    var buf = Utils.GetDummyBytes(size: 100000);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   [Category(\"GZip\")]",
          "65:   public void DelayedHeaderWriteNoData()",
          "66:   {",
          "71:    {",
          "73:    }",
          "78:   }",
          "",
          "[Removed Lines]",
          "67:    var ms = new MemoryStream();",
          "68:    Assert.AreEqual(0, ms.Length);",
          "70:    using (GZipOutputStream outStream = new GZipOutputStream(ms))",
          "72:     Assert.AreEqual(0, ms.Length);",
          "75:    byte[] data = ms.ToArray();",
          "77:    Assert.IsTrue(data.Length > 0);",
          "",
          "[Added Lines]",
          "65:    using var ms = new MemoryStream();",
          "66:    Assert.Zero(ms.Length);",
          "68:    using (new GZipOutputStream(ms))",
          "70:     Assert.Zero(ms.Length);",
          "73:    Assert.NotZero(ms.ToArray().Length);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "260:    s.Close();",
          "262:    memStream = new TrackedMemoryStream();",
          "264:    {",
          "265:     s.Close();",
          "266:    }",
          "",
          "[Removed Lines]",
          "263:    using (GZipOutputStream no2 = new GZipOutputStream(memStream))",
          "",
          "[Added Lines]",
          "259:    using (new GZipOutputStream(memStream))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "273:    var s = new GZipOutputStream(memStream);",
          "274:    s.Finish();",
          "284:   }",
          "286:   [Test]",
          "",
          "[Removed Lines]",
          "276:    try",
          "277:    {",
          "278:     s.WriteByte(7);",
          "279:     Assert.Fail(\"Write should fail\");",
          "280:    }",
          "281:    catch",
          "282:    {",
          "283:    }",
          "",
          "[Added Lines]",
          "272:    Assert.Throws<InvalidOperationException>(() => s.WriteByte(value: 7), \"Write should fail\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "290:    var s = new GZipOutputStream(memStream);",
          "291:    s.Close();",
          "301:   }",
          "",
          "[Removed Lines]",
          "293:    try",
          "294:    {",
          "295:     s.WriteByte(7);",
          "296:     Assert.Fail(\"Write should fail\");",
          "297:    }",
          "298:    catch",
          "299:    {",
          "300:    }",
          "",
          "[Added Lines]",
          "282:    Assert.Throws<InvalidOperationException>(() => s.WriteByte(value: 7), \"Write should fail\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "311:    var outStream = new GZipOutputStream(ms);",
          "319:    outStream.Write(buf, 0, buf.Length);",
          "",
          "[Removed Lines]",
          "314:    byte[] buf = new byte[100000];",
          "315:    var rnd = new Random();",
          "316:    rnd.NextBytes(buf);",
          "",
          "[Added Lines]",
          "296:    var buf = Utils.GetDummyBytes(size: 100000, seed: 3);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "321:    outStream.Finish();",
          "329:    ms.Seek(0, SeekOrigin.Begin);",
          "",
          "[Removed Lines]",
          "324:    byte[] garbage = new byte[4096];",
          "325:    rnd.NextBytes(garbage);",
          "326:    ms.Write(garbage, 0, garbage.Length);",
          "",
          "[Added Lines]",
          "304:    Utils.WriteDummyData(ms, size: 4096, seed: 4);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "336:    int count = buf2.Length;",
          "337:    while (true)",
          "338:    {",
          "340:     if (numRead <= 0)",
          "341:     {",
          "342:      break;",
          "",
          "[Removed Lines]",
          "339:     int numRead = inStream.Read(buf2, currentIndex, count);",
          "",
          "[Added Lines]",
          "317:     var numRead = inStream.Read(buf2, currentIndex, count);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "346:    }",
          "350:    for (int i = 0; i < buf.Length; ++i)",
          "351:    {",
          "352:     Assert.AreEqual(buf2[i], buf[i]);",
          "",
          "[Removed Lines]",
          "349:    Assert.AreEqual(0, count);",
          "",
          "[Added Lines]",
          "327:    Assert.Zero(count);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "365:    var ms = new MemoryStream();",
          "366:    var outStream = new GZipOutputStream(ms);",
          "372:    outStream.Write(buf, 0, buf.Length);",
          "",
          "[Removed Lines]",
          "368:    byte[] buf = new byte[100000];",
          "369:    var rnd = new Random();",
          "370:    rnd.NextBytes(buf);",
          "",
          "[Added Lines]",
          "346:    byte[] buf = Utils.GetDummyBytes(size: 100000);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "414:   {",
          "415:    var outputBufferSize = 100000;",
          "416:    var inputBufferSize = outputBufferSize * 4;",
          "418:    var outputBuffer = new byte[outputBufferSize];",
          "457:    }",
          "459:   }",
          "",
          "[Removed Lines]",
          "419:    var inputBuffer = new byte[inputBufferSize];",
          "421:    using (var msGzip = new MemoryStream())",
          "422:    {",
          "423:     using (var gzos = new GZipOutputStream(msGzip))",
          "424:     {",
          "425:      gzos.IsStreamOwner = false;",
          "427:      var rnd = new Random(0);",
          "428:      rnd.NextBytes(inputBuffer);",
          "429:      gzos.Write(inputBuffer, 0, inputBuffer.Length);",
          "431:      gzos.Flush();",
          "432:      gzos.Finish();",
          "433:     }",
          "435:     msGzip.Seek(0, SeekOrigin.Begin);",
          "438:     using (var gzis = new GZipInputStream(msGzip))",
          "439:     using (var msRaw = new MemoryStream())",
          "440:     {",
          "442:      int readOut;",
          "443:      while ((readOut = gzis.Read(outputBuffer, 0, outputBuffer.Length)) > 0)",
          "444:      {",
          "445:       msRaw.Write(outputBuffer, 0, readOut);",
          "446:      }",
          "448:      var resultBuffer = msRaw.ToArray();",
          "450:      for (var i = 0; i < resultBuffer.Length; i++)",
          "451:      {",
          "452:       Assert.AreEqual(inputBuffer[i], resultBuffer[i]);",
          "453:      }",
          "456:     }",
          "",
          "[Added Lines]",
          "393:    var inputBuffer = Utils.GetDummyBytes(inputBufferSize, seed: 0);",
          "397:    using var msGzip = new MemoryStream();",
          "398:    using (var gzos = new GZipOutputStream(msGzip))",
          "399:    {",
          "400:     gzos.IsStreamOwner = false;",
          "402:     gzos.Write(inputBuffer, 0, inputBuffer.Length);",
          "404:     gzos.Flush();",
          "405:     gzos.Finish();",
          "406:    }",
          "408:    msGzip.Seek(0, SeekOrigin.Begin);",
          "411:    using (var gzis = new GZipInputStream(msGzip))",
          "412:    using (var msRaw = new MemoryStream())",
          "413:    {",
          "415:     int readOut;",
          "416:     while ((readOut = gzis.Read(outputBuffer, 0, outputBuffer.Length)) > 0)",
          "417:     {",
          "418:      msRaw.Write(outputBuffer, 0, readOut);",
          "419:     }",
          "421:     var resultBuffer = msRaw.ToArray();",
          "423:     for (var i = 0; i < resultBuffer.Length; i++)",
          "424:     {",
          "425:      Assert.AreEqual(inputBuffer[i], resultBuffer[i]);",
          "426:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "468:   [Test]",
          "469:   [Category(\"Zip\")]",
          "471:   {",
          "472:    MemoryStream ms = new SelfClosingStream();",
          "473:    using (var gzos = new GZipOutputStream(ms))",
          "474:    {",
          "475:     gzos.IsStreamOwner = false;",
          "482:    }",
          "484:    ms.Seek(0, SeekOrigin.Begin);",
          "",
          "[Removed Lines]",
          "470:   public void ShouldGracefullyHandleReadingANonReableStream()",
          "477:     byte[] buf = new byte[100000];",
          "478:     var rnd = new Random();",
          "479:     rnd.NextBytes(buf);",
          "481:     gzos.Write(buf, 0, buf.Length);",
          "",
          "[Added Lines]",
          "441:   public void ShouldGracefullyHandleReadingANonReadableStream()",
          "447:     Utils.WriteDummyData(gzos, size: 100000);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "526:    var content = \"FileContents\";",
          "530:    {",
          "551:    }",
          "553:   }",
          "554:  }",
          "555: }",
          "",
          "[Removed Lines]",
          "529:    using (var ms = new MemoryStream())",
          "531:     using (var outStream = new GZipOutputStream(ms) { IsStreamOwner = false })",
          "532:     {",
          "533:      outStream.FileName = \"/path/to/file.ext\";",
          "535:      var writeBuffer = Encoding.ASCII.GetBytes(content);",
          "536:      outStream.Write(writeBuffer, 0, writeBuffer.Length);",
          "537:      outStream.Flush();",
          "538:      outStream.Finish();",
          "539:     }",
          "541:     ms.Seek(0, SeekOrigin.Begin);",
          "543:     using (var inStream = new GZipInputStream(ms))",
          "544:     {",
          "545:      var readBuffer = new byte[content.Length];",
          "546:      inStream.Read(readBuffer, 0, readBuffer.Length);",
          "547:      Assert.AreEqual(content, Encoding.ASCII.GetString(readBuffer));",
          "548:      Assert.AreEqual(\"file.ext\", inStream.GetFilename());",
          "549:     }",
          "",
          "[Added Lines]",
          "495:    using var ms = new MemoryStream();",
          "496:    using (var outStream = new GZipOutputStream(ms) { IsStreamOwner = false })",
          "498:     outStream.FileName = \"/path/to/file.ext\";",
          "500:     var writeBuffer = Encoding.ASCII.GetBytes(content);",
          "501:     outStream.Write(writeBuffer, 0, writeBuffer.Length);",
          "502:     outStream.Flush();",
          "503:     outStream.Finish();",
          "504:    }",
          "506:    ms.Seek(0, SeekOrigin.Begin);",
          "508:    using (var inStream = new GZipInputStream(ms))",
          "509:    {",
          "510:     var readBuffer = new byte[content.Length];",
          "511:     inStream.Read(readBuffer, 0, readBuffer.Length);",
          "512:     Assert.AreEqual(content, Encoding.ASCII.GetString(readBuffer));",
          "513:     Assert.AreEqual(\"file.ext\", inStream.GetFilename());",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: using System.Text;",
          "3: using ICSharpCode.SharpZipLib.Core;",
          "4: using ICSharpCode.SharpZipLib.Tar;",
          "5: using static ICSharpCode.SharpZipLib.Tests.TestSupport.Utils;",
          "6: using NUnit.Framework;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: using ICSharpCode.SharpZipLib.Tests.TestSupport;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:   public void ExtractTarOK(string outputDir, string fileName, bool allowTraverse)",
          "57:   {",
          "58:    var fileContent = Encoding.UTF8.GetBytes(\"file content\");",
          "62:    var extractPath = Path.Combine(tempPath, outputDir);",
          "63:    var expectedOutputFile = Path.Combine(extractPath, fileName);",
          "",
          "[Removed Lines]",
          "59:    using var tempDir = new TempDir();",
          "61:    var tempPath = tempDir.Fullpath;",
          "",
          "[Added Lines]",
          "60:    using var tempDir = GetTempDir();",
          "62:    var tempPath = tempDir.FullName;",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Tar/TarTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: using System;",
          "6: using System.IO;",
          "7: using System.Text;",
          "9: namespace ICSharpCode.SharpZipLib.Tests.Tar",
          "10: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: using NUnit.Framework.Internal;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:   public void EmptyTar()",
          "36:   {",
          "37:    var ms = new MemoryStream();",
          "40:    {",
          "41:     recordSize = tarOut.RecordSize;",
          "42:    }",
          "",
          "[Removed Lines]",
          "38:    int recordSize = 0;",
          "39:    using (TarArchive tarOut = TarArchive.CreateOutputTarArchive(ms))",
          "",
          "[Added Lines]",
          "39:    int recordSize;",
          "40:    using (var tarOut = TarArchive.CreateOutputTarArchive(ms))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:    ms2.Write(ms.GetBuffer(), 0, ms.GetBuffer().Length);",
          "49:    ms2.Seek(0, SeekOrigin.Begin);",
          "52:    {",
          "53:     entryCount = 0;",
          "54:     tarIn.ProgressMessageEvent += EntryCounter;",
          "55:     tarIn.ListContents();",
          "57:    }",
          "58:   }",
          "",
          "[Removed Lines]",
          "51:    using (TarArchive tarIn = TarArchive.CreateInputTarArchive(ms2, null))",
          "56:     Assert.AreEqual(0, entryCount, \"Expected 0 tar entries\");",
          "",
          "[Added Lines]",
          "52:    using (var tarIn = TarArchive.CreateInputTarArchive(ms2, nameEncoding: null))",
          "57:     Assert.Zero(entryCount, \"Expected 0 tar entries\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "64:   [Category(\"Tar\")]",
          "65:   public void BlockFactorHandling()",
          "66:   {",
          "72:    {",
          "73:     var ms = new MemoryStream();",
          "76:     {",
          "79:      tarOut.PutNextEntry(entry);",
          "88:      {",
          "89:       tarOut.Write(buffer, 0, buffer.Length);",
          "90:      }",
          "",
          "[Removed Lines]",
          "67:    const int MinimumBlockFactor = 1;",
          "68:    const int MaximumBlockFactor = 64;",
          "69:    const int FillFactor = 2;",
          "71:    for (int factor = MinimumBlockFactor; factor < MaximumBlockFactor; ++factor)",
          "75:     using (TarOutputStream tarOut = new TarOutputStream(ms, factor, null))",
          "77:      TarEntry entry = TarEntry.CreateTarEntry(\"TestEntry\");",
          "78:      entry.Size = (TarBuffer.BlockSize * factor * FillFactor);",
          "81:      byte[] buffer = new byte[TarBuffer.BlockSize];",
          "83:      var r = new Random();",
          "84:      r.NextBytes(buffer);",
          "87:      for (int i = 0; i < factor * FillFactor; ++i)",
          "",
          "[Added Lines]",
          "68:    const int minimumBlockFactor = 1;",
          "69:    const int maximumBlockFactor = 64;",
          "70:    const int fillFactor = 2;",
          "72:    for (var factor = minimumBlockFactor; factor < maximumBlockFactor; ++factor)",
          "76:     using (var tarOut = new TarOutputStream(ms, factor, nameEncoding: null))",
          "78:      var entry = TarEntry.CreateTarEntry(\"TestEntry\");",
          "79:      entry.Size = TarBuffer.BlockSize * factor * fillFactor;",
          "82:      var buffer = Utils.GetDummyBytes(TarBuffer.BlockSize);",
          "85:      for (var i = 0; i < factor * fillFactor; ++i)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "94:     Assert.IsNotNull(tarData, \"Data written is null\");",
          "98:     int totalBlocks = usedBlocks + (factor - 1);",
          "99:     totalBlocks /= factor;",
          "100:     totalBlocks *= factor;",
          "",
          "[Removed Lines]",
          "97:     int usedBlocks = 1 + (factor * FillFactor) + 2;",
          "",
          "[Added Lines]",
          "95:     int usedBlocks = 1 + (factor * fillFactor) + 2;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "102:     Assert.AreEqual(TarBuffer.BlockSize * totalBlocks, tarData.Length, \"Tar file should contain {0} blocks in length\",",
          "103:      totalBlocks);",
          "106:     {",
          "119:     }",
          "120:    }",
          "121:   }",
          "",
          "[Removed Lines]",
          "105:     if (usedBlocks < totalBlocks)",
          "108:      int byteIndex = TarBuffer.BlockSize * ((factor * FillFactor) + 1);",
          "109:      while (byteIndex < tarData.Length)",
          "110:      {",
          "111:       int blockNumber = byteIndex / TarBuffer.BlockSize;",
          "112:       int offset = blockNumber % TarBuffer.BlockSize;",
          "113:       Assert.AreEqual(0, tarData[byteIndex],",
          "114:        string.Format(\"Trailing block data should be null iteration {0} block {1} offset {2}  index {3}\",",
          "115:        factor,",
          "116:        blockNumber, offset, byteIndex));",
          "117:       byteIndex += 1;",
          "118:      }",
          "",
          "[Added Lines]",
          "103:     if (usedBlocks >= totalBlocks) continue;",
          "106:     var byteIndex = TarBuffer.BlockSize * ((factor * fillFactor) + 1);",
          "107:     while (byteIndex < tarData.Length)",
          "109:      var blockNumber = byteIndex / TarBuffer.BlockSize;",
          "110:      var offset = blockNumber % TarBuffer.BlockSize;",
          "111:      Assert.AreEqual(0, tarData[byteIndex],",
          "112:       \"Trailing block data should be null iteration {0} block {1} offset {2}  index {3}\",",
          "113:        factor, blockNumber, offset, byteIndex);",
          "114:      byteIndex += 1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "127:   [Category(\"Tar\")]",
          "128:   public void TrailerContainsNulls()",
          "129:   {",
          "133:    {",
          "134:     var ms = new MemoryStream();",
          "137:     {",
          "138:      TarEntry entry = TarEntry.CreateTarEntry(\"TestEntry\");",
          "139:      if (iteration > 0)",
          "",
          "[Removed Lines]",
          "130:    const int TestBlockFactor = 3;",
          "132:    for (int iteration = 0; iteration < TestBlockFactor * 2; ++iteration)",
          "136:     using (TarOutputStream tarOut = new TarOutputStream(ms, TestBlockFactor, null))",
          "",
          "[Added Lines]",
          "126:    const int testBlockFactor = 3;",
          "128:    for (int iteration = 0; iteration < testBlockFactor * 2; ++iteration)",
          "132:     using (TarOutputStream tarOut = new TarOutputStream(ms, testBlockFactor, null))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "169:     int usedBlocks = 1 + iteration + 2;",
          "174:     Assert.AreEqual(TarBuffer.BlockSize * totalBlocks, tarData.Length,",
          "175:      string.Format(\"Tar file should be {0} blocks in length\", totalBlocks));",
          "",
          "[Removed Lines]",
          "170:     int totalBlocks = usedBlocks + (TestBlockFactor - 1);",
          "171:     totalBlocks /= TestBlockFactor;",
          "172:     totalBlocks *= TestBlockFactor;",
          "",
          "[Added Lines]",
          "166:     int totalBlocks = usedBlocks + (testBlockFactor - 1);",
          "167:     totalBlocks /= testBlockFactor;",
          "168:     totalBlocks *= testBlockFactor;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "195:   private void TryLongName(string name)",
          "196:   {",
          "197:    var ms = new MemoryStream();",
          "199:    {",
          "200:     DateTime modTime = DateTime.Now;",
          "",
          "[Removed Lines]",
          "198:    using (TarOutputStream tarOut = new TarOutputStream(ms, null))",
          "",
          "[Added Lines]",
          "194:    using (TarOutputStream tarOut = new TarOutputStream(ms, nameEncoding: null))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "207:    ms2.Write(ms.GetBuffer(), 0, ms.GetBuffer().Length);",
          "208:    ms2.Seek(0, SeekOrigin.Begin);",
          "211:    {",
          "212:     TarEntry nextEntry = tarIn.GetNextEntry();",
          "",
          "[Removed Lines]",
          "210:    using (TarInputStream tarIn = new TarInputStream(ms2, null))",
          "",
          "[Added Lines]",
          "206:    using (TarInputStream tarIn = new TarInputStream(ms2,  nameEncoding: null))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "290:    var buffer = new byte[2560];",
          "291:    var truncated = Convert.FromBase64String(input64);",
          "292:    Array.Copy(truncated, buffer, truncated.Length);",
          "307:   }",
          "",
          "[Removed Lines]",
          "293:    truncated = null;",
          "295:    using (var ms = new MemoryStream(buffer))",
          "296:    using (var tis = new TarInputStream(ms, null))",
          "297:    {",
          "298:     var entry = tis.GetNextEntry();",
          "299:     Assert.IsNotNull(entry, \"Entry is null\");",
          "301:     Assert.IsNotNull(entry.Name, \"Entry name is null\");",
          "303:     Assert.AreEqual(expectedName.Length, entry.Name.Length, $\"Entry name is truncated to {entry.Name.Length} bytes.\");",
          "305:     Assert.AreEqual(expectedName, entry.Name, \"Entry name does not match expected value\");",
          "306:    }",
          "",
          "[Added Lines]",
          "290:    using var ms = new MemoryStream(buffer);",
          "291:    using var tis = new TarInputStream(ms, nameEncoding: null);",
          "292:    var entry = tis.GetNextEntry();",
          "294:    Assert.IsNotNull(entry, \"Entry is null\");",
          "295:    Assert.IsNotNull(entry.Name, \"Entry name is null\");",
          "296:    Assert.AreEqual(expectedName.Length, entry.Name.Length, $\"Entry name is truncated to {entry.Name.Length} bytes.\");",
          "297:    Assert.AreEqual(expectedName, entry.Name, \"Entry name does not match expected value\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "394:   public void Checksum()",
          "395:   {",
          "396:    var ms = new MemoryStream();",
          "398:    {",
          "402:     entry.TarHeader.Mode = 12345;",
          "404:     tarOut.PutNextEntry(entry);",
          "",
          "[Removed Lines]",
          "397:    using (TarOutputStream tarOut = new TarOutputStream(ms, null))",
          "399:     DateTime modTime = DateTime.Now;",
          "401:     TarEntry entry = TarEntry.CreateTarEntry(\"TestEntry\");",
          "",
          "[Added Lines]",
          "388:    using (var tarOut = new TarOutputStream(ms,  nameEncoding: null))",
          "390:     var entry = TarEntry.CreateTarEntry(\"TestEntry\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "409:    ms2.Seek(0, SeekOrigin.Begin);",
          "410:    TarEntry nextEntry;",
          "413:    {",
          "414:     nextEntry = tarIn.GetNextEntry();",
          "415:     Assert.IsTrue(nextEntry.TarHeader.IsChecksumValid, \"Checksum should be valid\");",
          "",
          "[Removed Lines]",
          "412:    using (TarInputStream tarIn = new TarInputStream(ms2, null))",
          "",
          "[Added Lines]",
          "401:    using (var tarIn = new TarInputStream(ms2, nameEncoding: null))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "421:    ms3.Write(new byte[] { 34 }, 0, 1);",
          "422:    ms3.Seek(0, SeekOrigin.Begin);",
          "425:    {",
          "438:    }",
          "439:   }",
          "",
          "[Removed Lines]",
          "424:    using (TarInputStream tarIn = new TarInputStream(ms3, null))",
          "426:     bool trapped = false;",
          "428:     try",
          "429:     {",
          "430:      nextEntry = tarIn.GetNextEntry();",
          "431:     }",
          "432:     catch (TarException)",
          "433:     {",
          "434:      trapped = true;",
          "435:     }",
          "437:     Assert.IsTrue(trapped, \"Checksum should be invalid\");",
          "",
          "[Added Lines]",
          "413:    using (var tarIn = new TarInputStream(ms3, nameEncoding: null))",
          "415:     Assert.Throws<TarException>(() => tarIn.GetNextEntry(), \"Checksum should be invalid\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "704:    long outCount, inCount;",
          "707:    {",
          "728:     }",
          "737:   }",
          "739:   [Test]",
          "",
          "[Removed Lines]",
          "706:    using (var ms = new MemoryStream())",
          "708:     using (var tarOut = TarArchive.CreateOutputTarArchive(ms))",
          "709:     using (var dummyFile = Utils.GetDummyFile(dummySize))",
          "710:     {",
          "711:      tarOut.IsStreamOwner = false;",
          "712:      tarOut.WriteEntry(TarEntry.CreateEntryFromFile(dummyFile.Filename), false);",
          "713:     }",
          "715:     outCount = ms.Position;",
          "716:     ms.Seek(0, SeekOrigin.Begin);",
          "718:     using (var tarIn = TarArchive.CreateInputTarArchive(ms, null))",
          "719:     using (var tempDir = new Utils.TempDir())",
          "720:     {",
          "721:      tarIn.IsStreamOwner = false;",
          "722:      tarIn.ExtractContents(tempDir.Fullpath);",
          "724:      foreach (var file in Directory.GetFiles(tempDir.Fullpath, \"*\", SearchOption.AllDirectories))",
          "725:      {",
          "726:       Console.WriteLine($\"Extracted \\\"{file}\\\"\");",
          "727:      }",
          "730:     inCount = ms.Position;",
          "732:     Console.WriteLine($\"Output count: {outCount}\");",
          "733:     Console.WriteLine($\"Input count: {inCount}\");",
          "735:     Assert.AreEqual(inCount, outCount, \"Bytes read and bytes written should be equal\");",
          "736:    }",
          "",
          "[Added Lines]",
          "684:    using var ms = new MemoryStream();",
          "685:    using (var tarOut = TarArchive.CreateOutputTarArchive(ms))",
          "686:    using (var dummyFile = Utils.GetDummyFile(dummySize))",
          "688:     tarOut.IsStreamOwner = false;",
          "689:     tarOut.WriteEntry(TarEntry.CreateEntryFromFile(dummyFile), recurse: false);",
          "690:    }",
          "692:    outCount = ms.Position;",
          "693:    ms.Seek(0, SeekOrigin.Begin);",
          "695:    using (var tarIn = TarArchive.CreateInputTarArchive(ms, nameEncoding: null))",
          "696:    using (var tempDir = Utils.GetTempDir())",
          "697:    {",
          "698:     tarIn.IsStreamOwner = false;",
          "699:     tarIn.ExtractContents(tempDir);",
          "701:     foreach (var file in Directory.GetFiles(tempDir, \"*\", SearchOption.AllDirectories))",
          "702:     {",
          "703:      Console.WriteLine($\"Extracted \\\"{file}\\\"\");",
          "705:    }",
          "707:    inCount = ms.Position;",
          "709:    Console.WriteLine($\"Output count: {outCount}\");",
          "710:    Console.WriteLine($\"Input count: {inCount}\");",
          "712:    Assert.AreEqual(inCount, outCount, \"Bytes read and bytes written should be equal\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "742:   [Explicit(\"Long Running\")]",
          "743:   public void WriteThroughput()",
          "744:   {",
          "747:    PerformanceTesting.TestWrite(TestDataSize.Large, bs =>",
          "748:    {",
          "750:     tos.PutNextEntry(new TarEntry(new TarHeader()",
          "751:     {",
          "753:      Size = (int)TestDataSize.Large,",
          "754:     }));",
          "755:     return tos;",
          "",
          "[Removed Lines]",
          "745:    const string EntryName = \"LargeTarEntry\";",
          "749:     var tos = new TarOutputStream(bs, null);",
          "752:      Name = EntryName,",
          "",
          "[Added Lines]",
          "721:    const string entryName = \"LargeTarEntry\";",
          "725:     var tos = new TarOutputStream(bs, nameEncoding: null);",
          "728:      Name = entryName,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "766:   [Explicit(\"Long Running\")]",
          "767:   public void SingleLargeEntry()",
          "768:   {",
          "770:    const TestDataSize dataSize = TestDataSize.Large;",
          "772:    PerformanceTesting.TestReadWrite(",
          "",
          "[Removed Lines]",
          "769:    const string EntryName = \"LargeTarEntry\";",
          "",
          "[Added Lines]",
          "745:    const string entryName = \"LargeTarEntry\";",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "776:      var tis = new TarInputStream(bs, null);",
          "777:      var entry = tis.GetNextEntry();",
          "780:      return tis;",
          "781:     },",
          "782:     output: bs =>",
          "",
          "[Removed Lines]",
          "779:      Assert.AreEqual(EntryName, entry.Name);",
          "",
          "[Added Lines]",
          "755:      Assert.AreEqual(entryName, entry.Name);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "784:      var tos = new TarOutputStream(bs, null);",
          "785:      tos.PutNextEntry(new TarEntry(new TarHeader()",
          "786:      {",
          "788:       Size = (int)dataSize,",
          "789:      }));",
          "790:      return tos;",
          "",
          "[Removed Lines]",
          "787:       Name = EntryName,",
          "",
          "[Added Lines]",
          "763:       Name = entryName,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "801:   [Category(\"Tar\")]",
          "802:   public void ExtractingCorruptTarShouldntLeakFiles()",
          "803:   {",
          "805:    {",
          "817:     }",
          "841:     }",
          "842:    }",
          "843:   }",
          "844:   [TestCase(10, \"utf-8\")]",
          "",
          "[Removed Lines]",
          "804:    using (var memoryStream = new MemoryStream())",
          "807:     using (var gzipStream = new GZipOutputStream(memoryStream))",
          "808:     {",
          "809:      gzipStream.IsStreamOwner = false;",
          "811:      using (var tarOut = TarArchive.CreateOutputTarArchive(gzipStream))",
          "812:      using (var dummyFile = Utils.GetDummyFile(32000))",
          "813:      {",
          "814:       tarOut.IsStreamOwner = false;",
          "815:       tarOut.WriteEntry(TarEntry.CreateEntryFromFile(dummyFile.Filename), false);",
          "816:      }",
          "820:     memoryStream.SetLength(16000);",
          "821:     memoryStream.Seek(0, SeekOrigin.Begin);",
          "824:     using (var gzipStream = new GZipInputStream(memoryStream))",
          "825:     {",
          "826:      string tempDirName;",
          "827:      gzipStream.IsStreamOwner = false;",
          "829:      using (var tempDir = new Utils.TempDir())",
          "830:      {",
          "831:       tempDirName = tempDir.Fullpath;",
          "833:       using (var tarIn = TarArchive.CreateInputTarArchive(gzipStream, null))",
          "834:       {",
          "835:        tarIn.IsStreamOwner = false;",
          "836:        Assert.Throws<SharpZipBaseException>(() => tarIn.ExtractContents(tempDir.Fullpath));",
          "837:       }",
          "838:      }",
          "840:      Assert.That(Directory.Exists(tempDirName), Is.False, \"Temporary folder should have been removed\");",
          "",
          "[Added Lines]",
          "780:    using var memoryStream = new MemoryStream();",
          "782:    using (var gzipStream = new GZipOutputStream(memoryStream))",
          "784:     gzipStream.IsStreamOwner = false;",
          "786:     using (var tarOut = TarArchive.CreateOutputTarArchive(gzipStream))",
          "787:     using (var dummyFile = Utils.GetDummyFile(size: 32000))",
          "788:     {",
          "789:      tarOut.IsStreamOwner = false;",
          "790:      tarOut.WriteEntry(TarEntry.CreateEntryFromFile(dummyFile), recurse: false);",
          "792:    }",
          "795:    memoryStream.SetLength(16000);",
          "796:    memoryStream.Seek(0, SeekOrigin.Begin);",
          "799:    using (var gzipStream = new GZipInputStream(memoryStream))",
          "800:    {",
          "801:     gzipStream.IsStreamOwner = false;",
          "803:     using var tempDir = Utils.GetTempDir();",
          "804:     using (var tarIn = TarArchive.CreateInputTarArchive(gzipStream, nameEncoding: null))",
          "805:     {",
          "806:      tarIn.IsStreamOwner = false;",
          "807:      Assert.Throws<SharpZipBaseException>(() => tarIn.ExtractContents(tempDir));",
          "811:     Assert.DoesNotThrow(() => tempDir.Delete());",
          "813:     Assert.That(tempDir.Exists, Is.False, \"Temporary folder should have been removed\");",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs -> test/ICSharpCode.SharpZipLib.Tests/TestSupport/StringTesting.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: \ufeffusing System.Collections.Generic;",
          "3: namespace ICSharpCode.SharpZipLib.Tests.TestSupport",
          "4: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: using System.Linq;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6:  {",
          "7:   static StringTesting()",
          "8:   {",
          "22:   }",
          "40:  }",
          "41: }",
          "",
          "[Removed Lines]",
          "9:    AddLanguage(\"Chinese\", \"\u6e2c\u8a66.txt\", \"big5\");",
          "10:    AddLanguage(\"Greek\", \"\u03cf\u03b0.txt\", \"windows-1253\");",
          "11:    AddLanguage(\"Nordic\", \"\u00c5\u00e6.txt\", \"windows-1252\");",
          "12:    AddLanguage(\"Arabic\", \"\u0680\u0685.txt\", \"windows-1256\");",
          "13:    AddLanguage(\"Russian\", \"\u041f\u0440\u0439\u0432\u0451\u0442.txt\", \"windows-1251\");",
          "14:   }",
          "16:   private static void AddLanguage(string language, string filename, string encoding)",
          "17:   {",
          "18:    languages.Add(language);",
          "19:    filenames.Add(filename);",
          "20:    encodings.Add(encoding);",
          "21:    entries++;",
          "24:   private static int entries = 0;",
          "25:   private static List<string> languages = new List<string>();",
          "26:   private static List<string> filenames = new List<string>();",
          "27:   private static List<string> encodings = new List<string>();",
          "29:   public static IEnumerable<string> Languages => filenames.AsReadOnly();",
          "30:   public static IEnumerable<string> Filenames => filenames.AsReadOnly();",
          "31:   public static IEnumerable<string> Encodings => filenames.AsReadOnly();",
          "33:   public static IEnumerable<(string language, string filename, string encoding)> GetTestSamples()",
          "34:   {",
          "35:    for (int i = 0; i < entries; i++)",
          "36:    {",
          "37:     yield return (languages[i], filenames[i], encodings[i]);",
          "38:    }",
          "39:   }",
          "",
          "[Added Lines]",
          "10:    TestSamples = new []",
          "11:    {",
          "12:     (\"Chinese\", \"\u6e2c\u8a66.txt\", \"big5\"),",
          "13:     (\"Greek\", \"\u03cf\u03b0.txt\", \"windows-1253\"),",
          "14:     (\"Nordic\", \"\u00c5\u00e6.txt\", \"windows-1252\"),",
          "15:     (\"Arabic\", \"\u0680\u0685.txt\", \"windows-1256\"),",
          "16:     (\"Russian\", \"\u041f\u0440\u0439\u0432\u0451\u0442.txt\", \"windows-1251\"),",
          "17:    };",
          "20:   public static (string language, string filename, string encoding)[] TestSamples { get; }",
          "22:   public static IEnumerable<string> Languages => TestSamples.Select(s => s.language);",
          "23:   public static IEnumerable<string> Filenames => TestSamples.Select(s => s.filename);",
          "24:   public static IEnumerable<string> Encodings => TestSamples.Select(s => s.encoding);",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs -> test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: using NUnit.Framework;",
          "2: using System;",
          "3: using System.IO;",
          "6: namespace ICSharpCode.SharpZipLib.Tests.TestSupport",
          "7: {",
          "",
          "[Removed Lines]",
          "4: using System.Text;",
          "",
          "[Added Lines]",
          "4: using System.Linq;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:  public static class Utils",
          "12:  {",
          "",
          "[Removed Lines]",
          "13:   public static int DummyContentLength = 16;",
          "15:   private static Random random = new Random();",
          "",
          "[Added Lines]",
          "13:   internal const int DefaultSeed = 5;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "40:    }",
          "41:   }",
          "44:   {",
          "49:   }",
          "52:   {",
          "63:   }",
          "66:   {",
          "67:    var tempFile = new TempFile();",
          "69:    return tempFile;",
          "70:   }",
          "72:   public static string GetDummyFileName()",
          "163:  }",
          "164: }",
          "",
          "[Removed Lines]",
          "43:   public static void WriteDummyData(string fileName, int size = -1)",
          "45:    using(var fs = File.OpenWrite(fileName))",
          "46:    {",
          "47:     WriteDummyData(fs, size);",
          "48:    }",
          "51:   public static void WriteDummyData(Stream stream, int size = -1)",
          "53:    var bytes = (size < 0)",
          "54:     ? Encoding.ASCII.GetBytes(DateTime.UtcNow.Ticks.ToString(\"x16\"))",
          "55:     : new byte[size];",
          "57:    if(size > 0)",
          "58:    {",
          "59:     random.NextBytes(bytes);",
          "60:    }",
          "62:    stream.Write(bytes, 0, bytes.Length);",
          "65:   public static TempFile GetDummyFile(int size = -1)",
          "68:    WriteDummyData(tempFile.Filename, size);",
          "73:    => $\"{random.Next():x8}{random.Next():x8}{random.Next():x8}\";",
          "75:   public class TempFile : IDisposable",
          "76:   {",
          "77:    public string Filename { get; internal set; }",
          "79:    public TempFile()",
          "80:    {",
          "81:     Filename = Path.GetTempFileName();",
          "82:    }",
          "84:    #region IDisposable Support",
          "86:    private bool disposed = false; // To detect redundant calls",
          "88:    protected virtual void Dispose(bool disposing)",
          "89:    {",
          "90:     if (!disposed)",
          "91:     {",
          "92:      if (disposing && File.Exists(Filename))",
          "93:      {",
          "94:       try",
          "95:       {",
          "96:        File.Delete(Filename);",
          "97:       }",
          "98:       catch { }",
          "99:      }",
          "101:      disposed = true;",
          "102:     }",
          "103:    }",
          "105:    public void Dispose()",
          "106:    {",
          "107:     Dispose(true);",
          "108:     GC.SuppressFinalize(this);",
          "109:    }",
          "111:    #endregion IDisposable Support",
          "112:   }",
          "114:   public class TempDir : IDisposable",
          "115:   {",
          "116:    public string Fullpath { get; internal set; }",
          "118:    public TempDir()",
          "119:    {",
          "120:     Fullpath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());",
          "121:     Directory.CreateDirectory(Fullpath);",
          "122:    }",
          "124:    #region IDisposable Support",
          "126:    private bool disposed = false; // To detect redundant calls",
          "128:    protected virtual void Dispose(bool disposing)",
          "129:    {",
          "130:     if (!disposed)",
          "131:     {",
          "132:      if (disposing && Directory.Exists(Fullpath))",
          "133:      {",
          "134:       try",
          "135:       {",
          "136:        Directory.Delete(Fullpath, true);",
          "137:       }",
          "138:       catch { }",
          "139:      }",
          "141:      disposed = true;",
          "142:     }",
          "143:    }",
          "145:    public void Dispose()",
          "146:    {",
          "147:     Dispose(true);",
          "148:     GC.SuppressFinalize(this);",
          "149:    }",
          "151:    internal string CreateDummyFile(int size = -1)",
          "152:     => CreateDummyFile(GetDummyFileName(), size);",
          "154:    internal string CreateDummyFile(string name, int size = -1)",
          "155:    {",
          "156:     var fileName = Path.Combine(Fullpath, name);",
          "157:     WriteDummyData(fileName, size);",
          "158:     return fileName;",
          "159:    }",
          "161:    #endregion IDisposable Support",
          "162:   }",
          "",
          "[Added Lines]",
          "48:   public static void WriteDummyData(string fileName, int size, int seed = DefaultSeed)",
          "50:    using var fs = File.Create(fileName);",
          "51:    WriteDummyData(fs, size, seed);",
          "60:   public static void WriteDummyData(Stream stream, int size, int seed = DefaultSeed)",
          "62:    var bytes = GetDummyBytes(size, seed);",
          "63:    stream.Write(bytes, offset: 0, bytes.Length);",
          "64:   }",
          "72:   public static byte[] GetDummyBytes(int size, int seed = DefaultSeed)",
          "73:   {",
          "74:    var random = new Random(seed);",
          "75:    var bytes = new byte[size];",
          "76:    random.NextBytes(bytes);",
          "77:    return bytes;",
          "85:   public static TempFile GetDummyFile(int size = 16)",
          "88:    using var fs = tempFile.Create();",
          "89:    WriteDummyData(fs, size);",
          "98:    => string.Concat(Guid.NewGuid().ToByteArray().Select(b => $\"{b:x2}\"));",
          "104:   public static TempDir GetTempDir() => new TempDir();",
          "110:   public static TempFile GetTempFile() => new TempFile();",
          "111:  }",
          "113:  public class TempFile : FileSystemInfo, IDisposable",
          "114:  {",
          "115:   private FileInfo _fileInfo;",
          "117:   public override string Name => _fileInfo.Name;",
          "118:   public override bool Exists => _fileInfo.Exists;",
          "119:   public string DirectoryName => _fileInfo.DirectoryName;",
          "121:   public override string FullName => _fileInfo.FullName;",
          "123:   public byte[] ReadAllBytes() => File.ReadAllBytes(_fileInfo.FullName);",
          "125:   public static implicit operator string(TempFile tf) => tf._fileInfo.FullName;",
          "127:   public override void Delete()",
          "128:      {",
          "129:       if(!Exists) return;",
          "130:    _fileInfo.Delete();",
          "131:      }",
          "133:   public FileStream Create() => _fileInfo.Create();",
          "135:      public static TempFile WithDummyData(int size, string dirPath = null, string filename = null, int seed = Utils.DefaultSeed)",
          "136:      {",
          "137:       var tempFile = new TempFile(dirPath, filename);",
          "138:       Utils.WriteDummyData(tempFile.FullName, size, seed);",
          "139:       return tempFile;",
          "140:      }",
          "142:      internal TempFile(string dirPath = null, string filename = null)",
          "143:      {",
          "144:       dirPath ??= Path.GetTempPath();",
          "145:       filename ??= Utils.GetDummyFileName();",
          "146:       _fileInfo = new FileInfo(Path.Combine(dirPath, filename));",
          "147:      }",
          "149:      #region IDisposable Support",
          "151:      private bool _disposed; // To detect redundant calls",
          "153:      protected virtual void Dispose(bool disposing)",
          "154:      {",
          "155:       if (_disposed) return;",
          "156:             if (disposing)",
          "157:             {",
          "158:              try",
          "159:              {",
          "160:               Delete();",
          "161:              }",
          "162:              catch",
          "163:              {",
          "165:              }",
          "166:             }",
          "168:       _disposed = true;",
          "169:      }",
          "171:      public void Dispose()",
          "172:      {",
          "173:       Dispose(disposing: true);",
          "174:       GC.SuppressFinalize(this);",
          "175:      }",
          "177:      #endregion IDisposable Support",
          "181:     public class TempDir : FileSystemInfo, IDisposable",
          "182:     {",
          "183:      public override string Name => Path.GetFileName(FullName);",
          "184:         public override bool Exists => Directory.Exists(FullName);",
          "186:         public static implicit operator string(TempDir td) => td.FullName;",
          "188:         public override void Delete()",
          "189:         {",
          "190:          if(!Exists) return;",
          "191:          Directory.Delete(FullPath, recursive: true);",
          "192:         }",
          "194:         public TempDir()",
          "195:      {",
          "196:          FullPath = Path.Combine(Path.GetTempPath(), Utils.GetDummyFileName());",
          "197:       Directory.CreateDirectory(FullPath);",
          "198:      }",
          "200:         public TempFile CreateDummyFile(int size = 16, int seed = Utils.DefaultSeed)",
          "201:          => CreateDummyFile(null, size);",
          "203:         public TempFile CreateDummyFile(string name, int size = 16, int seed = Utils.DefaultSeed)",
          "204:          => TempFile.WithDummyData(size, FullPath, name, seed);",
          "206:         public TempFile GetFile(string fileName) => new TempFile(FullPath, fileName);",
          "208:      #region IDisposable Support",
          "210:      private bool _disposed; // To detect redundant calls",
          "212:      protected virtual void Dispose(bool disposing)",
          "213:      {",
          "214:       if (_disposed) return;",
          "215:             if (disposing)",
          "216:             {",
          "217:              try",
          "218:              {",
          "219:               Delete();",
          "220:              }",
          "221:              catch",
          "222:              {",
          "224:              }",
          "225:             }",
          "226:             _disposed = true;",
          "227:      }",
          "229:      public void Dispose()",
          "230:      {",
          "231:       Dispose(true);",
          "232:       GC.SuppressFinalize(this);",
          "233:      }",
          "235:         #endregion IDisposable Support",
          "236:     }",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs -> test/ICSharpCode.SharpZipLib.Tests/Zip/FastZipHandling.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:   [Category(\"CreatesTempFile\")]",
          "104:   public void CreateEmptyDirectories(string password)",
          "105:   {",
          "107:    {",
          "112:     string targetDir = Path.Combine(archiveRootDir, \"floyd\");",
          "113:     Directory.CreateDirectory(targetDir);",
          "",
          "[Removed Lines]",
          "106:    using (var tempFilePath = new Utils.TempDir())",
          "108:     string name = Path.Combine(tempFilePath.Fullpath, \"x.zip\");",
          "111:     string archiveRootDir = Path.Combine(tempFilePath.Fullpath, ZipTempDir);",
          "",
          "[Added Lines]",
          "106:    using (var tempFilePath = Utils.GetTempDir())",
          "108:     string name = Path.Combine(tempFilePath.FullName, \"x.zip\");",
          "111:     string archiveRootDir = Path.Combine(tempFilePath.FullName, ZipTempDir);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:      CreateEmptyDirectories = true,",
          "119:      Password = password,",
          "120:     };",
          "124:     using (var zipFile = new ZipFile(name))",
          "",
          "[Removed Lines]",
          "121:     fastZip.CreateZip(name, archiveRootDir, true, null);",
          "",
          "[Added Lines]",
          "121:     fastZip.CreateZip(name, archiveRootDir, recurse: true, fileFilter: null);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:      var folderEntry = zipFile.GetEntry(\"floyd/\");",
          "129:      Assert.That(folderEntry.IsDirectory, Is.True, \"The entry must be a folder\");",
          "132:     }",
          "133:    }",
          "134:   }",
          "",
          "[Removed Lines]",
          "131:      Assert.IsTrue(zipFile.TestArchive(true));",
          "",
          "[Added Lines]",
          "131:      Assert.IsTrue(zipFile.TestArchive(testData: true));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "138:   [Category(\"CreatesTempFile\")]",
          "139:   public void ContentEqualAfterAfterArchived([Values(0, 1, 64)]int contentSize)",
          "140:   {",
          "160:   }",
          "162:   [Test]",
          "",
          "[Removed Lines]",
          "141:    using(var sourceDir = new Utils.TempDir())",
          "142:    using(var targetDir = new Utils.TempDir())",
          "143:    using(var zipFile = Utils.GetDummyFile(0))",
          "144:    {",
          "145:     var sourceFile = sourceDir.CreateDummyFile(contentSize);",
          "146:     var sourceContent = File.ReadAllBytes(sourceFile);",
          "147:     new FastZip().CreateZip(zipFile.Filename, sourceDir.Fullpath, true, null);",
          "149:     Assert.DoesNotThrow(() =>",
          "150:     {",
          "151:      new FastZip().ExtractZip(zipFile.Filename, targetDir.Fullpath, null);",
          "152:     }, \"Exception during extraction of test archive\");",
          "154:     var targetFile = Path.Combine(targetDir.Fullpath, Path.GetFileName(sourceFile));",
          "155:     var targetContent = File.ReadAllBytes(targetFile);",
          "157:     Assert.AreEqual(sourceContent.Length, targetContent.Length, \"Extracted file size does not match source file size\");",
          "158:     Assert.AreEqual(sourceContent, targetContent, \"Extracted content does not match source content\");",
          "159:    }",
          "",
          "[Added Lines]",
          "141:    using var sourceDir = Utils.GetTempDir();",
          "142:    using var targetDir = Utils.GetTempDir();",
          "143:    using var zipFile = Utils.GetTempFile();",
          "145:    var sourceFile = sourceDir.CreateDummyFile(contentSize);",
          "146:    var sourceContent = sourceFile.ReadAllBytes();",
          "147:    new FastZip().CreateZip(zipFile.FullName, sourceDir.FullName, recurse: true, fileFilter: null);",
          "149:    Assert.DoesNotThrow(() =>",
          "150:    {",
          "151:     new FastZip().ExtractZip(zipFile, targetDir, fileFilter: null);",
          "152:    }, \"Exception during extraction of test archive\");",
          "154:    var targetFile = Path.Combine(targetDir, Path.GetFileName(sourceFile));",
          "155:    var targetContent = File.ReadAllBytes(targetFile);",
          "157:    Assert.AreEqual(sourceContent.Length, targetContent.Length, \"Extracted file size does not match source file size\");",
          "158:    Assert.AreEqual(sourceContent, targetContent, \"Extracted content does not match source content\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "230:   {",
          "231:    Assert.Throws<DirectoryNotFoundException>(() =>",
          "232:    {",
          "240:    });",
          "241:   }",
          "243:   #region String testing helper",
          "249:   {",
          "250:    var zippy = new FastZip();",
          "254:    {",
          "291:    }",
          "292:   }",
          "",
          "[Removed Lines]",
          "233:     using (var tempDir = new Utils.TempDir())",
          "234:     {",
          "235:      var fastZip = new FastZip();",
          "236:      var badPath = Path.Combine(Path.GetTempPath(), Utils.GetDummyFileName());",
          "237:      var addFile = Path.Combine(tempDir.Fullpath, \"test.zip\");",
          "238:      fastZip.CreateZip(addFile, badPath, false, null);",
          "239:     }",
          "245:   private void TestFileNames(params string[] names)",
          "246:    => TestFileNames((IEnumerable<string>)names);",
          "248:   private void TestFileNames(IEnumerable<string> names)",
          "252:    using (var tempDir = new Utils.TempDir())",
          "253:    using (var tempZip = new Utils.TempFile())",
          "255:     int nameCount = 0;",
          "256:     foreach (var name in names)",
          "257:     {",
          "258:      tempDir.CreateDummyFile(name);",
          "259:      nameCount++;",
          "260:     }",
          "262:     zippy.CreateZip(tempZip.Filename, tempDir.Fullpath, true, null);",
          "264:     using (ZipFile z = new ZipFile(tempZip.Filename))",
          "265:     {",
          "266:      Assert.AreEqual(nameCount, z.Count);",
          "267:      foreach (var name in names)",
          "268:      {",
          "269:       var index = z.FindEntry(name, true);",
          "271:       Assert.AreNotEqual(-1, index, \"Zip entry \\\"{0}\\\" not found\", name);",
          "273:       var entry = z[index];",
          "275:       if (ZipStrings.UseUnicode)",
          "276:       {",
          "277:        Assert.IsTrue(entry.IsUnicodeText, \"Zip entry #{0} not marked as unicode\", index);",
          "278:       }",
          "279:       else",
          "280:       {",
          "281:        Assert.IsFalse(entry.IsUnicodeText, \"Zip entry #{0} marked as unicode\", index);",
          "282:       }",
          "284:       Assert.AreEqual(name, entry.Name);",
          "286:       var nameBytes = string.Join(\" \", Encoding.BigEndianUnicode.GetBytes(entry.Name).Select(b => b.ToString(\"x2\")));",
          "288:       Console.WriteLine($\" - Zip entry: {entry.Name} ({nameBytes})\");",
          "289:      }",
          "290:     }",
          "",
          "[Added Lines]",
          "232:     using var tempDir = Utils.GetTempDir();",
          "233:     var fastZip = new FastZip();",
          "234:     var badPath = Path.Combine(Path.GetTempPath(), Utils.GetDummyFileName());",
          "235:     var addFile = tempDir.GetFile(\"test.zip\");",
          "236:     fastZip.CreateZip(addFile, badPath, recurse: false, fileFilter: null);",
          "242:   private void TestFileNames(IReadOnlyList<string> names)",
          "246:    using var tempDir = Utils.GetTempDir();",
          "247:    using var tempZip = Utils.GetTempFile();",
          "248:    int nameCount = 0;",
          "249:    foreach (var name in names)",
          "251:     tempDir.CreateDummyFile(name);",
          "252:     nameCount++;",
          "253:    }",
          "255:    zippy.CreateZip(tempZip, tempDir, recurse: true, fileFilter: null);",
          "257:    using var zf = new ZipFile(tempZip);",
          "258:    Assert.AreEqual(nameCount, zf.Count);",
          "259:    foreach (var name in names)",
          "260:    {",
          "261:     var index = zf.FindEntry(name, ignoreCase: true);",
          "263:     Assert.AreNotEqual(expected: -1, index, \"Zip entry \\\"{0}\\\" not found\", name);",
          "265:     var entry = zf[index];",
          "267:     if (ZipStrings.UseUnicode)",
          "268:     {",
          "269:      Assert.IsTrue(entry.IsUnicodeText, \"Zip entry #{0} not marked as unicode\", index);",
          "270:     }",
          "271:     else",
          "272:     {",
          "273:      Assert.IsFalse(entry.IsUnicodeText, \"Zip entry #{0} marked as unicode\", index);",
          "274:     }",
          "276:     Assert.AreEqual(name, entry.Name);",
          "278:     var nameBytes = string.Join(\" \", Encoding.BigEndianUnicode.GetBytes(entry.Name).Select(b => b.ToString(\"x2\")));",
          "280:     Console.WriteLine($\" - Zip entry: {entry.Name} ({nameBytes})\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "301:    var preCp = ZipStrings.CodePage;",
          "302:    try",
          "303:    {",
          "305:    }",
          "306:    finally",
          "307:    {",
          "",
          "[Removed Lines]",
          "304:     TestFileNames(StringTesting.Filenames);",
          "",
          "[Added Lines]",
          "294:     TestFileNames(StringTesting.Filenames.ToArray());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "319:    {",
          "320:     Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);",
          "323:     {",
          "324:      Console.WriteLine($\"{language} filename \\\"{filename}\\\" using \\\"{encoding}\\\":\");",
          "",
          "[Removed Lines]",
          "322:     foreach ((string language, string filename, string encoding) in StringTesting.GetTestSamples())",
          "",
          "[Added Lines]",
          "312:     foreach (var (language, filename, encoding) in StringTesting.TestSamples)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "337:      }",
          "339:      ZipStrings.CodePage = Encoding.GetEncoding(encoding).CodePage;",
          "341:     }",
          "342:    }",
          "343:    finally",
          "",
          "[Removed Lines]",
          "340:      TestFileNames(filename);",
          "",
          "[Added Lines]",
          "330:      TestFileNames(new []{filename});",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "659:   {",
          "660:    const string tempFileName = \"a(2).dat\";",
          "688:   }",
          "690:   [Category(\"Zip\")]",
          "",
          "[Removed Lines]",
          "662:    using (var tempFolder = new Utils.TempDir())",
          "663:    {",
          "665:     string addFile = Path.Combine(tempFolder.Fullpath, tempFileName);",
          "666:     MakeTempFile(addFile, 16);",
          "669:     var target = new TrackedMemoryStream();",
          "670:     var fastZip = new FastZip();",
          "672:         fastZip.CreateZip(target, tempFolder.Fullpath, false, @\"a\\(2\\)\\.dat\", null, leaveOpen: leaveOpen);",
          "675:     Assert.That(target.IsDisposed, Is.Not.EqualTo(leaveOpen), \"IsDisposed should be the opposite of leaveOpen\");",
          "678:     var archive = new MemoryStream(target.ToArray());",
          "679:     using (ZipFile zf = new ZipFile(archive))",
          "680:     {",
          "681:      Assert.AreEqual(1, zf.Count);",
          "682:      ZipEntry entry = zf[0];",
          "683:      Assert.AreEqual(tempFileName, entry.Name);",
          "684:      Assert.AreEqual(16, entry.Size);",
          "685:      Assert.IsTrue(zf.TestArchive(true));",
          "686:     }",
          "687:    }",
          "",
          "[Added Lines]",
          "652:    using var tempFolder = Utils.GetTempDir();",
          "654:    tempFolder.CreateDummyFile(tempFileName, size: 16);",
          "657:    var target = new TrackedMemoryStream();",
          "658:    var fastZip = new FastZip();",
          "660:    fastZip.CreateZip(target, tempFolder, recurse: false, @\"a\\(2\\)\\.dat\", directoryFilter: null, leaveOpen);",
          "663:    Assert.That(target.IsDisposed, Is.Not.EqualTo(leaveOpen), \"IsDisposed should be the opposite of leaveOpen\");",
          "666:    var archive = new MemoryStream(target.ToArray());",
          "667:    using var zf = new ZipFile(archive);",
          "668:    Assert.AreEqual(expected: 1, zf.Count);",
          "669:    var entry = zf[0];",
          "670:    Assert.AreEqual(tempFileName, entry.Name);",
          "671:    Assert.AreEqual(expected: 16, entry.Size);",
          "672:    Assert.IsTrue(zf.TestArchive(testData: true));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "748:    }",
          "750:    var fastZip = new FastZip(timeSetting);",
          "760:   }",
          "762:   [Category(\"Zip\")]",
          "",
          "[Removed Lines]",
          "751:    using (var extractDir = new Utils.TempDir())",
          "752:    {",
          "753:     fastZip.ExtractZip(archiveStream, extractDir.Fullpath, FastZip.Overwrite.Always,",
          "754:      _ => true, \"\", \"\", true, true, false);",
          "755:     var fi = new FileInfo(Path.Combine(extractDir.Fullpath, SingleEntryFileName));",
          "756:     var actualTime = FileTimeFromTimeSetting(fi, timeSetting);",
          "758:     Assert.LessOrEqual(Math.Abs((targetTime - actualTime).TotalSeconds), 2);",
          "759:    }",
          "",
          "[Added Lines]",
          "736:    using var extractDir = Utils.GetTempDir();",
          "737:    fastZip.ExtractZip(archiveStream, extractDir.FullName, FastZip.Overwrite.Always,",
          "738:     _ => true, \"\", \"\", restoreDateTime: true, isStreamOwner: true, allowParentTraversal: false);",
          "739:    var fi = new FileInfo(Path.Combine(extractDir.FullName, SingleEntryFileName));",
          "740:    var actualTime = FileTimeFromTimeSetting(fi, timeSetting);",
          "742:    Assert.LessOrEqual(Math.Abs((targetTime - actualTime).TotalSeconds), 2);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "771:    var targetTime = ExpectedFixedTime(dtk);",
          "772:    var fastZip = new FastZip(targetTime);",
          "782:   }",
          "784:   [Category(\"Zip\")]",
          "",
          "[Removed Lines]",
          "773:    using (var extractDir = new Utils.TempDir())",
          "774:    {",
          "775:     fastZip.ExtractZip(target, extractDir.Fullpath, FastZip.Overwrite.Always,",
          "776:      _ => true, \"\", \"\", true, true, false);",
          "777:     var fi = new FileInfo(Path.Combine(extractDir.Fullpath, SingleEntryFileName));",
          "778:     var fileTime = FileTimeFromTimeSetting(fi, TimeSetting.Fixed);",
          "779:     if (fileTime.Kind != dtk) fileTime = fileTime.ToUniversalTime();",
          "780:     Assert.AreEqual(targetTime, fileTime);",
          "781:    }",
          "",
          "[Added Lines]",
          "756:    using var extractDir = Utils.GetTempDir();",
          "757:    fastZip.ExtractZip(target, extractDir.FullName, FastZip.Overwrite.Always,",
          "758:     _ => true, \"\", \"\", restoreDateTime: true, isStreamOwner: true, allowParentTraversal: false);",
          "759:    var fi = new FileInfo(Path.Combine(extractDir.FullName, SingleEntryFileName));",
          "760:    var fileTime = FileTimeFromTimeSetting(fi, TimeSetting.Fixed);",
          "761:    if (fileTime.Kind != dtk) fileTime = fileTime.ToUniversalTime();",
          "762:    Assert.AreEqual(targetTime, fileTime);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "794:    var fastZip = new FastZip();",
          "802:   }",
          "804:   private static bool IsLastAccessTime(TimeSetting ts)",
          "",
          "[Removed Lines]",
          "795:    using (var extractDir = new Utils.TempDir())",
          "796:    {",
          "797:     fastZip.ExtractZip(target, extractDir.Fullpath, FastZip.Overwrite.Always,",
          "798:      _ => true, \"\", \"\", true, true, false);",
          "799:     var fi = new FileInfo(Path.Combine(extractDir.Fullpath, SingleEntryFileName));",
          "800:     Assert.AreEqual(targetTime, FileTimeFromTimeSetting(fi, TimeSetting.Fixed));",
          "801:    }",
          "",
          "[Added Lines]",
          "776:    using var extractDir = Utils.GetTempDir();",
          "777:    fastZip.ExtractZip(target, extractDir.FullName, FastZip.Overwrite.Always,",
          "778:     _ => true, \"\", \"\", restoreDateTime: true, isStreamOwner: true, allowParentTraversal: false);",
          "779:    var fi = new FileInfo(Path.Combine(extractDir.FullName, SingleEntryFileName));",
          "780:    Assert.AreEqual(targetTime, FileTimeFromTimeSetting(fi, TimeSetting.Fixed));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "851:   {",
          "852:    var target = new TrackedMemoryStream();",
          "866:    return target;",
          "867:   }",
          "",
          "[Removed Lines]",
          "854:    using (var tempFolder = new Utils.TempDir())",
          "855:    {",
          "858:     var addFile = Path.Combine(tempFolder.Fullpath, SingleEntryFileName);",
          "859:     MakeTempFile(addFile, 16);",
          "860:     var fi = new FileInfo(addFile);",
          "861:     alterFile?.Invoke(fi);",
          "863:     fastZip.CreateZip(target, tempFolder.Fullpath, false, SingleEntryFileName, null, leaveOpen: true);",
          "864:    }",
          "",
          "[Added Lines]",
          "833:    using var tempFolder = Utils.GetTempDir();",
          "835:    var addFile = Path.Combine(tempFolder.FullName, SingleEntryFileName);",
          "836:    MakeTempFile(addFile, 16);",
          "837:    var fi = new FileInfo(addFile);",
          "838:    alterFile?.Invoke(fi);",
          "840:    fastZip.CreateZip(target, tempFolder.FullName, recurse: false,",
          "841:     SingleEntryFileName, directoryFilter: null, leaveOpen: true);",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs -> test/ICSharpCode.SharpZipLib.Tests/Zip/StreamHandling.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:    ms.Seek(0, SeekOrigin.Begin);",
          "46:    var inStream = new ZipInputStream(ms);",
          "50:    MustFailRead(inStream, buffer, -1, 1);",
          "51:    MustFailRead(inStream, buffer, 0, 11);",
          "52:    MustFailRead(inStream, buffer, 7, 5);",
          "",
          "[Removed Lines]",
          "47:    ZipEntry e = inStream.GetNextEntry();",
          "49:    MustFailRead(inStream, null, 0, 0);",
          "",
          "[Added Lines]",
          "47:    inStream.GetNextEntry();",
          "49:    MustFailRead(inStream, buffer: null, 0, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:    msw.Position = 0;",
          "118:    {",
          "119:     while (zis.GetNextEntry() != null)",
          "120:     {",
          "125:      {",
          "127:      }",
          "",
          "[Removed Lines]",
          "117:    using (ZipInputStream zis = new ZipInputStream(msw))",
          "121:      int len = 0;",
          "122:      int bufferSize = 1024;",
          "123:      byte[] buffer = new byte[bufferSize];",
          "124:      while ((len = zis.Read(buffer, 0, bufferSize)) > 0)",
          "",
          "[Added Lines]",
          "117:    using (var zis = new ZipInputStream(msw))",
          "121:      const int bufferSize = 1024;",
          "122:      var buffer = new byte[bufferSize];",
          "123:      while (zis.Read(buffer, 0, bufferSize) > 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "241:   {",
          "242:    var buffer = new byte[255];",
          "253:     {",
          "284:    }",
          "285:   }",
          "",
          "[Removed Lines]",
          "244:    using (var dummyZip = Utils.GetDummyFile(0))",
          "245:    using (var inputFile = Utils.GetDummyFile(contentLength))",
          "246:    {",
          "248:     var inputFileName = ZipEntry.CleanName(inputFile.Filename);",
          "250:     using (var zipFileStream = File.OpenWrite(dummyZip.Filename))",
          "251:     using (var zipOutputStream = new ZipOutputStream(zipFileStream))",
          "252:     using (var inputFileStream = File.OpenRead(inputFile.Filename))",
          "254:      zipOutputStream.PutNextEntry(new ZipEntry(inputFileName)",
          "255:      {",
          "256:       CompressionMethod = CompressionMethod.Stored,",
          "257:      });",
          "259:      StreamUtils.Copy(inputFileStream, zipOutputStream, buffer);",
          "260:     }",
          "262:     using (var zf = new ZipFile(dummyZip.Filename))",
          "263:     {",
          "264:      var inputBytes = File.ReadAllBytes(inputFile.Filename);",
          "266:      var entry = zf.GetEntry(inputFileName);",
          "267:      Assert.IsNotNull(entry, \"No entry matching source file \\\"{0}\\\" found in archive, found \\\"{1}\\\"\", inputFileName, zf[0].Name);",
          "269:      Assert.DoesNotThrow(() =>",
          "270:      {",
          "271:       using (var entryStream = zf.GetInputStream(entry))",
          "272:       {",
          "273:        var outputBytes = new byte[entryStream.Length];",
          "274:        entryStream.Read(outputBytes, 0, outputBytes.Length);",
          "276:        Assert.AreEqual(inputBytes, outputBytes, \"Archive content does not match the source content\");",
          "277:       }",
          "278:      }, \"Failed to locate entry stream in archive\");",
          "280:      Assert.IsTrue(zf.TestArchive(testData: true), \"Archive did not pass TestArchive\");",
          "281:     }",
          "",
          "[Added Lines]",
          "243:    using var dummyZip = Utils.GetTempFile();",
          "244:    using var inputFile = Utils.GetDummyFile(contentLength);",
          "246:    var inputFileName = ZipEntry.CleanName(inputFile);",
          "248:    using (var zipFileStream = File.OpenWrite(dummyZip))",
          "249:    using (var zipOutputStream = new ZipOutputStream(zipFileStream))",
          "250:    using (var inputFileStream = File.OpenRead(inputFile))",
          "251:    {",
          "252:     zipOutputStream.PutNextEntry(new ZipEntry(inputFileName)",
          "254:      CompressionMethod = CompressionMethod.Stored,",
          "255:     });",
          "257:     StreamUtils.Copy(inputFileStream, zipOutputStream, buffer);",
          "258:    }",
          "260:    using (var zf = new ZipFile(dummyZip))",
          "261:    {",
          "262:     var inputBytes = File.ReadAllBytes(inputFile);",
          "264:     var entry = zf.GetEntry(inputFileName);",
          "265:     Assert.IsNotNull(entry, \"No entry matching source file \\\"{0}\\\" found in archive, found \\\"{1}\\\"\", inputFileName, zf[0].Name);",
          "267:     Assert.DoesNotThrow(() =>",
          "268:     {",
          "269:      using var entryStream = zf.GetInputStream(entry);",
          "270:      var outputBytes = new byte[entryStream.Length];",
          "271:      entryStream.Read(outputBytes, 0, outputBytes.Length);",
          "273:      Assert.AreEqual(inputBytes, outputBytes, \"Archive content does not match the source content\");",
          "274:     }, \"Failed to locate entry stream in archive\");",
          "276:     Assert.IsTrue(zf.TestArchive(testData: true), \"Archive did not pass TestArchive\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "288:   [Category(\"Zip\")]",
          "289:   public void ZipEntryFileNameAutoClean()",
          "290:   {",
          "296:     {",
          "311:    }",
          "312:   }",
          "",
          "[Removed Lines]",
          "291:    using (var dummyZip = Utils.GetDummyFile(0))",
          "292:    using (var inputFile = Utils.GetDummyFile()) {",
          "293:     using (var zipFileStream = File.OpenWrite(dummyZip.Filename))",
          "294:     using (var zipOutputStream = new ZipOutputStream(zipFileStream))",
          "295:     using (var inputFileStream = File.OpenRead(inputFile.Filename))",
          "298:      zipOutputStream.PutNextEntry(new ZipEntry(inputFile.Filename)",
          "299:      {",
          "300:       CompressionMethod = CompressionMethod.Stored,",
          "301:      });",
          "303:      inputFileStream.CopyTo(zipOutputStream);",
          "304:     }",
          "306:     using (var zf = new ZipFile(dummyZip.Filename))",
          "307:     {",
          "309:      Assert.AreEqual(ZipEntry.CleanName(inputFile.Filename), zf[0].Name);",
          "310:     }",
          "",
          "[Added Lines]",
          "284:    using var dummyZip = Utils.GetDummyFile(0);",
          "285:    using var inputFile = Utils.GetDummyFile();",
          "286:    using (var zipFileStream = File.OpenWrite(dummyZip))",
          "287:    using (var zipOutputStream = new ZipOutputStream(zipFileStream))",
          "288:    using (var inputFileStream = File.OpenRead(inputFile))",
          "289:    {",
          "291:     zipOutputStream.PutNextEntry(new ZipEntry(inputFile)",
          "293:      CompressionMethod = CompressionMethod.Stored,",
          "294:     });",
          "296:     inputFileStream.CopyTo(zipOutputStream);",
          "297:    }",
          "299:    using (var zf = new ZipFile(dummyZip))",
          "300:    {",
          "302:     Assert.AreEqual(ZipEntry.CleanName(inputFile), zf[0].Name);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "424:   [Explicit(\"Long Running\")]",
          "425:   public void SingleLargeEntry()",
          "426:   {",
          "429:    PerformanceTesting.TestReadWrite(",
          "430:     size: TestDataSize.Large,",
          "",
          "[Removed Lines]",
          "427:    const string EntryName = \"CantSeek\";",
          "",
          "[Added Lines]",
          "419:    const string entryName = \"CantSeek\";",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "433:      var zis = new ZipInputStream(bs);",
          "434:      var entry = zis.GetNextEntry();",
          "437:      Assert.IsTrue((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0);",
          "438:      return zis;",
          "439:     },",
          "440:     output: bs =>",
          "441:     {",
          "442:      var zos = new ZipOutputStream(bs);",
          "444:      return zos;",
          "445:     }",
          "446:    );",
          "",
          "[Removed Lines]",
          "436:      Assert.AreEqual(EntryName, entry.Name);",
          "443:      zos.PutNextEntry(new ZipEntry(EntryName));",
          "",
          "[Added Lines]",
          "428:      Assert.AreEqual(entryName, entry.Name);",
          "435:      zos.PutNextEntry(new ZipEntry(entryName));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "458:   [Category(\"Zip\")]",
          "459:   public void ShouldReadBZip2EntryButNotDecompress()",
          "460:   {",
          "475:   }",
          "",
          "[Removed Lines]",
          "461:    var fileBytes = System.Convert.FromBase64String(BZip2CompressedZip);",
          "463:    using (var input = new MemoryStream(fileBytes, false))",
          "464:    {",
          "465:     var zis = new ZipInputStream(input);",
          "466:     var entry = zis.GetNextEntry();",
          "468:     Assert.That(entry.Name, Is.EqualTo(\"a.dat\"), \"Should be able to get entry name\");",
          "469:     Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Entry should be BZip2 compressed\");",
          "470:     Assert.That(zis.CanDecompressEntry, Is.False, \"Should not be able to decompress BZip2 entry\");",
          "472:     var buffer = new byte[1];",
          "473:     Assert.Throws<ZipException>(() => zis.Read(buffer, 0, 1), \"Trying to read the stream should throw\");",
          "474:    }",
          "",
          "[Added Lines]",
          "453:    var fileBytes = Convert.FromBase64String(BZip2CompressedZip);",
          "455:    using var input = new MemoryStream(fileBytes, writable: false);",
          "456:    var zis = new ZipInputStream(input);",
          "457:    var entry = zis.GetNextEntry();",
          "459:    Assert.That(entry.Name, Is.EqualTo(\"a.dat\"), \"Should be able to get entry name\");",
          "460:    Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Entry should be BZip2 compressed\");",
          "461:    Assert.That(zis.CanDecompressEntry, Is.False, \"Should not be able to decompress BZip2 entry\");",
          "463:    var buffer = new byte[1];",
          "464:    Assert.Throws<ZipException>(() => zis.Read(buffer, 0, 1), \"Trying to read the stream should throw\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "510:   [Category(\"Zip\")]",
          "511:   public void AddingAnAESEntryWithNoPasswordShouldThrow()",
          "512:   {",
          "522:   }",
          "524:   [Test]",
          "525:   [Category(\"Zip\")]",
          "526:   public void ShouldThrowDescriptiveExceptionOnUncompressedDescriptorEntry()",
          "527:   {",
          "529:    {",
          "557:    }",
          "558:   }",
          "559:  }",
          "",
          "[Removed Lines]",
          "513:    using (var memoryStream = new MemoryStream())",
          "514:    {",
          "515:     using (var outStream = new ZipOutputStream(memoryStream))",
          "516:     {",
          "517:      var newEntry = new ZipEntry(\"test\") { AESKeySize = 256 };",
          "519:      Assert.Throws<InvalidOperationException>(() => outStream.PutNextEntry(newEntry));",
          "520:     }",
          "521:    }",
          "528:    using (var ms = new MemoryStreamWithoutSeek())",
          "530:     using (var zos = new ZipOutputStream(ms))",
          "531:     {",
          "532:      zos.IsStreamOwner = false;",
          "533:      var entry = new ZipEntry(\"testentry\");",
          "534:      entry.CompressionMethod = CompressionMethod.Stored;",
          "535:      entry.Flags |= (int)GeneralBitFlags.Descriptor;",
          "536:      zos.PutNextEntry(entry);",
          "537:      zos.Write(new byte[1], 0, 1);",
          "538:      zos.CloseEntry();",
          "539:     }",
          "542:     ms.Seek(8, SeekOrigin.Begin);",
          "543:     ms.WriteByte((byte)CompressionMethod.Stored);",
          "544:     ms.Seek(0, SeekOrigin.Begin);",
          "546:     using (var zis = new ZipInputStream(ms))",
          "547:     {",
          "548:      zis.IsStreamOwner = false;",
          "549:      var buf = new byte[32];",
          "550:      zis.GetNextEntry();",
          "552:      Assert.Throws(typeof(StreamUnsupportedException), () =>",
          "553:      {",
          "554:       zis.Read(buf, 0, buf.Length);",
          "555:      });",
          "556:     }",
          "",
          "[Added Lines]",
          "503:    using var memoryStream = new MemoryStream();",
          "504:    using var outStream = new ZipOutputStream(memoryStream);",
          "505:    var newEntry = new ZipEntry(\"test\") { AESKeySize = 256 };",
          "507:    Assert.Throws<InvalidOperationException>(() => outStream.PutNextEntry(newEntry));",
          "514:    using var ms = new MemoryStreamWithoutSeek();",
          "515:    using (var zos = new ZipOutputStream(ms))",
          "517:     zos.IsStreamOwner = false;",
          "518:     var entry = new ZipEntry(\"testentry\");",
          "519:     entry.CompressionMethod = CompressionMethod.Stored;",
          "520:     entry.Flags |= (int)GeneralBitFlags.Descriptor;",
          "521:     zos.PutNextEntry(entry);",
          "522:     zos.Write(new byte[1], 0, 1);",
          "523:     zos.CloseEntry();",
          "524:    }",
          "527:    ms.Seek(8, SeekOrigin.Begin);",
          "528:    ms.WriteByte((byte)CompressionMethod.Stored);",
          "529:    ms.Seek(0, SeekOrigin.Begin);",
          "531:    using (var zis = new ZipInputStream(ms))",
          "532:    {",
          "533:     zis.IsStreamOwner = false;",
          "534:     var buf = new byte[32];",
          "535:     zis.GetNextEntry();",
          "537:     Assert.Throws(typeof(StreamUnsupportedException), () =>",
          "538:     {",
          "539:      zis.Read(buf, 0, buf.Length);",
          "540:     });",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs -> test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:   [Category(\"Zip\")]",
          "239:   public void BasicEncryption()",
          "240:   {",
          "242:    var memStream = new MemoryStream();",
          "244:    {",
          "253:    }",
          "256:    {",
          "260:     Assert.IsTrue(ze.IsCrypted, \"Entry should be encrypted\");",
          "262:     {",
          "265:     }",
          "266:    }",
          "267:   }",
          "",
          "[Removed Lines]",
          "241:    const string TestValue = \"0001000\";",
          "243:    using (ZipFile f = new ZipFile(memStream))",
          "245:     f.IsStreamOwner = false;",
          "246:     f.Password = \"Hello\";",
          "248:     var m = new StringMemoryDataSource(TestValue);",
          "249:     f.BeginUpdate(new MemoryArchiveStorage());",
          "250:     f.Add(m, \"a.dat\");",
          "251:     f.CommitUpdate();",
          "252:     Assert.IsTrue(f.TestArchive(true), \"Archive test should pass\");",
          "255:    using (ZipFile g = new ZipFile(memStream))",
          "257:     g.Password = \"Hello\";",
          "258:     ZipEntry ze = g[0];",
          "261:     using (StreamReader r = new StreamReader(g.GetInputStream(0)))",
          "263:      string data = r.ReadToEnd();",
          "264:      Assert.AreEqual(TestValue, data);",
          "",
          "[Added Lines]",
          "241:    const string testValue = \"0001000\";",
          "243:    using (var zf = new ZipFile(memStream))",
          "245:     zf.IsStreamOwner = false;",
          "246:     zf.Password = \"Hello\";",
          "248:     var m = new StringMemoryDataSource(testValue);",
          "249:     zf.BeginUpdate(new MemoryArchiveStorage());",
          "250:     zf.Add(m, \"a.dat\");",
          "251:     zf.CommitUpdate();",
          "252:     Assert.IsTrue(zf.TestArchive(testData: true), \"Archive test should pass\");",
          "255:    using (var zf = new ZipFile(memStream))",
          "257:     zf.Password = \"Hello\";",
          "258:     var ze = zf[0];",
          "261:     using (var r = new StreamReader(zf.GetInputStream(entryIndex: 0)))",
          "263:      var data = r.ReadToEnd();",
          "264:      Assert.AreEqual(testValue, data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:   [Category(\"CreatesTempFile\")]",
          "272:   public void BasicEncryptionToDisk()",
          "273:   {",
          "276:    Assert.IsNotNull(tempFile, \"No permission to execute this test?\");",
          "278:    tempFile = Path.Combine(tempFile, \"SharpZipTest.Zip\");",
          "281:    {",
          "288:    }",
          "291:    {",
          "294:    }",
          "297:    {",
          "301:     Assert.IsTrue(ze.IsCrypted, \"Entry should be encrypted\");",
          "303:     {",
          "306:     }",
          "307:    }",
          "",
          "[Removed Lines]",
          "274:    const string TestValue = \"0001000\";",
          "275:    string tempFile = GetTempFilePath();",
          "280:    using (ZipFile f = ZipFile.Create(tempFile))",
          "282:     f.Password = \"Hello\";",
          "284:     var m = new StringMemoryDataSource(TestValue);",
          "285:     f.BeginUpdate();",
          "286:     f.Add(m, \"a.dat\");",
          "287:     f.CommitUpdate();",
          "290:    using (ZipFile f = new ZipFile(tempFile))",
          "292:     f.Password = \"Hello\";",
          "293:     Assert.IsTrue(f.TestArchive(true), \"Archive test should pass\");",
          "296:    using (ZipFile g = new ZipFile(tempFile))",
          "298:     g.Password = \"Hello\";",
          "299:     ZipEntry ze = g[0];",
          "302:     using (StreamReader r = new StreamReader(g.GetInputStream(0)))",
          "304:      string data = r.ReadToEnd();",
          "305:      Assert.AreEqual(TestValue, data);",
          "",
          "[Added Lines]",
          "274:    const string testValue = \"0001000\";",
          "275:    var tempFile = GetTempFilePath();",
          "280:    using (var zf = ZipFile.Create(tempFile))",
          "282:     zf.Password = \"Hello\";",
          "284:     var m = new StringMemoryDataSource(testValue);",
          "285:     zf.BeginUpdate();",
          "286:     zf.Add(m, \"a.dat\");",
          "287:     zf.CommitUpdate();",
          "290:    using (var zf = new ZipFile(tempFile))",
          "292:     zf.Password = \"Hello\";",
          "293:     Assert.IsTrue(zf.TestArchive(testData: true), \"Archive test should pass\");",
          "296:    using (var zf = new ZipFile(tempFile))",
          "298:     zf.Password = \"Hello\";",
          "299:     ZipEntry ze = zf[0];",
          "302:     using (var r = new StreamReader(zf.GetInputStream(entryIndex: 0)))",
          "304:      var data = r.ReadToEnd();",
          "305:      Assert.AreEqual(testValue, data);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "313:   [Category(\"Zip\")]",
          "314:   public void AddEncryptedEntriesToExistingArchive()",
          "315:   {",
          "317:    var memStream = new MemoryStream();",
          "318:    using (ZipFile f = new ZipFile(memStream))",
          "319:    {",
          "320:     f.IsStreamOwner = false;",
          "321:     f.UseZip64 = UseZip64.Off;",
          "324:     f.BeginUpdate(new MemoryArchiveStorage());",
          "325:     f.Add(m, \"a.dat\");",
          "326:     f.CommitUpdate();",
          "",
          "[Removed Lines]",
          "316:    const string TestValue = \"0001000\";",
          "323:     var m = new StringMemoryDataSource(TestValue);",
          "",
          "[Added Lines]",
          "316:    const string testValue = \"0001000\";",
          "323:     var m = new StringMemoryDataSource(testValue);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "335:     using (StreamReader r = new StreamReader(g.GetInputStream(0)))",
          "336:     {",
          "337:      string data = r.ReadToEnd();",
          "339:     }",
          "343:     g.Password = \"Axolotyl\";",
          "344:     g.UseZip64 = UseZip64.Off;",
          "",
          "[Removed Lines]",
          "338:      Assert.AreEqual(TestValue, data);",
          "341:     var n = new StringMemoryDataSource(TestValue);",
          "",
          "[Added Lines]",
          "338:      Assert.AreEqual(testValue, data);",
          "341:     var n = new StringMemoryDataSource(testValue);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "353:     using (StreamReader r = new StreamReader(g.GetInputStream(0)))",
          "354:     {",
          "355:      string data = r.ReadToEnd();",
          "357:     }",
          "358:    }",
          "359:   }",
          "",
          "[Removed Lines]",
          "356:      Assert.AreEqual(TestValue, data);",
          "",
          "[Added Lines]",
          "356:      Assert.AreEqual(testValue, data);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "684:   [Category(\"CreatesTempFile\")]",
          "685:   public void CreateArchiveWithNoCompression()",
          "686:   {",
          "690:    {",
          "702:     {",
          "709:     }",
          "710:    }",
          "711:   }",
          "",
          "[Removed Lines]",
          "688:    using (var sourceFile = Utils.GetDummyFile())",
          "689:    using (var zipFile = Utils.GetDummyFile(0))",
          "691:     var inputContent = File.ReadAllText(sourceFile.Filename);",
          "692:     using (ZipFile f = ZipFile.Create(zipFile.Filename))",
          "693:     {",
          "694:      f.BeginUpdate();",
          "695:      f.Add(sourceFile.Filename, CompressionMethod.Stored);",
          "696:      f.CommitUpdate();",
          "697:      Assert.IsTrue(f.TestArchive(true));",
          "698:      f.Close();",
          "699:     }",
          "701:     using (ZipFile f = new ZipFile(zipFile.Filename))",
          "703:      Assert.AreEqual(1, f.Count);",
          "704:      using (var sr = new StreamReader(f.GetInputStream(f[0])))",
          "705:      {",
          "706:       var outputContent = sr.ReadToEnd();",
          "707:       Assert.AreEqual(inputContent, outputContent, \"extracted content does not match source content\");",
          "708:      }",
          "",
          "[Added Lines]",
          "687:    using var sourceFile = Utils.GetDummyFile();",
          "688:    using var zipFile = Utils.GetDummyFile(0);",
          "689:    var inputContent = File.ReadAllText(sourceFile);",
          "690:    using (var zf = ZipFile.Create(zipFile))",
          "692:     zf.BeginUpdate();",
          "693:     zf.Add(sourceFile, CompressionMethod.Stored);",
          "694:     zf.CommitUpdate();",
          "695:     Assert.IsTrue(zf.TestArchive(testData: true));",
          "696:     zf.Close();",
          "697:    }",
          "699:    using (var zf = new ZipFile(zipFile))",
          "700:    {",
          "701:     Assert.AreEqual(1, zf.Count);",
          "702:     using (var sr = new StreamReader(zf.GetInputStream(zf[0])))",
          "704:      var outputContent = sr.ReadToEnd();",
          "705:      Assert.AreEqual(inputContent, outputContent, \"extracted content does not match source content\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1009:   [Category(\"Unicode\")]",
          "1010:   public void UnicodeNames()",
          "1011:   {",
          "1013:    {",
          "1030:     {",
          "1051:     }",
          "1052:    }",
          "1053:   }",
          "",
          "[Removed Lines]",
          "1012:    using (var memStream = new MemoryStream())",
          "1014:     using (ZipFile f = new ZipFile(memStream))",
          "1015:     {",
          "1016:      f.IsStreamOwner = false;",
          "1018:      f.BeginUpdate(new MemoryArchiveStorage());",
          "1019:      foreach ((string language, string name, _) in StringTesting.GetTestSamples())",
          "1020:      {",
          "1021:       f.Add(new StringMemoryDataSource(language), name,",
          "1022:          CompressionMethod.Deflated, true);",
          "1023:      }",
          "1024:      f.CommitUpdate();",
          "1026:      Assert.IsTrue(f.TestArchive(true));",
          "1027:     }",
          "1028:     memStream.Seek(0, SeekOrigin.Begin);",
          "1029:     using (var zf = new ZipFile(memStream))",
          "1031:      foreach (string name in StringTesting.Filenames)",
          "1032:      {",
          "1034:       var content = \"\";",
          "1035:       var index = zf.FindEntry(name, true);",
          "1036:       var entry = zf[index];",
          "1038:       using (var entryStream = zf.GetInputStream(entry))",
          "1039:       using (var sr = new StreamReader(entryStream))",
          "1040:       {",
          "1041:        content = sr.ReadToEnd();",
          "1042:       }",
          "1046:       Console.WriteLine($\"Entry #{index}: {name}, Content: {content}\");",
          "1048:       Assert.IsTrue(index >= 0);",
          "1049:       Assert.AreEqual(name, entry.Name);",
          "1050:      }",
          "",
          "[Added Lines]",
          "1009:    using var memStream = new MemoryStream();",
          "1010:    using (var f = new ZipFile(memStream))",
          "1012:     f.IsStreamOwner = false;",
          "1014:     f.BeginUpdate(new MemoryArchiveStorage());",
          "1015:     foreach (var (language, name, _) in StringTesting.TestSamples)",
          "1017:      f.Add(new StringMemoryDataSource(language), name,",
          "1018:       CompressionMethod.Deflated, useUnicodeText: true);",
          "1019:     }",
          "1020:     f.CommitUpdate();",
          "1022:     Assert.IsTrue(f.TestArchive(testData: true));",
          "1023:    }",
          "1024:    memStream.Seek(0, SeekOrigin.Begin);",
          "1025:    using (var zf = new ZipFile(memStream))",
          "1026:    {",
          "1027:     foreach (var name in StringTesting.Filenames)",
          "1028:     {",
          "1029:      string content;",
          "1030:      var index = zf.FindEntry(name, ignoreCase: true);",
          "1031:      var entry = zf[index];",
          "1033:      using (var entryStream = zf.GetInputStream(entry))",
          "1034:      using (var sr = new StreamReader(entryStream))",
          "1035:      {",
          "1036:       content = sr.ReadToEnd();",
          "1037:      }",
          "1039:      TestContext.WriteLine($\"Entry #{index}: {name}, Content: {content}\");",
          "1041:      Assert.IsTrue(index >= 0);",
          "1042:      Assert.AreEqual(name, entry.Name);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1463:   }",
          "1468:   [Test]",
          "1469:   [Category(\"Zip\")]",
          "1471:   {",
          "1472:    var ms = new TrackedMemoryStream(new byte[32]);",
          "1474:    Assert.IsFalse(ms.IsClosed, \"Underlying stream should NOT be closed initially\");",
          "1484:    {",
          "1504:    {",
          "1509:    }",
          "1511:    {",
          "1513:    }",
          "1517:   }",
          "1519:   [Test]",
          "",
          "[Removed Lines]",
          "1470:   public void StreamClosedOnError()",
          "1475:    bool blewUp = false;",
          "1476:    try",
          "1477:    {",
          "1478:     using (var zipFile = new ZipFile(ms, false))",
          "1479:     {",
          "1480:      Assert.Fail(\"Exception not thrown\");",
          "1481:     }",
          "1482:    }",
          "1483:    catch",
          "1485:     blewUp = true;",
          "1486:    }",
          "1488:    Assert.IsTrue(blewUp, \"Should have failed to load the file\");",
          "1489:    Assert.IsTrue(ms.IsClosed, \"Underlying stream should be closed\");",
          "1490:   }",
          "1495:   [Test]",
          "1496:   [Category(\"Zip\")]",
          "1497:   public void StreamNotClosedOnError()",
          "1498:   {",
          "1499:    var ms = new TrackedMemoryStream(new byte[32]);",
          "1501:    Assert.IsFalse(ms.IsClosed, \"Underlying stream should NOT be closed initially\");",
          "1502:    bool blewUp = false;",
          "1503:    try",
          "1505:     using (var zipFile = new ZipFile(ms, true))",
          "1506:     {",
          "1507:      Assert.Fail(\"Exception not thrown\");",
          "1508:     }",
          "1510:    catch",
          "1512:     blewUp = true;",
          "1515:    Assert.IsTrue(blewUp, \"Should have failed to load the file\");",
          "1516:    Assert.IsFalse(ms.IsClosed, \"Underlying stream should NOT be closed\");",
          "",
          "[Added Lines]",
          "1462:   public void StreamClosedOnError([Values(true, false)] bool leaveOpen)",
          "1467:    Assert.Throws<ZipException>(() =>",
          "1469:     using var zf = new ZipFile(ms, leaveOpen);",
          "1470:    }, \"Should have failed to load the file\");",
          "1472:    if (leaveOpen)",
          "1474:     Assert.IsFalse(ms.IsClosed, \"Underlying stream should NOT be closed\");",
          "1476:    else",
          "1478:     Assert.IsTrue(ms.IsClosed, \"Underlying stream should be closed\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1586:   public void AddingAnAESEncryptedEntryShouldThrow()",
          "1587:   {",
          "1588:    var memStream = new MemoryStream();",
          "1590:    {",
          "1600:   }",
          "",
          "[Removed Lines]",
          "1589:    using (ZipFile zof = new ZipFile(memStream))",
          "1591:     var entry = new ZipEntry(\"test\")",
          "1592:     {",
          "1593:      AESKeySize = 256",
          "1594:     };",
          "1596:     zof.BeginUpdate();",
          "1597:     var exception = Assert.Throws<NotSupportedException>(() => zof.Add(new StringMemoryDataSource(\"foo\"), entry));",
          "1598:     Assert.That(exception.Message, Is.EqualTo(\"Creation of AES encrypted entries is not supported\"));",
          "1599:    }",
          "",
          "[Added Lines]",
          "1552:    using var zof = new ZipFile(memStream);",
          "1553:    var entry = new ZipEntry(\"test\")",
          "1555:     AESKeySize = 256,",
          "1556:    };",
          "1558:    zof.BeginUpdate();",
          "1559:    var exception = Assert.Throws<NotSupportedException>(() => zof.Add(new StringMemoryDataSource(\"foo\"), entry));",
          "1560:    Assert.That(exception?.Message, Is.EqualTo(\"Creation of AES encrypted entries is not supported\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1608:   public void AddFileWithAlternateName()",
          "1609:   {",
          "1615:    {",
          "1640:     }",
          "1641:    }",
          "1642:   }",
          "",
          "[Removed Lines]",
          "1611:    string fileName = Guid.NewGuid().ToString();",
          "1613:    using (var sourceFile = Utils.GetDummyFile())",
          "1614:    using (var outputFile = Utils.GetDummyFile(0))",
          "1616:     var inputContent = File.ReadAllText(sourceFile.Filename);",
          "1617:     using (ZipFile f = ZipFile.Create(outputFile.Filename))",
          "1618:     {",
          "1619:      f.BeginUpdate();",
          "1622:      f.Add(sourceFile.Filename, fileName);",
          "1624:      f.CommitUpdate();",
          "1625:      f.Close();",
          "1626:     }",
          "1628:     using (ZipFile zipFile = new ZipFile(outputFile.Filename))",
          "1629:     {",
          "1630:      Assert.That(zipFile.Count, Is.EqualTo(1));",
          "1632:      var fileEntry = zipFile.GetEntry(fileName);",
          "1633:      Assert.That(fileEntry, Is.Not.Null);",
          "1635:      using (var sr = new StreamReader(zipFile.GetInputStream(fileEntry)))",
          "1636:      {",
          "1637:       var outputContent = sr.ReadToEnd();",
          "1638:       Assert.AreEqual(inputContent, outputContent, \"extracted content does not match source content\");",
          "1639:      }",
          "",
          "[Added Lines]",
          "1572:    var fileName = Utils.GetDummyFileName();",
          "1574:    using var sourceFile = Utils.GetDummyFile(size: 16);",
          "1575:    using var outputFile = Utils.GetTempFile();",
          "1576:    var inputContent = File.ReadAllText(sourceFile);",
          "1577:    using (var zf = ZipFile.Create(outputFile))",
          "1579:     zf.BeginUpdate();",
          "1582:     zf.Add(sourceFile, fileName);",
          "1584:     zf.CommitUpdate();",
          "1585:     zf.Close();",
          "1586:    }",
          "1588:    using (var zipFile = new ZipFile(outputFile))",
          "1589:    {",
          "1590:     Assert.That(zipFile.Count, Is.EqualTo(1));",
          "1592:     var fileEntry = zipFile.GetEntry(fileName);",
          "1593:     Assert.That(fileEntry, Is.Not.Null);",
          "1595:     using (var sr = new StreamReader(zipFile.GetInputStream(fileEntry)))",
          "1596:     {",
          "1597:      var outputContent = sr.ReadToEnd();",
          "1598:      Assert.AreEqual(inputContent, outputContent, \"extracted content does not match source content\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1713:   [Category(\"Zip\")]",
          "1714:   public void ShouldReadBZip2ZipCreatedBy7Zip()",
          "1715:   {",
          "1717:    \"UEsDBC4AAAAMAIa50U4/rHf5qwAAAK8AAAAJAAAASGVsbG8udHh0QlpoOTFBWSZTWTL8pwYAA\" +",
          "1718:    \"BWfgEhlUAAiLUgQP+feMCAAiCKaeiaBobU9JiaAMGmoak9GmRNqPUDQ9T1PQsz/t9B6YvEdvF\" +",
          "1719:    \"5dhwXzGE1ooO41A6TtATBEFxFUq6trGtUcSJDyWWWj/S2VwY15fy3IqHi3hHUS+K76zdoDzQa\" +",
          "",
          "[Removed Lines]",
          "1716:    const string BZip2CompressedZipCreatedBy7Zip =",
          "",
          "[Added Lines]",
          "1675:    const string bZip2CompressedZipCreatedBy7Zip =",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1721:    \"AAwAhrnRTj+sd/mrAAAArwAAAAkAJAAAAAAAAAAgAAAAAAAAAEhlbGxvLnR4dAoAIAAAAAAAA\" +",
          "1722:    \"QAYAO97MLZZJdUB73swtlkl1QEK0UTFWCXVAVBLBQYAAAAAAQABAFsAAADSAAAAAAA=\";",
          "1725:     \"SharpZipLib (#ziplib, formerly NZipLib) is a compression library that supports Zip files using both stored and deflate compression methods, PKZIP 2.0 style and AES encryption.\";",
          "1744:   }",
          "",
          "[Removed Lines]",
          "1724:    const string OriginalText =",
          "1727:    var fileBytes = System.Convert.FromBase64String(BZip2CompressedZipCreatedBy7Zip);",
          "1729:    using (var input = new MemoryStream(fileBytes, false))",
          "1730:    {",
          "1731:     using (ZipFile f = new ZipFile(input))",
          "1732:     {",
          "1733:      var entry = f.GetEntry(\"Hello.txt\");",
          "1734:      Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Compression method should be BZip2\");",
          "1735:      Assert.That(entry.Version, Is.EqualTo(ZipConstants.VersionBZip2), \"Entry version should be 46\");",
          "1737:      using (var reader = new StreamReader(f.GetInputStream(entry)))",
          "1738:      {",
          "1739:       string contents = reader.ReadToEnd();",
          "1740:       Assert.That(contents, Is.EqualTo(OriginalText), \"extract string must match original string\");",
          "1741:      }",
          "1742:     }",
          "1743:    }",
          "",
          "[Added Lines]",
          "1683:    const string originalText =",
          "1686:    var fileBytes = Convert.FromBase64String(bZip2CompressedZipCreatedBy7Zip);",
          "1688:    using var input = new MemoryStream(fileBytes, writable: false);",
          "1689:    using var zf = new ZipFile(input);",
          "1690:    var entry = zf.GetEntry(\"Hello.txt\");",
          "1691:    Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Compression method should be BZip2\");",
          "1692:    Assert.That(entry.Version, Is.EqualTo(ZipConstants.VersionBZip2), \"Entry version should be 46\");",
          "1694:    using var reader = new StreamReader(zf.GetInputStream(entry));",
          "1695:    var contents = reader.ReadToEnd();",
          "1696:    Assert.That(contents, Is.EqualTo(originalText), \"extract string must match original string\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1750:   [Category(\"Zip\")]",
          "1751:   public void ShouldReadAESBZip2ZipCreatedBy7Zip()",
          "1752:   {",
          "1754:     \"UEsDBDMAAQBjAIa50U4AAAAAxwAAAK8AAAAJAAsASGVsbG8udHh0AZkHAAIAQUUDDAAYg6jqf\" +",
          "1755:    \"kvZClVMOtgmqKT0/8I9fMPgo96myxw9hLQUhKj1Qczi3fT7QIhAnAKU+u03nA8rCKGWmDI5Qz\" +",
          "1756:    \"qPREy95boQVDPwmwEsWksv3GAWzMfzZUhmB/TgIJlA34a4yP0f2ucy3/QCQYo8QcHjBtjWX5b\" +",
          "",
          "[Removed Lines]",
          "1753:    const string BZip2CompressedZipCreatedBy7Zip =",
          "",
          "[Added Lines]",
          "1706:    const string bZip2CompressedZipCreatedBy7Zip =",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1759:    \"wAAAAkALwAAAAAAAAAgAAAAAAAAAEhlbGxvLnR4dAoAIAAAAAAAAQAYAO97MLZZJdUBYdnjul\" +",
          "1760:    \"kl1QEK0UTFWCXVAQGZBwACAEFFAwwAUEsFBgAAAAABAAEAZgAAAPkAAAAAAA==\";",
          "1763:     \"SharpZipLib (#ziplib, formerly NZipLib) is a compression library that supports Zip files using both stored and deflate compression methods, PKZIP 2.0 style and AES encryption.\";",
          "1786:   }",
          "",
          "[Removed Lines]",
          "1762:    const string OriginalText =",
          "1765:    var fileBytes = System.Convert.FromBase64String(BZip2CompressedZipCreatedBy7Zip);",
          "1767:    using (var input = new MemoryStream(fileBytes, false))",
          "1768:    {",
          "1769:     using (ZipFile f = new ZipFile(input))",
          "1770:     {",
          "1771:      f.Password = \"password\";",
          "1773:      var entry = f.GetEntry(\"Hello.txt\");",
          "1774:      Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Compression method should be BZip2\");",
          "1775:      Assert.That(entry.Version, Is.EqualTo(ZipConstants.VERSION_AES), \"Entry version should be 51\");",
          "1776:      Assert.That(entry.IsCrypted, Is.True, \"Entry should be encrypted\");",
          "1777:      Assert.That(entry.AESKeySize, Is.EqualTo(256), \"AES Keysize should be 256\");",
          "1779:      using (var reader = new StreamReader(f.GetInputStream(entry)))",
          "1780:      {",
          "1781:       string contents = reader.ReadToEnd();",
          "1782:       Assert.That(contents, Is.EqualTo(OriginalText), \"extract string must match original string\");",
          "1783:      }",
          "1784:     }",
          "1785:    }",
          "",
          "[Added Lines]",
          "1715:    const string originalText =",
          "1718:    var fileBytes = Convert.FromBase64String(bZip2CompressedZipCreatedBy7Zip);",
          "1720:    using var input = new MemoryStream(fileBytes, writable: false);",
          "1721:    using var zf = new ZipFile(input);",
          "1722:    zf.Password = \"password\";",
          "1724:    var entry = zf.GetEntry(\"Hello.txt\");",
          "1725:    Assert.That(entry.CompressionMethod, Is.EqualTo(CompressionMethod.BZip2), \"Compression method should be BZip2\");",
          "1726:    Assert.That(entry.Version, Is.EqualTo(ZipConstants.VERSION_AES), \"Entry version should be 51\");",
          "1727:    Assert.That(entry.IsCrypted, Is.True, \"Entry should be encrypted\");",
          "1728:    Assert.That(entry.AESKeySize, Is.EqualTo(256), \"AES Keysize should be 256\");",
          "1730:    using var reader = new StreamReader(zf.GetInputStream(entry));",
          "1731:    var contents = reader.ReadToEnd();",
          "1732:    Assert.That(contents, Is.EqualTo(originalText), \"extract string must match original string\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5b1a92b477de8841c5ed5f3dcd6e8eb80ff53bf",
      "candidate_info": {
        "commit_hash": "b5b1a92b477de8841c5ed5f3dcd6e8eb80ff53bf",
        "repo": "icsharpcode/SharpZipLib",
        "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/b5b1a92b477de8841c5ed5f3dcd6e8eb80ff53bf",
        "files": [
          "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
        ],
        "message": "fix(tar): permit slashed output dir (#666)",
        "before_after_code_files": [
          "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs||src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
          ],
          "candidate": [
            "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs"
          ]
        }
      },
      "candidate_diff": {
        "src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs||src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs": [
          "File: src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs -> src/ICSharpCode.SharpZipLib/Tar/TarArchive.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "613:     throw new ObjectDisposedException(\"TarArchive\");",
          "614:    }",
          "618:    while (true)",
          "619:    {",
          "",
          "[Removed Lines]",
          "616:    var fullDistDir = Path.GetFullPath(destinationDirectory);",
          "",
          "[Added Lines]",
          "616:    var fullDistDir = Path.GetFullPath(destinationDirectory).TrimEnd('/', '\\\\');",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs||test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Tar/TarArchiveTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:   [Test]",
          "14:   [Category(\"Tar\")]",
          "15:   [Category(\"CreatesTempFile\")]",
          "17:   {",
          "19:   }",
          "21:   [Test]",
          "",
          "[Removed Lines]",
          "16:   public void ExtractingContentsWithNonTraversalPathSucceeds()",
          "18:    Assert.DoesNotThrow(() => ExtractTarOK(\"output\", \"test-good\", allowTraverse: false));",
          "",
          "[Added Lines]",
          "16:   [TestCase(\"output\")]",
          "17:   [TestCase(\"output/\")]",
          "18:   [TestCase(@\"output\\\", IncludePlatform = \"Win\")]",
          "19:   public void ExtractingContentsWithNonTraversalPathSucceeds(string outputDir)",
          "21:    Assert.DoesNotThrow(() => ExtractTarOK(outputDir, \"file\", allowTraverse: false));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30:   [Category(\"Tar\")]",
          "31:   [Category(\"CreatesTempFile\")]",
          "32:   [TestCase(\"output\", \"../file\")]",
          "33:   [TestCase(\"output\", \"../output.txt\")]",
          "34:   public void ExtractingContentsWithDisallowedPathsFails(string outputDir, string fileName)",
          "35:   {",
          "36:    Assert.Throws<InvalidNameException>(() => ExtractTarOK(outputDir, fileName, allowTraverse: false));",
          "37:   }",
          "39:   public void ExtractTarOK(string outputDir, string fileName, bool allowTraverse)",
          "40:   {",
          "41:    var fileContent = Encoding.UTF8.GetBytes(\"file content\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:   [TestCase(\"output/\", \"../file\")]",
          "43:   [Test]",
          "44:   [Category(\"Tar\")]",
          "45:   [Category(\"CreatesTempFile\")]",
          "46:   [Platform(Include = \"Win\", Reason = \"Backslashes are only treated as path separators on windows\")]",
          "47:   [TestCase(@\"output\\\", @\"..\\file\")]",
          "48:   [TestCase(@\"output/\", @\"..\\file\")]",
          "49:   [TestCase(\"output\", @\"..\\output.txt\")]",
          "50:   [TestCase(@\"output\\\", @\"..\\output.txt\")]",
          "51:   public void ExtractingContentsOnWindowsWithDisallowedPathsFails(string outputDir, string fileName)",
          "52:   {",
          "53:    Assert.Throws<InvalidNameException>(() => ExtractTarOK(outputDir, fileName, allowTraverse: false));",
          "54:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e1e1a9111c6cb77ea72bd5771931c3b1defbd258",
      "candidate_info": {
        "commit_hash": "e1e1a9111c6cb77ea72bd5771931c3b1defbd258",
        "repo": "icsharpcode/SharpZipLib",
        "commit_url": "https://github.com/icsharpcode/SharpZipLib/commit/e1e1a9111c6cb77ea72bd5771931c3b1defbd258",
        "files": [
          "src/ICSharpCode.SharpZipLib/AssemblyInfo.cs",
          "src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs",
          "src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs",
          "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj",
          "src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs"
        ],
        "message": "feat(zip): ZipOutputStream async support (#574)\n\nCo-authored-by: C\u00e9dric Luthi <cedric.luthi@gmail.com>",
        "before_after_code_files": [
          "src/ICSharpCode.SharpZipLib/AssemblyInfo.cs||src/ICSharpCode.SharpZipLib/AssemblyInfo.cs",
          "src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs||src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs",
          "src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs||src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs",
          "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj||src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj",
          "src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs||src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs||src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs||src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs||src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs||src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs",
          "src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs||src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs||test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs||test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs",
          "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs",
          "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj"
          ],
          "candidate": [
            "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj"
          ]
        }
      },
      "candidate_diff": {
        "src/ICSharpCode.SharpZipLib/AssemblyInfo.cs||src/ICSharpCode.SharpZipLib/AssemblyInfo.cs": [
          "File: src/ICSharpCode.SharpZipLib/AssemblyInfo.cs -> src/ICSharpCode.SharpZipLib/AssemblyInfo.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \ufeffusing System.Runtime.CompilerServices;",
          "3: [assembly: InternalsVisibleTo(\"ICSharpCode.SharpZipLib.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b9a14ea8fc9d7599e0e82a1292a23103f0210e2f928a0f466963af23fffadba59dcc8c9e26ecd114d7c0b4179e4bc93b1656b7ee2d4a67dd7c1992653e0d9cc534f7914b6f583b022e0a7aa8a430f407932f9a6806f0fc64d61e78d5ae01aa8f8233196719d44da2c50a2d1cfa3f7abb7487b3567a4f0456aa6667154c6749b1\")]",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs||src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs": [
          "File: src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs -> src/ICSharpCode.SharpZipLib/Core/ByteOrderUtils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \ufeffusing System.IO;",
          "2: using System.Runtime.CompilerServices;",
          "3: using System.Threading.Tasks;",
          "4: using CT = System.Threading.CancellationToken;",
          "9: namespace ICSharpCode.SharpZipLib.Core",
          "10: {",
          "11:  internal static class ByteOrderStreamExtensions",
          "12:  {",
          "13:   internal static byte[] SwappedBytes(ushort value) => new[] {(byte)value, (byte)(value >> 8)};",
          "14:   internal static byte[] SwappedBytes(short  value) => new[] {(byte)value, (byte)(value >> 8)};",
          "15:   internal static byte[] SwappedBytes(uint   value) => new[] {(byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24)};",
          "16:   internal static byte[] SwappedBytes(int    value) => new[] {(byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24)};",
          "18:   internal static byte[] SwappedBytes(long value) => new[] {",
          "19:    (byte)value,         (byte)(value >>  8), (byte)(value >> 16), (byte)(value >> 24),",
          "20:    (byte)(value >> 32), (byte)(value >> 40), (byte)(value >> 48), (byte)(value >> 56)",
          "21:   };",
          "23:   internal static byte[] SwappedBytes(ulong value) => new[] {",
          "24:    (byte)value,         (byte)(value >>  8), (byte)(value >> 16), (byte)(value >> 24),",
          "25:    (byte)(value >> 32), (byte)(value >> 40), (byte)(value >> 48), (byte)(value >> 56)",
          "26:   };",
          "28:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "29:   internal static long SwappedS64(byte[] bytes) => (",
          "30:    (long)bytes[0] <<  0 | (long)bytes[1] <<  8 | (long)bytes[2] << 16 | (long)bytes[3] << 24 |",
          "31:    (long)bytes[4] << 32 | (long)bytes[5] << 40 | (long)bytes[6] << 48 | (long)bytes[7] << 56);",
          "33:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "34:   internal static ulong SwappedU64(byte[] bytes) => (",
          "35:    (ulong)bytes[0] <<  0 | (ulong)bytes[1] <<  8 | (ulong)bytes[2] << 16 | (ulong)bytes[3] << 24 |",
          "36:    (ulong)bytes[4] << 32 | (ulong)bytes[5] << 40 | (ulong)bytes[6] << 48 | (ulong)bytes[7] << 56);",
          "38:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "39:   internal static int SwappedS32(byte[] bytes) => bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24;",
          "41:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "42:   internal static uint SwappedU32(byte[] bytes) => (uint) SwappedS32(bytes);",
          "44:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "45:   internal static short SwappedS16(byte[] bytes) => (short)(bytes[0] | bytes[1] << 8);",
          "47:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "48:   internal static ushort SwappedU16(byte[] bytes) => (ushort) SwappedS16(bytes);",
          "50:   internal static byte[] ReadBytes(this Stream stream, int count)",
          "51:   {",
          "52:    var bytes = new byte[count];",
          "53:    var remaining = count;",
          "54:    while (remaining > 0)",
          "55:    {",
          "56:     var bytesRead = stream.Read(bytes, count - remaining, remaining);",
          "57:     if (bytesRead < 1) throw new EndOfStreamException();",
          "58:     remaining -= bytesRead;",
          "59:    }",
          "61:    return bytes;",
          "62:   }",
          "65:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "66:   public static int ReadLEShort(this Stream stream) => SwappedS16(ReadBytes(stream, 2));",
          "69:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "70:   public static int ReadLEInt(this Stream stream) => SwappedS32(ReadBytes(stream, 4));",
          "73:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "74:   public static long ReadLELong(this Stream stream) => SwappedS64(ReadBytes(stream, 8));",
          "77:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "78:   public static void WriteLEShort(this Stream stream, int value) => stream.Write(SwappedBytes(value), 0, 2);",
          "81:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "82:   public static async Task WriteLEShortAsync(this Stream stream, int value, CT ct)",
          "83:    => await stream.WriteAsync(SwappedBytes(value), 0, 2, ct);",
          "86:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "87:   public static void WriteLEUshort(this Stream stream, ushort value) => stream.Write(SwappedBytes(value), 0, 2);",
          "90:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "91:   public static async Task WriteLEUshortAsync(this Stream stream, ushort value, CT ct)",
          "92:    => await stream.WriteAsync(SwappedBytes(value), 0, 2, ct);",
          "95:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "96:   public static void WriteLEInt(this Stream stream, int value) => stream.Write(SwappedBytes(value), 0, 4);",
          "99:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "100:   public static async Task WriteLEIntAsync(this Stream stream, int value, CT ct)",
          "101:    => await stream.WriteAsync(SwappedBytes(value), 0, 4, ct);",
          "104:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "105:   public static void WriteLEUint(this Stream stream, uint value) => stream.Write(SwappedBytes(value), 0, 4);",
          "108:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "109:   public static async Task WriteLEUintAsync(this Stream stream, uint value, CT ct)",
          "110:    => await stream.WriteAsync(SwappedBytes(value), 0, 4, ct);",
          "113:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "114:   public static void WriteLELong(this Stream stream, long value) => stream.Write(SwappedBytes(value), 0, 8);",
          "117:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "118:   public static async Task WriteLELongAsync(this Stream stream, long value, CT ct)",
          "119:    => await stream.WriteAsync(SwappedBytes(value), 0, 8, ct);",
          "122:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "123:   public static void WriteLEUlong(this Stream stream, ulong value) => stream.Write(SwappedBytes(value), 0, 8);",
          "126:   [MethodImpl(MethodImplOptions.AggressiveInlining)]",
          "127:   public static async Task WriteLEUlongAsync(this Stream stream, ulong value, CT ct)",
          "128:    => await stream.WriteAsync(SwappedBytes(value), 0, 8, ct);",
          "129:  }",
          "130: }",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs||src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs": [
          "File: src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs -> src/ICSharpCode.SharpZipLib/Core/StreamUtils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: using System;",
          "2: using System.IO;",
          "4: namespace ICSharpCode.SharpZipLib.Core",
          "5: {",
          "10:  {",
          "",
          "[Removed Lines]",
          "9:  public sealed class StreamUtils",
          "",
          "[Added Lines]",
          "3: using System.Threading;",
          "4: using System.Threading.Tasks;",
          "11:  public static class StreamUtils",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18:   {",
          "19:    ReadFully(stream, buffer, 0, buffer.Length);",
          "20:   }",
          "",
          "[Removed Lines]",
          "17:   static public void ReadFully(Stream stream, byte[] buffer)",
          "",
          "[Added Lines]",
          "19:   public static void ReadFully(Stream stream, byte[] buffer)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "33:   {",
          "34:    if (stream == null)",
          "35:    {",
          "",
          "[Removed Lines]",
          "32:   static public void ReadFully(Stream stream, byte[] buffer, int offset, int count)",
          "",
          "[Added Lines]",
          "34:   public static void ReadFully(Stream stream, byte[] buffer, int offset, int count)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:   {",
          "78:    if (stream == null)",
          "79:    {",
          "",
          "[Removed Lines]",
          "76:   static public int ReadRequestedBytes(Stream stream, byte[] buffer, int offset, int count)",
          "",
          "[Added Lines]",
          "78:   public static int ReadRequestedBytes(Stream stream, byte[] buffer, int offset, int count)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "122:   {",
          "123:    if (source == null)",
          "124:    {",
          "",
          "[Removed Lines]",
          "121:   static public void Copy(Stream source, Stream destination, byte[] buffer)",
          "",
          "[Added Lines]",
          "123:   public static void Copy(Stream source, Stream destination, byte[] buffer)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "173:    byte[] buffer, ProgressHandler progressHandler, TimeSpan updateInterval, object sender, string name)",
          "174:   {",
          "175:    Copy(source, destination, buffer, progressHandler, updateInterval, sender, name, -1);",
          "",
          "[Removed Lines]",
          "172:   static public void Copy(Stream source, Stream destination,",
          "",
          "[Added Lines]",
          "174:   public static void Copy(Stream source, Stream destination,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "192:    byte[] buffer,",
          "193:    ProgressHandler progressHandler, TimeSpan updateInterval,",
          "194:    object sender, string name, long fixedTarget)",
          "",
          "[Removed Lines]",
          "191:   static public void Copy(Stream source, Stream destination,",
          "",
          "[Added Lines]",
          "193:   public static void Copy(Stream source, Stream destination,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "272:     progressHandler(sender, args);",
          "273:    }",
          "274:   }",
          "280:   {",
          "282:   }",
          "283:  }",
          "284: }",
          "",
          "[Removed Lines]",
          "279:   private StreamUtils()",
          "",
          "[Added Lines]",
          "278:   internal static async Task WriteProcToStreamAsync(this Stream targetStream, MemoryStream bufferStream, Action<Stream> writeProc, CancellationToken ct)",
          "280:    bufferStream.SetLength(0);",
          "281:    writeProc(bufferStream);",
          "282:    bufferStream.Position = 0;",
          "283:    await bufferStream.CopyToAsync(targetStream, 81920, ct);",
          "284:    bufferStream.SetLength(0);",
          "285:   }",
          "287:   internal static async Task WriteProcToStreamAsync(this Stream targetStream, Action<Stream> writeProc, CancellationToken ct)",
          "288:   {",
          "289:    using (var ms = new MemoryStream())",
          "290:    {",
          "291:     await WriteProcToStreamAsync(targetStream, ms, writeProc, ct);",
          "292:    }",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj||src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj": [
          "File: src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj -> src/ICSharpCode.SharpZipLib/ICSharpCode.SharpZipLib.csproj"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs||src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs -> src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: using System;",
          "3: using System.IO;",
          "4: using System.Security.Cryptography;",
          "6: namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams",
          "7: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: using System.Threading;",
          "6: using System.Threading.Tasks;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:      break;",
          "106:     }",
          "113:     baseOutputStream_.Write(buffer_, 0, len);",
          "114:    }",
          "",
          "[Removed Lines]",
          "108:     if (cryptoTransform_ != null)",
          "109:     {",
          "110:      EncryptBlock(buffer_, 0, len);",
          "111:     }",
          "",
          "[Added Lines]",
          "110:     EncryptBlock(buffer_, 0, len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:    }",
          "132:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140:   public virtual async Task FinishAsync(CancellationToken ct)",
          "141:   {",
          "142:    deflater_.Finish();",
          "143:    while (!deflater_.IsFinished)",
          "144:    {",
          "145:     int len = deflater_.Deflate(buffer_, 0, buffer_.Length);",
          "146:     if (len <= 0)",
          "147:     {",
          "148:      break;",
          "149:     }",
          "151:     EncryptBlock(buffer_, 0, len);",
          "153:     await baseOutputStream_.WriteAsync(buffer_, 0, len, ct);",
          "154:    }",
          "156:    if (!deflater_.IsFinished)",
          "157:    {",
          "158:     throw new SharpZipBaseException(\"Can't deflate all input?\");",
          "159:    }",
          "161:    await baseOutputStream_.FlushAsync(ct);",
          "163:    if (cryptoTransform_ != null)",
          "164:    {",
          "165:     if (cryptoTransform_ is ZipAESTransform)",
          "166:     {",
          "167:      AESAuthCode = ((ZipAESTransform)cryptoTransform_).GetAuthCode();",
          "168:     }",
          "169:     cryptoTransform_.Dispose();",
          "170:     cryptoTransform_ = null;",
          "171:    }",
          "172:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "178:   protected void EncryptBlock(byte[] buffer, int offset, int length)",
          "179:   {",
          "180:    cryptoTransform_.TransformBlock(buffer, 0, length, buffer, 0);",
          "181:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:       if(cryptoTransform_ is null) return;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "204:     {",
          "205:      break;",
          "206:     }",
          "212:     baseOutputStream_.Write(buffer_, 0, deflateCount);",
          "213:    }",
          "",
          "[Removed Lines]",
          "207:     if (cryptoTransform_ != null)",
          "208:     {",
          "209:      EncryptBlock(buffer_, 0, deflateCount);",
          "210:     }",
          "",
          "[Added Lines]",
          "249:     EncryptBlock(buffer_, 0, deflateCount);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "369:    }",
          "370:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "411: #if NETSTANDARD2_1",
          "416:   public override async ValueTask DisposeAsync()",
          "417:   {",
          "418:    if (!isClosed_)",
          "419:    {",
          "420:     isClosed_ = true;",
          "422:     try",
          "423:     {",
          "424:      await FinishAsync(CancellationToken.None);",
          "425:      if (cryptoTransform_ != null)",
          "426:      {",
          "427:       GetAuthCodeIfAES();",
          "428:       cryptoTransform_.Dispose();",
          "429:       cryptoTransform_ = null;",
          "430:      }",
          "431:     }",
          "432:     finally",
          "433:     {",
          "434:      if (IsStreamOwner)",
          "435:      {",
          "436:       await baseOutputStream_.DisposeAsync();",
          "437:      }",
          "438:     }",
          "439:    }",
          "440:   }",
          "441: #endif",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs||src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs -> src/ICSharpCode.SharpZipLib/Zip/ZipExtraData.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:   public void SetData(byte[] data, int index, int count)",
          "154:   {",
          "155:    using (MemoryStream ms = new MemoryStream(data, index, count, false))",
          "157:    {",
          "163:     if (((_flags & Flags.ModificationTime) != 0))",
          "164:     {",
          "167:      _modificationTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc) +",
          "168:       new TimeSpan(0, 0, 0, iTime, 0);",
          "",
          "[Removed Lines]",
          "156:    using (ZipHelperStream helperStream = new ZipHelperStream(ms))",
          "162:     _flags = (Flags)helperStream.ReadByte();",
          "165:      int iTime = helperStream.ReadLEInt();",
          "",
          "[Added Lines]",
          "161:     _flags = (Flags)ms.ReadByte();",
          "164:      int iTime = ms.ReadLEInt();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:     if ((_flags & Flags.AccessTime) != 0)",
          "175:     {",
          "178:      _lastAccessTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc) +",
          "179:       new TimeSpan(0, 0, 0, iTime, 0);",
          "",
          "[Removed Lines]",
          "176:      int iTime = helperStream.ReadLEInt();",
          "",
          "[Added Lines]",
          "175:      int iTime = ms.ReadLEInt();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "182:     if ((_flags & Flags.CreateTime) != 0)",
          "183:     {",
          "186:      _createTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc) +",
          "187:       new TimeSpan(0, 0, 0, iTime, 0);",
          "",
          "[Removed Lines]",
          "184:      int iTime = helperStream.ReadLEInt();",
          "",
          "[Added Lines]",
          "183:      int iTime = ms.ReadLEInt();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "196:   public byte[] GetData()",
          "197:   {",
          "198:    using (MemoryStream ms = new MemoryStream())",
          "200:    {",
          "203:     if ((_flags & Flags.ModificationTime) != 0)",
          "204:     {",
          "205:      TimeSpan span = _modificationTime - new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);",
          "206:      var seconds = (int)span.TotalSeconds;",
          "208:     }",
          "209:     if ((_flags & Flags.AccessTime) != 0)",
          "210:     {",
          "211:      TimeSpan span = _lastAccessTime - new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);",
          "212:      var seconds = (int)span.TotalSeconds;",
          "214:     }",
          "215:     if ((_flags & Flags.CreateTime) != 0)",
          "216:     {",
          "217:      TimeSpan span = _createTime - new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);",
          "218:      var seconds = (int)span.TotalSeconds;",
          "220:     }",
          "221:     return ms.ToArray();",
          "222:    }",
          "",
          "[Removed Lines]",
          "199:    using (ZipHelperStream helperStream = new ZipHelperStream(ms))",
          "201:     helperStream.IsStreamOwner = false;",
          "202:     helperStream.WriteByte((byte)_flags);     // Flags",
          "207:      helperStream.WriteLEInt(seconds);",
          "213:      helperStream.WriteLEInt(seconds);",
          "219:      helperStream.WriteLEInt(seconds);",
          "",
          "[Added Lines]",
          "199:     ms.WriteByte((byte)_flags);     // Flags",
          "204:      ms.WriteLEInt(seconds);",
          "210:      ms.WriteLEInt(seconds);",
          "216:      ms.WriteLEInt(seconds);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "342:   public void SetData(byte[] data, int index, int count)",
          "343:   {",
          "344:    using (MemoryStream ms = new MemoryStream(data, index, count, false))",
          "346:    {",
          "349:     {",
          "352:      if (ntfsTag == 1)",
          "353:      {",
          "354:       if (ntfsLength >= 24)",
          "355:       {",
          "357:        _lastModificationTime = DateTime.FromFileTimeUtc(lastModificationTicks);",
          "360:        _lastAccessTime = DateTime.FromFileTimeUtc(lastAccessTicks);",
          "363:        _createTime = DateTime.FromFileTimeUtc(createTimeTicks);",
          "364:       }",
          "365:       break;",
          "",
          "[Removed Lines]",
          "345:    using (ZipHelperStream helperStream = new ZipHelperStream(ms))",
          "347:     helperStream.ReadLEInt(); // Reserved",
          "348:     while (helperStream.Position < helperStream.Length)",
          "350:      int ntfsTag = helperStream.ReadLEShort();",
          "351:      int ntfsLength = helperStream.ReadLEShort();",
          "356:        long lastModificationTicks = helperStream.ReadLELong();",
          "359:        long lastAccessTicks = helperStream.ReadLELong();",
          "362:        long createTimeTicks = helperStream.ReadLELong();",
          "",
          "[Added Lines]",
          "343:     ms.ReadLEInt(); // Reserved",
          "344:     while (ms.Position < ms.Length)",
          "346:      int ntfsTag = ms.ReadLEShort();",
          "347:      int ntfsLength = ms.ReadLEShort();",
          "352:        long lastModificationTicks = ms.ReadLELong();",
          "355:        long lastAccessTicks = ms.ReadLELong();",
          "358:        long createTimeTicks = ms.ReadLELong();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "367:      else",
          "368:      {",
          "371:      }",
          "372:     }",
          "373:    }",
          "",
          "[Removed Lines]",
          "370:       helperStream.Seek(ntfsLength, SeekOrigin.Current);",
          "",
          "[Added Lines]",
          "366:       ms.Seek(ntfsLength, SeekOrigin.Current);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "380:   public byte[] GetData()",
          "381:   {",
          "382:    using (MemoryStream ms = new MemoryStream())",
          "384:    {",
          "392:     return ms.ToArray();",
          "393:    }",
          "394:   }",
          "",
          "[Removed Lines]",
          "383:    using (ZipHelperStream helperStream = new ZipHelperStream(ms))",
          "385:     helperStream.IsStreamOwner = false;",
          "386:     helperStream.WriteLEInt(0);       // Reserved",
          "387:     helperStream.WriteLEShort(1);     // Tag",
          "388:     helperStream.WriteLEShort(24);    // Length = 3 x 8.",
          "389:     helperStream.WriteLELong(_lastModificationTime.ToFileTimeUtc());",
          "390:     helperStream.WriteLELong(_lastAccessTime.ToFileTimeUtc());",
          "391:     helperStream.WriteLELong(_createTime.ToFileTimeUtc());",
          "",
          "[Added Lines]",
          "380:     ms.WriteLEInt(0);       // Reserved",
          "381:     ms.WriteLEShort(1);     // Tag",
          "382:     ms.WriteLEShort(24);    // Length = 3 x 8.",
          "383:     ms.WriteLELong(_lastModificationTime.ToFileTimeUtc());",
          "384:     ms.WriteLELong(_lastAccessTime.ToFileTimeUtc());",
          "385:     ms.WriteLELong(_createTime.ToFileTimeUtc());",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs||src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs -> src/ICSharpCode.SharpZipLib/Zip/ZipFile.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1004:       if ((this[entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0)",
          "1005:       {",
          "1007:        var data = new DescriptorData();",
          "1010:        if (checkCRC && this[entryIndex].Crc != data.Crc)",
          "1011:        {",
          "1012:         status.AddError();",
          "",
          "[Removed Lines]",
          "1006:        var helper = new ZipHelperStream(baseStream_);",
          "1008:        helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64, data);",
          "",
          "[Added Lines]",
          "1007:        ZipFormat.ReadDataDescriptor(baseStream_, this[entryIndex].LocalHeaderRequiresZip64, data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1582:      if (entries_.Length == 0)",
          "1583:      {",
          "1584:       byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipStrings.ConvertToArray(comment_);",
          "1589:      }",
          "1590:     }",
          "1591:    }",
          "",
          "[Removed Lines]",
          "1585:       using (ZipHelperStream zhs = new ZipHelperStream(baseStream_))",
          "1586:       {",
          "1587:        zhs.WriteEndOfCentralDirectory(0, 0, 0, theComment);",
          "1588:       }",
          "",
          "[Added Lines]",
          "1583:       ZipFormat.WriteEndOfCentralDirectory(baseStream_, 0, 0, 0, theComment);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2729:      if ((update.OutEntry.Flags & (int)GeneralBitFlags.Descriptor) == (int)GeneralBitFlags.Descriptor)",
          "2730:      {",
          "2733:      }",
          "2734:     }",
          "2735:    }",
          "",
          "[Removed Lines]",
          "2731:       var helper = new ZipHelperStream(workFile.baseStream_);",
          "2732:       helper.WriteDataDescriptor(update.OutEntry);",
          "",
          "[Added Lines]",
          "2726:       ZipFormat.WriteDataDescriptor(workFile.baseStream_, update.OutEntry);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2866:   {",
          "2867:    long baseLength = baseStream_.Length;",
          "2871:    if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)",
          "2872:    {",
          "2879:     baseStream_.Dispose();",
          "2880:     baseStream_ = null;",
          "",
          "[Removed Lines]",
          "2869:    ZipHelperStream updateFile = null;",
          "2873:     Stream copyStream = archiveStorage_.MakeTemporaryCopy(baseStream_);",
          "2874:     updateFile = new ZipHelperStream(copyStream)",
          "2875:     {",
          "2876:      IsStreamOwner = true",
          "2877:     };",
          "",
          "[Added Lines]",
          "2863:    Stream updateFile;",
          "2867:     updateFile = archiveStorage_.MakeTemporaryCopy(baseStream_);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2893:      baseStream_ = archiveStorage_.OpenForDirectUpdate(baseStream_);",
          "2895:     }",
          "2896:     else",
          "2897:     {",
          "2898:      baseStream_.Dispose();",
          "2899:      baseStream_ = null;",
          "2901:     }",
          "2902:    }",
          "2905:    {",
          "2906:     long locatedCentralDirOffset =",
          "2909:     if (locatedCentralDirOffset < 0)",
          "2910:     {",
          "2911:      throw new ZipException(\"Cannot find central directory\");",
          "",
          "[Removed Lines]",
          "2894:      updateFile = new ZipHelperStream(baseStream_);",
          "2900:      updateFile = new ZipHelperStream(Name);",
          "2904:    using (updateFile)",
          "2907:      updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature,",
          "2908:               baseLength, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);",
          "",
          "[Added Lines]",
          "2884:      updateFile = baseStream_;",
          "2890:      updateFile = new FileStream(Name, FileMode.Open, FileAccess.ReadWrite);",
          "2894:    try",
          "2897:      ZipFormat.LocateBlockWithSignature(updateFile, ZipConstants.EndOfCentralDirectorySignature,",
          "2898:       baseLength, ZipConstants.EndOfCentralRecordBaseSize, 0xffff);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2920:     updateFile.Write(rawComment, 0, rawComment.Length);",
          "2921:     updateFile.SetLength(updateFile.Position);",
          "2922:    }",
          "2924:    if (archiveStorage_.UpdateMode == FileUpdateMode.Safe)",
          "2925:    {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2913:    finally",
          "2914:    {",
          "2915:     if(updateFile != baseStream_)",
          "2916:      updateFile.Dispose();",
          "2917:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3082:     }",
          "3084:     byte[] theComment = (newComment_ != null) ? newComment_.RawComment : ZipStrings.ConvertToArray(comment_);",
          "3090:     endOfStream = workFile.baseStream_.Position;",
          "",
          "[Removed Lines]",
          "3085:     using (ZipHelperStream zhs = new ZipHelperStream(workFile.baseStream_))",
          "3086:     {",
          "3087:      zhs.WriteEndOfCentralDirectory(updateCount_, sizeEntries, centralDirOffset, theComment);",
          "3088:     }",
          "",
          "[Added Lines]",
          "3080:     ZipFormat.WriteEndOfCentralDirectory(workFile.baseStream_, updateCount_,",
          "3081:      sizeEntries, centralDirOffset, theComment);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3426:   #endregion Reading",
          "",
          "[Removed Lines]",
          "3429:   private long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)",
          "3430:   {",
          "3431:    using (ZipHelperStream les = new ZipHelperStream(baseStream_))",
          "3432:    {",
          "3433:     return les.LocateBlockWithSignature(signature, endLocation, minimumBlockSize, maximumVariableData);",
          "3434:    }",
          "3435:   }",
          "",
          "[Added Lines]",
          "3422:   private long LocateBlockWithSignature(int signature, long endLocation, int minimumBlockSize, int maximumVariableData)",
          "3423:    => ZipFormat.LocateBlockWithSignature(baseStream_, signature, endLocation, minimumBlockSize, maximumVariableData);",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs||src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs -> src/ICSharpCode.SharpZipLib/Zip/ZipFormat.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: using System;",
          "2: using System.IO;",
          "3: using System.Threading;",
          "4: using System.Threading.Tasks;",
          "5: using ICSharpCode.SharpZipLib.Core;",
          "7: namespace ICSharpCode.SharpZipLib.Zip",
          "8: {",
          "12:  public class DescriptorData",
          "13:  {",
          "14:   private long _crc;",
          "19:   public long CompressedSize { get; set; }",
          "24:   public long Size { get; set; }",
          "29:   public long Crc",
          "30:   {",
          "31:    get => _crc;",
          "32:    set => _crc = (value & 0xffffffff);",
          "33:   }",
          "34:  }",
          "36:  internal struct EntryPatchData",
          "37:  {",
          "38:   public long SizePatchOffset { get; set; }",
          "40:   public long CrcPatchOffset { get; set; }",
          "41:  }",
          "46:  internal static class ZipFormat",
          "47:  {",
          "50:   internal static int WriteLocalHeader(Stream stream, ZipEntry entry, out EntryPatchData patchData,",
          "51:    bool headerInfoAvailable, bool patchEntryHeader, long streamOffset)",
          "52:   {",
          "53:    patchData = new EntryPatchData();",
          "55:    stream.WriteLEInt(ZipConstants.LocalHeaderSignature);",
          "56:    stream.WriteLEShort(entry.Version);",
          "57:    stream.WriteLEShort(entry.Flags);",
          "58:    stream.WriteLEShort((byte)entry.CompressionMethodForHeader);",
          "59:    stream.WriteLEInt((int)entry.DosTime);",
          "61:    if (headerInfoAvailable)",
          "62:    {",
          "63:     stream.WriteLEInt((int)entry.Crc);",
          "64:     if (entry.LocalHeaderRequiresZip64)",
          "65:     {",
          "66:      stream.WriteLEInt(-1);",
          "67:      stream.WriteLEInt(-1);",
          "68:     }",
          "69:     else",
          "70:     {",
          "71:      stream.WriteLEInt((int)entry.CompressedSize + entry.EncryptionOverheadSize);",
          "72:      stream.WriteLEInt((int)entry.Size);",
          "73:     }",
          "74:    }",
          "75:    else",
          "76:    {",
          "77:     if (patchEntryHeader)",
          "78:      patchData.CrcPatchOffset = streamOffset + stream.Position;",
          "80:     stream.WriteLEInt(0);  // Crc",
          "82:     if (patchEntryHeader)",
          "83:      patchData.SizePatchOffset = streamOffset + stream.Position;",
          "86:     if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)",
          "87:     {",
          "88:      stream.WriteLEInt(-1);",
          "89:      stream.WriteLEInt(-1);",
          "90:     }",
          "91:     else",
          "92:     {",
          "93:      stream.WriteLEInt(0);  // Compressed size",
          "94:      stream.WriteLEInt(0);  // Uncompressed size",
          "95:     }",
          "96:    }",
          "98:    byte[] name = ZipStrings.ConvertToArray(entry.Flags, entry.Name);",
          "100:    if (name.Length > 0xFFFF)",
          "101:    {",
          "102:     throw new ZipException(\"Entry name too long.\");",
          "103:    }",
          "105:    var ed = new ZipExtraData(entry.ExtraData);",
          "107:    if (entry.LocalHeaderRequiresZip64)",
          "108:    {",
          "109:     ed.StartNewEntry();",
          "110:     if (headerInfoAvailable)",
          "111:     {",
          "112:      ed.AddLeLong(entry.Size);",
          "113:      ed.AddLeLong(entry.CompressedSize + entry.EncryptionOverheadSize);",
          "114:     }",
          "115:     else",
          "116:     {",
          "117:      ed.AddLeLong(-1);",
          "118:      ed.AddLeLong(-1);",
          "119:     }",
          "120:     ed.AddNewEntry(1);",
          "122:     if (!ed.Find(1))",
          "123:     {",
          "124:      throw new ZipException(\"Internal error cant find extra data\");",
          "125:     }",
          "127:     patchData.SizePatchOffset = ed.CurrentReadIndex;",
          "128:    }",
          "129:    else",
          "130:    {",
          "131:     ed.Delete(1);",
          "132:    }",
          "134:    if (entry.AESKeySize > 0)",
          "135:    {",
          "136:     AddExtraDataAES(entry, ed);",
          "137:    }",
          "138:    byte[] extra = ed.GetEntryData();",
          "140:    stream.WriteLEShort(name.Length);",
          "141:    stream.WriteLEShort(extra.Length);",
          "143:    if (name.Length > 0)",
          "144:    {",
          "145:     stream.Write(name, 0, name.Length);",
          "146:    }",
          "148:    if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)",
          "149:    {",
          "150:     patchData.SizePatchOffset += streamOffset + stream.Position;",
          "151:    }",
          "153:    if (extra.Length > 0)",
          "154:    {",
          "155:     stream.Write(extra, 0, extra.Length);",
          "156:    }",
          "158:    return ZipConstants.LocalHeaderBaseSize + name.Length + extra.Length;",
          "159:   }",
          "170:   internal static long LocateBlockWithSignature(Stream stream, int signature, long endLocation, int minimumBlockSize, int maximumVariableData)",
          "171:   {",
          "172:    long pos = endLocation - minimumBlockSize;",
          "173:    if (pos < 0)",
          "174:    {",
          "175:     return -1;",
          "176:    }",
          "178:    long giveUpMarker = Math.Max(pos - maximumVariableData, 0);",
          "181:    do",
          "182:    {",
          "183:     if (pos < giveUpMarker)",
          "184:     {",
          "185:      return -1;",
          "186:     }",
          "187:     stream.Seek(pos--, SeekOrigin.Begin);",
          "188:    } while (stream.ReadLEInt() != signature);",
          "190:    return stream.Position;",
          "191:   }",
          "194:   public static async Task WriteZip64EndOfCentralDirectoryAsync(Stream stream, long noOfEntries,",
          "195:    long sizeEntries, long centralDirOffset, CancellationToken cancellationToken)",
          "196:   {",
          "197:    await stream.WriteProcToStreamAsync(s => WriteZip64EndOfCentralDirectory(s, noOfEntries, sizeEntries, centralDirOffset), cancellationToken);",
          "198:   }",
          "207:   internal static void WriteZip64EndOfCentralDirectory(Stream stream, long noOfEntries, long sizeEntries, long centralDirOffset)",
          "208:   {",
          "209:    long centralSignatureOffset = centralDirOffset + sizeEntries;",
          "210:    stream.WriteLEInt(ZipConstants.Zip64CentralFileHeaderSignature);",
          "211:    stream.WriteLELong(44);    // Size of this record (total size of remaining fields in header or full size - 12)",
          "212:    stream.WriteLEShort(ZipConstants.VersionMadeBy);   // Version made by",
          "213:    stream.WriteLEShort(ZipConstants.VersionZip64);   // Version to extract",
          "214:    stream.WriteLEInt(0);      // Number of this disk",
          "215:    stream.WriteLEInt(0);      // number of the disk with the start of the central directory",
          "216:    stream.WriteLELong(noOfEntries);       // No of entries on this disk",
          "217:    stream.WriteLELong(noOfEntries);       // Total No of entries in central directory",
          "218:    stream.WriteLELong(sizeEntries);       // Size of the central directory",
          "219:    stream.WriteLELong(centralDirOffset);  // offset of start of central directory",
          "223:    stream.WriteLEInt(ZipConstants.Zip64CentralDirLocatorSignature);",
          "226:    stream.WriteLEInt(0);",
          "229:    stream.WriteLELong(centralSignatureOffset);",
          "232:    stream.WriteLEInt(1);",
          "233:   }",
          "236:   public static  async Task WriteEndOfCentralDirectoryAsync(Stream stream, long noOfEntries, long sizeEntries,",
          "237:    long start, byte[] comment, CancellationToken cancellationToken)",
          "238:    => await stream.WriteProcToStreamAsync(s",
          "239:     => WriteEndOfCentralDirectory(s, noOfEntries, sizeEntries, start, comment), cancellationToken);",
          "250:   internal static void WriteEndOfCentralDirectory(Stream stream, long noOfEntries, long sizeEntries, long start, byte[] comment)",
          "251:   {",
          "252:    if (noOfEntries >= 0xffff ||",
          "253:        start >= 0xffffffff ||",
          "254:        sizeEntries >= 0xffffffff)",
          "255:    {",
          "256:     WriteZip64EndOfCentralDirectory(stream, noOfEntries, sizeEntries, start);",
          "257:    }",
          "259:    stream.WriteLEInt(ZipConstants.EndOfCentralDirectorySignature);",
          "262:    stream.WriteLEShort(0);                    // number of this disk",
          "263:    stream.WriteLEShort(0);                    // no of disk with start of central dir",
          "266:    if (noOfEntries >= 0xffff)",
          "267:    {",
          "268:     stream.WriteLEUshort(0xffff);  // Zip64 marker",
          "269:     stream.WriteLEUshort(0xffff);",
          "270:    }",
          "271:    else",
          "272:    {",
          "273:     stream.WriteLEShort((short)noOfEntries);          // entries in central dir for this disk",
          "274:     stream.WriteLEShort((short)noOfEntries);          // total entries in central directory",
          "275:    }",
          "278:    if (sizeEntries >= 0xffffffff)",
          "279:    {",
          "280:     stream.WriteLEUint(0xffffffff);    // Zip64 marker",
          "281:    }",
          "282:    else",
          "283:    {",
          "284:     stream.WriteLEInt((int)sizeEntries);",
          "285:    }",
          "288:    if (start >= 0xffffffff)",
          "289:    {",
          "290:     stream.WriteLEUint(0xffffffff);    // Zip64 marker",
          "291:    }",
          "292:    else",
          "293:    {",
          "294:     stream.WriteLEInt((int)start);",
          "295:    }",
          "297:    var commentLength = comment?.Length ?? 0;",
          "299:    if (commentLength > 0xffff)",
          "300:    {",
          "301:     throw new ZipException($\"Comment length ({commentLength}) is larger than 64K\");",
          "302:    }",
          "304:    stream.WriteLEShort(commentLength);",
          "306:    if (commentLength > 0)",
          "307:    {",
          "308:     stream.Write(comment, 0, commentLength);",
          "309:    }",
          "310:   }",
          "320:   internal static int WriteDataDescriptor(Stream stream, ZipEntry entry)",
          "321:   {",
          "322:    if (entry == null)",
          "323:    {",
          "324:     throw new ArgumentNullException(nameof(entry));",
          "325:    }",
          "327:    int result = 0;",
          "330:    if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)",
          "331:    {",
          "334:     stream.WriteLEInt(ZipConstants.DataDescriptorSignature);",
          "335:     stream.WriteLEInt(unchecked((int)(entry.Crc)));",
          "337:     result += 8;",
          "339:     if (entry.LocalHeaderRequiresZip64)",
          "340:     {",
          "341:      stream.WriteLELong(entry.CompressedSize);",
          "342:      stream.WriteLELong(entry.Size);",
          "343:      result += 16;",
          "344:     }",
          "345:     else",
          "346:     {",
          "347:      stream.WriteLEInt((int)entry.CompressedSize);",
          "348:      stream.WriteLEInt((int)entry.Size);",
          "349:      result += 8;",
          "350:     }",
          "351:    }",
          "353:    return result;",
          "354:   }",
          "363:   internal static void ReadDataDescriptor(Stream stream, bool zip64, DescriptorData data)",
          "364:   {",
          "365:    int intValue = stream.ReadLEInt();",
          "369:    if (intValue != ZipConstants.DataDescriptorSignature)",
          "370:    {",
          "371:     throw new ZipException(\"Data descriptor signature not found\");",
          "372:    }",
          "374:    data.Crc = stream.ReadLEInt();",
          "376:    if (zip64)",
          "377:    {",
          "378:     data.CompressedSize = stream.ReadLELong();",
          "379:     data.Size = stream.ReadLELong();",
          "380:    }",
          "381:    else",
          "382:    {",
          "383:     data.CompressedSize = stream.ReadLEInt();",
          "384:     data.Size = stream.ReadLEInt();",
          "385:    }",
          "386:   }",
          "388:   internal static int WriteEndEntry(Stream stream, ZipEntry entry)",
          "389:   {",
          "390:    stream.WriteLEInt(ZipConstants.CentralHeaderSignature);",
          "391:    stream.WriteLEShort((entry.HostSystem << 8) | entry.VersionMadeBy);",
          "392:    stream.WriteLEShort(entry.Version);",
          "393:    stream.WriteLEShort(entry.Flags);",
          "394:    stream.WriteLEShort((short)entry.CompressionMethodForHeader);",
          "395:    stream.WriteLEInt((int)entry.DosTime);",
          "396:    stream.WriteLEInt((int)entry.Crc);",
          "398:    if (entry.IsZip64Forced() ||",
          "399:     (entry.CompressedSize >= uint.MaxValue))",
          "400:    {",
          "401:     stream.WriteLEInt(-1);",
          "402:    }",
          "403:    else",
          "404:    {",
          "405:     stream.WriteLEInt((int)entry.CompressedSize);",
          "406:    }",
          "408:    if (entry.IsZip64Forced() ||",
          "409:     (entry.Size >= uint.MaxValue))",
          "410:    {",
          "411:     stream.WriteLEInt(-1);",
          "412:    }",
          "413:    else",
          "414:    {",
          "415:     stream.WriteLEInt((int)entry.Size);",
          "416:    }",
          "418:    byte[] name = ZipStrings.ConvertToArray(entry.Flags, entry.Name);",
          "420:    if (name.Length > 0xffff)",
          "421:    {",
          "422:     throw new ZipException(\"Name too long.\");",
          "423:    }",
          "425:    var ed = new ZipExtraData(entry.ExtraData);",
          "427:    if (entry.CentralHeaderRequiresZip64)",
          "428:    {",
          "429:     ed.StartNewEntry();",
          "430:     if (entry.IsZip64Forced() ||",
          "431:      (entry.Size >= 0xffffffff))",
          "432:     {",
          "433:      ed.AddLeLong(entry.Size);",
          "434:     }",
          "436:     if (entry.IsZip64Forced() ||",
          "437:      (entry.CompressedSize >= 0xffffffff))",
          "438:     {",
          "439:      ed.AddLeLong(entry.CompressedSize);",
          "440:     }",
          "442:     if (entry.Offset >= 0xffffffff)",
          "443:     {",
          "444:      ed.AddLeLong(entry.Offset);",
          "445:     }",
          "447:     ed.AddNewEntry(1);",
          "448:    }",
          "449:    else",
          "450:    {",
          "451:     ed.Delete(1);",
          "452:    }",
          "454:    if (entry.AESKeySize > 0)",
          "455:    {",
          "456:     AddExtraDataAES(entry, ed);",
          "457:    }",
          "458:    byte[] extra = ed.GetEntryData();",
          "460:    byte[] entryComment = !(entry.Comment is null)",
          "461:     ? ZipStrings.ConvertToArray(entry.Flags, entry.Comment)",
          "462:     : Empty.Array<byte>();",
          "464:    if (entryComment.Length > 0xffff)",
          "465:    {",
          "466:     throw new ZipException(\"Comment too long.\");",
          "467:    }",
          "469:    stream.WriteLEShort(name.Length);",
          "470:    stream.WriteLEShort(extra.Length);",
          "471:    stream.WriteLEShort(entryComment.Length);",
          "472:    stream.WriteLEShort(0);    // disk number",
          "473:    stream.WriteLEShort(0);    // internal file attributes",
          "476:    if (entry.ExternalFileAttributes != -1)",
          "477:    {",
          "478:     stream.WriteLEInt(entry.ExternalFileAttributes);",
          "479:    }",
          "480:    else",
          "481:    {",
          "482:     if (entry.IsDirectory)",
          "483:     {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)",
          "484:      stream.WriteLEInt(16);",
          "485:     }",
          "486:     else",
          "487:     {",
          "488:      stream.WriteLEInt(0);",
          "489:     }",
          "490:    }",
          "492:    if (entry.Offset >= uint.MaxValue)",
          "493:    {",
          "494:     stream.WriteLEInt(-1);",
          "495:    }",
          "496:    else",
          "497:    {",
          "498:     stream.WriteLEInt((int)entry.Offset);",
          "499:    }",
          "501:    if (name.Length > 0)",
          "502:    {",
          "503:     stream.Write(name, 0, name.Length);",
          "504:    }",
          "506:    if (extra.Length > 0)",
          "507:    {",
          "508:     stream.Write(extra, 0, extra.Length);",
          "509:    }",
          "511:    if (entryComment.Length > 0)",
          "512:    {",
          "513:     stream.Write(entryComment, 0, entryComment.Length);",
          "514:    }",
          "516:    return ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;",
          "517:   }",
          "519:   internal static void AddExtraDataAES(ZipEntry entry, ZipExtraData extraData)",
          "520:   {",
          "522:    const int VENDOR_VERSION = 2;",
          "524:    const int VENDOR_ID = 0x4541; //not 6965;",
          "525:    extraData.StartNewEntry();",
          "528:    extraData.AddLeShort(VENDOR_VERSION);               // 2 = AE-2",
          "529:    extraData.AddLeShort(VENDOR_ID);                    // \"AE\"",
          "530:    extraData.AddData(entry.AESEncryptionStrength);     //  1 = 128, 2 = 192, 3 = 256",
          "531:    extraData.AddLeShort((int)entry.CompressionMethod); // The actual compression method used to compress the file",
          "532:    extraData.AddNewEntry(0x9901);",
          "533:   }",
          "535:   internal static async Task PatchLocalHeaderAsync(Stream stream, ZipEntry entry,",
          "536:    EntryPatchData patchData, CancellationToken ct)",
          "537:   {",
          "538:    var initialPos = stream.Position;",
          "541:    stream.Seek(patchData.CrcPatchOffset, SeekOrigin.Begin);",
          "542:    await stream.WriteLEIntAsync((int)entry.Crc, ct);",
          "545:    if (entry.LocalHeaderRequiresZip64)",
          "546:    {",
          "547:     if (patchData.SizePatchOffset == -1)",
          "548:     {",
          "549:      throw new ZipException(\"Entry requires zip64 but this has been turned off\");",
          "550:     }",
          "552:     stream.Seek(patchData.SizePatchOffset, SeekOrigin.Begin);",
          "555:     await stream.WriteLELongAsync(entry.Size, ct);",
          "556:     await stream.WriteLELongAsync(entry.CompressedSize, ct);",
          "557:    }",
          "558:    else",
          "559:    {",
          "560:     await stream.WriteLEIntAsync((int)entry.CompressedSize, ct);",
          "561:     await stream.WriteLEIntAsync((int)entry.Size, ct);",
          "562:    }",
          "564:    stream.Seek(initialPos, SeekOrigin.Begin);",
          "565:   }",
          "567:   internal static void PatchLocalHeaderSync(Stream stream, ZipEntry entry,",
          "568:    EntryPatchData patchData)",
          "569:   {",
          "570:    var initialPos = stream.Position;",
          "571:    stream.Seek(patchData.CrcPatchOffset, SeekOrigin.Begin);",
          "572:    stream.WriteLEInt((int)entry.Crc);",
          "574:    if (entry.LocalHeaderRequiresZip64)",
          "575:    {",
          "576:     if (patchData.SizePatchOffset == -1)",
          "577:     {",
          "578:      throw new ZipException(\"Entry requires zip64 but this has been turned off\");",
          "579:     }",
          "582:     stream.Seek(patchData.SizePatchOffset, SeekOrigin.Begin);",
          "585:     stream.WriteLELong(entry.Size);",
          "586:     stream.WriteLELong(entry.CompressedSize);",
          "587:    }",
          "588:    else",
          "589:    {",
          "590:     stream.WriteLEInt((int)entry.CompressedSize);",
          "591:     stream.WriteLEInt((int)entry.Size);",
          "592:    }",
          "594:    stream.Seek(initialPos, SeekOrigin.Begin);",
          "595:   }",
          "596:  }",
          "597: }",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs||src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs -> src/ICSharpCode.SharpZipLib/Zip/ZipHelperStream.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs||src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs": [
          "File: src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs -> src/ICSharpCode.SharpZipLib/Zip/ZipOutputStream.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: using System.Collections.Generic;",
          "8: using System.IO;",
          "9: using System.Security.Cryptography;",
          "11: namespace ICSharpCode.SharpZipLib.Zip",
          "12: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: using System.Threading;",
          "11: using System.Threading.Tasks;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218:   private void TransformEntryName(ZipEntry entry)",
          "219:   {",
          "231:   }",
          "",
          "[Removed Lines]",
          "220:    if (this.NameTransform != null)",
          "221:    {",
          "222:     if (entry.IsDirectory)",
          "223:     {",
          "224:      entry.Name = this.NameTransform.TransformDirectory(entry.Name);",
          "225:     }",
          "226:     else",
          "227:     {",
          "228:      entry.Name = this.NameTransform.TransformFile(entry.Name);",
          "229:     }",
          "230:    }",
          "",
          "[Added Lines]",
          "222:    if (NameTransform == null) return;",
          "223:    entry.Name = entry.IsDirectory",
          "224:     ? NameTransform.TransformDirectory(entry.Name)",
          "225:     : NameTransform.TransformFile(entry.Name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "260:   public void PutNextEntry(ZipEntry entry)",
          "261:   {",
          "262:    if (entry == null)",
          "263:    {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "256:   {",
          "257:    if (curEntry != null)",
          "258:    {",
          "259:     CloseEntry();",
          "260:    }",
          "262:    PutNextEntry(baseOutputStream_, entry);",
          "264:    if (entry.IsCrypted)",
          "265:    {",
          "266:     WriteOutput(GetEntryEncryptionHeader(entry));",
          "267:    }",
          "268:   }",
          "270:   private void WriteOutput(byte[] bytes)",
          "271:    => baseOutputStream_.Write(bytes, 0, bytes.Length);",
          "273:   private Task WriteOutputAsync(byte[] bytes)",
          "274:    => baseOutputStream_.WriteAsync(bytes, 0, bytes.Length);",
          "276:   private byte[] GetEntryEncryptionHeader(ZipEntry entry) =>",
          "277:    entry.AESKeySize > 0",
          "278:     ? InitializeAESPassword(entry, Password)",
          "279:     : CreateZipCryptoHeader(entry.Crc < 0 ? entry.DosTime << 16 : entry.Crc);",
          "281:   internal void PutNextEntry(Stream stream, ZipEntry entry, long streamOffset = 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "269:     throw new InvalidOperationException(\"ZipOutputStream was finished\");",
          "270:    }",
          "277:    if (entries.Count == int.MaxValue)",
          "278:    {",
          "279:     throw new ZipException(\"Too many entries for Zip file\");",
          "",
          "[Removed Lines]",
          "272:    if (curEntry != null)",
          "273:    {",
          "274:     CloseEntry();",
          "275:    }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "365:    entry.CompressionMethod = (CompressionMethod)method;",
          "367:    curMethod = method;",
          "370:    if ((useZip64_ == UseZip64.On) || ((entry.Size < 0) && (useZip64_ == UseZip64.Dynamic)))",
          "371:    {",
          "372:     entry.ForceZip64();",
          "373:    }",
          "425:    TransformEntryName(entry);",
          "491:    if (entry.AESKeySize > 0)",
          "492:     offset += entry.AESOverheadSize;",
          "",
          "[Removed Lines]",
          "368:    sizePatchPos = -1;",
          "376:    WriteLeInt(ZipConstants.LocalHeaderSignature);",
          "378:    WriteLeShort(entry.Version);",
          "379:    WriteLeShort(entry.Flags);",
          "380:    WriteLeShort((byte)entry.CompressionMethodForHeader);",
          "381:    WriteLeInt((int)entry.DosTime);",
          "384:    if (headerInfoAvailable)",
          "385:    {",
          "386:     WriteLeInt((int)entry.Crc);",
          "387:     if (entry.LocalHeaderRequiresZip64)",
          "388:     {",
          "389:      WriteLeInt(-1);",
          "390:      WriteLeInt(-1);",
          "391:     }",
          "392:     else",
          "393:     {",
          "394:      WriteLeInt((int)entry.CompressedSize + entry.EncryptionOverheadSize);",
          "395:      WriteLeInt((int)entry.Size);",
          "396:     }",
          "397:    }",
          "398:    else",
          "399:    {",
          "400:     if (patchEntryHeader)",
          "401:     {",
          "402:      crcPatchPos = baseOutputStream_.Position;",
          "403:     }",
          "404:     WriteLeInt(0);  // Crc",
          "406:     if (patchEntryHeader)",
          "407:     {",
          "408:      sizePatchPos = baseOutputStream_.Position;",
          "409:     }",
          "412:     if (entry.LocalHeaderRequiresZip64 || patchEntryHeader)",
          "413:     {",
          "414:      WriteLeInt(-1);",
          "415:      WriteLeInt(-1);",
          "416:     }",
          "417:     else",
          "418:     {",
          "419:      WriteLeInt(0);  // Compressed size",
          "420:      WriteLeInt(0);  // Uncompressed size",
          "421:     }",
          "422:    }",
          "426:    byte[] name = ZipStrings.ConvertToArray(entry.Flags, entry.Name);",
          "428:    if (name.Length > 0xFFFF)",
          "429:    {",
          "430:     throw new ZipException(\"Entry name too long.\");",
          "431:    }",
          "433:    var ed = new ZipExtraData(entry.ExtraData);",
          "435:    if (entry.LocalHeaderRequiresZip64)",
          "436:    {",
          "437:     ed.StartNewEntry();",
          "438:     if (headerInfoAvailable)",
          "439:     {",
          "440:      ed.AddLeLong(entry.Size);",
          "441:      ed.AddLeLong(entry.CompressedSize + entry.EncryptionOverheadSize);",
          "442:     }",
          "443:     else",
          "444:     {",
          "445:      ed.AddLeLong(-1);",
          "446:      ed.AddLeLong(-1);",
          "447:     }",
          "448:     ed.AddNewEntry(1);",
          "450:     if (!ed.Find(1))",
          "451:     {",
          "452:      throw new ZipException(\"Internal error cant find extra data\");",
          "453:     }",
          "455:     if (patchEntryHeader)",
          "456:     {",
          "457:      sizePatchPos = ed.CurrentReadIndex;",
          "458:     }",
          "459:    }",
          "460:    else",
          "461:    {",
          "462:     ed.Delete(1);",
          "463:    }",
          "465:    if (entry.AESKeySize > 0)",
          "466:    {",
          "467:     AddExtraDataAES(entry, ed);",
          "468:    }",
          "469:    byte[] extra = ed.GetEntryData();",
          "471:    WriteLeShort(name.Length);",
          "472:    WriteLeShort(extra.Length);",
          "474:    if (name.Length > 0)",
          "475:    {",
          "476:     baseOutputStream_.Write(name, 0, name.Length);",
          "477:    }",
          "479:    if (entry.LocalHeaderRequiresZip64 && patchEntryHeader)",
          "480:    {",
          "481:     sizePatchPos += baseOutputStream_.Position;",
          "482:    }",
          "484:    if (extra.Length > 0)",
          "485:    {",
          "486:     baseOutputStream_.Write(extra, 0, extra.Length);",
          "487:    }",
          "489:    offset += ZipConstants.LocalHeaderBaseSize + name.Length + extra.Length;",
          "",
          "[Added Lines]",
          "394:    offset += ZipFormat.WriteLocalHeader(stream, entry, out var entryPatchData,",
          "395:     headerInfoAvailable, patchEntryHeader, streamOffset);",
          "397:    patchData = entryPatchData;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "500:     deflater_.SetLevel(compressionLevel);",
          "501:    }",
          "502:    size = 0;",
          "522:   }",
          "",
          "[Removed Lines]",
          "504:    if (entry.IsCrypted)",
          "505:    {",
          "506:     if (entry.AESKeySize > 0)",
          "507:     {",
          "508:      WriteAESHeader(entry);",
          "509:     }",
          "510:     else",
          "511:     {",
          "512:      if (entry.Crc < 0)",
          "513:      {            // so testing Zip will says its ok",
          "514:       WriteEncryptionHeader(entry.DosTime << 16);",
          "515:      }",
          "516:      else",
          "517:      {",
          "518:       WriteEncryptionHeader(entry.Crc);",
          "519:      }",
          "520:     }",
          "521:    }",
          "",
          "[Added Lines]",
          "413:   }",
          "443:   public async Task PutNextEntryAsync(ZipEntry entry, CancellationToken ct = default)",
          "444:   {",
          "445:    if (curEntry != null) await CloseEntryAsync(ct);",
          "446:    await baseOutputStream_.WriteProcToStreamAsync(s =>",
          "447:    {",
          "448:     PutNextEntry(s, entry, baseOutputStream_.Position);",
          "449:    }, ct);",
          "451:    if (!entry.IsCrypted) return;",
          "452:    await WriteOutputAsync(GetEntryEncryptionHeader(entry));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "536:   public void CloseEntry()",
          "537:   {",
          "538:    if (curEntry == null)",
          "539:    {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468:   {",
          "469:    WriteEntryFooter(baseOutputStream_);",
          "472:    if (patchEntryHeader)",
          "473:    {",
          "474:     patchEntryHeader = false;",
          "475:     ZipFormat.PatchLocalHeaderSync(baseOutputStream_, curEntry, patchData);",
          "476:    }",
          "478:    entries.Add(curEntry);",
          "479:    curEntry = null;",
          "480:   }",
          "483:   public async Task CloseEntryAsync(CancellationToken ct)",
          "484:   {",
          "485:    await baseOutputStream_.WriteProcToStreamAsync(WriteEntryFooter, ct);",
          "488:    if (patchEntryHeader)",
          "489:    {",
          "490:     patchEntryHeader = false;",
          "491:     await ZipFormat.PatchLocalHeaderAsync(baseOutputStream_, curEntry, patchData, ct);",
          "492:    }",
          "494:    entries.Add(curEntry);",
          "495:    curEntry = null;",
          "496:   }",
          "498:   internal void WriteEntryFooter(Stream stream)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "566:    if (curEntry.AESKeySize > 0)",
          "567:    {",
          "570:     curEntry.Crc = 0;",
          "571:    }",
          "",
          "[Removed Lines]",
          "568:     baseOutputStream_.Write(AESAuthCode, 0, 10);",
          "",
          "[Added Lines]",
          "530:     stream.Write(AESAuthCode, 0, 10);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "606:     curEntry.CompressedSize += curEntry.EncryptionOverheadSize;",
          "607:    }",
          "638:    if ((curEntry.Flags & 8) != 0)",
          "639:    {",
          "643:     if (curEntry.LocalHeaderRequiresZip64)",
          "644:     {",
          "647:      offset += ZipConstants.Zip64DataDescriptorSize;",
          "648:     }",
          "649:     else",
          "650:     {",
          "653:      offset += ZipConstants.DataDescriptorSize;",
          "654:     }",
          "655:    }",
          "659:   }",
          "677:   {",
          "681:    _aesRnd.GetBytes(salt);",
          "683:    int blockSize = entry.AESKeySize / 8;   // bits to bytes",
          "685:    cryptoTransform_ = new ZipAESTransform(rawPassword, salt, blockSize, true);",
          "690:   {",
          "691:    offset += ZipConstants.CryptoHeaderSize;",
          "695:    byte[] cryptBuffer = new byte[ZipConstants.CryptoHeaderSize];",
          "696:    using (var rng = new RNGCryptoServiceProvider())",
          "",
          "[Removed Lines]",
          "610:    if (patchEntryHeader)",
          "611:    {",
          "612:     patchEntryHeader = false;",
          "614:     long curPos = baseOutputStream_.Position;",
          "615:     baseOutputStream_.Seek(crcPatchPos, SeekOrigin.Begin);",
          "616:     WriteLeInt((int)curEntry.Crc);",
          "618:     if (curEntry.LocalHeaderRequiresZip64)",
          "619:     {",
          "620:      if (sizePatchPos == -1)",
          "621:      {",
          "622:       throw new ZipException(\"Entry requires zip64 but this has been turned off\");",
          "623:      }",
          "625:      baseOutputStream_.Seek(sizePatchPos, SeekOrigin.Begin);",
          "626:      WriteLeLong(curEntry.Size);",
          "627:      WriteLeLong(curEntry.CompressedSize);",
          "628:     }",
          "629:     else",
          "630:     {",
          "631:      WriteLeInt((int)curEntry.CompressedSize);",
          "632:      WriteLeInt((int)curEntry.Size);",
          "633:     }",
          "634:     baseOutputStream_.Seek(curPos, SeekOrigin.Begin);",
          "635:    }",
          "640:     WriteLeInt(ZipConstants.DataDescriptorSignature);",
          "641:     WriteLeInt(unchecked((int)curEntry.Crc));",
          "645:      WriteLeLong(curEntry.CompressedSize);",
          "646:      WriteLeLong(curEntry.Size);",
          "651:      WriteLeInt((int)curEntry.CompressedSize);",
          "652:      WriteLeInt((int)curEntry.Size);",
          "657:    entries.Add(curEntry);",
          "658:    curEntry = null;",
          "665:   private void InitializePassword(string password)",
          "666:   {",
          "667:    var pkManaged = new PkzipClassicManaged();",
          "668:    byte[] key = PkzipClassic.GenerateKeys(ZipStrings.ConvertToArray(password));",
          "669:    cryptoTransform_ = pkManaged.CreateEncryptor(key, null);",
          "670:   }",
          "675:   private void InitializeAESPassword(ZipEntry entry, string rawPassword,",
          "676:            out byte[] salt, out byte[] pwdVerifier)",
          "678:    salt = new byte[entry.AESSaltLen];",
          "686:    pwdVerifier = ((ZipAESTransform)cryptoTransform_).PwdVerifier;",
          "687:   }",
          "689:   private void WriteEncryptionHeader(long crcValue)",
          "693:    InitializePassword(Password);",
          "",
          "[Added Lines]",
          "574:     stream.WriteLEInt(ZipConstants.DataDescriptorSignature);",
          "575:     stream.WriteLEInt(unchecked((int)curEntry.Crc));",
          "579:      stream.WriteLELong(curEntry.CompressedSize);",
          "580:      stream.WriteLELong(curEntry.Size);",
          "585:      stream.WriteLEInt((int)curEntry.CompressedSize);",
          "586:      stream.WriteLEInt((int)curEntry.Size);",
          "609:   protected byte[] InitializeAESPassword(ZipEntry entry, string rawPassword)",
          "611:    var salt = new byte[entry.AESSaltLen];",
          "613:    if (_aesRnd == null)",
          "614:     _aesRnd = RandomNumberGenerator.Create();",
          "620:    var headBytes = new byte[salt.Length + 2];",
          "622:    Array.Copy(salt, headBytes, salt.Length);",
          "623:    Array.Copy(((ZipAESTransform)cryptoTransform_).PwdVerifier, 0,",
          "624:     headBytes, headBytes.Length - 2, 2);",
          "626:    return headBytes;",
          "627:   }",
          "629:   private byte[] CreateZipCryptoHeader(long crcValue)",
          "633:    InitializeZipCryptoPassword(Password);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "701:    cryptBuffer[11] = (byte)(crcValue >> 24);",
          "703:    EncryptBlock(cryptBuffer, 0, cryptBuffer.Length);",
          "721:   }",
          "726:   {",
          "743:   }",
          "",
          "[Removed Lines]",
          "704:    baseOutputStream_.Write(cryptBuffer, 0, cryptBuffer.Length);",
          "705:   }",
          "707:   private static void AddExtraDataAES(ZipEntry entry, ZipExtraData extraData)",
          "708:   {",
          "710:    const int VENDOR_VERSION = 2;",
          "712:    const int VENDOR_ID = 0x4541; //not 6965;",
          "713:    extraData.StartNewEntry();",
          "716:    extraData.AddLeShort(VENDOR_VERSION);               // 2 = AE-2",
          "717:    extraData.AddLeShort(VENDOR_ID);                    // \"AE\"",
          "718:    extraData.AddData(entry.AESEncryptionStrength);     //  1 = 128, 2 = 192, 3 = 256",
          "719:    extraData.AddLeShort((int)entry.CompressionMethod); // The actual compression method used to compress the file",
          "720:    extraData.AddNewEntry(0x9901);",
          "725:   private void WriteAESHeader(ZipEntry entry)",
          "727:    byte[] salt;",
          "728:    byte[] pwdVerifier;",
          "729:    InitializeAESPassword(entry, Password, out salt, out pwdVerifier);",
          "741:    baseOutputStream_.Write(salt, 0, salt.Length);",
          "742:    baseOutputStream_.Write(pwdVerifier, 0, pwdVerifier.Length);",
          "",
          "[Added Lines]",
          "645:    return cryptBuffer;",
          "652:   private void InitializeZipCryptoPassword(string password)",
          "654:    var pkManaged = new PkzipClassicManaged();",
          "655:    byte[] key = PkzipClassic.GenerateKeys(ZipStrings.ConvertToArray(password));",
          "656:    cryptoTransform_ = pkManaged.CreateEncryptor(key, null);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "849:    long numEntries = entries.Count;",
          "850:    long sizeEntries = 0;",
          "853:    {",
          "919:     {",
          "921:     }",
          "930:     {",
          "932:     }",
          "942:     {",
          "952:      {",
          "964:     }",
          "982:    }",
          "990:   }",
          "",
          "[Removed Lines]",
          "852:    foreach (ZipEntry entry in entries)",
          "854:     WriteLeInt(ZipConstants.CentralHeaderSignature);",
          "855:     WriteLeShort((entry.HostSystem << 8) | entry.VersionMadeBy);",
          "856:     WriteLeShort(entry.Version);",
          "857:     WriteLeShort(entry.Flags);",
          "858:     WriteLeShort((short)entry.CompressionMethodForHeader);",
          "859:     WriteLeInt((int)entry.DosTime);",
          "860:     WriteLeInt((int)entry.Crc);",
          "862:     if (entry.IsZip64Forced() ||",
          "863:      (entry.CompressedSize >= uint.MaxValue))",
          "864:     {",
          "865:      WriteLeInt(-1);",
          "866:     }",
          "867:     else",
          "868:     {",
          "869:      WriteLeInt((int)entry.CompressedSize);",
          "870:     }",
          "872:     if (entry.IsZip64Forced() ||",
          "873:      (entry.Size >= uint.MaxValue))",
          "874:     {",
          "875:      WriteLeInt(-1);",
          "876:     }",
          "877:     else",
          "878:     {",
          "879:      WriteLeInt((int)entry.Size);",
          "880:     }",
          "882:     byte[] name = ZipStrings.ConvertToArray(entry.Flags, entry.Name);",
          "884:     if (name.Length > 0xffff)",
          "885:     {",
          "886:      throw new ZipException(\"Name too long.\");",
          "887:     }",
          "889:     var ed = new ZipExtraData(entry.ExtraData);",
          "891:     if (entry.CentralHeaderRequiresZip64)",
          "892:     {",
          "893:      ed.StartNewEntry();",
          "894:      if (entry.IsZip64Forced() ||",
          "895:       (entry.Size >= 0xffffffff))",
          "896:      {",
          "897:       ed.AddLeLong(entry.Size);",
          "898:      }",
          "900:      if (entry.IsZip64Forced() ||",
          "901:       (entry.CompressedSize >= 0xffffffff))",
          "902:      {",
          "903:       ed.AddLeLong(entry.CompressedSize);",
          "904:      }",
          "906:      if (entry.Offset >= 0xffffffff)",
          "907:      {",
          "908:       ed.AddLeLong(entry.Offset);",
          "909:      }",
          "911:      ed.AddNewEntry(1);",
          "912:     }",
          "913:     else",
          "914:     {",
          "915:      ed.Delete(1);",
          "916:     }",
          "918:     if (entry.AESKeySize > 0)",
          "920:      AddExtraDataAES(entry, ed);",
          "922:     byte[] extra = ed.GetEntryData();",
          "924:     byte[] entryComment =",
          "925:      (entry.Comment != null) ?",
          "926:      ZipStrings.ConvertToArray(entry.Flags, entry.Comment) :",
          "927:      Empty.Array<byte>();",
          "929:     if (entryComment.Length > 0xffff)",
          "931:      throw new ZipException(\"Comment too long.\");",
          "934:     WriteLeShort(name.Length);",
          "935:     WriteLeShort(extra.Length);",
          "936:     WriteLeShort(entryComment.Length);",
          "937:     WriteLeShort(0);    // disk number",
          "938:     WriteLeShort(0);    // internal file attributes",
          "941:     if (entry.ExternalFileAttributes != -1)",
          "943:      WriteLeInt(entry.ExternalFileAttributes);",
          "944:     }",
          "945:     else",
          "946:     {",
          "947:      if (entry.IsDirectory)",
          "948:      {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)",
          "949:       WriteLeInt(16);",
          "950:      }",
          "951:      else",
          "953:       WriteLeInt(0);",
          "954:      }",
          "955:     }",
          "957:     if (entry.Offset >= uint.MaxValue)",
          "958:     {",
          "959:      WriteLeInt(-1);",
          "960:     }",
          "961:     else",
          "962:     {",
          "963:      WriteLeInt((int)entry.Offset);",
          "966:     if (name.Length > 0)",
          "967:     {",
          "968:      baseOutputStream_.Write(name, 0, name.Length);",
          "969:     }",
          "971:     if (extra.Length > 0)",
          "972:     {",
          "973:      baseOutputStream_.Write(extra, 0, extra.Length);",
          "974:     }",
          "976:     if (entryComment.Length > 0)",
          "977:     {",
          "978:      baseOutputStream_.Write(entryComment, 0, entryComment.Length);",
          "979:     }",
          "981:     sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;",
          "984:    using (ZipHelperStream zhs = new ZipHelperStream(baseOutputStream_))",
          "985:    {",
          "986:     zhs.WriteEndOfCentralDirectory(numEntries, sizeEntries, offset, zipComment);",
          "987:    }",
          "989:    entries = null;",
          "",
          "[Added Lines]",
          "766:    foreach (var entry in entries)",
          "768:     sizeEntries += ZipFormat.WriteEndEntry(baseOutputStream_, entry);",
          "769:    }",
          "771:    ZipFormat.WriteEndOfCentralDirectory(baseOutputStream_, numEntries, sizeEntries, offset, zipComment);",
          "773:    entries = null;",
          "774:   }",
          "777:   public override async Task FinishAsync(CancellationToken ct)",
          "778:   {",
          "779:    using (var ms = new MemoryStream())",
          "780:    {",
          "781:     if (entries == null)",
          "783:      return;",
          "786:     if (curEntry != null)",
          "788:      await CloseEntryAsync(ct);",
          "791:     long numEntries = entries.Count;",
          "792:     long sizeEntries = 0;",
          "794:     foreach (var entry in entries)",
          "796:      await baseOutputStream_.WriteProcToStreamAsync(ms, s =>",
          "798:       sizeEntries += ZipFormat.WriteEndEntry(s, entry);",
          "799:      }, ct);",
          "802:     await baseOutputStream_.WriteProcToStreamAsync(ms, s",
          "803:       => ZipFormat.WriteEndOfCentralDirectory(s, numEntries, sizeEntries, offset, zipComment),",
          "804:      ct);",
          "806:     entries = null;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1047:   private bool patchEntryHeader;",
          "",
          "[Removed Lines]",
          "1052:   private long crcPatchPos = -1;",
          "1057:   private long sizePatchPos = -1;",
          "",
          "[Added Lines]",
          "870:   private EntryPatchData patchData;",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs||test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Base/InflaterDeflaterTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: using System.IO;",
          "7: using System.Security;",
          "8: using System.Text;",
          "9: using System.Threading.Tasks;",
          "11: namespace ICSharpCode.SharpZipLib.Tests.Base",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: using System.Threading;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:     outStream.IsStreamOwner = false;",
          "114:     await outStream.WriteAsync(data, 0, data.Length);",
          "115:     await outStream.FlushAsync();",
          "117:    }",
          "118:    return memoryStream;",
          "119:   }",
          "",
          "[Removed Lines]",
          "116:     outStream.Finish();",
          "",
          "[Added Lines]",
          "117:     await outStream.FinishAsync(CancellationToken.None);",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs||test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Core/ByteOrderUtilsTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \ufeffusing System;",
          "2: using System.IO;",
          "3: using System.Threading;",
          "4: using System.Threading.Tasks;",
          "5: using NUnit.Framework;",
          "6: using BO = ICSharpCode.SharpZipLib.Core.ByteOrderStreamExtensions;",
          "7: using ICSharpCode.SharpZipLib.Core;",
          "11: namespace ICSharpCode.SharpZipLib.Tests.Core",
          "12: {",
          "13:  [TestFixture]",
          "14:  [Category(\"Core\")]",
          "15:  public class ByteOrderUtilsTests",
          "16:  {",
          "17:   private const short native16 = 0x1234;",
          "18:   private static readonly byte[] swapped16 = { 0x34, 0x12 };",
          "20:   private const int native32 = 0x12345678;",
          "21:   private static readonly byte[] swapped32 = { 0x78, 0x56, 0x34, 0x12 };",
          "23:   private const long native64 = 0x123456789abcdef0;",
          "24:   private static readonly byte[] swapped64 = { 0xf0, 0xde, 0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12 };",
          "26:   [Test]",
          "27:   public void ToSwappedBytes()",
          "28:   {",
          "29:    Assert.AreEqual(swapped16, BO.SwappedBytes(native16));",
          "30:    Assert.AreEqual(swapped16, BO.SwappedBytes((ushort)native16));",
          "32:    Assert.AreEqual(swapped32, BO.SwappedBytes(native32));",
          "33:    Assert.AreEqual(swapped32, BO.SwappedBytes((uint)native32));",
          "35:    Assert.AreEqual(swapped64, BO.SwappedBytes(native64));",
          "36:    Assert.AreEqual(swapped64, BO.SwappedBytes((ulong)native64));",
          "37:   }",
          "39:   [Test]",
          "40:   public void FromSwappedBytes()",
          "41:   {",
          "42:    Assert.AreEqual(native16, BO.SwappedS16(swapped16));",
          "43:    Assert.AreEqual(native16, BO.SwappedU16(swapped16));",
          "45:    Assert.AreEqual(native32, BO.SwappedS32(swapped32));",
          "46:    Assert.AreEqual(native32, BO.SwappedU32(swapped32));",
          "48:    Assert.AreEqual(native64, BO.SwappedS64(swapped64));",
          "49:    Assert.AreEqual(native64, BO.SwappedU64(swapped64));",
          "50:   }",
          "52:   [Test]",
          "53:   public void ReadLESigned16()",
          "54:    => TestReadLE(native16, 2, BO.ReadLEShort);",
          "56:   [Test]",
          "57:   public void ReadLESigned32()",
          "58:    => TestReadLE(native32,4, BO.ReadLEInt);",
          "60:   [Test]",
          "61:   public void ReadLESigned64()",
          "62:    => TestReadLE(native64,8, BO.ReadLELong);",
          "64:   [Test]",
          "65:   public void WriteLESigned16()",
          "66:    => TestWriteLE(swapped16, s => s.WriteLEShort(native16));",
          "68:   [Test]",
          "69:   public void WriteLESigned32()",
          "70:    => TestWriteLE(swapped32, s => s.WriteLEInt(native32));",
          "72:   [Test]",
          "73:   public void WriteLESigned64()",
          "74:    => TestWriteLE(swapped64, s => s.WriteLELong(native64));",
          "76:   [Test]",
          "77:   public void WriteLEUnsigned16()",
          "78:    => TestWriteLE(swapped16, s => s.WriteLEUshort((ushort)native16));",
          "80:   [Test]",
          "81:   public void WriteLEUnsigned32()",
          "82:    => TestWriteLE(swapped32, s => s.WriteLEUint(native32));",
          "84:   [Test]",
          "85:   public void WriteLEUnsigned64()",
          "86:    => TestWriteLE(swapped64, s => s.WriteLEUlong(native64));",
          "88:   [Test]",
          "89:   public async Task WriteLEAsyncSigned16()",
          "90:    => await TestWriteLEAsync(swapped16, (int)native16, BO.WriteLEShortAsync);",
          "92:   [Test]",
          "93:   public async Task WriteLEAsyncUnsigned16()",
          "94:    => await TestWriteLEAsync(swapped16, (ushort)native16, BO.WriteLEUshortAsync);",
          "96:   [Test]",
          "97:   public async Task WriteLEAsyncSigned32()",
          "98:    => await TestWriteLEAsync(swapped32, native32, BO.WriteLEIntAsync);",
          "99:   [Test]",
          "100:   public async Task WriteLEAsyncUnsigned32()",
          "101:    => await TestWriteLEAsync(swapped32, (uint)native32, BO.WriteLEUintAsync);",
          "103:   [Test]",
          "104:   public async Task WriteLEAsyncSigned64()",
          "105:    => await TestWriteLEAsync(swapped64, native64, BO.WriteLELongAsync);",
          "106:   [Test]",
          "107:   public async Task WriteLEAsyncUnsigned64()",
          "108:    => await TestWriteLEAsync(swapped64, (ulong)native64, BO.WriteLEUlongAsync);",
          "111:   private static void TestReadLE<T>(T expected, int bytes, Func<Stream, T> read)",
          "112:   {",
          "113:    using (var ms = new MemoryStream(swapped64, 8 - bytes, bytes))",
          "114:    {",
          "115:     Assert.AreEqual(expected, read(ms));",
          "116:    }",
          "117:   }",
          "119:   private static void TestWriteLE(byte[] expected, Action<Stream> write)",
          "120:   {",
          "121:    using (var ms = new MemoryStream())",
          "122:    {",
          "123:     write(ms);",
          "124:     Assert.AreEqual(expected, ms.ToArray());",
          "125:    }",
          "126:   }",
          "128:   private static async Task TestWriteLEAsync<T>(byte[] expected, T input, Func<Stream, T, CancellationToken, Task> write)",
          "129:   {",
          "130:    using (var ms = new MemoryStream())",
          "131:    {",
          "132:     await write(ms, input, CancellationToken.None);",
          "133:     Assert.AreEqual(expected, ms.ToArray());",
          "134:    }",
          "135:   }",
          "136:  }",
          "137: }",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj||test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj": [
          "File: test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj -> test/ICSharpCode.SharpZipLib.Tests/ICSharpCode.SharpZipLib.Tests.csproj",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:   <TargetFrameworks>netcoreapp3.1;net46</TargetFrameworks>",
          "6:     <ApplicationIcon />",
          "7:     <StartupObject />",
          "9:   </PropertyGroup>",
          "11:   <ItemGroup>",
          "",
          "[Removed Lines]",
          "8:   <LangVersion>8</LangVersion>",
          "",
          "[Added Lines]",
          "8:     <SignAssembly>true</SignAssembly>",
          "9:     <AssemblyOriginatorKeyFile>..\\..\\assets\\ICSharpCode.SharpZipLib.snk</AssemblyOriginatorKeyFile>",
          "10:     <PublicSign>true</PublicSign>",
          "11:   <LangVersion>8.0</LangVersion>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25:     <Service Include=\"{82a7f48d-3b50-4b1e-b82e-3ada8210c358}\" />",
          "26:   </ItemGroup>",
          "28: </Project>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31:   <ItemGroup>",
          "32:     <None Include=\"..\\..\\assets\\ICSharpCode.SharpZipLib.snk\">",
          "33:       <Link>ICSharpCode.SharpZipLib.snk</Link>",
          "34:     </None>",
          "35:   </ItemGroup>",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs -> test/ICSharpCode.SharpZipLib.Tests/TestSupport/Utils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: using System;",
          "3: using System.IO;",
          "4: using System.Linq;",
          "6: namespace ICSharpCode.SharpZipLib.Tests.TestSupport",
          "7: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: using System.Text;",
          "6: using System.Threading.Tasks;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:    random.NextBytes(bytes);",
          "77:    return bytes;",
          "78:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:   public static async Task WriteDummyDataAsync(Stream stream, int size = -1)",
          "83:   {",
          "84:    var bytes = GetDummyBytes(size);",
          "85:    await stream.WriteAsync(bytes, 0, bytes.Length);",
          "86:   }",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs||test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs -> test/ICSharpCode.SharpZipLib.Tests/TestSupport/ZipTesting.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: using ICSharpCode.SharpZipLib.Zip;",
          "2: using System.IO;",
          "4: namespace ICSharpCode.SharpZipLib.Tests.TestSupport",
          "5: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: using System;",
          "4: using NUnit.Framework;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9:  internal static class ZipTesting",
          "10:  {",
          "17:   {",
          "19:   }",
          "28:   {",
          "31:    {",
          "35:   }",
          "36:  }",
          "37: }",
          "",
          "[Removed Lines]",
          "16:   public static bool TestArchive(byte[] data)",
          "18:    return TestArchive(data, null);",
          "27:   public static bool TestArchive(byte[] data, string password)",
          "29:    using (MemoryStream ms = new MemoryStream(data))",
          "30:    using (ZipFile zipFile = new ZipFile(ms))",
          "32:     zipFile.Password = password;",
          "33:     return zipFile.TestArchive(true);",
          "34:    }",
          "",
          "[Added Lines]",
          "13:   public static void AssertValidZip(Stream stream, string password = null, bool usesAes = true)",
          "14:   {",
          "15:    Assert.That(TestArchive(stream, password), \"Archive did not pass ZipFile.TestArchive\");",
          "17:    if (!string.IsNullOrEmpty(password) && usesAes)",
          "18:    {",
          "19:     Assert.Ignore(\"ZipInputStream does not support AES\");",
          "20:    }",
          "22:    stream.Seek(0, SeekOrigin.Begin);",
          "24:    Assert.DoesNotThrow(() =>",
          "25:    {",
          "26:     using var zis = new ZipInputStream(stream){Password = password};",
          "27:     while (zis.GetNextEntry() != null)",
          "28:     {",
          "29:      new StreamReader(zis).ReadToEnd();",
          "30:     }",
          "31:    }, \"Archive could not be read by ZipInputStream\");",
          "32:   }",
          "40:   public static bool TestArchive(byte[] data, string password = null)",
          "42:    using var ms = new MemoryStream(data);",
          "43:    return TestArchive(new MemoryStream(data), password);",
          "52:   public static bool TestArchive(Stream stream, string password = null)",
          "54:    using var zipFile = new ZipFile(stream)",
          "56:     IsStreamOwner = false,",
          "57:     Password = password,",
          "58:    };",
          "60:    return zipFile.TestArchive(true, TestStrategy.FindAllErrors, (status, message) =>",
          "61:    {",
          "62:     if (!string.IsNullOrWhiteSpace(message)) TestContext.Out.WriteLine(message);",
          "63:    });",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs -> test/ICSharpCode.SharpZipLib.Tests/Zip/ZipFileHandling.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "913:    var ms2 = new MemoryStream(s.ToArray());",
          "914:    using (ZipFile zf = new ZipFile(ms2))",
          "915:    {",
          "917:    }",
          "918:   }",
          "",
          "[Removed Lines]",
          "916:     Assert.IsTrue(zf.TestArchive(true));",
          "",
          "[Added Lines]",
          "916:     Assert.IsTrue(zf.TestArchive(true, TestStrategy.FindAllErrors,",
          "917:      (status, message) => {",
          "918:       if (!string.IsNullOrWhiteSpace(message)) TestContext.Out.WriteLine(message);",
          "919:      }));",
          "",
          "---------------"
        ],
        "test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs||test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs": [
          "File: test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs -> test/ICSharpCode.SharpZipLib.Tests/Zip/ZipStreamAsyncTests.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \ufeffusing System.IO;",
          "2: using System.Threading;",
          "3: using System.Threading.Tasks;",
          "4: using ICSharpCode.SharpZipLib.Tests.TestSupport;",
          "5: using ICSharpCode.SharpZipLib.Zip;",
          "6: using NUnit.Framework;",
          "8: namespace ICSharpCode.SharpZipLib.Tests.Zip",
          "9: {",
          "10:  [TestFixture]",
          "11:  public class ZipStreamAsyncTests",
          "12:  {",
          "14:   [Test]",
          "15:   [Category(\"Zip\")]",
          "16:   [Category(\"Async\")]",
          "17:   public async Task WriteZipStreamUsingAsync()",
          "18:   {",
          "19: #if NETCOREAPP3_1_OR_GREATER",
          "20:    await using var ms = new MemoryStream();",
          "22:    await using (var outStream = new ZipOutputStream(ms){IsStreamOwner = false})",
          "23:    {",
          "24:     await outStream.PutNextEntryAsync(new ZipEntry(\"FirstFile\"));",
          "25:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "27:     await outStream.PutNextEntryAsync(new ZipEntry(\"SecondFile\"));",
          "28:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "29:    }",
          "31:    ZipTesting.AssertValidZip(ms);",
          "32: #endif",
          "33:   }",
          "35:   [Test]",
          "36:   [Category(\"Zip\")]",
          "37:   [Category(\"Async\")]",
          "38:   public async Task WriteZipStreamAsync ()",
          "39:   {",
          "40:    using var ms = new MemoryStream();",
          "42:    using(var outStream = new ZipOutputStream(ms) { IsStreamOwner = false })",
          "43:    {",
          "44:     await outStream.PutNextEntryAsync(new ZipEntry(\"FirstFile\"));",
          "45:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "47:     await outStream.PutNextEntryAsync(new ZipEntry(\"SecondFile\"));",
          "48:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "50:     await outStream.FinishAsync(CancellationToken.None);",
          "51:    }",
          "53:    ZipTesting.AssertValidZip(ms);",
          "54:   }",
          "57:   [Test]",
          "58:   [Category(\"Zip\")]",
          "59:   [Category(\"Async\")]",
          "60:   public async Task WriteZipStreamWithAesAsync()",
          "61:   {",
          "62:    using var ms = new MemoryStream();",
          "63:    var password = \"f4ls3p0s1t1v3\";",
          "65:    using (var outStream = new ZipOutputStream(ms){IsStreamOwner = false, Password = password})",
          "66:    {",
          "67:     await outStream.PutNextEntryAsync(new ZipEntry(\"FirstFile\"){AESKeySize = 256});",
          "68:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "70:     await outStream.PutNextEntryAsync(new ZipEntry(\"SecondFile\"){AESKeySize = 256});",
          "71:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "73:     await outStream.FinishAsync(CancellationToken.None);",
          "74:    }",
          "76:    ZipTesting.AssertValidZip(ms, password);",
          "77:   }",
          "79:   [Test]",
          "80:   [Category(\"Zip\")]",
          "81:   [Category(\"Async\")]",
          "82:   public async Task WriteZipStreamWithZipCryptoAsync()",
          "83:   {",
          "84:    using var ms = new MemoryStream();",
          "85:    var password = \"f4ls3p0s1t1v3\";",
          "87:    using (var outStream = new ZipOutputStream(ms){IsStreamOwner = false, Password = password})",
          "88:    {",
          "89:     await outStream.PutNextEntryAsync(new ZipEntry(\"FirstFile\"){AESKeySize = 0});",
          "90:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "92:     await outStream.PutNextEntryAsync(new ZipEntry(\"SecondFile\"){AESKeySize = 0});",
          "93:     await Utils.WriteDummyDataAsync(outStream, 12);",
          "95:     await outStream.FinishAsync(CancellationToken.None);",
          "96:    }",
          "98:    ZipTesting.AssertValidZip(ms, password, false);",
          "99:   }",
          "101:  }",
          "102: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
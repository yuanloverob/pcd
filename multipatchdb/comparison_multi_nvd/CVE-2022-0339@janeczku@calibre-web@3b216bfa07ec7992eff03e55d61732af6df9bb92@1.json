{
  "cve_id": "CVE-2022-0339",
  "cve_desc": "Server-Side Request Forgery (SSRF) in Pypi calibreweb prior to 0.6.16.",
  "repo": "janeczku/calibre-web",
  "patch_hash": "3b216bfa07ec7992eff03e55d61732af6df9bb92",
  "patch_info": {
    "commit_hash": "3b216bfa07ec7992eff03e55d61732af6df9bb92",
    "repo": "janeczku/calibre-web",
    "commit_url": "https://github.com/janeczku/calibre-web/commit/3b216bfa07ec7992eff03e55d61732af6df9bb92",
    "files": [
      "cps/admin.py",
      "cps/editbooks.py",
      "cps/kobo_auth.py",
      "cps/static/js/main.js",
      "cps/templates/generate_kobo_auth_url.html"
    ],
    "message": "Kobo sync token is now also created if accessed from localhost(fixes #1990) Create kobo sync token button is now \"unclicked\" after closing dialog Additional localhost route is catched If book format is deleted this also deletes the book synced to kobo status",
    "before_after_code_files": [
      "cps/admin.py||cps/admin.py",
      "cps/editbooks.py||cps/editbooks.py",
      "cps/kobo_auth.py||cps/kobo_auth.py",
      "cps/static/js/main.js||cps/static/js/main.js",
      "cps/templates/generate_kobo_auth_url.html||cps/templates/generate_kobo_auth_url.html"
    ]
  },
  "patch_diff": {
    "cps/admin.py||cps/admin.py": [
      "File: cps/admin.py -> cps/admin.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1426:             for kobo_entry in kobo_entries:",
      "1427:                 ub.session.delete(kobo_entry)",
      "1428:             ub.session_commit()",
      "1431:         else:",
      "1434:     else:",
      "1439: def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
      "",
      "[Removed Lines]",
      "1429:             log.info(u\"User {} deleted\".format(content.name))",
      "1430:             return(_(u\"User '%(nick)s' deleted\", nick=content.name))",
      "1432:             log.warning(_(u\"Can't delete Guest User\"))",
      "1433:             raise Exception(_(u\"Can't delete Guest User\"))",
      "1435:         log.warning(u\"No admin user remaining, can't delete user\")",
      "1436:         raise Exception(_(u\"No admin user remaining, can't delete user\"))",
      "",
      "[Added Lines]",
      "1429:             log.info(\"User {} deleted\".format(content.name))",
      "1430:             return(_(\"User '%(nick)s' deleted\", nick=content.name))",
      "1432:             log.warning(_(\"Can't delete Guest User\"))",
      "1433:             raise Exception(_(\"Can't delete Guest User\"))",
      "1435:         log.warning(\"No admin user remaining, can't delete user\")",
      "1436:         raise Exception(_(\"No admin user remaining, can't delete user\"))",
      "",
      "---------------"
    ],
    "cps/editbooks.py||cps/editbooks.py": [
      "File: cps/editbooks.py -> cps/editbooks.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "341:                 else:",
      "342:                     calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
      "343:                         filter(db.Data.format == book_format).delete()",
      "344:                 calibre_db.session.commit()",
      "345:             except Exception as ex:",
      "346:                 log.debug_or_exception(ex)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "344:                     kobo_sync_status.remove_synced_book(book.id, True)",
      "",
      "---------------"
    ],
    "cps/kobo_auth.py||cps/kobo_auth.py": [
      "File: cps/kobo_auth.py -> cps/kobo_auth.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "118: @kobo_auth.route(\"/generate_auth_token/<int:user_id>\")",
      "119: @login_required",
      "120: def generate_auth_token(user_id):",
      "121:     host_list = request.host.rsplit(':')",
      "122:     if len(host_list) == 1:",
      "123:         host = ':'.join(host_list)",
      "124:     else:",
      "125:         host = ':'.join(host_list[0:-1])",
      "166: @kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])",
      "167: @login_required",
      "168: def delete_auth_token(user_id):",
      "170:     ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\",
      "171:         .filter(ub.RemoteAuthToken.token_type==1).delete()",
      "",
      "[Removed Lines]",
      "126:     if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):",
      "127:         warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')",
      "128:         return render_title_template(",
      "129:             \"generate_kobo_auth_url.html\",",
      "130:             title=_(u\"Kobo Setup\"),",
      "131:             warning = warning",
      "132:         )",
      "133:     else:",
      "134:         # Invalidate any prevously generated Kobo Auth token for this user.",
      "135:         auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
      "136:             ub.RemoteAuthToken.user_id == user_id",
      "137:         ).filter(ub.RemoteAuthToken.token_type==1).first()",
      "139:         if not auth_token:",
      "140:             auth_token = ub.RemoteAuthToken()",
      "141:             auth_token.user_id = user_id",
      "142:             auth_token.expiration = datetime.max",
      "143:             auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
      "144:             auth_token.token_type = 1",
      "146:             ub.session.add(auth_token)",
      "147:             ub.session_commit()",
      "149:         books = calibre_db.session.query(db.Books).join(db.Data).all()",
      "151:         for book in books:",
      "152:             formats = [data.format for data in book.data]",
      "153:             if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
      "154:                 helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
      "156:         return render_title_template(",
      "157:             \"generate_kobo_auth_url.html\",",
      "158:             title=_(u\"Kobo Setup\"),",
      "159:             kobo_auth_url=url_for(",
      "160:                 \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True",
      "161:             ),",
      "162:             warning = False",
      "163:         )",
      "169:     # Invalidate any prevously generated Kobo Auth token for this user.",
      "",
      "[Added Lines]",
      "121:     warning = False",
      "127:     if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f') or host == \"[::1]\":",
      "128:         warning = _('Please access Calibre-Web from non localhost to get valid api_endpoint for kobo device')",
      "130:     # Generate auth token if none is existing for this user",
      "131:     auth_token = ub.session.query(ub.RemoteAuthToken).filter(",
      "132:         ub.RemoteAuthToken.user_id == user_id",
      "133:     ).filter(ub.RemoteAuthToken.token_type==1).first()",
      "135:     if not auth_token:",
      "136:         auth_token = ub.RemoteAuthToken()",
      "137:         auth_token.user_id = user_id",
      "138:         auth_token.expiration = datetime.max",
      "139:         auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")",
      "140:         auth_token.token_type = 1",
      "142:         ub.session.add(auth_token)",
      "143:         ub.session_commit()",
      "145:     books = calibre_db.session.query(db.Books).join(db.Data).all()",
      "147:     for book in books:",
      "148:         formats = [data.format for data in book.data]",
      "149:         if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:",
      "150:             helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)",
      "152:     return render_title_template(",
      "153:         \"generate_kobo_auth_url.html\",",
      "154:         title=_(u\"Kobo Setup\"),",
      "155:         auth_token=auth_token.auth_token,",
      "156:         warning = warning",
      "157:     )",
      "163:     # Invalidate any previously generated Kobo Auth token for this user",
      "",
      "---------------"
    ],
    "cps/static/js/main.js||cps/static/js/main.js": [
      "File: cps/static/js/main.js -> cps/static/js/main.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "536:     $(\"#modal_kobo_token\")",
      "537:         .on(\"show.bs.modal\", function(e) {",
      "538:             var $modalBody = $(this).find(\".modal-body\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "538:             $(e.relatedTarget).one('focus', function(e){$(this).blur();});",
      "",
      "---------------"
    ],
    "cps/templates/generate_kobo_auth_url.html||cps/templates/generate_kobo_auth_url.html": [
      "File: cps/templates/generate_kobo_auth_url.html -> cps/templates/generate_kobo_auth_url.html",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: {% extends \"fragment.html\" %}",
      "2: {% block body %}",
      "3: <div class=\"well\">",
      "6:   </p>",
      "11: </div>",
      "12: {% endblock %}",
      "",
      "[Removed Lines]",
      "4:   <p>",
      "5:     {{_('Open the .kobo/Kobo eReader.conf file in a text editor and add (or edit):')}}</a>",
      "7:   <p>",
      "8:     {% if not warning %}api_endpoint={{kobo_auth_url}}{% else %}{{warning}}{% endif %}</a>",
      "9:   </p>",
      "10:   <p>",
      "",
      "[Added Lines]",
      "4: <p>",
      "5:   {% if not warning %}",
      "6:       {{_('Open the .kobo/Kobo eReader.conf file in a text editor and add (or edit):')}}",
      "7:     </p><p>",
      "8:       api_endpoint={{url_for(\"kobo.TopLevelEndpoint\", auth_token=auth_token, _external=True)}}",
      "9:   {% else %}",
      "10:       {{warning}}",
      "11:     </p><p>{{_('Kobo Token:')}} {{ auth_token }}",
      "12:   {% endif %}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2e007a160e652b2e7bbdeb5a8319560188324502",
      "candidate_info": {
        "commit_hash": "2e007a160e652b2e7bbdeb5a8319560188324502",
        "repo": "janeczku/calibre-web",
        "commit_url": "https://github.com/janeczku/calibre-web/commit/2e007a160e652b2e7bbdeb5a8319560188324502",
        "files": [
          "cps/__init__.py",
          "cps/admin.py",
          "cps/babel.py",
          "cps/editbooks.py",
          "cps/helper.py",
          "cps/kobo_auth.py",
          "cps/main.py",
          "cps/opds.py",
          "cps/search.py",
          "cps/services/__init__.py",
          "cps/shelf.py",
          "cps/tasks_status.py",
          "cps/templates/tasks.html",
          "cps/web.py"
        ],
        "message": "reenable startup logging Bugfixes from refactoring and merge",
        "before_after_code_files": [
          "cps/__init__.py||cps/__init__.py",
          "cps/admin.py||cps/admin.py",
          "cps/babel.py||cps/babel.py",
          "cps/editbooks.py||cps/editbooks.py",
          "cps/helper.py||cps/helper.py",
          "cps/kobo_auth.py||cps/kobo_auth.py",
          "cps/main.py||cps/main.py",
          "cps/opds.py||cps/opds.py",
          "cps/search.py||cps/search.py",
          "cps/services/__init__.py||cps/services/__init__.py",
          "cps/shelf.py||cps/shelf.py",
          "cps/tasks_status.py||cps/tasks_status.py",
          "cps/templates/tasks.html||cps/templates/tasks.html",
          "cps/web.py||cps/web.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cps/admin.py||cps/admin.py",
            "cps/editbooks.py||cps/editbooks.py",
            "cps/kobo_auth.py||cps/kobo_auth.py"
          ],
          "candidate": [
            "cps/admin.py||cps/admin.py",
            "cps/editbooks.py||cps/editbooks.py",
            "cps/kobo_auth.py||cps/kobo_auth.py"
          ]
        }
      },
      "candidate_diff": {
        "cps/__init__.py||cps/__init__.py": [
          "File: cps/__init__.py -> cps/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: from .MyLoginManager import MyLoginManager",
          "28: from flask_principal import Principal",
          "30: from .cli import CliParameter",
          "31: from .constants import CONFIG_DIR",
          "32: from .reverseproxy import ReverseProxied",
          "33: from .server import WebServer",
          "34: from .dep_check import dependency_check",
          "36: from .updater import Updater",
          "38: from . import config_sql",
          "40: from . import cache_buster",
          "41: from . import ub, db",
          "",
          "[Removed Lines]",
          "35: from . import services",
          "37: from .babel import babel, BABEL_TRANSLATIONS",
          "39: from . import logger",
          "",
          "[Added Lines]",
          "30: from . import logger",
          "37: from .babel import babel",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "157:     web_server.init_app(app, config)",
          "159:     babel.init_app(app)",
          "163:     if services.ldap:",
          "164:         services.ldap.init_app(app, config)",
          "",
          "[Removed Lines]",
          "160:     BABEL_TRANSLATIONS.update(str(item) for item in babel.list_translations())",
          "161:     BABEL_TRANSLATIONS.add('en')",
          "",
          "[Added Lines]",
          "160:     from . import services",
          "",
          "---------------"
        ],
        "cps/admin.py||cps/admin.py": [
          "File: cps/admin.py -> cps/admin.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
          "39: from sqlalchemy.sql.expression import func, or_, text",
          "43:     kobo_sync_status, schedule",
          "44: from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
          "46: from .gdriveutils import is_gdrive_ready, gdrive_support",
          "47: from .render_template import render_title_template, get_sidebar_config",
          "48: from .services.worker import WorkerThread",
          "52: log = logger.create()",
          "",
          "[Removed Lines]",
          "41: from . import constants, logger, helper, services, cli",
          "42: from . import db, calibre_db, ub, web_server, config, updater_thread, babel, gdriveutils, \\",
          "45:     valid_email, check_username, update_thumbnail_cache",
          "49: from . import debug_info, BABEL_TRANSLATIONS",
          "",
          "[Added Lines]",
          "42: from . import constants, logger, helper, services, cli_param",
          "43: from . import db, calibre_db, ub, web_server, config, updater_thread, gdriveutils, \\",
          "46:     valid_email, check_username",
          "50: from .babel import get_available_translations, get_available_locale, get_user_locale_language",
          "51: from . import debug_info",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:         'kobo':  bool(services.kobo),",
          "58:         'updater': constants.UPDATER_AVAILABLE,",
          "59:         'gmail': bool(services.gmail),",
          "61:     }",
          "63: try:",
          "",
          "[Removed Lines]",
          "60:         'scheduler': schedule.use_APScheduler",
          "",
          "[Added Lines]",
          "62:         'scheduler': schedule.use_APScheduler,",
          "63:         'gdrive': gdrive_support",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:     oauth_check = {}",
          "80: admi = Blueprint('admin', __name__)",
          "",
          "[Removed Lines]",
          "79: feature_support['gdrive'] = gdrive_support",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "160: # needed for docker applications, as changes on metadata.db from host are not visible to application",
          "161: @admi.route(\"/reconnect\", methods=['GET'])",
          "162: def reconnect():",
          "164:         calibre_db.reconnect_db(config, ub.app_DB_path)",
          "165:         return json.dumps({})",
          "166:     else:",
          "",
          "[Removed Lines]",
          "163:     if cli.reconnect_enable:",
          "",
          "[Added Lines]",
          "165:     if cli_param.reconnect_enable:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "175:     content = config.get_scheduled_task_settings()",
          "176:     if content['schedule_generate_book_covers']:",
          "177:         log.info(\"Update of Cover cache requested\")",
          "179:     return \"\"",
          "",
          "[Removed Lines]",
          "178:         update_thumbnail_cache()",
          "",
          "[Added Lines]",
          "180:         helper.update_thumbnail_cache()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "264:     restrict_columns = calibre_db.session.query(db.CustomColumns)\\",
          "265:         .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all()",
          "266:     languages = calibre_db.speaking_language()",
          "268:     return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
          "269:                                  restrictColumns=restrict_columns,",
          "270:                                  languages=languages,",
          "",
          "[Removed Lines]",
          "267:     translations = [Locale('en')] + babel.list_translations()",
          "",
          "[Added Lines]",
          "269:     translations = get_available_locale()",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "278: def edit_user_table():",
          "279:     visibility = current_user.view_settings.get('useredit', {})",
          "280:     languages = calibre_db.speaking_language()",
          "282:     all_user = ub.session.query(ub.User)",
          "283:     tags = calibre_db.session.query(db.Tags)\\",
          "284:         .join(db.books_tags_link)\\",
          "",
          "[Removed Lines]",
          "281:     translations = [LC('en')] + babel.list_translations()",
          "",
          "[Added Lines]",
          "283:     translations = get_available_locale()",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "349:         if user.default_language == \"all\":",
          "350:             user.default = _(\"All\")",
          "351:         else:",
          "354:     table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
          "355:     js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
          "",
          "[Removed Lines]",
          "352:             user.default = Locale.parse(user.default_language).get_language_name(get_locale())",
          "",
          "[Added Lines]",
          "354:             user.default = get_user_locale_language(user.default_language)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "397: @login_required",
          "398: @admin_required",
          "399: def table_get_locale():",
          "401:     ret = list()",
          "402:     current_locale = get_locale()",
          "403:     for loc in locale:",
          "",
          "[Removed Lines]",
          "400:     locale = [LC('en')] + babel.list_translations()",
          "",
          "[Added Lines]",
          "402:     locale = get_available_locale()",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "498:                 elif param == 'locale':",
          "499:                     if user.name == \"Guest\":",
          "500:                         raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
          "502:                         user.locale = vals['value']",
          "503:                     else:",
          "504:                         raise Exception(_(\"No Valid Locale Given\"))",
          "",
          "[Removed Lines]",
          "501:                     if vals['value'] in BABEL_TRANSLATIONS:",
          "",
          "[Added Lines]",
          "503:                     if vals['value'] in get_available_translations():",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "539:     return \"\"",
          "558: @admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
          "559: @login_required",
          "560: @admin_required",
          "",
          "[Removed Lines]",
          "542: def check_valid_read_column(column):",
          "543:     if column != \"0\":",
          "544:         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
          "545:               .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():",
          "546:             return False",
          "547:     return True",
          "550: def check_valid_restricted_column(column):",
          "551:     if column != \"0\":",
          "552:         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
          "553:               .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():",
          "554:             return False",
          "555:     return True",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "759:             ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
          "760:     return \"\"",
          "799: @admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
          "800: @login_required",
          "801: @admin_required",
          "",
          "[Removed Lines]",
          "763: def restriction_addition(element, list_func):",
          "764:     elementlist = list_func()",
          "765:     if elementlist == ['']:",
          "766:         elementlist = []",
          "767:     if not element['add_element'] in elementlist:",
          "768:         elementlist += [element['add_element']]",
          "769:     return ','.join(elementlist)",
          "772: def restriction_deletion(element, list_func):",
          "773:     elementlist = list_func()",
          "774:     if element['Element'] in elementlist:",
          "775:         elementlist.remove(element['Element'])",
          "776:     return ','.join(elementlist)",
          "779: def prepare_tags(user, action, tags_name, id_list):",
          "780:     if \"tags\" in tags_name:",
          "781:         tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
          "782:         if not tags:",
          "783:             raise Exception(_(\"Tag not found\"))",
          "784:         new_tags_list = [x.name for x in tags]",
          "785:     else:",
          "786:         tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
          "787:             .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
          "788:         new_tags_list = [x.value for x in tags]",
          "789:     saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
          "790:     if action == \"remove\":",
          "791:         saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
          "792:     elif action == \"add\":",
          "793:         saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
          "794:     else:",
          "795:         raise Exception(_(\"Invalid Action\"))",
          "796:     return \",\".join(saved_tags_list)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "964:     return pathchooser()",
          "967: def pathchooser():",
          "968:     browse_for = \"folder\"",
          "969:     folder_only = request.args.get('folder', False) == \"true\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "916: def check_valid_read_column(column):",
          "917:     if column != \"0\":",
          "918:         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
          "919:               .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():",
          "920:             return False",
          "921:     return True",
          "924: def check_valid_restricted_column(column):",
          "925:     if column != \"0\":",
          "926:         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
          "927:               .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():",
          "928:             return False",
          "929:     return True",
          "932: def restriction_addition(element, list_func):",
          "933:     elementlist = list_func()",
          "934:     if elementlist == ['']:",
          "935:         elementlist = []",
          "936:     if not element['add_element'] in elementlist:",
          "937:         elementlist += [element['add_element']]",
          "938:     return ','.join(elementlist)",
          "941: def restriction_deletion(element, list_func):",
          "942:     elementlist = list_func()",
          "943:     if element['Element'] in elementlist:",
          "944:         elementlist.remove(element['Element'])",
          "945:     return ','.join(elementlist)",
          "948: def prepare_tags(user, action, tags_name, id_list):",
          "949:     if \"tags\" in tags_name:",
          "950:         tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
          "951:         if not tags:",
          "952:             raise Exception(_(\"Tag not found\"))",
          "953:         new_tags_list = [x.name for x in tags]",
          "954:     else:",
          "955:         tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\",
          "956:             .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
          "957:         new_tags_list = [x.value for x in tags]",
          "958:     saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
          "959:     if action == \"remove\":",
          "960:         saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
          "961:     elif action == \"add\":",
          "962:         saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
          "963:     else:",
          "964:         raise Exception(_(\"Invalid Action\"))",
          "965:     return \",\".join(saved_tags_list)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1207:     return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
          "1226:     to_save = request.form.to_dict()",
          "1234:     try:",
          "1239:     except (OperationalError, InvalidRequestError) as e:",
          "1240:         ub.session.rollback()",
          "1241:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1374:     else:",
          "1390:     else:",
          "1564:     try:",
          "1610: @login_required",
          "1611: @admin_required",
          "1638:     try:",
          "1652:             else:",
          "1654:         else:",
          "1663: @login_required",
          "1664: @admin_required",
          "1684:     to_save = request.form.to_dict()",
          "1896:     try:",
          "1899:     except Exception as ex:",
          "1916:     try:",
          "1917:         ub.session.commit()",
          "1921:         ub.session.rollback()",
          "1956:         else:",
          "1959:         try:",
          "1970:         else:",
          "1978: def extract_user_data_from_field(user, field):",
          "",
          "[Removed Lines]",
          "1210: def _db_simulate_change():",
          "1211:     param = request.form.to_dict()",
          "1212:     to_save = dict()",
          "1213:     to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
          "1214:                                            '',",
          "1215:                                            param['config_calibre_dir'],",
          "1216:                                            flags=re.IGNORECASE).strip()",
          "1217:     db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],",
          "1218:                                                     ub.app_DB_path,",
          "1219:                                                     config.config_calibre_uuid)",
          "1220:     db_change = bool(db_change and config.config_calibre_dir)",
          "1221:     return db_change, db_valid",
          "1224: def _db_configuration_update_helper():",
          "1225:     db_change = False",
          "1227:     gdrive_error = None",
          "1229:     to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
          "1230:                                            '',",
          "1231:                                            to_save['config_calibre_dir'],",
          "1232:                                            flags=re.IGNORECASE)",
          "1233:     db_valid = False",
          "1235:         db_change, db_valid = _db_simulate_change()",
          "1237:         # gdrive_error drive setup",
          "1238:         gdrive_error = _configuration_gdrive_helper(to_save)",
          "1242:         _db_configuration_result(_(u\"Database error: %(error)s.\", error=e.orig), gdrive_error)",
          "1243:     try:",
          "1244:         metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
          "1245:         if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
          "1246:             gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
          "1247:             db_change = True",
          "1248:     except Exception as ex:",
          "1249:         return _db_configuration_result('{}'.format(ex), gdrive_error)",
          "1251:     if db_change or not db_valid or not config.db_configured \\",
          "1252:             or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:",
          "1253:         if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
          "1254:             return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
          "1255:                                             gdrive_error)",
          "1256:         config.store_calibre_uuid(calibre_db, db.Library_Id)",
          "1257:         # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
          "1258:         if db_change:",
          "1259:             log.info(\"Calibre Database changed, all Calibre-Web info related to old Database gets deleted\")",
          "1260:             ub.session.query(ub.Downloads).delete()",
          "1261:             ub.session.query(ub.ArchivedBook).delete()",
          "1262:             ub.session.query(ub.ReadBook).delete()",
          "1263:             ub.session.query(ub.BookShelf).delete()",
          "1264:             ub.session.query(ub.Bookmark).delete()",
          "1265:             ub.session.query(ub.KoboReadingState).delete()",
          "1266:             ub.session.query(ub.KoboStatistics).delete()",
          "1267:             ub.session.query(ub.KoboSyncedBooks).delete()",
          "1268:             helper.delete_thumbnail_cache()",
          "1269:             ub.session_commit()",
          "1270:         _config_string(to_save, \"config_calibre_dir\")",
          "1271:         calibre_db.update_config(config)",
          "1272:         if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
          "1273:             flash(_(u\"DB is not Writeable\"), category=\"warning\")",
          "1274:     config.save()",
          "1275:     return _db_configuration_result(None, gdrive_error)",
          "1278: def _configuration_update_helper():",
          "1279:     reboot_required = False",
          "1280:     to_save = request.form.to_dict()",
          "1281:     try:",
          "1282:         reboot_required |= _config_int(to_save, \"config_port\")",
          "1283:         reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
          "1284:         reboot_required |= _config_string(to_save, \"config_keyfile\")",
          "1285:         if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
          "1286:             return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
          "1288:         reboot_required |= _config_string(to_save, \"config_certfile\")",
          "1289:         if config.config_certfile and not os.path.isfile(config.config_certfile):",
          "1290:             return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
          "1292:         _config_checkbox_int(to_save, \"config_uploading\")",
          "1293:         _config_checkbox_int(to_save, \"config_unicode_filename\")",
          "1294:         # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
          "1295:         reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
          "1296:                             and config.config_login_type == constants.LOGIN_LDAP)",
          "1297:         _config_checkbox_int(to_save, \"config_public_reg\")",
          "1298:         _config_checkbox_int(to_save, \"config_register_email\")",
          "1299:         reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
          "1300:         _config_int(to_save, \"config_external_port\")",
          "1301:         _config_checkbox_int(to_save, \"config_kobo_proxy\")",
          "1303:         if \"config_upload_formats\" in to_save:",
          "1304:             to_save[\"config_upload_formats\"] = ','.join(",
          "1305:                 helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
          "1306:             _config_string(to_save, \"config_upload_formats\")",
          "1307:             constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
          "1309:         _config_string(to_save, \"config_calibre\")",
          "1310:         _config_string(to_save, \"config_converterpath\")",
          "1311:         _config_string(to_save, \"config_kepubifypath\")",
          "1313:         reboot_required |= _config_int(to_save, \"config_login_type\")",
          "1315:         # LDAP configurator",
          "1316:         if config.config_login_type == constants.LOGIN_LDAP:",
          "1317:             reboot, message = _configuration_ldap_helper(to_save)",
          "1318:             if message:",
          "1319:                 return message",
          "1320:             reboot_required |= reboot",
          "1322:         # Remote login configuration",
          "1323:         _config_checkbox(to_save, \"config_remote_login\")",
          "1324:         if not config.config_remote_login:",
          "1325:             ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
          "1327:         # Goodreads configuration",
          "1328:         _config_checkbox(to_save, \"config_use_goodreads\")",
          "1329:         _config_string(to_save, \"config_goodreads_api_key\")",
          "1330:         _config_string(to_save, \"config_goodreads_api_secret\")",
          "1331:         if services.goodreads_support:",
          "1332:             services.goodreads_support.connect(config.config_goodreads_api_key,",
          "1333:                                                config.config_goodreads_api_secret,",
          "1334:                                                config.config_use_goodreads)",
          "1336:         _config_int(to_save, \"config_updatechannel\")",
          "1338:         # Reverse proxy login configuration",
          "1339:         _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
          "1340:         _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
          "1342:         # OAuth configuration",
          "1343:         if config.config_login_type == constants.LOGIN_OAUTH:",
          "1344:             reboot_required |= _configuration_oauth_helper(to_save)",
          "1346:         reboot, message = _configuration_logfile_helper(to_save)",
          "1347:         if message:",
          "1348:             return message",
          "1349:         reboot_required |= reboot",
          "1350:         # Rarfile Content configuration",
          "1351:         _config_string(to_save, \"config_rarfile_location\")",
          "1352:         if \"config_rarfile_location\" in to_save:",
          "1353:             unrar_status = helper.check_unrar(config.config_rarfile_location)",
          "1354:             if unrar_status:",
          "1355:                 return _configuration_result(unrar_status)",
          "1356:     except (OperationalError, InvalidRequestError) as e:",
          "1357:         ub.session.rollback()",
          "1358:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1359:         _configuration_result(_(u\"Database error: %(error)s.\", error=e.orig))",
          "1361:     config.save()",
          "1362:     if reboot_required:",
          "1363:         web_server.stop(True)",
          "1365:     return _configuration_result(None, reboot_required)",
          "1368: def _configuration_result(error_flash=None, reboot=False):",
          "1369:     resp = {}",
          "1370:     if error_flash:",
          "1371:         log.error(error_flash)",
          "1372:         config.load()",
          "1373:         resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
          "1375:         resp['result'] = [{'type': \"success\", 'message': _(u\"Calibre-Web configuration updated\")}]",
          "1376:     resp['reboot'] = reboot",
          "1377:     resp['config_upload'] = config.config_upload_formats",
          "1378:     return Response(json.dumps(resp), mimetype='application/json')",
          "1381: def _db_configuration_result(error_flash=None, gdrive_error=None):",
          "1382:     gdrive_authenticate = not is_gdrive_ready()",
          "1383:     gdrivefolders = []",
          "1384:     if not gdrive_error and config.config_use_google_drive:",
          "1385:         gdrive_error = gdriveutils.get_error_text()",
          "1386:     if gdrive_error and gdrive_support:",
          "1387:         log.error(gdrive_error)",
          "1388:         gdrive_error = _(gdrive_error)",
          "1389:         flash(gdrive_error, category=\"error\")",
          "1391:         if not gdrive_authenticate and gdrive_support:",
          "1392:             gdrivefolders = gdriveutils.listRootFolders()",
          "1393:     if error_flash:",
          "1394:         log.error(error_flash)",
          "1395:         config.load()",
          "1396:         flash(error_flash, category=\"error\")",
          "1397:     elif request.method == \"POST\" and not gdrive_error:",
          "1398:         flash(_(\"Database Settings updated\"), category=\"success\")",
          "1400:     return render_title_template(\"config_db.html\",",
          "1401:                                  config=config,",
          "1402:                                  show_authenticate_google_drive=gdrive_authenticate,",
          "1403:                                  gdriveError=gdrive_error,",
          "1404:                                  gdrivefolders=gdrivefolders,",
          "1405:                                  feature_support=feature_support,",
          "1406:                                  title=_(u\"Database Configuration\"), page=\"dbconfig\")",
          "1409: def _handle_new_user(to_save, content, languages, translations, kobo_support):",
          "1410:     content.default_language = to_save[\"default_language\"]",
          "1411:     content.locale = to_save.get(\"locale\", content.locale)",
          "1413:     content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
          "1414:     if \"show_detail_random\" in to_save:",
          "1415:         content.sidebar_view |= constants.DETAIL_RANDOM",
          "1417:     content.role = constants.selected_roles(to_save)",
          "1418:     content.password = generate_password_hash(to_save[\"password\"])",
          "1419:     try:",
          "1420:         if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
          "1421:             log.info(\"Missing entries on new user\")",
          "1422:             raise Exception(_(u\"Please fill out all fields!\"))",
          "1423:         content.email = check_email(to_save[\"email\"])",
          "1424:         # Query User name, if not existing, change",
          "1425:         content.name = check_username(to_save[\"name\"])",
          "1426:         if to_save.get(\"kindle_mail\"):",
          "1427:             content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
          "1428:         if config.config_public_reg and not check_valid_domain(content.email):",
          "1429:             log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
          "1430:             raise Exception(_(u\"E-mail is not from valid domain\"))",
          "1431:     except Exception as ex:",
          "1432:         flash(str(ex), category=\"error\")",
          "1433:         return render_title_template(\"user_edit.html\", new_user=1, content=content,",
          "1434:                                      config=config,",
          "1435:                                      translations=translations,",
          "1436:                                      languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
          "1437:                                      kobo_support=kobo_support, registered_oauth=oauth_check)",
          "1438:     try:",
          "1439:         content.allowed_tags = config.config_allowed_tags",
          "1440:         content.denied_tags = config.config_denied_tags",
          "1441:         content.allowed_column_value = config.config_allowed_column_value",
          "1442:         content.denied_column_value = config.config_denied_column_value",
          "1443:         # No default value for kobo sync shelf setting",
          "1444:         content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
          "1445:         ub.session.add(content)",
          "1446:         ub.session.commit()",
          "1447:         flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
          "1448:         log.debug(\"User {} created\".format(content.name))",
          "1449:         return redirect(url_for('admin.admin'))",
          "1450:     except IntegrityError:",
          "1451:         ub.session.rollback()",
          "1452:         log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
          "1453:         flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
          "1454:     except OperationalError as e:",
          "1455:         ub.session.rollback()",
          "1456:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1457:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1460: def _delete_user(content):",
          "1461:     if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
          "1462:                                         ub.User.id != content.id).count():",
          "1463:         if content.name != \"Guest\":",
          "1464:             # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
          "1465:             # and user itself",
          "1466:             ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
          "1467:             ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
          "1468:             for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
          "1469:                 ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
          "1470:             ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
          "1471:             ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
          "1472:             ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
          "1473:             ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
          "1474:             ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
          "1475:             ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
          "1476:             ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
          "1477:             # delete KoboReadingState and all it's children",
          "1478:             kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
          "1479:             for kobo_entry in kobo_entries:",
          "1480:                 ub.session.delete(kobo_entry)",
          "1481:             ub.session_commit()",
          "1482:             log.info(\"User {} deleted\".format(content.name))",
          "1483:             return _(\"User '%(nick)s' deleted\", nick=content.name)",
          "1484:         else:",
          "1485:             log.warning(_(\"Can't delete Guest User\"))",
          "1486:             raise Exception(_(\"Can't delete Guest User\"))",
          "1487:     else:",
          "1488:         log.warning(\"No admin user remaining, can't delete user\")",
          "1489:         raise Exception(_(\"No admin user remaining, can't delete user\"))",
          "1492: def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
          "1493:     if to_save.get(\"delete\"):",
          "1494:         try:",
          "1495:             flash(_delete_user(content), category=\"success\")",
          "1496:         except Exception as ex:",
          "1497:             log.error(ex)",
          "1498:             flash(str(ex), category=\"error\")",
          "1499:         return redirect(url_for('admin.admin'))",
          "1500:     else:",
          "1501:         if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
          "1502:                                                 ub.User.id != content.id).count() and 'admin_role' not in to_save:",
          "1503:             log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
          "1504:             flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
          "1505:             return redirect(url_for('admin.admin'))",
          "1506:         if to_save.get(\"password\"):",
          "1507:             content.password = generate_password_hash(to_save[\"password\"])",
          "1508:         anonymous = content.is_anonymous",
          "1509:         content.role = constants.selected_roles(to_save)",
          "1510:         if anonymous:",
          "1511:             content.role |= constants.ROLE_ANONYMOUS",
          "1512:         else:",
          "1513:             content.role &= ~constants.ROLE_ANONYMOUS",
          "1515:         val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
          "1516:         sidebar, __ = get_sidebar_config()",
          "1517:         for element in sidebar:",
          "1518:             value = element['visibility']",
          "1519:             if value in val and not content.check_visibility(value):",
          "1520:                 content.sidebar_view |= value",
          "1521:             elif value not in val and content.check_visibility(value):",
          "1522:                 content.sidebar_view &= ~value",
          "1524:         if to_save.get(\"Show_detail_random\"):",
          "1525:             content.sidebar_view |= constants.DETAIL_RANDOM",
          "1526:         else:",
          "1527:             content.sidebar_view &= ~constants.DETAIL_RANDOM",
          "1529:         old_state = content.kobo_only_shelves_sync",
          "1530:         content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
          "1531:         # 1 -> 0: nothing has to be done",
          "1532:         # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
          "1533:         # which don't have to be synced have to be removed (added to Shelf archive)",
          "1534:         if old_state == 0 and content.kobo_only_shelves_sync == 1:",
          "1535:             kobo_sync_status.update_on_sync_shelfs(content.id)",
          "1536:         if to_save.get(\"default_language\"):",
          "1537:             content.default_language = to_save[\"default_language\"]",
          "1538:         if to_save.get(\"locale\"):",
          "1539:             content.locale = to_save[\"locale\"]",
          "1540:         try:",
          "1541:             if to_save.get(\"email\", content.email) != content.email:",
          "1542:                 content.email = check_email(to_save[\"email\"])",
          "1543:             # Query User name, if not existing, change",
          "1544:             if to_save.get(\"name\", content.name) != content.name:",
          "1545:                 if to_save.get(\"name\") == \"Guest\":",
          "1546:                     raise Exception(_(\"Guest Name can't be changed\"))",
          "1547:                 content.name = check_username(to_save[\"name\"])",
          "1548:             if to_save.get(\"kindle_mail\") != content.kindle_mail:",
          "1549:                 content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
          "1550:         except Exception as ex:",
          "1551:             log.error(ex)",
          "1552:             flash(str(ex), category=\"error\")",
          "1553:             return render_title_template(\"user_edit.html\",",
          "1554:                                          translations=translations,",
          "1555:                                          languages=languages,",
          "1556:                                          mail_configured=config.get_mail_server_configured(),",
          "1557:                                          kobo_support=kobo_support,",
          "1558:                                          new_user=0,",
          "1559:                                          content=content,",
          "1560:                                          config=config,",
          "1561:                                          registered_oauth=oauth_check,",
          "1562:                                          title=_(u\"Edit User %(nick)s\", nick=content.name),",
          "1563:                                          page=\"edituser\")",
          "1565:         ub.session_commit()",
          "1566:         flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
          "1567:     except IntegrityError as ex:",
          "1568:         ub.session.rollback()",
          "1569:         log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
          "1570:         flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1571:     except OperationalError as e:",
          "1572:         ub.session.rollback()",
          "1573:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1574:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1575:     return \"\"",
          "1578: @admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
          "1579: @login_required",
          "1580: @admin_required",
          "1581: def new_user():",
          "1582:     content = ub.User()",
          "1583:     languages = calibre_db.speaking_language()",
          "1584:     translations = [Locale('en')] + babel.list_translations()",
          "1585:     kobo_support = feature_support['kobo'] and config.config_kobo_sync",
          "1586:     if request.method == \"POST\":",
          "1587:         to_save = request.form.to_dict()",
          "1588:         _handle_new_user(to_save, content, languages, translations, kobo_support)",
          "1589:     else:",
          "1590:         content.role = config.config_default_role",
          "1591:         content.sidebar_view = config.config_default_show",
          "1592:         content.locale = config.config_default_locale",
          "1593:         content.default_language = config.config_default_language",
          "1594:     return render_title_template(\"user_edit.html\", new_user=1, content=content,",
          "1595:                                  config=config, translations=translations,",
          "1596:                                  languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
          "1597:                                  kobo_support=kobo_support, registered_oauth=oauth_check)",
          "1600: @admi.route(\"/admin/mailsettings\")",
          "1601: @login_required",
          "1602: @admin_required",
          "1603: def edit_mailsettings():",
          "1604:     content = config.get_mail_settings()",
          "1605:     return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
          "1606:                                  page=\"mailset\", feature_support=feature_support)",
          "1609: @admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
          "1612: def update_mailsettings():",
          "1613:     to_save = request.form.to_dict()",
          "1614:     _config_int(to_save, \"mail_server_type\")",
          "1615:     if to_save.get(\"invalidate\"):",
          "1616:         config.mail_gmail_token = {}",
          "1617:         try:",
          "1618:             flag_modified(config, \"mail_gmail_token\")",
          "1619:         except AttributeError:",
          "1620:             pass",
          "1621:     elif to_save.get(\"gmail\"):",
          "1622:         try:",
          "1623:             config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
          "1624:             flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
          "1625:         except Exception as ex:",
          "1626:             flash(str(ex), category=\"error\")",
          "1627:             log.error(ex)",
          "1628:             return edit_mailsettings()",
          "1630:     else:",
          "1631:         _config_string(to_save, \"mail_server\")",
          "1632:         _config_int(to_save, \"mail_port\")",
          "1633:         _config_int(to_save, \"mail_use_ssl\")",
          "1634:         _config_string(to_save, \"mail_login\")",
          "1635:         _config_string(to_save, \"mail_password\")",
          "1636:         _config_string(to_save, \"mail_from\")",
          "1637:         _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
          "1639:         config.save()",
          "1640:     except (OperationalError, InvalidRequestError) as e:",
          "1641:         ub.session.rollback()",
          "1642:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1643:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1644:         return edit_mailsettings()",
          "1646:     if to_save.get(\"test\"):",
          "1647:         if current_user.email:",
          "1648:             result = send_test_mail(current_user.email, current_user.name)",
          "1649:             if result is None:",
          "1650:                 flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
          "1651:                         email=current_user.email), category=\"info\")",
          "1653:                 flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
          "1655:             flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
          "1656:     else:",
          "1657:         flash(_(u\"E-mail server settings updated\"), category=\"success\")",
          "1659:     return edit_mailsettings()",
          "1662: @admi.route(\"/admin/scheduledtasks\")",
          "1665: def edit_scheduledtasks():",
          "1666:     content = config.get_scheduled_task_settings()",
          "1667:     time_field = list()",
          "1668:     duration_field = list()",
          "1670:     for n in range(24):",
          "1671:         time_field.append((n , format_time(time(hour=n), format=\"short\",)))",
          "1672:     for n in range(5, 65, 5):",
          "1673:         t = timedelta(hours=n // 60, minutes=n % 60)",
          "1674:         duration_field.append((n, format_timedelta(t, threshold=.9)))",
          "1676:     return render_title_template(\"schedule_edit.html\", config=content, starttime=time_field, duration=duration_field, title=_(u\"Edit Scheduled Tasks Settings\"))",
          "1679: @admi.route(\"/admin/scheduledtasks\", methods=[\"POST\"])",
          "1680: @login_required",
          "1681: @admin_required",
          "1682: def update_scheduledtasks():",
          "1683:     error = False",
          "1685:     if 0 <= int(to_save.get(\"schedule_start_time\")) <= 23:",
          "1686:         _config_int(to_save, \"schedule_start_time\")",
          "1687:     else:",
          "1688:         flash(_(u\"Invalid start time for task specified\"), category=\"error\")",
          "1689:         error = True",
          "1690:     if 0 < int(to_save.get(\"schedule_duration\")) <= 60:",
          "1691:         _config_int(to_save, \"schedule_duration\")",
          "1692:     else:",
          "1693:         flash(_(u\"Invalid duration for task specified\"), category=\"error\")",
          "1694:         error = True",
          "1695:     _config_checkbox(to_save, \"schedule_generate_book_covers\")",
          "1696:     _config_checkbox(to_save, \"schedule_generate_series_covers\")",
          "1697:     _config_checkbox(to_save, \"schedule_reconnect\")",
          "1699:     if not error:",
          "1700:         try:",
          "1701:             config.save()",
          "1702:             flash(_(u\"Scheduled tasks settings updated\"), category=\"success\")",
          "1704:             # Cancel any running tasks",
          "1705:             schedule.end_scheduled_tasks()",
          "1707:             # Re-register tasks with new settings",
          "1708:             schedule.register_scheduled_tasks(config.schedule_reconnect)",
          "1709:         except IntegrityError:",
          "1710:             ub.session.rollback()",
          "1711:             log.error(\"An unknown error occurred while saving scheduled tasks settings\")",
          "1712:             flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1713:         except OperationalError:",
          "1714:             ub.session.rollback()",
          "1715:             log.error(\"Settings DB is not Writeable\")",
          "1716:             flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
          "1718:     return edit_scheduledtasks()",
          "1721: @admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
          "1722: @login_required",
          "1723: @admin_required",
          "1724: def edit_user(user_id):",
          "1725:     content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
          "1726:     if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
          "1727:         flash(_(u\"User not found\"), category=\"error\")",
          "1728:         return redirect(url_for('admin.admin'))",
          "1729:     languages = calibre_db.speaking_language(return_all_languages=True)",
          "1730:     translations = babel.list_translations() + [Locale('en')]",
          "1731:     kobo_support = feature_support['kobo'] and config.config_kobo_sync",
          "1732:     if request.method == \"POST\":",
          "1733:         to_save = request.form.to_dict()",
          "1734:         resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
          "1735:         if resp:",
          "1736:             return resp",
          "1737:     return render_title_template(\"user_edit.html\",",
          "1738:                                  translations=translations,",
          "1739:                                  languages=languages,",
          "1740:                                  new_user=0,",
          "1741:                                  content=content,",
          "1742:                                  config=config,",
          "1743:                                  registered_oauth=oauth_check,",
          "1744:                                  mail_configured=config.get_mail_server_configured(),",
          "1745:                                  kobo_support=kobo_support,",
          "1746:                                  title=_(u\"Edit User %(nick)s\", nick=content.name),",
          "1747:                                  page=\"edituser\")",
          "1750: @admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
          "1751: @login_required",
          "1752: @admin_required",
          "1753: def reset_user_password(user_id):",
          "1754:     if current_user is not None and current_user.is_authenticated:",
          "1755:         ret, message = reset_password(user_id)",
          "1756:         if ret == 1:",
          "1757:             log.debug(u\"Password for user %s reset\", message)",
          "1758:             flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
          "1759:         elif ret == 0:",
          "1760:             log.error(u\"An unknown error occurred. Please try again later.\")",
          "1761:             flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1762:         else:",
          "1763:             log.error(u\"Please configure the SMTP mail settings first...\")",
          "1764:             flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
          "1765:     return redirect(url_for('admin.admin'))",
          "1768: @admi.route(\"/admin/logfile\")",
          "1769: @login_required",
          "1770: @admin_required",
          "1771: def view_logfile():",
          "1772:     logfiles = {0: logger.get_logfile(config.config_logfile),",
          "1773:                 1: logger.get_accesslogfile(config.config_access_logfile)}",
          "1774:     return render_title_template(\"logviewer.html\",",
          "1775:                                  title=_(u\"Logfile viewer\"),",
          "1776:                                  accesslog_enable=config.config_access_log,",
          "1777:                                  log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
          "1778:                                  logfiles=logfiles,",
          "1779:                                  page=\"logfile\")",
          "1782: @admi.route(\"/ajax/log/<int:logtype>\")",
          "1783: @login_required",
          "1784: @admin_required",
          "1785: def send_logfile(logtype):",
          "1786:     if logtype == 1:",
          "1787:         logfile = logger.get_accesslogfile(config.config_access_logfile)",
          "1788:         return send_from_directory(os.path.dirname(logfile),",
          "1789:                                    os.path.basename(logfile))",
          "1790:     if logtype == 0:",
          "1791:         logfile = logger.get_logfile(config.config_logfile)",
          "1792:         return send_from_directory(os.path.dirname(logfile),",
          "1793:                                    os.path.basename(logfile))",
          "1794:     else:",
          "1795:         return \"\"",
          "1798: @admi.route(\"/admin/logdownload/<int:logtype>\")",
          "1799: @login_required",
          "1800: @admin_required",
          "1801: def download_log(logtype):",
          "1802:     if logtype == 0:",
          "1803:         file_name = logger.get_logfile(config.config_logfile)",
          "1804:     elif logtype == 1:",
          "1805:         file_name = logger.get_accesslogfile(config.config_access_logfile)",
          "1806:     else:",
          "1807:         abort(404)",
          "1808:     if logger.is_valid_logfile(file_name):",
          "1809:         return debug_info.assemble_logfiles(file_name)",
          "1810:     abort(404)",
          "1813: @admi.route(\"/admin/debug\")",
          "1814: @login_required",
          "1815: @admin_required",
          "1816: def download_debug():",
          "1817:     return debug_info.send_debug()",
          "1820: @admi.route(\"/get_update_status\", methods=['GET'])",
          "1821: @login_required",
          "1822: @admin_required",
          "1823: def get_update_status():",
          "1824:     if feature_support['updater']:",
          "1825:         log.info(u\"Update status requested\")",
          "1826:         return updater_thread.get_available_updates(request.method, locale=get_locale())",
          "1827:     else:",
          "1828:         return ''",
          "1831: @admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
          "1832: @login_required",
          "1833: @admin_required",
          "1834: def get_updater_status():",
          "1835:     status = {}",
          "1836:     if feature_support['updater']:",
          "1837:         if request.method == \"POST\":",
          "1838:             commit = request.form.to_dict()",
          "1839:             if \"start\" in commit and commit['start'] == 'True':",
          "1840:                 txt = {",
          "1841:                     \"1\": _(u'Requesting update package'),",
          "1842:                     \"2\": _(u'Downloading update package'),",
          "1843:                     \"3\": _(u'Unzipping update package'),",
          "1844:                     \"4\": _(u'Replacing files'),",
          "1845:                     \"5\": _(u'Database connections are closed'),",
          "1846:                     \"6\": _(u'Stopping server'),",
          "1847:                     \"7\": _(u'Update finished, please press okay and reload page'),",
          "1848:                     \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
          "1849:                     \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
          "1850:                     \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
          "1851:                     \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
          "1852:                     \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
          "1853:                     \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
          "1854:                 }",
          "1855:                 status['text'] = txt",
          "1856:                 updater_thread.status = 0",
          "1857:                 updater_thread.resume()",
          "1858:                 status['status'] = updater_thread.get_update_status()",
          "1859:         elif request.method == \"GET\":",
          "1860:             try:",
          "1861:                 status['status'] = updater_thread.get_update_status()",
          "1862:                 if status['status'] == -1:",
          "1863:                     status['status'] = 7",
          "1864:             except Exception:",
          "1865:                 status['status'] = 11",
          "1866:         return json.dumps(status)",
          "1867:     return ''",
          "1870: def ldap_import_create_user(user, user_data):",
          "1871:     user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
          "1873:     try:",
          "1874:         username = user_data[user_login_field][0].decode('utf-8')",
          "1875:     except KeyError as ex:",
          "1876:         log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
          "1877:         message = _(u'Failed to extract at least One LDAP User')",
          "1878:         return 0, message",
          "1880:     # check for duplicate username",
          "1881:     if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
          "1882:         # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
          "1883:         log.warning(\"LDAP User  %s Already in Database\", user_data)",
          "1884:         return 0, None",
          "1886:     kindlemail = ''",
          "1887:     if 'mail' in user_data:",
          "1888:         useremail = user_data['mail'][0].decode('utf-8')",
          "1889:         if len(user_data['mail']) > 1:",
          "1890:             kindlemail = user_data['mail'][1].decode('utf-8')",
          "1892:     else:",
          "1893:         log.debug('No Mail Field Found in LDAP Response')",
          "1894:         useremail = username + '@email.com'",
          "1897:         # check for duplicate email",
          "1898:         useremail = check_email(useremail)",
          "1900:         log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
          "1901:         return 0, None",
          "1902:     content = ub.User()",
          "1903:     content.name = username",
          "1904:     content.password = ''  # dummy password which will be replaced by ldap one",
          "1905:     content.email = useremail",
          "1906:     content.kindle_mail = kindlemail",
          "1907:     content.default_language = config.config_default_language",
          "1908:     content.locale = config.config_default_locale",
          "1909:     content.role = config.config_default_role",
          "1910:     content.sidebar_view = config.config_default_show",
          "1911:     content.allowed_tags = config.config_allowed_tags",
          "1912:     content.denied_tags = config.config_denied_tags",
          "1913:     content.allowed_column_value = config.config_allowed_column_value",
          "1914:     content.denied_column_value = config.config_denied_column_value",
          "1915:     ub.session.add(content)",
          "1918:         return 1, None    # increase no of users",
          "1919:     except Exception as ex:",
          "1920:         log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
          "1922:         message = _(u'Failed to Create at Least One LDAP User')",
          "1923:         return 0, message",
          "1926: @admi.route('/import_ldap_users', methods=[\"POST\"])",
          "1927: @login_required",
          "1928: @admin_required",
          "1929: def import_ldap_users():",
          "1930:     showtext = {}",
          "1931:     try:",
          "1932:         new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
          "1933:     except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
          "1934:         log.error_or_exception(e)",
          "1935:         showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
          "1936:         return json.dumps(showtext)",
          "1937:     if not new_users:",
          "1938:         log.debug('LDAP empty response')",
          "1939:         showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
          "1940:         return json.dumps(showtext)",
          "1942:     imported = 0",
          "1943:     for username in new_users:",
          "1944:         user = username.decode('utf-8')",
          "1945:         if '=' in user:",
          "1946:             # if member object field is empty take user object as filter",
          "1947:             if config.config_ldap_member_user_object:",
          "1948:                 query_filter = config.config_ldap_member_user_object",
          "1949:             else:",
          "1950:                 query_filter = config.config_ldap_user_object",
          "1951:             try:",
          "1952:                 user_identifier = extract_user_identifier(user, query_filter)",
          "1953:             except Exception as ex:",
          "1954:                 log.warning(ex)",
          "1955:                 continue",
          "1957:             user_identifier = user",
          "1958:             query_filter = None",
          "1960:             user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
          "1961:         except AttributeError as ex:",
          "1962:             log.error_or_exception(ex)",
          "1963:             continue",
          "1964:         if user_data:",
          "1965:             user_count, message = ldap_import_create_user(user, user_data)",
          "1966:             if message:",
          "1967:                 showtext['text'] = message",
          "1968:             else:",
          "1969:                 imported += user_count",
          "1971:             log.warning(\"LDAP User: %s Not Found\", user)",
          "1972:             showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
          "1973:     if not showtext:",
          "1974:         showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
          "1975:     return json.dumps(showtext)",
          "",
          "[Added Lines]",
          "1211: @admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
          "1212: @login_required",
          "1213: @admin_required",
          "1214: def new_user():",
          "1215:     content = ub.User()",
          "1216:     languages = calibre_db.speaking_language()",
          "1217:     translations = get_available_locale()",
          "1218:     kobo_support = feature_support['kobo'] and config.config_kobo_sync",
          "1219:     if request.method == \"POST\":",
          "1220:         to_save = request.form.to_dict()",
          "1221:         _handle_new_user(to_save, content, languages, translations, kobo_support)",
          "1222:     else:",
          "1223:         content.role = config.config_default_role",
          "1224:         content.sidebar_view = config.config_default_show",
          "1225:         content.locale = config.config_default_locale",
          "1226:         content.default_language = config.config_default_language",
          "1227:     return render_title_template(\"user_edit.html\", new_user=1, content=content,",
          "1228:                                  config=config, translations=translations,",
          "1229:                                  languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
          "1230:                                  kobo_support=kobo_support, registered_oauth=oauth_check)",
          "1233: @admi.route(\"/admin/mailsettings\")",
          "1234: @login_required",
          "1235: @admin_required",
          "1236: def edit_mailsettings():",
          "1237:     content = config.get_mail_settings()",
          "1238:     return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),",
          "1239:                                  page=\"mailset\", feature_support=feature_support)",
          "1242: @admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
          "1243: @login_required",
          "1244: @admin_required",
          "1245: def update_mailsettings():",
          "1247:     _config_int(to_save, \"mail_server_type\")",
          "1248:     if to_save.get(\"invalidate\"):",
          "1249:         config.mail_gmail_token = {}",
          "1250:         try:",
          "1251:             flag_modified(config, \"mail_gmail_token\")",
          "1252:         except AttributeError:",
          "1253:             pass",
          "1254:     elif to_save.get(\"gmail\"):",
          "1255:         try:",
          "1256:             config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
          "1257:             flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")",
          "1258:         except Exception as ex:",
          "1259:             flash(str(ex), category=\"error\")",
          "1260:             log.error(ex)",
          "1261:             return edit_mailsettings()",
          "1263:     else:",
          "1264:         _config_string(to_save, \"mail_server\")",
          "1265:         _config_int(to_save, \"mail_port\")",
          "1266:         _config_int(to_save, \"mail_use_ssl\")",
          "1267:         _config_string(to_save, \"mail_login\")",
          "1268:         _config_string(to_save, \"mail_password\")",
          "1269:         _config_string(to_save, \"mail_from\")",
          "1270:         _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)",
          "1272:         config.save()",
          "1276:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1277:         return edit_mailsettings()",
          "1279:     if to_save.get(\"test\"):",
          "1280:         if current_user.email:",
          "1281:             result = send_test_mail(current_user.email, current_user.name)",
          "1282:             if result is None:",
          "1283:                 flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
          "1284:                         email=current_user.email), category=\"info\")",
          "1285:             else:",
          "1286:                 flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
          "1287:         else:",
          "1288:             flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")",
          "1289:     else:",
          "1290:         flash(_(u\"E-mail server settings updated\"), category=\"success\")",
          "1292:     return edit_mailsettings()",
          "1295: @admi.route(\"/admin/scheduledtasks\")",
          "1296: @login_required",
          "1297: @admin_required",
          "1298: def edit_scheduledtasks():",
          "1299:     content = config.get_scheduled_task_settings()",
          "1300:     time_field = list()",
          "1301:     duration_field = list()",
          "1303:     for n in range(24):",
          "1304:         time_field.append((n , format_time(time(hour=n), format=\"short\",)))",
          "1305:     for n in range(5, 65, 5):",
          "1306:         t = timedelta(hours=n // 60, minutes=n % 60)",
          "1307:         duration_field.append((n, format_timedelta(t, threshold=.9)))",
          "1309:     return render_title_template(\"schedule_edit.html\",",
          "1310:                                  config=content,",
          "1311:                                  starttime=time_field,",
          "1312:                                  duration=duration_field,",
          "1313:                                  title=_(u\"Edit Scheduled Tasks Settings\"))",
          "1316: @admi.route(\"/admin/scheduledtasks\", methods=[\"POST\"])",
          "1317: @login_required",
          "1318: @admin_required",
          "1319: def update_scheduledtasks():",
          "1320:     error = False",
          "1321:     to_save = request.form.to_dict()",
          "1322:     if 0 <= int(to_save.get(\"schedule_start_time\")) <= 23:",
          "1323:         _config_int(to_save, \"schedule_start_time\")",
          "1324:     else:",
          "1325:         flash(_(u\"Invalid start time for task specified\"), category=\"error\")",
          "1326:         error = True",
          "1327:     if 0 < int(to_save.get(\"schedule_duration\")) <= 60:",
          "1328:         _config_int(to_save, \"schedule_duration\")",
          "1329:     else:",
          "1330:         flash(_(u\"Invalid duration for task specified\"), category=\"error\")",
          "1331:         error = True",
          "1332:     _config_checkbox(to_save, \"schedule_generate_book_covers\")",
          "1333:     _config_checkbox(to_save, \"schedule_generate_series_covers\")",
          "1334:     _config_checkbox(to_save, \"schedule_reconnect\")",
          "1336:     if not error:",
          "1337:         try:",
          "1338:             config.save()",
          "1339:             flash(_(u\"Scheduled tasks settings updated\"), category=\"success\")",
          "1341:             # Cancel any running tasks",
          "1342:             schedule.end_scheduled_tasks()",
          "1344:             # Re-register tasks with new settings",
          "1345:             schedule.register_scheduled_tasks(config.schedule_reconnect)",
          "1346:         except IntegrityError:",
          "1347:             ub.session.rollback()",
          "1348:             log.error(\"An unknown error occurred while saving scheduled tasks settings\")",
          "1349:             flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1350:         except OperationalError:",
          "1351:             ub.session.rollback()",
          "1352:             log.error(\"Settings DB is not Writeable\")",
          "1353:             flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
          "1355:     return edit_scheduledtasks()",
          "1358: @admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
          "1359: @login_required",
          "1360: @admin_required",
          "1361: def edit_user(user_id):",
          "1362:     content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
          "1363:     if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
          "1364:         flash(_(u\"User not found\"), category=\"error\")",
          "1365:         return redirect(url_for('admin.admin'))",
          "1366:     languages = calibre_db.speaking_language(return_all_languages=True)",
          "1367:     translations = get_available_locale()",
          "1368:     kobo_support = feature_support['kobo'] and config.config_kobo_sync",
          "1369:     if request.method == \"POST\":",
          "1370:         to_save = request.form.to_dict()",
          "1371:         resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
          "1372:         if resp:",
          "1373:             return resp",
          "1374:     return render_title_template(\"user_edit.html\",",
          "1375:                                  translations=translations,",
          "1376:                                  languages=languages,",
          "1377:                                  new_user=0,",
          "1378:                                  content=content,",
          "1379:                                  config=config,",
          "1380:                                  registered_oauth=oauth_check,",
          "1381:                                  mail_configured=config.get_mail_server_configured(),",
          "1382:                                  kobo_support=kobo_support,",
          "1383:                                  title=_(u\"Edit User %(nick)s\", nick=content.name),",
          "1384:                                  page=\"edituser\")",
          "1387: @admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
          "1388: @login_required",
          "1389: @admin_required",
          "1390: def reset_user_password(user_id):",
          "1391:     if current_user is not None and current_user.is_authenticated:",
          "1392:         ret, message = reset_password(user_id)",
          "1393:         if ret == 1:",
          "1394:             log.debug(u\"Password for user %s reset\", message)",
          "1395:             flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")",
          "1396:         elif ret == 0:",
          "1397:             log.error(u\"An unknown error occurred. Please try again later.\")",
          "1398:             flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1399:         else:",
          "1400:             log.error(u\"Please configure the SMTP mail settings first...\")",
          "1401:             flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")",
          "1402:     return redirect(url_for('admin.admin'))",
          "1405: @admi.route(\"/admin/logfile\")",
          "1406: @login_required",
          "1407: @admin_required",
          "1408: def view_logfile():",
          "1409:     logfiles = {0: logger.get_logfile(config.config_logfile),",
          "1410:                 1: logger.get_accesslogfile(config.config_access_logfile)}",
          "1411:     return render_title_template(\"logviewer.html\",",
          "1412:                                  title=_(u\"Logfile viewer\"),",
          "1413:                                  accesslog_enable=config.config_access_log,",
          "1414:                                  log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
          "1415:                                  logfiles=logfiles,",
          "1416:                                  page=\"logfile\")",
          "1419: @admi.route(\"/ajax/log/<int:logtype>\")",
          "1420: @login_required",
          "1421: @admin_required",
          "1422: def send_logfile(logtype):",
          "1423:     if logtype == 1:",
          "1424:         logfile = logger.get_accesslogfile(config.config_access_logfile)",
          "1425:         return send_from_directory(os.path.dirname(logfile),",
          "1426:                                    os.path.basename(logfile))",
          "1427:     if logtype == 0:",
          "1428:         logfile = logger.get_logfile(config.config_logfile)",
          "1429:         return send_from_directory(os.path.dirname(logfile),",
          "1430:                                    os.path.basename(logfile))",
          "1432:         return \"\"",
          "1435: @admi.route(\"/admin/logdownload/<int:logtype>\")",
          "1436: @login_required",
          "1437: @admin_required",
          "1438: def download_log(logtype):",
          "1439:     if logtype == 0:",
          "1440:         file_name = logger.get_logfile(config.config_logfile)",
          "1441:     elif logtype == 1:",
          "1442:         file_name = logger.get_accesslogfile(config.config_access_logfile)",
          "1444:         abort(404)",
          "1445:     if logger.is_valid_logfile(file_name):",
          "1446:         return debug_info.assemble_logfiles(file_name)",
          "1447:     abort(404)",
          "1450: @admi.route(\"/admin/debug\")",
          "1451: @login_required",
          "1452: @admin_required",
          "1453: def download_debug():",
          "1454:     return debug_info.send_debug()",
          "1457: @admi.route(\"/get_update_status\", methods=['GET'])",
          "1458: @login_required",
          "1459: @admin_required",
          "1460: def get_update_status():",
          "1461:     if feature_support['updater']:",
          "1462:         log.info(u\"Update status requested\")",
          "1463:         return updater_thread.get_available_updates(request.method, locale=get_locale())",
          "1464:     else:",
          "1465:         return ''",
          "1468: @admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
          "1469: @login_required",
          "1470: @admin_required",
          "1471: def get_updater_status():",
          "1472:     status = {}",
          "1473:     if feature_support['updater']:",
          "1474:         if request.method == \"POST\":",
          "1475:             commit = request.form.to_dict()",
          "1476:             if \"start\" in commit and commit['start'] == 'True':",
          "1477:                 txt = {",
          "1478:                     \"1\": _(u'Requesting update package'),",
          "1479:                     \"2\": _(u'Downloading update package'),",
          "1480:                     \"3\": _(u'Unzipping update package'),",
          "1481:                     \"4\": _(u'Replacing files'),",
          "1482:                     \"5\": _(u'Database connections are closed'),",
          "1483:                     \"6\": _(u'Stopping server'),",
          "1484:                     \"7\": _(u'Update finished, please press okay and reload page'),",
          "1485:                     \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
          "1486:                     \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
          "1487:                     \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
          "1488:                     \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
          "1489:                     \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
          "1490:                     \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
          "1491:                 }",
          "1492:                 status['text'] = txt",
          "1493:                 updater_thread.status = 0",
          "1494:                 updater_thread.resume()",
          "1495:                 status['status'] = updater_thread.get_update_status()",
          "1496:         elif request.method == \"GET\":",
          "1497:             try:",
          "1498:                 status['status'] = updater_thread.get_update_status()",
          "1499:                 if status['status'] == -1:",
          "1500:                     status['status'] = 7",
          "1501:             except Exception:",
          "1502:                 status['status'] = 11",
          "1503:         return json.dumps(status)",
          "1504:     return ''",
          "1507: def ldap_import_create_user(user, user_data):",
          "1508:     user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
          "1511:         username = user_data[user_login_field][0].decode('utf-8')",
          "1512:     except KeyError as ex:",
          "1513:         log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
          "1514:         message = _(u'Failed to extract at least One LDAP User')",
          "1515:         return 0, message",
          "1517:     # check for duplicate username",
          "1518:     if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
          "1519:         # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
          "1520:         log.warning(\"LDAP User  %s Already in Database\", user_data)",
          "1521:         return 0, None",
          "1523:     kindlemail = ''",
          "1524:     if 'mail' in user_data:",
          "1525:         useremail = user_data['mail'][0].decode('utf-8')",
          "1526:         if len(user_data['mail']) > 1:",
          "1527:             kindlemail = user_data['mail'][1].decode('utf-8')",
          "1529:     else:",
          "1530:         log.debug('No Mail Field Found in LDAP Response')",
          "1531:         useremail = username + '@email.com'",
          "1533:     try:",
          "1534:         # check for duplicate email",
          "1535:         useremail = check_email(useremail)",
          "1536:     except Exception as ex:",
          "1537:         log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
          "1538:         return 0, None",
          "1539:     content = ub.User()",
          "1540:     content.name = username",
          "1541:     content.password = ''  # dummy password which will be replaced by ldap one",
          "1542:     content.email = useremail",
          "1543:     content.kindle_mail = kindlemail",
          "1544:     content.default_language = config.config_default_language",
          "1545:     content.locale = config.config_default_locale",
          "1546:     content.role = config.config_default_role",
          "1547:     content.sidebar_view = config.config_default_show",
          "1548:     content.allowed_tags = config.config_allowed_tags",
          "1549:     content.denied_tags = config.config_denied_tags",
          "1550:     content.allowed_column_value = config.config_allowed_column_value",
          "1551:     content.denied_column_value = config.config_denied_column_value",
          "1552:     ub.session.add(content)",
          "1553:     try:",
          "1554:         ub.session.commit()",
          "1555:         return 1, None    # increase no of users",
          "1556:     except Exception as ex:",
          "1557:         log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
          "1558:         ub.session.rollback()",
          "1559:         message = _(u'Failed to Create at Least One LDAP User')",
          "1560:         return 0, message",
          "1563: @admi.route('/import_ldap_users', methods=[\"POST\"])",
          "1566: def import_ldap_users():",
          "1567:     showtext = {}",
          "1569:         new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
          "1570:     except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
          "1571:         log.error_or_exception(e)",
          "1572:         showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
          "1573:         return json.dumps(showtext)",
          "1574:     if not new_users:",
          "1575:         log.debug('LDAP empty response')",
          "1576:         showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
          "1577:         return json.dumps(showtext)",
          "1579:     imported = 0",
          "1580:     for username in new_users:",
          "1581:         user = username.decode('utf-8')",
          "1582:         if '=' in user:",
          "1583:             # if member object field is empty take user object as filter",
          "1584:             if config.config_ldap_member_user_object:",
          "1585:                 query_filter = config.config_ldap_member_user_object",
          "1587:                 query_filter = config.config_ldap_user_object",
          "1588:             try:",
          "1589:                 user_identifier = extract_user_identifier(user, query_filter)",
          "1590:             except Exception as ex:",
          "1591:                 log.warning(ex)",
          "1592:                 continue",
          "1594:             user_identifier = user",
          "1595:             query_filter = None",
          "1596:         try:",
          "1597:             user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
          "1598:         except AttributeError as ex:",
          "1599:             log.error_or_exception(ex)",
          "1600:             continue",
          "1601:         if user_data:",
          "1602:             user_count, message = ldap_import_create_user(user, user_data)",
          "1603:             if message:",
          "1604:                 showtext['text'] = message",
          "1605:             else:",
          "1606:                 imported += user_count",
          "1607:         else:",
          "1608:             log.warning(\"LDAP User: %s Not Found\", user)",
          "1609:             showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
          "1610:     if not showtext:",
          "1611:         showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
          "1612:     return json.dumps(showtext)",
          "1615: @admi.route(\"/ajax/canceltask\", methods=['POST'])",
          "1618: def cancel_task():",
          "1619:     task_id = request.get_json().get('task_id', None)",
          "1620:     worker = WorkerThread.get_instance()",
          "1621:     worker.end_task(task_id)",
          "1622:     return \"\"",
          "1625: def _db_simulate_change():",
          "1626:     param = request.form.to_dict()",
          "1627:     to_save = dict()",
          "1628:     to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
          "1629:                                            '',",
          "1630:                                            param['config_calibre_dir'],",
          "1631:                                            flags=re.IGNORECASE).strip()",
          "1632:     db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],",
          "1633:                                                     ub.app_DB_path,",
          "1634:                                                     config.config_calibre_uuid)",
          "1635:     db_change = bool(db_change and config.config_calibre_dir)",
          "1636:     return db_change, db_valid",
          "1639: def _db_configuration_update_helper():",
          "1640:     db_change = False",
          "1642:     gdrive_error = None",
          "1644:     to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
          "1645:                                            '',",
          "1646:                                            to_save['config_calibre_dir'],",
          "1647:                                            flags=re.IGNORECASE)",
          "1648:     db_valid = False",
          "1649:     try:",
          "1650:         db_change, db_valid = _db_simulate_change()",
          "1652:         # gdrive_error drive setup",
          "1653:         gdrive_error = _configuration_gdrive_helper(to_save)",
          "1654:     except (OperationalError, InvalidRequestError) as e:",
          "1655:         ub.session.rollback()",
          "1656:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1657:         _db_configuration_result(_(u\"Database error: %(error)s.\", error=e.orig), gdrive_error)",
          "1658:     try:",
          "1659:         metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
          "1660:         if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
          "1661:             gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
          "1662:             db_change = True",
          "1663:     except Exception as ex:",
          "1664:         return _db_configuration_result('{}'.format(ex), gdrive_error)",
          "1666:     if db_change or not db_valid or not config.db_configured \\",
          "1667:             or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:",
          "1668:         if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):",
          "1669:             return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),",
          "1670:                                             gdrive_error)",
          "1671:         config.store_calibre_uuid(calibre_db, db.Library_Id)",
          "1672:         # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
          "1673:         if db_change:",
          "1674:             log.info(\"Calibre Database changed, all Calibre-Web info related to old Database gets deleted\")",
          "1675:             ub.session.query(ub.Downloads).delete()",
          "1676:             ub.session.query(ub.ArchivedBook).delete()",
          "1677:             ub.session.query(ub.ReadBook).delete()",
          "1678:             ub.session.query(ub.BookShelf).delete()",
          "1679:             ub.session.query(ub.Bookmark).delete()",
          "1680:             ub.session.query(ub.KoboReadingState).delete()",
          "1681:             ub.session.query(ub.KoboStatistics).delete()",
          "1682:             ub.session.query(ub.KoboSyncedBooks).delete()",
          "1683:             helper.delete_thumbnail_cache()",
          "1684:             ub.session_commit()",
          "1685:         _config_string(to_save, \"config_calibre_dir\")",
          "1686:         calibre_db.update_config(config)",
          "1687:         if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
          "1688:             flash(_(u\"DB is not Writeable\"), category=\"warning\")",
          "1689:     config.save()",
          "1690:     return _db_configuration_result(None, gdrive_error)",
          "1693: def _configuration_update_helper():",
          "1694:     reboot_required = False",
          "1695:     to_save = request.form.to_dict()",
          "1696:     try:",
          "1697:         reboot_required |= _config_int(to_save, \"config_port\")",
          "1698:         reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
          "1699:         reboot_required |= _config_string(to_save, \"config_keyfile\")",
          "1700:         if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
          "1701:             return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
          "1703:         reboot_required |= _config_string(to_save, \"config_certfile\")",
          "1704:         if config.config_certfile and not os.path.isfile(config.config_certfile):",
          "1705:             return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
          "1707:         _config_checkbox_int(to_save, \"config_uploading\")",
          "1708:         _config_checkbox_int(to_save, \"config_unicode_filename\")",
          "1709:         # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
          "1710:         reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
          "1711:                             and config.config_login_type == constants.LOGIN_LDAP)",
          "1712:         _config_checkbox_int(to_save, \"config_public_reg\")",
          "1713:         _config_checkbox_int(to_save, \"config_register_email\")",
          "1714:         reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
          "1715:         _config_int(to_save, \"config_external_port\")",
          "1716:         _config_checkbox_int(to_save, \"config_kobo_proxy\")",
          "1718:         if \"config_upload_formats\" in to_save:",
          "1719:             to_save[\"config_upload_formats\"] = ','.join(",
          "1720:                 helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
          "1721:             _config_string(to_save, \"config_upload_formats\")",
          "1722:             constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
          "1724:         _config_string(to_save, \"config_calibre\")",
          "1725:         _config_string(to_save, \"config_converterpath\")",
          "1726:         _config_string(to_save, \"config_kepubifypath\")",
          "1728:         reboot_required |= _config_int(to_save, \"config_login_type\")",
          "1730:         # LDAP configurator",
          "1731:         if config.config_login_type == constants.LOGIN_LDAP:",
          "1732:             reboot, message = _configuration_ldap_helper(to_save)",
          "1733:             if message:",
          "1734:                 return message",
          "1735:             reboot_required |= reboot",
          "1737:         # Remote login configuration",
          "1738:         _config_checkbox(to_save, \"config_remote_login\")",
          "1739:         if not config.config_remote_login:",
          "1740:             ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
          "1742:         # Goodreads configuration",
          "1743:         _config_checkbox(to_save, \"config_use_goodreads\")",
          "1744:         _config_string(to_save, \"config_goodreads_api_key\")",
          "1745:         _config_string(to_save, \"config_goodreads_api_secret\")",
          "1746:         if services.goodreads_support:",
          "1747:             services.goodreads_support.connect(config.config_goodreads_api_key,",
          "1748:                                                config.config_goodreads_api_secret,",
          "1749:                                                config.config_use_goodreads)",
          "1751:         _config_int(to_save, \"config_updatechannel\")",
          "1753:         # Reverse proxy login configuration",
          "1754:         _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
          "1755:         _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
          "1757:         # OAuth configuration",
          "1758:         if config.config_login_type == constants.LOGIN_OAUTH:",
          "1759:             reboot_required |= _configuration_oauth_helper(to_save)",
          "1761:         reboot, message = _configuration_logfile_helper(to_save)",
          "1762:         if message:",
          "1763:             return message",
          "1764:         reboot_required |= reboot",
          "1765:         # Rarfile Content configuration",
          "1766:         _config_string(to_save, \"config_rarfile_location\")",
          "1767:         if \"config_rarfile_location\" in to_save:",
          "1768:             unrar_status = helper.check_unrar(config.config_rarfile_location)",
          "1769:             if unrar_status:",
          "1770:                 return _configuration_result(unrar_status)",
          "1771:     except (OperationalError, InvalidRequestError) as e:",
          "1772:         ub.session.rollback()",
          "1773:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1774:         _configuration_result(_(u\"Database error: %(error)s.\", error=e.orig))",
          "1776:     config.save()",
          "1777:     if reboot_required:",
          "1778:         web_server.stop(True)",
          "1780:     return _configuration_result(None, reboot_required)",
          "1783: def _configuration_result(error_flash=None, reboot=False):",
          "1784:     resp = {}",
          "1785:     if error_flash:",
          "1786:         log.error(error_flash)",
          "1787:         config.load()",
          "1788:         resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
          "1789:     else:",
          "1790:         resp['result'] = [{'type': \"success\", 'message': _(u\"Calibre-Web configuration updated\")}]",
          "1791:     resp['reboot'] = reboot",
          "1792:     resp['config_upload'] = config.config_upload_formats",
          "1793:     return Response(json.dumps(resp), mimetype='application/json')",
          "1796: def _db_configuration_result(error_flash=None, gdrive_error=None):",
          "1797:     gdrive_authenticate = not is_gdrive_ready()",
          "1798:     gdrivefolders = []",
          "1799:     if not gdrive_error and config.config_use_google_drive:",
          "1800:         gdrive_error = gdriveutils.get_error_text()",
          "1801:     if gdrive_error and gdrive_support:",
          "1802:         log.error(gdrive_error)",
          "1803:         gdrive_error = _(gdrive_error)",
          "1804:         flash(gdrive_error, category=\"error\")",
          "1805:     else:",
          "1806:         if not gdrive_authenticate and gdrive_support:",
          "1807:             gdrivefolders = gdriveutils.listRootFolders()",
          "1808:     if error_flash:",
          "1809:         log.error(error_flash)",
          "1810:         config.load()",
          "1811:         flash(error_flash, category=\"error\")",
          "1812:     elif request.method == \"POST\" and not gdrive_error:",
          "1813:         flash(_(\"Database Settings updated\"), category=\"success\")",
          "1815:     return render_title_template(\"config_db.html\",",
          "1816:                                  config=config,",
          "1817:                                  show_authenticate_google_drive=gdrive_authenticate,",
          "1818:                                  gdriveError=gdrive_error,",
          "1819:                                  gdrivefolders=gdrivefolders,",
          "1820:                                  feature_support=feature_support,",
          "1821:                                  title=_(u\"Database Configuration\"), page=\"dbconfig\")",
          "1824: def _handle_new_user(to_save, content, languages, translations, kobo_support):",
          "1825:     content.default_language = to_save[\"default_language\"]",
          "1826:     content.locale = to_save.get(\"locale\", content.locale)",
          "1828:     content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
          "1829:     if \"show_detail_random\" in to_save:",
          "1830:         content.sidebar_view |= constants.DETAIL_RANDOM",
          "1832:     content.role = constants.selected_roles(to_save)",
          "1833:     content.password = generate_password_hash(to_save[\"password\"])",
          "1835:         if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
          "1836:             log.info(\"Missing entries on new user\")",
          "1837:             raise Exception(_(u\"Please fill out all fields!\"))",
          "1838:         content.email = check_email(to_save[\"email\"])",
          "1839:         # Query User name, if not existing, change",
          "1840:         content.name = check_username(to_save[\"name\"])",
          "1841:         if to_save.get(\"kindle_mail\"):",
          "1842:             content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
          "1843:         if config.config_public_reg and not check_valid_domain(content.email):",
          "1844:             log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
          "1845:             raise Exception(_(u\"E-mail is not from valid domain\"))",
          "1847:         flash(str(ex), category=\"error\")",
          "1848:         return render_title_template(\"user_edit.html\", new_user=1, content=content,",
          "1849:                                      config=config,",
          "1850:                                      translations=translations,",
          "1851:                                      languages=languages, title=_(u\"Add new user\"), page=\"newuser\",",
          "1852:                                      kobo_support=kobo_support, registered_oauth=oauth_check)",
          "1854:         content.allowed_tags = config.config_allowed_tags",
          "1855:         content.denied_tags = config.config_denied_tags",
          "1856:         content.allowed_column_value = config.config_allowed_column_value",
          "1857:         content.denied_column_value = config.config_denied_column_value",
          "1858:         # No default value for kobo sync shelf setting",
          "1859:         content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
          "1860:         ub.session.add(content)",
          "1862:         flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")",
          "1863:         log.debug(\"User {} created\".format(content.name))",
          "1864:         return redirect(url_for('admin.admin'))",
          "1865:     except IntegrityError:",
          "1867:         log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
          "1868:         flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")",
          "1869:     except OperationalError as e:",
          "1870:         ub.session.rollback()",
          "1871:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1872:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1875: def _delete_user(content):",
          "1876:     if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
          "1877:                                         ub.User.id != content.id).count():",
          "1878:         if content.name != \"Guest\":",
          "1879:             # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
          "1880:             # and user itself",
          "1881:             ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
          "1882:             ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
          "1883:             for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
          "1884:                 ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
          "1885:             ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
          "1886:             ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
          "1887:             ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
          "1888:             ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
          "1889:             ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
          "1890:             ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
          "1891:             ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
          "1892:             # delete KoboReadingState and all it's children",
          "1893:             kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
          "1894:             for kobo_entry in kobo_entries:",
          "1895:                 ub.session.delete(kobo_entry)",
          "1896:             ub.session_commit()",
          "1897:             log.info(\"User {} deleted\".format(content.name))",
          "1898:             return _(\"User '%(nick)s' deleted\", nick=content.name)",
          "1900:             log.warning(_(\"Can't delete Guest User\"))",
          "1901:             raise Exception(_(\"Can't delete Guest User\"))",
          "1902:     else:",
          "1903:         log.warning(\"No admin user remaining, can't delete user\")",
          "1904:         raise Exception(_(\"No admin user remaining, can't delete user\"))",
          "1907: def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
          "1908:     if to_save.get(\"delete\"):",
          "1910:             flash(_delete_user(content), category=\"success\")",
          "1911:         except Exception as ex:",
          "1912:             log.error(ex)",
          "1913:             flash(str(ex), category=\"error\")",
          "1914:         return redirect(url_for('admin.admin'))",
          "1915:     else:",
          "1916:         if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
          "1917:                                                 ub.User.id != content.id).count() and 'admin_role' not in to_save:",
          "1918:             log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
          "1919:             flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
          "1920:             return redirect(url_for('admin.admin'))",
          "1921:         if to_save.get(\"password\"):",
          "1922:             content.password = generate_password_hash(to_save[\"password\"])",
          "1923:         anonymous = content.is_anonymous",
          "1924:         content.role = constants.selected_roles(to_save)",
          "1925:         if anonymous:",
          "1926:             content.role |= constants.ROLE_ANONYMOUS",
          "1928:             content.role &= ~constants.ROLE_ANONYMOUS",
          "1930:         val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
          "1931:         sidebar, __ = get_sidebar_config()",
          "1932:         for element in sidebar:",
          "1933:             value = element['visibility']",
          "1934:             if value in val and not content.check_visibility(value):",
          "1935:                 content.sidebar_view |= value",
          "1936:             elif value not in val and content.check_visibility(value):",
          "1937:                 content.sidebar_view &= ~value",
          "1939:         if to_save.get(\"Show_detail_random\"):",
          "1940:             content.sidebar_view |= constants.DETAIL_RANDOM",
          "1941:         else:",
          "1942:             content.sidebar_view &= ~constants.DETAIL_RANDOM",
          "1944:         old_state = content.kobo_only_shelves_sync",
          "1945:         content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
          "1946:         # 1 -> 0: nothing has to be done",
          "1947:         # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
          "1948:         # which don't have to be synced have to be removed (added to Shelf archive)",
          "1949:         if old_state == 0 and content.kobo_only_shelves_sync == 1:",
          "1950:             kobo_sync_status.update_on_sync_shelfs(content.id)",
          "1951:         if to_save.get(\"default_language\"):",
          "1952:             content.default_language = to_save[\"default_language\"]",
          "1953:         if to_save.get(\"locale\"):",
          "1954:             content.locale = to_save[\"locale\"]",
          "1955:         try:",
          "1956:             if to_save.get(\"email\", content.email) != content.email:",
          "1957:                 content.email = check_email(to_save[\"email\"])",
          "1958:             # Query User name, if not existing, change",
          "1959:             if to_save.get(\"name\", content.name) != content.name:",
          "1960:                 if to_save.get(\"name\") == \"Guest\":",
          "1961:                     raise Exception(_(\"Guest Name can't be changed\"))",
          "1962:                 content.name = check_username(to_save[\"name\"])",
          "1963:             if to_save.get(\"kindle_mail\") != content.kindle_mail:",
          "1964:                 content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
          "1965:         except Exception as ex:",
          "1966:             log.error(ex)",
          "1967:             flash(str(ex), category=\"error\")",
          "1968:             return render_title_template(\"user_edit.html\",",
          "1969:                                          translations=translations,",
          "1970:                                          languages=languages,",
          "1971:                                          mail_configured=config.get_mail_server_configured(),",
          "1972:                                          kobo_support=kobo_support,",
          "1973:                                          new_user=0,",
          "1974:                                          content=content,",
          "1975:                                          config=config,",
          "1976:                                          registered_oauth=oauth_check,",
          "1977:                                          title=_(u\"Edit User %(nick)s\", nick=content.name),",
          "1978:                                          page=\"edituser\")",
          "1979:     try:",
          "1980:         ub.session_commit()",
          "1981:         flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
          "1982:     except IntegrityError as ex:",
          "1983:         ub.session.rollback()",
          "1984:         log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
          "1985:         flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")",
          "1986:     except OperationalError as e:",
          "1987:         ub.session.rollback()",
          "1988:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "1989:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1990:     return \"\"",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1994: def extract_user_identifier(user, filtr):",
          "1995:     dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
          "1996:     return extract_user_data_from_field(user, dynamic_field)",
          "",
          "[Removed Lines]",
          "1999: @admi.route(\"/ajax/canceltask\", methods=['POST'])",
          "2000: @login_required",
          "2001: @admin_required",
          "2002: def cancel_task():",
          "2003:     task_id = request.get_json().get('task_id', None)",
          "2004:     worker = WorkerThread.get_instance()",
          "2005:     worker.end_task(task_id)",
          "2006:     return \"\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "cps/babel.py||cps/babel.py": [
          "File: cps/babel.py -> cps/babel.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: from babel import negotiate_locale",
          "3: from flask_babel import Babel",
          "4: from babel.core import UnknownLocaleError",
          "",
          "[Removed Lines]",
          "1: from babel import Locale as LC",
          "",
          "[Added Lines]",
          "1: from babel import Locale",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9: log = logger.create()",
          "11: babel = Babel()",
          "14: @babel.localeselector",
          "15: def get_locale():",
          "",
          "[Removed Lines]",
          "12: BABEL_TRANSLATIONS = set()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "23:     if request.accept_languages:",
          "24:         for x in request.accept_languages.values():",
          "25:             try:",
          "27:             except (UnknownLocaleError, ValueError) as e:",
          "28:                 log.debug('Could not parse locale \"%s\": %s', x, e)",
          "",
          "[Removed Lines]",
          "26:                 preferred.append(str(LC.parse(x.replace('-', '_'))))",
          "30:     return negotiate_locale(preferred or ['en'], BABEL_TRANSLATIONS)",
          "",
          "[Added Lines]",
          "26:                 preferred.append(str(Locale.parse(x.replace('-', '_'))))",
          "30:     return negotiate_locale(preferred or ['en'], get_available_translations())",
          "33: def get_user_locale_language(user_language):",
          "34:     return Locale.parse(user_language).get_language_name(get_locale())",
          "36: def get_available_locale():",
          "37:     return [Locale('en')] + babel.list_translations()",
          "39: def get_available_translations():",
          "40:     return set(str(item) for item in get_available_locale())",
          "",
          "---------------"
        ],
        "cps/editbooks.py||cps/editbooks.py": [
          "File: cps/editbooks.py -> cps/editbooks.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: from flask_babel import get_locale",
          "40: from flask_login import current_user, login_required",
          "41: from sqlalchemy.exc import OperationalError, IntegrityError",
          "43: from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
          "46: from .services.worker import WorkerThread",
          "47: from .tasks.upload import TaskUpload",
          "48: from .render_template import render_title_template",
          "",
          "[Removed Lines]",
          "42: # from sqlite3 import OperationalError as sqliteOperationalError",
          "44: from . import config, ub, db",
          "45: from . import calibre_db",
          "",
          "[Added Lines]",
          "44: from . import config, ub, db, calibre_db",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:     return inner",
          "232: @editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
          "233: @login_required",
          "234: def delete_book_from_details(book_id):",
          "",
          "[Removed Lines]",
          "77: def search_objects_remove(db_book_object, db_type, input_elements):",
          "78:     del_elements = []",
          "79:     for c_elements in db_book_object:",
          "80:         found = False",
          "81:         if db_type == 'languages':",
          "82:             type_elements = c_elements.lang_code",
          "83:         elif db_type == 'custom':",
          "84:             type_elements = c_elements.value",
          "85:         else:",
          "86:             type_elements = c_elements.name",
          "87:         for inp_element in input_elements:",
          "88:             if inp_element.lower() == type_elements.lower():",
          "89:                 found = True",
          "90:                 break",
          "91:         # if the element was not found in the new list, add it to remove list",
          "92:         if not found:",
          "93:             del_elements.append(c_elements)",
          "94:     return del_elements",
          "97: def search_objects_add(db_book_object, db_type, input_elements):",
          "98:     add_elements = []",
          "99:     for inp_element in input_elements:",
          "100:         found = False",
          "101:         for c_elements in db_book_object:",
          "102:             if db_type == 'languages':",
          "103:                 type_elements = c_elements.lang_code",
          "104:             elif db_type == 'custom':",
          "105:                 type_elements = c_elements.value",
          "106:             else:",
          "107:                 type_elements = c_elements.name",
          "108:             if inp_element == type_elements:",
          "109:                 found = True",
          "110:                 break",
          "111:         if not found:",
          "112:             add_elements.append(inp_element)",
          "113:     return add_elements",
          "116: def remove_objects(db_book_object, db_session, del_elements):",
          "117:     changed = False",
          "118:     if len(del_elements) > 0:",
          "119:         for del_element in del_elements:",
          "120:             db_book_object.remove(del_element)",
          "121:             changed = True",
          "122:             if len(del_element.books) == 0:",
          "123:                 db_session.delete(del_element)",
          "124:     return changed",
          "127: def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
          "128:     changed = False",
          "129:     if db_type == 'languages':",
          "130:         db_filter = db_object.lang_code",
          "131:     elif db_type == 'custom':",
          "132:         db_filter = db_object.value",
          "133:     else:",
          "134:         db_filter = db_object.name",
          "135:     for add_element in add_elements:",
          "136:         # check if an element with that name exists",
          "137:         db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
          "138:         # if no element is found add it",
          "139:         if db_type == 'author':",
          "140:             new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
          "141:         elif db_type == 'series':",
          "142:             new_element = db_object(add_element, add_element)",
          "143:         elif db_type == 'custom':",
          "144:             new_element = db_object(value=add_element)",
          "145:         elif db_type == 'publisher':",
          "146:             new_element = db_object(add_element, None)",
          "147:         else:  # db_type should be tag or language",
          "148:             new_element = db_object(add_element)",
          "149:         if db_element is None:",
          "150:             changed = True",
          "151:             db_session.add(new_element)",
          "152:             db_book_object.append(new_element)",
          "153:         else:",
          "154:             db_element = create_objects_for_addition(db_element, add_element, db_type)",
          "155:             # add element to book",
          "156:             changed = True",
          "157:             db_book_object.append(db_element)",
          "158:     return changed",
          "161: def create_objects_for_addition(db_element, add_element, db_type):",
          "162:     if db_type == 'custom':",
          "163:         if db_element.value != add_element:",
          "164:             db_element.value = add_element",
          "165:     elif db_type == 'languages':",
          "166:         if db_element.lang_code != add_element:",
          "167:             db_element.lang_code = add_element",
          "168:     elif db_type == 'series':",
          "169:         if db_element.name != add_element:",
          "170:             db_element.name = add_element",
          "171:             db_element.sort = add_element",
          "172:     elif db_type == 'author':",
          "173:         if db_element.name != add_element:",
          "174:             db_element.name = add_element",
          "175:             db_element.sort = helper.get_sorted_author(add_element.replace('|', ','))",
          "176:     elif db_type == 'publisher':",
          "177:         if db_element.name != add_element:",
          "178:             db_element.name = add_element",
          "179:             db_element.sort = None",
          "180:     elif db_element.name != add_element:",
          "181:         db_element.name = add_element",
          "182:     return db_element",
          "185: # Modifies different Database objects, first check if elements have to be deleted,",
          "186: # because they are no longer used, than check if elements have to be added to database",
          "187: def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
          "188:     # passing input_elements not as a list may lead to undesired results",
          "189:     if not isinstance(input_elements, list):",
          "190:         raise TypeError(str(input_elements) + \" should be passed as a list\")",
          "191:     input_elements = [x for x in input_elements if x != '']",
          "192:     # we have all input element (authors, series, tags) names now",
          "193:     # 1. search for elements to remove",
          "194:     del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
          "195:     # 2. search for elements that need to be added",
          "196:     add_elements = search_objects_add(db_book_object, db_type, input_elements)",
          "197:     # if there are elements to remove, we remove them now",
          "198:     changed = remove_objects(db_book_object, db_session, del_elements)",
          "199:     # if there are elements to add, we add them now!",
          "200:     if len(add_elements) > 0:",
          "201:         changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
          "202:     return changed",
          "205: def modify_identifiers(input_identifiers, db_identifiers, db_session):",
          "206:     \"\"\"Modify Identifiers to match input information.",
          "207:        input_identifiers is a list of read-to-persist Identifiers objects.",
          "208:        db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
          "209:     changed = False",
          "210:     error = False",
          "211:     input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
          "212:     if len(input_identifiers) != len(input_dict):",
          "213:         error = True",
          "214:     db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers])",
          "215:     # delete db identifiers not present in input or modify them with input val",
          "216:     for identifier_type, identifier in db_dict.items():",
          "217:         if identifier_type not in input_dict.keys():",
          "218:             db_session.delete(identifier)",
          "219:             changed = True",
          "220:         else:",
          "221:             input_identifier = input_dict[identifier_type]",
          "222:             identifier.type = input_identifier.type",
          "223:             identifier.val = input_identifier.val",
          "224:     # add input identifiers not present in db",
          "225:     for identifier_type, identifier in input_dict.items():",
          "226:         if identifier_type not in db_dict.keys():",
          "227:             db_session.add(identifier)",
          "228:             changed = True",
          "229:     return changed, error",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:     return delete_book_from_table(book_id, book_format, False)",
          "583:     cc = (calibre_db.session.query(db.CustomColumns)",
          "602:             else:",
          "607:                 else:",
          "645:             else:",
          "898: def merge_metadata(to_save, meta):",
          "",
          "[Removed Lines]",
          "245: def delete_whole_book(book_id, book):",
          "246:     # delete book from shelves, Downloads, Read list",
          "247:     ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
          "248:     ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
          "249:     ub.delete_download(book_id)",
          "250:     ub.session_commit()",
          "252:     # check if only this book links to:",
          "253:     # author, language, series, tags, custom columns",
          "254:     modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
          "255:     modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
          "256:     modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
          "257:     modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
          "258:     modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
          "260:     cc = calibre_db.session.query(db.CustomColumns). \\",
          "261:         filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "262:     for c in cc:",
          "263:         cc_string = \"custom_column_\" + str(c.id)",
          "264:         if not c.is_multiple:",
          "265:             if len(getattr(book, cc_string)) > 0:",
          "266:                 if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
          "267:                     del_cc = getattr(book, cc_string)[0]",
          "268:                     getattr(book, cc_string).remove(del_cc)",
          "269:                     log.debug('remove ' + str(c.id))",
          "270:                     calibre_db.session.delete(del_cc)",
          "271:                     calibre_db.session.commit()",
          "272:                 elif c.datatype == 'rating':",
          "273:                     del_cc = getattr(book, cc_string)[0]",
          "274:                     getattr(book, cc_string).remove(del_cc)",
          "275:                     if len(del_cc.books) == 0:",
          "276:                         log.debug('remove ' + str(c.id))",
          "277:                         calibre_db.session.delete(del_cc)",
          "278:                         calibre_db.session.commit()",
          "279:                 else:",
          "280:                     del_cc = getattr(book, cc_string)[0]",
          "281:                     getattr(book, cc_string).remove(del_cc)",
          "282:                     log.debug('remove ' + str(c.id))",
          "283:                     calibre_db.session.delete(del_cc)",
          "284:                     calibre_db.session.commit()",
          "285:         else:",
          "286:             modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
          "287:                                    calibre_db.session, 'custom')",
          "288:     calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
          "291: def render_delete_book_result(book_format, json_response, warning, book_id):",
          "292:     if book_format:",
          "293:         if json_response:",
          "294:             return json.dumps([warning, {\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "295:                                          \"type\": \"success\",",
          "296:                                          \"format\": book_format,",
          "297:                                          \"message\": _('Book Format Successfully Deleted')}])",
          "298:         else:",
          "299:             flash(_('Book Format Successfully Deleted'), category=\"success\")",
          "300:             return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "301:     else:",
          "302:         if json_response:",
          "303:             return json.dumps([warning, {\"location\": url_for('web.index'),",
          "304:                                          \"type\": \"success\",",
          "305:                                          \"format\": book_format,",
          "306:                                          \"message\": _('Book Successfully Deleted')}])",
          "307:         else:",
          "308:             flash(_('Book Successfully Deleted'), category=\"success\")",
          "309:             return redirect(url_for('web.index'))",
          "312: def delete_book_from_table(book_id, book_format, json_response):",
          "313:     warning = {}",
          "314:     if current_user.role_delete_books():",
          "315:         book = calibre_db.get_book(book_id)",
          "316:         if book:",
          "317:             try:",
          "318:                 result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
          "319:                 if not result:",
          "320:                     if json_response:",
          "321:                         return json.dumps([{\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "322:                                             \"type\": \"danger\",",
          "323:                                             \"format\": \"\",",
          "324:                                             \"message\": error}])",
          "325:                     else:",
          "326:                         flash(error, category=\"error\")",
          "327:                         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "328:                 if error:",
          "329:                     if json_response:",
          "330:                         warning = {\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "331:                                    \"type\": \"warning\",",
          "332:                                    \"format\": \"\",",
          "333:                                    \"message\": error}",
          "334:                     else:",
          "335:                         flash(error, category=\"warning\")",
          "336:                 if not book_format:",
          "337:                     delete_whole_book(book_id, book)",
          "338:                 else:",
          "339:                     calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
          "340:                         filter(db.Data.format == book_format).delete()",
          "341:                     if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:",
          "342:                         kobo_sync_status.remove_synced_book(book.id, True)",
          "343:                 calibre_db.session.commit()",
          "344:             except Exception as ex:",
          "345:                 log.error_or_exception(ex)",
          "346:                 calibre_db.session.rollback()",
          "347:                 if json_response:",
          "348:                     return json.dumps([{\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "349:                                         \"type\": \"danger\",",
          "350:                                         \"format\": \"\",",
          "351:                                         \"message\": ex}])",
          "352:                 else:",
          "353:                     flash(str(ex), category=\"error\")",
          "354:                     return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "356:         else:",
          "357:             # book not found",
          "358:             log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
          "359:         return render_delete_book_result(book_format, json_response, warning, book_id)",
          "360:     message = _(\"You are missing permissions to delete books\")",
          "361:     if json_response:",
          "362:         return json.dumps({\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "363:                            \"type\": \"danger\",",
          "364:                            \"format\": \"\",",
          "365:                            \"message\": message})",
          "366:     else:",
          "367:         flash(message, category=\"error\")",
          "368:         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "371: def render_edit_book(book_id):",
          "372:     cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "373:     book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "374:     if not book:",
          "375:         flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
          "376:               category=\"error\")",
          "377:         return redirect(url_for(\"web.index\"))",
          "379:     for lang in book.languages:",
          "380:         lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
          "382:     book.authors = calibre_db.order_authors([book])",
          "384:     author_names = []",
          "385:     for authr in book.authors:",
          "386:         author_names.append(authr.name.replace('|', ','))",
          "388:     # Option for showing convert_book button",
          "389:     valid_source_formats = list()",
          "390:     allowed_conversion_formats = list()",
          "391:     kepub_possible = None",
          "392:     if config.config_converterpath:",
          "393:         for file in book.data:",
          "394:             if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
          "395:                 valid_source_formats.append(file.format.lower())",
          "396:     if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
          "397:         kepub_possible = True",
          "398:         if not config.config_converterpath:",
          "399:             valid_source_formats.append('epub')",
          "401:     # Determine what formats don't already exist",
          "402:     if config.config_converterpath:",
          "403:         allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
          "404:         for file in book.data:",
          "405:             if file.format.lower() in allowed_conversion_formats:",
          "406:                 allowed_conversion_formats.remove(file.format.lower())",
          "407:     if kepub_possible:",
          "408:         allowed_conversion_formats.append('kepub')",
          "409:     return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
          "410:                                  title=_(u\"edit metadata\"), page=\"editbook\",",
          "411:                                  conversion_formats=allowed_conversion_formats,",
          "412:                                  config=config,",
          "413:                                  source_formats=valid_source_formats)",
          "416: def edit_book_ratings(to_save, book):",
          "417:     changed = False",
          "418:     if to_save.get(\"rating\", \"\").strip():",
          "419:         old_rating = False",
          "420:         if len(book.ratings) > 0:",
          "421:             old_rating = book.ratings[0].rating",
          "422:         rating_x2 = int(float(to_save.get(\"rating\", \"\")) * 2)",
          "423:         if rating_x2 != old_rating:",
          "424:             changed = True",
          "425:             is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == rating_x2).first()",
          "426:             if is_rating:",
          "427:                 book.ratings.append(is_rating)",
          "428:             else:",
          "429:                 new_rating = db.Ratings(rating=rating_x2)",
          "430:                 book.ratings.append(new_rating)",
          "431:             if old_rating:",
          "432:                 book.ratings.remove(book.ratings[0])",
          "433:     else:",
          "434:         if len(book.ratings) > 0:",
          "435:             book.ratings.remove(book.ratings[0])",
          "436:             changed = True",
          "437:     return changed",
          "440: def edit_book_tags(tags, book):",
          "441:     input_tags = tags.split(',')",
          "442:     input_tags = list(map(lambda it: it.strip(), input_tags))",
          "443:     # Remove duplicates",
          "444:     input_tags = helper.uniq(input_tags)",
          "445:     return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
          "448: def edit_book_series(series, book):",
          "449:     input_series = [series.strip()]",
          "450:     input_series = [x for x in input_series if x != '']",
          "451:     return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
          "454: def edit_book_series_index(series_index, book):",
          "455:     # Add default series_index to book",
          "456:     modify_date = False",
          "457:     series_index = series_index or '1'",
          "458:     if not series_index.replace('.', '', 1).isdigit():",
          "459:         flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
          "460:         return False",
          "461:     if str(book.series_index) != series_index:",
          "462:         book.series_index = series_index",
          "463:         modify_date = True",
          "464:     return modify_date",
          "467: # Handle book comments/description",
          "468: def edit_book_comments(comments, book):",
          "469:     modify_date = False",
          "470:     if comments:",
          "471:         comments = clean_html(comments)",
          "472:     if len(book.comments):",
          "473:         if book.comments[0].text != comments:",
          "474:             book.comments[0].text = comments",
          "475:             modify_date = True",
          "476:     else:",
          "477:         if comments:",
          "478:             book.comments.append(db.Comments(comment=comments, book=book.id))",
          "479:             modify_date = True",
          "480:     return modify_date",
          "483: def edit_book_languages(languages, book, upload_mode=False, invalid=None):",
          "484:     input_languages = languages.split(',')",
          "485:     unknown_languages = []",
          "486:     if not upload_mode:",
          "487:         input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
          "488:     else:",
          "489:         input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
          "490:     for lang in unknown_languages:",
          "491:         log.error(\"'%s' is not a valid language\", lang)",
          "492:         if isinstance(invalid, list):",
          "493:             invalid.append(lang)",
          "494:         else:",
          "495:             raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=lang))",
          "496:     # ToDo: Not working correct",
          "497:     if upload_mode and len(input_l) == 1:",
          "498:         # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
          "499:         # the book it's language is set to the filter language",
          "500:         if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
          "501:             input_l[0] = calibre_db.session.query(db.Languages). \\",
          "502:                 filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
          "503:     # Remove duplicates",
          "504:     input_l = helper.uniq(input_l)",
          "505:     return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
          "508: def edit_book_publisher(publishers, book):",
          "509:     changed = False",
          "510:     if publishers:",
          "511:         publisher = publishers.rstrip().strip()",
          "512:         if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
          "513:             changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
          "514:                                               'publisher')",
          "515:     elif len(book.publishers):",
          "516:         changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
          "517:     return changed",
          "520: def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
          "521:     changed = False",
          "522:     if to_save[cc_string] == 'None':",
          "523:         to_save[cc_string] = None",
          "524:     elif c.datatype == 'bool':",
          "525:         to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
          "526:     elif c.datatype == 'comments':",
          "527:         to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
          "528:         if to_save[cc_string]:",
          "529:             to_save[cc_string] = clean_html(to_save[cc_string])",
          "530:     elif c.datatype == 'datetime':",
          "531:         try:",
          "532:             to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
          "533:         except ValueError:",
          "534:             to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
          "536:     if to_save[cc_string] != cc_db_value:",
          "537:         if cc_db_value is not None:",
          "538:             if to_save[cc_string] is not None:",
          "539:                 setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
          "540:                 changed = True",
          "541:             else:",
          "542:                 del_cc = getattr(book, cc_string)[0]",
          "543:                 getattr(book, cc_string).remove(del_cc)",
          "544:                 calibre_db.session.delete(del_cc)",
          "545:                 changed = True",
          "546:         else:",
          "547:             cc_class = db.cc_classes[c.id]",
          "548:             new_cc = cc_class(value=to_save[cc_string], book=book_id)",
          "549:             calibre_db.session.add(new_cc)",
          "550:             changed = True",
          "551:     return changed, to_save",
          "554: def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
          "555:     changed = False",
          "556:     if c.datatype == 'rating':",
          "557:         to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
          "558:     if to_save[cc_string].strip() != cc_db_value:",
          "559:         if cc_db_value is not None:",
          "560:             # remove old cc_val",
          "561:             del_cc = getattr(book, cc_string)[0]",
          "562:             getattr(book, cc_string).remove(del_cc)",
          "563:             if len(del_cc.books) == 0:",
          "564:                 calibre_db.session.delete(del_cc)",
          "565:                 changed = True",
          "566:         cc_class = db.cc_classes[c.id]",
          "567:         new_cc = calibre_db.session.query(cc_class).filter(",
          "568:             cc_class.value == to_save[cc_string].strip()).first()",
          "569:         # if no cc val is found add it",
          "570:         if new_cc is None:",
          "571:             new_cc = cc_class(value=to_save[cc_string].strip())",
          "572:             calibre_db.session.add(new_cc)",
          "573:             changed = True",
          "574:             calibre_db.session.flush()",
          "575:             new_cc = calibre_db.session.query(cc_class).filter(",
          "576:                 cc_class.value == to_save[cc_string].strip()).first()",
          "577:         # add cc value to book",
          "578:         getattr(book, cc_string).append(new_cc)",
          "579:     return changed, to_save",
          "582: def edit_single_cc_data(book_id, book, column_id, to_save):",
          "584:           .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions))",
          "585:           .filter(db.CustomColumns.id == column_id)",
          "586:           .all())",
          "587:     return edit_cc_data(book_id, book, to_save, cc)",
          "590: def edit_all_cc_data(book_id, book, to_save):",
          "591:     cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "592:     return edit_cc_data(book_id, book, to_save, cc)",
          "595: def edit_cc_data(book_id, book, to_save, cc):",
          "596:     changed = False",
          "597:     for c in cc:",
          "598:         cc_string = \"custom_column_\" + str(c.id)",
          "599:         if not c.is_multiple:",
          "600:             if len(getattr(book, cc_string)) > 0:",
          "601:                 cc_db_value = getattr(book, cc_string)[0].value",
          "603:                 cc_db_value = None",
          "604:             if to_save[cc_string].strip():",
          "605:                 if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
          "606:                     changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
          "608:                     changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
          "609:             else:",
          "610:                 if cc_db_value is not None:",
          "611:                     # remove old cc_val",
          "612:                     del_cc = getattr(book, cc_string)[0]",
          "613:                     getattr(book, cc_string).remove(del_cc)",
          "614:                     if not del_cc.books or len(del_cc.books) == 0:",
          "615:                         calibre_db.session.delete(del_cc)",
          "616:                         changed = True",
          "617:         else:",
          "618:             input_tags = to_save[cc_string].split(',')",
          "619:             input_tags = list(map(lambda it: it.strip(), input_tags))",
          "620:             changed |= modify_database_object(input_tags,",
          "621:                                               getattr(book, cc_string),",
          "622:                                               db.cc_classes[c.id],",
          "623:                                               calibre_db.session,",
          "624:                                               'custom')",
          "625:     return changed",
          "628: # returns None if no file is uploaded",
          "629: # returns False if an error occurs, in all other cases the ebook metadata is returned",
          "630: def upload_single_file(file_request, book, book_id):",
          "631:     # Check and handle Uploaded file",
          "632:     requested_file = file_request.files.get('btn-upload-format', None)",
          "633:     if requested_file:",
          "634:         # check for empty request",
          "635:         if requested_file.filename != '':",
          "636:             if not current_user.role_upload():",
          "637:                 flash(_(u\"User has no rights to upload additional file formats\"), category=\"error\")",
          "638:                 return False",
          "639:             if '.' in requested_file.filename:",
          "640:                 file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
          "641:                 if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
          "642:                     flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
          "643:                           category=\"error\")",
          "644:                     return False",
          "646:                 flash(_('File to be uploaded must have an extension'), category=\"error\")",
          "647:                 return False",
          "649:             file_name = book.path.rsplit('/', 1)[-1]",
          "650:             filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
          "651:             saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
          "653:             # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
          "654:             if not os.path.exists(filepath):",
          "655:                 try:",
          "656:                     os.makedirs(filepath)",
          "657:                 except OSError:",
          "658:                     flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
          "659:                     return False",
          "660:             try:",
          "661:                 requested_file.save(saved_filename)",
          "662:             except OSError:",
          "663:                 flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
          "664:                 return False",
          "666:             file_size = os.path.getsize(saved_filename)",
          "667:             is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
          "669:             # Format entry already exists, no need to update the database",
          "670:             if is_format:",
          "671:                 log.warning('Book format %s already existing', file_ext.upper())",
          "672:             else:",
          "673:                 try:",
          "674:                     db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
          "675:                     calibre_db.session.add(db_format)",
          "676:                     calibre_db.session.commit()",
          "677:                     calibre_db.update_title_sort(config)",
          "678:                 except (OperationalError, IntegrityError) as e:",
          "679:                     calibre_db.session.rollback()",
          "680:                     log.error_or_exception(\"Database error: {}\".format(e))",
          "681:                     flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "682:                     return False  # return redirect(url_for('web.show_book', book_id=book.id))",
          "684:             # Queue uploader info",
          "685:             link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
          "686:             upload_text = N_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
          "687:             WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(book.title)))",
          "689:             return uploader.process(",
          "690:                 saved_filename, *os.path.splitext(requested_file.filename),",
          "691:                 rarExecutable=config.config_rarfile_location)",
          "692:     return None",
          "695: def upload_cover(cover_request, book):",
          "696:     requested_file = cover_request.files.get('btn-upload-cover', None)",
          "697:     if requested_file:",
          "698:         # check for empty request",
          "699:         if requested_file.filename != '':",
          "700:             if not current_user.role_upload():",
          "701:                 flash(_(u\"User has no rights to upload cover\"), category=\"error\")",
          "702:                 return False",
          "703:             ret, message = helper.save_cover(requested_file, book.path)",
          "704:             if ret is True:",
          "705:                 helper.replace_cover_thumbnail_cache(book.id)",
          "706:                 return True",
          "707:             else:",
          "708:                 flash(message, category=\"error\")",
          "709:                 return False",
          "710:     return None",
          "713: def handle_title_on_edit(book, book_title):",
          "714:     # handle book title",
          "715:     book_title = book_title.rstrip().strip()",
          "716:     if book.title != book_title:",
          "717:         if book_title == '':",
          "718:             book_title = _(u'Unknown')",
          "719:         book.title = book_title",
          "720:         return True",
          "721:     return False",
          "724: def handle_author_on_edit(book, author_name, update_stored=True):",
          "725:     # handle author(s)",
          "726:     input_authors, renamed = prepare_authors(author_name)",
          "728:     change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
          "730:     # Search for each author if author is in database, if not, author name and sorted author name is generated new",
          "731:     # everything then is assembled for sorted author field in database",
          "732:     sort_authors_list = list()",
          "733:     for inp in input_authors:",
          "734:         stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
          "735:         if not stored_author:",
          "736:             stored_author = helper.get_sorted_author(inp)",
          "737:         else:",
          "738:             stored_author = stored_author.sort",
          "739:         sort_authors_list.append(helper.get_sorted_author(stored_author))",
          "740:     sort_authors = ' & '.join(sort_authors_list)",
          "741:     if book.author_sort != sort_authors and update_stored:",
          "742:         book.author_sort = sort_authors",
          "743:         change = True",
          "744:     return input_authors, change, renamed",
          "747: @editbook.route(\"/admin/book/<int:book_id>\", methods=['GET'])",
          "748: @login_required_if_no_ano",
          "749: @edit_required",
          "750: def show_edit_book(book_id):",
          "751:     return render_edit_book(book_id)",
          "754: @editbook.route(\"/admin/book/<int:book_id>\", methods=['POST'])",
          "755: @login_required_if_no_ano",
          "756: @edit_required",
          "757: def edit_book(book_id):",
          "758:     modify_date = False",
          "759:     edit_error = False",
          "761:     # create the function for sorting...",
          "762:     #try:",
          "763:     calibre_db.update_title_sort(config)",
          "764:     #except sqliteOperationalError as e:",
          "765:     #    log.error_or_exception(e)",
          "766:     #    calibre_db.session.rollback()",
          "768:     book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "769:     # Book not found",
          "770:     if not book:",
          "771:         flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
          "772:               category=\"error\")",
          "773:         return redirect(url_for(\"web.index\"))",
          "775:     to_save = request.form.to_dict()",
          "777:     try:",
          "778:         # Update folder of book on local disk",
          "779:         edited_books_id = None",
          "780:         title_author_error = None",
          "781:         # handle book title change",
          "782:         title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
          "783:         # handle book author change",
          "784:         input_authors, author_change, renamed = handle_author_on_edit(book, to_save[\"author_name\"])",
          "785:         if author_change or title_change:",
          "786:             edited_books_id = book.id",
          "787:             modify_date = True",
          "788:             title_author_error = helper.update_dir_structure(edited_books_id,",
          "789:                                                              config.config_calibre_dir,",
          "790:                                                              input_authors[0],",
          "791:                                                              renamed_author=renamed)",
          "792:         if title_author_error:",
          "793:             flash(title_author_error, category=\"error\")",
          "794:             calibre_db.session.rollback()",
          "795:             book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "797:         # handle upload other formats from local disk",
          "798:         meta = upload_single_file(request, book, book_id)",
          "799:         # only merge metadata if file was uploaded and no error occurred (meta equals not false or none)",
          "800:         if meta:",
          "801:             merge_metadata(to_save, meta)",
          "802:         # handle upload covers from local disk",
          "803:         cover_upload_success = upload_cover(request, book)",
          "804:         if cover_upload_success:",
          "805:             book.has_cover = 1",
          "806:             modify_date = True",
          "808:         # upload new covers or new file formats to google drive",
          "809:         if config.config_use_google_drive:",
          "810:             gdriveutils.updateGdriveCalibreFromLocal()",
          "812:         if to_save.get(\"cover_url\", None):",
          "813:             if not current_user.role_upload():",
          "814:                 edit_error = True",
          "815:                 flash(_(u\"User has no rights to upload cover\"), category=\"error\")",
          "816:             if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
          "817:                 book.has_cover = 0",
          "818:             else:",
          "819:                 result, error = helper.save_cover_from_url(to_save[\"cover_url\"].strip(), book.path)",
          "820:                 if result is True:",
          "821:                     book.has_cover = 1",
          "822:                     modify_date = True",
          "823:                     helper.replace_cover_thumbnail_cache(book.id)",
          "824:                 else:",
          "825:                     flash(error, category=\"error\")",
          "827:         # Add default series_index to book",
          "828:         modify_date |= edit_book_series_index(to_save[\"series_index\"], book)",
          "829:         # Handle book comments/description",
          "830:         modify_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
          "831:         # Handle identifiers",
          "832:         input_identifiers = identifier_list(to_save, book)",
          "833:         modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
          "834:         if warning:",
          "835:             flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
          "836:         modify_date |= modification",
          "837:         # Handle book tags",
          "838:         modify_date |= edit_book_tags(to_save['tags'], book)",
          "839:         # Handle book series",
          "840:         modify_date |= edit_book_series(to_save[\"series\"], book)",
          "841:         # handle book publisher",
          "842:         modify_date |= edit_book_publisher(to_save['publisher'], book)",
          "843:         # handle book languages",
          "844:         try:",
          "845:             modify_date |= edit_book_languages(to_save['languages'], book)",
          "846:         except ValueError as e:",
          "847:             flash(str(e), category=\"error\")",
          "848:             edit_error = True",
          "849:         # handle book ratings",
          "850:         modify_date |= edit_book_ratings(to_save, book)",
          "851:         # handle cc data",
          "852:         modify_date |= edit_all_cc_data(book_id, book, to_save)",
          "854:         if to_save.get(\"pubdate\", None):",
          "855:             try:",
          "856:                 book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
          "857:             except ValueError as e:",
          "858:                 book.pubdate = db.Books.DEFAULT_PUBDATE",
          "859:                 flash(str(e), category=\"error\")",
          "860:                 edit_error = True",
          "861:         else:",
          "862:             book.pubdate = db.Books.DEFAULT_PUBDATE",
          "864:         if modify_date:",
          "865:             book.last_modified = datetime.utcnow()",
          "866:             kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
          "868:         calibre_db.session.merge(book)",
          "869:         calibre_db.session.commit()",
          "870:         if config.config_use_google_drive:",
          "871:             gdriveutils.updateGdriveCalibreFromLocal()",
          "872:         if meta is not False \\",
          "873:             and edit_error is not True \\",
          "874:                 and title_author_error is not True \\",
          "875:                 and cover_upload_success is not False:",
          "876:             flash(_(\"Metadata successfully updated\"), category=\"success\")",
          "877:         if \"detail_view\" in to_save:",
          "878:             return redirect(url_for('web.show_book', book_id=book.id))",
          "879:         else:",
          "880:             return render_edit_book(book_id)",
          "881:     except ValueError as e:",
          "882:         log.error_or_exception(\"Error: {}\".format(e))",
          "883:         calibre_db.session.rollback()",
          "884:         flash(str(e), category=\"error\")",
          "885:         return redirect(url_for('web.show_book', book_id=book.id))",
          "886:     except (OperationalError, IntegrityError) as e:",
          "887:         log.error_or_exception(\"Database error: {}\".format(e))",
          "888:         calibre_db.session.rollback()",
          "889:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "890:         return redirect(url_for('web.show_book', book_id=book.id))",
          "891:     except Exception as ex:",
          "892:         log.error_or_exception(ex)",
          "893:         calibre_db.session.rollback()",
          "894:         flash(_(\"Error editing book: {}\".format(ex)), category=\"error\")",
          "895:         return redirect(url_for('web.show_book', book_id=book.id))",
          "",
          "[Added Lines]",
          "89: @editbook.route(\"/admin/book/<int:book_id>\", methods=['GET'])",
          "90: @login_required_if_no_ano",
          "91: @edit_required",
          "92: def show_edit_book(book_id):",
          "93:     return render_edit_book(book_id)",
          "96: @editbook.route(\"/admin/book/<int:book_id>\", methods=['POST'])",
          "97: @login_required_if_no_ano",
          "98: @edit_required",
          "99: def edit_book(book_id):",
          "100:     modify_date = False",
          "101:     edit_error = False",
          "103:     # create the function for sorting...",
          "104:     calibre_db.update_title_sort(config)",
          "106:     book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "107:     # Book not found",
          "108:     if not book:",
          "109:         flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
          "110:               category=\"error\")",
          "111:         return redirect(url_for(\"web.index\"))",
          "113:     to_save = request.form.to_dict()",
          "115:     try:",
          "116:         # Update folder of book on local disk",
          "117:         edited_books_id = None",
          "118:         title_author_error = None",
          "119:         # handle book title change",
          "120:         title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
          "121:         # handle book author change",
          "122:         input_authors, author_change, renamed = handle_author_on_edit(book, to_save[\"author_name\"])",
          "123:         if author_change or title_change:",
          "124:             edited_books_id = book.id",
          "125:             modify_date = True",
          "126:             title_author_error = helper.update_dir_structure(edited_books_id,",
          "127:                                                              config.config_calibre_dir,",
          "128:                                                              input_authors[0],",
          "129:                                                              renamed_author=renamed)",
          "130:         if title_author_error:",
          "131:             flash(title_author_error, category=\"error\")",
          "132:             calibre_db.session.rollback()",
          "133:             book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "135:         # handle upload other formats from local disk",
          "136:         meta = upload_single_file(request, book, book_id)",
          "137:         # only merge metadata if file was uploaded and no error occurred (meta equals not false or none)",
          "138:         if meta:",
          "139:             merge_metadata(to_save, meta)",
          "140:         # handle upload covers from local disk",
          "141:         cover_upload_success = upload_cover(request, book)",
          "142:         if cover_upload_success:",
          "143:             book.has_cover = 1",
          "144:             modify_date = True",
          "146:         # upload new covers or new file formats to google drive",
          "147:         if config.config_use_google_drive:",
          "148:             gdriveutils.updateGdriveCalibreFromLocal()",
          "150:         if to_save.get(\"cover_url\", None):",
          "151:             if not current_user.role_upload():",
          "152:                 edit_error = True",
          "153:                 flash(_(u\"User has no rights to upload cover\"), category=\"error\")",
          "154:             if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
          "155:                 book.has_cover = 0",
          "156:             else:",
          "157:                 result, error = helper.save_cover_from_url(to_save[\"cover_url\"].strip(), book.path)",
          "158:                 if result is True:",
          "159:                     book.has_cover = 1",
          "160:                     modify_date = True",
          "161:                     helper.replace_cover_thumbnail_cache(book.id)",
          "162:                 else:",
          "163:                     flash(error, category=\"error\")",
          "165:         # Add default series_index to book",
          "166:         modify_date |= edit_book_series_index(to_save[\"series_index\"], book)",
          "167:         # Handle book comments/description",
          "168:         modify_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
          "169:         # Handle identifiers",
          "170:         input_identifiers = identifier_list(to_save, book)",
          "171:         modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
          "172:         if warning:",
          "173:             flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
          "174:         modify_date |= modification",
          "175:         # Handle book tags",
          "176:         modify_date |= edit_book_tags(to_save['tags'], book)",
          "177:         # Handle book series",
          "178:         modify_date |= edit_book_series(to_save[\"series\"], book)",
          "179:         # handle book publisher",
          "180:         modify_date |= edit_book_publisher(to_save['publisher'], book)",
          "181:         # handle book languages",
          "182:         try:",
          "183:             modify_date |= edit_book_languages(to_save['languages'], book)",
          "184:         except ValueError as e:",
          "185:             flash(str(e), category=\"error\")",
          "186:             edit_error = True",
          "187:         # handle book ratings",
          "188:         modify_date |= edit_book_ratings(to_save, book)",
          "189:         # handle cc data",
          "190:         modify_date |= edit_all_cc_data(book_id, book, to_save)",
          "192:         if to_save.get(\"pubdate\", None):",
          "193:             try:",
          "194:                 book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
          "195:             except ValueError as e:",
          "196:                 book.pubdate = db.Books.DEFAULT_PUBDATE",
          "197:                 flash(str(e), category=\"error\")",
          "198:                 edit_error = True",
          "199:         else:",
          "200:             book.pubdate = db.Books.DEFAULT_PUBDATE",
          "202:         if modify_date:",
          "203:             book.last_modified = datetime.utcnow()",
          "204:             kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
          "206:         calibre_db.session.merge(book)",
          "207:         calibre_db.session.commit()",
          "208:         if config.config_use_google_drive:",
          "209:             gdriveutils.updateGdriveCalibreFromLocal()",
          "210:         if meta is not False \\",
          "211:             and edit_error is not True \\",
          "212:                 and title_author_error is not True \\",
          "213:                 and cover_upload_success is not False:",
          "214:             flash(_(\"Metadata successfully updated\"), category=\"success\")",
          "215:         if \"detail_view\" in to_save:",
          "216:             return redirect(url_for('web.show_book', book_id=book.id))",
          "217:         else:",
          "218:             return render_edit_book(book_id)",
          "219:     except ValueError as e:",
          "220:         log.error_or_exception(\"Error: {}\".format(e))",
          "221:         calibre_db.session.rollback()",
          "222:         flash(str(e), category=\"error\")",
          "223:         return redirect(url_for('web.show_book', book_id=book.id))",
          "224:     except (OperationalError, IntegrityError) as e:",
          "225:         log.error_or_exception(\"Database error: {}\".format(e))",
          "226:         calibre_db.session.rollback()",
          "227:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "228:         return redirect(url_for('web.show_book', book_id=book.id))",
          "229:     except Exception as ex:",
          "230:         log.error_or_exception(ex)",
          "231:         calibre_db.session.rollback()",
          "232:         flash(_(\"Error editing book: {}\".format(ex)), category=\"error\")",
          "233:         return redirect(url_for('web.show_book', book_id=book.id))",
          "236: @editbook.route(\"/upload\", methods=[\"POST\"])",
          "237: @login_required_if_no_ano",
          "238: @upload_required",
          "239: def upload():",
          "240:     if not config.config_uploading:",
          "241:         abort(404)",
          "242:     if request.method == 'POST' and 'btn-upload' in request.files:",
          "243:         for requested_file in request.files.getlist(\"btn-upload\"):",
          "244:             try:",
          "245:                 modify_date = False",
          "246:                 # create the function for sorting...",
          "247:                 calibre_db.update_title_sort(config)",
          "248:                 calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
          "250:                 meta, error = file_handling_on_upload(requested_file)",
          "251:                 if error:",
          "252:                     return error",
          "254:                 db_book, input_authors, title_dir, renamed_authors = create_book_on_upload(modify_date, meta)",
          "256:                 # Comments need book id therefore only possible after flush",
          "257:                 modify_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
          "259:                 book_id = db_book.id",
          "260:                 title = db_book.title",
          "261:                 if config.config_use_google_drive:",
          "262:                     helper.upload_new_file_gdrive(book_id,",
          "263:                                                   input_authors[0],",
          "264:                                                   renamed_authors,",
          "265:                                                   title,",
          "266:                                                   title_dir,",
          "267:                                                   meta.file_path,",
          "268:                                                   meta.extension.lower())",
          "269:                 else:",
          "270:                     error = helper.update_dir_structure(book_id,",
          "271:                                                         config.config_calibre_dir,",
          "272:                                                         input_authors[0],",
          "273:                                                         meta.file_path,",
          "274:                                                         title_dir + meta.extension.lower(),",
          "275:                                                         renamed_author=renamed_authors)",
          "277:                 move_coverfile(meta, db_book)",
          "279:                 # save data to database, reread data",
          "280:                 calibre_db.session.commit()",
          "282:                 if config.config_use_google_drive:",
          "283:                     gdriveutils.updateGdriveCalibreFromLocal()",
          "284:                 if error:",
          "285:                     flash(error, category=\"error\")",
          "286:                 link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
          "287:                 upload_text = N_(u\"File %(file)s uploaded\", file=link)",
          "288:                 WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(title)))",
          "289:                 helper.add_book_to_thumbnail_cache(book_id)",
          "291:                 if len(request.files.getlist(\"btn-upload\")) < 2:",
          "292:                     if current_user.role_edit() or current_user.role_admin():",
          "293:                         resp = {\"location\": url_for('edit-book.show_edit_book', book_id=book_id)}",
          "294:                         return Response(json.dumps(resp), mimetype='application/json')",
          "295:                     else:",
          "296:                         resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
          "297:                         return Response(json.dumps(resp), mimetype='application/json')",
          "298:             except (OperationalError, IntegrityError) as e:",
          "299:                 calibre_db.session.rollback()",
          "300:                 log.error_or_exception(\"Database error: {}\".format(e))",
          "301:                 flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "302:         return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
          "305: @editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
          "306: @login_required_if_no_ano",
          "307: @edit_required",
          "308: def convert_bookformat(book_id):",
          "309:     # check to see if we have form fields to work with -  if not send user back",
          "310:     book_format_from = request.form.get('book_format_from', None)",
          "311:     book_format_to = request.form.get('book_format_to', None)",
          "313:     if (book_format_from is None) or (book_format_to is None):",
          "314:         flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
          "315:         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "317:     log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
          "318:     rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
          "319:                                      book_format_to.upper(), current_user.name)",
          "321:     if rtn is None:",
          "322:         flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
          "323:                 book_format=book_format_to),",
          "324:               category=\"success\")",
          "325:     else:",
          "326:         flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
          "327:     return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "330: @editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
          "331: @login_required",
          "332: def table_get_custom_enum(c_id):",
          "333:     ret = list()",
          "335:           .filter(db.CustomColumns.id == c_id)",
          "336:           .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).one_or_none())",
          "337:     ret.append({'value': \"\", 'text': \"\"})",
          "338:     for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
          "339:         ret.append({'value': en, 'text': en})",
          "340:     return json.dumps(ret)",
          "343: @editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
          "344: @login_required_if_no_ano",
          "345: @edit_required",
          "346: def edit_list_book(param):",
          "347:     vals = request.form.to_dict()",
          "348:     book = calibre_db.get_book(vals['pk'])",
          "349:     sort_param = \"\"",
          "350:     ret = \"\"",
          "351:     try:",
          "352:         if param == 'series_index':",
          "353:             edit_book_series_index(vals['value'], book)",
          "354:             ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
          "355:         elif param == 'tags':",
          "356:             edit_book_tags(vals['value'], book)",
          "357:             ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
          "358:                            mimetype='application/json')",
          "359:         elif param == 'series':",
          "360:             edit_book_series(vals['value'], book)",
          "361:             ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
          "362:                            mimetype='application/json')",
          "363:         elif param == 'publishers':",
          "364:             edit_book_publisher(vals['value'], book)",
          "365:             ret = Response(json.dumps({'success': True,",
          "366:                                        'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
          "367:                            mimetype='application/json')",
          "368:         elif param == 'languages':",
          "369:             invalid = list()",
          "370:             edit_book_languages(vals['value'], book, invalid=invalid)",
          "371:             if invalid:",
          "372:                 ret = Response(json.dumps({'success': False,",
          "373:                                            'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
          "374:                                mimetype='application/json')",
          "376:                 lang_names = list()",
          "377:                 for lang in book.languages:",
          "378:                     lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
          "379:                 ret = Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
          "380:                                mimetype='application/json')",
          "381:         elif param == 'author_sort':",
          "382:             book.author_sort = vals['value']",
          "383:             ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
          "384:                            mimetype='application/json')",
          "385:         elif param == 'title':",
          "386:             sort_param = book.sort",
          "387:             if handle_title_on_edit(book, vals.get('value', \"\")):",
          "388:                 rename_error = helper.update_dir_structure(book.id, config.config_calibre_dir)",
          "389:                 if not rename_error:",
          "390:                     ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
          "391:                                    mimetype='application/json')",
          "393:                     ret = Response(json.dumps({'success': False,",
          "394:                                                'msg': rename_error}),",
          "395:                                    mimetype='application/json')",
          "396:         elif param == 'sort':",
          "397:             book.sort = vals['value']",
          "398:             ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
          "399:                            mimetype='application/json')",
          "400:         elif param == 'comments':",
          "401:             edit_book_comments(vals['value'], book)",
          "402:             ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
          "403:                            mimetype='application/json')",
          "404:         elif param == 'authors':",
          "405:             input_authors, __, renamed = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
          "406:             rename_error = helper.update_dir_structure(book.id, config.config_calibre_dir, input_authors[0],",
          "407:                                                        renamed_author=renamed)",
          "408:             if not rename_error:",
          "409:                 ret = Response(json.dumps({",
          "410:                     'success': True,",
          "411:                     'newValue':  ' & '.join([author.replace('|', ',') for author in input_authors])}),",
          "412:                     mimetype='application/json')",
          "414:                 ret = Response(json.dumps({'success': False,",
          "415:                                            'msg': rename_error}),",
          "416:                                mimetype='application/json')",
          "417:         elif param == 'is_archived':",
          "418:             is_archived = change_archived_books(book.id, vals['value'] == \"True\",",
          "419:                                                 message=\"Book {} archive bit set to: {}\".format(book.id, vals['value']))",
          "420:             if is_archived:",
          "421:                 kobo_sync_status.remove_synced_book(book.id)",
          "422:             return \"\"",
          "423:         elif param == 'read_status':",
          "424:             ret = helper.edit_book_read_status(book.id, vals['value'] == \"True\")",
          "425:             if ret:",
          "426:                 return ret, 400",
          "427:         elif param.startswith(\"custom_column_\"):",
          "428:             new_val = dict()",
          "429:             new_val[param] = vals['value']",
          "430:             edit_single_cc_data(book.id, book, param[14:], new_val)",
          "431:             # ToDo: Very hacky find better solution",
          "432:             if vals['value'] in [\"True\", \"False\"]:",
          "433:                 ret = \"\"",
          "434:             else:",
          "435:                 ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
          "436:                                mimetype='application/json')",
          "437:         else:",
          "438:             return _(\"Parameter not found\"), 400",
          "439:         book.last_modified = datetime.utcnow()",
          "441:         calibre_db.session.commit()",
          "442:         # revert change for sort if automatic fields link is deactivated",
          "443:         if param == 'title' and vals.get('checkT') == \"false\":",
          "444:             book.sort = sort_param",
          "445:             calibre_db.session.commit()",
          "446:     except (OperationalError, IntegrityError) as e:",
          "447:         calibre_db.session.rollback()",
          "448:         log.error_or_exception(\"Database error: {}\".format(e))",
          "449:         ret = Response(json.dumps({'success': False,",
          "450:                                    'msg': 'Database error: {}'.format(e.orig)}),",
          "451:                        mimetype='application/json')",
          "452:     return ret",
          "455: @editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
          "456: @login_required",
          "457: def get_sorted_entry(field, bookid):",
          "458:     if field in ['title', 'authors', 'sort', 'author_sort']:",
          "459:         book = calibre_db.get_filtered_book(bookid)",
          "460:         if book:",
          "461:             if field == 'title':",
          "462:                 return json.dumps({'sort': book.sort})",
          "463:             elif field == 'authors':",
          "464:                 return json.dumps({'author_sort': book.author_sort})",
          "465:             if field == 'sort':",
          "466:                 return json.dumps({'sort': book.title})",
          "467:             if field == 'author_sort':",
          "468:                 return json.dumps({'author_sort': book.author})",
          "469:     return \"\"",
          "472: @editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
          "473: @login_required",
          "474: @edit_required",
          "475: def simulate_merge_list_book():",
          "476:     vals = request.get_json().get('Merge_books')",
          "477:     if vals:",
          "478:         to_book = calibre_db.get_book(vals[0]).title",
          "479:         vals.pop(0)",
          "480:         if to_book:",
          "481:             from_book = []",
          "482:             for book_id in vals:",
          "483:                 from_book.append(calibre_db.get_book(book_id).title)",
          "484:             return json.dumps({'to': to_book, 'from': from_book})",
          "485:     return \"\"",
          "488: @editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
          "489: @login_required",
          "490: @edit_required",
          "491: def merge_list_book():",
          "492:     vals = request.get_json().get('Merge_books')",
          "493:     to_file = list()",
          "494:     if vals:",
          "495:         # load all formats from target book",
          "496:         to_book = calibre_db.get_book(vals[0])",
          "497:         vals.pop(0)",
          "498:         if to_book:",
          "499:             for file in to_book.data:",
          "500:                 to_file.append(file.format)",
          "501:             to_name = helper.get_valid_filename(to_book.title,",
          "502:                                                 chars=96) + ' - ' + helper.get_valid_filename(to_book.authors[0].name,",
          "503:                                                                                               chars=96)",
          "504:             for book_id in vals:",
          "505:                 from_book = calibre_db.get_book(book_id)",
          "506:                 if from_book:",
          "507:                     for element in from_book.data:",
          "508:                         if element.format not in to_file:",
          "509:                             # create new data entry with: book_id, book_format, uncompressed_size, name",
          "510:                             filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
          "511:                                                                          to_book.path,",
          "512:                                                                          to_name + \".\" + element.format.lower()))",
          "513:                             filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
          "514:                                                                          from_book.path,",
          "515:                                                                          element.name + \".\" + element.format.lower()))",
          "516:                             copyfile(filepath_old, filepath_new)",
          "517:                             to_book.data.append(db.Data(to_book.id,",
          "518:                                                         element.format,",
          "519:                                                         element.uncompressed_size,",
          "520:                                                         to_name))",
          "521:                     delete_book_from_table(from_book.id, \"\", True)",
          "522:                     return json.dumps({'success': True})",
          "523:     return \"\"",
          "526: @editbook.route(\"/ajax/xchange\", methods=['POST'])",
          "527: @login_required",
          "528: @edit_required",
          "529: def table_xchange_author_title():",
          "530:     vals = request.get_json().get('xchange')",
          "531:     edited_books_id = False",
          "532:     if vals:",
          "533:         for val in vals:",
          "534:             modify_date = False",
          "535:             book = calibre_db.get_book(val)",
          "536:             authors = book.title",
          "537:             book.authors = calibre_db.order_authors([book])",
          "538:             author_names = []",
          "539:             for authr in book.authors:",
          "540:                 author_names.append(authr.name.replace('|', ','))",
          "542:             title_change = handle_title_on_edit(book, \" \".join(author_names))",
          "543:             input_authors, author_change, renamed = handle_author_on_edit(book, authors)",
          "544:             if author_change or title_change:",
          "545:                 edited_books_id = book.id",
          "546:                 modify_date = True",
          "548:             if config.config_use_google_drive:",
          "549:                 gdriveutils.updateGdriveCalibreFromLocal()",
          "551:             if edited_books_id:",
          "552:                 # toDo: Handle error",
          "553:                 edit_error = helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],",
          "554:                                                          renamed_author=renamed)",
          "555:             if modify_date:",
          "556:                 book.last_modified = datetime.utcnow()",
          "557:             try:",
          "558:                 calibre_db.session.commit()",
          "559:             except (OperationalError, IntegrityError) as e:",
          "560:                 calibre_db.session.rollback()",
          "561:                 log.error_or_exception(\"Database error: %s\", e)",
          "562:                 return json.dumps({'success': False})",
          "564:             if config.config_use_google_drive:",
          "565:                 gdriveutils.updateGdriveCalibreFromLocal()",
          "566:         return json.dumps({'success': True})",
          "567:     return \"\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1085:               category=\"error\")",
          "1121:                 else:",
          "1151:                 calibre_db.session.rollback()",
          "1286:             else:",
          "1289:         else:",
          "",
          "[Removed Lines]",
          "1088: @editbook.route(\"/upload\", methods=[\"POST\"])",
          "1089: @login_required_if_no_ano",
          "1090: @upload_required",
          "1091: def upload():",
          "1092:     if not config.config_uploading:",
          "1093:         abort(404)",
          "1094:     if request.method == 'POST' and 'btn-upload' in request.files:",
          "1095:         for requested_file in request.files.getlist(\"btn-upload\"):",
          "1096:             try:",
          "1097:                 modify_date = False",
          "1098:                 # create the function for sorting...",
          "1099:                 calibre_db.update_title_sort(config)",
          "1100:                 calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
          "1102:                 meta, error = file_handling_on_upload(requested_file)",
          "1103:                 if error:",
          "1104:                     return error",
          "1106:                 db_book, input_authors, title_dir, renamed_authors = create_book_on_upload(modify_date, meta)",
          "1108:                 # Comments need book id therefore only possible after flush",
          "1109:                 modify_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
          "1111:                 book_id = db_book.id",
          "1112:                 title = db_book.title",
          "1113:                 if config.config_use_google_drive:",
          "1114:                     helper.upload_new_file_gdrive(book_id,",
          "1115:                                                   input_authors[0],",
          "1116:                                                   renamed_authors,",
          "1117:                                                   title,",
          "1118:                                                   title_dir,",
          "1119:                                                   meta.file_path,",
          "1120:                                                   meta.extension.lower())",
          "1122:                     error = helper.update_dir_structure(book_id,",
          "1123:                                                         config.config_calibre_dir,",
          "1124:                                                         input_authors[0],",
          "1125:                                                         meta.file_path,",
          "1126:                                                         title_dir + meta.extension.lower(),",
          "1127:                                                         renamed_author=renamed_authors)",
          "1129:                 move_coverfile(meta, db_book)",
          "1131:                 # save data to database, reread data",
          "1132:                 calibre_db.session.commit()",
          "1134:                 if config.config_use_google_drive:",
          "1135:                     gdriveutils.updateGdriveCalibreFromLocal()",
          "1136:                 if error:",
          "1137:                     flash(error, category=\"error\")",
          "1138:                 link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
          "1139:                 upload_text = N_(u\"File %(file)s uploaded\", file=link)",
          "1140:                 WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(title)))",
          "1141:                 helper.add_book_to_thumbnail_cache(book_id)",
          "1143:                 if len(request.files.getlist(\"btn-upload\")) < 2:",
          "1144:                     if current_user.role_edit() or current_user.role_admin():",
          "1145:                         resp = {\"location\": url_for('edit-book.show_edit_book', book_id=book_id)}",
          "1146:                         return Response(json.dumps(resp), mimetype='application/json')",
          "1147:                     else:",
          "1148:                         resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
          "1149:                         return Response(json.dumps(resp), mimetype='application/json')",
          "1150:             except (OperationalError, IntegrityError) as e:",
          "1152:                 log.error_or_exception(\"Database error: {}\".format(e))",
          "1153:                 flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1154:         return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
          "1157: @editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
          "1158: @login_required_if_no_ano",
          "1159: @edit_required",
          "1160: def convert_bookformat(book_id):",
          "1161:     # check to see if we have form fields to work with -  if not send user back",
          "1162:     book_format_from = request.form.get('book_format_from', None)",
          "1163:     book_format_to = request.form.get('book_format_to', None)",
          "1165:     if (book_format_from is None) or (book_format_to is None):",
          "1166:         flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
          "1167:         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "1169:     log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
          "1170:     rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
          "1171:                                      book_format_to.upper(), current_user.name)",
          "1173:     if rtn is None:",
          "1174:         flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
          "1175:                 book_format=book_format_to),",
          "1176:               category=\"success\")",
          "1177:     else:",
          "1178:         flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
          "1179:     return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "1182: @editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
          "1183: @login_required",
          "1184: def table_get_custom_enum(c_id):",
          "1185:     ret = list()",
          "1186:     cc = (calibre_db.session.query(db.CustomColumns)",
          "1187:           .filter(db.CustomColumns.id == c_id)",
          "1188:           .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).one_or_none())",
          "1189:     ret.append({'value': \"\", 'text': \"\"})",
          "1190:     for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
          "1191:         ret.append({'value': en, 'text': en})",
          "1192:     return json.dumps(ret)",
          "1195: @editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
          "1196: @login_required_if_no_ano",
          "1197: @edit_required",
          "1198: def edit_list_book(param):",
          "1199:     vals = request.form.to_dict()",
          "1200:     book = calibre_db.get_book(vals['pk'])",
          "1201:     sort_param = \"\"",
          "1202:     ret = \"\"",
          "1203:     try:",
          "1204:         if param == 'series_index':",
          "1205:             edit_book_series_index(vals['value'], book)",
          "1206:             ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
          "1207:         elif param == 'tags':",
          "1208:             edit_book_tags(vals['value'], book)",
          "1209:             ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
          "1210:                            mimetype='application/json')",
          "1211:         elif param == 'series':",
          "1212:             edit_book_series(vals['value'], book)",
          "1213:             ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
          "1214:                            mimetype='application/json')",
          "1215:         elif param == 'publishers':",
          "1216:             edit_book_publisher(vals['value'], book)",
          "1217:             ret = Response(json.dumps({'success': True,",
          "1218:                                        'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
          "1219:                            mimetype='application/json')",
          "1220:         elif param == 'languages':",
          "1221:             invalid = list()",
          "1222:             edit_book_languages(vals['value'], book, invalid=invalid)",
          "1223:             if invalid:",
          "1224:                 ret = Response(json.dumps({'success': False,",
          "1225:                                            'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
          "1226:                                mimetype='application/json')",
          "1227:             else:",
          "1228:                 lang_names = list()",
          "1229:                 for lang in book.languages:",
          "1230:                     lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
          "1231:                 ret = Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
          "1232:                                mimetype='application/json')",
          "1233:         elif param == 'author_sort':",
          "1234:             book.author_sort = vals['value']",
          "1235:             ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
          "1236:                            mimetype='application/json')",
          "1237:         elif param == 'title':",
          "1238:             sort_param = book.sort",
          "1239:             if handle_title_on_edit(book, vals.get('value', \"\")):",
          "1240:                 rename_error = helper.update_dir_structure(book.id, config.config_calibre_dir)",
          "1241:                 if not rename_error:",
          "1242:                     ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
          "1243:                                    mimetype='application/json')",
          "1244:                 else:",
          "1245:                     ret = Response(json.dumps({'success': False,",
          "1246:                                                'msg': rename_error}),",
          "1247:                                    mimetype='application/json')",
          "1248:         elif param == 'sort':",
          "1249:             book.sort = vals['value']",
          "1250:             ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
          "1251:                            mimetype='application/json')",
          "1252:         elif param == 'comments':",
          "1253:             edit_book_comments(vals['value'], book)",
          "1254:             ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
          "1255:                            mimetype='application/json')",
          "1256:         elif param == 'authors':",
          "1257:             input_authors, __, renamed = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
          "1258:             rename_error = helper.update_dir_structure(book.id, config.config_calibre_dir, input_authors[0],",
          "1259:                                                        renamed_author=renamed)",
          "1260:             if not rename_error:",
          "1261:                 ret = Response(json.dumps({",
          "1262:                     'success': True,",
          "1263:                     'newValue':  ' & '.join([author.replace('|', ',') for author in input_authors])}),",
          "1264:                     mimetype='application/json')",
          "1265:             else:",
          "1266:                 ret = Response(json.dumps({'success': False,",
          "1267:                                            'msg': rename_error}),",
          "1268:                                mimetype='application/json')",
          "1269:         elif param == 'is_archived':",
          "1270:             is_archived = change_archived_books(book.id, vals['value'] == \"True\",",
          "1271:                                                 message=\"Book {} archive bit set to: {}\".format(book.id, vals['value']))",
          "1272:             if is_archived:",
          "1273:                 kobo_sync_status.remove_synced_book(book.id)",
          "1274:             return \"\"",
          "1275:         elif param == 'read_status':",
          "1276:             ret = helper.edit_book_read_status(book.id, vals['value'] == \"True\")",
          "1277:             if ret:",
          "1278:                 return ret, 400",
          "1279:         elif param.startswith(\"custom_column_\"):",
          "1280:             new_val = dict()",
          "1281:             new_val[param] = vals['value']",
          "1282:             edit_single_cc_data(book.id, book, param[14:], new_val)",
          "1283:             # ToDo: Very hacky find better solution",
          "1284:             if vals['value'] in [\"True\", \"False\"]:",
          "1285:                 ret = \"\"",
          "1287:                 ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
          "1288:                                mimetype='application/json')",
          "1290:             return _(\"Parameter not found\"), 400",
          "1291:         book.last_modified = datetime.utcnow()",
          "1293:         calibre_db.session.commit()",
          "1294:         # revert change for sort if automatic fields link is deactivated",
          "1295:         if param == 'title' and vals.get('checkT') == \"false\":",
          "1296:             book.sort = sort_param",
          "1297:             calibre_db.session.commit()",
          "1298:     except (OperationalError, IntegrityError) as e:",
          "1299:         calibre_db.session.rollback()",
          "1300:         log.error_or_exception(\"Database error: {}\".format(e))",
          "1301:         ret = Response(json.dumps({'success': False,",
          "1302:                                    'msg': 'Database error: {}'.format(e.orig)}),",
          "1303:                        mimetype='application/json')",
          "1304:     return ret",
          "1307: @editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
          "1308: @login_required",
          "1309: def get_sorted_entry(field, bookid):",
          "1310:     if field in ['title', 'authors', 'sort', 'author_sort']:",
          "1311:         book = calibre_db.get_filtered_book(bookid)",
          "1312:         if book:",
          "1313:             if field == 'title':",
          "1314:                 return json.dumps({'sort': book.sort})",
          "1315:             elif field == 'authors':",
          "1316:                 return json.dumps({'author_sort': book.author_sort})",
          "1317:             if field == 'sort':",
          "1318:                 return json.dumps({'sort': book.title})",
          "1319:             if field == 'author_sort':",
          "1320:                 return json.dumps({'author_sort': book.author})",
          "1321:     return \"\"",
          "1324: @editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
          "1325: @login_required",
          "1326: @edit_required",
          "1327: def simulate_merge_list_book():",
          "1328:     vals = request.get_json().get('Merge_books')",
          "1329:     if vals:",
          "1330:         to_book = calibre_db.get_book(vals[0]).title",
          "1331:         vals.pop(0)",
          "1332:         if to_book:",
          "1333:             from_book = []",
          "1334:             for book_id in vals:",
          "1335:                 from_book.append(calibre_db.get_book(book_id).title)",
          "1336:             return json.dumps({'to': to_book, 'from': from_book})",
          "1337:     return \"\"",
          "1340: @editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
          "1341: @login_required",
          "1342: @edit_required",
          "1343: def merge_list_book():",
          "1344:     vals = request.get_json().get('Merge_books')",
          "1345:     to_file = list()",
          "1346:     if vals:",
          "1347:         # load all formats from target book",
          "1348:         to_book = calibre_db.get_book(vals[0])",
          "1349:         vals.pop(0)",
          "1350:         if to_book:",
          "1351:             for file in to_book.data:",
          "1352:                 to_file.append(file.format)",
          "1353:             to_name = helper.get_valid_filename(to_book.title,",
          "1354:                                                 chars=96) + ' - ' + helper.get_valid_filename(to_book.authors[0].name,",
          "1355:                                                                                               chars=96)",
          "1356:             for book_id in vals:",
          "1357:                 from_book = calibre_db.get_book(book_id)",
          "1358:                 if from_book:",
          "1359:                     for element in from_book.data:",
          "1360:                         if element.format not in to_file:",
          "1361:                             # create new data entry with: book_id, book_format, uncompressed_size, name",
          "1362:                             filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
          "1363:                                                                          to_book.path,",
          "1364:                                                                          to_name + \".\" + element.format.lower()))",
          "1365:                             filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
          "1366:                                                                          from_book.path,",
          "1367:                                                                          element.name + \".\" + element.format.lower()))",
          "1368:                             copyfile(filepath_old, filepath_new)",
          "1369:                             to_book.data.append(db.Data(to_book.id,",
          "1370:                                                         element.format,",
          "1371:                                                         element.uncompressed_size,",
          "1372:                                                         to_name))",
          "1373:                     delete_book_from_table(from_book.id, \"\", True)",
          "1374:                     return json.dumps({'success': True})",
          "1375:     return \"\"",
          "1378: @editbook.route(\"/ajax/xchange\", methods=['POST'])",
          "1379: @login_required",
          "1380: @edit_required",
          "1381: def table_xchange_author_title():",
          "1382:     vals = request.get_json().get('xchange')",
          "1383:     edited_books_id = False",
          "1384:     if vals:",
          "1385:         for val in vals:",
          "1386:             modify_date = False",
          "1387:             book = calibre_db.get_book(val)",
          "1388:             authors = book.title",
          "1389:             book.authors = calibre_db.order_authors([book])",
          "1390:             author_names = []",
          "1391:             for authr in book.authors:",
          "1392:                 author_names.append(authr.name.replace('|', ','))",
          "1394:             title_change = handle_title_on_edit(book, \" \".join(author_names))",
          "1395:             input_authors, author_change, renamed = handle_author_on_edit(book, authors)",
          "1396:             if author_change or title_change:",
          "1397:                 edited_books_id = book.id",
          "1398:                 modify_date = True",
          "1400:             if config.config_use_google_drive:",
          "1401:                 gdriveutils.updateGdriveCalibreFromLocal()",
          "1403:             if edited_books_id:",
          "1404:                 # toDo: Handle error",
          "1405:                 edit_error = helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],",
          "1406:                                                          renamed_author=renamed)",
          "1407:             if modify_date:",
          "1408:                 book.last_modified = datetime.utcnow()",
          "1409:             try:",
          "1410:                 calibre_db.session.commit()",
          "1411:             except (OperationalError, IntegrityError) as e:",
          "1412:                 calibre_db.session.rollback()",
          "1413:                 log.error_or_exception(\"Database error: %s\", e)",
          "1414:                 return json.dumps({'success': False})",
          "1416:             if config.config_use_google_drive:",
          "1417:                 gdriveutils.updateGdriveCalibreFromLocal()",
          "1418:         return json.dumps({'success': True})",
          "1419:     return \"\"",
          "",
          "[Added Lines]",
          "760: def delete_whole_book(book_id, book):",
          "761:     # delete book from shelves, Downloads, Read list",
          "762:     ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
          "763:     ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
          "764:     ub.delete_download(book_id)",
          "765:     ub.session_commit()",
          "767:     # check if only this book links to:",
          "768:     # author, language, series, tags, custom columns",
          "769:     modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
          "770:     modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
          "771:     modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
          "772:     modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
          "773:     modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
          "775:     cc = calibre_db.session.query(db.CustomColumns). \\",
          "776:         filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "777:     for c in cc:",
          "778:         cc_string = \"custom_column_\" + str(c.id)",
          "779:         if not c.is_multiple:",
          "780:             if len(getattr(book, cc_string)) > 0:",
          "781:                 if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
          "782:                     del_cc = getattr(book, cc_string)[0]",
          "783:                     getattr(book, cc_string).remove(del_cc)",
          "784:                     log.debug('remove ' + str(c.id))",
          "785:                     calibre_db.session.delete(del_cc)",
          "786:                     calibre_db.session.commit()",
          "787:                 elif c.datatype == 'rating':",
          "788:                     del_cc = getattr(book, cc_string)[0]",
          "789:                     getattr(book, cc_string).remove(del_cc)",
          "790:                     if len(del_cc.books) == 0:",
          "791:                         log.debug('remove ' + str(c.id))",
          "792:                         calibre_db.session.delete(del_cc)",
          "793:                         calibre_db.session.commit()",
          "795:                     del_cc = getattr(book, cc_string)[0]",
          "796:                     getattr(book, cc_string).remove(del_cc)",
          "797:                     log.debug('remove ' + str(c.id))",
          "798:                     calibre_db.session.delete(del_cc)",
          "799:                     calibre_db.session.commit()",
          "800:         else:",
          "801:             modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
          "802:                                    calibre_db.session, 'custom')",
          "803:     calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
          "806: def render_delete_book_result(book_format, json_response, warning, book_id):",
          "807:     if book_format:",
          "808:         if json_response:",
          "809:             return json.dumps([warning, {\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "810:                                          \"type\": \"success\",",
          "811:                                          \"format\": book_format,",
          "812:                                          \"message\": _('Book Format Successfully Deleted')}])",
          "813:         else:",
          "814:             flash(_('Book Format Successfully Deleted'), category=\"success\")",
          "815:             return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "816:     else:",
          "817:         if json_response:",
          "818:             return json.dumps([warning, {\"location\": url_for('web.index'),",
          "819:                                          \"type\": \"success\",",
          "820:                                          \"format\": book_format,",
          "821:                                          \"message\": _('Book Successfully Deleted')}])",
          "822:         else:",
          "823:             flash(_('Book Successfully Deleted'), category=\"success\")",
          "824:             return redirect(url_for('web.index'))",
          "827: def delete_book_from_table(book_id, book_format, json_response):",
          "828:     warning = {}",
          "829:     if current_user.role_delete_books():",
          "830:         book = calibre_db.get_book(book_id)",
          "831:         if book:",
          "832:             try:",
          "833:                 result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
          "834:                 if not result:",
          "835:                     if json_response:",
          "836:                         return json.dumps([{\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "837:                                             \"type\": \"danger\",",
          "838:                                             \"format\": \"\",",
          "839:                                             \"message\": error}])",
          "840:                     else:",
          "841:                         flash(error, category=\"error\")",
          "842:                         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "843:                 if error:",
          "844:                     if json_response:",
          "845:                         warning = {\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "846:                                    \"type\": \"warning\",",
          "847:                                    \"format\": \"\",",
          "848:                                    \"message\": error}",
          "849:                     else:",
          "850:                         flash(error, category=\"warning\")",
          "851:                 if not book_format:",
          "852:                     delete_whole_book(book_id, book)",
          "853:                 else:",
          "854:                     calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
          "855:                         filter(db.Data.format == book_format).delete()",
          "856:                     if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:",
          "857:                         kobo_sync_status.remove_synced_book(book.id, True)",
          "858:                 calibre_db.session.commit()",
          "859:             except Exception as ex:",
          "860:                 log.error_or_exception(ex)",
          "862:                 if json_response:",
          "863:                     return json.dumps([{\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "864:                                         \"type\": \"danger\",",
          "865:                                         \"format\": \"\",",
          "866:                                         \"message\": ex}])",
          "867:                 else:",
          "868:                     flash(str(ex), category=\"error\")",
          "869:                     return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "871:         else:",
          "872:             # book not found",
          "873:             log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
          "874:         return render_delete_book_result(book_format, json_response, warning, book_id)",
          "875:     message = _(\"You are missing permissions to delete books\")",
          "876:     if json_response:",
          "877:         return json.dumps({\"location\": url_for(\"edit-book.show_edit_book\", book_id=book_id),",
          "878:                            \"type\": \"danger\",",
          "879:                            \"format\": \"\",",
          "880:                            \"message\": message})",
          "881:     else:",
          "882:         flash(message, category=\"error\")",
          "883:         return redirect(url_for('edit-book.show_edit_book', book_id=book_id))",
          "886: def render_edit_book(book_id):",
          "887:     cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "888:     book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
          "889:     if not book:",
          "890:         flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),",
          "891:               category=\"error\")",
          "892:         return redirect(url_for(\"web.index\"))",
          "894:     for lang in book.languages:",
          "895:         lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
          "897:     book.authors = calibre_db.order_authors([book])",
          "899:     author_names = []",
          "900:     for authr in book.authors:",
          "901:         author_names.append(authr.name.replace('|', ','))",
          "903:     # Option for showing convert_book button",
          "904:     valid_source_formats = list()",
          "905:     allowed_conversion_formats = list()",
          "906:     kepub_possible = None",
          "907:     if config.config_converterpath:",
          "908:         for file in book.data:",
          "909:             if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
          "910:                 valid_source_formats.append(file.format.lower())",
          "911:     if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
          "912:         kepub_possible = True",
          "913:         if not config.config_converterpath:",
          "914:             valid_source_formats.append('epub')",
          "916:     # Determine what formats don't already exist",
          "917:     if config.config_converterpath:",
          "918:         allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
          "919:         for file in book.data:",
          "920:             if file.format.lower() in allowed_conversion_formats:",
          "921:                 allowed_conversion_formats.remove(file.format.lower())",
          "922:     if kepub_possible:",
          "923:         allowed_conversion_formats.append('kepub')",
          "924:     return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
          "925:                                  title=_(u\"edit metadata\"), page=\"editbook\",",
          "926:                                  conversion_formats=allowed_conversion_formats,",
          "927:                                  config=config,",
          "928:                                  source_formats=valid_source_formats)",
          "931: def edit_book_ratings(to_save, book):",
          "932:     changed = False",
          "933:     if to_save.get(\"rating\", \"\").strip():",
          "934:         old_rating = False",
          "935:         if len(book.ratings) > 0:",
          "936:             old_rating = book.ratings[0].rating",
          "937:         rating_x2 = int(float(to_save.get(\"rating\", \"\")) * 2)",
          "938:         if rating_x2 != old_rating:",
          "939:             changed = True",
          "940:             is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == rating_x2).first()",
          "941:             if is_rating:",
          "942:                 book.ratings.append(is_rating)",
          "943:             else:",
          "944:                 new_rating = db.Ratings(rating=rating_x2)",
          "945:                 book.ratings.append(new_rating)",
          "946:             if old_rating:",
          "947:                 book.ratings.remove(book.ratings[0])",
          "948:     else:",
          "949:         if len(book.ratings) > 0:",
          "950:             book.ratings.remove(book.ratings[0])",
          "951:             changed = True",
          "952:     return changed",
          "955: def edit_book_tags(tags, book):",
          "956:     input_tags = tags.split(',')",
          "957:     input_tags = list(map(lambda it: it.strip(), input_tags))",
          "958:     # Remove duplicates",
          "959:     input_tags = helper.uniq(input_tags)",
          "960:     return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
          "963: def edit_book_series(series, book):",
          "964:     input_series = [series.strip()]",
          "965:     input_series = [x for x in input_series if x != '']",
          "966:     return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
          "969: def edit_book_series_index(series_index, book):",
          "970:     # Add default series_index to book",
          "971:     modify_date = False",
          "972:     series_index = series_index or '1'",
          "973:     if not series_index.replace('.', '', 1).isdigit():",
          "974:         flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
          "975:         return False",
          "976:     if str(book.series_index) != series_index:",
          "977:         book.series_index = series_index",
          "978:         modify_date = True",
          "979:     return modify_date",
          "982: # Handle book comments/description",
          "983: def edit_book_comments(comments, book):",
          "984:     modify_date = False",
          "985:     if comments:",
          "986:         comments = clean_html(comments)",
          "987:     if len(book.comments):",
          "988:         if book.comments[0].text != comments:",
          "989:             book.comments[0].text = comments",
          "990:             modify_date = True",
          "991:     else:",
          "992:         if comments:",
          "993:             book.comments.append(db.Comments(comment=comments, book=book.id))",
          "994:             modify_date = True",
          "995:     return modify_date",
          "998: def edit_book_languages(languages, book, upload_mode=False, invalid=None):",
          "999:     input_languages = languages.split(',')",
          "1000:     unknown_languages = []",
          "1001:     if not upload_mode:",
          "1002:         input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
          "1003:     else:",
          "1004:         input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
          "1005:     for lang in unknown_languages:",
          "1006:         log.error(\"'%s' is not a valid language\", lang)",
          "1007:         if isinstance(invalid, list):",
          "1008:             invalid.append(lang)",
          "1009:         else:",
          "1010:             raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=lang))",
          "1011:     # ToDo: Not working correct",
          "1012:     if upload_mode and len(input_l) == 1:",
          "1013:         # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
          "1014:         # the book it's language is set to the filter language",
          "1015:         if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
          "1016:             input_l[0] = calibre_db.session.query(db.Languages). \\",
          "1017:                 filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
          "1018:     # Remove duplicates",
          "1019:     input_l = helper.uniq(input_l)",
          "1020:     return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
          "1023: def edit_book_publisher(publishers, book):",
          "1024:     changed = False",
          "1025:     if publishers:",
          "1026:         publisher = publishers.rstrip().strip()",
          "1027:         if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
          "1028:             changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
          "1029:                                               'publisher')",
          "1030:     elif len(book.publishers):",
          "1031:         changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
          "1032:     return changed",
          "1035: def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
          "1036:     changed = False",
          "1037:     if to_save[cc_string] == 'None':",
          "1038:         to_save[cc_string] = None",
          "1039:     elif c.datatype == 'bool':",
          "1040:         to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
          "1041:     elif c.datatype == 'comments':",
          "1042:         to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
          "1043:         if to_save[cc_string]:",
          "1044:             to_save[cc_string] = clean_html(to_save[cc_string])",
          "1045:     elif c.datatype == 'datetime':",
          "1046:         try:",
          "1047:             to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
          "1048:         except ValueError:",
          "1049:             to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
          "1051:     if to_save[cc_string] != cc_db_value:",
          "1052:         if cc_db_value is not None:",
          "1053:             if to_save[cc_string] is not None:",
          "1054:                 setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
          "1055:                 changed = True",
          "1056:             else:",
          "1057:                 del_cc = getattr(book, cc_string)[0]",
          "1058:                 getattr(book, cc_string).remove(del_cc)",
          "1059:                 calibre_db.session.delete(del_cc)",
          "1060:                 changed = True",
          "1061:         else:",
          "1062:             cc_class = db.cc_classes[c.id]",
          "1063:             new_cc = cc_class(value=to_save[cc_string], book=book_id)",
          "1064:             calibre_db.session.add(new_cc)",
          "1065:             changed = True",
          "1066:     return changed, to_save",
          "1069: def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
          "1070:     changed = False",
          "1071:     if c.datatype == 'rating':",
          "1072:         to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
          "1073:     if to_save[cc_string].strip() != cc_db_value:",
          "1074:         if cc_db_value is not None:",
          "1075:             # remove old cc_val",
          "1076:             del_cc = getattr(book, cc_string)[0]",
          "1077:             getattr(book, cc_string).remove(del_cc)",
          "1078:             if len(del_cc.books) == 0:",
          "1079:                 calibre_db.session.delete(del_cc)",
          "1080:                 changed = True",
          "1081:         cc_class = db.cc_classes[c.id]",
          "1082:         new_cc = calibre_db.session.query(cc_class).filter(",
          "1083:             cc_class.value == to_save[cc_string].strip()).first()",
          "1084:         # if no cc val is found add it",
          "1085:         if new_cc is None:",
          "1086:             new_cc = cc_class(value=to_save[cc_string].strip())",
          "1087:             calibre_db.session.add(new_cc)",
          "1088:             changed = True",
          "1089:             calibre_db.session.flush()",
          "1090:             new_cc = calibre_db.session.query(cc_class).filter(",
          "1091:                 cc_class.value == to_save[cc_string].strip()).first()",
          "1092:         # add cc value to book",
          "1093:         getattr(book, cc_string).append(new_cc)",
          "1094:     return changed, to_save",
          "1097: def edit_single_cc_data(book_id, book, column_id, to_save):",
          "1098:     cc = (calibre_db.session.query(db.CustomColumns)",
          "1099:           .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions))",
          "1100:           .filter(db.CustomColumns.id == column_id)",
          "1101:           .all())",
          "1102:     return edit_cc_data(book_id, book, to_save, cc)",
          "1105: def edit_all_cc_data(book_id, book, to_save):",
          "1106:     cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()",
          "1107:     return edit_cc_data(book_id, book, to_save, cc)",
          "1110: def edit_cc_data(book_id, book, to_save, cc):",
          "1111:     changed = False",
          "1112:     for c in cc:",
          "1113:         cc_string = \"custom_column_\" + str(c.id)",
          "1114:         if not c.is_multiple:",
          "1115:             if len(getattr(book, cc_string)) > 0:",
          "1116:                 cc_db_value = getattr(book, cc_string)[0].value",
          "1117:             else:",
          "1118:                 cc_db_value = None",
          "1119:             if to_save[cc_string].strip():",
          "1120:                 if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
          "1121:                     changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
          "1122:                 else:",
          "1123:                     changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
          "1124:             else:",
          "1125:                 if cc_db_value is not None:",
          "1126:                     # remove old cc_val",
          "1127:                     del_cc = getattr(book, cc_string)[0]",
          "1128:                     getattr(book, cc_string).remove(del_cc)",
          "1129:                     if not del_cc.books or len(del_cc.books) == 0:",
          "1130:                         calibre_db.session.delete(del_cc)",
          "1131:                         changed = True",
          "1132:         else:",
          "1133:             input_tags = to_save[cc_string].split(',')",
          "1134:             input_tags = list(map(lambda it: it.strip(), input_tags))",
          "1135:             changed |= modify_database_object(input_tags,",
          "1136:                                               getattr(book, cc_string),",
          "1137:                                               db.cc_classes[c.id],",
          "1138:                                               calibre_db.session,",
          "1139:                                               'custom')",
          "1140:     return changed",
          "1143: # returns None if no file is uploaded",
          "1144: # returns False if an error occurs, in all other cases the ebook metadata is returned",
          "1145: def upload_single_file(file_request, book, book_id):",
          "1146:     # Check and handle Uploaded file",
          "1147:     requested_file = file_request.files.get('btn-upload-format', None)",
          "1148:     if requested_file:",
          "1149:         # check for empty request",
          "1150:         if requested_file.filename != '':",
          "1151:             if not current_user.role_upload():",
          "1152:                 flash(_(u\"User has no rights to upload additional file formats\"), category=\"error\")",
          "1153:                 return False",
          "1154:             if '.' in requested_file.filename:",
          "1155:                 file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
          "1156:                 if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
          "1157:                     flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
          "1158:                           category=\"error\")",
          "1159:                     return False",
          "1160:             else:",
          "1161:                 flash(_('File to be uploaded must have an extension'), category=\"error\")",
          "1162:                 return False",
          "1164:             file_name = book.path.rsplit('/', 1)[-1]",
          "1165:             filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
          "1166:             saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
          "1168:             # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
          "1169:             if not os.path.exists(filepath):",
          "1170:                 try:",
          "1171:                     os.makedirs(filepath)",
          "1172:                 except OSError:",
          "1173:                     flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
          "1174:                     return False",
          "1175:             try:",
          "1176:                 requested_file.save(saved_filename)",
          "1177:             except OSError:",
          "1178:                 flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
          "1179:                 return False",
          "1181:             file_size = os.path.getsize(saved_filename)",
          "1182:             is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
          "1184:             # Format entry already exists, no need to update the database",
          "1185:             if is_format:",
          "1186:                 log.warning('Book format %s already existing', file_ext.upper())",
          "1187:             else:",
          "1188:                 try:",
          "1189:                     db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
          "1190:                     calibre_db.session.add(db_format)",
          "1191:                     calibre_db.session.commit()",
          "1192:                     calibre_db.update_title_sort(config)",
          "1193:                 except (OperationalError, IntegrityError) as e:",
          "1194:                     calibre_db.session.rollback()",
          "1195:                     log.error_or_exception(\"Database error: {}\".format(e))",
          "1196:                     flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "1197:                     return False  # return redirect(url_for('web.show_book', book_id=book.id))",
          "1199:             # Queue uploader info",
          "1200:             link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
          "1201:             upload_text = N_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
          "1202:             WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(book.title)))",
          "1204:             return uploader.process(",
          "1205:                 saved_filename, *os.path.splitext(requested_file.filename),",
          "1206:                 rarExecutable=config.config_rarfile_location)",
          "1207:     return None",
          "1210: def upload_cover(cover_request, book):",
          "1211:     requested_file = cover_request.files.get('btn-upload-cover', None)",
          "1212:     if requested_file:",
          "1213:         # check for empty request",
          "1214:         if requested_file.filename != '':",
          "1215:             if not current_user.role_upload():",
          "1216:                 flash(_(u\"User has no rights to upload cover\"), category=\"error\")",
          "1217:                 return False",
          "1218:             ret, message = helper.save_cover(requested_file, book.path)",
          "1219:             if ret is True:",
          "1220:                 helper.replace_cover_thumbnail_cache(book.id)",
          "1221:                 return True",
          "1223:                 flash(message, category=\"error\")",
          "1224:                 return False",
          "1225:     return None",
          "1228: def handle_title_on_edit(book, book_title):",
          "1229:     # handle book title",
          "1230:     book_title = book_title.rstrip().strip()",
          "1231:     if book.title != book_title:",
          "1232:         if book_title == '':",
          "1233:             book_title = _(u'Unknown')",
          "1234:         book.title = book_title",
          "1235:         return True",
          "1236:     return False",
          "1239: def handle_author_on_edit(book, author_name, update_stored=True):",
          "1240:     # handle author(s)",
          "1241:     input_authors, renamed = prepare_authors(author_name)",
          "1243:     change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
          "1245:     # Search for each author if author is in database, if not, author name and sorted author name is generated new",
          "1246:     # everything then is assembled for sorted author field in database",
          "1247:     sort_authors_list = list()",
          "1248:     for inp in input_authors:",
          "1249:         stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
          "1250:         if not stored_author:",
          "1251:             stored_author = helper.get_sorted_author(inp)",
          "1253:             stored_author = stored_author.sort",
          "1254:         sort_authors_list.append(helper.get_sorted_author(stored_author))",
          "1255:     sort_authors = ' & '.join(sort_authors_list)",
          "1256:     if book.author_sort != sort_authors and update_stored:",
          "1257:         book.author_sort = sort_authors",
          "1258:         change = True",
          "1259:     return input_authors, change, renamed",
          "1262: def search_objects_remove(db_book_object, db_type, input_elements):",
          "1263:     del_elements = []",
          "1264:     for c_elements in db_book_object:",
          "1265:         found = False",
          "1266:         if db_type == 'languages':",
          "1267:             type_elements = c_elements.lang_code",
          "1268:         elif db_type == 'custom':",
          "1269:             type_elements = c_elements.value",
          "1270:         else:",
          "1271:             type_elements = c_elements.name",
          "1272:         for inp_element in input_elements:",
          "1273:             if inp_element.lower() == type_elements.lower():",
          "1274:                 found = True",
          "1275:                 break",
          "1276:         # if the element was not found in the new list, add it to remove list",
          "1277:         if not found:",
          "1278:             del_elements.append(c_elements)",
          "1279:     return del_elements",
          "1282: def search_objects_add(db_book_object, db_type, input_elements):",
          "1283:     add_elements = []",
          "1284:     for inp_element in input_elements:",
          "1285:         found = False",
          "1286:         for c_elements in db_book_object:",
          "1287:             if db_type == 'languages':",
          "1288:                 type_elements = c_elements.lang_code",
          "1289:             elif db_type == 'custom':",
          "1290:                 type_elements = c_elements.value",
          "1291:             else:",
          "1292:                 type_elements = c_elements.name",
          "1293:             if inp_element == type_elements:",
          "1294:                 found = True",
          "1295:                 break",
          "1296:         if not found:",
          "1297:             add_elements.append(inp_element)",
          "1298:     return add_elements",
          "1301: def remove_objects(db_book_object, db_session, del_elements):",
          "1302:     changed = False",
          "1303:     if len(del_elements) > 0:",
          "1304:         for del_element in del_elements:",
          "1305:             db_book_object.remove(del_element)",
          "1306:             changed = True",
          "1307:             if len(del_element.books) == 0:",
          "1308:                 db_session.delete(del_element)",
          "1309:     return changed",
          "1312: def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
          "1313:     changed = False",
          "1314:     if db_type == 'languages':",
          "1315:         db_filter = db_object.lang_code",
          "1316:     elif db_type == 'custom':",
          "1317:         db_filter = db_object.value",
          "1318:     else:",
          "1319:         db_filter = db_object.name",
          "1320:     for add_element in add_elements:",
          "1321:         # check if an element with that name exists",
          "1322:         db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
          "1323:         # if no element is found add it",
          "1324:         if db_type == 'author':",
          "1325:             new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
          "1326:         elif db_type == 'series':",
          "1327:             new_element = db_object(add_element, add_element)",
          "1328:         elif db_type == 'custom':",
          "1329:             new_element = db_object(value=add_element)",
          "1330:         elif db_type == 'publisher':",
          "1331:             new_element = db_object(add_element, None)",
          "1332:         else:  # db_type should be tag or language",
          "1333:             new_element = db_object(add_element)",
          "1334:         if db_element is None:",
          "1335:             changed = True",
          "1336:             db_session.add(new_element)",
          "1337:             db_book_object.append(new_element)",
          "1338:         else:",
          "1339:             db_element = create_objects_for_addition(db_element, add_element, db_type)",
          "1340:             # add element to book",
          "1341:             changed = True",
          "1342:             db_book_object.append(db_element)",
          "1343:     return changed",
          "1346: def create_objects_for_addition(db_element, add_element, db_type):",
          "1347:     if db_type == 'custom':",
          "1348:         if db_element.value != add_element:",
          "1349:             db_element.value = add_element",
          "1350:     elif db_type == 'languages':",
          "1351:         if db_element.lang_code != add_element:",
          "1352:             db_element.lang_code = add_element",
          "1353:     elif db_type == 'series':",
          "1354:         if db_element.name != add_element:",
          "1355:             db_element.name = add_element",
          "1356:             db_element.sort = add_element",
          "1357:     elif db_type == 'author':",
          "1358:         if db_element.name != add_element:",
          "1359:             db_element.name = add_element",
          "1360:             db_element.sort = helper.get_sorted_author(add_element.replace('|', ','))",
          "1361:     elif db_type == 'publisher':",
          "1362:         if db_element.name != add_element:",
          "1363:             db_element.name = add_element",
          "1364:             db_element.sort = None",
          "1365:     elif db_element.name != add_element:",
          "1366:         db_element.name = add_element",
          "1367:     return db_element",
          "1370: # Modifies different Database objects, first check if elements have to be deleted,",
          "1371: # because they are no longer used, than check if elements have to be added to database",
          "1372: def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
          "1373:     # passing input_elements not as a list may lead to undesired results",
          "1374:     if not isinstance(input_elements, list):",
          "1375:         raise TypeError(str(input_elements) + \" should be passed as a list\")",
          "1376:     input_elements = [x for x in input_elements if x != '']",
          "1377:     # we have all input element (authors, series, tags) names now",
          "1378:     # 1. search for elements to remove",
          "1379:     del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
          "1380:     # 2. search for elements that need to be added",
          "1381:     add_elements = search_objects_add(db_book_object, db_type, input_elements)",
          "1382:     # if there are elements to remove, we remove them now",
          "1383:     changed = remove_objects(db_book_object, db_session, del_elements)",
          "1384:     # if there are elements to add, we add them now!",
          "1385:     if len(add_elements) > 0:",
          "1386:         changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
          "1387:     return changed",
          "1390: def modify_identifiers(input_identifiers, db_identifiers, db_session):",
          "1391:     \"\"\"Modify Identifiers to match input information.",
          "1392:        input_identifiers is a list of read-to-persist Identifiers objects.",
          "1393:        db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
          "1394:     changed = False",
          "1395:     error = False",
          "1396:     input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
          "1397:     if len(input_identifiers) != len(input_dict):",
          "1398:         error = True",
          "1399:     db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers])",
          "1400:     # delete db identifiers not present in input or modify them with input val",
          "1401:     for identifier_type, identifier in db_dict.items():",
          "1402:         if identifier_type not in input_dict.keys():",
          "1403:             db_session.delete(identifier)",
          "1404:             changed = True",
          "1405:         else:",
          "1406:             input_identifier = input_dict[identifier_type]",
          "1407:             identifier.type = input_identifier.type",
          "1408:             identifier.val = input_identifier.val",
          "1409:     # add input identifiers not present in db",
          "1410:     for identifier_type, identifier in input_dict.items():",
          "1411:         if identifier_type not in db_dict.keys():",
          "1412:             db_session.add(identifier)",
          "1413:             changed = True",
          "1414:     return changed, error",
          "",
          "---------------"
        ],
        "cps/helper.py||cps/helper.py": [
          "File: cps/helper.py -> cps/helper.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: import requests",
          "30: import unidecode",
          "33: from flask import send_from_directory, make_response, redirect, abort, url_for",
          "34: from flask_babel import gettext as _",
          "35: from flask_babel import lazy_gettext as N_",
          "37: from flask_login import current_user",
          "38: from sqlalchemy.sql.expression import true, false, and_, or_, text, func",
          "39: from sqlalchemy.exc import InvalidRequestError, OperationalError",
          "",
          "[Removed Lines]",
          "36: from flask_babel import format_datetime, get_locale",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:     advocate = requests",
          "53:     UnacceptableAddressException = MissingSchema = BaseException",
          "56: from .tasks.convert import TaskConvert",
          "57: from . import logger, config, db, ub, fs",
          "58: from . import gdriveutils as gd",
          "59: from .constants import STATIC_DIR as _STATIC_DIR, CACHE_TYPE_THUMBNAILS, THUMBNAIL_TYPE_COVER, THUMBNAIL_TYPE_SERIES",
          "60: from .subproc_wrapper import process_wait",
          "63: from .tasks.mail import TaskEmail",
          "64: from .tasks.thumbnail import TaskClearCoverThumbnailCache, TaskGenerateCoverThumbnails",
          "",
          "[Removed Lines]",
          "55: from . import calibre_db, cli",
          "61: from .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS, STAT_ENDED, \\",
          "62:     STAT_CANCELLED",
          "",
          "[Added Lines]",
          "52: from . import calibre_db, cli_param",
          "58: from .services.worker import WorkerThread",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78: # Convert existing book entry to new format",
          "80:     book = calibre_db.get_book(book_id)",
          "81:     data = calibre_db.get_book_format(book.id, old_book_format)",
          "83:     if not data:",
          "84:         error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)",
          "85:         log.error(\"convert_book_format: %s\", error_message)",
          "",
          "[Removed Lines]",
          "79: def convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):",
          "82:     file_path = os.path.join(calibrepath, book.path, data.name)",
          "",
          "[Added Lines]",
          "75: def convert_book_format(book_id, calibre_path, old_book_format, new_book_format, user_id, kindle_mail=None):",
          "78:     file_path = os.path.join(calibre_path, book.path, data.name)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "146: def check_send_to_kindle_with_converter(formats):",
          "148:     if 'EPUB' in formats and 'MOBI' not in formats:",
          "154:     if 'AZW3' in formats and 'MOBI' not in formats:",
          "163: def check_send_to_kindle(entry):",
          "",
          "[Removed Lines]",
          "147:     bookformats = list()",
          "149:         bookformats.append({'format': 'Mobi',",
          "150:                             'convert': 1,",
          "151:                             'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
          "152:                                       orig='Epub',",
          "153:                                       format='Mobi')})",
          "155:         bookformats.append({'format': 'Mobi',",
          "156:                             'convert': 2,",
          "157:                             'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
          "158:                                       orig='Azw3',",
          "159:                                       format='Mobi')})",
          "160:     return bookformats",
          "",
          "[Added Lines]",
          "143:     book_formats = list()",
          "145:         book_formats.append({'format': 'Mobi',",
          "146:                              'convert': 1,",
          "147:                              'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
          "148:                                        orig='Epub',",
          "149:                                        format='Mobi')})",
          "151:         book_formats.append({'format': 'Mobi',",
          "152:                              'convert': 2,",
          "153:                              'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
          "154:                                        orig='Azw3',",
          "155:                                        format='Mobi')})",
          "156:     return book_formats",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "165:         returns all available book formats for sending to Kindle",
          "166:     \"\"\"",
          "167:     formats = list()",
          "169:     if len(entry.data):",
          "170:         for ele in iter(entry.data):",
          "171:             if ele.uncompressed_size < config.mail_size:",
          "172:                 formats.append(ele.format)",
          "173:         if 'MOBI' in formats:",
          "177:         if 'PDF' in formats:",
          "181:         if 'AZW' in formats:",
          "185:         if config.config_converterpath:",
          "188:     else:",
          "189:         log.error(u'Cannot find book entry %d', entry.id)",
          "190:         return None",
          "",
          "[Removed Lines]",
          "168:     bookformats = list()",
          "174:             bookformats.append({'format': 'Mobi',",
          "175:                                 'convert': 0,",
          "176:                                 'text': _('Send %(format)s to Kindle', format='Mobi')})",
          "178:             bookformats.append({'format': 'Pdf',",
          "179:                                 'convert': 0,",
          "180:                                 'text': _('Send %(format)s to Kindle', format='Pdf')})",
          "182:             bookformats.append({'format': 'Azw',",
          "183:                                 'convert': 0,",
          "184:                                 'text': _('Send %(format)s to Kindle', format='Azw')})",
          "186:             bookformats.extend(check_send_to_kindle_with_converter(formats))",
          "187:         return bookformats",
          "",
          "[Added Lines]",
          "164:     book_formats = list()",
          "170:             book_formats.append({'format': 'Mobi',",
          "171:                                  'convert': 0,",
          "172:                                  'text': _('Send %(format)s to Kindle', format='Mobi')})",
          "174:             book_formats.append({'format': 'Pdf',",
          "175:                                  'convert': 0,",
          "176:                                  'text': _('Send %(format)s to Kindle', format='Pdf')})",
          "178:             book_formats.append({'format': 'Azw',",
          "179:                                  'convert': 0,",
          "180:                                  'text': _('Send %(format)s to Kindle', format='Azw')})",
          "182:             book_formats.extend(check_send_to_kindle_with_converter(formats))",
          "183:         return book_formats",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "194: # list with supported formats",
          "195: def check_read_formats(entry):",
          "196:     extensions_reader = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}",
          "198:     if len(entry.data):",
          "199:         for ele in iter(entry.data):",
          "200:             if ele.format.upper() in extensions_reader:",
          "205: # Files are processed in the following order/priority:",
          "",
          "[Removed Lines]",
          "197:     bookformats = list()",
          "201:                 bookformats.append(ele.format.lower())",
          "202:     return bookformats",
          "",
          "[Added Lines]",
          "193:     book_formats = list()",
          "197:                 book_formats.append(ele.format.lower())",
          "198:     return book_formats",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "229:     return _(u\"The requested file could not be read. Maybe wrong permissions?\")",
          "242: def get_valid_filename(value, replace_whitespace=True, chars=128):",
          "243:     \"\"\"",
          "244:     Returns the given string converted to a string that can be used for a clean",
          "245:     filename. Limits num characters to 128 max.",
          "246:     \"\"\"",
          "249:     if value[-1:] == u'.':",
          "250:         value = value[:-1]+u'_'",
          "251:     value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')",
          "",
          "[Removed Lines]",
          "232: def shorten_component(s, by_what):",
          "233:     l = len(s)",
          "234:     if l < by_what:",
          "235:         return s",
          "236:     l = (l - by_what)//2",
          "237:     if l <= 0:",
          "238:         return s",
          "239:     return s[:l] + s[-l:]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "814: # saves book cover from url",
          "815: def save_cover_from_url(url, book_path):",
          "816:     try:",
          "818:             img = requests.get(url, timeout=(10, 200), allow_redirects=False)  # ToDo: Error Handling",
          "819:         elif use_advocate:",
          "820:             img = advocate.get(url, timeout=(10, 200), allow_redirects=False)      # ToDo: Error Handling",
          "",
          "[Removed Lines]",
          "817:         if cli.allow_localhost:",
          "",
          "[Added Lines]",
          "801:         if cli_param.allow_localhost:",
          "",
          "---------------"
        ],
        "cps/kobo_auth.py||cps/kobo_auth.py": [
          "File: cps/kobo_auth.py -> cps/kobo_auth.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "71: from . import logger, config, calibre_db, db, helper, ub, lm",
          "72: from .render_template import render_title_template",
          "75: log = logger.create()",
          "115: kobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")",
          "",
          "[Removed Lines]",
          "78: def register_url_value_preprocessor(kobo):",
          "79:     @kobo.url_value_preprocessor",
          "80:     # pylint: disable=unused-variable",
          "81:     def pop_auth_token(__, values):",
          "82:         g.auth_token = values.pop(\"auth_token\")",
          "85: def disable_failed_auth_redirect_for_blueprint(bp):",
          "86:     lm.blueprint_login_views[bp.name] = None",
          "89: def get_auth_token():",
          "90:     if \"auth_token\" in g:",
          "91:         return g.get(\"auth_token\")",
          "92:     else:",
          "93:         return None",
          "96: def requires_kobo_auth(f):",
          "97:     @wraps(f)",
          "98:     def inner(*args, **kwargs):",
          "99:         auth_token = get_auth_token()",
          "100:         if auth_token is not None:",
          "101:             user = (",
          "102:                 ub.session.query(ub.User)",
          "103:                 .join(ub.RemoteAuthToken)",
          "104:                 .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
          "105:                 .first()",
          "106:             )",
          "107:             if user is not None:",
          "108:                 login_user(user)",
          "109:                 return f(*args, **kwargs)",
          "110:             log.debug(\"Received Kobo request without a recognizable auth token.\")",
          "111:             return abort(401)",
          "112:     return inner",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:         .filter(ub.RemoteAuthToken.token_type==1).delete()",
          "167:     return ub.session_commit()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131: def disable_failed_auth_redirect_for_blueprint(bp):",
          "132:     lm.blueprint_login_views[bp.name] = None",
          "135: def get_auth_token():",
          "136:     if \"auth_token\" in g:",
          "137:         return g.get(\"auth_token\")",
          "138:     else:",
          "139:         return None",
          "142: def register_url_value_preprocessor(kobo):",
          "143:     @kobo.url_value_preprocessor",
          "144:     # pylint: disable=unused-variable",
          "145:     def pop_auth_token(__, values):",
          "146:         g.auth_token = values.pop(\"auth_token\")",
          "149: def requires_kobo_auth(f):",
          "150:     @wraps(f)",
          "151:     def inner(*args, **kwargs):",
          "152:         auth_token = get_auth_token()",
          "153:         if auth_token is not None:",
          "154:             user = (",
          "155:                 ub.session.query(ub.User)",
          "156:                 .join(ub.RemoteAuthToken)",
          "157:                 .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)",
          "158:                 .first()",
          "159:             )",
          "160:             if user is not None:",
          "161:                 login_user(user)",
          "162:                 return f(*args, **kwargs)",
          "163:             log.debug(\"Received Kobo request without a recognizable auth token.\")",
          "164:             return abort(401)",
          "165:     return inner",
          "",
          "---------------"
        ],
        "cps/main.py||cps/main.py": [
          "File: cps/main.py -> cps/main.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from . import create_app",
          "22: from .jinjia import jinjia",
          "24: from .remotelogin import remotelogin",
          "29: try:",
          "30:     from kobo import kobo, get_kobo_activated",
          "",
          "[Removed Lines]",
          "23: from .shelf import shelf",
          "25: from .search_metadata import meta",
          "26: from .error_handler import init_errorhandler",
          "27: from .tasks_status import tasks",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     from .editbooks import editbook",
          "51:     from .about import about",
          "52:     from .search import search",
          "54:     from . import web_server",
          "55:     init_errorhandler()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49:     from .search_metadata import meta",
          "50:     from .shelf import shelf",
          "51:     from .tasks_status import tasks",
          "52:     from .error_handler import init_errorhandler",
          "",
          "---------------"
        ],
        "cps/opds.py||cps/opds.py": [
          "File: cps/opds.py -> cps/opds.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:     return decorated",
          "73: @opds.route(\"/opds/\")",
          "74: @opds.route(\"/opds\")",
          "75: @requires_basic_auth_if_no_ano",
          "",
          "[Removed Lines]",
          "59: class FeedObject:",
          "60:     def __init__(self, rating_id, rating_name):",
          "61:         self.rating_id = rating_id",
          "62:         self.rating_name = rating_name",
          "64:     @property",
          "65:     def id(self):",
          "66:         return self.rating_id",
          "68:     @property",
          "69:     def name(self):",
          "70:         return self.rating_name",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "468:     return render_xml_template('feed.xml', entries=result, pagination=pagination)",
          "471: def feed_search(term):",
          "472:     if term:",
          "473:         entries, __, ___ = calibre_db.get_search_results(term, config=config)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457: class FeedObject:",
          "458:     def __init__(self, rating_id, rating_name):",
          "459:         self.rating_id = rating_id",
          "460:         self.rating_name = rating_name",
          "462:     @property",
          "463:     def id(self):",
          "464:         return self.rating_id",
          "466:     @property",
          "467:     def name(self):",
          "468:         return self.rating_name",
          "",
          "---------------"
        ],
        "cps/search.py||cps/search.py": [
          "File: cps/search.py -> cps/search.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "406:                                                                       offset,",
          "407:                                                                       order,",
          "408:                                                                       limit,",
          "411:     return render_title_template('search.html',",
          "412:                                  searchterm=term,",
          "",
          "[Removed Lines]",
          "409:                                                                       False,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "cps/services/__init__.py||cps/services/__init__.py": [
          "File: cps/services/__init__.py -> cps/services/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: from .. import logger",
          "22: log = logger.create()",
          "26: except ImportError as err:",
          "27:     log.debug(\"Cannot import goodreads, showing authors-metadata will not work: %s\", err)",
          "28:     goodreads_support = None",
          "",
          "[Removed Lines]",
          "25: try: from . import goodreads_support",
          "",
          "[Added Lines]",
          "23: try:",
          "24:     from . import goodreads_support",
          "",
          "---------------"
        ],
        "cps/shelf.py||cps/shelf.py": [
          "File: cps/shelf.py -> cps/shelf.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: from .render_template import render_title_template",
          "34: from .usermanagement import login_required_if_no_ano",
          "37: log = logger.create()",
          "59: @shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])",
          "",
          "[Removed Lines]",
          "36: shelf = Blueprint('shelf', __name__)",
          "40: def check_shelf_edit_permissions(cur_shelf):",
          "41:     if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):",
          "42:         log.error(\"User {} not allowed to edit shelf: {}\".format(current_user.id, cur_shelf.name))",
          "43:         return False",
          "44:     if cur_shelf.is_public and not current_user.role_edit_shelfs():",
          "45:         log.info(\"User {} not allowed to edit public shelves\".format(current_user.id))",
          "46:         return False",
          "47:     return True",
          "50: def check_shelf_view_permissions(cur_shelf):",
          "51:     if cur_shelf.is_public:",
          "52:         return True",
          "53:     if current_user.is_anonymous or cur_shelf.user_id != current_user.id:",
          "54:         log.error(\"User is unauthorized to view non-public shelf: {}\".format(cur_shelf.name))",
          "55:         return False",
          "56:     return True",
          "",
          "[Added Lines]",
          "38: shelf = Blueprint('shelf', __name__)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238:     return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)",
          "241: # if shelf ID is set, we are editing a shelf",
          "242: def create_edit_shelf(shelf, page_title, page, shelf_id=False):",
          "243:     sync_only_selected_shelves = current_user.kobo_only_shelves_sync",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223: @shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])",
          "224: @login_required",
          "225: def delete_shelf(shelf_id):",
          "226:     cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
          "227:     try:",
          "228:         if not delete_shelf_helper(cur_shelf):",
          "229:             flash(_(\"Error deleting Shelf\"), category=\"error\")",
          "230:         else:",
          "231:             flash(_(\"Shelf successfully deleted\"), category=\"success\")",
          "232:     except InvalidRequestError as e:",
          "233:         ub.session.rollback()",
          "234:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "235:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "236:     return redirect(url_for('web.index'))",
          "239: @shelf.route(\"/simpleshelf/<int:shelf_id>\")",
          "240: @login_required_if_no_ano",
          "241: def show_simpleshelf(shelf_id):",
          "242:     return render_show_shelf(2, shelf_id, 1, None)",
          "245: @shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})",
          "246: @shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})",
          "247: @shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")",
          "248: @login_required_if_no_ano",
          "249: def show_shelf(shelf_id, sort_param, page):",
          "250:     return render_show_shelf(1, shelf_id, page, sort_param)",
          "253: @shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
          "254: @login_required",
          "255: def order_shelf(shelf_id):",
          "256:     shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
          "257:     if shelf and check_shelf_view_permissions(shelf):",
          "258:         if request.method == \"POST\":",
          "259:             to_save = request.form.to_dict()",
          "260:             books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(",
          "261:                 ub.BookShelf.order.asc()).all()",
          "262:             counter = 0",
          "263:             for book in books_in_shelf:",
          "264:                 setattr(book, 'order', to_save[str(book.book_id)])",
          "265:                 counter += 1",
          "266:                 # if order diffrent from before -> shelf.last_modified = datetime.utcnow()",
          "267:             try:",
          "268:                 ub.session.commit()",
          "269:             except (OperationalError, InvalidRequestError) as e:",
          "270:                 ub.session.rollback()",
          "271:                 log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "272:                 flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "274:         result = list()",
          "275:         if shelf:",
          "276:             result = calibre_db.session.query(db.Books) \\",
          "277:                 .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
          "278:                 .add_columns(calibre_db.common_filters().label(\"visible\")) \\",
          "279:                 .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()",
          "280:         return render_title_template('shelf_order.html', entries=result,",
          "281:                                      title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),",
          "282:                                      shelf=shelf, page=\"shelforder\")",
          "283:     else:",
          "284:         abort(404)",
          "287: def check_shelf_edit_permissions(cur_shelf):",
          "288:     if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):",
          "289:         log.error(\"User {} not allowed to edit shelf: {}\".format(current_user.id, cur_shelf.name))",
          "290:         return False",
          "291:     if cur_shelf.is_public and not current_user.role_edit_shelfs():",
          "292:         log.info(\"User {} not allowed to edit public shelves\".format(current_user.id))",
          "293:         return False",
          "294:     return True",
          "297: def check_shelf_view_permissions(cur_shelf):",
          "298:     if cur_shelf.is_public:",
          "299:         return True",
          "300:     if current_user.is_anonymous or cur_shelf.user_id != current_user.id:",
          "301:         log.error(\"User is unauthorized to view non-public shelf: {}\".format(cur_shelf.name))",
          "302:         return False",
          "303:     return True",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:                     ub.ShelfArchive.uuid == shelf.uuid).delete()",
          "256:                 ub.session_commit()",
          "257:         shelf_title = to_save.get(\"title\", \"\")",
          "259:             shelf.name = shelf_title",
          "260:             shelf.is_public = is_public",
          "261:             if not shelf_id:",
          "",
          "[Removed Lines]",
          "258:         if check_shelf_is_unique(shelf, shelf_title, is_public, shelf_id):",
          "",
          "[Added Lines]",
          "323:         if check_shelf_is_unique(shelf_title, is_public, shelf_id):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "288:                                  sync_only_selected_shelves=sync_only_selected_shelves)",
          "292:     if shelf_id:",
          "293:         ident = ub.Shelf.id != shelf_id",
          "294:     else:",
          "",
          "[Removed Lines]",
          "291: def check_shelf_is_unique(shelf, title, is_public, shelf_id=False):",
          "",
          "[Added Lines]",
          "356: def check_shelf_is_unique(title, is_public, shelf_id=False):",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "328:     return True",
          "395: def change_shelf_order(shelf_id, order):",
          "396:     result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,",
          "397:                                                           db.Books.id == db.books_series_link.c.book)\\",
          "",
          "[Removed Lines]",
          "331: @shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])",
          "332: @login_required",
          "333: def delete_shelf(shelf_id):",
          "334:     cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
          "335:     try:",
          "336:         if not delete_shelf_helper(cur_shelf):",
          "337:             flash(_(\"Error deleting Shelf\"), category=\"error\")",
          "338:         else:",
          "339:             flash(_(\"Shelf successfully deleted\"), category=\"success\")",
          "340:     except InvalidRequestError as e:",
          "341:         ub.session.rollback()",
          "342:         log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "343:         flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "344:     return redirect(url_for('web.index'))",
          "347: @shelf.route(\"/simpleshelf/<int:shelf_id>\")",
          "348: @login_required_if_no_ano",
          "349: def show_simpleshelf(shelf_id):",
          "350:     return render_show_shelf(2, shelf_id, 1, None)",
          "353: @shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})",
          "354: @shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})",
          "355: @shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")",
          "356: @login_required_if_no_ano",
          "357: def show_shelf(shelf_id, sort_param, page):",
          "358:     return render_show_shelf(1, shelf_id, page, sort_param)",
          "361: @shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])",
          "362: @login_required",
          "363: def order_shelf(shelf_id):",
          "364:     shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()",
          "365:     if shelf and check_shelf_view_permissions(shelf):",
          "366:         if request.method == \"POST\":",
          "367:             to_save = request.form.to_dict()",
          "368:             books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(",
          "369:                 ub.BookShelf.order.asc()).all()",
          "370:             counter = 0",
          "371:             for book in books_in_shelf:",
          "372:                 setattr(book, 'order', to_save[str(book.book_id)])",
          "373:                 counter += 1",
          "374:                 # if order diffrent from before -> shelf.last_modified = datetime.utcnow()",
          "375:             try:",
          "376:                 ub.session.commit()",
          "377:             except (OperationalError, InvalidRequestError) as e:",
          "378:                 ub.session.rollback()",
          "379:                 log.error_or_exception(\"Settings Database error: {}\".format(e))",
          "380:                 flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")",
          "382:         result = list()",
          "383:         if shelf:",
          "384:             result = calibre_db.session.query(db.Books) \\",
          "385:                 .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\",
          "386:                 .add_columns(calibre_db.common_filters().label(\"visible\")) \\",
          "387:                 .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()",
          "388:         return render_title_template('shelf_order.html', entries=result,",
          "389:                                      title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),",
          "390:                                      shelf=shelf, page=\"shelforder\")",
          "391:     else:",
          "392:         abort(404)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "cps/tasks_status.py||cps/tasks_status.py": [
          "File: cps/tasks_status.py -> cps/tasks_status.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: @tasks.route(\"/ajax/emailstat\")",
          "35: @login_required",
          "36: def get_email_status_json():",
          "38:     return jsonify(render_task_status(tasks))",
          "",
          "[Removed Lines]",
          "37:     tasks = WorkerThread.getInstance().tasks",
          "",
          "[Added Lines]",
          "37:     tasks = WorkerThread.get_instance().tasks",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42: @login_required",
          "43: def get_tasks_status():",
          "44:     # if current user admin, show all email, otherwise only own emails",
          "46:     answer = render_task_status(tasks)",
          "47:     return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")",
          "",
          "[Removed Lines]",
          "45:     tasks = WorkerThread.getInstance().tasks",
          "",
          "[Added Lines]",
          "45:     tasks = WorkerThread.get_instance().tasks",
          "",
          "---------------"
        ],
        "cps/templates/tasks.html||cps/templates/tasks.html": [
          "File: cps/templates/tasks.html -> cps/templates/tasks.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: {% block body %}",
          "6: <div class=\"discover\">",
          "7:     <h2>{{_('Tasks')}}</h2>",
          "9:       <thead>",
          "10:         <tr>",
          "11:             {% if g.user.role_admin() %}",
          "",
          "[Removed Lines]",
          "8:     <table class=\"table table-no-bordered\" id=\"tasktable\" data-url=\"{{  url_for('task.get_email_status_json') }}\"  data-sort-name=\"starttime\" data-sort-order=\"asc\" data-locale=\"{{ g.user.locale }}\">",
          "",
          "[Added Lines]",
          "8:     <table class=\"table table-no-bordered\" id=\"tasktable\" data-url=\"{{  url_for('tasks.get_email_status_json') }}\"  data-sort-name=\"starttime\" data-sort-order=\"asc\" data-locale=\"{{ g.user.locale }}\">",
          "",
          "---------------"
        ],
        "cps/web.py||cps/web.py": [
          "File: cps/web.py -> cps/web.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: from functools import wraps",
          "81: @app.after_request",
          "",
          "[Removed Lines]",
          "75: #try:",
          "76: #    from natsort import natsorted as sort",
          "77: #except ImportError:",
          "78: #    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files",
          "",
          "[Added Lines]",
          "75: try:",
          "76:     from natsort import natsorted as sort",
          "77: except ImportError:",
          "78:     sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files",
          "",
          "---------------"
        ]
      }
    }
  ]
}
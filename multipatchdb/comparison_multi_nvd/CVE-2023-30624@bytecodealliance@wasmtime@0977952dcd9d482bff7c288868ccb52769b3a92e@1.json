{
  "cve_id": "CVE-2023-30624",
  "cve_desc": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 6.0.2, 7.0.1, and 8.0.1, Wasmtime's implementation of managing per-instance state, such as tables and memories, contains LLVM-level undefined behavior. This undefined behavior was found to cause runtime-level issues when compiled with LLVM 16 which causes some writes, which are critical for correctness, to be optimized away. Vulnerable versions of Wasmtime compiled with Rust 1.70, which is currently in beta, or later are known to have incorrectly compiled functions. Versions of Wasmtime compiled with the current Rust stable release, 1.69, and prior are not known at this time to have any issues, but can theoretically exhibit potential issues.\n\nThe underlying problem is that Wasmtime's runtime state for an instance involves a Rust-defined structure called `Instance` which has a trailing `VMContext` structure after it. This `VMContext` structure has a runtime-defined layout that is unique per-module. This representation cannot be expressed with safe code in Rust so `unsafe` code is required to maintain this state. The code doing this, however, has methods which take `&self` as an argument but modify data in the `VMContext` part of the allocation. This means that pointers derived from `&self` are mutated. This is typically not allowed, except in the presence of `UnsafeCell`, in Rust. When compiled to LLVM these functions have `noalias readonly` parameters which means it's UB to write through the pointers.\n\nWasmtime's internal representation and management of `VMContext` has been updated to use `&mut self` methods where appropriate. Additionally verification tools for `unsafe` code in Rust, such as `cargo miri`, are planned to be executed on the `main` branch soon to fix any Rust-level issues that may be exploited in future compiler versions.\n\nPrecomplied binaries available for Wasmtime from GitHub releases have been compiled with at most LLVM 15 so are not known to be vulnerable. As mentioned above, however, it's still recommended to update.\n\nWasmtime version 6.0.2, 7.0.1, and 8.0.1 have been issued which contain the patch necessary to work correctly on LLVM 16 and have no known UB on LLVM 15 and earlier. If Wasmtime is compiled with Rust 1.69 and prior, which use LLVM 15, then there are no known issues. There is a theoretical possibility for undefined behavior to exploited, however, so it's recommended that users upgrade to a patched version of Wasmtime. Users using beta Rust (1.70 at this time) or nightly Rust (1.71 at this time) must update to a patched version to work correctly.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
  "patch_info": {
    "commit_hash": "0977952dcd9d482bff7c288868ccb52769b3a92e",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e",
    "files": [
      "RELEASES.md",
      "crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs"
    ],
    "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix dates and fill out more notes",
    "before_after_code_files": [
      "crates/environ/src/module.rs||crates/environ/src/module.rs",
      "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
      "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
      "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
      "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
    ]
  },
  "patch_diff": {
    "crates/environ/src/module.rs||crates/environ/src/module.rs": [
      "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "241:         }",
      "242:         let mut idx = 0;",
      "243:         let ok = self.module.memory_initialization.init_memory(",
      "244:             InitMemory::CompileTime(&self.module),",
      "",
      "[Removed Lines]",
      "245:             &mut |memory, init| {",
      "",
      "[Added Lines]",
      "244:             &mut (),",
      "246:             |(), memory, init| {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "529:         &self,",
      "532:     ) -> bool {",
      "533:         let initializers = match self {",
      "",
      "[Removed Lines]",
      "528:     pub fn init_memory(",
      "530:         state: InitMemory<'_>,",
      "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "[Added Lines]",
      "529:     pub fn init_memory<T>(",
      "531:         state: &mut T,",
      "532:         init: InitMemory<'_, T>,",
      "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "543:             MemoryInitialization::Static { map } => {",
      "544:                 for (index, init) in map {",
      "545:                     if let Some(init) = init {",
      "547:                         if !result {",
      "548:                             return result;",
      "549:                         }",
      "",
      "[Removed Lines]",
      "546:                         let result = write(index, init);",
      "",
      "[Added Lines]",
      "548:                         let result = write(state, index, init);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "569:             let base = match base {",
      "571:                     InitMemory::Runtime {",
      "572:                         get_global_as_u64, ..",
      "574:                     InitMemory::CompileTime(_) => return false,",
      "575:                 },",
      "576:                 None => 0,",
      "",
      "[Removed Lines]",
      "570:                 Some(index) => match &state {",
      "573:                     } => get_global_as_u64(index),",
      "",
      "[Added Lines]",
      "572:                 Some(index) => match &init {",
      "575:                     } => get_global_as_u64(state, index),",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "585:                 None => return false,",
      "586:             };",
      "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
      "590:                 InitMemory::Runtime {",
      "591:                     memory_size_in_pages,",
      "592:                     ..",
      "594:             };",
      "",
      "[Removed Lines]",
      "588:             let cur_size_in_pages = match &state {",
      "593:                 } => memory_size_in_pages(memory_index),",
      "",
      "[Added Lines]",
      "590:             let cur_size_in_pages = match &init {",
      "595:                 } => memory_size_in_pages(state, memory_index),",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "616:                 offset: start,",
      "617:                 data: data.clone(),",
      "618:             };",
      "620:             if !result {",
      "621:                 return result;",
      "622:             }",
      "",
      "[Removed Lines]",
      "619:             let result = write(memory_index, &init);",
      "",
      "[Added Lines]",
      "621:             let result = write(state, memory_index, &init);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "631: pub enum InitMemory<'a> {",
      "",
      "[Added Lines]",
      "633: pub enum InitMemory<'a, T> {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "641:     Runtime {",
      "647:     },",
      "648: }",
      "",
      "[Removed Lines]",
      "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
      "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
      "",
      "[Added Lines]",
      "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
      "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
      "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "",
      "[Removed Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
      "151:         (self.vmctx_ptr().cast::<u8>())",
      "",
      "[Added Lines]",
      "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
      "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
      "152:             .add(usize::try_from(offset).unwrap())",
      "153:             .cast()",
      "154:     }",
      "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
      "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:     #[allow(dead_code)]",
      "187:         unsafe { *self.table_ptr(index) }",
      "188:     }",
      "192:         unsafe {",
      "194:         }",
      "195:     }",
      "200:     }",
      "",
      "[Removed Lines]",
      "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
      "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "[Added Lines]",
      "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
      "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
      "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
      "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:     }",
      "242:         unsafe { &*self.global_ptr(index) }",
      "243:     }",
      "248:     }",
      "",
      "[Removed Lines]",
      "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "[Added Lines]",
      "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
      "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
      "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "254:     pub(crate) fn defined_or_imported_global_ptr(",
      "256:         index: GlobalIndex,",
      "257:     ) -> *mut VMGlobalDefinition {",
      "258:         if let Some(index) = self.module().defined_global_index(index) {",
      "",
      "[Removed Lines]",
      "255:         &self,",
      "",
      "[Added Lines]",
      "261:         &mut self,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "263:     }",
      "268:     }",
      "273:     }",
      "278:     }",
      "",
      "[Removed Lines]",
      "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
      "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
      "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
      "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
      "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
      "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "[Added Lines]",
      "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
      "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
      "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
      "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
      "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
      "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "402:     }",
      "406:         let index = DefinedTableIndex::new(",
      "407:             usize::try_from(",
      "408:                 (table as *const VMTableDefinition)",
      "",
      "[Removed Lines]",
      "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "[Added Lines]",
      "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "584:             let func = &self.module().functions[index];",
      "585:             let sig = func.signature;",
      "586:             let anyfunc: *mut VMCallerCheckedFuncRef = self",
      "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
      "589:                 );",
      "590:             self.construct_anyfunc(index, sig, anyfunc);",
      "",
      "[Removed Lines]",
      "587:                 .vmctx_plus_offset::<VMCallerCheckedFuncRef>(",
      "",
      "[Added Lines]",
      "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "923:     ) {",
      "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
      "927:         self.set_callee(None);",
      "928:         self.set_store(store.as_raw());",
      "931:         let signatures = self.runtime_info.signature_ids();",
      "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
      "939:         ptr::copy_nonoverlapping(",
      "940:             imports.functions.as_ptr(),",
      "942:             imports.functions.len(),",
      "943:         );",
      "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
      "945:         ptr::copy_nonoverlapping(",
      "946:             imports.tables.as_ptr(),",
      "948:             imports.tables.len(),",
      "949:         );",
      "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
      "951:         ptr::copy_nonoverlapping(",
      "952:             imports.memories.as_ptr(),",
      "954:             imports.memories.len(),",
      "955:         );",
      "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
      "957:         ptr::copy_nonoverlapping(",
      "958:             imports.globals.as_ptr(),",
      "960:             imports.globals.len(),",
      "961:         );",
      "",
      "[Removed Lines]",
      "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
      "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
      "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
      "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
      "",
      "[Added Lines]",
      "942:             &VMBuiltinFunctionsArray::INIT;",
      "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
      "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
      "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
      "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
      "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
      "973:             ptr = ptr.add(1);",
      "",
      "[Removed Lines]",
      "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
      "",
      "[Added Lines]",
      "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
      "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
      "985:             let memory_index = module.memory_index(defined_memory_index);",
      "",
      "[Removed Lines]",
      "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
      "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
      "",
      "[Added Lines]",
      "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
      "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1068: impl Drop for Instance {",
      "1069:     fn drop(&mut self) {",
      "1073:                 Some(idx) => idx,",
      "1074:                 None => continue,",
      "1075:             };",
      "",
      "[Removed Lines]",
      "1071:         for (idx, global) in self.module().globals.iter() {",
      "1072:             let idx = match self.module().defined_global_index(idx) {",
      "",
      "[Added Lines]",
      "1078:         let module = self.module().clone();",
      "1079:         for (idx, global) in module.globals.iter() {",
      "1080:             let idx = match module.defined_global_index(idx) {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1182:     }",
      "1187:     }",
      "",
      "[Removed Lines]",
      "1185:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1186:         self.instance().table_index(table)",
      "",
      "[Added Lines]",
      "1193:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
      "1194:         self.instance_mut().table_index(table)",
      "",
      "---------------"
    ],
    "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
      "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "200:     fn purge_module(&self, module: CompiledModuleId);",
      "201: }",
      "204:     match init.base {",
      "205:         Some(base) => {",
      "214:             init.offset",
      "215:                 .checked_add(val)",
      "",
      "[Removed Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
      "206:             let val = unsafe {",
      "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
      "209:                 } else {",
      "211:                 }",
      "212:             };",
      "",
      "[Added Lines]",
      "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
      "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "256:         TableInitialization::FuncTable { segments, .. }",
      "257:         | TableInitialization::Segments { segments } => {",
      "258:             for segment in segments {",
      "259:                 instance.table_init_segment(",
      "260:                     segment.table_index,",
      "261:                     &segment.elements,",
      "263:                     0,",
      "264:                     segment.elements.len() as u32,",
      "265:                 )?;",
      "",
      "[Removed Lines]",
      "262:                     get_table_init_start(segment, instance)?,",
      "",
      "[Added Lines]",
      "253:                 let start = get_table_init_start(segment, instance)?;",
      "257:                     start,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "270:     Ok(())",
      "271: }",
      "274:     match init.base {",
      "275:         Some(base) => {",
      "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
      "277:                 .memory",
      "278:                 .memory64;",
      "279:             let val = unsafe {",
      "285:                 if mem64 {",
      "287:                 } else {",
      "289:                 }",
      "290:             };",
      "",
      "[Removed Lines]",
      "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
      "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
      "281:                     instance.global(def_index)",
      "282:                 } else {",
      "283:                     &*instance.imported_global(base).from",
      "284:                 };",
      "288:                     u64::from(*global.as_u32())",
      "",
      "[Added Lines]",
      "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
      "275:                 let global = instance.defined_or_imported_global_ptr(base);",
      "279:                     u64::from(*(*global).as_u32())",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "297:     }",
      "298: }",
      "301:     for init in initializers {",
      "302:         let memory = instance.get_memory(init.memory_index);",
      "303:         let start = get_memory_init_start(init, instance)?;",
      "",
      "[Removed Lines]",
      "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
      "",
      "[Added Lines]",
      "291: fn check_memory_init_bounds(",
      "292:     instance: &mut Instance,",
      "293:     initializers: &[MemoryInitializer],",
      "294: ) -> Result<()> {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "319: }",
      "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
      "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
      "335:         } else {",
      "337:         }",
      "338:     };",
      "",
      "[Removed Lines]",
      "322:     let memory_size_in_pages =",
      "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
      "327:     let get_global_as_u64 = &|global| unsafe {",
      "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
      "329:             instance.global(def_index)",
      "330:         } else {",
      "331:             &*instance.imported_global(global).from",
      "332:         };",
      "336:             u64::from(*def.as_u32())",
      "",
      "[Added Lines]",
      "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
      "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
      "318:     };",
      "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
      "323:         let def = instance.defined_or_imported_global_ptr(global);",
      "327:             u64::from(*(*def).as_u32())",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:     let ok = module.memory_initialization.init_memory(",
      "349:         InitMemory::Runtime {",
      "350:             memory_size_in_pages,",
      "351:             get_global_as_u64,",
      "352:         },",
      "",
      "[Removed Lines]",
      "353:         &mut |memory_index, init| {",
      "",
      "[Added Lines]",
      "340:         instance,",
      "345:         |instance, memory_index, init| {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
      "384:     check_table_init_bounds(instance, module)?;",
      "387:         MemoryInitialization::Segmented(initializers) => {",
      "388:             check_memory_init_bounds(instance, initializers)?;",
      "389:         }",
      "",
      "[Removed Lines]",
      "386:     match &instance.module().memory_initialization {",
      "",
      "[Added Lines]",
      "378:     match &module.memory_initialization {",
      "",
      "---------------"
    ],
    "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
      "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
      "414:     let index = GlobalIndex::from_u32(index);",
      "416:     let global = instance.defined_or_imported_global_ptr(index);",
      "417:     match (*global).as_externref().clone() {",
      "418:         None => ptr::null_mut(),",
      "",
      "[Removed Lines]",
      "415:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "415:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "435:     };",
      "437:     let index = GlobalIndex::from_u32(index);",
      "439:     let global = instance.defined_or_imported_global_ptr(index);",
      "",
      "[Removed Lines]",
      "438:     let instance = (*vmctx).instance();",
      "",
      "[Added Lines]",
      "438:     let instance = (*vmctx).instance_mut();",
      "",
      "---------------"
    ],
    "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
      "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "219: where",
      "220:     F: FnMut(*mut VMContext),",
      "221: {",
      "224:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
      "225:         wasmtime_setjmp(",
      "",
      "[Removed Lines]",
      "222:     let limits = (*caller).instance().runtime_limits();",
      "",
      "[Added Lines]",
      "222:     let limits = (*caller).instance_mut().runtime_limits();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ef6243db3f19417b01733837789480d4f0ba5b52",
      "candidate_info": {
        "commit_hash": "ef6243db3f19417b01733837789480d4f0ba5b52",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/ef6243db3f19417b01733837789480d4f0ba5b52",
        "files": [
          "RELEASES.md",
          "crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs"
        ],
        "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix release dates",
        "before_after_code_files": [
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:         }",
          "242:         let mut idx = 0;",
          "243:         let ok = self.module.memory_initialization.init_memory(",
          "244:             InitMemory::CompileTime(&self.module),",
          "",
          "[Removed Lines]",
          "245:             &mut |memory, init| {",
          "",
          "[Added Lines]",
          "244:             &mut (),",
          "246:             |(), memory, init| {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:         &self,",
          "532:     ) -> bool {",
          "533:         let initializers = match self {",
          "",
          "[Removed Lines]",
          "528:     pub fn init_memory(",
          "530:         state: InitMemory<'_>,",
          "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "[Added Lines]",
          "529:     pub fn init_memory<T>(",
          "531:         state: &mut T,",
          "532:         init: InitMemory<'_, T>,",
          "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "543:             MemoryInitialization::Static { map } => {",
          "544:                 for (index, init) in map {",
          "545:                     if let Some(init) = init {",
          "547:                         if !result {",
          "548:                             return result;",
          "549:                         }",
          "",
          "[Removed Lines]",
          "546:                         let result = write(index, init);",
          "",
          "[Added Lines]",
          "548:                         let result = write(state, index, init);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "569:             let base = match base {",
          "571:                     InitMemory::Runtime {",
          "572:                         get_global_as_u64, ..",
          "574:                     InitMemory::CompileTime(_) => return false,",
          "575:                 },",
          "576:                 None => 0,",
          "",
          "[Removed Lines]",
          "570:                 Some(index) => match &state {",
          "573:                     } => get_global_as_u64(index),",
          "",
          "[Added Lines]",
          "572:                 Some(index) => match &init {",
          "575:                     } => get_global_as_u64(state, index),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "585:                 None => return false,",
          "586:             };",
          "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
          "590:                 InitMemory::Runtime {",
          "591:                     memory_size_in_pages,",
          "592:                     ..",
          "594:             };",
          "",
          "[Removed Lines]",
          "588:             let cur_size_in_pages = match &state {",
          "593:                 } => memory_size_in_pages(memory_index),",
          "",
          "[Added Lines]",
          "590:             let cur_size_in_pages = match &init {",
          "595:                 } => memory_size_in_pages(state, memory_index),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "616:                 offset: start,",
          "617:                 data: data.clone(),",
          "618:             };",
          "620:             if !result {",
          "621:                 return result;",
          "622:             }",
          "",
          "[Removed Lines]",
          "619:             let result = write(memory_index, &init);",
          "",
          "[Added Lines]",
          "621:             let result = write(state, memory_index, &init);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "631: pub enum InitMemory<'a> {",
          "",
          "[Added Lines]",
          "633: pub enum InitMemory<'a, T> {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "641:     Runtime {",
          "647:     },",
          "648: }",
          "",
          "[Removed Lines]",
          "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
          "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
          "",
          "[Added Lines]",
          "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
          "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "",
          "[Removed Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
          "151:         (self.vmctx_ptr().cast::<u8>())",
          "",
          "[Added Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
          "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
          "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185:     #[allow(dead_code)]",
          "187:         unsafe { *self.table_ptr(index) }",
          "188:     }",
          "192:         unsafe {",
          "194:         }",
          "195:     }",
          "200:     }",
          "",
          "[Removed Lines]",
          "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
          "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "[Added Lines]",
          "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
          "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "238:     }",
          "242:         unsafe { &*self.global_ptr(index) }",
          "243:     }",
          "248:     }",
          "",
          "[Removed Lines]",
          "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "[Added Lines]",
          "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "254:     pub(crate) fn defined_or_imported_global_ptr(",
          "256:         index: GlobalIndex,",
          "257:     ) -> *mut VMGlobalDefinition {",
          "258:         if let Some(index) = self.module().defined_global_index(index) {",
          "",
          "[Removed Lines]",
          "255:         &self,",
          "",
          "[Added Lines]",
          "261:         &mut self,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "263:     }",
          "268:     }",
          "273:     }",
          "278:     }",
          "",
          "[Removed Lines]",
          "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
          "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
          "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
          "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
          "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
          "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "[Added Lines]",
          "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
          "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
          "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
          "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
          "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
          "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "402:     }",
          "406:         let index = DefinedTableIndex::new(",
          "407:             usize::try_from(",
          "408:                 (table as *const VMTableDefinition)",
          "",
          "[Removed Lines]",
          "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "[Added Lines]",
          "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "584:             let func = &self.module().functions[index];",
          "585:             let sig = func.signature;",
          "586:             let anyfunc: *mut VMCallerCheckedFuncRef = self",
          "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
          "589:                 );",
          "590:             self.construct_anyfunc(index, sig, anyfunc);",
          "",
          "[Removed Lines]",
          "587:                 .vmctx_plus_offset::<VMCallerCheckedFuncRef>(",
          "",
          "[Added Lines]",
          "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "923:     ) {",
          "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
          "927:         self.set_callee(None);",
          "928:         self.set_store(store.as_raw());",
          "931:         let signatures = self.runtime_info.signature_ids();",
          "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
          "939:         ptr::copy_nonoverlapping(",
          "940:             imports.functions.as_ptr(),",
          "942:             imports.functions.len(),",
          "943:         );",
          "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
          "945:         ptr::copy_nonoverlapping(",
          "946:             imports.tables.as_ptr(),",
          "948:             imports.tables.len(),",
          "949:         );",
          "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
          "951:         ptr::copy_nonoverlapping(",
          "952:             imports.memories.as_ptr(),",
          "954:             imports.memories.len(),",
          "955:         );",
          "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
          "957:         ptr::copy_nonoverlapping(",
          "958:             imports.globals.as_ptr(),",
          "960:             imports.globals.len(),",
          "961:         );",
          "",
          "[Removed Lines]",
          "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
          "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
          "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
          "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
          "",
          "[Added Lines]",
          "942:             &VMBuiltinFunctionsArray::INIT;",
          "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
          "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
          "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
          "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
          "973:             ptr = ptr.add(1);",
          "",
          "[Removed Lines]",
          "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
          "",
          "[Added Lines]",
          "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
          "985:             let memory_index = module.memory_index(defined_memory_index);",
          "",
          "[Removed Lines]",
          "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
          "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
          "",
          "[Added Lines]",
          "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
          "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1068: impl Drop for Instance {",
          "1069:     fn drop(&mut self) {",
          "1073:                 Some(idx) => idx,",
          "1074:                 None => continue,",
          "1075:             };",
          "",
          "[Removed Lines]",
          "1071:         for (idx, global) in self.module().globals.iter() {",
          "1072:             let idx = match self.module().defined_global_index(idx) {",
          "",
          "[Added Lines]",
          "1078:         let module = self.module().clone();",
          "1079:         for (idx, global) in module.globals.iter() {",
          "1080:             let idx = match module.defined_global_index(idx) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1182:     }",
          "1187:     }",
          "",
          "[Removed Lines]",
          "1185:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1186:         self.instance().table_index(table)",
          "",
          "[Added Lines]",
          "1193:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1194:         self.instance_mut().table_index(table)",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "200:     fn purge_module(&self, module: CompiledModuleId);",
          "201: }",
          "204:     match init.base {",
          "205:         Some(base) => {",
          "214:             init.offset",
          "215:                 .checked_add(val)",
          "",
          "[Removed Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
          "206:             let val = unsafe {",
          "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
          "209:                 } else {",
          "211:                 }",
          "212:             };",
          "",
          "[Added Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
          "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:         TableInitialization::FuncTable { segments, .. }",
          "257:         | TableInitialization::Segments { segments } => {",
          "258:             for segment in segments {",
          "259:                 instance.table_init_segment(",
          "260:                     segment.table_index,",
          "261:                     &segment.elements,",
          "263:                     0,",
          "264:                     segment.elements.len() as u32,",
          "265:                 )?;",
          "",
          "[Removed Lines]",
          "262:                     get_table_init_start(segment, instance)?,",
          "",
          "[Added Lines]",
          "253:                 let start = get_table_init_start(segment, instance)?;",
          "257:                     start,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "270:     Ok(())",
          "271: }",
          "274:     match init.base {",
          "275:         Some(base) => {",
          "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
          "277:                 .memory",
          "278:                 .memory64;",
          "279:             let val = unsafe {",
          "285:                 if mem64 {",
          "287:                 } else {",
          "289:                 }",
          "290:             };",
          "",
          "[Removed Lines]",
          "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
          "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
          "281:                     instance.global(def_index)",
          "282:                 } else {",
          "283:                     &*instance.imported_global(base).from",
          "284:                 };",
          "288:                     u64::from(*global.as_u32())",
          "",
          "[Added Lines]",
          "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
          "275:                 let global = instance.defined_or_imported_global_ptr(base);",
          "279:                     u64::from(*(*global).as_u32())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "297:     }",
          "298: }",
          "301:     for init in initializers {",
          "302:         let memory = instance.get_memory(init.memory_index);",
          "303:         let start = get_memory_init_start(init, instance)?;",
          "",
          "[Removed Lines]",
          "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
          "",
          "[Added Lines]",
          "291: fn check_memory_init_bounds(",
          "292:     instance: &mut Instance,",
          "293:     initializers: &[MemoryInitializer],",
          "294: ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319: }",
          "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
          "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
          "335:         } else {",
          "337:         }",
          "338:     };",
          "",
          "[Removed Lines]",
          "322:     let memory_size_in_pages =",
          "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
          "327:     let get_global_as_u64 = &|global| unsafe {",
          "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
          "329:             instance.global(def_index)",
          "330:         } else {",
          "331:             &*instance.imported_global(global).from",
          "332:         };",
          "336:             u64::from(*def.as_u32())",
          "",
          "[Added Lines]",
          "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
          "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
          "318:     };",
          "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
          "323:         let def = instance.defined_or_imported_global_ptr(global);",
          "327:             u64::from(*(*def).as_u32())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "348:     let ok = module.memory_initialization.init_memory(",
          "349:         InitMemory::Runtime {",
          "350:             memory_size_in_pages,",
          "351:             get_global_as_u64,",
          "352:         },",
          "",
          "[Removed Lines]",
          "353:         &mut |memory_index, init| {",
          "",
          "[Added Lines]",
          "340:         instance,",
          "345:         |instance, memory_index, init| {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
          "384:     check_table_init_bounds(instance, module)?;",
          "387:         MemoryInitialization::Segmented(initializers) => {",
          "388:             check_memory_init_bounds(instance, initializers)?;",
          "389:         }",
          "",
          "[Removed Lines]",
          "386:     match &instance.module().memory_initialization {",
          "",
          "[Added Lines]",
          "378:     match &module.memory_initialization {",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
          "414:     let index = GlobalIndex::from_u32(index);",
          "416:     let global = instance.defined_or_imported_global_ptr(index);",
          "417:     match (*global).as_externref().clone() {",
          "418:         None => ptr::null_mut(),",
          "",
          "[Removed Lines]",
          "415:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "415:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "435:     };",
          "437:     let index = GlobalIndex::from_u32(index);",
          "439:     let global = instance.defined_or_imported_global_ptr(index);",
          "",
          "[Removed Lines]",
          "438:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "438:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "219: where",
          "220:     F: FnMut(*mut VMContext),",
          "221: {",
          "224:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
          "225:         wasmtime_setjmp(",
          "",
          "[Removed Lines]",
          "222:     let limits = (*caller).instance().runtime_limits();",
          "",
          "[Added Lines]",
          "222:     let limits = (*caller).instance_mut().runtime_limits();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "589e9a810ec7c985cf4fea3c9c59b89f66712c56",
      "candidate_info": {
        "commit_hash": "589e9a810ec7c985cf4fea3c9c59b89f66712c56",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/589e9a810ec7c985cf4fea3c9c59b89f66712c56",
        "files": [
          "RELEASES.md",
          "crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs"
        ],
        "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix release date\n\n* Fix another release date",
        "before_after_code_files": [
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:         }",
          "242:         let mut idx = 0;",
          "243:         let ok = self.module.memory_initialization.init_memory(",
          "244:             InitMemory::CompileTime(&self.module),",
          "",
          "[Removed Lines]",
          "245:             &mut |memory, init| {",
          "",
          "[Added Lines]",
          "244:             &mut (),",
          "246:             |(), memory, init| {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:         &self,",
          "532:     ) -> bool {",
          "533:         let initializers = match self {",
          "",
          "[Removed Lines]",
          "528:     pub fn init_memory(",
          "530:         state: InitMemory<'_>,",
          "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "[Added Lines]",
          "529:     pub fn init_memory<T>(",
          "531:         state: &mut T,",
          "532:         init: InitMemory<'_, T>,",
          "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "543:             MemoryInitialization::Static { map } => {",
          "544:                 for (index, init) in map {",
          "545:                     if let Some(init) = init {",
          "547:                         if !result {",
          "548:                             return result;",
          "549:                         }",
          "",
          "[Removed Lines]",
          "546:                         let result = write(index, init);",
          "",
          "[Added Lines]",
          "548:                         let result = write(state, index, init);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "569:             let base = match base {",
          "571:                     InitMemory::Runtime {",
          "572:                         get_global_as_u64, ..",
          "574:                     InitMemory::CompileTime(_) => return false,",
          "575:                 },",
          "576:                 None => 0,",
          "",
          "[Removed Lines]",
          "570:                 Some(index) => match &state {",
          "573:                     } => get_global_as_u64(index),",
          "",
          "[Added Lines]",
          "572:                 Some(index) => match &init {",
          "575:                     } => get_global_as_u64(state, index),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "585:                 None => return false,",
          "586:             };",
          "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
          "590:                 InitMemory::Runtime {",
          "591:                     memory_size_in_pages,",
          "592:                     ..",
          "594:             };",
          "",
          "[Removed Lines]",
          "588:             let cur_size_in_pages = match &state {",
          "593:                 } => memory_size_in_pages(memory_index),",
          "",
          "[Added Lines]",
          "590:             let cur_size_in_pages = match &init {",
          "595:                 } => memory_size_in_pages(state, memory_index),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "616:                 offset: start,",
          "617:                 data: data.clone(),",
          "618:             };",
          "620:             if !result {",
          "621:                 return result;",
          "622:             }",
          "",
          "[Removed Lines]",
          "619:             let result = write(memory_index, &init);",
          "",
          "[Added Lines]",
          "621:             let result = write(state, memory_index, &init);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "631: pub enum InitMemory<'a> {",
          "",
          "[Added Lines]",
          "633: pub enum InitMemory<'a, T> {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "641:     Runtime {",
          "647:     },",
          "648: }",
          "",
          "[Removed Lines]",
          "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
          "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
          "",
          "[Added Lines]",
          "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
          "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "",
          "[Removed Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
          "151:         (self.vmctx_ptr().cast::<u8>())",
          "",
          "[Added Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
          "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
          "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185:     #[allow(dead_code)]",
          "187:         unsafe { *self.table_ptr(index) }",
          "188:     }",
          "192:         unsafe {",
          "194:         }",
          "195:     }",
          "200:     }",
          "",
          "[Removed Lines]",
          "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
          "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "[Added Lines]",
          "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
          "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "238:     }",
          "242:         unsafe { &*self.global_ptr(index) }",
          "243:     }",
          "248:     }",
          "",
          "[Removed Lines]",
          "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "[Added Lines]",
          "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "254:     pub(crate) fn defined_or_imported_global_ptr(",
          "256:         index: GlobalIndex,",
          "257:     ) -> *mut VMGlobalDefinition {",
          "258:         if let Some(index) = self.module().defined_global_index(index) {",
          "",
          "[Removed Lines]",
          "255:         &self,",
          "",
          "[Added Lines]",
          "261:         &mut self,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "263:     }",
          "268:     }",
          "273:     }",
          "278:     }",
          "",
          "[Removed Lines]",
          "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
          "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
          "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
          "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
          "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
          "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "[Added Lines]",
          "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
          "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
          "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
          "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
          "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
          "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "402:     }",
          "406:         let index = DefinedTableIndex::new(",
          "407:             usize::try_from(",
          "408:                 (table as *const VMTableDefinition)",
          "",
          "[Removed Lines]",
          "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "[Added Lines]",
          "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "584:             let func = &self.module().functions[index];",
          "585:             let sig = func.signature;",
          "586:             let anyfunc: *mut VMCallerCheckedFuncRef = self",
          "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
          "589:                 );",
          "590:             self.construct_anyfunc(index, sig, anyfunc);",
          "",
          "[Removed Lines]",
          "587:                 .vmctx_plus_offset::<VMCallerCheckedFuncRef>(",
          "",
          "[Added Lines]",
          "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "923:     ) {",
          "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
          "927:         self.set_callee(None);",
          "928:         self.set_store(store.as_raw());",
          "931:         let signatures = self.runtime_info.signature_ids();",
          "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
          "939:         ptr::copy_nonoverlapping(",
          "940:             imports.functions.as_ptr(),",
          "942:             imports.functions.len(),",
          "943:         );",
          "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
          "945:         ptr::copy_nonoverlapping(",
          "946:             imports.tables.as_ptr(),",
          "948:             imports.tables.len(),",
          "949:         );",
          "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
          "951:         ptr::copy_nonoverlapping(",
          "952:             imports.memories.as_ptr(),",
          "954:             imports.memories.len(),",
          "955:         );",
          "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
          "957:         ptr::copy_nonoverlapping(",
          "958:             imports.globals.as_ptr(),",
          "960:             imports.globals.len(),",
          "961:         );",
          "",
          "[Removed Lines]",
          "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
          "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
          "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
          "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
          "",
          "[Added Lines]",
          "942:             &VMBuiltinFunctionsArray::INIT;",
          "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
          "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
          "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
          "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
          "973:             ptr = ptr.add(1);",
          "",
          "[Removed Lines]",
          "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
          "",
          "[Added Lines]",
          "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
          "985:             let memory_index = module.memory_index(defined_memory_index);",
          "",
          "[Removed Lines]",
          "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
          "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
          "",
          "[Added Lines]",
          "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
          "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1051: impl Drop for Instance {",
          "1052:     fn drop(&mut self) {",
          "1056:                 Some(idx) => idx,",
          "1057:                 None => continue,",
          "1058:             };",
          "",
          "[Removed Lines]",
          "1054:         for (idx, global) in self.module().globals.iter() {",
          "1055:             let idx = match self.module().defined_global_index(idx) {",
          "",
          "[Added Lines]",
          "1061:         let module = self.module().clone();",
          "1062:         for (idx, global) in module.globals.iter() {",
          "1063:             let idx = match module.defined_global_index(idx) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1165:     }",
          "1170:     }",
          "",
          "[Removed Lines]",
          "1168:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1169:         self.instance().table_index(table)",
          "",
          "[Added Lines]",
          "1176:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1177:         self.instance_mut().table_index(table)",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "200:     fn purge_module(&self, module: CompiledModuleId);",
          "201: }",
          "204:     match init.base {",
          "205:         Some(base) => {",
          "214:             init.offset",
          "215:                 .checked_add(val)",
          "",
          "[Removed Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
          "206:             let val = unsafe {",
          "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
          "209:                 } else {",
          "211:                 }",
          "212:             };",
          "",
          "[Added Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
          "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:         TableInitialization::FuncTable { segments, .. }",
          "257:         | TableInitialization::Segments { segments } => {",
          "258:             for segment in segments {",
          "259:                 instance.table_init_segment(",
          "260:                     segment.table_index,",
          "261:                     &segment.elements,",
          "263:                     0,",
          "264:                     segment.elements.len() as u32,",
          "265:                 )?;",
          "",
          "[Removed Lines]",
          "262:                     get_table_init_start(segment, instance)?,",
          "",
          "[Added Lines]",
          "253:                 let start = get_table_init_start(segment, instance)?;",
          "257:                     start,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "270:     Ok(())",
          "271: }",
          "274:     match init.base {",
          "275:         Some(base) => {",
          "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
          "277:                 .memory",
          "278:                 .memory64;",
          "279:             let val = unsafe {",
          "285:                 if mem64 {",
          "287:                 } else {",
          "289:                 }",
          "290:             };",
          "",
          "[Removed Lines]",
          "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
          "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
          "281:                     instance.global(def_index)",
          "282:                 } else {",
          "283:                     &*instance.imported_global(base).from",
          "284:                 };",
          "288:                     u64::from(*global.as_u32())",
          "",
          "[Added Lines]",
          "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
          "275:                 let global = instance.defined_or_imported_global_ptr(base);",
          "279:                     u64::from(*(*global).as_u32())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "297:     }",
          "298: }",
          "301:     for init in initializers {",
          "302:         let memory = instance.get_memory(init.memory_index);",
          "303:         let start = get_memory_init_start(init, instance)?;",
          "",
          "[Removed Lines]",
          "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
          "",
          "[Added Lines]",
          "291: fn check_memory_init_bounds(",
          "292:     instance: &mut Instance,",
          "293:     initializers: &[MemoryInitializer],",
          "294: ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319: }",
          "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
          "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
          "335:         } else {",
          "337:         }",
          "338:     };",
          "",
          "[Removed Lines]",
          "322:     let memory_size_in_pages =",
          "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
          "327:     let get_global_as_u64 = &|global| unsafe {",
          "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
          "329:             instance.global(def_index)",
          "330:         } else {",
          "331:             &*instance.imported_global(global).from",
          "332:         };",
          "336:             u64::from(*def.as_u32())",
          "",
          "[Added Lines]",
          "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
          "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
          "318:     };",
          "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
          "323:         let def = instance.defined_or_imported_global_ptr(global);",
          "327:             u64::from(*(*def).as_u32())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "348:     let ok = module.memory_initialization.init_memory(",
          "349:         InitMemory::Runtime {",
          "350:             memory_size_in_pages,",
          "351:             get_global_as_u64,",
          "352:         },",
          "",
          "[Removed Lines]",
          "353:         &mut |memory_index, init| {",
          "",
          "[Added Lines]",
          "340:         instance,",
          "345:         |instance, memory_index, init| {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
          "384:     check_table_init_bounds(instance, module)?;",
          "387:         MemoryInitialization::Segmented(initializers) => {",
          "388:             check_memory_init_bounds(instance, initializers)?;",
          "389:         }",
          "",
          "[Removed Lines]",
          "386:     match &instance.module().memory_initialization {",
          "",
          "[Added Lines]",
          "378:     match &module.memory_initialization {",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
          "414:     let index = GlobalIndex::from_u32(index);",
          "416:     let global = instance.defined_or_imported_global_ptr(index);",
          "417:     match (*global).as_externref().clone() {",
          "418:         None => ptr::null_mut(),",
          "",
          "[Removed Lines]",
          "415:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "415:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "435:     };",
          "437:     let index = GlobalIndex::from_u32(index);",
          "439:     let global = instance.defined_or_imported_global_ptr(index);",
          "",
          "[Removed Lines]",
          "438:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "438:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "203: where",
          "204:     F: FnMut(*mut VMContext),",
          "205: {",
          "208:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
          "209:         wasmtime_setjmp(",
          "",
          "[Removed Lines]",
          "206:     let limits = (*caller).instance().runtime_limits();",
          "",
          "[Added Lines]",
          "206:     let limits = (*caller).instance_mut().runtime_limits();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4b9ce0e579034a9b84ed287da7a2cf3617d61ad2",
      "candidate_info": {
        "commit_hash": "4b9ce0e579034a9b84ed287da7a2cf3617d61ad2",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/4b9ce0e579034a9b84ed287da7a2cf3617d61ad2",
        "files": [
          "RELEASES.md",
          "crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs"
        ],
        "message": "Merge pull request from GHSA-ch89-5g45-qwc7\n\n* Fix miscompile from functions mutating `VMContext`\n\nThis commit fixes a miscompilation in Wasmtime on LLVM 16 where methods\non `Instance` which mutated the state of the internal `VMContext` were\noptimized to not actually mutate the state. The root cause of this issue\nis a change in LLVM which takes advantage of `noalias readonly` pointers\nwhich is how `&self` methods are translated. This means that `Instance`\nmethods which take `&self` but actually mutate the `VMContext` end up\nbeing undefined behavior from LLVM's point of view, meaning that the\nwrites are candidate for removal.\n\nThe fix applied here is intended to be a temporary one while a more\nformal fix, ideally backed by `cargo miri` verification, is implemented\non `main`. The fix here is to change the return value of\n`vmctx_plus_offset` to return `*const T` instead of `*mut T`. This\ncaused lots of portions of the runtime code to stop compiling because\nmutations were indeed happening. To cover these a new\n`vmctx_plus_offset_mut` method was added which notably takes `&mut self`\ninstead of `&self`. This forced all callers which may mutate to reflect\nthe `&mut self` requirement, propagating that outwards.\n\nThis fixes the miscompilation with LLVM 16 in the immediate future and\nshould be at least a meager line of defense against issues like this in\nthe future. This is not a long-term fix, though, since `cargo miri`\nstill does not like what's being done in `Instance` and with\n`VMContext`. That fix is likely to be more invasive, though, so it's\nbeing deferred to later.\n\n* Update release notes\n\n* Fix release date",
        "before_after_code_files": [
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ],
          "candidate": [
            "crates/environ/src/module.rs||crates/environ/src/module.rs",
            "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
            "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
            "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
            "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:         }",
          "242:         let mut idx = 0;",
          "243:         let ok = self.module.memory_initialization.init_memory(",
          "244:             InitMemory::CompileTime(&self.module),",
          "",
          "[Removed Lines]",
          "245:             &mut |memory, init| {",
          "",
          "[Added Lines]",
          "244:             &mut (),",
          "246:             |(), memory, init| {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:         &self,",
          "532:     ) -> bool {",
          "533:         let initializers = match self {",
          "",
          "[Removed Lines]",
          "528:     pub fn init_memory(",
          "530:         state: InitMemory<'_>,",
          "531:         write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "[Added Lines]",
          "529:     pub fn init_memory<T>(",
          "531:         state: &mut T,",
          "532:         init: InitMemory<'_, T>,",
          "533:         mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "543:             MemoryInitialization::Static { map } => {",
          "544:                 for (index, init) in map {",
          "545:                     if let Some(init) = init {",
          "547:                         if !result {",
          "548:                             return result;",
          "549:                         }",
          "",
          "[Removed Lines]",
          "546:                         let result = write(index, init);",
          "",
          "[Added Lines]",
          "548:                         let result = write(state, index, init);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "569:             let base = match base {",
          "571:                     InitMemory::Runtime {",
          "572:                         get_global_as_u64, ..",
          "574:                     InitMemory::CompileTime(_) => return false,",
          "575:                 },",
          "576:                 None => 0,",
          "",
          "[Removed Lines]",
          "570:                 Some(index) => match &state {",
          "573:                     } => get_global_as_u64(index),",
          "",
          "[Added Lines]",
          "572:                 Some(index) => match &init {",
          "575:                     } => get_global_as_u64(state, index),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "585:                 None => return false,",
          "586:             };",
          "589:                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,",
          "590:                 InitMemory::Runtime {",
          "591:                     memory_size_in_pages,",
          "592:                     ..",
          "594:             };",
          "",
          "[Removed Lines]",
          "588:             let cur_size_in_pages = match &state {",
          "593:                 } => memory_size_in_pages(memory_index),",
          "",
          "[Added Lines]",
          "590:             let cur_size_in_pages = match &init {",
          "595:                 } => memory_size_in_pages(state, memory_index),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "616:                 offset: start,",
          "617:                 data: data.clone(),",
          "618:             };",
          "620:             if !result {",
          "621:                 return result;",
          "622:             }",
          "",
          "[Removed Lines]",
          "619:             let result = write(memory_index, &init);",
          "",
          "[Added Lines]",
          "621:             let result = write(state, memory_index, &init);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "631: pub enum InitMemory<'a> {",
          "",
          "[Added Lines]",
          "633: pub enum InitMemory<'a, T> {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "641:     Runtime {",
          "647:     },",
          "648: }",
          "",
          "[Removed Lines]",
          "643:         memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,",
          "646:         get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,",
          "",
          "[Added Lines]",
          "645:         memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,",
          "648:         get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "",
          "[Removed Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
          "151:         (self.vmctx_ptr().cast::<u8>())",
          "",
          "[Added Lines]",
          "150:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {",
          "151:         (std::ptr::addr_of!(self.vmctx).cast::<u8>())",
          "152:             .add(usize::try_from(offset).unwrap())",
          "153:             .cast()",
          "154:     }",
          "156:     unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {",
          "157:         (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185:     #[allow(dead_code)]",
          "187:         unsafe { *self.table_ptr(index) }",
          "188:     }",
          "192:         unsafe {",
          "194:         }",
          "195:     }",
          "200:     }",
          "",
          "[Removed Lines]",
          "186:     fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {",
          "191:     fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "198:     fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "199:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "[Added Lines]",
          "192:     fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {",
          "197:     fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {",
          "204:     fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {",
          "205:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "238:     }",
          "242:         unsafe { &*self.global_ptr(index) }",
          "243:     }",
          "248:     }",
          "",
          "[Removed Lines]",
          "241:     fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "246:     fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "247:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "[Added Lines]",
          "247:     fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {",
          "252:     fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {",
          "253:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "254:     pub(crate) fn defined_or_imported_global_ptr(",
          "256:         index: GlobalIndex,",
          "257:     ) -> *mut VMGlobalDefinition {",
          "258:         if let Some(index) = self.module().defined_global_index(index) {",
          "",
          "[Removed Lines]",
          "255:         &self,",
          "",
          "[Added Lines]",
          "261:         &mut self,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "263:     }",
          "268:     }",
          "273:     }",
          "278:     }",
          "",
          "[Removed Lines]",
          "266:     pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {",
          "267:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }",
          "271:     pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {",
          "272:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }",
          "276:     pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {",
          "277:         unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "[Added Lines]",
          "272:     pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {",
          "273:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }",
          "277:     pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {",
          "278:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }",
          "282:     pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {",
          "283:         unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "402:     }",
          "406:         let index = DefinedTableIndex::new(",
          "407:             usize::try_from(",
          "408:                 (table as *const VMTableDefinition)",
          "",
          "[Removed Lines]",
          "405:     unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "[Added Lines]",
          "411:     unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "584:             let func = &self.module().functions[index];",
          "585:             let sig = func.signature;",
          "586:             let anyfunc: *mut VMCallerCheckedAnyfunc = self",
          "588:                     self.offsets().vmctx_anyfunc(func.anyfunc),",
          "589:                 );",
          "590:             self.construct_anyfunc(index, sig, anyfunc);",
          "",
          "[Removed Lines]",
          "587:                 .vmctx_plus_offset::<VMCallerCheckedAnyfunc>(",
          "",
          "[Added Lines]",
          "593:                 .vmctx_plus_offset_mut::<VMCallerCheckedAnyfunc>(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "923:     ) {",
          "924:         assert!(std::ptr::eq(module, self.module().as_ref()));",
          "927:         self.set_callee(None);",
          "928:         self.set_store(store.as_raw());",
          "931:         let signatures = self.runtime_info.signature_ids();",
          "938:         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);",
          "939:         ptr::copy_nonoverlapping(",
          "940:             imports.functions.as_ptr(),",
          "942:             imports.functions.len(),",
          "943:         );",
          "944:         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);",
          "945:         ptr::copy_nonoverlapping(",
          "946:             imports.tables.as_ptr(),",
          "948:             imports.tables.len(),",
          "949:         );",
          "950:         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);",
          "951:         ptr::copy_nonoverlapping(",
          "952:             imports.memories.as_ptr(),",
          "954:             imports.memories.len(),",
          "955:         );",
          "956:         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);",
          "957:         ptr::copy_nonoverlapping(",
          "958:             imports.globals.as_ptr(),",
          "960:             imports.globals.len(),",
          "961:         );",
          "",
          "[Removed Lines]",
          "941:             self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),",
          "947:             self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),",
          "953:             self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),",
          "959:             self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),",
          "",
          "[Added Lines]",
          "942:             &VMBuiltinFunctionsArray::INIT;",
          "948:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),",
          "954:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),",
          "960:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),",
          "966:             self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "971:         for i in 0..module.table_plans.len() - module.num_imported_tables {",
          "972:             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());",
          "973:             ptr = ptr.add(1);",
          "",
          "[Removed Lines]",
          "970:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());",
          "",
          "[Added Lines]",
          "977:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "983:         for i in 0..module.memory_plans.len() - module.num_imported_memories {",
          "984:             let defined_memory_index = DefinedMemoryIndex::new(i);",
          "985:             let memory_index = module.memory_index(defined_memory_index);",
          "",
          "[Removed Lines]",
          "981:         let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());",
          "982:         let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());",
          "",
          "[Added Lines]",
          "988:         let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());",
          "989:         let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1051: impl Drop for Instance {",
          "1052:     fn drop(&mut self) {",
          "1056:                 Some(idx) => idx,",
          "1057:                 None => continue,",
          "1058:             };",
          "",
          "[Removed Lines]",
          "1054:         for (idx, global) in self.module().globals.iter() {",
          "1055:             let idx = match self.module().defined_global_index(idx) {",
          "",
          "[Added Lines]",
          "1061:         let module = self.module().clone();",
          "1062:         for (idx, global) in module.globals.iter() {",
          "1063:             let idx = match module.defined_global_index(idx) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1165:     }",
          "1170:     }",
          "",
          "[Removed Lines]",
          "1168:     pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1169:         self.instance().table_index(table)",
          "",
          "[Added Lines]",
          "1176:     pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {",
          "1177:         self.instance_mut().table_index(table)",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "200:     fn purge_module(&self, module: CompiledModuleId);",
          "201: }",
          "204:     match init.base {",
          "205:         Some(base) => {",
          "214:             init.offset",
          "215:                 .checked_add(val)",
          "",
          "[Removed Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {",
          "206:             let val = unsafe {",
          "207:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
          "209:                 } else {",
          "211:                 }",
          "212:             };",
          "",
          "[Added Lines]",
          "203: fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {",
          "206:             let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "256:         TableInitialization::FuncTable { segments, .. }",
          "257:         | TableInitialization::Segments { segments } => {",
          "258:             for segment in segments {",
          "259:                 instance.table_init_segment(",
          "260:                     segment.table_index,",
          "261:                     &segment.elements,",
          "263:                     0,",
          "264:                     segment.elements.len() as u32,",
          "265:                 )?;",
          "",
          "[Removed Lines]",
          "262:                     get_table_init_start(segment, instance)?,",
          "",
          "[Added Lines]",
          "253:                 let start = get_table_init_start(segment, instance)?;",
          "257:                     start,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "270:     Ok(())",
          "271: }",
          "274:     match init.base {",
          "275:         Some(base) => {",
          "276:             let mem64 = instance.module().memory_plans[init.memory_index]",
          "277:                 .memory",
          "278:                 .memory64;",
          "279:             let val = unsafe {",
          "285:                 if mem64 {",
          "287:                 } else {",
          "289:                 }",
          "290:             };",
          "",
          "[Removed Lines]",
          "273: fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {",
          "280:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
          "281:                     instance.global(def_index)",
          "282:                 } else {",
          "283:                     &*instance.imported_global(base).from",
          "284:                 };",
          "288:                     u64::from(*global.as_u32())",
          "",
          "[Added Lines]",
          "268: fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {",
          "275:                 let global = instance.defined_or_imported_global_ptr(base);",
          "279:                     u64::from(*(*global).as_u32())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "297:     }",
          "298: }",
          "301:     for init in initializers {",
          "302:         let memory = instance.get_memory(init.memory_index);",
          "303:         let start = get_memory_init_start(init, instance)?;",
          "",
          "[Removed Lines]",
          "300: fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {",
          "",
          "[Added Lines]",
          "291: fn check_memory_init_bounds(",
          "292:     instance: &mut Instance,",
          "293:     initializers: &[MemoryInitializer],",
          "294: ) -> Result<()> {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319: }",
          "321: fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {",
          "333:         if module.globals[global].wasm_ty == WasmType::I64 {",
          "335:         } else {",
          "337:         }",
          "338:     };",
          "",
          "[Removed Lines]",
          "322:     let memory_size_in_pages =",
          "323:         &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);",
          "327:     let get_global_as_u64 = &|global| unsafe {",
          "328:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
          "329:             instance.global(def_index)",
          "330:         } else {",
          "331:             &*instance.imported_global(global).from",
          "332:         };",
          "336:             u64::from(*def.as_u32())",
          "",
          "[Added Lines]",
          "316:     let memory_size_in_pages = &|instance: &mut Instance, memory| {",
          "317:         (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)",
          "318:     };",
          "322:     let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {",
          "323:         let def = instance.defined_or_imported_global_ptr(global);",
          "327:             u64::from(*(*def).as_u32())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "348:     let ok = module.memory_initialization.init_memory(",
          "349:         InitMemory::Runtime {",
          "350:             memory_size_in_pages,",
          "351:             get_global_as_u64,",
          "352:         },",
          "",
          "[Removed Lines]",
          "353:         &mut |memory_index, init| {",
          "",
          "[Added Lines]",
          "340:         instance,",
          "345:         |instance, memory_index, init| {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "383: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {",
          "384:     check_table_init_bounds(instance, module)?;",
          "387:         MemoryInitialization::Segmented(initializers) => {",
          "388:             check_memory_init_bounds(instance, initializers)?;",
          "389:         }",
          "",
          "[Removed Lines]",
          "386:     match &instance.module().memory_initialization {",
          "",
          "[Added Lines]",
          "378:     match &module.memory_initialization {",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {",
          "414:     let index = GlobalIndex::from_u32(index);",
          "416:     let global = instance.defined_or_imported_global_ptr(index);",
          "417:     match (*global).as_externref().clone() {",
          "418:         None => ptr::null_mut(),",
          "",
          "[Removed Lines]",
          "415:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "415:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "435:     };",
          "437:     let index = GlobalIndex::from_u32(index);",
          "439:     let global = instance.defined_or_imported_global_ptr(index);",
          "",
          "[Removed Lines]",
          "438:     let instance = (*vmctx).instance();",
          "",
          "[Added Lines]",
          "438:     let instance = (*vmctx).instance_mut();",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers.rs||crates/runtime/src/traphandlers.rs": [
          "File: crates/runtime/src/traphandlers.rs -> crates/runtime/src/traphandlers.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "203: where",
          "204:     F: FnMut(*mut VMContext),",
          "205: {",
          "208:     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {",
          "209:         wasmtime_setjmp(",
          "",
          "[Removed Lines]",
          "206:     let limits = (*caller).instance().runtime_limits();",
          "",
          "[Added Lines]",
          "206:     let limits = (*caller).instance_mut().runtime_limits();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
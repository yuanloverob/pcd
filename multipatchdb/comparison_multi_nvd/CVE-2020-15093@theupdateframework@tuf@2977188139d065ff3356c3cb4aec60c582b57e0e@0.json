{
  "cve_id": "CVE-2020-15093",
  "cve_desc": "The tough library (Rust/crates.io) prior to version 0.7.1 does not properly verify the threshold of cryptographic signatures. It allows an attacker to duplicate a valid signature in order to circumvent TUF requiring a minimum threshold of unique signatures before the metadata is considered valid. A fix is available in version 0.7.1. CVE-2020-6174 is assigned to the same vulnerability in the TUF reference implementation.",
  "repo": "theupdateframework/tuf",
  "patch_hash": "2977188139d065ff3356c3cb4aec60c582b57e0e",
  "patch_info": {
    "commit_hash": "2977188139d065ff3356c3cb4aec60c582b57e0e",
    "repo": "theupdateframework/tuf",
    "commit_url": "https://github.com/theupdateframework/tuf/commit/2977188139d065ff3356c3cb4aec60c582b57e0e",
    "files": [
      "tests/test_sig.py",
      "tests/test_updater.py",
      "tuf/sig.py"
    ],
    "message": "Merge pull request #974 from lukpueh/fix-signature-threshold\n\nFix signature threshold",
    "before_after_code_files": [
      "tests/test_sig.py||tests/test_sig.py",
      "tests/test_updater.py||tests/test_updater.py",
      "tuf/sig.py||tuf/sig.py"
    ]
  },
  "patch_diff": {
    "tests/test_sig.py||tests/test_sig.py": [
      "File: tests/test_sig.py -> tests/test_sig.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: import unittest",
      "33: import logging",
      "35: import tuf",
      "36: import tuf.log",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: import copy",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "384:     tuf.roledb.remove_role('Root')",
      "387:   def test_verify_unrecognized_sig(self):",
      "388:     signable = {'signed' : 'test', 'signatures' : []}",
      "389:     signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
      "390:     # Create and sign dummy metadata twice with same key",
      "391:     # Note that we use the non-deterministic rsassa-pss signing scheme, so",
      "392:     # creating the signature twice shows that we don't only detect duplicate",
      "393:     # signatures but also different signatures from the same key.",
      "394:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
      "395:     signed = securesystemslib.formats.encode_canonical(",
      "396:         signable[\"signed\"]).encode(\"utf-8\")",
      "397:     signable[\"signatures\"].append(",
      "398:         securesystemslib.keys.create_signature(KEYS[0], signed))",
      "399:     signable[\"signatures\"].append(",
      "400:         securesystemslib.keys.create_signature(KEYS[0], signed))",
      "402:     # 'get_signature_status' uses keys from keydb for verification",
      "403:     tuf.keydb.add_key(KEYS[0])",
      "405:     # Assert that 'get_signature_status' returns two good signatures ...",
      "406:     status = tuf.sig.get_signature_status(",
      "407:         signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2)",
      "408:     self.assertTrue(len(status[\"good_sigs\"]) == 2)",
      "410:     # ... but only one counts towards the threshold",
      "411:     self.assertFalse(",
      "412:         tuf.sig.verify(signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2))",
      "414:     # Clean-up keydb",
      "415:     tuf.keydb.remove_key(KEYS[0][\"keyid\"])",
      "419:   def test_verify_count_different_keyids_for_same_key_towards_threshold(self):",
      "420:     # Create and sign dummy metadata twice with same key but different keyids",
      "421:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
      "422:     key_sha256 = copy.deepcopy(KEYS[0])",
      "423:     key_sha256[\"keyid\"] = \"deadbeef256\"",
      "425:     key_sha512 = copy.deepcopy(KEYS[0])",
      "426:     key_sha512[\"keyid\"] = \"deadbeef512\"",
      "428:     signed = securesystemslib.formats.encode_canonical(",
      "429:         signable[\"signed\"]).encode(\"utf-8\")",
      "430:     signable[\"signatures\"].append(",
      "431:         securesystemslib.keys.create_signature(key_sha256, signed))",
      "432:     signable[\"signatures\"].append(",
      "433:         securesystemslib.keys.create_signature(key_sha512, signed))",
      "435:     # 'get_signature_status' uses keys from keydb for verification",
      "436:     tuf.keydb.add_key(key_sha256)",
      "437:     tuf.keydb.add_key(key_sha512)",
      "439:     # Assert that both keys count towards threshold although its the same key",
      "440:     keyids = [key_sha256[\"keyid\"], key_sha512[\"keyid\"]]",
      "441:     self.assertTrue(",
      "442:         tuf.sig.verify(signable, \"root\", keyids=keyids, threshold=2))",
      "444:     # Clean-up keydb",
      "445:     tuf.keydb.remove_key(key_sha256[\"keyid\"])",
      "446:     tuf.keydb.remove_key(key_sha512[\"keyid\"])",
      "",
      "---------------"
    ],
    "tests/test_updater.py||tests/test_updater.py": [
      "File: tests/test_updater.py -> tests/test_updater.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "429:   def test_1__update_fileinfo(self):",
      "430:       # Tests",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:   def test_1__refresh_must_not_count_duplicate_keyids_towards_threshold(self):",
      "429:     # Update root threshold on the server repository and sign twice with 1 key",
      "430:     repository = repo_tool.load_repository(self.repository_directory)",
      "431:     repository.root.threshold = 2",
      "432:     repository.root.load_signing_key(self.role_keys['root']['private'])",
      "434:     # The client uses the threshold from the previous root file to verify the",
      "435:     # new root. Thus we need to make two updates so that the threshold used for",
      "436:     # verification becomes 2. I.e. we bump the version, sign twice with the",
      "437:     # same key and write to disk '2.root.json' and '3.root.json'.",
      "438:     for version in [2, 3]:",
      "439:       repository.root.version = version",
      "440:       info = tuf.roledb.get_roleinfo(\"root\")",
      "441:       metadata = repo_lib.generate_root_metadata(",
      "442:           info[\"version\"], info[\"expires\"], False)",
      "443:       signed_metadata = repo_lib.sign_metadata(",
      "444:           metadata, info[\"keyids\"], \"root.json\", \"default\")",
      "445:       signed_metadata[\"signatures\"].append(signed_metadata[\"signatures\"][0])",
      "446:       live_root_path = os.path.join(",
      "447:           self.repository_directory, \"metadata\", \"root.json\")",
      "449:       # Bypass server side verification in 'write' or 'writeall', which would",
      "450:       # catch the unmet threshold.",
      "451:       # We also skip writing to 'metadata.staged' and copying to 'metadata' and",
      "452:       # instead write directly to 'metadata'",
      "453:       repo_lib.write_metadata_file(signed_metadata, live_root_path, info[\"version\"], True)",
      "456:     # Update from current '1.root.json' to '3.root.json' on client and assert",
      "457:     # raise of 'BadSignatureError' (caused by unmet signature threshold).",
      "458:     try:",
      "459:       self.repository_updater.refresh()",
      "461:     except tuf.exceptions.NoWorkingMirrorError as e:",
      "462:       mirror_errors = list(e.mirror_errors.values())",
      "463:       self.assertTrue(len(mirror_errors) == 1)",
      "464:       self.assertTrue(",
      "465:           isinstance(mirror_errors[0],",
      "466:           securesystemslib.exceptions.BadSignatureError))",
      "467:       self.assertEqual(",
      "468:           str(mirror_errors[0]),",
      "469:           repr(\"root\") + \" metadata has bad signature.\")",
      "471:     else:",
      "472:       self.fail(",
      "473:           \"Expected a NoWorkingMirrorError composed of one BadSignatureError\")",
      "",
      "---------------"
    ],
    "tuf/sig.py||tuf/sig.py": [
      "File: tuf/sig.py -> tuf/sig.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "71:   \"\"\"",
      "72:   <Purpose>",
      "73:     Return a dictionary representing the status of the signatures listed in",
      "80:   <Arguments>",
      "81:     signable:",
      "",
      "[Removed Lines]",
      "74:     'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
      "75:     keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,",
      "76:     the status of these signatures can be determined.  This method will iterate",
      "77:     the signatures in 'signable' and enumerate all the keys that are valid,",
      "78:     invalid, unrecognized, or unauthorized.",
      "",
      "[Added Lines]",
      "74:     'signable'. Signatures in the returned dictionary are identified by the",
      "75:     signature keyid and can have a status of either:",
      "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
      "80:       overwritten by passed 'keyids').",
      "82:       'role' is None.",
      "84:       scheme.",
      "86:       but is not trusted for the passed role as per 'tuf.roledb' or the passed",
      "87:       'keyids'.",
      "89:     NOTE: The result may contain duplicate keyids or keyids that reference the",
      "90:     same key, if 'signable' lists multiple signatures from the same key.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:       Conformant to tuf.formats.SIGNABLE_SCHEMA.",
      "89:     role:",
      "92:     threshold:",
      "93:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
      "",
      "[Removed Lines]",
      "90:       TUF role (e.g., 'root', 'targets', 'snapshot').",
      "",
      "[Added Lines]",
      "102:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "134:   # The signature status dictionary returned.",
      "135:   signature_status = {}",
      "152:   good_sigs = []",
      "153:   bad_sigs = []",
      "154:   unknown_sigs = []",
      "",
      "[Removed Lines]",
      "137:   # The fields of the signature_status dict, where each field stores keyids.  A",
      "138:   # description of each field:",
      "139:   #",
      "140:   # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
      "141:   # associated with 'role';",
      "142:   #",
      "143:   # bad_sigs = negation of good_sigs;",
      "144:   #",
      "145:   # unknown_sigs = keys not found in the 'keydb' database;",
      "146:   #",
      "147:   # untrusted_sigs = keys that are not in the list of keyids associated with",
      "148:   # 'role';",
      "149:   #",
      "150:   # unknown_signing_scheme = signing schemes specified in keys that are",
      "151:   # unsupported;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "240:     keyids=None):",
      "241:   \"\"\"",
      "242:   <Purpose>",
      "248:   <Arguments>",
      "249:     signable:",
      "251:       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
      "253:     role:",
      "256:     threshold:",
      "257:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
      "",
      "[Removed Lines]",
      "243:     Verify whether the authorized signatures of 'signable' meet the minimum",
      "244:     required by 'role'.  Authorized signatures are those with valid keys",
      "245:     associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
      "246:     and 'role' must not equal 'None' or be less than zero.",
      "250:       A dictionary containing a list of signatures and a 'signed' identifier.",
      "254:       TUF role (e.g., 'root', 'targets', 'snapshot').",
      "",
      "[Added Lines]",
      "239:     Verify that 'signable' has a valid threshold of authorized signatures",
      "240:     identified by unique keyids. The threshold and whether a keyid is",
      "241:     authorized is determined by querying the 'threshold' and 'keyids' info for",
      "242:     the passed 'role' in 'tuf.roledb'. Both values can be overwritten by",
      "243:     passing the 'threshold' or 'keyids' arguments.",
      "245:     NOTE:",
      "246:     - Signatures with identical authorized keyids only count towards the",
      "247:       threshold once.",
      "248:     - Signatures with different authorized keyids each count towards the",
      "249:       threshold, even if the keyids identify the same key.",
      "253:       A dictionary containing a list of signatures and a 'signed' identifier",
      "254:       that conforms to SIGNABLE_SCHEMA, e.g.:",
      "258:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "278:     get_signature_status() will be caught here and re-raised.",
      "280:   <Returns>",
      "283:   \"\"\"",
      "285:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
      "",
      "[Removed Lines]",
      "281:     Boolean.  True if the number of good signatures >= the role's threshold,",
      "282:     False otherwise.",
      "",
      "[Added Lines]",
      "285:     Boolean.  True if the number of good unique (by keyid) signatures >= the",
      "286:     role's threshold, False otherwise.",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "303:   if threshold is None or threshold <= 0: #pragma: no cover",
      "304:     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
      "",
      "[Removed Lines]",
      "306:   return len(good_sigs) >= threshold",
      "",
      "[Added Lines]",
      "310:   return len(set(good_sigs)) >= threshold",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
      "candidate_info": {
        "commit_hash": "a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
        "repo": "theupdateframework/tuf",
        "commit_url": "https://github.com/theupdateframework/tuf/commit/a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
        "files": [
          "tests/test_sig.py",
          "tests/test_updater.py",
          "tuf/sig.py"
        ],
        "message": "Fix signature threshold verification\n\nPrior to this commit metadadata signature verification as provided\nby `tuf.sig.verify()` and used e.g. in `tuf.client.updater` counted\nmultiple signatures with identical authorized keyids each\nseparately towards the threshold. This behavior practically\nsubverts the signature thresholds check.\n\nThis commit fixes the issue by counting identical authorized keyids\nonly once towards the threshold.\n\nThe commit further clarifies the behavior of the relevant functions\nin the `sig` module, i.e. `get_signature_status` and `verify` in\ntheir respective docstrings. And adds tests for those functions and\nalso for the client updater.\n\n---\n\nNOTE: With this commit signatures with different authorized keyids\nstill each count separately towards the threshold, even if the\nkeyids identify the same key. If this behavior is not desired, I\npropose the following fix instead. It verifies uniqueness of keys\n(and not keyids):\n\n```\ndiff --git a/tuf/sig.py b/tuf/sig.py\nindex ae9bae15..5392e596 100755\n--- a/tuf/sig.py\n+++ b/tuf/sig.py\n@@ -303,7 +303,14 @@ def verify(signable, role, repository_name='default', threshold=None,\n   if threshold is None or threshold <= 0: #pragma: no cover\n     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))\n\n-  return len(good_sigs) >= threshold\n+  # Different keyids might point to the same key\n+  # To be safe, check against unique public key values\n+  unique_good_sig_keys = set()\n+  for keyid in good_sigs:\n+    key = tuf.keydb.get_key(keyid, repository_name)\n+    unique_good_sig_keys.add(key[\"keyval\"][\"public\"])\n+\n+  return len(unique_good_sig_keys) >= threshold\n\n```\n\nSigned-off-by: Lukas Puehringer <lukas.puehringer@nyu.edu>",
        "before_after_code_files": [
          "tests/test_sig.py||tests/test_sig.py",
          "tests/test_updater.py||tests/test_updater.py",
          "tuf/sig.py||tuf/sig.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/theupdateframework/python-tuf/pull/974"
        ],
        "olp_code_files": {
          "patch": [
            "tests/test_sig.py||tests/test_sig.py",
            "tests/test_updater.py||tests/test_updater.py",
            "tuf/sig.py||tuf/sig.py"
          ],
          "candidate": [
            "tests/test_sig.py||tests/test_sig.py",
            "tests/test_updater.py||tests/test_updater.py",
            "tuf/sig.py||tuf/sig.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_sig.py||tests/test_sig.py": [
          "File: tests/test_sig.py -> tests/test_sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: import unittest",
          "33: import logging",
          "35: import tuf",
          "36: import tuf.log",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: import copy",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "384:     tuf.roledb.remove_role('Root')",
          "387:   def test_verify_unrecognized_sig(self):",
          "388:     signable = {'signed' : 'test', 'signatures' : []}",
          "389:     signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
          "390:     # Create and sign dummy metadata twice with same key",
          "391:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "392:     signed = securesystemslib.formats.encode_canonical(",
          "393:         signable[\"signed\"]).encode(\"utf-8\")",
          "394:     signable[\"signatures\"].append(",
          "395:         securesystemslib.keys.create_signature(KEYS[0], signed))",
          "396:     signable[\"signatures\"].append(",
          "397:         securesystemslib.keys.create_signature(KEYS[0], signed))",
          "399:     # 'get_signature_status' uses keys from keydb for verification",
          "400:     tuf.keydb.add_key(KEYS[0])",
          "402:     # Assert that 'get_signature_status' returns two good signatures ...",
          "403:     status = tuf.sig.get_signature_status(",
          "404:         signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2)",
          "405:     self.assertTrue(len(status[\"good_sigs\"]) == 2)",
          "407:     # ... but only one counts towards the threshold",
          "408:     self.assertFalse(",
          "409:         tuf.sig.verify(signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2))",
          "411:     # Clean-up keydb",
          "412:     tuf.keydb.remove_key(KEYS[0][\"keyid\"])",
          "416:   def test_verify_count_different_keyids_for_same_key_towards_threshold(self):",
          "417:     # Create and sign dummy metadata twice with same key but different keyids",
          "418:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "419:     key_sha256 = copy.deepcopy(KEYS[0])",
          "420:     key_sha256[\"keyid\"] = \"deadbeef256\"",
          "422:     key_sha512 = copy.deepcopy(KEYS[0])",
          "423:     key_sha512[\"keyid\"] = \"deadbeef512\"",
          "425:     signed = securesystemslib.formats.encode_canonical(",
          "426:         signable[\"signed\"]).encode(\"utf-8\")",
          "427:     signable[\"signatures\"].append(",
          "428:         securesystemslib.keys.create_signature(key_sha256, signed))",
          "429:     signable[\"signatures\"].append(",
          "430:         securesystemslib.keys.create_signature(key_sha512, signed))",
          "432:     # 'get_signature_status' uses keys from keydb for verification",
          "433:     tuf.keydb.add_key(key_sha256)",
          "434:     tuf.keydb.add_key(key_sha512)",
          "436:     # Assert that both keys count towards threshold although its the same key",
          "437:     keyids = [key_sha256[\"keyid\"], key_sha512[\"keyid\"]]",
          "438:     self.assertTrue(",
          "439:         tuf.sig.verify(signable, \"root\", keyids=keyids, threshold=2))",
          "441:     # Clean-up keydb",
          "442:     tuf.keydb.remove_key(key_sha256[\"keyid\"])",
          "443:     tuf.keydb.remove_key(key_sha512[\"keyid\"])",
          "",
          "---------------"
        ],
        "tests/test_updater.py||tests/test_updater.py": [
          "File: tests/test_updater.py -> tests/test_updater.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:   def test_1__update_fileinfo(self):",
          "430:       # Tests",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428:   def test_1__refresh_must_not_count_duplicate_keyids_towards_threshold(self):",
          "429:     # Update root threshold on the server repository and sign twice with 1 key",
          "430:     repository = repo_tool.load_repository(self.repository_directory)",
          "431:     repository.root.threshold = 2",
          "432:     repository.root.load_signing_key(self.role_keys['root']['private'])",
          "434:     # The client uses the threshold from the previous root file to verify the",
          "435:     # new root. Thus we need to make two updates so that the threshold used for",
          "436:     # verification becomes 2. I.e. we bump the version, sign twice with the",
          "437:     # same key and write to disk '2.root.json' and '3.root.json'.",
          "438:     for version in [2, 3]:",
          "439:       repository.root.version = version",
          "440:       info = tuf.roledb.get_roleinfo(\"root\")",
          "441:       metadata = repo_lib.generate_root_metadata(",
          "442:           info[\"version\"], info[\"expires\"], False)",
          "443:       signed_metadata = repo_lib.sign_metadata(",
          "444:           metadata, info[\"keyids\"], \"root.json\", \"default\")",
          "445:       signed_metadata[\"signatures\"].append(signed_metadata[\"signatures\"][0])",
          "446:       live_root_path = os.path.join(",
          "447:           self.repository_directory, \"metadata\", \"root.json\")",
          "449:       # Bypass server side verification in 'write' or 'writeall', which would",
          "450:       # catch the unmet threshold.",
          "451:       # We also skip writing to 'metadata.staged' and copying to 'metadata' and",
          "452:       # instead write directly to 'metadata'",
          "453:       repo_lib.write_metadata_file(signed_metadata, live_root_path, info[\"version\"], True)",
          "456:     # Update from current '1.root.json' to '3.root.json' on client and assert",
          "457:     # raise of 'BadSignatureError' (caused by unmet signature threshold).",
          "458:     try:",
          "459:       self.repository_updater.refresh()",
          "461:     except tuf.exceptions.NoWorkingMirrorError as e:",
          "462:       mirror_errors = list(e.mirror_errors.values())",
          "463:       self.assertTrue(len(mirror_errors) == 1)",
          "464:       self.assertTrue(",
          "465:           isinstance(mirror_errors[0],",
          "466:           securesystemslib.exceptions.BadSignatureError))",
          "467:       self.assertEqual(",
          "468:           str(mirror_errors[0]),",
          "469:           repr(\"root\") + \" metadata has bad signature.\")",
          "471:     else:",
          "472:       self.fail(",
          "473:           \"Expected a NoWorkingMirrorError composed of one BadSignatureError\")",
          "",
          "---------------"
        ],
        "tuf/sig.py||tuf/sig.py": [
          "File: tuf/sig.py -> tuf/sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:   \"\"\"",
          "72:   <Purpose>",
          "73:     Return a dictionary representing the status of the signatures listed in",
          "80:   <Arguments>",
          "81:     signable:",
          "",
          "[Removed Lines]",
          "74:     'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
          "75:     keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,",
          "76:     the status of these signatures can be determined.  This method will iterate",
          "77:     the signatures in 'signable' and enumerate all the keys that are valid,",
          "78:     invalid, unrecognized, or unauthorized.",
          "",
          "[Added Lines]",
          "74:     'signable'. Signatures in the returned dictionary are identified by the",
          "75:     signature keyid and can have a status of either:",
          "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
          "80:       overwritten by passed 'keyids').",
          "83:       scheme.",
          "85:       but is not trusted for the passed role as per 'tuf.roledb' or the passed",
          "86:       'keyids'.",
          "88:     NOTE: The result may contain duplicate keyids or keyids that reference the",
          "89:     same key, if 'signable' lists multiple signatures from the same key.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:       Conformant to tuf.formats.SIGNABLE_SCHEMA.",
          "89:     role:",
          "92:     threshold:",
          "93:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
          "",
          "[Removed Lines]",
          "90:       TUF role (e.g., 'root', 'targets', 'snapshot').",
          "",
          "[Added Lines]",
          "101:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "134:   # The signature status dictionary returned.",
          "135:   signature_status = {}",
          "152:   good_sigs = []",
          "153:   bad_sigs = []",
          "154:   unknown_sigs = []",
          "",
          "[Removed Lines]",
          "137:   # The fields of the signature_status dict, where each field stores keyids.  A",
          "138:   # description of each field:",
          "139:   #",
          "140:   # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
          "141:   # associated with 'role';",
          "142:   #",
          "143:   # bad_sigs = negation of good_sigs;",
          "144:   #",
          "145:   # unknown_sigs = keys not found in the 'keydb' database;",
          "146:   #",
          "147:   # untrusted_sigs = keys that are not in the list of keyids associated with",
          "148:   # 'role';",
          "149:   #",
          "150:   # unknown_signing_scheme = signing schemes specified in keys that are",
          "151:   # unsupported;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "240:     keyids=None):",
          "241:   \"\"\"",
          "242:   <Purpose>",
          "248:   <Arguments>",
          "249:     signable:",
          "251:       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
          "253:     role:",
          "256:     threshold:",
          "257:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
          "",
          "[Removed Lines]",
          "243:     Verify whether the authorized signatures of 'signable' meet the minimum",
          "244:     required by 'role'.  Authorized signatures are those with valid keys",
          "245:     associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
          "246:     and 'role' must not equal 'None' or be less than zero.",
          "250:       A dictionary containing a list of signatures and a 'signed' identifier.",
          "254:       TUF role (e.g., 'root', 'targets', 'snapshot').",
          "",
          "[Added Lines]",
          "238:     Verify that 'signable' has a valid threshold of authorized signatures",
          "239:     identified by unique keyids. The threshold and whether a keyid is",
          "240:     authorized is determined by querying the 'threshold' and 'keyids' info for",
          "241:     the passed 'role' in 'tuf.roledb'. Both values can be overwritten by",
          "242:     passing the 'threshold' or 'keyids' arguments.",
          "244:     NOTE:",
          "245:     - Signatures with identical authorized keyids only count towards the",
          "246:       threshold once.",
          "247:     - Signatures with different authorized keyids each count towards the",
          "248:       threshold, even if the keyids identify the same key.",
          "252:       A dictionary containing a list of signatures and a 'signed' identifier",
          "253:       that conforms to SIGNABLE_SCHEMA, e.g.:",
          "257:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "278:     get_signature_status() will be caught here and re-raised.",
          "280:   <Returns>",
          "283:   \"\"\"",
          "285:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "",
          "[Removed Lines]",
          "281:     Boolean.  True if the number of good signatures >= the role's threshold,",
          "282:     False otherwise.",
          "",
          "[Added Lines]",
          "284:     Boolean.  True if the number of good unique (by keyid) signatures >= the",
          "285:     role's threshold, False otherwise.",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "303:   if threshold is None or threshold <= 0: #pragma: no cover",
          "304:     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
          "",
          "[Removed Lines]",
          "306:   return len(good_sigs) >= threshold",
          "",
          "[Added Lines]",
          "309:   return len(set(good_sigs)) >= threshold",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
      "candidate_info": {
        "commit_hash": "67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
        "repo": "theupdateframework/tuf",
        "commit_url": "https://github.com/theupdateframework/tuf/commit/67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
        "files": [
          "tests/test_sig.py",
          "tuf/sig.py"
        ],
        "message": "Update docs and comments in sig.py and test_sig.py\n\nSigned-off-by: Lukas Puehringer <lukas.puehringer@nyu.edu>",
        "before_after_code_files": [
          "tests/test_sig.py||tests/test_sig.py",
          "tuf/sig.py||tuf/sig.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/theupdateframework/python-tuf/pull/974"
        ],
        "olp_code_files": {
          "patch": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ],
          "candidate": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_sig.py||tests/test_sig.py": [
          "File: tests/test_sig.py -> tests/test_sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
          "390:     # Create and sign dummy metadata twice with same key",
          "391:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "392:     signed = securesystemslib.formats.encode_canonical(",
          "393:         signable[\"signed\"]).encode(\"utf-8\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391:     # Note that we use the non-deterministic rsassa-pss signing scheme, so",
          "392:     # creating the signature twice shows that we don't only detect duplicate",
          "393:     # signatures but also different signatures from the same key.",
          "",
          "---------------"
        ],
        "tuf/sig.py||tuf/sig.py": [
          "File: tuf/sig.py -> tuf/sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
          "80:       overwritten by passed 'keyids').",
          "83:       scheme.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:       'role' is None.",
          "",
          "---------------"
        ]
      }
    }
  ]
}
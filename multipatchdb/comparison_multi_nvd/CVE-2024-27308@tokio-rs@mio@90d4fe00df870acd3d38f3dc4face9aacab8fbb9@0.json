{
  "cve_id": "CVE-2024-27308",
  "cve_desc": "Mio is a Metal I/O library for Rust. When using named pipes on Windows, mio will under some circumstances return invalid tokens that correspond to named pipes that have already been deregistered from the mio registry. The impact of this vulnerability depends on how mio is used. For some applications, invalid tokens may be ignored or cause a warning or a crash. On the other hand, for applications that store pointers in the tokens, this vulnerability may result in a use-after-free. For users of Tokio, this vulnerability is serious and can result in a use-after-free in Tokio. The vulnerability is Windows-specific, and can only happen if you are using named pipes. Other IO resources are not affected. This vulnerability has been fixed in mio v0.8.11. All versions of mio between v0.7.2 and v0.8.10 are vulnerable. Tokio is vulnerable when you are using a vulnerable version of mio AND you are using at least Tokio v1.30.0. Versions of Tokio prior to v1.30.0 will ignore invalid tokens, so they are not vulnerable. Vulnerable libraries that use mio can work around this issue by detecting and ignoring invalid tokens.",
  "repo": "tokio-rs/mio",
  "patch_hash": "90d4fe00df870acd3d38f3dc4face9aacab8fbb9",
  "patch_info": {
    "commit_hash": "90d4fe00df870acd3d38f3dc4face9aacab8fbb9",
    "repo": "tokio-rs/mio",
    "commit_url": "https://github.com/tokio-rs/mio/commit/90d4fe00df870acd3d38f3dc4face9aacab8fbb9",
    "files": [
      "src/sys/windows/event.rs",
      "src/sys/windows/named_pipe.rs"
    ],
    "message": "named-pipes: fix receiving IOCP events after deregister\n\nBackport of the following commits\n * 04c3bb6ef23d217ee7f8f68e3e6d0d9fcddd1520\n * dc3b3f63ba34e2189d9e57fd83b1d4ce5a52385e\n * 6fd5dd0d615a66a30a449d3f8eb1266dad96af62",
    "before_after_code_files": [
      "src/sys/windows/event.rs||src/sys/windows/event.rs",
      "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs"
    ]
  },
  "patch_diff": {
    "src/sys/windows/event.rs||src/sys/windows/event.rs": [
      "File: src/sys/windows/event.rs -> src/sys/windows/event.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "41:     pub(super) fn to_completion_status(&self) -> CompletionStatus {",
      "42:         CompletionStatus::new(self.flags, self.data as usize, std::ptr::null_mut())",
      "43:     }",
      "44: }",
      "46: pub(crate) const READABLE_FLAGS: u32 = afd::POLL_RECEIVE",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "45:     #[cfg(feature = \"os-ext\")]",
      "46:     pub(super) fn to_completion_status_with_overlapped(",
      "47:         &self,",
      "48:         overlapped: *mut super::Overlapped,",
      "49:     ) -> CompletionStatus {",
      "50:         CompletionStatus::new(self.flags, self.data as usize, overlapped)",
      "51:     }",
      "",
      "---------------"
    ],
    "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs": [
      "File: src/sys/windows/named_pipe.rs -> src/sys/windows/named_pipe.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "84:     connect: Overlapped,",
      "85:     read: Overlapped,",
      "86:     write: Overlapped,",
      "88:     handle: Handle,",
      "89:     connecting: AtomicBool,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "87:     event: Overlapped,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "112:     unsafe fn ptr_from_write_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {",
      "114:         (ptr as *mut Overlapped).wrapping_sub(2) as *const Inner",
      "115:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "119:     unsafe fn ptr_from_event_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {",
      "121:         (ptr as *mut Overlapped).wrapping_sub(3) as *const Inner",
      "122:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "478:                 connecting: AtomicBool::new(false),",
      "479:                 read: Overlapped::new(read_done),",
      "480:                 write: Overlapped::new(write_done),",
      "481:                 io: Mutex::new(Io {",
      "482:                     cp: None,",
      "483:                     token: None,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "488:                 event: Overlapped::new(event_done),",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "725:             Err(e) => {",
      "726:                 io.read = State::Err(e);",
      "728:                 true",
      "729:             }",
      "730:         }",
      "",
      "[Removed Lines]",
      "727:                 io.notify_readable(events);",
      "",
      "[Added Lines]",
      "735:                 io.notify_readable(me, events);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "787:             Ok(None) => (),",
      "788:             Err(e) => {",
      "789:                 io.write = State::Err(e);",
      "791:             }",
      "792:         }",
      "793:     }",
      "",
      "[Removed Lines]",
      "790:                 io.notify_writable(events);",
      "",
      "[Added Lines]",
      "798:                 io.notify_writable(me, events);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "797:         #[allow(clippy::needless_option_as_deref)]",
      "798:         if Inner::schedule_read(me, &mut io, events.as_deref_mut()) {",
      "799:             if let State::None = io.write {",
      "801:             }",
      "802:         }",
      "803:     }",
      "",
      "[Removed Lines]",
      "800:                 io.notify_writable(events);",
      "",
      "[Added Lines]",
      "808:                 io.notify_writable(me, events);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "877:     }",
      "881: }",
      "883: fn write_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {",
      "",
      "[Removed Lines]",
      "880:     io.notify_readable(events);",
      "",
      "[Added Lines]",
      "888:     io.notify_readable(&me, events);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "897:         State::Ok(..) => {",
      "899:             return;",
      "900:         }",
      "901:         State::Pending(buf, pos) => (buf, pos),",
      "",
      "[Removed Lines]",
      "898:             io.notify_writable(events);",
      "",
      "[Added Lines]",
      "906:             io.notify_writable(&me, events);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "909:                 let new_pos = pos + (status.bytes_transferred() as usize);",
      "910:                 if new_pos == buf.len() {",
      "911:                     me.put_buffer(buf);",
      "913:                 } else {",
      "914:                     Inner::schedule_write(&me, buf, new_pos, &mut io, events);",
      "915:                 }",
      "",
      "[Removed Lines]",
      "912:                     io.notify_writable(events);",
      "",
      "[Added Lines]",
      "920:                     io.notify_writable(&me, events);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "917:             Err(e) => {",
      "918:                 debug_assert_eq!(status.bytes_transferred(), 0);",
      "919:                 io.write = State::Err(e);",
      "921:             }",
      "922:         }",
      "923:     }",
      "924: }",
      "926: impl Io {",
      "927:     fn check_association(&self, registry: &Registry, required: bool) -> io::Result<()> {",
      "928:         match self.cp {",
      "",
      "[Removed Lines]",
      "920:                 io.notify_writable(events);",
      "",
      "[Added Lines]",
      "928:                 io.notify_writable(&me, events);",
      "934: fn event_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {",
      "935:     let status = CompletionStatus::from_entry(status);",
      "940:     let me = unsafe { Arc::from_raw(Inner::ptr_from_event_overlapped(status.overlapped())) };",
      "942:     let io = me.io.lock().unwrap();",
      "945:     if io.token.is_some() {",
      "949:         if let Some(events) = events {",
      "950:             let mut ev = Event::from_completion_status(&status);",
      "954:             ev.data >>= 1;",
      "955:             events.push(ev);",
      "956:         }",
      "957:     }",
      "958: }",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "938:         }",
      "939:     }",
      "942:         if let Some(token) = self.token {",
      "943:             let mut ev = Event::new(token);",
      "944:             ev.set_readable();",
      "",
      "[Removed Lines]",
      "941:     fn notify_readable(&self, events: Option<&mut Vec<Event>>) {",
      "",
      "[Added Lines]",
      "975:     fn notify_readable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "946:             if let Some(events) = events {",
      "947:                 events.push(ev);",
      "948:             } else {",
      "950:             }",
      "951:         }",
      "952:     }",
      "955:         if let Some(token) = self.token {",
      "956:             let mut ev = Event::new(token);",
      "957:             ev.set_writable();",
      "",
      "[Removed Lines]",
      "949:                 let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());",
      "954:     fn notify_writable(&self, events: Option<&mut Vec<Event>>) {",
      "",
      "[Added Lines]",
      "983:                 self.schedule_event(me, ev);",
      "988:     fn notify_writable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "959:             if let Some(events) = events {",
      "960:                 events.push(ev);",
      "961:             } else {",
      "963:             }",
      "964:         }",
      "965:     }",
      "",
      "[Removed Lines]",
      "962:                 let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());",
      "",
      "[Added Lines]",
      "996:                 self.schedule_event(me, ev);",
      "997:             }",
      "998:         }",
      "999:     }",
      "1001:     fn schedule_event(&self, me: &Arc<Inner>, mut event: Event) {",
      "1009:         event.data <<= 1;",
      "1010:         event.data += 1;",
      "1012:         let completion_status =",
      "1013:             event.to_completion_status_with_overlapped(me.event.as_ptr() as *mut _);",
      "1015:         match self.cp.as_ref().unwrap().post(completion_status) {",
      "1016:             Ok(_) => {",
      "1018:                 mem::forget(me.clone());",
      "1019:             }",
      "1020:             Err(_) => {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "708449851283b57eb6f514c8f289b66e982720b3",
      "candidate_info": {
        "commit_hash": "708449851283b57eb6f514c8f289b66e982720b3",
        "repo": "tokio-rs/mio",
        "commit_url": "https://github.com/tokio-rs/mio/commit/708449851283b57eb6f514c8f289b66e982720b3",
        "files": [
          "src/sys/windows/mod.rs",
          "tests/poll.rs"
        ],
        "message": "Fix warnings",
        "before_after_code_files": [
          "src/sys/windows/mod.rs||src/sys/windows/mod.rs",
          "tests/poll.rs||tests/poll.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tokio-rs/mio/pull/1761"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/sys/windows/mod.rs||src/sys/windows/mod.rs": [
          "File: src/sys/windows/mod.rs -> src/sys/windows/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: use overlapped::Overlapped;",
          "15: mod selector;",
          "19: cfg_net! {",
          "",
          "[Removed Lines]",
          "16: pub use selector::{Selector, SelectorInner, SockState};",
          "",
          "[Added Lines]",
          "16: pub use selector::Selector;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:     pub(crate) mod tcp;",
          "37:     pub(crate) mod udp;",
          "38: }",
          "40: cfg_os_ext! {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39:     pub use selector::{SelectorInner, SockState};",
          "",
          "---------------"
        ],
        "tests/poll.rs||tests/poll.rs": [
          "File: tests/poll.rs -> tests/poll.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "581:     let interests = Interest::READABLE;",
          "582:     registry.register(&mut source, token, interests).unwrap();",
          "583:     assert_eq!(source.registrations.len(), 1);",
          "585:     assert!(source.reregistrations.is_empty());",
          "586:     assert_eq!(source.deregister_count, 0);",
          "",
          "[Removed Lines]",
          "584:     assert_eq!(source.registrations.get(0), Some(&(token, interests)));",
          "",
          "[Added Lines]",
          "584:     assert_eq!(source.registrations.first(), Some(&(token, interests)));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "593:     assert_eq!(source.registrations.len(), 1);",
          "594:     assert_eq!(source.reregistrations.len(), 1);",
          "595:     assert_eq!(",
          "597:         Some(&(re_token, re_interests))",
          "598:     );",
          "599:     assert_eq!(source.deregister_count, 0);",
          "",
          "[Removed Lines]",
          "596:         source.reregistrations.get(0),",
          "",
          "[Added Lines]",
          "596:         source.reregistrations.first(),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04c3bb6ef23d217ee7f8f68e3e6d0d9fcddd1520",
      "candidate_info": {
        "commit_hash": "04c3bb6ef23d217ee7f8f68e3e6d0d9fcddd1520",
        "repo": "tokio-rs/mio",
        "commit_url": "https://github.com/tokio-rs/mio/commit/04c3bb6ef23d217ee7f8f68e3e6d0d9fcddd1520",
        "files": [
          "src/sys/windows/event.rs",
          "src/sys/windows/named_pipe.rs"
        ],
        "message": "named-pipes: fix receiving IOCP events after deregister",
        "before_after_code_files": [
          "src/sys/windows/event.rs||src/sys/windows/event.rs",
          "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/sys/windows/event.rs||src/sys/windows/event.rs",
            "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs"
          ],
          "candidate": [
            "src/sys/windows/event.rs||src/sys/windows/event.rs",
            "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/sys/windows/event.rs||src/sys/windows/event.rs": [
          "File: src/sys/windows/event.rs -> src/sys/windows/event.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     pub(super) fn to_completion_status(&self) -> CompletionStatus {",
          "42:         CompletionStatus::new(self.flags, self.data as usize, std::ptr::null_mut())",
          "43:     }",
          "44: }",
          "46: pub(crate) const READABLE_FLAGS: u32 = afd::POLL_RECEIVE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     pub(super) fn to_completion_status_with_overlapped(",
          "46:         &self,",
          "47:         overlapped: *mut super::Overlapped,",
          "48:     ) -> CompletionStatus {",
          "49:         CompletionStatus::new(self.flags, self.data as usize, overlapped)",
          "50:     }",
          "",
          "---------------"
        ],
        "src/sys/windows/named_pipe.rs||src/sys/windows/named_pipe.rs": [
          "File: src/sys/windows/named_pipe.rs -> src/sys/windows/named_pipe.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "84:     connect: Overlapped,",
          "85:     read: Overlapped,",
          "86:     write: Overlapped,",
          "88:     handle: Handle,",
          "89:     connecting: AtomicBool,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:     event: Overlapped,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:     unsafe fn ptr_from_write_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {",
          "114:         (ptr as *mut Overlapped).wrapping_sub(2) as *const Inner",
          "115:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119:     unsafe fn ptr_from_event_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {",
          "121:         (ptr as *mut Overlapped).wrapping_sub(3) as *const Inner",
          "122:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "478:                 connecting: AtomicBool::new(false),",
          "479:                 read: Overlapped::new(read_done),",
          "480:                 write: Overlapped::new(write_done),",
          "481:                 io: Mutex::new(Io {",
          "482:                     cp: None,",
          "483:                     token: None,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "488:                 event: Overlapped::new(event_done),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "725:             Err(e) => {",
          "726:                 io.read = State::Err(e);",
          "728:                 true",
          "729:             }",
          "730:         }",
          "",
          "[Removed Lines]",
          "727:                 io.notify_readable(events);",
          "",
          "[Added Lines]",
          "735:                 io.notify_readable(me, events);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "787:             Ok(None) => (),",
          "788:             Err(e) => {",
          "789:                 io.write = State::Err(e);",
          "791:             }",
          "792:         }",
          "793:     }",
          "",
          "[Removed Lines]",
          "790:                 io.notify_writable(events);",
          "",
          "[Added Lines]",
          "798:                 io.notify_writable(me, events);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "797:         #[allow(clippy::needless_option_as_deref)]",
          "798:         if Inner::schedule_read(me, &mut io, events.as_deref_mut()) {",
          "799:             if let State::None = io.write {",
          "801:             }",
          "802:         }",
          "803:     }",
          "",
          "[Removed Lines]",
          "800:                 io.notify_writable(events);",
          "",
          "[Added Lines]",
          "808:                 io.notify_writable(me, events);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "877:     }",
          "881: }",
          "883: fn write_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {",
          "",
          "[Removed Lines]",
          "880:     io.notify_readable(events);",
          "",
          "[Added Lines]",
          "888:     io.notify_readable(&me, events);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "897:         State::Ok(..) => {",
          "899:             return;",
          "900:         }",
          "901:         State::Pending(buf, pos) => (buf, pos),",
          "",
          "[Removed Lines]",
          "898:             io.notify_writable(events);",
          "",
          "[Added Lines]",
          "906:             io.notify_writable(&me, events);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "909:                 let new_pos = pos + (status.bytes_transferred() as usize);",
          "910:                 if new_pos == buf.len() {",
          "911:                     me.put_buffer(buf);",
          "913:                 } else {",
          "914:                     Inner::schedule_write(&me, buf, new_pos, &mut io, events);",
          "915:                 }",
          "",
          "[Removed Lines]",
          "912:                     io.notify_writable(events);",
          "",
          "[Added Lines]",
          "920:                     io.notify_writable(&me, events);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "917:             Err(e) => {",
          "918:                 debug_assert_eq!(status.bytes_transferred(), 0);",
          "919:                 io.write = State::Err(e);",
          "921:             }",
          "922:         }",
          "923:     }",
          "924: }",
          "926: impl Io {",
          "927:     fn check_association(&self, registry: &Registry, required: bool) -> io::Result<()> {",
          "928:         match self.cp {",
          "",
          "[Removed Lines]",
          "920:                 io.notify_writable(events);",
          "",
          "[Added Lines]",
          "928:                 io.notify_writable(&me, events);",
          "934: fn event_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {",
          "935:     let status = CompletionStatus::from_entry(status);",
          "940:     let me = unsafe { Arc::from_raw(Inner::ptr_from_event_overlapped(status.overlapped())) };",
          "942:     let io = me.io.lock().unwrap();",
          "945:     if io.token.is_some() {",
          "949:         if let Some(events) = events {",
          "950:             let mut ev = Event::from_completion_status(&status);",
          "954:             ev.data >>= 1;",
          "955:             events.push(ev);",
          "956:         }",
          "957:     }",
          "958: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "938:         }",
          "939:     }",
          "942:         if let Some(token) = self.token {",
          "943:             let mut ev = Event::new(token);",
          "944:             ev.set_readable();",
          "",
          "[Removed Lines]",
          "941:     fn notify_readable(&self, events: Option<&mut Vec<Event>>) {",
          "",
          "[Added Lines]",
          "975:     fn notify_readable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "946:             if let Some(events) = events {",
          "947:                 events.push(ev);",
          "948:             } else {",
          "950:             }",
          "951:         }",
          "952:     }",
          "955:         if let Some(token) = self.token {",
          "956:             let mut ev = Event::new(token);",
          "957:             ev.set_writable();",
          "",
          "[Removed Lines]",
          "949:                 let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());",
          "954:     fn notify_writable(&self, events: Option<&mut Vec<Event>>) {",
          "",
          "[Added Lines]",
          "983:                 self.schedule_event(me, ev);",
          "988:     fn notify_writable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "959:             if let Some(events) = events {",
          "960:                 events.push(ev);",
          "961:             } else {",
          "963:             }",
          "964:         }",
          "965:     }",
          "",
          "[Removed Lines]",
          "962:                 let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());",
          "",
          "[Added Lines]",
          "996:                 self.schedule_event(me, ev);",
          "997:             }",
          "998:         }",
          "999:     }",
          "1001:     fn schedule_event(&self, me: &Arc<Inner>, mut event: Event) {",
          "1004:         event.data <<= 1;",
          "1005:         event.data += 1;",
          "1007:         let completion_status =",
          "1008:             event.to_completion_status_with_overlapped(me.event.as_ptr() as *mut _);",
          "1010:         match self.cp.as_ref().unwrap().post(completion_status) {",
          "1011:             Ok(_) => {",
          "1013:                 mem::forget(me.clone());",
          "1014:             }",
          "1015:             Err(_) => {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
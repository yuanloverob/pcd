{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
      "candidate_info": {
        "commit_hash": "bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/bc3e62f7e9e0c56b984ca38a26a78651669e594b",
        "files": [
          "mem/q_malloc.c",
          "mem/q_malloc.h",
          "mem/q_malloc_dyn.h"
        ],
        "message": "mem/q_malloc: add support for debug history\n\nBy setting a size via the QM_DBG_MALLOC_HIST define, we now keep a\nhistory of the file, func, line debug information in each fragment.",
        "before_after_code_files": [
          "mem/q_malloc.c||mem/q_malloc.c",
          "mem/q_malloc.h||mem/q_malloc.h",
          "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mem/q_malloc.c||mem/q_malloc.c": [
          "File: mem/q_malloc.c -> mem/q_malloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126:     (PREV_FRAG_END(f)->check2!=END_CHECK_PATTERN2) ) ){",
          "127:   LM_CRIT(\" qm_*: prev. fragm. tail overwritten(%lx, %lx)[%p:%p] (%s, %s:%ld)!\\n\",",
          "128:     PREV_FRAG_END(f)->check1, PREV_FRAG_END(f)->check2, f,",
          "131:   abort();",
          "132:  }",
          "133: }",
          "",
          "[Removed Lines]",
          "129:     (char*)f+sizeof(struct qm_frag), FRAG_PREV(f)->func,",
          "130:     FRAG_PREV(f)->file,FRAG_PREV(f)->line);",
          "",
          "[Added Lines]",
          "129:     (char*)f+sizeof(struct qm_frag),",
          "130:     qm_dbg_coords(FRAG_PREV(f)));",
          "",
          "---------------"
        ],
        "mem/q_malloc.h||mem/q_malloc.h": [
          "File: mem/q_malloc.h -> mem/q_malloc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct qm_frag {",
          "62:  unsigned long size;",
          "63:  union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: #ifdef DBG_MALLOC",
          "62: #ifndef QM_DBG_MALLOC_HIST",
          "63: #define QM_DBG_MALLOC_HIST 1",
          "64: #endif",
          "65: struct qm_frag_dbg {",
          "66:        const char* file;",
          "67:        const char* func;",
          "68:        unsigned long line;",
          "69: };",
          "71: #define qm_dbg_coords(_frag) \\",
          "72:        (_frag)->dbg[0].file, (_frag)->dbg[0].func, (_frag)->dbg[0].line",
          "73: #else",
          "74: #define qm_dbg_coords(_frag)",
          "75: #endif",
          "77: #ifdef DBG_MALLOC",
          "78: #if QM_DBG_MALLOC_HIST > 1",
          "79: #define qm_dbg_move(_frag) \\",
          "80:        memmove(&(_frag)->dbg[1], &(_frag)->dbg[0], \\",
          "81:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "82: #define qm_dbg_clear(_frag) \\",
          "83:        memset(&(_frag)->dbg[1], 0, \\",
          "84:                        (QM_DBG_MALLOC_HIST - 1) * sizeof(struct qm_frag_dbg))",
          "86: #define qm_dbg_move(_frag)",
          "87: #define qm_dbg_clear(_frag)",
          "89: #define qm_dbg_fill(_frag, _file, _func, _line) \\",
          "90:        do { \\",
          "91:                qm_dbg_move(_frag); \\",
          "92:                (_frag)->dbg[0].file = _file; \\",
          "93:                (_frag)->dbg[0].func = _func; \\",
          "94:                (_frag)->dbg[0].line = _line; \\",
          "95:        } while(0)",
          "98: #define qm_dbg_fill(_frag, _file, _func, _line)",
          "99: #define qm_dbg_clear(_frag)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:   long is_free;",
          "66:  } u;",
          "67: #ifdef DBG_MALLOC",
          "71:  unsigned long check;",
          "72: #endif",
          "73: #ifdef SHM_EXTRA_STATS",
          "",
          "[Removed Lines]",
          "68:  const char *file;",
          "69:  const char *func;",
          "70:  unsigned long line;",
          "",
          "[Added Lines]",
          "110:  struct qm_frag_dbg dbg[QM_DBG_MALLOC_HIST];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "158: void qm_stats_set_index(void *ptr, unsigned long idx);",
          "160: #ifdef DBG_MALLOC",
          "164: #else",
          "165: static inline const char *qm_frag_file(void *p) { return NULL; }",
          "166: static inline const char *qm_frag_func(void *p) { return NULL; }",
          "",
          "[Removed Lines]",
          "161: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->file; }",
          "162: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->func; }",
          "163: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->line; }",
          "",
          "[Added Lines]",
          "201: static inline const char *qm_frag_file(void *p) { return QM_FRAG(p)->dbg[0].file; }",
          "202: static inline const char *qm_frag_func(void *p) { return QM_FRAG(p)->dbg[0].func; }",
          "203: static inline unsigned long qm_frag_line(void *p) { return QM_FRAG(p)->dbg[0].line; }",
          "",
          "---------------"
        ],
        "mem/q_malloc_dyn.h||mem/q_malloc_dyn.h": [
          "File: mem/q_malloc_dyn.h -> mem/q_malloc_dyn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:   end->check1=END_CHECK_PATTERN1;",
          "63:   end->check2=END_CHECK_PATTERN2;",
          "68:   n->check=ST_CHECK_PATTERN;",
          "69: #endif",
          "71:   qm_insert_free(qm, n);",
          "",
          "[Removed Lines]",
          "65:   n->file=file;",
          "66:   n->func=func;",
          "67:   n->line=line;",
          "",
          "[Added Lines]",
          "66:   qm_dbg_clear(n);",
          "67:   qm_dbg_fill(n, file, func, line);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:    qm->max_real_used=qm->real_used;",
          "143: #ifdef DBG_MALLOC",
          "147:   f->check=ST_CHECK_PATTERN;",
          "",
          "[Removed Lines]",
          "144:   f->file=file;",
          "145:   f->func=func;",
          "146:   f->line=line;",
          "",
          "[Added Lines]",
          "143:   qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:  if (f->u.is_free){",
          "201:   LM_CRIT(\"freeing already freed pointer,\"",
          "202:     \" first free: %s: %s(%ld) - aborting\\n\",",
          "204:   abort();",
          "205:  }",
          "206:  LM_GEN1( memlog, \"freeing frag. %p alloc'ed from %s: %s(%ld)\\n\",",
          "208: #endif",
          "210:  size=f->size;",
          "",
          "[Removed Lines]",
          "203:     f->file, f->func, f->line);",
          "207:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "200:     qm_dbg_coords(f));",
          "204:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "245:  f->size=size;",
          "246:  FRAG_END(f)->size=f->size;",
          "247: #ifdef DBG_MALLOC",
          "251: #endif",
          "252:  qm_insert_free(qm, f);",
          "253:  qm->fragments -= 1;",
          "",
          "[Removed Lines]",
          "248:  f->file=file;",
          "249:  f->func=func;",
          "250:  f->line=line;",
          "",
          "[Added Lines]",
          "245:  qm_dbg_fill(f, file, func, line);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "308:  #ifdef DBG_MALLOC",
          "309:  qm_debug_frag(qm, f);",
          "310:  LM_GEN1( memlog, \"realloc'ing frag %p alloc'ed from %s: %s(%ld)\\n\",",
          "312:  if (f->u.is_free) {",
          "313:   LM_CRIT(\"trying to realloc an already freed \"",
          "314:     \"pointer %p , fragment %p -- aborting\\n\", p, f);",
          "",
          "[Removed Lines]",
          "311:    f, f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "306:    f, qm_dbg_coords(f));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "435:  for (f = qm->first_frag; f >= qm->first_frag &&",
          "436:          (void *)f < (void *)qm->last_frag_end; f = FRAG_NEXT(f)) {",
          "439:     LM_ERR(\"Unable to update alloc'ed. memory summary\\n\");",
          "440:     dbg_ht_free(allocd);",
          "441:     return;",
          "",
          "[Removed Lines]",
          "437:   if (!f->u.is_free && f->file)",
          "438:    if (dbg_ht_update(allocd, f->file, f->func, f->line, f->size) < 0) {",
          "",
          "[Added Lines]",
          "432:   if (!f->u.is_free && f->dbg[0].file)",
          "433:    if (dbg_ht_update(allocd, qm_dbg_coords(f), f->size) < 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "474:      LM_GEN1(memdump, \"unused fragm.: hash = %3d, fragment %p,\"",
          "475:       \" address %p size %lu, created from %s: %s(%lu)\\n\",",
          "476:          h, f, (char*)f+sizeof(struct qm_frag), f->size,",
          "478: #endif",
          "479:     }",
          "480:   }",
          "",
          "[Removed Lines]",
          "477:       f->file, f->func, f->line);",
          "",
          "[Added Lines]",
          "472:       qm_dbg_coords(f));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94b37404316da5148349c960336d5a9f68bc37ae",
      "candidate_info": {
        "commit_hash": "94b37404316da5148349c960336d5a9f68bc37ae",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/94b37404316da5148349c960336d5a9f68bc37ae",
        "files": [
          "context.c",
          "context.h"
        ],
        "message": "context API: Fix ctx cleanup API; Document context_destroy() behavior\n\nAlthough this patch fixes a memory leak in clear_global_context(), this\nfunction is not being used at all.\n\n(cherry picked from commit 02e1177714b91fa8b7e29f0162c8e9385767f6b1)",
        "before_after_code_files": [
          "context.c||context.c",
          "context.h||context.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "context.c||context.c": [
          "File: context.c -> context.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146: {",
          "147:  if (current_processing_ctx) {",
          "148:   context_destroy(CONTEXT_GLOBAL, current_processing_ctx);",
          "149:   current_processing_ctx = NULL;",
          "150:  }",
          "151: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:   context_free(current_processing_ctx);",
          "",
          "---------------"
        ],
        "context.h||context.h": [
          "File: context.h -> context.h"
        ]
      }
    },
    {
      "candidate_hash": "c74c2ef1fe328bddbec50f8968443f74fc8c8a6c",
      "candidate_info": {
        "commit_hash": "c74c2ef1fe328bddbec50f8968443f74fc8c8a6c",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/c74c2ef1fe328bddbec50f8968443f74fc8c8a6c",
        "files": [
          "modules/tm/t_cancel.c",
          "modules/tm/t_reply.c"
        ],
        "message": "tm: use INVITE's AVPs when sending locally generated msgs\n\nThis allows the TLS_MGM module to pick up the right tls_domain that\nshould be used for sending the ACK/CANCEL message\n\n(cherry picked from commit 84c1614ecea5025230b46950408c8343c693ec8b)",
        "before_after_code_files": [
          "modules/tm/t_cancel.c||modules/tm/t_cancel.c",
          "modules/tm/t_reply.c||modules/tm/t_reply.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/tm/t_cancel.c||modules/tm/t_cancel.c": [
          "File: modules/tm/t_cancel.c -> modules/tm/t_cancel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  char *cancel;",
          "89:  unsigned int len;",
          "90:  struct retr_buf *crb, *irb;",
          "92:  crb=&t->uac[branch].local_cancel;",
          "93:  irb=&t->uac[branch].request;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:  struct usr_avp **backup_list;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:  LM_DBG(\"sending cancel...\\n\");",
          "124:  if (t->uac[branch].br_flags & tcp_no_new_conn_bflag)",
          "125:   tcp_no_new_conn = 1;",
          "126:  if (SEND_BUFFER( crb )==0) {",
          "127:   if ( has_tran_tmcbs( t, TMCB_MSG_SENT_OUT) ) {",
          "128:    set_extra_tmcb_params( &crb->buffer, &crb->dst);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "127:  backup_list = set_avp_list( &t->user_avps );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "130:     t, t->uas.request, 0, 0);",
          "131:   }",
          "132:  }",
          "133:  tcp_no_new_conn = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "135:  set_avp_list(backup_list);",
          "",
          "---------------"
        ],
        "modules/tm/t_reply.c||modules/tm/t_reply.c": [
          "File: modules/tm/t_reply.c -> modules/tm/t_reply.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "290:  str method = str_init(ACK);",
          "291:  str to;",
          "292:  str ack_buf;",
          "294:  if(parse_headers(rpl,is_local(trans)?HDR_EOH_F:(HDR_TO_F|HDR_FROM_F),0)==-1",
          "295:  || !rpl->to || !rpl->from ) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:  struct usr_avp **backup_list;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:  if (trans->uac[branch].br_flags & tcp_no_new_conn_bflag)",
          "311:   tcp_no_new_conn = 1;",
          "313:  if(SEND_PR_BUFFER(&trans->uac[branch].request, ack_buf.s, ack_buf.len)==0){",
          "315:   if ( has_tran_tmcbs( trans, TMCB_MSG_SENT_OUT) ) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "314:  backup_list = set_avp_list( &trans->user_avps );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "318:     trans, trans->uas.request, 0, 0);",
          "319:   }",
          "320:  }",
          "322:  tcp_no_new_conn = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "323:  set_avp_list(backup_list);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1628c902a1ce251ae9c4ecf782a3a1814f52b888",
      "candidate_info": {
        "commit_hash": "1628c902a1ce251ae9c4ecf782a3a1814f52b888",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/1628c902a1ce251ae9c4ecf782a3a1814f52b888",
        "files": [
          "Makefile.conf.template"
        ],
        "message": "Properly exclude tls_openssl/wolfssl when using menuconfig\n\n(cherry picked from commit 870f19040b2e28d671552ff2d1e62c7661333894)",
        "before_after_code_files": [
          "Makefile.conf.template||Makefile.conf.template"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.conf.template||Makefile.conf.template": [
          "File: Makefile.conf.template -> Makefile.conf.template",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #sngtc= Voice Transcoding using the D-series Sangoma transcoding cards | libsngtc_node",
          "59: #siprec= SIP Call Recording to an external/passive recorder | uuid-dev",
          "60: #snmpstats= Provides an SNMP management interface to OpenSIPS | NetSNMP v5.3",
          "62: #xcap= XCAP utility functions for OpenSIPS. | libxml-dev",
          "63: #xcap_client= XCAP client for OpenSIPS.It fetches XCAP elements, either documents or part of them, by sending HTTP GET requests | libxml-dev and libcurl-dev",
          "64: #xml= Introduces a new type of variable that provides both serialization and de-serialization from XML format. | XML library, libxml2-dev",
          "",
          "[Removed Lines]",
          "61: #tls_mgm= Provides a TLS interface to manage certificates for OpenSIPS | SSL development library, typically libssl-dev",
          "",
          "[Added Lines]",
          "61: #tls_openssl= Implements TLS operations using the OpenSSL libarary | SSL development library, typically libssl-dev",
          "62: #tls_mgm= Provides a TLS interface to manage certificates for OpenSIPS |",
          "63: #tls_wolfssl= Implements TLS operations using the wolfSSL libarary |",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6215c1fad65551db9760aa3b8389d039934161c",
      "candidate_info": {
        "commit_hash": "d6215c1fad65551db9760aa3b8389d039934161c",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/d6215c1fad65551db9760aa3b8389d039934161c",
        "files": [
          "modules/dialog/dlg_repl_profile.h"
        ],
        "message": "dialog: Fix shm memleak on OOM error case\n\n(cherry picked from commit 6d03091833a0ee9a9d1294b0aff87a7435c60bf4)",
        "before_after_code_files": [
          "modules/dialog/dlg_repl_profile.h||modules/dialog/dlg_repl_profile.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/dialog/dlg_repl_profile.h||modules/dialog/dlg_repl_profile.h": [
          "File: modules/dialog/dlg_repl_profile.h -> modules/dialog/dlg_repl_profile.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "120:   memset(cnt, 0, sizeof *cnt);",
          "122:   if (shtag->len && shm_str_dup(&cnt->shtag, shtag) < 0) {",
          "123:    LM_ERR(\"oom\\n\");",
          "124:    return NULL;",
          "125:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123:    shm_free(cnt);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
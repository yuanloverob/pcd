{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a71c14997936b3911ffa73d01e632838a40b97d",
      "candidate_info": {
        "commit_hash": "6a71c14997936b3911ffa73d01e632838a40b97d",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/6a71c14997936b3911ffa73d01e632838a40b97d",
        "files": [
          "cachedb/cachedb.h",
          "modules/cachedb_local/cachedb_local.c",
          "modules/sql_cacher/sql_cacher.c"
        ],
        "message": "sql_cacher: don't allow usage of a replicated local cache\n\nUsing a replicated collection for cachedb_local would lead to invalid\nkeys in the cache due to reload version inconsistencies.\n\n(cherry picked from commit 1b9662649d2e0606225b5e198a083619d0ca97e1)",
        "before_after_code_files": [
          "cachedb/cachedb.h||cachedb/cachedb.h",
          "modules/cachedb_local/cachedb_local.c||modules/cachedb_local/cachedb_local.c",
          "modules/sql_cacher/sql_cacher.c||modules/sql_cacher/sql_cacher.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "cachedb/cachedb.h||cachedb/cachedb.h": [
          "File: cachedb/cachedb.h -> cachedb/cachedb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "144:                 const cdb_dict_t *pairs);",
          "147:  int capability;",
          "148: } cachedb_funcs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:  int (*is_replicated) (cachedb_con *con);",
          "",
          "---------------"
        ],
        "modules/cachedb_local/cachedb_local.c||modules/cachedb_local/cachedb_local.c": [
          "File: modules/cachedb_local/cachedb_local.c -> modules/cachedb_local/cachedb_local.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:  cachedb_do_close(con,lcache_free_connection);",
          "322: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324: int lcache_is_replicated (cachedb_con *con)",
          "325: {",
          "326:  return cluster_id ? 1 : 0;",
          "327: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "348:  cde.cdb_func.remove = lcache_htable_remove;",
          "349:  cde.cdb_func.add = lcache_htable_add;",
          "350:  cde.cdb_func.sub = lcache_htable_sub;",
          "352:  cde.cdb_func.capability = CACHEDB_CAP_BINARY_VALUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:  cde.cdb_func.is_replicated = lcache_is_replicated;",
          "",
          "---------------"
        ],
        "modules/sql_cacher/sql_cacher.c||modules/sql_cacher/sql_cacher.c": [
          "File: modules/sql_cacher/sql_cacher.c -> modules/sql_cacher/sql_cacher.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "743:    c_entry->cachedb_url.len, c_entry->cachedb_url.s);",
          "744:   return NULL;",
          "745:  }",
          "747:  if (new_db_hdls->cdbf.set(new_db_hdls->cdbcon, &cdb_test_key, &cdb_test_val,",
          "748:   0) < 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "747:  if (new_db_hdls->cdbf.is_replicated &&",
          "748:   new_db_hdls->cdbf.is_replicated(new_db_hdls->cdbcon)) {",
          "749:   LM_ERR(\"Cannot use an OpenSIPS replicated cacheDB\\n\");",
          "750:   return NULL;",
          "751:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cd52ccc5e6eac577b9a564e05b58d726d59b0210",
      "candidate_info": {
        "commit_hash": "cd52ccc5e6eac577b9a564e05b58d726d59b0210",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/cd52ccc5e6eac577b9a564e05b58d726d59b0210",
        "files": [
          "modules/b2b_entities/b2be_load.h",
          "modules/b2b_entities/client.c",
          "modules/b2b_entities/client.h",
          "modules/b2b_entities/dlg.c",
          "modules/b2b_entities/dlg.h",
          "modules/b2b_entities/server.c",
          "modules/b2b_entities/server.h"
        ],
        "message": "b2b_entities: allow enforcing the Max-Forwards value\n\nRelated to #2471\n\n(cherry picked from commit 404f580026f2bb67cdacf56e1384213643a0505e)",
        "before_after_code_files": [
          "modules/b2b_entities/b2be_load.h||modules/b2b_entities/b2be_load.h",
          "modules/b2b_entities/client.c||modules/b2b_entities/client.c",
          "modules/b2b_entities/client.h||modules/b2b_entities/client.h",
          "modules/b2b_entities/dlg.c||modules/b2b_entities/dlg.c",
          "modules/b2b_entities/dlg.h||modules/b2b_entities/dlg.h",
          "modules/b2b_entities/server.c||modules/b2b_entities/server.c",
          "modules/b2b_entities/server.h||modules/b2b_entities/server.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/b2b_entities/b2be_load.h||modules/b2b_entities/b2be_load.h": [
          "File: modules/b2b_entities/b2be_load.h -> modules/b2b_entities/b2be_load.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:  str* from_tag;",
          "68:  str local_contact;",
          "69:  unsigned int cseq;",
          "70:  struct socket_info* send_sock;",
          "71:  struct usr_avp *avps;",
          "72: }client_info_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70:  unsigned int maxfwd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:  str* client_headers;",
          "88:  str* body;",
          "89:  b2b_dlginfo_t* dlginfo;",
          "90:  unsigned int no_cb;",
          "91: }b2b_req_data_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:  unsigned int maxfwd;",
          "",
          "---------------"
        ],
        "modules/b2b_entities/client.c||modules/b2b_entities/client.c": [
          "File: modules/b2b_entities/client.c -> modules/b2b_entities/client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "203:  td.id.rem_tag.s = 0;",
          "204:  td.id.rem_tag.len = 0;",
          "206:  td.rem_uri = ci->to_uri;",
          "207:  if(ci->req_uri.s)",
          "208:   td.rem_target    = ci->req_uri;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:  if (ci->maxfwd > 0) {",
          "207:   td.mf_enforced = 1;",
          "208:   td.mf_value = ci->maxfwd - 1;",
          "209:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "269:  return NULL;",
          "270: }",
          "273: {",
          "274:  dlg_t* td =NULL;",
          "",
          "[Removed Lines]",
          "272: dlg_t* b2b_client_build_dlg(b2b_dlg_t* dlg, dlg_leg_t* leg)",
          "",
          "[Added Lines]",
          "277: dlg_t* b2b_client_build_dlg(b2b_dlg_t* dlg, dlg_leg_t* leg, unsigned int maxfwd)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292:  td->loc_dname = dlg->from_dname;",
          "293:  td->rem_dname = dlg->to_dname;",
          "295:  if(dlg->proxy.len)",
          "296:   td->obp = dlg->proxy;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "300:  if (maxfwd > 0) {",
          "301:   td->mf_enforced = 1;",
          "302:   td->mf_value = maxfwd - 1;",
          "303:  }",
          "",
          "---------------"
        ],
        "modules/b2b_entities/client.h||modules/b2b_entities/client.h": [
          "File: modules/b2b_entities/client.h -> modules/b2b_entities/client.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void b2b_client_tm_cback( struct cell *t, int type, struct tmcb_params *ps);",
          "44: #endif",
          "",
          "[Removed Lines]",
          "42: dlg_t* b2b_client_build_dlg(b2b_dlg_t* dlg, dlg_leg_t* leg);",
          "",
          "[Added Lines]",
          "42: dlg_t* b2b_client_build_dlg(b2b_dlg_t* dlg, dlg_leg_t* leg, unsigned int maxfwd);",
          "",
          "---------------"
        ],
        "modules/b2b_entities/dlg.c||modules/b2b_entities/dlg.c": [
          "File: modules/b2b_entities/dlg.c -> modules/b2b_entities/dlg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1878:  shm_free(param);",
          "1879: }",
          "1882: {",
          "1884: }",
          "1886: void free_tm_dlg(dlg_t* td)",
          "",
          "[Removed Lines]",
          "1881: dlg_t* b2b_client_dlg(b2b_dlg_t* dlg)",
          "1883:  return b2b_client_build_dlg(dlg, dlg->legs);",
          "",
          "[Added Lines]",
          "1881: dlg_t* b2b_client_dlg(b2b_dlg_t* dlg, unsigned int maxfwd)",
          "1883:  return b2b_client_build_dlg(dlg, dlg->legs, maxfwd);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1892:  pkg_free(td);",
          "1893: }",
          "1897: {",
          "1898:  str* b2b_key_shm = NULL;",
          "1899:  dlg_t* td = NULL;",
          "",
          "[Removed Lines]",
          "1895: int b2b_send_indlg_req(b2b_dlg_t* dlg, enum b2b_entity_type et,",
          "1896:   str* b2b_key, str* method, str* ehdr, str* body, unsigned int no_cb)",
          "",
          "[Added Lines]",
          "1895: int b2b_send_indlg_req(b2b_dlg_t* dlg, enum b2b_entity_type et, str* b2b_key,",
          "1896:  str* method, str* ehdr, unsigned int maxfwd, str* body, unsigned int no_cb)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1923:  }",
          "1927:  if(td == NULL)",
          "1928:  {",
          "1929:   LM_ERR(\"Failed to build tm dialog structure, was asked to send [%.*s]\"",
          "",
          "[Removed Lines]",
          "1926:  td = build_dlg(dlg);",
          "",
          "[Added Lines]",
          "1926:  td = build_dlg(dlg, maxfwd);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2132:    dlg->last_method == METHOD_INVITE)",
          "2133:  {",
          "2136:   dlg->state= B2B_ESTABLISHED;",
          "2137:  }",
          "",
          "[Removed Lines]",
          "2135:   b2b_send_indlg_req(dlg, et, b2b_key, &ack, &ehdr, req_data->body, req_data->no_cb);",
          "",
          "[Added Lines]",
          "2135:   b2b_send_indlg_req(dlg, et, b2b_key, &ack, &ehdr, 0,",
          "2136:    req_data->body, req_data->no_cb);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2170:   }",
          "2171:   else",
          "2172:   {",
          "2175:    method_value = METHOD_BYE;",
          "2176:   }",
          "2177:  }",
          "2178:  else",
          "2179:  {",
          "2181:  }",
          "2183:  if(ret < 0)",
          "",
          "[Removed Lines]",
          "2173:    b2b_send_indlg_req(dlg, et, b2b_key, &ack, &ehdr, 0, req_data->no_cb);",
          "2174:    ret = b2b_send_indlg_req(dlg, et, b2b_key, &bye, &ehdr, req_data->body, req_data->no_cb);",
          "2180:   ret = b2b_send_indlg_req(dlg, et, b2b_key, method, &ehdr, req_data->body, req_data->no_cb);",
          "",
          "[Added Lines]",
          "2174:    b2b_send_indlg_req(dlg, et, b2b_key, &ack, &ehdr, 0, 0, req_data->no_cb);",
          "2175:    ret = b2b_send_indlg_req(dlg, et, b2b_key, &bye, &ehdr, 0, req_data->body,",
          "2176:     req_data->no_cb);",
          "2182:   ret = b2b_send_indlg_req(dlg, et, b2b_key, method, &ehdr,",
          "2183:    req_data->maxfwd, req_data->body, req_data->no_cb);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2415:  LM_DBG(\"start type=%d\\n\", etype);",
          "2416:  if(etype== B2B_SERVER)",
          "2418:  else",
          "2421:  if(td == NULL)",
          "2422:  {",
          "",
          "[Removed Lines]",
          "2417:   td = b2b_server_build_dlg(dlg);",
          "2419:   td = b2b_client_build_dlg(dlg, leg);",
          "",
          "[Added Lines]",
          "2420:   td = b2b_server_build_dlg(dlg, 0);",
          "2422:   td = b2b_client_build_dlg(dlg, leg, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2930:      new_hdr->s = NULL; new_hdr->len = 0;",
          "2932:      b2b_send_indlg_req(dlg, B2B_CLIENT, b2b_key, &t->method,",
          "2934:      pkg_free(extra_headers.s);",
          "2936:      dlg->state = B2B_NEW_AUTH;",
          "",
          "[Removed Lines]",
          "2933:        &extra_headers, &body, 0);",
          "",
          "[Added Lines]",
          "2936:        &extra_headers, 0, &body, 0);",
          "",
          "---------------"
        ],
        "modules/b2b_entities/dlg.h||modules/b2b_entities/dlg.h": [
          "File: modules/b2b_entities/dlg.h -> modules/b2b_entities/dlg.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: void b2b_delete_record(b2b_dlg_t* dlg, b2b_table htable, unsigned int hash_index);",
          "170: str* b2b_key_copy_shm(str* b2b_key);",
          "",
          "[Removed Lines]",
          "168: typedef dlg_t* (*build_dlg_f)(b2b_dlg_t* dlg);",
          "",
          "[Added Lines]",
          "168: typedef dlg_t* (*build_dlg_f)(b2b_dlg_t* dlg, unsigned int maxfwd);",
          "",
          "---------------"
        ],
        "modules/b2b_entities/server.c||modules/b2b_entities/server.c": [
          "File: modules/b2b_entities/server.c -> modules/b2b_entities/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: }",
          "120: {",
          "121:  dlg_t* td =NULL;",
          "",
          "[Removed Lines]",
          "119: dlg_t* b2b_server_build_dlg(b2b_dlg_t* dlg)",
          "",
          "[Added Lines]",
          "119: dlg_t* b2b_server_build_dlg(b2b_dlg_t* dlg, unsigned int maxfwd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:  td->loc_dname = dlg->to_dname;",
          "143:  td->rem_dname = dlg->from_dname;",
          "145:  if(dlg->route_set[CALLER_LEG].s && dlg->route_set[CALLER_LEG].len)",
          "146:  {",
          "147:   if(parse_rr_body(dlg->route_set[CALLER_LEG].s, dlg->route_set[CALLER_LEG].len,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:  if (maxfwd > 0) {",
          "146:   td->mf_enforced = 1;",
          "147:   td->mf_value = maxfwd - 1;",
          "148:  }",
          "",
          "---------------"
        ],
        "modules/b2b_entities/server.h||modules/b2b_entities/server.h": [
          "File: modules/b2b_entities/server.h -> modules/b2b_entities/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: str* server_new(struct sip_msg*, str* local_contact, b2b_notify_t, str *,",
          "35:   str*, struct b2b_tracer*);",
          "39: void b2b_server_tm_cback( struct cell *t, int type, struct tmcb_params *ps);",
          "",
          "[Removed Lines]",
          "37: dlg_t* b2b_server_build_dlg(b2b_dlg_t* dlg);",
          "",
          "[Added Lines]",
          "37: dlg_t* b2b_server_build_dlg(b2b_dlg_t* dlg, unsigned int maxfwd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa80bdf1aa054e38b64aa5fcab9e6de25e3c08e3",
      "candidate_info": {
        "commit_hash": "fa80bdf1aa054e38b64aa5fcab9e6de25e3c08e3",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/fa80bdf1aa054e38b64aa5fcab9e6de25e3c08e3",
        "files": [
          "modules/freeswitch/fs_proc.c"
        ],
        "message": "freeswitch: If-guard some verbose DBG logs\n\nSuggested by @NormB\n\n(cherry picked from commit 6ec8ddec144ce133a365bdc8a095a1f267376f58)",
        "before_after_code_files": [
          "modules/freeswitch/fs_proc.c||modules/freeswitch/fs_proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/freeswitch/fs_proc.c||modules/freeswitch/fs_proc.c": [
          "File: modules/freeswitch/fs_proc.c -> modules/freeswitch/fs_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:  fs_evs *sock;",
          "542:  int rc;",
          "544:  LM_DBG(\"applying FS socket commands\\n\");",
          "546:  lock_start_write(sockets_esl_lock);",
          "547:  list_for_each_safe(_, __, fs_sockets_esl) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "544: #ifdef EXTRA_DEBUG",
          "546: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "576: {",
          "577:  fs_api_set_proc_no();",
          "579:  LM_DBG(\"size: %d, method: %d\\n\", reactor_size, io_poll_method);",
          "581:  if (init_worker_reactor(\"FS Manager\", RCT_PRIO_MAX) != 0) {",
          "582:   LM_BUG(\"failed to init FS reactor\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "581: #ifdef EXTRA_DEBUG",
          "583: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80179471cb4a4ce11469de2bdb720e6f866f78aa",
      "candidate_info": {
        "commit_hash": "80179471cb4a4ce11469de2bdb720e6f866f78aa",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/80179471cb4a4ce11469de2bdb720e6f866f78aa",
        "files": [
          "modules/tracer/tracer.c"
        ],
        "message": "tracer: fix trace_stop removal from list\n\nFix the way we detect the previous element when removing from list\nBefore this change, if there were multiple elements in the list, they\nwere leaking due to the bad handling of the list removal.\n\n(cherry picked from commit dae9817b313cb98ed3d4d449064c64c9a4ac7cd8)",
        "before_after_code_files": [
          "modules/tracer/tracer.c||modules/tracer/tracer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/tracer/tracer.c||modules/tracer/tracer.c": [
          "File: modules/tracer/tracer.c -> modules/tracer/tracer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3253:  hash=it->hash;",
          "3257:   if (it->next->hash == hash)",
          "3258:    break;",
          "3259:   else",
          "",
          "[Removed Lines]",
          "3256:  for (prev=NULL, it=(*dyn_trace_list); it && it->next; it = it->next) {",
          "",
          "[Added Lines]",
          "3256:  for (prev=NULL, it=(*dyn_trace_list); it && it->hash != hash && it->next; it = it->next) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ccfdb699bdb2e43979a780ead5baad31e2120a00",
      "candidate_info": {
        "commit_hash": "ccfdb699bdb2e43979a780ead5baad31e2120a00",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/ccfdb699bdb2e43979a780ead5baad31e2120a00",
        "files": [
          "modules/clusterer/sharing_tags.c"
        ],
        "message": "clusterer: Always broadcast a packet after shtag activation\n\nDue to network outages, it is currently possible for both sharing tags\nof an Active/Backup pair to end up in ACTIVE state.  This patch makes it\nso a \"cluster_shtag_set_active\" MI command always broadcasts (forces)\nthe ACTIVE state onto all neighbours, thus fixing the incorrect,\npost-outage state of the tags.\n\nCredits to @bogdan-iancu and @rvlad-patrascu for their contributions to\nthis fix!\n\n(cherry picked from commit 77c24e2122ea6f66f251349e05984cfbdef9166c)",
        "before_after_code_files": [
          "modules/clusterer/sharing_tags.c||modules/clusterer/sharing_tags.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/clusterer/sharing_tags.c||modules/clusterer/sharing_tags.c": [
          "File: modules/clusterer/sharing_tags.c -> modules/clusterer/sharing_tags.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "584:  }",
          "585:  ret = (tag==NULL)? -1 : tag->state ;",
          "622:     lock_switch_write(shtags_lock, lock_old_flag);",
          "624:     lock_switch_read(shtags_lock, lock_old_flag);",
          "625:    }",
          "626:   }",
          "631:   shtag_run_callbacks( tag_name, SHTAG_STATE_ACTIVE, cluster_id);",
          "635:  return ret;",
          "636: }",
          "",
          "[Removed Lines]",
          "588:  if (ret==SHTAG_STATE_ACTIVE && old_state!=SHTAG_STATE_ACTIVE) {",
          "590:   cl = get_cluster_by_id(cluster_id);",
          "591:   if (!cl) {",
          "592:    LM_ERR(\"Bad cluster id: %d\\n\", cluster_id);",
          "593:    lock_stop_sw_read(shtags_lock);",
          "594:    return ret;",
          "595:   }",
          "598:   for (node = cl->node_list; node; node = node->next) {",
          "599:    if (tag->send_active_msg)",
          "600:     for (ni = tag->active_msgs_sent;",
          "601:      ni && ni->node_id != node->node_id; ni = ni->next) ;",
          "602:    if (!tag->send_active_msg || !ni) {",
          "603:     if (shtag_send_active_info(cluster_id,&tag->name,node->node_id)<0){",
          "604:      LM_ERR(\"Failed to send message about tag [%.*s/%d] \"",
          "605:       \"going active to node: %d\\n\", tag_name->len, tag_name->s,",
          "606:       cluster_id, node->node_id);",
          "608:      lock_switch_write(shtags_lock, lock_old_flag);",
          "609:      tag->send_active_msg = 1;",
          "610:      lock_switch_read(shtags_lock, lock_old_flag);",
          "612:      continue;",
          "613:     }",
          "614:     ni = shm_malloc(sizeof *ni);",
          "615:     if (!ni) {",
          "616:      LM_ERR(\"No more shm memory!\\n\");",
          "617:      lock_stop_sw_read(shtags_lock);",
          "618:      return ret;",
          "619:     }",
          "620:     ni->node_id = node->node_id;",
          "621:     ni->next = tag->active_msgs_sent;",
          "623:     tag->active_msgs_sent = ni;",
          "628:   lock_stop_sw_read(shtags_lock);",
          "632:  } else",
          "633:   lock_stop_sw_read(shtags_lock);",
          "",
          "[Added Lines]",
          "587:  cl = get_cluster_by_id(cluster_id);",
          "588:  if (!cl) {",
          "589:   LM_ERR(\"Bad cluster id: %d\\n\", cluster_id);",
          "590:   lock_stop_sw_read(shtags_lock);",
          "591:   return ret;",
          "592:  }",
          "595:  for (node = cl->node_list; node; node = node->next) {",
          "596:   if (tag->send_active_msg)",
          "597:    for (ni = tag->active_msgs_sent;",
          "598:     ni && ni->node_id != node->node_id; ni = ni->next) ;",
          "599:   if (!tag->send_active_msg || !ni) {",
          "600:    if (shtag_send_active_info(cluster_id,&tag->name,node->node_id)<0){",
          "601:     LM_ERR(\"Failed to send message about tag [%.*s/%d] \"",
          "602:      \"going active to node: %d\\n\", tag_name->len, tag_name->s,",
          "603:      cluster_id, node->node_id);",
          "606:     tag->send_active_msg = 1;",
          "609:     continue;",
          "610:    }",
          "611:    ni = shm_malloc(sizeof *ni);",
          "612:    if (!ni) {",
          "613:     LM_ERR(\"No more shm memory!\\n\");",
          "614:     lock_stop_sw_read(shtags_lock);",
          "615:     return ret;",
          "617:    ni->node_id = node->node_id;",
          "618:    ni->next = tag->active_msgs_sent;",
          "619:    lock_switch_write(shtags_lock, lock_old_flag);",
          "620:    tag->active_msgs_sent = ni;",
          "621:    lock_switch_read(shtags_lock, lock_old_flag);",
          "623:  }",
          "625:  lock_stop_sw_read(shtags_lock);",
          "628:  if (ret==SHTAG_STATE_ACTIVE && old_state!=SHTAG_STATE_ACTIVE)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
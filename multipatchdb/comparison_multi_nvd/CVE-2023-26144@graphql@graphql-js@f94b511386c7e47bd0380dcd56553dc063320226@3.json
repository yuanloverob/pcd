{
  "cve_id": "CVE-2023-26144",
  "cve_desc": "Versions of the package graphql from 16.3.0 and before 16.8.1 are vulnerable to Denial of Service (DoS) due to insufficient checks in the OverlappingFieldsCanBeMergedRule.ts file when parsing large queries. This vulnerability allows an attacker to degrade system performance.\r\r**Note:** It was not proven that this vulnerability can crash the process.",
  "repo": "graphql/graphql-js",
  "patch_hash": "f94b511386c7e47bd0380dcd56553dc063320226",
  "patch_info": {
    "commit_hash": "f94b511386c7e47bd0380dcd56553dc063320226",
    "repo": "graphql/graphql-js",
    "commit_url": "https://github.com/graphql/graphql-js/commit/f94b511386c7e47bd0380dcd56553dc063320226",
    "files": [
      "benchmark/repeated-fields-benchmark.js",
      "src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts",
      "src/validation/rules/OverlappingFieldsCanBeMergedRule.ts"
    ],
    "message": "OverlappingFieldsCanBeMergedRule: Fix performance degradation (#3958)\n\nCo-authored-by: AaronMoat <AaronMoat@users.noreply.github.com>\nCo-authored-by: Ivan Goncharov <ivan.goncharov.ua@gmail.com>\nResolves https://github.com/graphql/graphql-js/issues/3955 (at least",
    "before_after_code_files": [
      "benchmark/repeated-fields-benchmark.js||benchmark/repeated-fields-benchmark.js",
      "src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts||src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts",
      "src/validation/rules/OverlappingFieldsCanBeMergedRule.ts||src/validation/rules/OverlappingFieldsCanBeMergedRule.ts"
    ]
  },
  "patch_diff": {
    "benchmark/repeated-fields-benchmark.js||benchmark/repeated-fields-benchmark.js": [
      "File: benchmark/repeated-fields-benchmark.js -> benchmark/repeated-fields-benchmark.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: import { graphqlSync } from 'graphql/graphql.js';",
      "2: import { buildSchema } from 'graphql/utilities/buildASTSchema.js';",
      "4: const schema = buildSchema('type Query { hello: String! }');",
      "5: const source = `{ ${'hello '.repeat(250)}}`;",
      "7: export const benchmark = {",
      "8:   name: 'Many repeated fields',",
      "9:   count: 5,",
      "10:   measure() {",
      "11:     graphqlSync({ schema, source });",
      "12:   },",
      "13: };",
      "",
      "---------------"
    ],
    "src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts||src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts": [
      "File: src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts -> src/validation/__tests__/OverlappingFieldsCanBeMergedRule-test.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "179:     ]);",
      "180:   });",
      "182:   it('mix of stream and no stream', () => {",
      "183:     expectErrors(`",
      "184:       fragment conflictingArgs on Dog {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "182:   it('different stream directive extra argument', () => {",
      "183:     expectErrors(`",
      "184:       fragment conflictingArgs on Dog {",
      "185:         name @stream(label: \"streamLabel\", initialCount: 1)",
      "186:         name @stream(label: \"streamLabel\", initialCount: 1, extraArg: true)",
      "187:       }",
      "188:     `).toDeepEqual([",
      "189:       {",
      "190:         message:",
      "191:           'Fields \"name\" conflict because they have differing stream directives. Use different aliases on the fields to fetch both if this was intentional.',",
      "192:         locations: [",
      "193:           { line: 3, column: 9 },",
      "194:           { line: 4, column: 9 },",
      "195:         ],",
      "196:       },",
      "197:     ]);",
      "198:   });",
      "",
      "---------------"
    ],
    "src/validation/rules/OverlappingFieldsCanBeMergedRule.ts||src/validation/rules/OverlappingFieldsCanBeMergedRule.ts": [
      "File: src/validation/rules/OverlappingFieldsCanBeMergedRule.ts -> src/validation/rules/OverlappingFieldsCanBeMergedRule.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "7:   DirectiveNode,",
      "8:   FieldNode,",
      "9:   FragmentDefinitionNode,",
      "11:   SelectionSetNode,",
      "12: } from '../../language/ast.js';",
      "13: import { Kind } from '../../language/kinds.js';",
      "14: import { print } from '../../language/printer.js';",
      "",
      "[Removed Lines]",
      "10:   ObjectValueNode,",
      "",
      "[Added Lines]",
      "11:   ValueNode,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "592:     }",
      "596:       return [",
      "597:         [responseName, 'they have differing arguments'],",
      "598:         [node1],",
      "",
      "[Removed Lines]",
      "595:     if (stringifyArguments(node1) !== stringifyArguments(node2)) {",
      "",
      "[Added Lines]",
      "595:     if (!sameArguments(node1, node2)) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "649:   }",
      "650: }",
      "665: }",
      "667: function getStreamDirective(",
      "",
      "[Removed Lines]",
      "652: function stringifyArguments(fieldNode: FieldNode | DirectiveNode): string {",
      "654:   const args = /* c8 ignore next */ fieldNode.arguments ?? [];",
      "656:   const inputObjectWithArgs: ObjectValueNode = {",
      "657:     kind: Kind.OBJECT,",
      "658:     fields: args.map((argNode) => ({",
      "659:       kind: Kind.OBJECT_FIELD,",
      "660:       name: argNode.name,",
      "661:       value: argNode.value,",
      "662:     })),",
      "663:   };",
      "664:   return print(sortValueNode(inputObjectWithArgs));",
      "",
      "[Added Lines]",
      "652: function sameArguments(",
      "653:   node1: FieldNode | DirectiveNode,",
      "654:   node2: FieldNode | DirectiveNode,",
      "655: ): boolean {",
      "656:   const args1 = node1.arguments;",
      "657:   const args2 = node2.arguments;",
      "659:   if (args1 === undefined || args1.length === 0) {",
      "660:     return args2 === undefined || args2.length === 0;",
      "661:   }",
      "662:   if (args2 === undefined || args2.length === 0) {",
      "663:     return false;",
      "664:   }",
      "666:   if (args1.length !== args2.length) {",
      "667:     return false;",
      "668:   }",
      "670:   const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));",
      "671:   return args1.every((arg1) => {",
      "672:     const value1 = arg1.value;",
      "673:     const value2 = values2.get(arg1.name.value);",
      "674:     if (value2 === undefined) {",
      "675:       return false;",
      "676:     }",
      "678:     return stringifyValue(value1) === stringifyValue(value2);",
      "679:   });",
      "680: }",
      "682: function stringifyValue(value: ValueNode): string | null {",
      "683:   return print(sortValueNode(value));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "681:     return true;",
      "682:   } else if (stream1 && stream2) {",
      "685:   }",
      "687:   return false;",
      "",
      "[Removed Lines]",
      "684:     return stringifyArguments(stream1) === stringifyArguments(stream2);",
      "",
      "[Added Lines]",
      "703:     return sameArguments(stream1, stream2);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2aedf25e157d1d1c8fdfeaa4c0d2f3d9d3457dba",
      "candidate_info": {
        "commit_hash": "2aedf25e157d1d1c8fdfeaa4c0d2f3d9d3457dba",
        "repo": "graphql/graphql-js",
        "commit_url": "https://github.com/graphql/graphql-js/commit/2aedf25e157d1d1c8fdfeaa4c0d2f3d9d3457dba",
        "files": [
          "src/execution/IncrementalPublisher.ts",
          "src/execution/buildFieldPlan.ts",
          "src/execution/collectFields.ts",
          "src/execution/execute.ts",
          "src/validation/rules/SingleFieldSubscriptionsRule.ts"
        ],
        "message": "simplify CollectFields for `@defer` and `@stream` (#3994)\n\nminimizes the changes to `CollectFields` required for incremental delivery (inspired by #3982) -- but retains a single memoized incremental field plan per list item.",
        "before_after_code_files": [
          "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts",
          "src/execution/buildFieldPlan.ts||src/execution/buildFieldPlan.ts",
          "src/execution/collectFields.ts||src/execution/collectFields.ts",
          "src/execution/execute.ts||src/execution/execute.ts",
          "src/validation/rules/SingleFieldSubscriptionsRule.ts||src/validation/rules/SingleFieldSubscriptionsRule.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/graphql/graphql-js/pull/4388",
          "https://github.com/graphql/graphql-js/pull/4385",
          "https://github.com/graphql/graphql-js/pull/4386"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts": [
          "File: src/execution/IncrementalPublisher.ts -> src/execution/IncrementalPublisher.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:   GraphQLFormattedError,",
          "9: } from '../error/GraphQLError.js';",
          "13: interface IncrementalUpdate<TData = unknown, TExtensions = ObjMap<unknown>> {",
          "14:   pending: ReadonlyArray<PendingResult>;",
          "",
          "[Removed Lines]",
          "11: import type { GroupedFieldSet } from './collectFields.js';",
          "",
          "[Added Lines]",
          "11: import type { GroupedFieldSet } from './buildFieldPlan.js';",
          "",
          "---------------"
        ],
        "src/execution/buildFieldPlan.ts||src/execution/buildFieldPlan.ts": [
          "File: src/execution/buildFieldPlan.ts -> src/execution/buildFieldPlan.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import { getBySet } from '../jsutils/getBySet.js';",
          "2: import { isSameSet } from '../jsutils/isSameSet.js';",
          "4: import type { DeferUsage, FieldDetails } from './collectFields.js';",
          "6: export type DeferUsageSet = ReadonlySet<DeferUsage>;",
          "8: export interface FieldGroup {",
          "9:   fields: ReadonlyArray<FieldDetails>;",
          "10:   deferUsages?: DeferUsageSet | undefined;",
          "11:   knownDeferUsages?: DeferUsageSet | undefined;",
          "12: }",
          "14: export type GroupedFieldSet = Map<string, FieldGroup>;",
          "16: export interface NewGroupedFieldSetDetails {",
          "17:   groupedFieldSet: GroupedFieldSet;",
          "18:   shouldInitiateDefer: boolean;",
          "19: }",
          "21: export function buildFieldPlan(",
          "22:   fields: Map<string, ReadonlyArray<FieldDetails>>,",
          "23:   parentDeferUsages: DeferUsageSet = new Set<DeferUsage>(),",
          "24:   knownDeferUsages: DeferUsageSet = new Set<DeferUsage>(),",
          "25: ): {",
          "26:   groupedFieldSet: GroupedFieldSet;",
          "27:   newGroupedFieldSetDetailsMap: Map<DeferUsageSet, NewGroupedFieldSetDetails>;",
          "28:   newDeferUsages: ReadonlyArray<DeferUsage>;",
          "29: } {",
          "30:   const newDeferUsages: Set<DeferUsage> = new Set<DeferUsage>();",
          "31:   const newKnownDeferUsages = new Set<DeferUsage>(knownDeferUsages);",
          "33:   const groupedFieldSet = new Map<",
          "34:     string,",
          "35:     {",
          "36:       fields: Array<FieldDetails>;",
          "37:       deferUsages: DeferUsageSet;",
          "38:       knownDeferUsages: DeferUsageSet;",
          "39:     }",
          "40:   >();",
          "42:   const newGroupedFieldSetDetailsMap = new Map<",
          "43:     DeferUsageSet,",
          "44:     {",
          "45:       groupedFieldSet: Map<",
          "46:         string,",
          "47:         {",
          "48:           fields: Array<FieldDetails>;",
          "49:           deferUsages: DeferUsageSet;",
          "50:           knownDeferUsages: DeferUsageSet;",
          "51:         }",
          "52:       >;",
          "53:       shouldInitiateDefer: boolean;",
          "54:     }",
          "55:   >();",
          "57:   const map = new Map<",
          "58:     string,",
          "59:     {",
          "60:       deferUsageSet: DeferUsageSet;",
          "61:       fieldDetailsList: ReadonlyArray<FieldDetails>;",
          "62:     }",
          "63:   >();",
          "65:   for (const [responseKey, fieldDetailsList] of fields) {",
          "66:     const deferUsageSet = new Set<DeferUsage>();",
          "67:     let inOriginalResult = false;",
          "68:     for (const fieldDetails of fieldDetailsList) {",
          "69:       const deferUsage = fieldDetails.deferUsage;",
          "70:       if (deferUsage === undefined) {",
          "71:         inOriginalResult = true;",
          "72:         continue;",
          "73:       }",
          "74:       deferUsageSet.add(deferUsage);",
          "75:       if (!knownDeferUsages.has(deferUsage)) {",
          "76:         newDeferUsages.add(deferUsage);",
          "77:         newKnownDeferUsages.add(deferUsage);",
          "78:       }",
          "79:     }",
          "80:     if (inOriginalResult) {",
          "81:       deferUsageSet.clear();",
          "82:     } else {",
          "83:       deferUsageSet.forEach((deferUsage) => {",
          "84:         const ancestors = getAncestors(deferUsage);",
          "85:         for (const ancestor of ancestors) {",
          "86:           if (deferUsageSet.has(ancestor)) {",
          "87:             deferUsageSet.delete(deferUsage);",
          "88:           }",
          "89:         }",
          "90:       });",
          "91:     }",
          "92:     map.set(responseKey, { deferUsageSet, fieldDetailsList });",
          "93:   }",
          "95:   for (const [responseKey, { deferUsageSet, fieldDetailsList }] of map) {",
          "96:     if (isSameSet(deferUsageSet, parentDeferUsages)) {",
          "97:       let fieldGroup = groupedFieldSet.get(responseKey);",
          "98:       if (fieldGroup === undefined) {",
          "99:         fieldGroup = {",
          "100:           fields: [],",
          "101:           deferUsages: deferUsageSet,",
          "102:           knownDeferUsages: newKnownDeferUsages,",
          "103:         };",
          "104:         groupedFieldSet.set(responseKey, fieldGroup);",
          "105:       }",
          "106:       fieldGroup.fields.push(...fieldDetailsList);",
          "107:       continue;",
          "108:     }",
          "110:     let newGroupedFieldSetDetails = getBySet(",
          "111:       newGroupedFieldSetDetailsMap,",
          "112:       deferUsageSet,",
          "113:     );",
          "114:     let newGroupedFieldSet;",
          "115:     if (newGroupedFieldSetDetails === undefined) {",
          "116:       newGroupedFieldSet = new Map<",
          "117:         string,",
          "118:         {",
          "119:           fields: Array<FieldDetails>;",
          "120:           deferUsages: DeferUsageSet;",
          "121:           knownDeferUsages: DeferUsageSet;",
          "122:         }",
          "123:       >();",
          "125:       newGroupedFieldSetDetails = {",
          "126:         groupedFieldSet: newGroupedFieldSet,",
          "127:         shouldInitiateDefer: Array.from(deferUsageSet).some(",
          "128:           (deferUsage) => !parentDeferUsages.has(deferUsage),",
          "129:         ),",
          "130:       };",
          "131:       newGroupedFieldSetDetailsMap.set(",
          "132:         deferUsageSet,",
          "133:         newGroupedFieldSetDetails,",
          "134:       );",
          "135:     } else {",
          "136:       newGroupedFieldSet = newGroupedFieldSetDetails.groupedFieldSet;",
          "137:     }",
          "138:     let fieldGroup = newGroupedFieldSet.get(responseKey);",
          "139:     if (fieldGroup === undefined) {",
          "140:       fieldGroup = {",
          "141:         fields: [],",
          "142:         deferUsages: deferUsageSet,",
          "143:         knownDeferUsages: newKnownDeferUsages,",
          "144:       };",
          "145:       newGroupedFieldSet.set(responseKey, fieldGroup);",
          "146:     }",
          "147:     fieldGroup.fields.push(...fieldDetailsList);",
          "148:   }",
          "150:   return {",
          "151:     groupedFieldSet,",
          "152:     newGroupedFieldSetDetailsMap,",
          "153:     newDeferUsages: Array.from(newDeferUsages),",
          "154:   };",
          "155: }",
          "157: function getAncestors(deferUsage: DeferUsage): ReadonlyArray<DeferUsage> {",
          "158:   const ancestors: Array<DeferUsage> = [];",
          "159:   let parentDeferUsage: DeferUsage | undefined = deferUsage.parentDeferUsage;",
          "160:   while (parentDeferUsage !== undefined) {",
          "161:     ancestors.unshift(parentDeferUsage);",
          "162:     parentDeferUsage = parentDeferUsage.parentDeferUsage;",
          "163:   }",
          "164:   return ancestors;",
          "165: }",
          "",
          "---------------"
        ],
        "src/execution/collectFields.ts||src/execution/collectFields.ts": [
          "File: src/execution/collectFields.ts -> src/execution/collectFields.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';",
          "3: import { invariant } from '../jsutils/invariant.js';",
          "5: import type { ObjMap } from '../jsutils/ObjMap.js';",
          "7: import type {",
          "",
          "[Removed Lines]",
          "2: import { getBySet } from '../jsutils/getBySet.js';",
          "4: import { isSameSet } from '../jsutils/isSameSet.js';",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: export interface DeferUsage {",
          "32:   label: string | undefined;",
          "34: }",
          "42: export interface FieldDetails {",
          "43:   node: FieldNode;",
          "63: }",
          "65: interface CollectFieldsContext {",
          "",
          "[Removed Lines]",
          "33:   ancestors: ReadonlyArray<Target>;",
          "36: export const NON_DEFERRED_TARGET_SET: TargetSet = new Set<Target>([undefined]);",
          "38: export type Target = DeferUsage | undefined;",
          "39: export type TargetSet = ReadonlySet<Target>;",
          "40: export type DeferUsageSet = ReadonlySet<DeferUsage>;",
          "44:   target: Target;",
          "45: }",
          "47: export interface FieldGroup {",
          "48:   fields: ReadonlyArray<FieldDetails>;",
          "49:   targets: TargetSet;",
          "50: }",
          "52: export type GroupedFieldSet = Map<string, FieldGroup>;",
          "54: export interface GroupedFieldSetDetails {",
          "55:   groupedFieldSet: GroupedFieldSet;",
          "56:   shouldInitiateDefer: boolean;",
          "57: }",
          "59: export interface CollectFieldsResult {",
          "60:   groupedFieldSet: GroupedFieldSet;",
          "61:   newGroupedFieldSetDetails: Map<DeferUsageSet, GroupedFieldSetDetails>;",
          "62:   newDeferUsages: ReadonlyArray<DeferUsage>;",
          "",
          "[Added Lines]",
          "31:   parentDeferUsage: DeferUsage | undefined;",
          "36:   deferUsage: DeferUsage | undefined;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "68:   variableValues: { [variable: string]: unknown };",
          "69:   operation: OperationDefinitionNode;",
          "70:   runtimeType: GraphQLObjectType;",
          "74:   visitedFragmentNames: Set<string>;",
          "75: }",
          "",
          "[Removed Lines]",
          "71:   targetsByKey: Map<string, Set<Target>>;",
          "72:   fieldsByTarget: Map<Target, AccumulatorMap<string, FieldNode>>;",
          "73:   newDeferUsages: Array<DeferUsage>;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89:   variableValues: { [variable: string]: unknown },",
          "90:   runtimeType: GraphQLObjectType,",
          "91:   operation: OperationDefinitionNode,",
          "93:   const context: CollectFieldsContext = {",
          "94:     schema,",
          "95:     fragments,",
          "96:     variableValues,",
          "97:     runtimeType,",
          "98:     operation,",
          "102:     visitedFragmentNames: new Set(),",
          "103:   };",
          "111: }",
          "",
          "[Removed Lines]",
          "92: ): CollectFieldsResult {",
          "99:     fieldsByTarget: new Map(),",
          "100:     targetsByKey: new Map(),",
          "101:     newDeferUsages: [],",
          "105:   collectFieldsImpl(context, operation.selectionSet);",
          "107:   return {",
          "108:     ...buildGroupedFieldSets(context.targetsByKey, context.fieldsByTarget),",
          "109:     newDeferUsages: context.newDeferUsages,",
          "110:   };",
          "",
          "[Added Lines]",
          "63: ): Map<string, ReadonlyArray<FieldDetails>> {",
          "64:   const groupedFieldSet = new AccumulatorMap<string, FieldDetails>();",
          "74:   collectFieldsImpl(context, operation.selectionSet, groupedFieldSet);",
          "75:   return groupedFieldSet;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "127:   variableValues: { [variable: string]: unknown },",
          "128:   operation: OperationDefinitionNode,",
          "129:   returnType: GraphQLObjectType,",
          "132:   const context: CollectFieldsContext = {",
          "133:     schema,",
          "134:     fragments,",
          "135:     variableValues,",
          "136:     runtimeType: returnType,",
          "137:     operation,",
          "141:     visitedFragmentNames: new Set(),",
          "142:   };",
          "146:     if (node.selectionSet) {",
          "148:     }",
          "149:   }",
          "159: }",
          "161: function collectFieldsImpl(",
          "162:   context: CollectFieldsContext,",
          "163:   selectionSet: SelectionSetNode,",
          "166: ): void {",
          "167:   const {",
          "168:     schema,",
          "",
          "[Removed Lines]",
          "130:   fieldGroup: FieldGroup,",
          "131: ): CollectFieldsResult {",
          "138:     fieldsByTarget: new Map(),",
          "139:     targetsByKey: new Map(),",
          "140:     newDeferUsages: [],",
          "144:   for (const fieldDetails of fieldGroup.fields) {",
          "145:     const node = fieldDetails.node;",
          "147:       collectFieldsImpl(context, node.selectionSet, fieldDetails.target);",
          "151:   return {",
          "152:     ...buildGroupedFieldSets(",
          "153:       context.targetsByKey,",
          "154:       context.fieldsByTarget,",
          "155:       fieldGroup.targets,",
          "156:     ),",
          "157:     newDeferUsages: context.newDeferUsages,",
          "158:   };",
          "164:   parentTarget?: Target,",
          "165:   newTarget?: Target,",
          "",
          "[Added Lines]",
          "95:   fieldDetails: ReadonlyArray<FieldDetails>,",
          "96: ): Map<string, ReadonlyArray<FieldDetails>> {",
          "105:   const subGroupedFieldSet = new AccumulatorMap<string, FieldDetails>();",
          "107:   for (const fieldDetail of fieldDetails) {",
          "108:     const node = fieldDetail.node;",
          "110:       collectFieldsImpl(",
          "111:         context,",
          "112:         node.selectionSet,",
          "113:         subGroupedFieldSet,",
          "114:         fieldDetail.deferUsage,",
          "115:       );",
          "119:   return subGroupedFieldSet;",
          "125:   groupedFieldSet: AccumulatorMap<string, FieldDetails>,",
          "126:   parentDeferUsage?: DeferUsage,",
          "127:   deferUsage?: DeferUsage,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "170:     variableValues,",
          "171:     runtimeType,",
          "172:     operation,",
          "176:     visitedFragmentNames,",
          "177:   } = context;",
          "",
          "[Removed Lines]",
          "173:     targetsByKey,",
          "174:     fieldsByTarget,",
          "175:     newDeferUsages,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "182:         if (!shouldIncludeNode(variableValues, selection)) {",
          "183:           continue;",
          "184:         }",
          "199:         break;",
          "200:       }",
          "201:       case Kind.INLINE_FRAGMENT: {",
          "",
          "[Removed Lines]",
          "185:         const key = getFieldEntryKey(selection);",
          "186:         const target = newTarget ?? parentTarget;",
          "187:         let keyTargets = targetsByKey.get(key);",
          "188:         if (keyTargets === undefined) {",
          "189:           keyTargets = new Set();",
          "190:           targetsByKey.set(key, keyTargets);",
          "191:         }",
          "192:         keyTargets.add(target);",
          "193:         let targetFields = fieldsByTarget.get(target);",
          "194:         if (targetFields === undefined) {",
          "195:           targetFields = new AccumulatorMap();",
          "196:           fieldsByTarget.set(target, targetFields);",
          "197:         }",
          "198:         targetFields.add(key, selection);",
          "",
          "[Added Lines]",
          "144:         groupedFieldSet.add(getFieldEntryKey(selection), {",
          "145:           node: selection,",
          "146:           deferUsage: deferUsage ?? parentDeferUsage,",
          "147:         });",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "206:           continue;",
          "207:         }",
          "223:         collectFieldsImpl(",
          "224:           context,",
          "225:           selection.selectionSet,",
          "228:         );",
          "230:         break;",
          "",
          "[Removed Lines]",
          "209:         const defer = getDeferValues(operation, variableValues, selection);",
          "211:         let target: Target;",
          "212:         if (!defer) {",
          "213:           target = newTarget;",
          "214:         } else {",
          "215:           const ancestors =",
          "216:             parentTarget === undefined",
          "217:               ? [parentTarget]",
          "218:               : [parentTarget, ...parentTarget.ancestors];",
          "219:           target = { ...defer, ancestors };",
          "220:           newDeferUsages.push(target);",
          "221:         }",
          "226:           parentTarget,",
          "227:           target,",
          "",
          "[Added Lines]",
          "158:         const newDeferUsage = getDeferUsage(",
          "159:           operation,",
          "160:           variableValues,",
          "161:           selection,",
          "162:           parentDeferUsage,",
          "163:         );",
          "168:           groupedFieldSet,",
          "169:           parentDeferUsage,",
          "170:           newDeferUsage ?? deferUsage,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "232:       case Kind.FRAGMENT_SPREAD: {",
          "233:         const fragName = selection.name.value;",
          "241:           continue;",
          "242:         }",
          "",
          "[Removed Lines]",
          "235:         if (!shouldIncludeNode(variableValues, selection)) {",
          "236:           continue;",
          "237:         }",
          "239:         const defer = getDeferValues(operation, variableValues, selection);",
          "240:         if (visitedFragmentNames.has(fragName) && !defer) {",
          "",
          "[Added Lines]",
          "178:         const newDeferUsage = getDeferUsage(",
          "179:           operation,",
          "180:           variableValues,",
          "181:           selection,",
          "182:           parentDeferUsage,",
          "183:         );",
          "185:         if (",
          "186:           !newDeferUsage &&",
          "187:           (visitedFragmentNames.has(fragName) ||",
          "188:             !shouldIncludeNode(variableValues, selection))",
          "189:         ) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "248:         ) {",
          "249:           continue;",
          "250:         }",
          "254:           visitedFragmentNames.add(fragName);",
          "263:         }",
          "266:         break;",
          "267:       }",
          "268:     }",
          "",
          "[Removed Lines]",
          "252:         let target: Target;",
          "253:         if (!defer) {",
          "255:           target = newTarget;",
          "256:         } else {",
          "257:           const ancestors =",
          "258:             parentTarget === undefined",
          "259:               ? [parentTarget]",
          "260:               : [parentTarget, ...parentTarget.ancestors];",
          "261:           target = { ...defer, ancestors };",
          "262:           newDeferUsages.push(target);",
          "265:         collectFieldsImpl(context, fragment.selectionSet, parentTarget, target);",
          "",
          "[Added Lines]",
          "200:         if (!newDeferUsage) {",
          "204:         collectFieldsImpl(",
          "205:           context,",
          "206:           fragment.selectionSet,",
          "207:           groupedFieldSet,",
          "208:           parentDeferUsage,",
          "209:           newDeferUsage ?? deferUsage,",
          "210:         );",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "278:   operation: OperationDefinitionNode,",
          "279:   variableValues: { [variable: string]: unknown },",
          "280:   node: FragmentSpreadNode | InlineFragmentNode,",
          "282:   const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);",
          "284:   if (!defer) {",
          "",
          "[Removed Lines]",
          "277: function getDeferValues(",
          "281: ): undefined | { label: string | undefined } {",
          "",
          "[Added Lines]",
          "222: function getDeferUsage(",
          "226:   parentDeferUsage: DeferUsage | undefined,",
          "227: ): DeferUsage | undefined {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "297:   return {",
          "298:     label: typeof defer.label === 'string' ? defer.label : undefined,",
          "299:   };",
          "300: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "245:     parentDeferUsage,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "351: function getFieldEntryKey(node: FieldNode): string {",
          "352:   return node.alias ? node.alias.value : node.name.value;",
          "353: }",
          "",
          "[Removed Lines]",
          "355: function buildGroupedFieldSets(",
          "356:   targetsByKey: Map<string, Set<Target>>,",
          "357:   fieldsByTarget: Map<Target, Map<string, ReadonlyArray<FieldNode>>>,",
          "358:   parentTargets = NON_DEFERRED_TARGET_SET,",
          "359: ): {",
          "360:   groupedFieldSet: GroupedFieldSet;",
          "361:   newGroupedFieldSetDetails: Map<DeferUsageSet, GroupedFieldSetDetails>;",
          "362: } {",
          "363:   const { parentTargetKeys, targetSetDetailsMap } = getTargetSetDetails(",
          "364:     targetsByKey,",
          "365:     parentTargets,",
          "366:   );",
          "368:   const groupedFieldSet =",
          "369:     parentTargetKeys.size > 0",
          "370:       ? getOrderedGroupedFieldSet(",
          "371:           parentTargetKeys,",
          "372:           parentTargets,",
          "373:           targetsByKey,",
          "374:           fieldsByTarget,",
          "375:         )",
          "376:       : new Map();",
          "378:   const newGroupedFieldSetDetails = new Map<",
          "379:     DeferUsageSet,",
          "380:     GroupedFieldSetDetails",
          "381:   >();",
          "383:   for (const [maskingTargets, targetSetDetails] of targetSetDetailsMap) {",
          "384:     const { keys, shouldInitiateDefer } = targetSetDetails;",
          "386:     const newGroupedFieldSet = getOrderedGroupedFieldSet(",
          "387:       keys,",
          "388:       maskingTargets,",
          "389:       targetsByKey,",
          "390:       fieldsByTarget,",
          "391:     );",
          "395:     newGroupedFieldSetDetails.set(maskingTargets as DeferUsageSet, {",
          "396:       groupedFieldSet: newGroupedFieldSet,",
          "397:       shouldInitiateDefer,",
          "398:     });",
          "399:   }",
          "401:   return {",
          "402:     groupedFieldSet,",
          "403:     newGroupedFieldSetDetails,",
          "404:   };",
          "405: }",
          "407: interface TargetSetDetails {",
          "408:   keys: Set<string>;",
          "409:   shouldInitiateDefer: boolean;",
          "410: }",
          "412: function getTargetSetDetails(",
          "413:   targetsByKey: Map<string, Set<Target>>,",
          "414:   parentTargets: TargetSet,",
          "415: ): {",
          "416:   parentTargetKeys: ReadonlySet<string>;",
          "417:   targetSetDetailsMap: Map<TargetSet, TargetSetDetails>;",
          "418: } {",
          "419:   const parentTargetKeys = new Set<string>();",
          "420:   const targetSetDetailsMap = new Map<TargetSet, TargetSetDetails>();",
          "422:   for (const [responseKey, targets] of targetsByKey) {",
          "423:     const maskingTargetList: Array<Target> = [];",
          "424:     for (const target of targets) {",
          "425:       if (",
          "426:         target === undefined ||",
          "427:         target.ancestors.every((ancestor) => !targets.has(ancestor))",
          "428:       ) {",
          "429:         maskingTargetList.push(target);",
          "430:       }",
          "431:     }",
          "433:     const maskingTargets: TargetSet = new Set<Target>(maskingTargetList);",
          "434:     if (isSameSet(maskingTargets, parentTargets)) {",
          "435:       parentTargetKeys.add(responseKey);",
          "436:       continue;",
          "437:     }",
          "439:     let targetSetDetails = getBySet(targetSetDetailsMap, maskingTargets);",
          "440:     if (targetSetDetails === undefined) {",
          "441:       targetSetDetails = {",
          "442:         keys: new Set(),",
          "443:         shouldInitiateDefer: maskingTargetList.some(",
          "444:           (deferUsage) => !parentTargets.has(deferUsage),",
          "445:         ),",
          "446:       };",
          "447:       targetSetDetailsMap.set(maskingTargets, targetSetDetails);",
          "448:     }",
          "449:     targetSetDetails.keys.add(responseKey);",
          "450:   }",
          "452:   return {",
          "453:     parentTargetKeys,",
          "454:     targetSetDetailsMap,",
          "455:   };",
          "456: }",
          "458: function getOrderedGroupedFieldSet(",
          "459:   keys: ReadonlySet<string>,",
          "460:   maskingTargets: TargetSet,",
          "461:   targetsByKey: Map<string, Set<Target>>,",
          "462:   fieldsByTarget: Map<Target, Map<string, ReadonlyArray<FieldNode>>>,",
          "463: ): GroupedFieldSet {",
          "464:   const groupedFieldSet = new Map<",
          "465:     string,",
          "466:     { fields: Array<FieldDetails>; targets: TargetSet }",
          "467:   >();",
          "469:   const firstTarget = maskingTargets.values().next().value as Target;",
          "471:   const firstFields = fieldsByTarget.get(firstTarget)!;",
          "472:   for (const [key] of firstFields) {",
          "473:     if (keys.has(key)) {",
          "474:       let fieldGroup = groupedFieldSet.get(key);",
          "475:       if (fieldGroup === undefined) {",
          "476:         fieldGroup = { fields: [], targets: maskingTargets };",
          "477:         groupedFieldSet.set(key, fieldGroup);",
          "478:       }",
          "480:       for (const target of targetsByKey.get(key)!) {",
          "482:         const fieldsForTarget = fieldsByTarget.get(target)!;",
          "484:         const nodes = fieldsForTarget.get(key)!;",
          "486:         fieldsForTarget.delete(key);",
          "487:         fieldGroup.fields.push(...nodes.map((node) => ({ node, target })));",
          "488:       }",
          "489:     }",
          "490:   }",
          "492:   return groupedFieldSet;",
          "493: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/execution/execute.ts||src/execution/execute.ts": [
          "File: src/execution/execute.ts -> src/execution/execute.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: import { assertValidSchema } from '../type/validate.js';",
          "50: import type {",
          "52:   DeferUsageSet,",
          "53:   FieldGroup,",
          "54:   GroupedFieldSet,",
          "62: import type {",
          "63:   ExecutionResult,",
          "64:   ExperimentalIncrementalExecutionResults,",
          "",
          "[Removed Lines]",
          "51:   DeferUsage,",
          "55:   GroupedFieldSetDetails,",
          "56: } from './collectFields.js';",
          "57: import {",
          "58:   collectFields,",
          "59:   collectSubfields as _collectSubfields,",
          "60:   NON_DEFERRED_TARGET_SET,",
          "61: } from './collectFields.js';",
          "",
          "[Added Lines]",
          "54:   NewGroupedFieldSetDetails,",
          "55: } from './buildFieldPlan.js';",
          "56: import { buildFieldPlan } from './buildFieldPlan.js';",
          "57: import type { DeferUsage, FieldDetails } from './collectFields.js';",
          "58: import { collectFields, collectSubfields } from './collectFields.js';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:   (",
          "93:     exeContext: ExecutionContext,",
          "94:     returnType: GraphQLObjectType,",
          "95:     fieldGroup: FieldGroup,",
          "98:       exeContext.schema,",
          "99:       exeContext.fragments,",
          "100:       exeContext.variableValues,",
          "101:       exeContext.operation,",
          "102:       returnType,",
          "105: );",
          "",
          "[Removed Lines]",
          "91: const collectSubfields = memoize3(",
          "96:   ) =>",
          "97:     _collectSubfields(",
          "103:       fieldGroup,",
          "104:     ),",
          "",
          "[Added Lines]",
          "88: const buildSubFieldPlan = memoize3(",
          "93:   ) => {",
          "94:     const subFields = collectSubfields(",
          "100:       fieldGroup.fields,",
          "101:     );",
          "102:     return buildFieldPlan(",
          "103:       subFields,",
          "104:       fieldGroup.deferUsages,",
          "105:       fieldGroup.knownDeferUsages,",
          "106:     );",
          "107:   },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "405:     );",
          "406:   }",
          "411:   const newDeferMap = addNewDeferredFragments(",
          "412:     incrementalPublisher,",
          "",
          "[Removed Lines]",
          "408:   const { groupedFieldSet, newGroupedFieldSetDetails, newDeferUsages } =",
          "409:     collectFields(schema, fragments, variableValues, rootType, operation);",
          "",
          "[Added Lines]",
          "411:   const fields = collectFields(",
          "412:     schema,",
          "413:     fragments,",
          "414:     variableValues,",
          "415:     rootType,",
          "416:     operation,",
          "417:   );",
          "418:   const { groupedFieldSet, newGroupedFieldSetDetailsMap, newDeferUsages } =",
          "419:     buildFieldPlan(fields);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "419:   const newDeferredGroupedFieldSetRecords = addNewDeferredGroupedFieldSets(",
          "420:     incrementalPublisher,",
          "422:     newDeferMap,",
          "423:     path,",
          "424:   );",
          "",
          "[Removed Lines]",
          "421:     newGroupedFieldSetDetails,",
          "",
          "[Added Lines]",
          "431:     newGroupedFieldSetDetailsMap,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "603:   const info = buildResolveInfo(",
          "604:     exeContext,",
          "605:     fieldDef,",
          "607:     parentType,",
          "608:     path,",
          "609:   );",
          "",
          "[Removed Lines]",
          "606:     fieldGroup,",
          "",
          "[Added Lines]",
          "616:     toNodes(fieldGroup),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "688: export function buildResolveInfo(",
          "689:   exeContext: ExecutionContext,",
          "690:   fieldDef: GraphQLField<unknown, unknown>,",
          "692:   parentType: GraphQLObjectType,",
          "693:   path: Path,",
          "694: ): GraphQLResolveInfo {",
          "",
          "[Removed Lines]",
          "691:   fieldGroup: FieldGroup,",
          "",
          "[Added Lines]",
          "701:   fieldNodes: ReadonlyArray<FieldNode>,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "697:   return {",
          "698:     fieldName: fieldDef.name,",
          "700:     returnType: fieldDef.type,",
          "701:     parentType,",
          "702:     path,",
          "",
          "[Removed Lines]",
          "699:     fieldNodes: toNodes(fieldGroup),",
          "",
          "[Added Lines]",
          "709:     fieldNodes,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "946:   const streamedFieldGroup: FieldGroup = {",
          "947:     fields: fieldGroup.fields.map((fieldDetails) => ({",
          "948:       node: fieldDetails.node,",
          "950:     })),",
          "952:   };",
          "954:   const streamUsage = {",
          "",
          "[Removed Lines]",
          "949:       target: undefined,",
          "951:     targets: NON_DEFERRED_TARGET_SET,",
          "",
          "[Added Lines]",
          "959:       deferUsage: undefined,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1457:   for (const newDeferUsage of newDeferUsages) {",
          "1466:     const parent =",
          "1468:         ? (incrementalDataRecord as InitialResultRecord | StreamItemsRecord)",
          "1472:     const deferredFragmentRecord = new DeferredFragmentRecord({",
          "",
          "[Removed Lines]",
          "1459:     const parentTarget = newDeferUsage.ancestors[0];",
          "1467:       parentTarget === undefined",
          "1469:         : deferredFragmentRecordFromDeferUsage(parentTarget, newDeferMap);",
          "",
          "[Added Lines]",
          "1467:     const parentDeferUsage = newDeferUsage.parentDeferUsage;",
          "1473:       parentDeferUsage === undefined",
          "1475:         : deferredFragmentRecordFromDeferUsage(parentDeferUsage, newDeferMap);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1498: function addNewDeferredGroupedFieldSets(",
          "1499:   incrementalPublisher: IncrementalPublisher,",
          "1501:   deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,",
          "1502:   path?: Path | undefined,",
          "1503: ): ReadonlyArray<DeferredGroupedFieldSetRecord> {",
          "",
          "[Removed Lines]",
          "1500:   newGroupedFieldSetDetails: Map<DeferUsageSet, GroupedFieldSetDetails>,",
          "",
          "[Added Lines]",
          "1506:   newGroupedFieldSetDetailsMap: Map<DeferUsageSet, NewGroupedFieldSetDetails>,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1505:     [];",
          "1507:   for (const [",
          "1509:     { groupedFieldSet, shouldInitiateDefer },",
          "1511:     const deferredFragmentRecords = getDeferredFragmentRecords(",
          "1513:       deferMap,",
          "1514:     );",
          "1515:     const deferredGroupedFieldSetRecord = new DeferredGroupedFieldSetRecord({",
          "",
          "[Removed Lines]",
          "1508:     newGroupedFieldSetDeferUsages,",
          "1510:   ] of newGroupedFieldSetDetails) {",
          "1512:       newGroupedFieldSetDeferUsages,",
          "",
          "[Added Lines]",
          "1514:     deferUsageSet,",
          "1516:   ] of newGroupedFieldSetDetailsMap) {",
          "1518:       deferUsageSet,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1546:   deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,",
          "1547: ): PromiseOrValue<ObjMap<unknown>> {",
          "1552:   const incrementalPublisher = exeContext.incrementalPublisher;",
          "",
          "[Removed Lines]",
          "1549:   const { groupedFieldSet, newGroupedFieldSetDetails, newDeferUsages } =",
          "1550:     collectSubfields(exeContext, returnType, fieldGroup);",
          "",
          "[Added Lines]",
          "1555:   const { groupedFieldSet, newGroupedFieldSetDetailsMap, newDeferUsages } =",
          "1556:     buildSubFieldPlan(exeContext, returnType, fieldGroup);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1562:   const newDeferredGroupedFieldSetRecords = addNewDeferredGroupedFieldSets(",
          "1563:     incrementalPublisher,",
          "1565:     newDeferMap,",
          "1566:     path,",
          "1567:   );",
          "",
          "[Removed Lines]",
          "1564:     newGroupedFieldSetDetails,",
          "",
          "[Added Lines]",
          "1570:     newGroupedFieldSetDetailsMap,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1801:     );",
          "1802:   }",
          "1805:     schema,",
          "1806:     fragments,",
          "1807:     variableValues,",
          "",
          "[Removed Lines]",
          "1804:   const { groupedFieldSet } = collectFields(",
          "",
          "[Added Lines]",
          "1810:   const fields = collectFields(",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1809:     operation,",
          "1810:   );",
          "1813:     string,",
          "1815:   ];",
          "1818:   const fieldDef = schema.getField(rootType, fieldName);",
          "1820:   if (!fieldDef) {",
          "1821:     throw new GraphQLError(",
          "1822:       `The subscription field \"${fieldName}\" is not defined.`,",
          "1824:     );",
          "1825:   }",
          "",
          "[Removed Lines]",
          "1812:   const firstRootField = groupedFieldSet.entries().next().value as [",
          "1814:     FieldGroup,",
          "1816:   const [responseName, fieldGroup] = firstRootField;",
          "1817:   const fieldName = fieldGroup.fields[0].node.name.value;",
          "1823:       { nodes: toNodes(fieldGroup) },",
          "",
          "[Added Lines]",
          "1818:   const firstRootField = fields.entries().next().value as [",
          "1820:     ReadonlyArray<FieldDetails>,",
          "1822:   const [responseName, fieldDetailsList] = firstRootField;",
          "1823:   const fieldName = fieldDetailsList[0].node.name.value;",
          "1826:   const fieldNodes = fieldDetailsList.map((fieldDetails) => fieldDetails.node);",
          "1830:       { nodes: fieldNodes },",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1828:   const info = buildResolveInfo(",
          "1829:     exeContext,",
          "1830:     fieldDef,",
          "1832:     rootType,",
          "1833:     path,",
          "1834:   );",
          "",
          "[Removed Lines]",
          "1831:     fieldGroup,",
          "",
          "[Added Lines]",
          "1838:     fieldNodes,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1842:     const args = getArgumentValues(",
          "1843:       fieldDef,",
          "1844:       fieldGroup.fields[0].node,",
          "1845:       variableValues,",
          "1846:     );",
          "",
          "[Added Lines]",
          "1849:     const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1858:     if (isPromise(result)) {",
          "1859:       return result.then(assertEventStream).then(undefined, (error) => {",
          "1861:       });",
          "1862:     }",
          "1864:     return assertEventStream(result);",
          "1865:   } catch (error) {",
          "1867:   }",
          "1868: }",
          "",
          "[Removed Lines]",
          "1860:         throw locatedError(error, toNodes(fieldGroup), pathToArray(path));",
          "1866:     throw locatedError(error, toNodes(fieldGroup), pathToArray(path));",
          "",
          "[Added Lines]",
          "1863:         throw locatedError(error, fieldNodes, pathToArray(path));",
          "1869:     throw locatedError(error, fieldNodes, pathToArray(path));",
          "",
          "---------------"
        ],
        "src/validation/rules/SingleFieldSubscriptionsRule.ts||src/validation/rules/SingleFieldSubscriptionsRule.ts": [
          "File: src/validation/rules/SingleFieldSubscriptionsRule.ts -> src/validation/rules/SingleFieldSubscriptionsRule.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: import { Kind } from '../../language/kinds.js';",
          "11: import type { ASTVisitor } from '../../language/visitor.js';",
          "14: import { collectFields } from '../../execution/collectFields.js';",
          "16: import type { ValidationContext } from '../ValidationContext.js';",
          "20: }",
          "",
          "[Removed Lines]",
          "13: import type { FieldGroup } from '../../execution/collectFields.js';",
          "18: function toNodes(fieldGroup: FieldGroup): ReadonlyArray<FieldNode> {",
          "19:   return fieldGroup.fields.map((fieldDetails) => fieldDetails.node);",
          "",
          "[Added Lines]",
          "13: import type { FieldDetails } from '../../execution/collectFields.js';",
          "18: function toNodes(",
          "19:   fieldDetailsList: ReadonlyArray<FieldDetails>,",
          "20: ): ReadonlyArray<FieldNode> {",
          "21:   return fieldDetailsList.map((fieldDetails) => fieldDetails.node);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:               fragments[definition.name.value] = definition;",
          "48:             }",
          "49:           }",
          "51:             schema,",
          "52:             fragments,",
          "53:             variableValues,",
          "54:             subscriptionType,",
          "55:             node,",
          "56:           );",
          "59:             const extraFieldGroups = fieldGroups.slice(1);",
          "60:             const extraFieldSelections = extraFieldGroups.flatMap(",
          "61:               (fieldGroup) => toNodes(fieldGroup),",
          "",
          "[Removed Lines]",
          "50:           const { groupedFieldSet } = collectFields(",
          "57:           if (groupedFieldSet.size > 1) {",
          "58:             const fieldGroups = [...groupedFieldSet.values()];",
          "",
          "[Added Lines]",
          "52:           const fields = collectFields(",
          "59:           if (fields.size > 1) {",
          "60:             const fieldGroups = [...fields.values()];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69:               ),",
          "70:             );",
          "71:           }",
          "73:             const fieldName = toNodes(fieldGroup)[0].name.value;",
          "74:             if (fieldName.startsWith('__')) {",
          "75:               context.reportError(",
          "",
          "[Removed Lines]",
          "72:           for (const fieldGroup of groupedFieldSet.values()) {",
          "",
          "[Added Lines]",
          "74:           for (const fieldGroup of fields.values()) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2b42b9103dd94ec595ca0e91961848c7ac5e7af4",
      "candidate_info": {
        "commit_hash": "2b42b9103dd94ec595ca0e91961848c7ac5e7af4",
        "repo": "graphql/graphql-js",
        "commit_url": "https://github.com/graphql/graphql-js/commit/2b42b9103dd94ec595ca0e91961848c7ac5e7af4",
        "files": [
          "src/execution/IncrementalPublisher.ts"
        ],
        "message": "incremental: use invariant for checking id",
        "before_after_code_files": [
          "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/graphql/graphql-js/pull/4388",
          "https://github.com/graphql/graphql-js/pull/4385",
          "https://github.com/graphql/graphql-js/pull/4386"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts": [
          "File: src/execution/IncrementalPublisher.ts -> src/execution/IncrementalPublisher.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "300:   ): void {",
          "301:     const streamRecord = streamItemsResult.streamRecord;",
          "302:     const id = streamRecord.id;",
          "309:     if (streamItemsResult.errors !== undefined) {",
          "310:       context.completed.push({",
          "311:         id,",
          "",
          "[Removed Lines]",
          "306:     if (id === undefined) {",
          "307:       return;",
          "308:     }",
          "",
          "[Added Lines]",
          "303:     invariant(id !== undefined);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef478a2d91090f5cae2e9d942a65b0e94e7e5ae7",
      "candidate_info": {
        "commit_hash": "ef478a2d91090f5cae2e9d942a65b0e94e7e5ae7",
        "repo": "graphql/graphql-js",
        "commit_url": "https://github.com/graphql/graphql-js/commit/ef478a2d91090f5cae2e9d942a65b0e94e7e5ae7",
        "files": [
          "src/execution/IncrementalPublisher.ts",
          "src/execution/__tests__/defer-test.ts"
        ],
        "message": "fix(incremental): skip all empty subsequent results (#3993)\n\nThe publish method checks to see if a subsequent result is empty; this\nsame logic should be employed to suppress pending notices for empty\nrecords.\n\nThis has already been achieved for subsequent results that are children\nof the initial result, as we generated the pending notices from the list\nof initially published records.\n\nFor subsequent results that are children of other subsequent results, we\npreviously generated the pending notice prior to actually publishing.\n\nThis change integrates the logic: the publishing method itself returns a\npending notice as required. This results in a bug-fix for subsequent\nrecords of other subsequent records as well as a reduction of code for\nsubsequent results to the initial result.",
        "before_after_code_files": [
          "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts",
          "src/execution/__tests__/defer-test.ts||src/execution/__tests__/defer-test.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/graphql/graphql-js/pull/4388",
          "https://github.com/graphql/graphql-js/pull/4385",
          "https://github.com/graphql/graphql-js/pull/4386"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts": [
          "File: src/execution/IncrementalPublisher.ts -> src/execution/IncrementalPublisher.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:     initialResultRecord: InitialResultRecord,",
          "302:     data: ObjMap<unknown> | null,",
          "303:   ): ExecutionResult | ExperimentalIncrementalExecutionResults {",
          "311:     const errors = initialResultRecord.errors;",
          "312:     const initialResult = errors.length === 0 ? { data } : { errors, data };",
          "323:       return {",
          "324:         initialResult: {",
          "325:           ...initialResult,",
          "",
          "[Removed Lines]",
          "304:     for (const child of initialResultRecord.children) {",
          "305:       if (child.filtered) {",
          "306:         continue;",
          "307:       }",
          "308:       this._publish(child);",
          "309:     }",
          "313:     const pending = this._pending;",
          "314:     if (pending.size > 0) {",
          "315:       const pendingSources = new Set<DeferredFragmentRecord | StreamRecord>();",
          "316:       for (const subsequentResultRecord of pending) {",
          "317:         const pendingSource = isStreamItemsRecord(subsequentResultRecord)",
          "318:           ? subsequentResultRecord.streamRecord",
          "319:           : subsequentResultRecord;",
          "320:         pendingSources.add(pendingSource);",
          "321:       }",
          "",
          "[Added Lines]",
          "304:     const pendingSources = this._publish(initialResultRecord.children);",
          "308:     if (pendingSources.size > 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "538:     const incrementalResults: Array<IncrementalResult> = [];",
          "539:     const completedResults: Array<CompletedResult> = [];",
          "540:     for (const subsequentResultRecord of completedRecords) {",
          "553:       if (isStreamItemsRecord(subsequentResultRecord)) {",
          "554:         if (subsequentResultRecord.isFinalRecord) {",
          "555:           newPendingSources.delete(subsequentResultRecord.streamRecord);",
          "",
          "[Removed Lines]",
          "541:       for (const child of subsequentResultRecord.children) {",
          "542:         if (child.filtered) {",
          "543:           continue;",
          "544:         }",
          "545:         const pendingSource = isStreamItemsRecord(child)",
          "546:           ? child.streamRecord",
          "547:           : child;",
          "548:         if (!pendingSource.pendingSent) {",
          "549:           newPendingSources.add(pendingSource);",
          "550:         }",
          "551:         this._publish(child);",
          "552:       }",
          "",
          "[Added Lines]",
          "527:       this._publish(subsequentResultRecord.children, newPendingSources);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "655:     return result;",
          "656:   }",
          "661:         this._push(subsequentResultRecord);",
          "663:       }",
          "667:     }",
          "676:     }",
          "677:   }",
          "679:   private _getChildren(",
          "",
          "[Removed Lines]",
          "658:   private _publish(subsequentResultRecord: SubsequentResultRecord): void {",
          "659:     if (isStreamItemsRecord(subsequentResultRecord)) {",
          "660:       if (subsequentResultRecord.isCompleted) {",
          "662:         return;",
          "665:       this._introduce(subsequentResultRecord);",
          "666:       return;",
          "669:     if (subsequentResultRecord._pending.size > 0) {",
          "670:       this._introduce(subsequentResultRecord);",
          "671:     } else if (",
          "672:       subsequentResultRecord.deferredGroupedFieldSetRecords.size > 0 ||",
          "673:       subsequentResultRecord.children.size > 0",
          "674:     ) {",
          "675:       this._push(subsequentResultRecord);",
          "",
          "[Added Lines]",
          "635:   private _publish(",
          "636:     subsequentResultRecords: ReadonlySet<SubsequentResultRecord>,",
          "637:     pendingSources = new Set<DeferredFragmentRecord | StreamRecord>(),",
          "638:   ): Set<DeferredFragmentRecord | StreamRecord> {",
          "639:     const emptyRecords: Array<SubsequentResultRecord> = [];",
          "641:     for (const subsequentResultRecord of subsequentResultRecords) {",
          "642:       if (subsequentResultRecord.filtered) {",
          "643:         continue;",
          "644:       }",
          "645:       if (isStreamItemsRecord(subsequentResultRecord)) {",
          "646:         if (subsequentResultRecord.isCompleted) {",
          "647:           this._push(subsequentResultRecord);",
          "648:         } else {",
          "649:           this._introduce(subsequentResultRecord);",
          "650:         }",
          "652:         const stream = subsequentResultRecord.streamRecord;",
          "653:         if (!stream.pendingSent) {",
          "654:           pendingSources.add(stream);",
          "655:         }",
          "656:         continue;",
          "657:       }",
          "659:       if (subsequentResultRecord._pending.size > 0) {",
          "660:         this._introduce(subsequentResultRecord);",
          "661:       } else if (",
          "662:         subsequentResultRecord.deferredGroupedFieldSetRecords.size === 0",
          "663:       ) {",
          "664:         emptyRecords.push(subsequentResultRecord);",
          "665:         continue;",
          "666:       } else {",
          "670:       if (!subsequentResultRecord.pendingSent) {",
          "671:         pendingSources.add(subsequentResultRecord);",
          "672:       }",
          "675:     for (const emptyRecord of emptyRecords) {",
          "676:       this._publish(emptyRecord.children, pendingSources);",
          "679:     return pendingSources;",
          "",
          "---------------"
        ],
        "src/execution/__tests__/defer-test.ts||src/execution/__tests__/defer-test.ts": [
          "File: src/execution/__tests__/defer-test.ts -> src/execution/__tests__/defer-test.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "1023:           },",
          "1024:         },",
          "1025:         pending: [",
          "1027:           { id: '1', path: ['hero', 'nestedObject', 'deeperObject'] },",
          "1028:         ],",
          "1029:         hasNext: true,",
          "1030:       },",
          "1031:       {",
          "1033:         incremental: [",
          "1034:           {",
          "1035:             data: {",
          "1036:               foo: 'foo',",
          "1037:             },",
          "1039:           },",
          "1046:           {",
          "1047:             data: {",
          "1048:               bar: 'bar',",
          "1049:             },",
          "1051:           },",
          "1052:         ],",
          "1054:         hasNext: false,",
          "1055:       },",
          "1056:     ]);",
          "",
          "[Removed Lines]",
          "1026:           { id: '0', path: ['hero'] },",
          "1032:         pending: [{ id: '2', path: ['hero', 'nestedObject', 'deeperObject'] }],",
          "1038:             id: '1',",
          "1040:         ],",
          "1041:         completed: [{ id: '0' }, { id: '1' }],",
          "1042:         hasNext: true,",
          "1043:       },",
          "1044:       {",
          "1045:         incremental: [",
          "1050:             id: '2',",
          "1053:         completed: [{ id: '2' }],",
          "",
          "[Added Lines]",
          "1026:           { id: '0', path: ['hero', 'nestedObject', 'deeperObject'] },",
          "1037:             id: '0',",
          "1043:             id: '1',",
          "1046:         completed: [{ id: '0' }, { id: '1' }],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a81e6238fa3f3dd317cb33572dcc97020376c329",
      "candidate_info": {
        "commit_hash": "a81e6238fa3f3dd317cb33572dcc97020376c329",
        "repo": "graphql/graphql-js",
        "commit_url": "https://github.com/graphql/graphql-js/commit/a81e6238fa3f3dd317cb33572dcc97020376c329",
        "files": [
          "resources/benchmark.ts"
        ],
        "message": "chore(benchmark): update v8 flag (#4029)\n\nchanged in v8 11.3 / node 20\n\nsee:\nhttps://chromium.googlesource.com/v8/v8/+/73c45833472086ca1c6ab4140cdb058d1890e930%5E%21/src/flags/flag-definitions.h\n\nfixes benchmarking, see\nhttps://github.com/graphql/graphql-js/actions/runs/8314729475/job/22752257524#step:6:142",
        "before_after_code_files": [
          "resources/benchmark.ts||resources/benchmark.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/graphql/graphql-js/pull/4388",
          "https://github.com/graphql/graphql-js/pull/4385",
          "https://github.com/graphql/graphql-js/pull/4386"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "resources/benchmark.ts||resources/benchmark.ts": [
          "File: resources/benchmark.ts -> resources/benchmark.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "405:       '--predictable',",
          "406:       '--no-concurrent-sweeping',",
          "408:       '--min-semi-space-size=1024', // 1GB",
          "409:       '--max-semi-space-size=1024', // 1GB",
          "410:       '--trace-gc', // no gc calls should happen during benchmark, so trace them",
          "",
          "[Removed Lines]",
          "407:       '--no-scavenge-task',",
          "",
          "[Added Lines]",
          "407:       '--no-minor-gc-task',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5cd50010cecd1f69982926bb485692d8fc9d322b",
      "candidate_info": {
        "commit_hash": "5cd50010cecd1f69982926bb485692d8fc9d322b",
        "repo": "graphql/graphql-js",
        "commit_url": "https://github.com/graphql/graphql-js/commit/5cd50010cecd1f69982926bb485692d8fc9d322b",
        "files": [
          "src/execution/IncrementalGraph.ts",
          "src/execution/IncrementalPublisher.ts"
        ],
        "message": "polish(incremental): replace iterator with current and next accessors\n\n-- we do not need a formal iterator as we are the only consumer.",
        "before_after_code_files": [
          "src/execution/IncrementalGraph.ts||src/execution/IncrementalGraph.ts",
          "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/graphql/graphql-js/pull/4388",
          "https://github.com/graphql/graphql-js/pull/4385",
          "https://github.com/graphql/graphql-js/pull/4386"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/execution/IncrementalGraph.ts||src/execution/IncrementalGraph.ts": [
          "File: src/execution/IncrementalGraph.ts -> src/execution/IncrementalGraph.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   private _completedQueue: Array<IncrementalDataRecordResult>;",
          "30:   private _nextQueue: Array<",
          "32:   >;",
          "34:   constructor() {",
          "",
          "[Removed Lines]",
          "31:     (iterable: IteratorResult<Iterable<IncrementalDataRecordResult>>) => void",
          "",
          "[Added Lines]",
          "31:     (iterable: Iterable<IncrementalDataRecordResult> | undefined) => void",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:     }",
          "71:   }",
          "104:   }",
          "106:   hasNext(): boolean {",
          "",
          "[Removed Lines]",
          "73:   completedIncrementalData() {",
          "74:     return {",
          "75:       [Symbol.asyncIterator]() {",
          "76:         return this;",
          "77:       },",
          "78:       next: (): Promise<",
          "79:         IteratorResult<Iterable<IncrementalDataRecordResult>>",
          "80:       > => {",
          "81:         const firstResult = this._completedQueue.shift();",
          "82:         if (firstResult !== undefined) {",
          "83:           return Promise.resolve({",
          "84:             value: this._yieldCurrentCompletedIncrementalData(firstResult),",
          "85:             done: false,",
          "86:           });",
          "87:         }",
          "88:         const { promise, resolve } =",
          "89:           promiseWithResolvers<",
          "90:             IteratorResult<Iterable<IncrementalDataRecordResult>>",
          "91:           >();",
          "92:         this._nextQueue.push(resolve);",
          "93:         return promise;",
          "94:       },",
          "95:       return: (): Promise<",
          "96:         IteratorResult<Iterable<IncrementalDataRecordResult>>",
          "97:       > => {",
          "98:         for (const resolve of this._nextQueue) {",
          "99:           resolve({ value: undefined, done: true });",
          "100:         }",
          "101:         return Promise.resolve({ value: undefined, done: true });",
          "102:       },",
          "103:     };",
          "",
          "[Added Lines]",
          "74:     let completed;",
          "75:     while ((completed = this._completedQueue.shift()) !== undefined) {",
          "76:       yield completed;",
          "77:     }",
          "78:     if (this._rootNodes.size === 0) {",
          "79:       for (const resolve of this._nextQueue) {",
          "80:         resolve(undefined);",
          "81:       }",
          "82:     }",
          "83:   }",
          "85:   nextCompletedBatch(): Promise<",
          "86:     Iterable<IncrementalDataRecordResult> | undefined",
          "87:   > {",
          "88:     const { promise, resolve } = promiseWithResolvers<",
          "89:       Iterable<IncrementalDataRecordResult> | undefined",
          "90:     >();",
          "91:     this._nextQueue.push(resolve);",
          "92:     return promise;",
          "93:   }",
          "95:   abort(): void {",
          "96:     for (const resolve of this._nextQueue) {",
          "97:       resolve(undefined);",
          "98:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "327:     first: IncrementalDataRecordResult,",
          "328:   ): Generator<IncrementalDataRecordResult> {",
          "329:     yield first;",
          "339:   }",
          "341:   private _enqueue(completed: IncrementalDataRecordResult): void {",
          "342:     const next = this._nextQueue.shift();",
          "343:     if (next !== undefined) {",
          "348:       return;",
          "349:     }",
          "350:     this._completedQueue.push(completed);",
          "",
          "[Removed Lines]",
          "330:     let completed;",
          "331:     while ((completed = this._completedQueue.shift()) !== undefined) {",
          "332:       yield completed;",
          "333:     }",
          "334:     if (this._rootNodes.size === 0) {",
          "335:       for (const resolve of this._nextQueue) {",
          "336:         resolve({ value: undefined, done: true });",
          "337:       }",
          "338:     }",
          "344:       next({",
          "345:         value: this._yieldCurrentCompletedIncrementalData(completed),",
          "346:         done: false,",
          "347:       });",
          "",
          "[Added Lines]",
          "325:     yield* this.currentCompletedBatch();",
          "331:       next(this._yieldCurrentCompletedIncrementalData(completed));",
          "",
          "---------------"
        ],
        "src/execution/IncrementalPublisher.ts||src/execution/IncrementalPublisher.ts": [
          "File: src/execution/IncrementalPublisher.ts -> src/execution/IncrementalPublisher.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "135:         completed: [],",
          "136:       };",
          "146:           this._handleCompletedIncrementalData(completedResult, context);",
          "147:         }",
          "",
          "[Removed Lines]",
          "138:       const completedIncrementalData =",
          "139:         this._incrementalGraph.completedIncrementalData();",
          "142:       const asyncIterator = completedIncrementalData[Symbol.asyncIterator]();",
          "143:       let iteration = await asyncIterator.next();",
          "144:       while (!iteration.done) {",
          "145:         for (const completedResult of iteration.value) {",
          "",
          "[Added Lines]",
          "138:       let batch: Iterable<IncrementalDataRecordResult> | undefined =",
          "139:         this._incrementalGraph.currentCompletedBatch();",
          "140:       do {",
          "141:         for (const completedResult of batch) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173:         }",
          "179:       await this._returnAsyncIteratorsIgnoringErrors();",
          "180:       return { value: undefined, done: true };",
          "",
          "[Removed Lines]",
          "176:         iteration = await asyncIterator.next();",
          "177:       }",
          "",
          "[Added Lines]",
          "171:         batch = await this._incrementalGraph.nextCompletedBatch();",
          "172:       } while (batch !== undefined);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:       IteratorResult<SubsequentIncrementalExecutionResult, void>",
          "185:     > => {",
          "186:       isDone = true;",
          "187:       await this._returnAsyncIterators();",
          "188:       return { value: undefined, done: true };",
          "189:     };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182:       this._incrementalGraph.abort();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "192:       error?: unknown,",
          "193:     ): Promise<IteratorResult<SubsequentIncrementalExecutionResult, void>> => {",
          "194:       isDone = true;",
          "195:       await this._returnAsyncIterators();",
          "196:       return Promise.reject(error);",
          "197:     };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:       this._incrementalGraph.abort();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "363:   }",
          "365:   private async _returnAsyncIterators(): Promise<void> {",
          "368:     const cancellableStreams = this._context.cancellableStreams;",
          "369:     if (cancellableStreams === undefined) {",
          "370:       return;",
          "",
          "[Removed Lines]",
          "366:     await this._incrementalGraph.completedIncrementalData().return();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
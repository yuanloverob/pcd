{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "69031794f90285ffae7351dae513f763a3d89ef9",
      "candidate_info": {
        "commit_hash": "69031794f90285ffae7351dae513f763a3d89ef9",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/69031794f90285ffae7351dae513f763a3d89ef9",
        "files": [
          "modules/clusterer/clusterer.c",
          "modules/clusterer/clusterer.h",
          "modules/clusterer/sharing_tags.c",
          "modules/clusterer/sync.c"
        ],
        "message": "clusterer: fix deadlocks when syncing\n\n(cherry picked from commit 652d89fbeffc180aea68e8bdfcac799d53124e6b)",
        "before_after_code_files": [
          "modules/clusterer/clusterer.c||modules/clusterer/clusterer.c",
          "modules/clusterer/clusterer.h||modules/clusterer/clusterer.h",
          "modules/clusterer/sharing_tags.c||modules/clusterer/sharing_tags.c",
          "modules/clusterer/sync.c||modules/clusterer/sync.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/clusterer/clusterer.c||modules/clusterer/clusterer.c": [
          "File: modules/clusterer/clusterer.c -> modules/clusterer/clusterer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "314: }",
          "316: enum clusterer_send_ret clusterer_send_msg(bin_packet_t *packet,",
          "318: {",
          "319:  node_info_t *node;",
          "320:  int rc;",
          "",
          "[Removed Lines]",
          "317:  int cluster_id, int dst_node_id, int check_cap)",
          "",
          "[Added Lines]",
          "317:  int cluster_id, int dst_node_id, int check_cap, int locked)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "326:   LM_ERR(\"cluster shutdown - cannot send new messages!\\n\");",
          "327:   return CLUSTERER_CURR_DISABLED;",
          "328:  }",
          "331:  cl = get_cluster_by_id(cluster_id);",
          "332:  if (!cl) {",
          "333:   LM_ERR(\"Unknown cluster id [%d]\\n\", cluster_id);",
          "335:   return CLUSTERER_SEND_ERR;",
          "336:  }",
          "338:  lock_get(cl->current_node->lock);",
          "339:  if (!(cl->current_node->flags & NODE_STATE_ENABLED)) {",
          "340:   lock_release(cl->current_node->lock);",
          "342:   return CLUSTERER_CURR_DISABLED;",
          "343:  }",
          "344:  lock_release(cl->current_node->lock);",
          "",
          "[Removed Lines]",
          "329:  lock_start_read(cl_list_lock);",
          "334:   lock_stop_read(cl_list_lock);",
          "341:   lock_stop_read(cl_list_lock);",
          "",
          "[Added Lines]",
          "329:  if (!locked)",
          "330:   lock_start_read(cl_list_lock);",
          "335:   if (!locked)",
          "336:    lock_stop_read(cl_list_lock);",
          "343:   if (!locked)",
          "344:    lock_stop_read(cl_list_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "346:  node = get_node_by_id(cl, dst_node_id);",
          "347:  if (!node) {",
          "348:   LM_ERR(\"Node id [%d] not found in cluster\\n\", dst_node_id);",
          "350:   return CLUSTERER_SEND_ERR;",
          "351:  }",
          "",
          "[Removed Lines]",
          "349:   lock_stop_read(cl_list_lock);",
          "",
          "[Added Lines]",
          "352:   if (!locked)",
          "353:    lock_stop_read(cl_list_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "379:  if (ev_actions_required)",
          "380:   do_actions_node_ev(cl, &ev_actions_required, 1);",
          "384:  switch (rc) {",
          "385:  case  0:",
          "",
          "[Removed Lines]",
          "382:  lock_stop_read(cl_list_lock);",
          "",
          "[Added Lines]",
          "386:  if (!locked)",
          "387:   lock_stop_read(cl_list_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "521:   return CLUSTERER_SEND_ERR;",
          "522:  }",
          "525: }",
          "527: enum clusterer_send_ret cl_send_all(bin_packet_t *packet, int cluster_id)",
          "",
          "[Removed Lines]",
          "524:  return clusterer_send_msg(packet, cluster_id, node_id, 1);",
          "",
          "[Added Lines]",
          "529:  return clusterer_send_msg(packet, cluster_id, node_id, 1, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "557:   return CLUSTERER_SEND_ERR;",
          "558:  }",
          "562:  bin_free_packet(&packet);",
          "",
          "[Removed Lines]",
          "560:  rc = clusterer_send_msg(&packet, cluster_id, dst_id, 0);",
          "",
          "[Added Lines]",
          "565:  rc = clusterer_send_msg(&packet, cluster_id, dst_id, 0, 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "612:  }",
          "614:  if (dst_id)",
          "616:  else",
          "617:   rc = clusterer_bcast_msg(&packet, cluster_id, NODE_CMP_ANY, 0);",
          "",
          "[Removed Lines]",
          "615:   rc = clusterer_send_msg(&packet, cluster_id, dst_id, 0);",
          "",
          "[Added Lines]",
          "620:   rc = clusterer_send_msg(&packet, cluster_id, dst_id, 0, 0);",
          "",
          "---------------"
        ],
        "modules/clusterer/clusterer.h||modules/clusterer/clusterer.h": [
          "File: modules/clusterer/clusterer.h -> modules/clusterer/clusterer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "156: int msg_add_trailer(bin_packet_t *packet, int cluster_id, int dst_id);",
          "157: enum clusterer_send_ret clusterer_send_msg(bin_packet_t *packet,",
          "159: int send_single_cap_update(struct cluster_info *cluster, struct local_cap *cap,",
          "160:        int cap_state);",
          "161: int send_cap_update(struct node_info *dest_node, int require_reply);",
          "",
          "[Removed Lines]",
          "158:  int cluster_id, int dst_id, int check_cap);",
          "",
          "[Added Lines]",
          "158:  int cluster_id, int dst_id, int check_cap, int locked);",
          "",
          "---------------"
        ],
        "modules/clusterer/sharing_tags.c||modules/clusterer/sharing_tags.c": [
          "File: modules/clusterer/sharing_tags.c -> modules/clusterer/sharing_tags.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "553:   return CLUSTERER_SEND_ERR;",
          "555:  msg_add_trailer(&packet, c_id, node_id);",
          "557:   CLUSTERER_SEND_SUCCESS) {",
          "558:   bin_free_packet(&packet);",
          "559:   return CLUSTERER_SEND_ERR;",
          "",
          "[Removed Lines]",
          "556:  if (clusterer_send_msg(&packet, c_id, node_id, 0) !=",
          "",
          "[Added Lines]",
          "556:  if (clusterer_send_msg(&packet, c_id, node_id, 0, 1) !=",
          "",
          "---------------"
        ],
        "modules/clusterer/sync.c||modules/clusterer/sync.c": [
          "File: modules/clusterer/sync.c -> modules/clusterer/sync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:  bin_push_str(&packet, capability);",
          "47:  msg_add_trailer(&packet, cluster_id, source_id);",
          "50:  if (rc == CLUSTERER_SEND_SUCCESS)",
          "51:   LM_INFO(\"Sent sync request for capability '%.*s' to node %d, \"",
          "52:           \"cluster %d\\n\", capability->len, capability->s, source_id,",
          "",
          "[Removed Lines]",
          "49:  rc = clusterer_send_msg(&packet, cluster_id, source_id, 0);",
          "",
          "[Added Lines]",
          "49:  rc = clusterer_send_msg(&packet, cluster_id, source_id, 0, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:    msg_add_trailer(sync_packet_snd, cluster_id, dst_id);",
          "195:     LM_ERR(\"Failed to send sync packet\\n\");",
          "197:    bin_free_packet(sync_packet_snd);",
          "",
          "[Removed Lines]",
          "194:    if (clusterer_send_msg(sync_packet_snd, cluster_id, dst_id, 0) < 0)",
          "",
          "[Added Lines]",
          "194:    if (clusterer_send_msg(sync_packet_snd, cluster_id, dst_id, 0,",
          "195:     1 /* we should be in a SYNC_REQ_RCV callback here so",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "314:   msg_add_trailer(sync_packet_snd, p->cluster->cluster_id, p->node_id);",
          "316:   if ((rc = clusterer_send_msg(sync_packet_snd, p->cluster->cluster_id,",
          "318:    LM_ERR(\"Failed to send sync packet, rc=%d\\n\", rc);",
          "320:   bin_free_packet(sync_packet_snd);",
          "",
          "[Removed Lines]",
          "317:    p->node_id, 0))<0)",
          "",
          "[Added Lines]",
          "319:    p->node_id, 0, 1))<0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "333:  msg_add_trailer(&sync_end_pkt, p->cluster->cluster_id, p->node_id);",
          "335:  if (clusterer_send_msg(&sync_end_pkt, p->cluster->cluster_id, p->node_id,",
          "337:   LM_ERR(\"Failed to send sync end message\\n\");",
          "338:   bin_free_packet(&sync_end_pkt);",
          "339:   lock_stop_read(cl_list_lock);",
          "",
          "[Removed Lines]",
          "336:   0) < 0) {",
          "",
          "[Added Lines]",
          "338:   0, 1) < 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef2ac0d8fc9ff25283be3d9f336286c55b0bbf9b",
      "candidate_info": {
        "commit_hash": "ef2ac0d8fc9ff25283be3d9f336286c55b0bbf9b",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/ef2ac0d8fc9ff25283be3d9f336286c55b0bbf9b",
        "files": [
          "modules/b2b_logic_xml/b2b_logic.c",
          "modules/b2b_logic_xml/logic.c"
        ],
        "message": "b2b_logic_xml: keep compatibility with b2b_context changes",
        "before_after_code_files": [
          "modules/b2b_logic_xml/b2b_logic.c||modules/b2b_logic_xml/b2b_logic.c",
          "modules/b2b_logic_xml/logic.c||modules/b2b_logic_xml/logic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/b2b_logic_xml/b2b_logic.c||modules/b2b_logic_xml/b2b_logic.c": [
          "File: modules/b2b_logic_xml/b2b_logic.c -> modules/b2b_logic_xml/b2b_logic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1665:  return NULL;",
          "1666: }",
          "1670: {",
          "1671:  b2bl_tuple_t *tuple;",
          "1675:  if (!tuple) {",
          "1689:     ctx->b2bl_key.s);",
          "1692:    return NULL;",
          "1693:   }",
          "1700:  }",
          "1702:  return tuple;",
          "1703: }",
          "1706: {",
          "1707:  b2bl_tuple_t *tuple;",
          "1708:  struct b2b_context *ctx;",
          "",
          "[Removed Lines]",
          "1669: b2bl_tuple_t *get_entities_ctx_tuple(struct b2b_context *ctx)",
          "1672:  unsigned int hash_index, local_index;",
          "1674:  tuple = ctx->data;",
          "1677:   if (b2bl_parse_key(&ctx->b2bl_key, &hash_index, &local_index) < 0) {",
          "1678:    LM_ERR(\"Failed to parse key [%.*s]\\n\", ctx->b2bl_key.len,",
          "1679:     ctx->b2bl_key.s);",
          "1680:    return NULL;",
          "1681:   }",
          "1683:   if (b2bl_htable[hash_index].locked_by != process_no)",
          "1684:    lock_get(&b2bl_htable[hash_index].lock);",
          "1686:   tuple = b2bl_search_tuple_safe(hash_index, local_index);",
          "1687:   if (!tuple) {",
          "1688:    LM_ERR(\"Tuple [%.*s] not found\\n\", ctx->b2bl_key.len,",
          "1690:    if (b2bl_htable[hash_index].locked_by != process_no)",
          "1691:     lock_release(&b2bl_htable[hash_index].lock);",
          "1696:   ctx->data = tuple;",
          "1698:   if (b2bl_htable[hash_index].locked_by != process_no)",
          "1699:    lock_release(&b2bl_htable[hash_index].lock);",
          "1705: b2bl_tuple_t *get_ctx_tuple(void)",
          "",
          "[Added Lines]",
          "1668: static b2bl_tuple_t *ctx_search_tuple(struct b2b_context *ctx, int *locked)",
          "1673:  if (b2bl_htable[ctx->hash_index].locked_by != process_no)",
          "1674:   lock_get(&b2bl_htable[ctx->hash_index].lock);",
          "1676:  tuple = b2bl_search_tuple_safe(ctx->hash_index, ctx->local_index);",
          "1679:   LM_ERR(\"Tuple [%u, %u] not found\\n\", ctx->hash_index, ctx->local_index);",
          "1680:   if (b2bl_htable[ctx->hash_index].locked_by != process_no)",
          "1681:    lock_release(&b2bl_htable[ctx->hash_index].lock);",
          "1682:   locked = 0;",
          "1683:   return NULL;",
          "1684:  }",
          "1686:  return tuple;",
          "1687: }",
          "1690: b2bl_tuple_t *get_entities_ctx_tuple(struct b2b_context *ctx, int *locked)",
          "1691: {",
          "1692:  b2bl_tuple_t *tuple;",
          "1694:  if (!ctx->init) {",
          "1696:   if (b2bl_parse_key(&ctx->b2bl_key,",
          "1697:    &ctx->hash_index, &ctx->local_index) < 0) {",
          "1698:    LM_ERR(\"Failed to parse key [%.*s]\\n\", ctx->b2bl_key.len,",
          "1702:   tuple = ctx_search_tuple(ctx, locked);",
          "1703:   if (tuple)",
          "1704:    ctx->init = 1;",
          "1705:   } else {",
          "1706:    tuple = ctx_search_tuple(ctx, locked);",
          "1712: b2bl_tuple_t *get_ctx_tuple(int *locked)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1718:    LM_DBG(\"b2b_logic key not set in b2b_entities context\\n\");",
          "1722:   }",
          "1725:   if (!tuple) {",
          "1726:    LM_ERR(\"Failed to get tuple [%.*s] from b2b context\\n\",",
          "1727:     ctx->b2bl_key.len, ctx->b2bl_key.s);",
          "",
          "[Removed Lines]",
          "1721:    return ctx->data;",
          "1724:   tuple = get_entities_ctx_tuple(ctx);",
          "",
          "[Added Lines]",
          "1728:    if (!ctx->init)",
          "1729:     return NULL;",
          "1730:    else",
          "1731:     return ctx_search_tuple(ctx, locked);",
          "1734:   tuple = get_entities_ctx_tuple(ctx, locked);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1739: int pv_get_b2bl_key(struct sip_msg *msg, pv_param_t *param, pv_value_t *res)",
          "1740: {",
          "1741:  b2bl_tuple_t *tuple;",
          "1744:  if (!tuple) {",
          "1745:   LM_DBG(\"Unable to get the tuple from the current context\\n\");",
          "1746:   return pv_get_null(msg, param, res);",
          "",
          "[Removed Lines]",
          "1743:  tuple = get_ctx_tuple();",
          "",
          "[Added Lines]",
          "1752:  int locked = 0;",
          "1754:  tuple = get_ctx_tuple(&locked);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1749:  res->flags = PV_VAL_STR;",
          "1750:  res->rs = *tuple->key;",
          "1752:  return 0;",
          "1753: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1763:  if (locked && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "1764:   lock_release(&b2bl_htable[tuple->hash_index].lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1808:  b2b_dlginfo_t dummy_dlginfo;",
          "1809:  str callid;",
          "1810:  int i;",
          "1813:  if (!tuple) {",
          "1814:   LM_ERR(\"Failed to get the tuple from the current context\\n\");",
          "1815:   return pv_get_null(msg, param, res);",
          "1816:  }",
          "1819:   lock_get(&b2bl_htable[tuple->hash_index].lock);",
          "1821:  curr_entities[0] = tuple->bridge_entities[0];",
          "",
          "[Removed Lines]",
          "1812:  tuple = get_ctx_tuple();",
          "1818:  if (b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "[Added Lines]",
          "1825:  int locked = 0;",
          "1827:  tuple = get_ctx_tuple(&locked);",
          "1833:  if (!locked && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2038:  return 0;",
          "2039: }",
          "2042: {",
          "2043:  struct b2b_context *ctx;",
          "",
          "[Removed Lines]",
          "2041: int get_ctx_vals(struct b2b_ctx_val ***vals, b2bl_tuple_t **tuple)",
          "",
          "[Added Lines]",
          "2056: int get_ctx_vals(struct b2b_ctx_val ***vals, b2bl_tuple_t **tuple, int *locked)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2050:   }",
          "2052:   if (!ctx->b2bl_key.s) {",
          "2054:     LM_DBG(\"tuple not created yet\\n\");",
          "2057:     return 0;",
          "2058:    } else {",
          "2060:    }",
          "2061:   } else {",
          "2063:    if (*tuple == NULL) {",
          "2064:     LM_ERR(\"Failed to get tuple [%.*s] from b2b context\\n\",",
          "2065:      ctx->b2bl_key.len, ctx->b2bl_key.s);",
          "",
          "[Removed Lines]",
          "2053:    if (!ctx->data) {",
          "",
          "[Added Lines]",
          "2068:    if (!ctx->init) {",
          "2075:     if (*tuple == NULL)",
          "2076:      return -1;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2079: {",
          "2080:  struct b2b_ctx_val **vals;",
          "2081:  b2bl_tuple_t *tuple = NULL;",
          "2083:  if (!param || !param->pvn.u.isname.name.s.s) {",
          "2084:   LM_ERR(\"Bad parameters!\\n\");",
          "2085:   return -1;",
          "2086:  }",
          "2089:   LM_ERR(\"Failed to get context values list\\n\");",
          "2090:   return pv_get_null(msg, param, res);",
          "2091:  }",
          "2094:   lock_get(&b2bl_htable[tuple->hash_index].lock);",
          "2096:  if (fetch_ctx_value(*vals, &param->pvn.u.isname.name.s, &param->pvv) != 0) {",
          "",
          "[Removed Lines]",
          "2088:  if (get_ctx_vals(&vals, &tuple) < 0) {",
          "2093:  if (tuple && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "[Added Lines]",
          "2099:  int locked = 0;",
          "2106:  if (get_ctx_vals(&vals, &tuple, &locked) < 0) {",
          "2111:  if (tuple && !locked && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2111: {",
          "2112:  struct b2b_ctx_val **ctx_vals = NULL;",
          "2113:  b2bl_tuple_t *tuple = NULL;",
          "2115:  if (!param || !param->pvn.u.isname.name.s.s) {",
          "2116:   LM_ERR(\"Bad parameters!\\n\");",
          "2117:   return -1;",
          "2118:  }",
          "2121:   LM_ERR(\"Failed to get context values list\\n\");",
          "2122:   return -1;",
          "2123:  }",
          "2126:   lock_get(&b2bl_htable[tuple->hash_index].lock);",
          "2128:  if (val==NULL || val->flags&(PV_VAL_NONE|PV_VAL_NULL|PV_VAL_EMPTY)) {",
          "",
          "[Removed Lines]",
          "2120:  if (get_ctx_vals(&ctx_vals, &tuple) < 0) {",
          "2125:  if (tuple && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "[Added Lines]",
          "2132:  int locked = 0;",
          "2139:  if (get_ctx_vals(&ctx_vals, &tuple, &locked) < 0) {",
          "2144:  if (tuple && !locked && b2bl_htable[tuple->hash_index].locked_by != process_no)",
          "",
          "---------------"
        ],
        "modules/b2b_logic_xml/logic.c||modules/b2b_logic_xml/logic.c": [
          "File: modules/b2b_logic_xml/logic.c -> modules/b2b_logic_xml/logic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2775:   LM_ERR(\"Failed to get b2b context\\n\");",
          "2776:   goto error;",
          "2777:  }",
          "2781:  tuple->lifetime = params->init_timeout + get_ticks();",
          "",
          "[Removed Lines]",
          "2778:  ctx->data = tuple;",
          "",
          "[Added Lines]",
          "2778:  ctx->init = 1;",
          "2779:  ctx->hash_index = hash_index;",
          "2780:  ctx->local_index = tuple->id;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3351:   LM_ERR(\"Failed to get b2b context\\n\");",
          "3352:   goto error;",
          "3353:  }",
          "3357:  node = xmlNodeGetChildByName(scenario_struct->init_node, \"state\");",
          "",
          "[Removed Lines]",
          "3354:  ctx->data = tuple;",
          "",
          "[Added Lines]",
          "3356:  ctx->init = 1;",
          "3357:  ctx->hash_index = hash_index;",
          "3358:  ctx->local_index = tuple->id;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4322:   LM_ERR(\"Failed to get b2b context\\n\");",
          "4323:   goto error;",
          "4324:  }",
          "4327:  if(entity_no!=0 && entity_no!=1)",
          "4328:  {",
          "",
          "[Removed Lines]",
          "4325:  ctx->data = tuple;",
          "",
          "[Added Lines]",
          "4329:  ctx->init = 1;",
          "4330:  ctx->hash_index = hash_index;",
          "4331:  ctx->local_index = tuple->id;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e12f00dc0f1d1638a78fa792074c1a46db269bd",
      "candidate_info": {
        "commit_hash": "7e12f00dc0f1d1638a78fa792074c1a46db269bd",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/7e12f00dc0f1d1638a78fa792074c1a46db269bd",
        "files": [
          "parser/parse_uri.c"
        ],
        "message": "parse_uri: Parse the port into an unsigned integer (OSS-Fuzz)\n\nFixes OSS-Fuzz#51605\n\n(cherry picked from commit b4a72a5f96f5726afa48854ad0850fe14f78909d)",
        "before_after_code_files": [
          "parser/parse_uri.c||parser/parse_uri.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "parser/parse_uri.c||parser/parse_uri.c": [
          "File: parser/parse_uri.c -> parser/parse_uri.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "358:  str user;",
          "359:  str password;",
          "361:  register char* p;",
          "362:  char* end;",
          "363:  char* pass;",
          "",
          "[Removed Lines]",
          "360:  int port_no;",
          "",
          "[Added Lines]",
          "360:  unsigned int port_no;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "372: #define case_port( ch, var, ovf_check1, ovf_check2) \\",
          "373:  case ch: \\",
          "374:    if (ovf_check1) \\",
          "376:    if (ovf_check2 && (var) > USHRT_MAX) \\",
          "377:     goto error_bad_port; \\",
          "378:    break",
          "",
          "[Removed Lines]",
          "375:     (var)=(var)*10+ch-'0'; \\",
          "",
          "[Added Lines]",
          "375:     (var)=(var)*10+(ch-'0'); \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f99dd82e38bb98662f304a9ebe0e77ebac961d7",
      "candidate_info": {
        "commit_hash": "5f99dd82e38bb98662f304a9ebe0e77ebac961d7",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/5f99dd82e38bb98662f304a9ebe0e77ebac961d7",
        "files": [
          "modules/clusterer/sync.c"
        ],
        "message": "clusterer: properly compute sync fallback interval in all cases\n\nThe timestamp of the sync request was not saved when queueing the sync\nafter certain send errors.\n\n(cherry picked from commit 816ef38b7c97b811a5822ceab9ebbe81609b1b6b)",
        "before_after_code_files": [
          "modules/clusterer/sync.c||modules/clusterer/sync.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/clusterer/sync.c||modules/clusterer/sync.c": [
          "File: modules/clusterer/sync.c -> modules/clusterer/sync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:    lock_get(cluster->lock);",
          "159:    lcap->flags |= CAP_SYNC_PENDING;",
          "160:    lock_release(cluster->lock);",
          "161:   } else if (rc == CLUSTERER_SEND_ERR)",
          "162:    return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:    if (cluster->current_node->flags & NODE_IS_SEED)",
          "162:     gettimeofday(&lcap->sync_req_time, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f58ffa930fee411a83d3196f682f4958ad57277",
      "candidate_info": {
        "commit_hash": "2f58ffa930fee411a83d3196f682f4958ad57277",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/2f58ffa930fee411a83d3196f682f4958ad57277",
        "files": [
          "modules/rtpproxy/rtpproxy.c"
        ],
        "message": "rtpproxy: Fix bad error handling on rare OOM case\n\n(cherry picked from commit d2cec34346fea49a98b5c5d33ae20044e47eec69)",
        "before_after_code_files": [
          "modules/rtpproxy/rtpproxy.c||modules/rtpproxy/rtpproxy.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/rtpproxy/rtpproxy.c||modules/rtpproxy/rtpproxy.c": [
          "File: modules/rtpproxy/rtpproxy.c -> modules/rtpproxy/rtpproxy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1086:  rtpp_no = (unsigned int*)shm_malloc(sizeof(unsigned int));",
          "1087:  list_version = (unsigned int*)shm_malloc(sizeof(unsigned int));",
          "1092:  if(!rtpp_no || !list_version) {",
          "1093:   LM_ERR(\"No more shared memory\\n\");",
          "1094:   return -1;",
          "1095:  }",
          "1096:  if (!(rtpp_set_list = (struct rtpp_set_head **)",
          "1097:   shm_malloc(sizeof(struct rtpp_set_head *)))) {",
          "1098:   LM_ERR(\"no more shm mem\\n\");",
          "",
          "[Removed Lines]",
          "1090:  my_version = 0;",
          "",
          "[Added Lines]",
          "1094:  my_version = 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
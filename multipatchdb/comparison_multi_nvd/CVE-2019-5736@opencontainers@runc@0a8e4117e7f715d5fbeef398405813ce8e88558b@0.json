{
  "cve_id": "CVE-2019-5736",
  "cve_desc": "runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe.",
  "repo": "opencontainers/runc",
  "patch_hash": "0a8e4117e7f715d5fbeef398405813ce8e88558b",
  "patch_info": {
    "commit_hash": "0a8e4117e7f715d5fbeef398405813ce8e88558b",
    "repo": "opencontainers/runc",
    "commit_url": "https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b",
    "files": [
      "libcontainer/nsenter/cloned_binary.c",
      "libcontainer/nsenter/nsexec.c"
    ],
    "message": "nsenter: clone /proc/self/exe to avoid exposing host binary to container\n\nThere are quite a few circumstances where /proc/self/exe pointing to a\npretty important container binary is a _bad_ thing, so to avoid this we\nhave to make a copy (preferably doing self-clean-up and not being\nwriteable).\n\nWe require memfd_create(2) -- though there is an O_TMPFILE fallback --\nbut we can always extend this to use a scratch MNT_DETACH overlayfs or\ntmpfs. The main downside to this approach is no page-cache sharing for\nthe runc binary (which overlayfs would give us) but this is far less\ncomplicated.\n\nThis is only done during nsenter so that it happens transparently to the\nGo code, and any libcontainer users benefit from it. This also makes\nExtraFiles and --preserve-fds handling trivial (because we don't need to\nworry about it).\n\nFixes: CVE-2019-5736\nCo-developed-by: Christian Brauner <christian.brauner@ubuntu.com>\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
    "before_after_code_files": [
      "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c",
      "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
    ]
  },
  "patch_diff": {
    "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
      "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #define _GNU_SOURCE",
      "19: #include <unistd.h>",
      "20: #include <stdio.h>",
      "21: #include <stdlib.h>",
      "22: #include <stdbool.h>",
      "23: #include <string.h>",
      "24: #include <limits.h>",
      "25: #include <fcntl.h>",
      "26: #include <errno.h>",
      "28: #include <sys/types.h>",
      "29: #include <sys/stat.h>",
      "30: #include <sys/vfs.h>",
      "31: #include <sys/mman.h>",
      "32: #include <sys/sendfile.h>",
      "33: #include <sys/syscall.h>",
      "36: #if !defined(SYS_memfd_create) && defined(__NR_memfd_create)",
      "37: #  define SYS_memfd_create __NR_memfd_create",
      "38: #endif",
      "39: #ifdef SYS_memfd_create",
      "40: #  define HAVE_MEMFD_CREATE",
      "42: #  ifndef MFD_CLOEXEC",
      "43: #    define MFD_CLOEXEC       0x0001U",
      "44: #    define MFD_ALLOW_SEALING 0x0002U",
      "45: #  endif",
      "46: int memfd_create(const char *name, unsigned int flags)",
      "47: {",
      "48:  return syscall(SYS_memfd_create, name, flags);",
      "49: }",
      "50: #endif",
      "53: #ifndef F_LINUX_SPECIFIC_BASE",
      "54: #  define F_LINUX_SPECIFIC_BASE 1024",
      "55: #endif",
      "56: #ifndef F_ADD_SEALS",
      "57: #  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)",
      "58: #  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)",
      "59: #endif",
      "60: #ifndef F_SEAL_SEAL",
      "65: #endif",
      "68: #ifdef HAVE_MEMFD_CREATE",
      "69: #  define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"",
      "70: #  define RUNC_MEMFD_SEALS \\",
      "71:  (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)",
      "72: #endif",
      "74: static void *must_realloc(void *ptr, size_t size)",
      "75: {",
      "76:  void *old = ptr;",
      "77:  do {",
      "78:   ptr = realloc(old, size);",
      "79:  } while(!ptr);",
      "80:  return ptr;",
      "81: }",
      "88: static int is_self_cloned(void)",
      "89: {",
      "90:  int fd, ret, is_cloned = 0;",
      "92:  fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);",
      "93:  if (fd < 0)",
      "94:   return -ENOTRECOVERABLE;",
      "96: #ifdef HAVE_MEMFD_CREATE",
      "97:  ret = fcntl(fd, F_GET_SEALS);",
      "98:  is_cloned = (ret == RUNC_MEMFD_SEALS);",
      "99: #else",
      "100:  struct stat statbuf = {0};",
      "101:  ret = fstat(fd, &statbuf);",
      "102:  if (ret >= 0)",
      "103:   is_cloned = (statbuf.st_nlink == 0);",
      "104: #endif",
      "105:  close(fd);",
      "106:  return is_cloned;",
      "107: }",
      "113: static char *read_file(char *path, size_t *length)",
      "114: {",
      "115:  int fd;",
      "116:  char buf[4096], *copy = NULL;",
      "118:  if (!length)",
      "119:   return NULL;",
      "121:  fd = open(path, O_RDONLY | O_CLOEXEC);",
      "122:  if (fd < 0)",
      "123:   return NULL;",
      "126:  for (;;) {",
      "127:   int n;",
      "129:   n = read(fd, buf, sizeof(buf));",
      "130:   if (n < 0)",
      "131:    goto error;",
      "132:   if (!n)",
      "133:    break;",
      "135:   copy = must_realloc(copy, (*length + n) * sizeof(*copy));",
      "136:   memcpy(copy + *length, buf, n);",
      "138:  }",
      "139:  close(fd);",
      "140:  return copy;",
      "142: error:",
      "143:  close(fd);",
      "144:  free(copy);",
      "145:  return NULL;",
      "146: }",
      "153: static int parse_xargs(char *data, int data_length, char ***output)",
      "154: {",
      "155:  int num = 0;",
      "156:  char *cur = data;",
      "158:  if (!data || *output != NULL)",
      "159:   return -1;",
      "161:  while (cur < data + data_length) {",
      "162:   num++;",
      "164:   (*output)[num - 1] = cur;",
      "165:   cur += strlen(cur) + 1;",
      "166:  }",
      "167:  (*output)[num] = NULL;",
      "168:  return num;",
      "169: }",
      "176: static int fetchve(char ***argv, char ***envp)",
      "177: {",
      "178:  char *cmdline = NULL, *environ = NULL;",
      "179:  size_t cmdline_size, environ_size;",
      "181:  cmdline = read_file(\"/proc/self/cmdline\", &cmdline_size);",
      "182:  if (!cmdline)",
      "183:   goto error;",
      "184:  environ = read_file(\"/proc/self/environ\", &environ_size);",
      "185:  if (!environ)",
      "186:   goto error;",
      "188:  if (parse_xargs(cmdline, cmdline_size, argv) <= 0)",
      "189:   goto error;",
      "190:  if (parse_xargs(environ, environ_size, envp) <= 0)",
      "191:   goto error;",
      "193:  return 0;",
      "195: error:",
      "196:  free(environ);",
      "197:  free(cmdline);",
      "198:  return -EINVAL;",
      "199: }",
      "201: static int clone_binary(void)",
      "202: {",
      "203:  int binfd, memfd;",
      "204:  ssize_t sent = 0;",
      "206: #ifdef HAVE_MEMFD_CREATE",
      "207:  memfd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
      "208: #else",
      "209:  memfd = open(\"/tmp\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0711);",
      "210: #endif",
      "211:  if (memfd < 0)",
      "212:   return -ENOTRECOVERABLE;",
      "214:  binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);",
      "215:  if (binfd < 0)",
      "216:   goto error;",
      "218:  sent = sendfile(memfd, binfd, NULL, RUNC_SENDFILE_MAX);",
      "219:  close(binfd);",
      "220:  if (sent < 0)",
      "221:   goto error;",
      "223: #ifdef HAVE_MEMFD_CREATE",
      "224:  int err = fcntl(memfd, F_ADD_SEALS, RUNC_MEMFD_SEALS);",
      "225:  if (err < 0)",
      "226:   goto error;",
      "227: #else",
      "229:  int newfd;",
      "230:  char *fdpath = NULL;",
      "232:  if (asprintf(&fdpath, \"/proc/self/fd/%d\", memfd) < 0)",
      "233:   goto error;",
      "234:  newfd = open(fdpath, O_RDONLY | O_CLOEXEC);",
      "235:  free(fdpath);",
      "236:  if (newfd < 0)",
      "237:   goto error;",
      "239:  close(memfd);",
      "240:  memfd = newfd;",
      "241: #endif",
      "242:  return memfd;",
      "244: error:",
      "245:  close(memfd);",
      "246:  return -EIO;",
      "247: }",
      "249: int ensure_cloned_binary(void)",
      "250: {",
      "251:  int execfd;",
      "252:  char **argv = NULL, **envp = NULL;",
      "255:  int cloned = is_self_cloned();",
      "256:  if (cloned > 0 || cloned == -ENOTRECOVERABLE)",
      "257:   return cloned;",
      "259:  if (fetchve(&argv, &envp) < 0)",
      "260:   return -EINVAL;",
      "262:  execfd = clone_binary();",
      "263:  if (execfd < 0)",
      "264:   return -EIO;",
      "266:  fexecve(execfd, argv, envp);",
      "267:  return -ENOEXEC;",
      "268: }",
      "",
      "---------------"
    ],
    "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
      "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "534:  free(namespaces);",
      "535: }",
      "537: void nsexec(void)",
      "538: {",
      "539:  int pipenum;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "538: extern int ensure_cloned_binary(void);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "549:  if (pipenum == -1)",
      "550:   return;",
      "553:  nl_parse(pipenum, &config);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "560:  if (ensure_cloned_binary() < 0)",
      "561:   bail(\"could not ensure we are a cloned binary\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bb7d8b1f41f7bf0399204d54009d6da57c3cc775",
      "candidate_info": {
        "commit_hash": "bb7d8b1f41f7bf0399204d54009d6da57c3cc775",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/bb7d8b1f41f7bf0399204d54009d6da57c3cc775",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "nsexec (CVE-2019-5736): avoid parsing environ\n\nMy first attempt to simplify this and make it less costly focussed on\nthe way constructors are called. I was under the impression that the ELF\nspecification mandated that arg, argv, and actually even envp need to be\npassed to functions located in the .init_arry section (aka\n\"constructors\"). Actually, the specifications is (cf. [2]):\n\nSHT_INIT_ARRAY\nThis section contains an array of pointers to initialization functions,\nas described in ``Initialization and Termination Functions'' in Chapter\n5. Each pointer in the array is taken as a parameterless procedure with\na void return.\n\nwhich means that this becomes a libc specific decision. Glibc passes\ndown those args, musl doesn't. So this approach can't work. However, we\ncan at least remove the environment parsing part based on POSIX since\n[1] mandates that there should be an environ variable defined in\nunistd.h which provides access to the environment. See also the relevant\nOpen Group specification [1].\n\n[1]: http://pubs.opengroup.org/onlinepubs/9699919799/\n[2]: http://www.sco.com/developers/gabi/latest/ch4.sheader.html#init_array\n\nFixes: CVE-2019-5736\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169: }",
          "177: {",
          "181:  cmdline = read_file(\"/proc/self/cmdline\", &cmdline_size);",
          "182:  if (!cmdline)",
          "183:   goto error;",
          "188:  if (parse_xargs(cmdline, cmdline_size, argv) <= 0)",
          "189:   goto error;",
          "193:  return 0;",
          "195: error:",
          "197:  free(cmdline);",
          "198:  return -EINVAL;",
          "199: }",
          "",
          "[Removed Lines]",
          "176: static int fetchve(char ***argv, char ***envp)",
          "178:  char *cmdline = NULL, *environ = NULL;",
          "179:  size_t cmdline_size, environ_size;",
          "184:  environ = read_file(\"/proc/self/environ\", &environ_size);",
          "185:  if (!environ)",
          "186:   goto error;",
          "190:  if (parse_xargs(environ, environ_size, envp) <= 0)",
          "191:   goto error;",
          "196:  free(environ);",
          "",
          "[Added Lines]",
          "176: static int fetchve(char ***argv)",
          "178:  char *cmdline = NULL;",
          "179:  size_t cmdline_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246:  return -EIO;",
          "247: }",
          "249: int ensure_cloned_binary(void)",
          "250: {",
          "251:  int execfd;",
          "255:  int cloned = is_self_cloned();",
          "256:  if (cloned > 0 || cloned == -ENOTRECOVERABLE)",
          "257:   return cloned;",
          "260:   return -EINVAL;",
          "262:  execfd = clone_binary();",
          "263:  if (execfd < 0)",
          "264:   return -EIO;",
          "267:  return -ENOEXEC;",
          "268: }",
          "",
          "[Removed Lines]",
          "252:  char **argv = NULL, **envp = NULL;",
          "259:  if (fetchve(&argv, &envp) < 0)",
          "266:  fexecve(execfd, argv, envp);",
          "",
          "[Added Lines]",
          "244: extern char **environ;",
          "249:  char **argv = NULL;",
          "256:  if (fetchve(&argv) < 0)",
          "263:  fexecve(execfd, argv, environ);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b775bf297c47a6bc50e36da89d1ec74a6fa01dc",
      "candidate_info": {
        "commit_hash": "5b775bf297c47a6bc50e36da89d1ec74a6fa01dc",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/5b775bf297c47a6bc50e36da89d1ec74a6fa01dc",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "nsenter: cloned_binary: detect and handle short copies\n\nFor a variety of reasons, sendfile(2) can end up doing a short-copy so\nwe need to just loop until we hit the binary size. Since /proc/self/exe\nis tautologically our own binary, there's no chance someone is going to\nmodify it underneath us (or changing the size).\n\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195: static int clone_binary(void)",
          "196: {",
          "197:  int binfd, memfd;",
          "200: #ifdef HAVE_MEMFD_CREATE",
          "201:  memfd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
          "",
          "[Removed Lines]",
          "198:  ssize_t sent = 0;",
          "",
          "[Added Lines]",
          "197:  struct stat statbuf = {};",
          "198:  size_t sent = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:  if (binfd < 0)",
          "210:   goto error;",
          "213:  close(binfd);",
          "215:   goto error;",
          "217: #ifdef HAVE_MEMFD_CREATE",
          "",
          "[Removed Lines]",
          "212:  sent = sendfile(memfd, binfd, NULL, RUNC_SENDFILE_MAX);",
          "214:  if (sent < 0)",
          "",
          "[Added Lines]",
          "212:  if (fstat(binfd, &statbuf) < 0)",
          "213:   goto error_binfd;",
          "215:  while (sent < statbuf.st_size) {",
          "216:   int n = sendfile(memfd, binfd, NULL, statbuf.st_size - sent);",
          "217:   if (n < 0)",
          "218:    goto error_binfd;",
          "219:   sent += n;",
          "220:  }",
          "222:  if (sent != statbuf.st_size)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "235: #endif",
          "236:  return memfd;",
          "238: error:",
          "239:  close(memfd);",
          "240:  return -EIO;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: error_binfd:",
          "247:  close(binfd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "16612d74de5f84977e50a9c8ead7f0e9e13b8628",
      "candidate_info": {
        "commit_hash": "16612d74de5f84977e50a9c8ead7f0e9e13b8628",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/16612d74de5f84977e50a9c8ead7f0e9e13b8628",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "nsenter: cloned_binary: try to ro-bind /proc/self/exe before copying\n\nThe usage of memfd_create(2) and other copying techniques is quite\nwasteful, despite attempts to minimise it with _LIBCONTAINER_STATEDIR.\nmemfd_create(2) added ~10M of memory usage to the cgroup associated with\nthe container, which can result in some setups getting OOM'd (or just\nhogging the hosts' memory when you have lots of created-but-not-started\ncontainers sticking around).\n\nThe easiest way of solving this is by creating a read-only bind-mount of\nthe binary, opening that read-only bindmount, and then umounting it to\nensure that the host won't accidentally be re-mounted read-write. This\navoids all copying and cleans up naturally like the other techniques\nused. Unfortunately, like the O_TMPFILE fallback, this requires being\nable to create a file inside _LIBCONTAINER_STATEDIR (since bind-mounting\nover the most obvious path -- /proc/self/exe -- is a *very bad idea*).\n\nUnfortunately detecting this isn't fool-proof -- on a system with a\nread-only root filesystem (that might become read-write during \"runc\ninit\" execution), we cannot tell whether we have already done an ro\nremount. As a partial mitigation, we store a _LIBCONTAINER_CLONED_BINARY\nenvironment variable which is checked *alongside* the protection being\npresent.\n\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <sys/types.h>",
          "29: #include <sys/stat.h>",
          "30: #include <sys/vfs.h>",
          "31: #include <sys/mman.h>",
          "32: #include <sys/sendfile.h>",
          "33: #include <sys/syscall.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include <sys/statfs.h>",
          "33: #include <sys/mount.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: #endif",
          "70: #define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"",
          "71: #define RUNC_MEMFD_SEALS \\",
          "72:  (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: #define CLONED_BINARY_ENV \"_LIBCONTAINER_CLONED_BINARY\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88: static int is_self_cloned(void)",
          "89: {",
          "90:  int fd, ret, is_cloned = 0;",
          "92:  fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);",
          "93:  if (fd < 0)",
          "94:   return -ENOTRECOVERABLE;",
          "97:  ret = fcntl(fd, F_GET_SEALS);",
          "98:  if (ret >= 0) {",
          "99:   is_cloned = (ret == RUNC_MEMFD_SEALS);",
          "112:  }",
          "114:  close(fd);",
          "115:  return is_cloned;",
          "116: }",
          "",
          "[Removed Lines]",
          "100:  } else {",
          "109:   struct stat statbuf = {};",
          "110:   if (fstat(fd, &statbuf) >= 0)",
          "111:    is_cloned = (statbuf.st_nlink == 0);",
          "",
          "[Added Lines]",
          "94:  struct stat statbuf = {};",
          "95:  struct statfs fsbuf = {};",
          "110:   goto out;",
          "118:  if (!getenv(CLONED_BINARY_ENV)) {",
          "119:   is_cloned = false;",
          "120:   goto out;",
          "121:  }",
          "129:  if (fstatfs(fd, &fsbuf) >= 0)",
          "130:   is_cloned |= (fsbuf.f_flags & MS_RDONLY);",
          "140:  if (fstat(fd, &statbuf) >= 0)",
          "141:   is_cloned |= (statbuf.st_nlink == 0);",
          "143: out:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "227:   return -1;",
          "234:  fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
          "235:  if (fd >= 0)",
          "236:   return fd;",
          "240: #ifdef O_TMPFILE",
          "",
          "[Removed Lines]",
          "237:  if (errno != ENOSYS)",
          "238:   goto err;",
          "",
          "[Added Lines]",
          "268:  if (errno != ENOSYS && errno != EINVAL)",
          "269:   goto error;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "266:   errno = EISDIR;",
          "267:  }",
          "268:  if (errno != EISDIR)",
          "",
          "[Removed Lines]",
          "269:   goto err;",
          "",
          "[Added Lines]",
          "300:   goto error;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "281:   close(fd);",
          "282:  }",
          "286:  return -1;",
          "287: }",
          "",
          "[Removed Lines]",
          "284: err:",
          "",
          "[Added Lines]",
          "315: error:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "316:  return -1;",
          "317: }",
          "319: static int clone_binary(void)",
          "320: {",
          "322:  struct stat statbuf = {};",
          "323:  size_t sent = 0;",
          "324:  int fdtype = EFD_NONE;",
          "328:   return -ENOTRECOVERABLE;",
          "330:  binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);",
          "",
          "[Removed Lines]",
          "321:  int binfd, memfd;",
          "326:  memfd = make_execfd(&fdtype);",
          "327:  if (memfd < 0 || fdtype == EFD_NONE)",
          "",
          "[Added Lines]",
          "350: static int try_bindfd(void)",
          "351: {",
          "352:  int fd, ret = -1;",
          "353:  char template[PATH_MAX] = {0};",
          "354:  char *prefix = secure_getenv(\"_LIBCONTAINER_STATEDIR\");",
          "356:  if (!prefix || *prefix != '/')",
          "357:   prefix = \"/tmp\";",
          "358:  if (snprintf(template, sizeof(template), \"%s/runc.XXXXXX\", prefix) < 0)",
          "359:   return ret;",
          "365:  fd = mkstemp(template);",
          "366:  if (fd < 0)",
          "367:   return ret;",
          "368:  close(fd);",
          "375:  ret = -EPERM;",
          "376:  if (mount(\"/proc/self/exe\", template, \"\", MS_BIND, \"\") < 0)",
          "377:   goto out;",
          "378:  if (mount(\"\", template, \"\", MS_REMOUNT | MS_BIND | MS_RDONLY, \"\") < 0)",
          "379:   goto out_umount;",
          "383:  ret = open(template, O_PATH | O_CLOEXEC);",
          "385: out_umount:",
          "391:  if (umount2(template, MNT_DETACH) < 0) {",
          "392:   if (ret >= 0)",
          "393:    close(ret);",
          "394:   ret = -ENOTRECOVERABLE;",
          "395:  }",
          "397: out:",
          "402:  unlink(template);",
          "403:  return ret;",
          "404: }",
          "408:  int binfd, execfd;",
          "417:  execfd = try_bindfd();",
          "418:  if (execfd >= 0)",
          "419:   return execfd;",
          "425:  execfd = make_execfd(&fdtype);",
          "426:  if (execfd < 0 || fdtype == EFD_NONE)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "335:   goto error_binfd;",
          "337:  while (sent < statbuf.st_size) {",
          "339:   if (n < 0)",
          "340:    goto error_binfd;",
          "341:   sent += n;",
          "",
          "[Removed Lines]",
          "338:   int n = sendfile(memfd, binfd, NULL, statbuf.st_size - sent);",
          "",
          "[Added Lines]",
          "437:   int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "344:  if (sent != statbuf.st_size)",
          "345:   goto error;",
          "348:   goto error;",
          "351: error_binfd:",
          "352:  close(binfd);",
          "353: error:",
          "355:  return -EIO;",
          "356: }",
          "",
          "[Removed Lines]",
          "347:  if (seal_execfd(&memfd, fdtype) < 0)",
          "349:  return memfd;",
          "354:  close(memfd);",
          "",
          "[Added Lines]",
          "446:  if (seal_execfd(&execfd, fdtype) < 0)",
          "449:  return execfd;",
          "454:  close(execfd);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "375:  if (execfd < 0)",
          "376:   return -EIO;",
          "378:  fexecve(execfd, argv, environ);",
          "379:  return -ENOEXEC;",
          "380: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "478:  if (putenv(CLONED_BINARY_ENV \"=1\"))",
          "479:   goto error;",
          "482: error:",
          "483:  close(execfd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2429d59352b81f6b9cc79b5ed26780c5fe6ba4ec",
      "candidate_info": {
        "commit_hash": "2429d59352b81f6b9cc79b5ed26780c5fe6ba4ec",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/2429d59352b81f6b9cc79b5ed26780c5fe6ba4ec",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "nsenter: cloned_binary: expand and add pre-3.11 fallbacks\n\nIn order to get around the memfd_create(2) requirement, 0a8e4117e7f7\n(\"nsenter: clone /proc/self/exe to avoid exposing host binary to\ncontainer\") added an O_TMPFILE fallback. However, this fallback was\nflawed in two ways:\n\n * It required O_TMPFILE which is relatively new (having been added to\n   Linux 3.11).\n\n * The fallback choice was made at compile-time, not runtime. This\n   results in several complications when it comes to running binaries\n   on different machines to the ones they were built on.\n\nThe easiest way to resolve these things is to have fallbacks work in a\nmore procedural way (though it does make the code unfortunately more\ncomplicated) and to add a new fallback that uses mkotemp(3).\n\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #if !defined(SYS_memfd_create) && defined(__NR_memfd_create)",
          "37: #  define SYS_memfd_create __NR_memfd_create",
          "38: #endif",
          "46: int memfd_create(const char *name, unsigned int flags)",
          "47: {",
          "48:  return syscall(SYS_memfd_create, name, flags);",
          "50: #endif",
          "53: #ifndef F_LINUX_SPECIFIC_BASE",
          "",
          "[Removed Lines]",
          "39: #ifdef SYS_memfd_create",
          "40: #  define HAVE_MEMFD_CREATE",
          "42: #  ifndef MFD_CLOEXEC",
          "43: #    define MFD_CLOEXEC       0x0001U",
          "44: #    define MFD_ALLOW_SEALING 0x0002U",
          "45: #  endif",
          "49: }",
          "",
          "[Added Lines]",
          "40: #ifndef MFD_CLOEXEC",
          "41: #  define MFD_CLOEXEC       0x0001U",
          "42: #  define MFD_ALLOW_SEALING 0x0002U",
          "43: #endif",
          "46: #ifdef SYS_memfd_create",
          "48: #else",
          "49:  errno = ENOSYS;",
          "50:  return -1;",
          "52: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65: #endif",
          "70:  (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)",
          "73: static void *must_realloc(void *ptr, size_t size)",
          "74: {",
          "",
          "[Removed Lines]",
          "67: #ifdef HAVE_MEMFD_CREATE",
          "68: #  define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"",
          "69: #  define RUNC_MEMFD_SEALS \\",
          "71: #endif",
          "",
          "[Added Lines]",
          "70: #define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"",
          "71: #define RUNC_MEMFD_SEALS \\",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:  if (fd < 0)",
          "93:   return -ENOTRECOVERABLE;",
          "96:  ret = fcntl(fd, F_GET_SEALS);",
          "104:  close(fd);",
          "105:  return is_cloned;",
          "106: }",
          "112: static char *read_file(char *path, size_t *length)",
          "113: {",
          "114:  int fd;",
          "",
          "[Removed Lines]",
          "95: #ifdef HAVE_MEMFD_CREATE",
          "97:  is_cloned = (ret == RUNC_MEMFD_SEALS);",
          "98: #else",
          "99:  struct stat statbuf = {0};",
          "100:  ret = fstat(fd, &statbuf);",
          "101:  if (ret >= 0)",
          "102:   is_cloned = (statbuf.st_nlink == 0);",
          "103: #endif",
          "",
          "[Added Lines]",
          "98:  if (ret >= 0) {",
          "99:   is_cloned = (ret == RUNC_MEMFD_SEALS);",
          "100:  } else {",
          "109:   struct stat statbuf = {};",
          "110:   if (fstat(fd, &statbuf) >= 0)",
          "111:    is_cloned = (statbuf.st_nlink == 0);",
          "112:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:  return -EINVAL;",
          "192: }",
          "194: static int clone_binary(void)",
          "195: {",
          "196:  int binfd, memfd;",
          "197:  struct stat statbuf = {};",
          "198:  size_t sent = 0;",
          "206:   return -ENOTRECOVERABLE;",
          "208:  binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);",
          "",
          "[Removed Lines]",
          "200: #ifdef HAVE_MEMFD_CREATE",
          "201:  memfd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
          "202: #else",
          "203:  memfd = open(\"/tmp\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0711);",
          "204: #endif",
          "205:  if (memfd < 0)",
          "",
          "[Added Lines]",
          "201: enum {",
          "202:  EFD_NONE = 0,",
          "203:  EFD_MEMFD,",
          "204:  EFD_FILE,",
          "205: };",
          "212: #ifndef O_TMPFILE",
          "213: #  if defined(__O_TMPFILE) && defined(O_DIRECTORY)",
          "214: #    define O_TMPFILE (__O_TMPFILE | O_DIRECTORY)",
          "215: #  endif",
          "216: #endif",
          "218: static int make_execfd(int *fdtype)",
          "219: {",
          "220:  int fd;",
          "221:  char template[] = \"/tmp/runc-cloned-binary.XXXXXX\";",
          "228:  fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
          "229:  if (fd >= 0)",
          "230:   return fd;",
          "231:  if (errno != ENOSYS)",
          "232:   goto err;",
          "234: #ifdef O_TMPFILE",
          "241:  fd = open(\"/tmp\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);",
          "242:  if (fd >= 0) {",
          "243:   struct stat statbuf = {};",
          "244:   bool working_otmpfile = false;",
          "252:   if (fstat(fd, &statbuf) >= 0)",
          "253:    working_otmpfile = (statbuf.st_nlink == 0);",
          "255:   if (working_otmpfile)",
          "256:    return fd;",
          "259:   close(fd);",
          "260:   errno = EISDIR;",
          "261:  }",
          "262:  if (errno != EISDIR)",
          "263:   goto err;",
          "271:  fd = mkostemp(template, O_CLOEXEC);",
          "272:  if (fd >= 0) {",
          "273:   if (unlink(template) >= 0)",
          "274:    return fd;",
          "275:   close(fd);",
          "276:  }",
          "278: err:",
          "280:  return -1;",
          "281: }",
          "283: static int seal_execfd(int *fd, int fdtype)",
          "284: {",
          "285:  switch (fdtype) {",
          "286:  case EFD_MEMFD:",
          "287:   return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);",
          "288:  case EFD_FILE: {",
          "290:   int newfd;",
          "291:   char fdpath[PATH_MAX] = {0};",
          "293:   if (fchmod(*fd, 0100) < 0)",
          "294:    return -1;",
          "296:   if (snprintf(fdpath, sizeof(fdpath), \"/proc/self/fd/%d\", *fd) < 0)",
          "297:    return -1;",
          "299:   newfd = open(fdpath, O_PATH | O_CLOEXEC);",
          "300:   if (newfd < 0)",
          "301:    return -1;",
          "303:   close(*fd);",
          "305:   return 0;",
          "306:  }",
          "307:  default:",
          "308:     break;",
          "309:  }",
          "310:  return -1;",
          "311: }",
          "318:  int fdtype = EFD_NONE;",
          "320:  memfd = make_execfd(&fdtype);",
          "321:  if (memfd < 0 || fdtype == EFD_NONE)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "222:  if (sent != statbuf.st_size)",
          "223:   goto error;",
          "239:   goto error;",
          "244:  return memfd;",
          "246: error_binfd:",
          "",
          "[Removed Lines]",
          "225: #ifdef HAVE_MEMFD_CREATE",
          "226:  int err = fcntl(memfd, F_ADD_SEALS, RUNC_MEMFD_SEALS);",
          "227:  if (err < 0)",
          "228:   goto error;",
          "229: #else",
          "231:  int newfd;",
          "232:  char *fdpath = NULL;",
          "234:  if (asprintf(&fdpath, \"/proc/self/fd/%d\", memfd) < 0)",
          "235:   goto error;",
          "236:  newfd = open(fdpath, O_RDONLY | O_CLOEXEC);",
          "237:  free(fdpath);",
          "238:  if (newfd < 0)",
          "241:  close(memfd);",
          "242:  memfd = newfd;",
          "243: #endif",
          "",
          "[Added Lines]",
          "341:  if (seal_execfd(&memfd, fdtype) < 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d4a37b427167907ef2402586a8e8e2931a22490",
      "candidate_info": {
        "commit_hash": "2d4a37b427167907ef2402586a8e8e2931a22490",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/2d4a37b427167907ef2402586a8e8e2931a22490",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "nsenter: cloned_binary: userspace copy fallback if sendfile fails\n\nThere are some circumstances where sendfile(2) can fail (one example is\nthat AppArmor appears to block writing to deleted files with sendfile(2)\nunder some circumstances) and so we need to have a userspace fallback.\nIt's fairly trivial (and handles short-writes).\n\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  for (;;) {",
          "165:   n = read(fd, buf, sizeof(buf));",
          "166:   if (n < 0)",
          "",
          "[Removed Lines]",
          "163:   int n;",
          "",
          "[Added Lines]",
          "163:   ssize_t n;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "403:  return ret;",
          "404: }",
          "406: static int clone_binary(void)",
          "407: {",
          "408:  int binfd, execfd;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "406: static ssize_t fd_to_fd(int outfd, int infd)",
          "407: {",
          "408:  ssize_t total = 0;",
          "409:  char buffer[4096];",
          "411:  for (;;) {",
          "412:   ssize_t nread, nwritten = 0;",
          "414:   nread = read(infd, buffer, sizeof(buffer));",
          "415:   if (nread < 0)",
          "416:    return -1;",
          "417:   if (!nread)",
          "418:    break;",
          "420:   do {",
          "421:    ssize_t n = write(outfd, buffer + nwritten, nread - nwritten);",
          "422:    if (n < 0)",
          "423:     return -1;",
          "424:    nwritten += n;",
          "425:   } while(nwritten < nread);",
          "427:   total += nwritten;",
          "428:  }",
          "430:  return total;",
          "431: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "436:  while (sent < statbuf.st_size) {",
          "437:   int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);",
          "440:   sent += n;",
          "441:  }",
          "442:  close(binfd);",
          "",
          "[Removed Lines]",
          "438:   if (n < 0)",
          "439:    goto error_binfd;",
          "",
          "[Added Lines]",
          "465:   if (n < 0) {",
          "467:    n = fd_to_fd(execfd, binfd);",
          "468:    if (n < 0)",
          "469:     goto error_binfd;",
          "470:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
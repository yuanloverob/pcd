{
  "cve_id": "CVE-2022-36085",
  "cve_desc": "Open Policy Agent (OPA) is an open source, general-purpose policy engine. The Rego compiler provides a (deprecated) `WithUnsafeBuiltins` function, which allows users to provide a set of built-in functions that should be deemed unsafe \u2014 and as such rejected \u2014 by the compiler if encountered in the policy compilation stage. A bypass of this protection has been found, where the use of the `with` keyword to mock such a built-in function (a feature introduced in OPA v0.40.0), isn\u2019t taken into account by `WithUnsafeBuiltins`. Multiple conditions need to be met in order to create an adverse effect. Version 0.43.1 contains a patch for this issue. As a workaround, avoid using the `WithUnsafeBuiltins` function and use the `capabilities` feature instead.",
  "repo": "open-policy-agent/opa",
  "patch_hash": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
  "patch_info": {
    "commit_hash": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
    "repo": "open-policy-agent/opa",
    "commit_url": "https://github.com/open-policy-agent/opa/commit/25a597bc3f4985162e7f65f9c36599f4f8f55823",
    "files": [
      "ast/compile.go",
      "ast/compile_test.go",
      "rego/rego_test.go"
    ],
    "message": "ast/compile: respect unsafeBuiltinMap for 'with' replacements (#5107)\n\nThe changes are necessary for both the Compiler and the QueryCompiler. Tests\nhave been added to ensure that the code path through the rego package has also\nbeen fixed.\n\nFixes CVE-2022-36085.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
    "before_after_code_files": [
      "ast/compile.go||ast/compile.go",
      "ast/compile_test.go||ast/compile_test.go",
      "rego/rego_test.go||rego/rego_test.go"
    ]
  },
  "patch_diff": {
    "ast/compile.go||ast/compile.go": [
      "File: ast/compile.go -> ast/compile.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "2196:    if !ok {",
      "2197:     return x, nil",
      "2198:    }",
      "2200:    if err != nil {",
      "2201:     c.err(err)",
      "2202:    }",
      "",
      "[Removed Lines]",
      "2199:    body, err := rewriteWithModifiersInBody(c, f, body)",
      "",
      "[Added Lines]",
      "2199:    body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2475: }",
      "2477: func (qc *queryCompiler) checkUnsafeBuiltins(_ *QueryContext, body Body) (Body, error) {",
      "2485:  if len(errs) > 0 {",
      "2486:   return nil, errs",
      "2487:  }",
      "2488:  return body, nil",
      "2489: }",
      "2491: func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Body, error) {",
      "2492:  errs := checkDeprecatedBuiltins(qc.compiler.deprecatedBuiltinsMap, body, qc.compiler.strict)",
      "2493:  if len(errs) > 0 {",
      "",
      "[Removed Lines]",
      "2478:  var unsafe map[string]struct{}",
      "2479:  if qc.unsafeBuiltins != nil {",
      "2480:   unsafe = qc.unsafeBuiltins",
      "2481:  } else {",
      "2482:   unsafe = qc.compiler.unsafeBuiltinsMap",
      "2483:  }",
      "2484:  errs := checkUnsafeBuiltins(unsafe, body)",
      "",
      "[Added Lines]",
      "2478:  errs := checkUnsafeBuiltins(qc.unsafeBuiltinsMap(), body)",
      "2485: func (qc *queryCompiler) unsafeBuiltinsMap() map[string]struct{} {",
      "2486:  if qc.unsafeBuiltins != nil {",
      "2487:   return qc.unsafeBuiltins",
      "2488:  }",
      "2489:  return qc.compiler.unsafeBuiltinsMap",
      "2490: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2499: func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {",
      "2500:  f := newEqualityFactory(newLocalVarGenerator(\"q\", body))",
      "2502:  if err != nil {",
      "2503:   return nil, Errors{err}",
      "2504:  }",
      "",
      "[Removed Lines]",
      "2501:  body, err := rewriteWithModifiersInBody(qc.compiler, f, body)",
      "",
      "[Added Lines]",
      "2502:  body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4789:  var result Body",
      "4790:  for i := range body {",
      "4792:   if err != nil {",
      "4793:    return nil, err",
      "4794:   }",
      "",
      "[Removed Lines]",
      "4788: func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {",
      "4791:   exprs, err := rewriteWithModifier(c, f, body[i])",
      "",
      "[Added Lines]",
      "4789: func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {",
      "4792:   exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4803:  return result, nil",
      "4804: }",
      "4808:  var result []*Expr",
      "4809:  for i := range expr.With {",
      "4811:   if err != nil {",
      "4812:    return nil, err",
      "4813:   }",
      "",
      "[Removed Lines]",
      "4806: func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {",
      "4810:   eval, err := validateWith(c, expr, i)",
      "",
      "[Added Lines]",
      "4807: func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {",
      "4811:   eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4822:  return append(result, expr), nil",
      "4823: }",
      "4826:  target, value := expr.With[i].Target, expr.With[i].Value",
      "",
      "[Removed Lines]",
      "4825: func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {",
      "",
      "[Added Lines]",
      "4826: func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4831:    value.Value = Ref([]*Term{NewTerm(v)})",
      "4832:   }",
      "4833:  }",
      "4835:  switch {",
      "4836:  case isDataRef(target):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4835:  isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)",
      "4836:  if err != nil {",
      "4837:   return false, err",
      "4838:  }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4854:    if child := node.Child(ref[len(ref)-1].Value); child != nil {",
      "4855:     for _, v := range child.Values {",
      "4856:      if len(v.(*Rule).Head.Args) > 0 {",
      "4859:       }",
      "4860:      }",
      "4861:     }",
      "4862:    }",
      "4863:   }",
      "4864:  case isInputRef(target): // ok, valid",
      "",
      "[Removed Lines]",
      "4857:       if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
      "4858:        return false, nil",
      "4865:  case isBuiltinRefOrVar(c.builtins, target):",
      "",
      "[Added Lines]",
      "4862:       if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
      "4863:        return false, err // may be nil",
      "4870:  case isBuiltinRefOrVar:",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4876:    return false, err",
      "4877:   }",
      "4881:   }",
      "4882:  default:",
      "4883:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)",
      "",
      "[Removed Lines]",
      "4879:   if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
      "4880:    return false, nil",
      "",
      "[Added Lines]",
      "4884:   if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
      "4885:    return false, err // may be nil",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4906:  return nil",
      "4907: }",
      "4910:  if v, ok := value.Value.(Ref); ok {",
      "4911:   if ruleTree.Find(v) != nil { // ref exists in rule tree",
      "4913:   }",
      "4914:  }",
      "4916: }",
      "4918: func isInputRef(term *Term) bool {",
      "",
      "[Removed Lines]",
      "4909: func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {",
      "4912:    return true",
      "4915:  return isBuiltinRefOrVar(bs, value)",
      "",
      "[Added Lines]",
      "4914: func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {",
      "4917:    return true, nil",
      "4920:  return isBuiltinRefOrVar(bs, unsafeMap, value)",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4933:  return false",
      "4934: }",
      "4937:  switch v := term.Value.(type) {",
      "4938:  case Ref, Var:",
      "4939:   _, ok := bs[v.String()]",
      "4941:  }",
      "4943: }",
      "4945: func isVirtual(node *TreeNode, ref Ref) bool {",
      "",
      "[Removed Lines]",
      "4936: func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {",
      "4940:   return ok",
      "4942:  return false",
      "",
      "[Added Lines]",
      "4941: func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {",
      "4944:   if _, ok := unsafeBuiltinsMap[v.String()]; ok {",
      "4945:    return false, NewError(CompileErr, term.Location, \"with keyword replacing built-in function: target must not be unsafe: %q\", v)",
      "4946:   }",
      "4948:   return ok, nil",
      "4950:  return false, nil",
      "",
      "---------------"
    ],
    "ast/compile_test.go||ast/compile_test.go": [
      "File: ast/compile_test.go -> ast/compile_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "4049:  tests := []struct {",
      "4050:   note         string",
      "4051:   input        string",
      "4052:   expected     string",
      "4053:   expectedRule *Rule",
      "4054:   wantErr      error",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4052:   opts         func(*Compiler) *Compiler",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4154:     return r",
      "4155:    }(),",
      "4156:   },",
      "4157:   {",
      "4158:    note: \"built-in function: valid, arity 1, non-compound name\",",
      "4159:    input: `",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4158:   {",
      "4159:    note: \"built-in function: replaced by another built-in that's marked unsafe\",",
      "4160:    input: `",
      "4161:     q := is_object({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})",
      "4162:     p { q with is_object as http.send }",
      "4163:    `,",
      "4164:    opts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },",
      "4165:    wantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),",
      "4166:   },",
      "4167:   {",
      "4168:    note: \"non-built-in function: replaced by another built-in that's marked unsafe\",",
      "4169:    input: `",
      "4170:    r(_) = {}",
      "4171:    q := r({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})",
      "4172:    p {",
      "4173:     q with r as http.send",
      "4174:    }`,",
      "4175:    opts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },",
      "4176:    wantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),",
      "4177:   },",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4171:  for _, tc := range tests {",
      "4172:   t.Run(tc.note, func(t *testing.T) {",
      "4173:    c := NewCompiler()",
      "4174:    module := fixture + tc.input",
      "4175:    c.Modules[\"test\"] = MustParseModule(module)",
      "4176:    compileStages(c, c.rewriteWithModifiers)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4195:    if tc.opts != nil {",
      "4196:     c = tc.opts(c)",
      "4197:    }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "6676: }",
      "6678: func TestQueryCompilerWithUnsafeBuiltins(t *testing.T) {",
      "6686:  }",
      "6687: }",
      "",
      "[Removed Lines]",
      "6679:  c := NewCompiler().WithUnsafeBuiltins(map[string]struct{}{",
      "6680:   \"count\": {},",
      "6681:  })",
      "6683:  _, err := c.QueryCompiler().WithUnsafeBuiltins(map[string]struct{}{}).Compile(MustParseBody(\"count([])\"))",
      "6684:  if err != nil {",
      "6685:   t.Fatal(err)",
      "",
      "[Added Lines]",
      "6703:  tests := []struct {",
      "6704:   note     string",
      "6705:   query    string",
      "6706:   compiler *Compiler",
      "6707:   opts     func(QueryCompiler) QueryCompiler",
      "6708:   err      string",
      "6709:  }{",
      "6710:   {",
      "6711:    note:     \"builtin unsafe via compiler\",",
      "6712:    query:    \"count([])\",",
      "6713:    compiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "6714:    err:      \"unsafe built-in function calls in expression: count\",",
      "6715:   },",
      "6716:   {",
      "6717:    note:     \"builtin unsafe via query compiler\",",
      "6718:    query:    \"count([])\",",
      "6719:    compiler: NewCompiler(),",
      "6720:    opts: func(qc QueryCompiler) QueryCompiler {",
      "6721:     return qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})",
      "6722:    },",
      "6723:    err: \"unsafe built-in function calls in expression: count\",",
      "6724:   },",
      "6725:   {",
      "6726:    note:     \"builtin unsafe via compiler, 'with' mocking\",",
      "6727:    query:    \"is_array([]) with is_array as count\",",
      "6728:    compiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "6729:    err:      `with keyword replacing built-in function: target must not be unsafe: \"count\"`,",
      "6730:   },",
      "6731:   {",
      "6732:    note:     \"builtin unsafe via query compiler,  'with' mocking\",",
      "6733:    query:    \"is_array([]) with is_array as count\",",
      "6734:    compiler: NewCompiler(),",
      "6735:    opts: func(qc QueryCompiler) QueryCompiler {",
      "6736:     return qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})",
      "6737:    },",
      "6738:    err: `with keyword replacing built-in function: target must not be unsafe: \"count\"`,",
      "6739:   },",
      "6740:  }",
      "6742:  for _, tc := range tests {",
      "6743:   t.Run(tc.note, func(t *testing.T) {",
      "6744:    qc := tc.compiler.QueryCompiler()",
      "6745:    if tc.opts != nil {",
      "6746:     qc = tc.opts(qc)",
      "6747:    }",
      "6748:    _, err := qc.Compile(MustParseBody(tc.query))",
      "6749:    var errs Errors",
      "6750:    if !errors.As(err, &errs) {",
      "6751:     t.Fatalf(\"expected error type %T, got %v %[2]T\", errs, err)",
      "6752:    }",
      "6753:    if exp, act := 1, len(errs); exp != act {",
      "6754:     t.Fatalf(\"expected %d error(s), got %d\", exp, act)",
      "6755:    }",
      "6756:    if exp, act := tc.err, errs[0].Message; exp != act {",
      "6757:     t.Errorf(\"expected message %q, got %q\", exp, act)",
      "6758:    }",
      "6759:   })",
      "",
      "---------------"
    ],
    "rego/rego_test.go||rego/rego_test.go": [
      "File: rego/rego_test.go -> rego/rego_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1437:  ctx := context.Background()",
      "1439:  unsafeCountExpr := \"unsafe built-in function calls in expression: count\"",
      "1441:  t.Run(\"unsafe query\", func(t *testing.T) {",
      "1442:   r := New(",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1440:  unsafeCountExprWith := `with keyword replacing built-in function: target must not be unsafe: \"count\"`",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1448:   }",
      "1449:  })",
      "1451:  t.Run(\"unsafe module\", func(t *testing.T) {",
      "1452:   r := New(",
      "1453:    Query(`data.pkg.deny`),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1452:  t.Run(\"unsafe query, 'with' replacement\", func(t *testing.T) {",
      "1453:   r := New(",
      "1454:    Query(`is_array([1, 2, 3]) with is_array as count`),",
      "1455:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1456:   )",
      "1457:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1458:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1459:   }",
      "1460:  })",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1463:   }",
      "1464:  })",
      "1466:  t.Run(\"inherit in query\", func(t *testing.T) {",
      "1467:   r := New(",
      "1468:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1477:  t.Run(\"unsafe module, 'with' replacement in query\", func(t *testing.T) {",
      "1478:   r := New(",
      "1479:    Query(`data.pkg.deny with is_array as count`),",
      "1480:    Module(\"pkg.rego\", `package pkg",
      "1481:    deny {",
      "1482:     is_array(input.requests) > 10",
      "1483:    }",
      "1484:    `),",
      "1485:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1486:   )",
      "1487:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1488:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1489:   }",
      "1490:  })",
      "1492:  t.Run(\"unsafe module, 'with' replacement in module\", func(t *testing.T) {",
      "1493:   r := New(",
      "1494:    Query(`data.pkg.deny`),",
      "1495:    Module(\"pkg.rego\", `package pkg",
      "1496:    deny {",
      "1497:     is_array(input.requests) > 10 with is_array as count",
      "1498:    }",
      "1499:    `),",
      "1500:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1501:   )",
      "1502:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1503:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1504:   }",
      "1505:  })",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1473:   }",
      "1474:  })",
      "1476:  t.Run(\"override/disable in query\", func(t *testing.T) {",
      "1477:   r := New(",
      "1478:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1517:  t.Run(\"inherit in query, 'with' replacement\", func(t *testing.T) {",
      "1518:   r := New(",
      "1519:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "1520:    Query(\"is_array([]) with is_array as count\"),",
      "1521:   )",
      "1522:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1523:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1524:   }",
      "1525:  })",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3406e96789771e992a0dcc20b87af79529d05b26",
      "candidate_info": {
        "commit_hash": "3406e96789771e992a0dcc20b87af79529d05b26",
        "repo": "open-policy-agent/opa",
        "commit_url": "https://github.com/open-policy-agent/opa/commit/3406e96789771e992a0dcc20b87af79529d05b26",
        "files": [
          "ast/compile.go",
          "ast/compile_test.go",
          "docs/content/policy-language.md",
          "internal/planner/planner.go",
          "internal/wasm/sdk/test/e2e/exceptions.yaml",
          "test/cases/testdata/withkeyword/test-with-builtin-mock.yaml",
          "test/cases/testdata/withkeyword/test-with-function-mock.yaml",
          "test/cases/testdata/withkeyword/test-with-function-mocks-issue-5299.yaml",
          "topdown/eval.go"
        ],
        "message": "ast/compile: rewrite ref-replacements with non-function values (#5301)\n\nBefore, this was OK:\n\n    test_a {\n    . mock_f := true\n      allow with f as mock_f\n    }\n\nbut this had panicked:\n\n    mock_f := true\n    test_a {\n      allow with f as mock_f\n    }\n\nWhich, from a user perspective, is quite incomprehensible. Technically,\nthe first snippet was a (supported) replacement-by-value, and the second\nwas an unsupported replacement by a rule that was not a function.\n\nFurthermore, the second case wasn't properly caught in the 'with' validations.\n\nNow, we'll capture the situation, and start supporting it. Both snippets will\nnow work the same, as one would expect from the language surface.\n\nFixes #5299.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
        "before_after_code_files": [
          "ast/compile.go||ast/compile.go",
          "ast/compile_test.go||ast/compile_test.go",
          "internal/planner/planner.go||internal/planner/planner.go",
          "topdown/eval.go||topdown/eval.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ],
          "candidate": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ]
        }
      },
      "candidate_diff": {
        "ast/compile.go||ast/compile.go": [
          "File: ast/compile.go -> ast/compile.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5151:     for _, v := range child.Values {",
          "5152:      if len(v.(*Rule).Head.Args) > 0 {",
          "5153:       if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
          "5155:       }",
          "5156:      }",
          "5157:     }",
          "",
          "[Removed Lines]",
          "5154:        return false, err // may be nil",
          "",
          "[Added Lines]",
          "5154:        return false, err // err may be nil",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5173:   }",
          "5175:   if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
          "5177:   }",
          "5178:  default:",
          "5179:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)",
          "",
          "[Removed Lines]",
          "5176:    return false, err // may be nil",
          "",
          "[Added Lines]",
          "5176:    return false, err // err may be nil",
          "",
          "---------------"
        ],
        "ast/compile_test.go||ast/compile_test.go": [
          "File: ast/compile_test.go -> ast/compile_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5292:    `,",
          "5293:    expected: `p { true with http.send as {\"body\": \"yay\"} }`,",
          "5294:   },",
          "5295:   {",
          "5296:    note: \"built-in function: replaced by comprehension\",",
          "5297:    input: `",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5295:   {",
          "5296:    note: \"built-in function: replaced by var\",",
          "5297:    input: `",
          "5298:     p {",
          "5299:      resp := { \"body\": \"yay\" }",
          "5300:      true with http.send as resp",
          "5301:     }",
          "5302:    `,",
          "5303:    expected: `p { __local0__ = {\"body\": \"yay\"}; true with http.send as __local0__ }`,",
          "5304:   },",
          "5305:   {",
          "5306:    note: \"non-built-in function: replaced by var\",",
          "5307:    input: `",
          "5308:     p {",
          "5309:      resp := true",
          "5310:      f(true) with f as resp",
          "5311:     }",
          "5312:     f(false) { true }",
          "5313:    `,",
          "5314:    expected: `p { __local0__ = true; data.test.f(true) with data.test.f as __local0__ }`,",
          "5315:   },",
          "",
          "---------------"
        ],
        "internal/planner/planner.go||internal/planner/planner.go": [
          "File: internal/planner/planner.go -> internal/planner/planner.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "870:     if node := p.rules.Lookup(r); node != nil {",
          "875:      }",
          "878:     }",
          "889:    }",
          "890:   }",
          "892:   if node := p.rules.Lookup(op); node != nil {",
          "",
          "[Removed Lines]",
          "871:      p.mocks.Push() // new scope",
          "872:      name, err = p.planRules(node.Rules(), false)",
          "873:      if err != nil {",
          "874:       return err",
          "876:      p.mocks.Pop()",
          "877:      return p.planExprCallFunc(name, node.Arity(), void, operands, p.defaultOperands(), iter)",
          "880:     return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement)",
          "882:    default: // replacement is a value",
          "883:     if bi, ok := p.decls[operator]; ok {",
          "884:      return p.planExprCallValue(replacement, len(bi.Decl.FuncArgs().Args), operands, iter)",
          "885:     }",
          "886:     if node := p.rules.Lookup(op); node != nil {",
          "887:      return p.planExprCallValue(replacement, node.Arity(), operands, iter)",
          "888:     }",
          "",
          "[Added Lines]",
          "871:      if node.Arity() > 0 {",
          "872:       p.mocks.Push() // new scope",
          "873:       name, err = p.planRules(node.Rules(), false)",
          "874:       if err != nil {",
          "875:        return err",
          "876:       }",
          "877:       p.mocks.Pop()",
          "878:       return p.planExprCallFunc(name, node.Arity(), void, operands, p.defaultOperands(), iter)",
          "882:    }",
          "885:    if bi, ok := p.decls[operator]; ok {",
          "886:     return p.planExprCallValue(replacement, len(bi.Decl.FuncArgs().Args), operands, iter)",
          "887:    }",
          "888:    if node := p.rules.Lookup(op); node != nil {",
          "889:     return p.planExprCallValue(replacement, node.Arity(), operands, iter)",
          "891:    return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement) // should be unreachable",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "972: func (p *Planner) planExprCallFunc(name string, arity int, void bool, operands []*ast.Term, args []ir.Operand, iter planiter) error {",
          "977:   return p.planCallArgs(operands, 0, args, func(args []ir.Operand) error {",
          "",
          "[Removed Lines]",
          "974:  if len(operands) == arity {",
          "",
          "[Added Lines]",
          "976:  switch {",
          "977:  case len(operands) == arity:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "993:    return iter()",
          "994:   })",
          "1005:   })",
          "1008: }",
          "1010: func (p *Planner) planExprCallValue(value *ast.Term, arity int, operands []*ast.Term, iter planiter) error {",
          "1012:   return p.planCallArgs(operands, 0, nil, func([]ir.Operand) error {",
          "1013:    p.ltarget = p.newOperand()",
          "1014:    return p.planTerm(value, func() error {",
          "",
          "[Removed Lines]",
          "995:  }",
          "999:  return p.planCallArgs(operands[:len(operands)-1], 0, args, func(args []ir.Operand) error {",
          "1000:   result := p.newLocal()",
          "1001:   p.appendStmt(&ir.CallStmt{",
          "1002:    Func:   name,",
          "1003:    Args:   args,",
          "1004:    Result: result,",
          "1006:   return p.planUnifyLocal(op(result), operands[len(operands)-1], iter)",
          "1007:  })",
          "1011:  if len(operands) == arity { // call: f(x) # result not captured",
          "",
          "[Added Lines]",
          "999:  case len(operands) == arity+1:",
          "1002:   return p.planCallArgs(operands[:len(operands)-1], 0, args, func(args []ir.Operand) error {",
          "1003:    result := p.newLocal()",
          "1004:    p.appendStmt(&ir.CallStmt{",
          "1005:     Func:   name,",
          "1006:     Args:   args,",
          "1007:     Result: result,",
          "1008:    })",
          "1009:    return p.planUnifyLocal(op(result), operands[len(operands)-1], iter)",
          "1012:  default:",
          "1013:   return fmt.Errorf(\"impossible replacement, arity mismatch\")",
          "1014:  }",
          "1018:  switch {",
          "1019:  case len(operands) == arity: // call: f(x) # result not captured",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1019:     return iter()",
          "1020:    })",
          "1021:   })",
          "1029:   })",
          "1031: }",
          "1033: func (p *Planner) planCallArgs(terms []*ast.Term, idx int, args []ir.Operand, iter func([]ir.Operand) error) error {",
          "",
          "[Removed Lines]",
          "1022:  }",
          "1025:  return p.planCallArgs(operands[:len(operands)-1], 0, nil, func([]ir.Operand) error {",
          "1026:   p.ltarget = p.newOperand()",
          "1027:   return p.planTerm(value, func() error {",
          "1028:    return p.planUnifyLocal(p.ltarget, operands[len(operands)-1], iter)",
          "1030:  })",
          "",
          "[Added Lines]",
          "1031:  case len(operands) == arity+1: // call: f(x, 1) # caller captures result",
          "1032:   return p.planCallArgs(operands[:len(operands)-1], 0, nil, func([]ir.Operand) error {",
          "1033:    p.ltarget = p.newOperand()",
          "1034:    return p.planTerm(value, func() error {",
          "1035:     return p.planUnifyLocal(p.ltarget, operands[len(operands)-1], iter)",
          "1036:    })",
          "1038:  default:",
          "1039:   return fmt.Errorf(\"impossible replacement, arity mismatch\")",
          "1040:  }",
          "",
          "---------------"
        ],
        "topdown/eval.go||topdown/eval.go": [
          "File: topdown/eval.go -> topdown/eval.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "727:  var mocked bool",
          "728:  mock, mocked := e.functionMocks.Get(ref)",
          "729:  if mocked {",
          "731:    mockCall := append([]*ast.Term{ast.NewTerm(m)}, terms[1:]...)",
          "733:    e.functionMocks.Push()",
          "",
          "[Removed Lines]",
          "730:   if m, ok := mock.Value.(ast.Ref); ok { // builtin or data function",
          "",
          "[Added Lines]",
          "730:   if m, ok := mock.Value.(ast.Ref); ok && isFunction(e.compiler.TypeEnv, m) { // builtin or data function",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3402:  return !ref.HasPrefix(ast.DefaultRootRef) && !ref.HasPrefix(ast.InputRootRef)",
          "3403: }",
          "3408:   return false",
          "3409:  }",
          "3411:  return ok",
          "3412: }",
          "",
          "[Removed Lines]",
          "3405: func isFunction(env *ast.TypeEnv, ref *ast.Term) bool {",
          "3406:  r, ok := ref.Value.(ast.Ref)",
          "3407:  if !ok {",
          "3410:  _, ok = env.Get(r).(*types.Function)",
          "",
          "[Added Lines]",
          "3405: func isFunction(env *ast.TypeEnv, ref interface{}) bool {",
          "3406:  var r ast.Ref",
          "3407:  switch v := ref.(type) {",
          "3408:  case ast.Ref:",
          "3409:   r = v",
          "3410:  case *ast.Term:",
          "3411:   return isFunction(env, v.Value)",
          "3412:  case ast.Value:",
          "3414:  default:",
          "3415:   panic(\"expected ast.Value or *ast.Term\")",
          "3417:  _, ok := env.Get(r).(*types.Function)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
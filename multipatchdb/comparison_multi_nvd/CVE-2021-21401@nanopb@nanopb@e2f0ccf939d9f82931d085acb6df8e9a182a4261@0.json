{
  "cve_id": "CVE-2021-21401",
  "cve_desc": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.",
  "repo": "nanopb/nanopb",
  "patch_hash": "e2f0ccf939d9f82931d085acb6df8e9a182a4261",
  "patch_info": {
    "commit_hash": "e2f0ccf939d9f82931d085acb6df8e9a182a4261",
    "repo": "nanopb/nanopb",
    "commit_url": "https://github.com/nanopb/nanopb/commit/e2f0ccf939d9f82931d085acb6df8e9a182a4261",
    "files": [
      "pb_decode.c"
    ],
    "message": "Fix invalid free() with oneof (#647)\n\nNanopb would call free() or realloc() on an invalid\n(attacker controlled) pointer value when all the following\nconditions are true:\n\n- PB_ENABLE_MALLOC is defined at the compile time\n- Message definition contains an oneof field, and the oneof\n  contains at least one pointer type field and at least one\n  non-pointer type field.\n- Data being decoded first contains a non-pointer value for\n  the oneof field, and later contains an overwriting pointer\n  value.\n\nDepending on message layout, the bug may not be exploitable in all\ncases, but it is known to be exploitable at least with string and\nbytes fields. Actual security impact will also depend on the heap\nimplementation used.",
    "before_after_code_files": [
      "pb_decode.c||pb_decode.c"
    ]
  },
  "patch_diff": {
    "pb_decode.c||pb_decode.c": [
      "File: pb_decode.c -> pb_decode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1204:     pb_release_single_field(&old_field);",
      "1206:     return true;",
      "1207: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1206:     if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)",
      "1207:     {",
      "1211:         field->pData = NULL;",
      "1212:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a03bdfbb543fc62adbe150993f221646edb61f1",
      "candidate_info": {
        "commit_hash": "0a03bdfbb543fc62adbe150993f221646edb61f1",
        "repo": "nanopb/nanopb",
        "commit_url": "https://github.com/nanopb/nanopb/commit/0a03bdfbb543fc62adbe150993f221646edb61f1",
        "files": [
          "tests/alltypes_pointer/alltypes.options"
        ],
        "message": "fuzztest: Better coverage of static data in oneof (#647)\n\nPreviously added static_message member of the oneof\nhad the shortcoming that the first member of the submessage\nwas also a pointer. So when it aliased with a pointer to a message,\nit was still a valid NULL pointer.",
        "before_after_code_files": [
          "tests/alltypes_pointer/alltypes.options||tests/alltypes_pointer/alltypes.options"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/alltypes_pointer/alltypes.options||tests/alltypes_pointer/alltypes.options": [
          "File: tests/alltypes_pointer/alltypes.options -> tests/alltypes_pointer/alltypes.options",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # Generate all fields as pointers.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: SubMessage.substuff1 type:FT_STATIC max_size:8",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9cbe4ae6b03ae4ac2a678861101a9d771a6522ce",
      "candidate_info": {
        "commit_hash": "9cbe4ae6b03ae4ac2a678861101a9d771a6522ce",
        "repo": "nanopb/nanopb",
        "commit_url": "https://github.com/nanopb/nanopb/commit/9cbe4ae6b03ae4ac2a678861101a9d771a6522ce",
        "files": [
          "tests/regression/issue_647/SConscript",
          "tests/regression/issue_647/repro.c",
          "tests/regression/issue_647/repro.proto"
        ],
        "message": "Add testcase for #647: invalid free with oneof",
        "before_after_code_files": [
          "tests/regression/issue_647/repro.c||tests/regression/issue_647/repro.c",
          "tests/regression/issue_647/repro.proto||tests/regression/issue_647/repro.proto"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/regression/issue_647/repro.c||tests/regression/issue_647/repro.c": [
          "File: tests/regression/issue_647/repro.c -> tests/regression/issue_647/repro.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <pb_decode.h>",
          "2: #include <unittests.h>",
          "3: #include <malloc_wrappers.h>",
          "4: #include \"repro.pb.h\"",
          "6: int main() {",
          "7:   const uint8_t data[] = {0x08, 0x08, 0x2d};",
          "8:   int status = 0;",
          "9:   Repro repro = Repro_init_zero;",
          "11:   pb_istream_t stream = pb_istream_from_buffer(data, sizeof(data));",
          "12:   TEST(!pb_decode(&stream, Repro_fields, &repro));",
          "13:   TEST(get_alloc_count() == 0);",
          "15:   return status;",
          "16: }",
          "",
          "---------------"
        ],
        "tests/regression/issue_647/repro.proto||tests/regression/issue_647/repro.proto": [
          "File: tests/regression/issue_647/repro.proto -> tests/regression/issue_647/repro.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: syntax = \"proto3\";",
          "3: import \"nanopb.proto\";",
          "5: message Repro {",
          "6:   oneof value_type {",
          "7:     bool boolean_value = 1;",
          "8:     bytes bytes_value = 5 [(nanopb).type = FT_POINTER];",
          "9:   }",
          "10: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a375a560651a86726e5283be85a9231fd0efe9c",
      "candidate_info": {
        "commit_hash": "4a375a560651a86726e5283be85a9231fd0efe9c",
        "repo": "nanopb/nanopb",
        "commit_url": "https://github.com/nanopb/nanopb/commit/4a375a560651a86726e5283be85a9231fd0efe9c",
        "files": [
          "pb_decode.c"
        ],
        "message": "Fix invalid free() with oneof (#647)\n\nNanopb would call free() or realloc() on an invalid\n(attacker controlled) pointer value when all the following\nconditions are true:\n\n- PB_ENABLE_MALLOC is defined at the compile time\n- Message definition contains an oneof field, and the oneof\n  contains at least one pointer type field and at least one\n  non-pointer type field.\n- Data being decoded first contains a non-pointer value for\n  the oneof field, and later contains an overwriting pointer\n  value.\n\nDepending on message layout, the bug may not be exploitable in all\ncases, but it is known to be exploitable at least with string and\nbytes fields. Actual security impact will also depend on the heap\nimplementation used.",
        "before_after_code_files": [
          "pb_decode.c||pb_decode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "pb_decode.c||pb_decode.c"
          ],
          "candidate": [
            "pb_decode.c||pb_decode.c"
          ]
        }
      },
      "candidate_diff": {
        "pb_decode.c||pb_decode.c": [
          "File: pb_decode.c -> pb_decode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1151:     if (!pb_field_iter_find(iter, new_tag))",
          "1152:         PB_RETURN_ERROR(stream, \"iterator error\");",
          "1154:     return true;",
          "1155: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1154:     if (PB_ATYPE(iter->pos->type) == PB_ATYPE_POINTER)",
          "1155:     {",
          "1159:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
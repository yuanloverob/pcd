{
  "cve_id": "CVE-2023-28096",
  "cve_desc": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying system\u2019s availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
  "repo": "OpenSIPS/opensips",
  "patch_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
  "patch_info": {
    "commit_hash": "417568707520af25ec5c5dd91da18e6db3649dcb",
    "repo": "OpenSIPS/opensips",
    "commit_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
    "files": [
      "lib/cJSON.c"
    ],
    "message": "cJSON: fix memory leak on object parsing error\n\nIssue discovered during OpenSIPS Security Audit 2021/2022,\nby Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
    "before_after_code_files": [
      "lib/cJSON.c||lib/cJSON.c"
    ]
  },
  "patch_diff": {
    "lib/cJSON.c||lib/cJSON.c": [
      "File: lib/cJSON.c -> lib/cJSON.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1483: fail:",
      "1484:     if (item->child != NULL)",
      "1485:     {",
      "1487:         item->child = NULL;",
      "1488:     }",
      "",
      "[Removed Lines]",
      "1486:         cJSON_Delete(child);",
      "",
      "[Added Lines]",
      "1486:         cJSON_Delete(item->child);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "31e2f33ec2dd28d88c6d356e7cffeb6c53cd5ac1",
      "candidate_info": {
        "commit_hash": "31e2f33ec2dd28d88c6d356e7cffeb6c53cd5ac1",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/31e2f33ec2dd28d88c6d356e7cffeb6c53cd5ac1",
        "files": [
          "modules/rtp_relay/rtp_relay_ctx.c"
        ],
        "message": "Ignore faked replies",
        "before_after_code_files": [
          "modules/rtp_relay/rtp_relay_ctx.c||modules/rtp_relay/rtp_relay_ctx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/rtp_relay/rtp_relay_ctx.c||modules/rtp_relay/rtp_relay_ctx.c": [
          "File: modules/rtp_relay/rtp_relay_ctx.c -> modules/rtp_relay/rtp_relay_ctx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1285:   return -1;",
          "1286:  }",
          "1288:  switch (tmp->state) {",
          "1289:   case RTP_RELAY_TMP_OFFER:",
          "1290:    pbody = get_body_part(msg, TYPE_APPLICATION, SUBTYPE_SDP);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288:  if (msg == NULL || msg == FAKED_REPLY) {",
          "1290:   goto error;",
          "1291:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0823797713251ae530e06a622ea6f77fb923fac3",
      "candidate_info": {
        "commit_hash": "0823797713251ae530e06a622ea6f77fb923fac3",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/0823797713251ae530e06a622ea6f77fb923fac3",
        "files": [
          "modules/b2b_entities/dlg.c"
        ],
        "message": "b2b_entities: fix accessing $b2b_logic variables for PRACK requests\n\nFixes #2686\n\n(cherry picked from commit 3b6cf1640fc569a721574faaff4132b2e2d7c477)",
        "before_after_code_files": [
          "modules/b2b_entities/dlg.c||modules/b2b_entities/dlg.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/b2b_entities/dlg.c||modules/b2b_entities/dlg.c": [
          "File: modules/b2b_entities/dlg.c -> modules/b2b_entities/dlg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "994:    return SCB_RUN_ALL;",
          "995:   }",
          "996:  }",
          "997:  if (method_value == METHOD_PRACK)",
          "998:  {",
          "999:   lock_release(&table[hash_index].lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "998:  ctx = b2b_get_context();",
          "999:  if (!ctx) {",
          "1000:   LM_ERR(\"Failed to get b2b context\\n\");",
          "1001:   lock_release(&server_htable[hash_index].lock);",
          "1002:   return SCB_DROP_MSG;",
          "1003:  }",
          "1004:  if (dlg->param.s && pkg_str_dup(&ctx->b2bl_key, &dlg->param) < 0) {",
          "1005:   LM_ERR(\"Failed to copy b2b_logic key to b2b context\\n\");",
          "1006:   lock_release(&server_htable[hash_index].lock);",
          "1007:   return SCB_DROP_MSG;",
          "1008:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1015:   goto done;",
          "1016:  }",
          "1030:  if(dlg->state < B2B_CONFIRMED)",
          "1031:  {",
          "1032:   if(method_value != METHOD_UPDATE)",
          "",
          "[Removed Lines]",
          "1018:  ctx = b2b_get_context();",
          "1019:  if (!ctx) {",
          "1020:   LM_ERR(\"Failed to get b2b context\\n\");",
          "1021:   lock_release(&server_htable[hash_index].lock);",
          "1022:   return SCB_DROP_MSG;",
          "1023:  }",
          "1024:  if (dlg->param.s && pkg_str_dup(&ctx->b2bl_key, &dlg->param) < 0) {",
          "1025:   LM_ERR(\"Failed to copy b2b_logic key to b2b context\\n\");",
          "1026:   lock_release(&server_htable[hash_index].lock);",
          "1027:   return SCB_DROP_MSG;",
          "1028:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fcd765665a3095aacc55360df16e9304fec0ab75",
      "candidate_info": {
        "commit_hash": "fcd765665a3095aacc55360df16e9304fec0ab75",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/fcd765665a3095aacc55360df16e9304fec0ab75",
        "files": [
          "modules/tm/async.c"
        ],
        "message": "async(): Attempt to recover from abort() state\n\nIt seems the \"if\" condition at the start of t_resume_async() is\nactually reachable under the right circumstances and causes an\nimmediate program crash.\n\nAs an intermediate improvement until the source of the issue is found,\ntry to simply overwrite the unexpected context, if one is found.  A\nsmall memory leak coupled with a CRITICAL log message is preferable to\nan instant, forced crash.\n\n(cherry picked from commit 7167bec5b6379ba1a6762501391133deaf5ba80d)",
        "before_after_code_files": [
          "modules/tm/async.c||modules/tm/async.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/tm/async.c||modules/tm/async.c": [
          "File: modules/tm/async.c -> modules/tm/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:   LM_DBG(\"resuming without a fd, transaction %p \\n\", t);",
          "91:  if (current_processing_ctx) {",
          "94:  }",
          "",
          "[Removed Lines]",
          "92:   LM_CRIT(\"BUG - a context already set!\\n\");",
          "93:   abort();",
          "",
          "[Added Lines]",
          "92:   LM_CRIT(\"BUG - a context is already set (%p), overwriting it...\\n\",",
          "93:           current_processing_ctx);",
          "94:   current_processing_ctx = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba938f9d76b277e0cb9f4cf27f7ea46bd89ca917",
      "candidate_info": {
        "commit_hash": "ba938f9d76b277e0cb9f4cf27f7ea46bd89ca917",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/ba938f9d76b277e0cb9f4cf27f7ea46bd89ca917",
        "files": [
          "modules/tracer/tracer.c"
        ],
        "message": "[tracer] avoid parsing the shm cloned SIP msg\n\nThe TM TMCB_MSG_SENT_OUT callback may be called when doing a retransmission for a locally generated request. If for the original sending, a pkg malloc'ed sip_msg is passed to TMCB_MSG_SENT_OUT callback, for the retransmissions the shm cloned sip_msg is passed. As the 'tracer' callback (on TMCB_MSG_SENT_OUT) requires some FROM hdr parsing (to get the from tag), it should NOT parse directly on the shm cloned SIP msg as it will tain the shm sip_msg with pkg pointers -> better do a local parsing (not attached to the sip_msg) of the FROM HDR.\nThis issue was leading to pkg leaking (of the parsed FROM hdr in the shm cloned sip_msg) or it a crash if using failure route from the local route.\n\nNote: this is specific to using tracer module from the local route.\nCloses  #2728\n\n(cherry picked from commit 4eabea8a9eb0a08909854722972cd35164557c76)",
        "before_after_code_files": [
          "modules/tracer/tracer.c||modules/tracer/tracer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/tracer/tracer.c||modules/tracer/tracer.c": [
          "File: modules/tracer/tracer.c -> modules/tracer/tracer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2344:  static char toip_buff[IP_ADDR_MAX_STR_SIZE+12];",
          "2345:  struct ip_addr to_ip;",
          "2346:  trace_instance_p instance;",
          "2358:  }",
          "2360:  LM_DBG(\"trace msg out \\n\");",
          "",
          "[Removed Lines]",
          "2348:  if(parse_from_header(msg)==-1 || msg->from==NULL || get_from(msg)==NULL)",
          "2349:  {",
          "2350:   LM_ERR(\"cannot parse FROM header\\n\");",
          "2351:   goto error;",
          "2352:  }",
          "2354:  if(parse_headers(msg, HDR_CALLID_F, 0)!=0)",
          "2355:  {",
          "2356:   LM_ERR(\"cannot parse call-id\\n\");",
          "2357:   return;",
          "",
          "[Added Lines]",
          "2347:  struct to_body from_b;",
          "2348:  str from_tag;",
          "2350:  if (msg->msg_flags&FL_SHM_CLONE) {",
          "2355:   if (msg->from) {",
          "2356:    if (get_from(msg)) {",
          "2357:     from_tag = get_from(msg)->tag_value;",
          "2358:    } else {",
          "2359:     parse_to( msg->from->body.s,",
          "2360:      msg->from->body.s+msg->from->body.len+1, &from_b);",
          "2361:     if (from_b.error == PARSE_ERROR) {",
          "2362:      from_tag.s = NULL;",
          "2363:      from_tag.s = 0;",
          "2364:     } else {",
          "2365:      from_tag = from_b.tag_value;",
          "2366:      free_to_params(&from_b);",
          "2367:     }",
          "2368:    }",
          "2369:   } else {",
          "2370:    from_tag.s = NULL;",
          "2371:    from_tag.s = 0;",
          "2372:   }",
          "2373:  } else {",
          "2374:   if(parse_from_header(msg)==-1||msg->from==NULL||get_from(msg)==NULL)",
          "2375:   {",
          "2376:    LM_ERR(\"cannot parse FROM header\\n\");",
          "2377:    goto error;",
          "2378:   }",
          "2379:   from_tag = get_from(msg)->tag_value;",
          "2381:   if(parse_headers(msg, HDR_CALLID_F, 0)!=0)",
          "2382:   {",
          "2383:    LM_ERR(\"cannot parse call-id\\n\");",
          "2384:    return;",
          "2385:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2429:  db_vals[11].val.string_val = \"out\";",
          "2434:  for (instance = info->instances; instance; instance = instance->next) {",
          "2435:   if ( trace_check_legs( instance, leg_flag)) {",
          "",
          "[Removed Lines]",
          "2431:  db_vals[12].val.str_val.s = get_from(msg)->tag_value.s;",
          "2432:  db_vals[12].val.str_val.len = get_from(msg)->tag_value.len;",
          "",
          "[Added Lines]",
          "2459:  db_vals[12].val.str_val = from_tag;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f010ce818dc4c74732008ffbbfd2eb9f54465a64",
      "candidate_info": {
        "commit_hash": "f010ce818dc4c74732008ffbbfd2eb9f54465a64",
        "repo": "OpenSIPS/opensips",
        "commit_url": "https://github.com/OpenSIPS/opensips/commit/f010ce818dc4c74732008ffbbfd2eb9f54465a64",
        "files": [
          "modules/mi_script/mi_script.c"
        ],
        "message": "mi_script: prevent leak on write error case\n\nThanks go to Suchi Sahoo from Five9 for reporting it\n\n(cherry picked from commit 443fdf90e635b48debcf71449e6c72754e3b24c7)",
        "before_after_code_files": [
          "modules/mi_script/mi_script.c||modules/mi_script/mi_script.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/naveenecosmob/opensips/pull/1",
          "https://github.com/naveenecosmob/opensips/pull/5"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "modules/mi_script/mi_script.c||modules/mi_script/mi_script.c": [
          "File: modules/mi_script/mi_script.c -> modules/mi_script/mi_script.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "541:  mi_request_t *req;",
          "542: };",
          "544: static void mi_script_async_resume_job(int sender, void *param)",
          "545: {",
          "546:  int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "544: static void mi_script_async_job_free(struct mi_script_async_job *job)",
          "545: {",
          "546:  if (job->msg.s)",
          "547:   shm_free(job->msg.s);",
          "548:  shm_free(job);",
          "549: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "550:  do {",
          "551:   ret = write(job->fd, &r, sizeof r);",
          "552:  } while (ret < 0 && (errno == EINTR || errno == EAGAIN));",
          "554:   LM_ERR(\"could not notify resume: %s\\n\", strerror(errno));",
          "555: }",
          "557: static void mi_script_async_job(mi_response_t *resp, struct mi_script_async_job *job)",
          "",
          "[Removed Lines]",
          "553:  if (ret < 0)",
          "",
          "[Added Lines]",
          "560:  if (ret < 0) {",
          "562:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "573:  if (ipc_send_rpc(job->process_no, mi_script_async_resume_job, job) < 0) {",
          "574:   LM_ERR(\"could not resume async MI command!\\n\");",
          "578:  }",
          "579: }",
          "",
          "[Removed Lines]",
          "575:   if (job->msg.s)",
          "576:    shm_free(job->msg.s);",
          "577:   shm_free(job);",
          "",
          "[Added Lines]",
          "583:   mi_script_async_job_free(job);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "654:    ret = -3;",
          "655:  }",
          "656: end:",
          "660:  return ret;",
          "661: }",
          "",
          "[Removed Lines]",
          "657:  if (job->msg.s)",
          "658:   shm_free(job->msg.s);",
          "659:  shm_free(job);",
          "",
          "[Added Lines]",
          "663:  mi_script_async_job_free(job);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
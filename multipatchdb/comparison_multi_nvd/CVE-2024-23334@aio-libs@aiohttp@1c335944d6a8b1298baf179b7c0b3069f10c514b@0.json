{
  "cve_id": "CVE-2024-23334",
  "cve_desc": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. When using aiohttp as a web server and configuring static routes, it is necessary to specify the root path for static files. Additionally, the option 'follow_symlinks' can be used to determine whether to follow symbolic links outside the static root directory. When 'follow_symlinks' is set to True, there is no validation to check if reading a file is within the root directory. This can lead to directory traversal vulnerabilities, resulting in unauthorized access to arbitrary files on the system, even when symlinks are not present.  Disabling follow_symlinks and using a reverse proxy are encouraged mitigations.  Version 3.9.2 fixes this issue.",
  "repo": "aio-libs/aiohttp",
  "patch_hash": "1c335944d6a8b1298baf179b7c0b3069f10c514b",
  "patch_info": {
    "commit_hash": "1c335944d6a8b1298baf179b7c0b3069f10c514b",
    "repo": "aio-libs/aiohttp",
    "commit_url": "https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b",
    "files": [
      "CHANGES/8079.bugfix.rst",
      "aiohttp/web_urldispatcher.py",
      "docs/web_advanced.rst",
      "docs/web_reference.rst",
      "tests/test_web_urldispatcher.py"
    ],
    "message": "Validate static paths (#8079)\n\nCo-authored-by: J. Nick Koston <nick@koston.org>",
    "before_after_code_files": [
      "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
      "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
    ]
  },
  "patch_diff": {
    "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py": [
      "File: aiohttp/web_urldispatcher.py -> aiohttp/web_urldispatcher.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "573:             url = url / filename",
      "575:         if append_version:",
      "576:             try:",
      "579:                     filepath.relative_to(self._directory)",
      "580:             except (ValueError, FileNotFoundError):",
      "581:                 # ValueError for case when path point to symlink",
      "",
      "[Removed Lines]",
      "577:                 filepath = self._directory.joinpath(filename).resolve()",
      "578:                 if not self._follow_symlinks:",
      "",
      "[Added Lines]",
      "576:             unresolved_path = self._directory.joinpath(filename)",
      "578:                 if self._follow_symlinks:",
      "579:                     normalized_path = Path(os.path.normpath(unresolved_path))",
      "580:                     normalized_path.relative_to(self._directory)",
      "581:                     filepath = normalized_path.resolve()",
      "582:                 else:",
      "583:                     filepath = unresolved_path.resolve()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "640:                 # /static/\\\\machine_name\\c$ or /static/D:\\path",
      "641:                 # where the static dir is totally different",
      "642:                 raise HTTPForbidden()",
      "645:                 filepath.relative_to(self._directory)",
      "646:         except (ValueError, FileNotFoundError) as error:",
      "647:             # relatively safe",
      "",
      "[Removed Lines]",
      "643:             filepath = self._directory.joinpath(filename).resolve()",
      "644:             if not self._follow_symlinks:",
      "",
      "[Added Lines]",
      "648:             unresolved_path = self._directory.joinpath(filename)",
      "649:             if self._follow_symlinks:",
      "650:                 normalized_path = Path(os.path.normpath(unresolved_path))",
      "651:                 normalized_path.relative_to(self._directory)",
      "652:                 filepath = normalized_path.resolve()",
      "653:             else:",
      "654:                 filepath = unresolved_path.resolve()",
      "",
      "---------------"
    ],
    "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py": [
      "File: tests/test_web_urldispatcher.py -> tests/test_web_urldispatcher.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "108:     assert (await r.text()) == data",
      "111: @pytest.mark.parametrize(",
      "112:     \"dir_name,filename,data\",",
      "113:     [",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111: async def test_follow_symlink_directory_traversal(",
      "112:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
      "113: ) -> None:",
      "114:     # Tests that follow_symlinks does not allow directory transversal",
      "115:     data = \"private\"",
      "117:     private_file = tmp_path / \"private_file\"",
      "118:     private_file.write_text(data)",
      "120:     safe_path = tmp_path / \"safe_dir\"",
      "121:     safe_path.mkdir()",
      "123:     app = web.Application()",
      "125:     # Register global static route:",
      "126:     app.router.add_static(\"/\", str(safe_path), follow_symlinks=True)",
      "127:     client = await aiohttp_client(app)",
      "129:     await client.start_server()",
      "130:     # We need to use a raw socket to test this, as the client will normalize",
      "131:     # the path before sending it to the server.",
      "132:     reader, writer = await asyncio.open_connection(client.host, client.port)",
      "133:     writer.write(b\"GET /../private_file HTTP/1.1\\r\\n\\r\\n\")",
      "134:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
      "135:     assert b\"404 Not Found\" in response",
      "136:     writer.close()",
      "137:     await writer.wait_closed()",
      "138:     await client.close()",
      "141: async def test_follow_symlink_directory_traversal_after_normalization(",
      "142:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
      "143: ) -> None:",
      "144:     # Tests that follow_symlinks does not allow directory transversal",
      "145:     # after normalization",
      "146:     #",
      "147:     # Directory structure",
      "148:     # |-- secret_dir",
      "149:     # |   |-- private_file (should never be accessible)",
      "150:     # |   |-- symlink_target_dir",
      "151:     # |       |-- symlink_target_file (should be accessible via the my_symlink symlink)",
      "152:     # |       |-- sandbox_dir",
      "153:     # |           |-- my_symlink -> symlink_target_dir",
      "154:     #",
      "155:     secret_path = tmp_path / \"secret_dir\"",
      "156:     secret_path.mkdir()",
      "158:     # This file is below the symlink target and should not be reachable",
      "159:     private_file = secret_path / \"private_file\"",
      "160:     private_file.write_text(\"private\")",
      "162:     symlink_target_path = secret_path / \"symlink_target_dir\"",
      "163:     symlink_target_path.mkdir()",
      "165:     sandbox_path = symlink_target_path / \"sandbox_dir\"",
      "166:     sandbox_path.mkdir()",
      "168:     # This file should be reachable via the symlink",
      "169:     symlink_target_file = symlink_target_path / \"symlink_target_file\"",
      "170:     symlink_target_file.write_text(\"readable\")",
      "172:     my_symlink_path = sandbox_path / \"my_symlink\"",
      "173:     pathlib.Path(str(my_symlink_path)).symlink_to(str(symlink_target_path), True)",
      "175:     app = web.Application()",
      "177:     # Register global static route:",
      "178:     app.router.add_static(\"/\", str(sandbox_path), follow_symlinks=True)",
      "179:     client = await aiohttp_client(app)",
      "181:     await client.start_server()",
      "182:     # We need to use a raw socket to test this, as the client will normalize",
      "183:     # the path before sending it to the server.",
      "184:     reader, writer = await asyncio.open_connection(client.host, client.port)",
      "185:     writer.write(b\"GET /my_symlink/../private_file HTTP/1.1\\r\\n\\r\\n\")",
      "186:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
      "187:     assert b\"404 Not Found\" in response",
      "188:     writer.close()",
      "189:     await writer.wait_closed()",
      "191:     reader, writer = await asyncio.open_connection(client.host, client.port)",
      "192:     writer.write(b\"GET /my_symlink/symlink_target_file HTTP/1.1\\r\\n\\r\\n\")",
      "193:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
      "194:     assert b\"200 OK\" in response",
      "195:     response = await reader.readuntil(b\"readable\")",
      "196:     assert response == b\"readable\"",
      "197:     writer.close()",
      "198:     await writer.wait_closed()",
      "199:     await client.close()",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9118a5831e8a65b8c839eb7e4ac983e040ff41df",
      "candidate_info": {
        "commit_hash": "9118a5831e8a65b8c839eb7e4ac983e040ff41df",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/9118a5831e8a65b8c839eb7e4ac983e040ff41df",
        "files": [
          "CHANGES/8079.bugfix.rst",
          "aiohttp/web_urldispatcher.py",
          "docs/web_advanced.rst",
          "docs/web_reference.rst",
          "tests/test_web_urldispatcher.py"
        ],
        "message": "[PR #8079/1c335944 backport][3.9] Validate static paths (#8080)\n\n**This is a backport of PR #8079 as merged into master\n(1c335944d6a8b1298baf179b7c0b3069f10c514b).**",
        "before_after_code_files": [
          "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
          "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ],
          "candidate": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py": [
          "File: aiohttp/web_urldispatcher.py -> aiohttp/web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "595:             url = url / filename",
          "597:         if append_version:",
          "598:             try:",
          "601:                     filepath.relative_to(self._directory)",
          "602:             except (ValueError, FileNotFoundError):",
          "603:                 # ValueError for case when path point to symlink",
          "",
          "[Removed Lines]",
          "599:                 filepath = self._directory.joinpath(filename).resolve()",
          "600:                 if not self._follow_symlinks:",
          "",
          "[Added Lines]",
          "598:             unresolved_path = self._directory.joinpath(filename)",
          "600:                 if self._follow_symlinks:",
          "601:                     normalized_path = Path(os.path.normpath(unresolved_path))",
          "602:                     normalized_path.relative_to(self._directory)",
          "603:                     filepath = normalized_path.resolve()",
          "604:                 else:",
          "605:                     filepath = unresolved_path.resolve()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "662:                 # /static/\\\\machine_name\\c$ or /static/D:\\path",
          "663:                 # where the static dir is totally different",
          "664:                 raise HTTPForbidden()",
          "667:                 filepath.relative_to(self._directory)",
          "668:         except (ValueError, FileNotFoundError) as error:",
          "669:             # relatively safe",
          "",
          "[Removed Lines]",
          "665:             filepath = self._directory.joinpath(filename).resolve()",
          "666:             if not self._follow_symlinks:",
          "",
          "[Added Lines]",
          "670:             unresolved_path = self._directory.joinpath(filename)",
          "671:             if self._follow_symlinks:",
          "672:                 normalized_path = Path(os.path.normpath(unresolved_path))",
          "673:                 normalized_path.relative_to(self._directory)",
          "674:                 filepath = normalized_path.resolve()",
          "675:             else:",
          "676:                 filepath = unresolved_path.resolve()",
          "",
          "---------------"
        ],
        "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py": [
          "File: tests/test_web_urldispatcher.py -> tests/test_web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:     assert (await r.text()) == data",
          "133: @pytest.mark.parametrize(",
          "134:     \"dir_name,filename,data\",",
          "135:     [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: async def test_follow_symlink_directory_traversal(",
          "134:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
          "135: ) -> None:",
          "136:     # Tests that follow_symlinks does not allow directory transversal",
          "137:     data = \"private\"",
          "139:     private_file = tmp_path / \"private_file\"",
          "140:     private_file.write_text(data)",
          "142:     safe_path = tmp_path / \"safe_dir\"",
          "143:     safe_path.mkdir()",
          "145:     app = web.Application()",
          "147:     # Register global static route:",
          "148:     app.router.add_static(\"/\", str(safe_path), follow_symlinks=True)",
          "149:     client = await aiohttp_client(app)",
          "151:     await client.start_server()",
          "152:     # We need to use a raw socket to test this, as the client will normalize",
          "153:     # the path before sending it to the server.",
          "154:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "155:     writer.write(b\"GET /../private_file HTTP/1.1\\r\\n\\r\\n\")",
          "156:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "157:     assert b\"404 Not Found\" in response",
          "158:     writer.close()",
          "159:     await writer.wait_closed()",
          "160:     await client.close()",
          "163: async def test_follow_symlink_directory_traversal_after_normalization(",
          "164:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
          "165: ) -> None:",
          "166:     # Tests that follow_symlinks does not allow directory transversal",
          "167:     # after normalization",
          "168:     #",
          "169:     # Directory structure",
          "170:     # |-- secret_dir",
          "171:     # |   |-- private_file (should never be accessible)",
          "172:     # |   |-- symlink_target_dir",
          "173:     # |       |-- symlink_target_file (should be accessible via the my_symlink symlink)",
          "174:     # |       |-- sandbox_dir",
          "175:     # |           |-- my_symlink -> symlink_target_dir",
          "176:     #",
          "177:     secret_path = tmp_path / \"secret_dir\"",
          "178:     secret_path.mkdir()",
          "180:     # This file is below the symlink target and should not be reachable",
          "181:     private_file = secret_path / \"private_file\"",
          "182:     private_file.write_text(\"private\")",
          "184:     symlink_target_path = secret_path / \"symlink_target_dir\"",
          "185:     symlink_target_path.mkdir()",
          "187:     sandbox_path = symlink_target_path / \"sandbox_dir\"",
          "188:     sandbox_path.mkdir()",
          "190:     # This file should be reachable via the symlink",
          "191:     symlink_target_file = symlink_target_path / \"symlink_target_file\"",
          "192:     symlink_target_file.write_text(\"readable\")",
          "194:     my_symlink_path = sandbox_path / \"my_symlink\"",
          "195:     pathlib.Path(str(my_symlink_path)).symlink_to(str(symlink_target_path), True)",
          "197:     app = web.Application()",
          "199:     # Register global static route:",
          "200:     app.router.add_static(\"/\", str(sandbox_path), follow_symlinks=True)",
          "201:     client = await aiohttp_client(app)",
          "203:     await client.start_server()",
          "204:     # We need to use a raw socket to test this, as the client will normalize",
          "205:     # the path before sending it to the server.",
          "206:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "207:     writer.write(b\"GET /my_symlink/../private_file HTTP/1.1\\r\\n\\r\\n\")",
          "208:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "209:     assert b\"404 Not Found\" in response",
          "210:     writer.close()",
          "211:     await writer.wait_closed()",
          "213:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "214:     writer.write(b\"GET /my_symlink/symlink_target_file HTTP/1.1\\r\\n\\r\\n\")",
          "215:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "216:     assert b\"200 OK\" in response",
          "217:     response = await reader.readuntil(b\"readable\")",
          "218:     assert response == b\"readable\"",
          "219:     writer.close()",
          "220:     await writer.wait_closed()",
          "221:     await client.close()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6018c7f6977d9dc01af86435eb0edfa5fd91578f",
      "candidate_info": {
        "commit_hash": "6018c7f6977d9dc01af86435eb0edfa5fd91578f",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/6018c7f6977d9dc01af86435eb0edfa5fd91578f",
        "files": [
          "CHANGES/8079.bugfix.rst",
          "aiohttp/web_urldispatcher.py",
          "docs/web_advanced.rst",
          "docs/web_reference.rst",
          "tests/test_web_urldispatcher.py"
        ],
        "message": "[PR #8079/1c335944 backport][3.10] Validate static paths (#8081)\n\n**This is a backport of PR #8079 as merged into master\n(1c335944d6a8b1298baf179b7c0b3069f10c514b).**",
        "before_after_code_files": [
          "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
          "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ],
          "candidate": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py": [
          "File: aiohttp/web_urldispatcher.py -> aiohttp/web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "595:             url = url / filename",
          "597:         if append_version:",
          "598:             try:",
          "601:                     filepath.relative_to(self._directory)",
          "602:             except (ValueError, FileNotFoundError):",
          "603:                 # ValueError for case when path point to symlink",
          "",
          "[Removed Lines]",
          "599:                 filepath = self._directory.joinpath(filename).resolve()",
          "600:                 if not self._follow_symlinks:",
          "",
          "[Added Lines]",
          "598:             unresolved_path = self._directory.joinpath(filename)",
          "600:                 if self._follow_symlinks:",
          "601:                     normalized_path = Path(os.path.normpath(unresolved_path))",
          "602:                     normalized_path.relative_to(self._directory)",
          "603:                     filepath = normalized_path.resolve()",
          "604:                 else:",
          "605:                     filepath = unresolved_path.resolve()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "662:                 # /static/\\\\machine_name\\c$ or /static/D:\\path",
          "663:                 # where the static dir is totally different",
          "664:                 raise HTTPForbidden()",
          "667:                 filepath.relative_to(self._directory)",
          "668:         except (ValueError, FileNotFoundError) as error:",
          "669:             # relatively safe",
          "",
          "[Removed Lines]",
          "665:             filepath = self._directory.joinpath(filename).resolve()",
          "666:             if not self._follow_symlinks:",
          "",
          "[Added Lines]",
          "670:             unresolved_path = self._directory.joinpath(filename)",
          "671:             if self._follow_symlinks:",
          "672:                 normalized_path = Path(os.path.normpath(unresolved_path))",
          "673:                 normalized_path.relative_to(self._directory)",
          "674:                 filepath = normalized_path.resolve()",
          "675:             else:",
          "676:                 filepath = unresolved_path.resolve()",
          "",
          "---------------"
        ],
        "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py": [
          "File: tests/test_web_urldispatcher.py -> tests/test_web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:     assert (await r.text()) == data",
          "133: @pytest.mark.parametrize(",
          "134:     \"dir_name,filename,data\",",
          "135:     [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: async def test_follow_symlink_directory_traversal(",
          "134:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
          "135: ) -> None:",
          "136:     # Tests that follow_symlinks does not allow directory transversal",
          "137:     data = \"private\"",
          "139:     private_file = tmp_path / \"private_file\"",
          "140:     private_file.write_text(data)",
          "142:     safe_path = tmp_path / \"safe_dir\"",
          "143:     safe_path.mkdir()",
          "145:     app = web.Application()",
          "147:     # Register global static route:",
          "148:     app.router.add_static(\"/\", str(safe_path), follow_symlinks=True)",
          "149:     client = await aiohttp_client(app)",
          "151:     await client.start_server()",
          "152:     # We need to use a raw socket to test this, as the client will normalize",
          "153:     # the path before sending it to the server.",
          "154:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "155:     writer.write(b\"GET /../private_file HTTP/1.1\\r\\n\\r\\n\")",
          "156:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "157:     assert b\"404 Not Found\" in response",
          "158:     writer.close()",
          "159:     await writer.wait_closed()",
          "160:     await client.close()",
          "163: async def test_follow_symlink_directory_traversal_after_normalization(",
          "164:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
          "165: ) -> None:",
          "166:     # Tests that follow_symlinks does not allow directory transversal",
          "167:     # after normalization",
          "168:     #",
          "169:     # Directory structure",
          "170:     # |-- secret_dir",
          "171:     # |   |-- private_file (should never be accessible)",
          "172:     # |   |-- symlink_target_dir",
          "173:     # |       |-- symlink_target_file (should be accessible via the my_symlink symlink)",
          "174:     # |       |-- sandbox_dir",
          "175:     # |           |-- my_symlink -> symlink_target_dir",
          "176:     #",
          "177:     secret_path = tmp_path / \"secret_dir\"",
          "178:     secret_path.mkdir()",
          "180:     # This file is below the symlink target and should not be reachable",
          "181:     private_file = secret_path / \"private_file\"",
          "182:     private_file.write_text(\"private\")",
          "184:     symlink_target_path = secret_path / \"symlink_target_dir\"",
          "185:     symlink_target_path.mkdir()",
          "187:     sandbox_path = symlink_target_path / \"sandbox_dir\"",
          "188:     sandbox_path.mkdir()",
          "190:     # This file should be reachable via the symlink",
          "191:     symlink_target_file = symlink_target_path / \"symlink_target_file\"",
          "192:     symlink_target_file.write_text(\"readable\")",
          "194:     my_symlink_path = sandbox_path / \"my_symlink\"",
          "195:     pathlib.Path(str(my_symlink_path)).symlink_to(str(symlink_target_path), True)",
          "197:     app = web.Application()",
          "199:     # Register global static route:",
          "200:     app.router.add_static(\"/\", str(sandbox_path), follow_symlinks=True)",
          "201:     client = await aiohttp_client(app)",
          "203:     await client.start_server()",
          "204:     # We need to use a raw socket to test this, as the client will normalize",
          "205:     # the path before sending it to the server.",
          "206:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "207:     writer.write(b\"GET /my_symlink/../private_file HTTP/1.1\\r\\n\\r\\n\")",
          "208:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "209:     assert b\"404 Not Found\" in response",
          "210:     writer.close()",
          "211:     await writer.wait_closed()",
          "213:     reader, writer = await asyncio.open_connection(client.host, client.port)",
          "214:     writer.write(b\"GET /my_symlink/symlink_target_file HTTP/1.1\\r\\n\\r\\n\")",
          "215:     response = await reader.readuntil(b\"\\r\\n\\r\\n\")",
          "216:     assert b\"200 OK\" in response",
          "217:     response = await reader.readuntil(b\"readable\")",
          "218:     assert response == b\"readable\"",
          "219:     writer.close()",
          "220:     await writer.wait_closed()",
          "221:     await client.close()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e494277110e40fb5c1cc65a1558dfea7d8ae7ca8",
      "candidate_info": {
        "commit_hash": "e494277110e40fb5c1cc65a1558dfea7d8ae7ca8",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/e494277110e40fb5c1cc65a1558dfea7d8ae7ca8",
        "files": [
          "CHANGES/8565.bugfix.rst",
          "aiohttp/web_fileresponse.py",
          "aiohttp/web_urldispatcher.py"
        ],
        "message": "Fix response to circular symlinks with Python v3.13 (#8642)\n\nCo-authored-by: J. Nick Koston <nick@koston.org>",
        "before_after_code_files": [
          "aiohttp/web_fileresponse.py||aiohttp/web_fileresponse.py",
          "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py"
          ],
          "candidate": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/web_fileresponse.py||aiohttp/web_fileresponse.py": [
          "File: aiohttp/web_fileresponse.py -> aiohttp/web_fileresponse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:             file_path, st, file_encoding = await loop.run_in_executor(",
          "189:                 None, self._get_file_path_stat_encoding, accept_encoding",
          "190:             )",
          "192:             self.set_status(HTTPNotFound.status_code)",
          "193:             return await super().prepare(request)",
          "",
          "[Removed Lines]",
          "191:         except FileNotFoundError:",
          "",
          "[Added Lines]",
          "191:         except OSError:",
          "192:             # Most likely to be FileNotFoundError or OSError for circular",
          "193:             # symlinks in python >= 3.13, so respond with 404.",
          "",
          "---------------"
        ],
        "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py": [
          "File: aiohttp/web_urldispatcher.py -> aiohttp/web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:     BaseDict = dict",
          "79: CIRCULAR_SYMLINK_ERROR = (",
          "81:     if sys.version_info < (3, 10) and sys.platform.startswith(\"win32\")",
          "83: )",
          "85: YARL_VERSION: Final[Tuple[int, ...]] = tuple(map(int, yarl_version.split(\".\")[:2]))",
          "",
          "[Removed Lines]",
          "80:     OSError",
          "82:     else RuntimeError",
          "",
          "[Added Lines]",
          "80:     (OSError,)",
          "82:     else (RuntimeError,) if sys.version_info < (3, 13) else ()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:             else:",
          "673:                 file_path = unresolved_path.resolve()",
          "674:                 file_path.relative_to(self._directory)",
          "677:             raise HTTPNotFound() from error",
          "679:         # if path is a directory, return the contents if permitted. Note the",
          "",
          "[Removed Lines]",
          "675:         except (ValueError, CIRCULAR_SYMLINK_ERROR) as error:",
          "676:             # ValueError for relative check; RuntimeError for circular symlink.",
          "",
          "[Added Lines]",
          "675:         except (ValueError, *CIRCULAR_SYMLINK_ERROR) as error:",
          "676:             # ValueError is raised for the relative check. Circular symlinks",
          "677:             # raise here on resolving for python < 3.13.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c9d09f11d71e878984f7a528d414b059d4f4d9bd",
      "candidate_info": {
        "commit_hash": "c9d09f11d71e878984f7a528d414b059d4f4d9bd",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/c9d09f11d71e878984f7a528d414b059d4f4d9bd",
        "files": [
          "CHANGES/8507.bugfix.rst",
          "aiohttp/web_urldispatcher.py",
          "tests/test_web_urldispatcher.py"
        ],
        "message": "Remove blocking IO for static resources and refactor exception handling (#8507)\n\nCo-authored-by: Sviatoslav Sydorenko (\u0421\u0432\u044f\u0442\u043e\u0441\u043b\u0430\u0432 \u0421\u0438\u0434\u043e\u0440\u0435\u043d\u043a\u043e) <wk.cvs.github@sydorenko.org.ua>\nCo-authored-by: J. Nick Koston <nick@koston.org>",
        "before_after_code_files": [
          "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
          "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ],
          "candidate": [
            "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py",
            "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/web_urldispatcher.py||aiohttp/web_urldispatcher.py": [
          "File: aiohttp/web_urldispatcher.py -> aiohttp/web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: import keyword",
          "8: import os",
          "9: import re",
          "10: from contextlib import contextmanager",
          "11: from pathlib import Path",
          "12: from types import MappingProxyType",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: import sys",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: else:",
          "76:     BaseDict = dict",
          "78: YARL_VERSION: Final[Tuple[int, ...]] = tuple(map(int, yarl_version.split(\".\")[:2]))",
          "80: HTTP_METHOD_RE: Final[Pattern[str]] = re.compile(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79: CIRCULAR_SYMLINK_ERROR = (",
          "80:     OSError",
          "81:     if sys.version_info < (3, 10) and sys.platform.startswith(\"win32\")",
          "82:     else RuntimeError",
          "83: )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "640:     async def _handle(self, request: Request) -> StreamResponse:",
          "641:         rel_url = request.match_info[\"filename\"]",
          "642:         try:",
          "650:             if self._follow_symlinks:",
          "651:                 normalized_path = Path(os.path.normpath(unresolved_path))",
          "652:                 normalized_path.relative_to(self._directory)",
          "654:             else:",
          "665:             raise HTTPNotFound() from error",
          "671:                     return Response(",
          "673:                     )",
          "675:                     raise HTTPForbidden()",
          "690:         index_of = f\"Index of /{html_escape(relative_path_to_dir)}\"",
          "691:         h1 = f\"<h1>{index_of}</h1>\"",
          "693:         index_list = []",
          "695:         for _file in sorted(dir_index):",
          "696:             # show file url as relative to static path",
          "697:             rel_path = _file.relative_to(self._directory).as_posix()",
          "",
          "[Removed Lines]",
          "643:             filename = Path(rel_url)",
          "644:             if filename.anchor:",
          "645:                 # rel_url is an absolute name like",
          "646:                 # /static/\\\\machine_name\\c$ or /static/D:\\path",
          "647:                 # where the static dir is totally different",
          "648:                 raise HTTPForbidden()",
          "649:             unresolved_path = self._directory.joinpath(filename)",
          "653:                 filepath = normalized_path.resolve()",
          "655:                 filepath = unresolved_path.resolve()",
          "656:                 filepath.relative_to(self._directory)",
          "657:         except (ValueError, FileNotFoundError) as error:",
          "658:             # relatively safe",
          "659:             raise HTTPNotFound() from error",
          "660:         except HTTPForbidden:",
          "661:             raise",
          "662:         except Exception as error:",
          "663:             # perm error or other kind!",
          "664:             request.app.logger.exception(error)",
          "667:         # on opening a dir, load its contents if allowed",
          "668:         if filepath.is_dir():",
          "669:             if self._show_index:",
          "670:                 try:",
          "672:                         text=self._directory_as_html(filepath), content_type=\"text/html\"",
          "674:                 except PermissionError:",
          "676:             else:",
          "677:                 raise HTTPForbidden()",
          "678:         elif filepath.is_file():",
          "679:             return FileResponse(filepath, chunk_size=self._chunk_size)",
          "680:         else:",
          "681:             raise HTTPNotFound",
          "683:     def _directory_as_html(self, filepath: Path) -> str:",
          "684:         # returns directory's index as html",
          "686:         # sanity check",
          "687:         assert filepath.is_dir()",
          "689:         relative_path_to_dir = filepath.relative_to(self._directory).as_posix()",
          "694:         dir_index = filepath.iterdir()",
          "",
          "[Added Lines]",
          "649:         filename = Path(rel_url)",
          "650:         if filename.anchor:",
          "651:             # rel_url is an absolute name like",
          "652:             # /static/\\\\machine_name\\c$ or /static/D:\\path",
          "653:             # where the static dir is totally different",
          "654:             raise HTTPForbidden()",
          "656:         unresolved_path = self._directory.joinpath(filename)",
          "657:         loop = asyncio.get_running_loop()",
          "658:         return await loop.run_in_executor(",
          "659:             None, self._resolve_path_to_response, unresolved_path",
          "660:         )",
          "662:     def _resolve_path_to_response(self, unresolved_path: Path) -> StreamResponse:",
          "663:         \"\"\"Take the unresolved path and query the file system to form a response.\"\"\"",
          "664:         # Check for access outside the root directory. For follow symlinks, URI",
          "665:         # cannot traverse out, but symlinks can. Otherwise, no access outside",
          "666:         # root is permitted.",
          "671:                 file_path = normalized_path.resolve()",
          "673:                 file_path = unresolved_path.resolve()",
          "674:                 file_path.relative_to(self._directory)",
          "675:         except (ValueError, CIRCULAR_SYMLINK_ERROR) as error:",
          "676:             # ValueError for relative check; RuntimeError for circular symlink.",
          "679:         # if path is a directory, return the contents if permitted. Note the",
          "680:         # directory check will raise if a segment is not readable.",
          "681:         try:",
          "682:             if file_path.is_dir():",
          "683:                 if self._show_index:",
          "685:                         text=self._directory_as_html(file_path),",
          "686:                         content_type=\"text/html\",",
          "688:                 else:",
          "690:         except PermissionError as error:",
          "691:             raise HTTPForbidden() from error",
          "693:         # Not a regular file or does not exist.",
          "694:         if not file_path.is_file():",
          "695:             raise HTTPNotFound()",
          "697:         return FileResponse(file_path, chunk_size=self._chunk_size)",
          "699:     def _directory_as_html(self, dir_path: Path) -> str:",
          "700:         \"\"\"returns directory's index as html.\"\"\"",
          "701:         assert dir_path.is_dir()",
          "703:         relative_path_to_dir = dir_path.relative_to(self._directory).as_posix()",
          "708:         dir_index = dir_path.iterdir()",
          "",
          "---------------"
        ],
        "tests/test_web_urldispatcher.py||tests/test_web_urldispatcher.py": [
          "File: tests/test_web_urldispatcher.py -> tests/test_web_urldispatcher.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import functools",
          "3: import pathlib",
          "4: import sys",
          "6: from unittest import mock",
          "7: from unittest.mock import MagicMock",
          "",
          "[Removed Lines]",
          "5: from typing import Optional",
          "",
          "[Added Lines]",
          "5: from typing import Generator, Optional",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "388:             assert route.handler.__doc__ == \"Doc\"",
          "393: ) -> None:",
          "397:     my_dir = tmp_path / \"my_dir\"",
          "398:     my_dir.mkdir()",
          "400:     app = web.Application()",
          "418: async def test_access_symlink_loop(",
          "",
          "[Removed Lines]",
          "391: async def test_unauthorized_folder_access(",
          "392:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient",
          "394:     # Tests the unauthorized access to a folder of static file server.",
          "395:     # Try to list a folder content of static file server when server does not",
          "396:     # have permissions to do so for the folder.",
          "402:     with mock.patch(\"pathlib.Path.__new__\") as path_constructor:",
          "403:         path = MagicMock()",
          "404:         path.joinpath.return_value = path",
          "405:         path.resolve.return_value = path",
          "406:         path.iterdir.return_value.__iter__.side_effect = PermissionError()",
          "407:         path_constructor.return_value = path",
          "409:         # Register global static route:",
          "410:         app.router.add_static(\"/\", str(tmp_path), show_index=True)",
          "411:         client = await aiohttp_client(app)",
          "413:         # Request the root of the static directory.",
          "414:         r = await client.get(\"/\" + my_dir.name)",
          "415:         assert r.status == 403",
          "",
          "[Added Lines]",
          "391: @pytest.mark.skipif(",
          "392:     sys.platform.startswith(\"win32\"), reason=\"Cannot remove read access on Windows\"",
          "393: )",
          "394: @pytest.mark.parametrize(\"file_request\", [\"\", \"my_file.txt\"])",
          "395: async def test_static_directory_without_read_permission(",
          "396:     tmp_path: pathlib.Path, aiohttp_client: AiohttpClient, file_request: str",
          "398:     \"\"\"Test static directory without read permission receives forbidden response.\"\"\"",
          "401:     my_dir.chmod(0o000)",
          "404:     app.router.add_static(\"/\", str(tmp_path), show_index=True)",
          "405:     client = await aiohttp_client(app)",
          "407:     r = await client.get(f\"/{my_dir.name}/{file_request}\")",
          "408:     assert r.status == 403",
          "411: @pytest.mark.parametrize(\"file_request\", [\"\", \"my_file.txt\"])",
          "412: async def test_static_directory_with_mock_permission_error(",
          "413:     monkeypatch: pytest.MonkeyPatch,",
          "414:     tmp_path: pathlib.Path,",
          "415:     aiohttp_client: AiohttpClient,",
          "416:     file_request: str,",
          "417: ) -> None:",
          "418:     \"\"\"Test static directory with mock permission errors receives forbidden response.\"\"\"",
          "419:     my_dir = tmp_path / \"my_dir\"",
          "420:     my_dir.mkdir()",
          "422:     real_iterdir = pathlib.Path.iterdir",
          "423:     real_is_dir = pathlib.Path.is_dir",
          "425:     def mock_iterdir(self: pathlib.Path) -> Generator[pathlib.Path, None, None]:",
          "426:         if my_dir.samefile(self):",
          "427:             raise PermissionError()",
          "428:         return real_iterdir(self)",
          "430:     def mock_is_dir(self: pathlib.Path) -> bool:",
          "431:         if my_dir.samefile(self.parent):",
          "432:             raise PermissionError()",
          "433:         return real_is_dir(self)",
          "435:     monkeypatch.setattr(\"pathlib.Path.iterdir\", mock_iterdir)",
          "436:     monkeypatch.setattr(\"pathlib.Path.is_dir\", mock_is_dir)",
          "438:     app = web.Application()",
          "439:     app.router.add_static(\"/\", str(tmp_path), show_index=True)",
          "440:     client = await aiohttp_client(app)",
          "442:     r = await client.get(\"/\")",
          "443:     assert r.status == 200",
          "444:     r = await client.get(f\"/{my_dir.name}/{file_request}\")",
          "445:     assert r.status == 403",
          "",
          "---------------"
        ]
      }
    }
  ]
}
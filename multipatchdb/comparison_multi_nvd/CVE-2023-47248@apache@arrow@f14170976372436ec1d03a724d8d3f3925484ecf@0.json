{
  "cve_id": "CVE-2023-47248",
  "cve_desc": "Deserialization of untrusted data in IPC and Parquet readers in PyArrow versions 0.14.0 to 14.0.0 allows arbitrary code execution. An application is vulnerable if it reads Arrow IPC, Feather or Parquet data from untrusted sources (for example user-supplied input files).\n\nThis vulnerability only affects PyArrow, not other Apache Arrow implementations or bindings.\n\nIt is recommended that users of PyArrow upgrade to 14.0.1. Similarly, it is recommended that downstream libraries upgrade their dependency requirements to PyArrow 14.0.1 or later. PyPI packages are already available, and we hope that conda-forge packages will be available soon.\n\nIf it is not possible to upgrade, we provide a separate package `pyarrow-hotfix` that disables the vulnerability on older PyArrow versions. See  https://pypi.org/project/pyarrow-hotfix/  for instructions.",
  "repo": "apache/arrow",
  "patch_hash": "f14170976372436ec1d03a724d8d3f3925484ecf",
  "patch_info": {
    "commit_hash": "f14170976372436ec1d03a724d8d3f3925484ecf",
    "repo": "apache/arrow",
    "commit_url": "https://github.com/apache/arrow/commit/f14170976372436ec1d03a724d8d3f3925484ecf",
    "files": [
      "docs/source/python/extending_types.rst",
      "python/pyarrow/tests/test_cffi.py",
      "python/pyarrow/tests/test_extension_type.py",
      "python/pyarrow/tests/test_pandas.py",
      "python/pyarrow/types.pxi"
    ],
    "message": "GH-38607: [Python] Disable PyExtensionType autoload (#38608)\n\n### Rationale for this change\n\nPyExtensionType autoload is really a misfeature. It creates PyArrow-specific extension types, though using ExtensionType is almost the same complexity while allowing deserialization from non-PyArrow software.\n\n### What changes are included in this PR?\n\n* Disable PyExtensionType autoloading and deprecate PyExtensionType instantiation.\n* Update the docs to emphasize ExtensionType.\n\n### Are these changes tested?\n\nYes.\n\n### Are there any user-facing changes?\n\nYes.\n\n* Closes: #38607\n\nAuthored-by: Antoine Pitrou <antoine@python.org>\nSigned-off-by: Ra\u00fal Cumplido <raulcumplido@gmail.com>",
    "before_after_code_files": [
      "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py",
      "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py",
      "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py",
      "python/pyarrow/types.pxi||python/pyarrow/types.pxi"
    ]
  },
  "patch_diff": {
    "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py": [
      "File: python/pyarrow/tests/test_cffi.py -> python/pyarrow/tests/test_cffi.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: # specific language governing permissions and limitations",
      "17: # under the License.",
      "19: import ctypes",
      "20: import gc",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: import contextlib",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "51:     return ctypes.pythonapi.PyCapsule_IsValid(ctypes.py_object(capsule), name) == 1",
      "56:     def __init__(self, width):",
      "57:         self._width = width",
      "60:     @property",
      "61:     def width(self):",
      "62:         return self._width",
      "68: def make_schema():",
      "",
      "[Removed Lines]",
      "54: class ParamExtType(pa.PyExtensionType):",
      "58:         pa.PyExtensionType.__init__(self, pa.binary(width))",
      "64:     def __reduce__(self):",
      "65:         return ParamExtType, (self.width,)",
      "",
      "[Added Lines]",
      "55: @contextlib.contextmanager",
      "56: def registered_extension_type(ext_type):",
      "57:     pa.register_extension_type(ext_type)",
      "58:     try:",
      "59:         yield",
      "60:     finally:",
      "61:         pa.unregister_extension_type(ext_type.extension_name)",
      "64: class ParamExtType(pa.ExtensionType):",
      "68:         super().__init__(pa.binary(width),",
      "69:                          \"pyarrow.tests.test_cffi.ParamExtType\")",
      "75:     def __arrow_ext_serialize__(self):",
      "76:         return str(self.width).encode()",
      "78:     @classmethod",
      "79:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "80:         width = int(serialized.decode())",
      "81:         return cls(width)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "75:                      metadata={b'key1': b'value1'})",
      "78: def make_batch():",
      "79:     return pa.record_batch([[[1], [2, 42]]], make_schema())",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "94: def make_extension_storage_schema():",
      "95:     # Should be kept in sync with make_extension_schema",
      "96:     return pa.schema([('ext', ParamExtType(3).storage_type)],",
      "97:                      metadata={b'key1': b'value1'})",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "204:         pa.Array._import_from_c(ptr_array, ptr_schema)",
      "208:     c_schema = ffi.new(\"struct ArrowSchema*\")",
      "209:     ptr_schema = int(ffi.cast(\"uintptr_t\", c_schema))",
      "",
      "[Removed Lines]",
      "207: def check_export_import_schema(schema_factory):",
      "",
      "[Added Lines]",
      "229: def check_export_import_schema(schema_factory, expected_schema_factory=None):",
      "230:     if expected_schema_factory is None:",
      "231:         expected_schema_factory = schema_factory",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "215:     assert pa.total_allocated_bytes() > old_allocated",
      "216:     # Delete and recreate C++ object from exported pointer",
      "217:     schema_new = pa.Schema._import_from_c(ptr_schema)",
      "219:     assert pa.total_allocated_bytes() == old_allocated",
      "220:     del schema_new",
      "221:     assert pa.total_allocated_bytes() == old_allocated",
      "",
      "[Removed Lines]",
      "218:     assert schema_new == schema_factory()",
      "",
      "[Added Lines]",
      "243:     assert schema_new == expected_schema_factory()",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "241: @needs_cffi",
      "242: def test_export_import_schema_with_extension():",
      "246: @needs_cffi",
      "",
      "[Removed Lines]",
      "243:     check_export_import_schema(make_extension_schema)",
      "",
      "[Added Lines]",
      "268:     # Extension type is unregistered => the storage type is imported",
      "269:     check_export_import_schema(make_extension_schema,",
      "270:                                make_extension_storage_schema)",
      "272:     # Extension type is registered => the extension type is imported",
      "273:     with registered_extension_type(ParamExtType(1)):",
      "274:         check_export_import_schema(make_extension_schema)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "320: @needs_cffi",
      "321: def test_export_import_batch_with_extension():",
      "325: def _export_import_batch_reader(ptr_stream, reader_factory):",
      "",
      "[Removed Lines]",
      "322:     check_export_import_batch(make_extension_batch)",
      "",
      "[Added Lines]",
      "353:     with registered_extension_type(ParamExtType(1)):",
      "354:         check_export_import_batch(make_extension_batch)",
      "",
      "---------------"
    ],
    "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py": [
      "File: python/pyarrow/tests/test_extension_type.py -> python/pyarrow/tests/test_extension_type.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "15: # specific language governing permissions and limitations",
      "16: # under the License.",
      "18: import os",
      "19: import shutil",
      "20: import subprocess",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: import contextlib",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "29: import pytest",
      "34:     def __init__(self):",
      "43:     def __init__(self):",
      "52:     def __init__(self):",
      "59: class UuidScalarType(pa.ExtensionScalar):",
      "",
      "[Removed Lines]",
      "32: class TinyIntType(pa.PyExtensionType):",
      "35:         pa.PyExtensionType.__init__(self, pa.int8())",
      "37:     def __reduce__(self):",
      "38:         return TinyIntType, ()",
      "41: class IntegerType(pa.PyExtensionType):",
      "44:         pa.PyExtensionType.__init__(self, pa.int64())",
      "46:     def __reduce__(self):",
      "47:         return IntegerType, ()",
      "50: class IntegerEmbeddedType(pa.PyExtensionType):",
      "53:         pa.PyExtensionType.__init__(self, IntegerType())",
      "55:     def __reduce__(self):",
      "56:         return IntegerEmbeddedType, ()",
      "",
      "[Added Lines]",
      "33: @contextlib.contextmanager",
      "34: def registered_extension_type(ext_type):",
      "35:     pa.register_extension_type(ext_type)",
      "36:     try:",
      "37:         yield",
      "38:     finally:",
      "39:         pa.unregister_extension_type(ext_type.extension_name)",
      "42: @contextlib.contextmanager",
      "43: def enabled_auto_load():",
      "44:     pa.PyExtensionType.set_auto_load(True)",
      "45:     try:",
      "46:         yield",
      "47:     finally:",
      "48:         pa.PyExtensionType.set_auto_load(False)",
      "51: class TinyIntType(pa.ExtensionType):",
      "54:         super().__init__(pa.int8(), 'pyarrow.tests.TinyIntType')",
      "56:     def __arrow_ext_serialize__(self):",
      "57:         return b''",
      "59:     @classmethod",
      "60:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "61:         assert serialized == b''",
      "62:         assert storage_type == pa.int8()",
      "63:         return cls()",
      "66: class IntegerType(pa.ExtensionType):",
      "69:         super().__init__(pa.int64(), 'pyarrow.tests.IntegerType')",
      "71:     def __arrow_ext_serialize__(self):",
      "72:         return b''",
      "74:     @classmethod",
      "75:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "76:         assert serialized == b''",
      "77:         assert storage_type == pa.int64()",
      "78:         return cls()",
      "81: class IntegerEmbeddedType(pa.ExtensionType):",
      "84:         super().__init__(IntegerType(), 'pyarrow.tests.IntegerType')",
      "86:     def __arrow_ext_serialize__(self):",
      "87:         # XXX pa.BaseExtensionType should expose C++ serialization method",
      "88:         return self.storage_type.__arrow_ext_serialize__()",
      "90:     @classmethod",
      "91:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "92:         deserialized_storage_type = storage_type.__arrow_ext_deserialize__(",
      "93:             serialized)",
      "94:         assert deserialized_storage_type == storage_type",
      "95:         return cls()",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "61:         return None if self.value is None else UUID(bytes=self.value.as_py())",
      "66:     def __init__(self):",
      "72:     def __arrow_ext_scalar_class__(self):",
      "73:         return UuidScalarType",
      "78:     def __init__(self):",
      "87:     def __init__(self):",
      "96:     def __init__(self, width):",
      "97:         self._width = width",
      "100:     @property",
      "101:     def width(self):",
      "102:         return self._width",
      "109:     storage_type = pa.struct([('left', pa.int64()),",
      "110:                               ('right', pa.int64())])",
      "112:     def __init__(self):",
      "121:     def __init__(self, storage_type):",
      "129:     \"\"\"",
      "130:     Generic extension type that can store any storage type.",
      "131:     \"\"\"",
      "133:     def __init__(self, storage_type, annotation):",
      "134:         self.annotation = annotation",
      "137:     def __reduce__(self):",
      "141: def ipc_write_batch(batch):",
      "",
      "[Removed Lines]",
      "64: class UuidType(pa.PyExtensionType):",
      "67:         pa.PyExtensionType.__init__(self, pa.binary(16))",
      "69:     def __reduce__(self):",
      "70:         return UuidType, ()",
      "76: class UuidType2(pa.PyExtensionType):",
      "79:         pa.PyExtensionType.__init__(self, pa.binary(16))",
      "81:     def __reduce__(self):",
      "82:         return UuidType2, ()",
      "85: class LabelType(pa.PyExtensionType):",
      "88:         pa.PyExtensionType.__init__(self, pa.string())",
      "90:     def __reduce__(self):",
      "91:         return LabelType, ()",
      "94: class ParamExtType(pa.PyExtensionType):",
      "98:         pa.PyExtensionType.__init__(self, pa.binary(width))",
      "104:     def __reduce__(self):",
      "105:         return ParamExtType, (self.width,)",
      "108: class MyStructType(pa.PyExtensionType):",
      "113:         pa.PyExtensionType.__init__(self, self.storage_type)",
      "115:     def __reduce__(self):",
      "116:         return MyStructType, ()",
      "119: class MyListType(pa.PyExtensionType):",
      "122:         pa.PyExtensionType.__init__(self, storage_type)",
      "124:     def __reduce__(self):",
      "125:         return MyListType, (self.storage_type,)",
      "128: class AnnotatedType(pa.PyExtensionType):",
      "135:         super().__init__(storage_type)",
      "138:         return AnnotatedType, (self.storage_type, self.annotation)",
      "",
      "[Added Lines]",
      "103: class UuidType(pa.ExtensionType):",
      "106:         super().__init__(pa.binary(16), 'pyarrow.tests.UuidType')",
      "111:     def __arrow_ext_serialize__(self):",
      "112:         return b''",
      "114:     @classmethod",
      "115:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "116:         return cls()",
      "119: class UuidType2(pa.ExtensionType):",
      "122:         super().__init__(pa.binary(16), 'pyarrow.tests.UuidType2')",
      "124:     def __arrow_ext_serialize__(self):",
      "125:         return b''",
      "127:     @classmethod",
      "128:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "129:         return cls()",
      "132: class LabelType(pa.ExtensionType):",
      "135:         super().__init__(pa.string(), 'pyarrow.tests.LabelType')",
      "137:     def __arrow_ext_serialize__(self):",
      "138:         return b''",
      "140:     @classmethod",
      "141:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "142:         return cls()",
      "145: class ParamExtType(pa.ExtensionType):",
      "149:         super().__init__(pa.binary(width), 'pyarrow.tests.ParamExtType')",
      "155:     def __arrow_ext_serialize__(self):",
      "156:         return str(self._width).encode()",
      "158:     @classmethod",
      "159:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "160:         width = int(serialized.decode())",
      "161:         assert storage_type == pa.binary(width)",
      "162:         return cls(width)",
      "165: class MyStructType(pa.ExtensionType):",
      "170:         super().__init__(self.storage_type, 'pyarrow.tests.MyStructType')",
      "172:     def __arrow_ext_serialize__(self):",
      "173:         return b''",
      "175:     @classmethod",
      "176:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "177:         assert serialized == b''",
      "178:         assert storage_type == cls.storage_type",
      "179:         return cls()",
      "182: class MyListType(pa.ExtensionType):",
      "185:         assert isinstance(storage_type, pa.ListType)",
      "186:         super().__init__(storage_type, 'pyarrow.tests.MyListType')",
      "188:     def __arrow_ext_serialize__(self):",
      "189:         return b''",
      "191:     @classmethod",
      "192:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "193:         assert serialized == b''",
      "194:         return cls(storage_type)",
      "197: class AnnotatedType(pa.ExtensionType):",
      "204:         super().__init__(storage_type, 'pyarrow.tests.AnnotatedType')",
      "206:     def __arrow_ext_serialize__(self):",
      "207:         return b''",
      "209:     @classmethod",
      "210:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "211:         assert serialized == b''",
      "212:         return cls(storage_type)",
      "215: class LegacyIntType(pa.PyExtensionType):",
      "217:     def __init__(self):",
      "218:         pa.PyExtensionType.__init__(self, pa.int8())",
      "221:         return LegacyIntType, ()",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "154: def test_ext_type_basics():",
      "155:     ty = UuidType()",
      "159: def test_ext_type_str():",
      "160:     ty = IntegerType()",
      "162:     assert str(ty) == expected",
      "163:     assert pa.DataType.__str__(ty) == expected",
      "",
      "[Removed Lines]",
      "156:     assert ty.extension_name == \"arrow.py_extension_type\"",
      "161:     expected = \"extension<arrow.py_extension_type<IntegerType>>\"",
      "",
      "[Added Lines]",
      "239:     assert ty.extension_name == \"pyarrow.tests.UuidType\"",
      "244:     expected = \"extension<pyarrow.tests.IntegerType<IntegerType>>\"",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "223:         del ty",
      "224:         ty = pickle_module.loads(ser)",
      "225:         wr = weakref.ref(ty)",
      "227:         del ty",
      "228:         assert wr() is None",
      "",
      "[Removed Lines]",
      "226:         assert ty.extension_name == \"arrow.py_extension_type\"",
      "",
      "[Added Lines]",
      "309:         assert ty.extension_name == \"pyarrow.tests.UuidType\"",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "571:     assert tiny_int_arr.type == TinyIntType()",
      "573:     # Casting between extension types w/ different storage types not okay.",
      "575:            \"to different extension type \"",
      "577:            \"One can first cast to the storage type, \"",
      "578:            \"then to the extension type.\"",
      "579:            )",
      "",
      "[Removed Lines]",
      "574:     msg = (\"Casting from 'extension<arrow.py_extension_type<TinyIntType>>' \"",
      "576:            \"'extension<arrow.py_extension_type<IntegerType>>' not permitted. \"",
      "",
      "[Added Lines]",
      "657:     msg = (\"Casting from 'extension<.*?<TinyIntType>>' \"",
      "659:            \"'extension<.*?<IntegerType>>' not permitted. \"",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "660:     return pa.RecordBatch.from_arrays([arr], [\"exts\"])",
      "664:     arr = batch.column(0)",
      "668:     return arr",
      "672:     batch = example_batch()",
      "673:     buf = ipc_write_batch(batch)",
      "674:     del batch",
      "676:     batch = ipc_read_batch(buf)",
      "692:         batch = ipc_read_batch(buf)",
      "712: class PeriodArray(pa.ExtensionArray):",
      "",
      "[Removed Lines]",
      "663: def check_example_batch(batch):",
      "665:     assert isinstance(arr, pa.ExtensionArray)",
      "666:     assert arr.type.storage_type == pa.binary(3)",
      "667:     assert arr.storage.to_pylist() == [b\"foo\", b\"bar\"]",
      "671: def test_ipc():",
      "677:     arr = check_example_batch(batch)",
      "678:     assert arr.type == ParamExtType(3)",
      "681: def test_ipc_unknown_type():",
      "682:     batch = example_batch()",
      "683:     buf = ipc_write_batch(batch)",
      "684:     del batch",
      "686:     orig_type = ParamExtType",
      "687:     try:",
      "688:         # Simulate the original Python type being unavailable.",
      "689:         # Deserialization should not fail but return a placeholder type.",
      "690:         del globals()['ParamExtType']",
      "693:         arr = check_example_batch(batch)",
      "694:         assert isinstance(arr.type, pa.UnknownExtensionType)",
      "696:         # Can be serialized again",
      "697:         buf2 = ipc_write_batch(batch)",
      "698:         del batch, arr",
      "700:         batch = ipc_read_batch(buf2)",
      "701:         arr = check_example_batch(batch)",
      "702:         assert isinstance(arr.type, pa.UnknownExtensionType)",
      "703:     finally:",
      "704:         globals()['ParamExtType'] = orig_type",
      "706:     # Deserialize again with the type restored",
      "707:     batch = ipc_read_batch(buf2)",
      "708:     arr = check_example_batch(batch)",
      "709:     assert arr.type == ParamExtType(3)",
      "",
      "[Added Lines]",
      "746: def check_example_batch(batch, *, expect_extension):",
      "748:     if expect_extension:",
      "749:         assert isinstance(arr, pa.ExtensionArray)",
      "750:         assert arr.type.storage_type == pa.binary(3)",
      "751:         assert arr.storage.to_pylist() == [b\"foo\", b\"bar\"]",
      "752:     else:",
      "753:         assert arr.type == pa.binary(3)",
      "754:         assert arr.to_pylist() == [b\"foo\", b\"bar\"]",
      "758: def test_ipc_unregistered():",
      "764:     batch.validate(full=True)",
      "765:     check_example_batch(batch, expect_extension=False)",
      "768: def test_ipc_registered():",
      "769:     with registered_extension_type(ParamExtType(1)):",
      "770:         batch = example_batch()",
      "771:         buf = ipc_write_batch(batch)",
      "772:         del batch",
      "775:         batch.validate(full=True)",
      "776:         arr = check_example_batch(batch, expect_extension=True)",
      "777:         assert arr.type == ParamExtType(3)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "931:     # When reading in, properly create extension type if it is registered",
      "932:     result = pq.read_table(filename)",
      "933:     assert result.schema.field(\"ext\").type == period_type",
      "934:     assert result.schema.field(\"ext\").metadata == {}",
      "935:     # Get the exact array class defined by the registered type.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1001:     result.validate(full=True)",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "939:     # When the type is not registered, read in as storage type",
      "940:     pa.unregister_extension_type(period_type.extension_name)",
      "941:     result = pq.read_table(filename)",
      "942:     assert result.schema.field(\"ext\").type == pa.int64()",
      "943:     # The extension metadata is present for roundtripping.",
      "944:     assert result.schema.field(\"ext\").metadata == {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1011:     result.validate(full=True)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "967:     filename = tmpdir / 'nested_extension_storage.parquet'",
      "968:     pq.write_table(orig_table, filename)",
      "970:     table = pq.read_table(filename)",
      "979: @pytest.mark.parquet",
      "",
      "[Removed Lines]",
      "971:     assert table.column('structs').type == mystruct_array.type",
      "972:     assert table.column('lists').type == mylist_array.type",
      "973:     assert table == orig_table",
      "975:     with pytest.raises(pa.ArrowInvalid, match='without all of its fields'):",
      "976:         pq.ParquetFile(filename).read(columns=['structs.left'])",
      "",
      "[Added Lines]",
      "1040:     # Unregistered",
      "1042:     table.validate(full=True)",
      "1043:     assert table.column('structs').type == struct_array.type",
      "1044:     assert table.column('structs').combine_chunks() == struct_array",
      "1045:     assert table.column('lists').type == list_array.type",
      "1046:     assert table.column('lists').combine_chunks() == list_array",
      "1048:     # Registered",
      "1049:     with registered_extension_type(mystruct_array.type):",
      "1050:         with registered_extension_type(mylist_array.type):",
      "1051:             table = pq.read_table(filename)",
      "1052:             table.validate(full=True)",
      "1053:             assert table.column('structs').type == mystruct_array.type",
      "1054:             assert table.column('lists').type == mylist_array.type",
      "1055:             assert table == orig_table",
      "1057:             # Cannot select a subfield of an extension type with",
      "1058:             # a struct storage type.",
      "1059:             with pytest.raises(pa.ArrowInvalid,",
      "1060:                                match='without all of its fields'):",
      "1061:                 pq.ParquetFile(filename).read(columns=['structs.left'])",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "995:     pq.write_table(orig_table, filename)",
      "997:     table = pq.read_table(filename)",
      "1001:     # List of extensions",
      "1002:     list_array = pa.ListArray.from_arrays([0, 1, None, 3], ext_array)",
      "",
      "[Removed Lines]",
      "998:     assert table.column(0).type == struct_array.type",
      "999:     assert table == orig_table",
      "",
      "[Added Lines]",
      "1083:     table.validate(full=True)",
      "1084:     assert table.column(0).type == pa.struct({'ints': pa.int64(),",
      "1085:                                               'exts': pa.int64()})",
      "1086:     with registered_extension_type(ext_type):",
      "1087:         table = pq.read_table(filename)",
      "1088:         table.validate(full=True)",
      "1089:         assert table.column(0).type == struct_array.type",
      "1090:         assert table == orig_table",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1006:     pq.write_table(orig_table, filename)",
      "1008:     table = pq.read_table(filename)",
      "1012:     # Large list of extensions",
      "1013:     list_array = pa.LargeListArray.from_arrays([0, 1, None, 3], ext_array)",
      "",
      "[Removed Lines]",
      "1009:     assert table.column(0).type == list_array.type",
      "1010:     assert table == orig_table",
      "",
      "[Added Lines]",
      "1100:     table.validate(full=True)",
      "1101:     assert table.column(0).type == pa.list_(pa.int64())",
      "1102:     with registered_extension_type(ext_type):",
      "1103:         table = pq.read_table(filename)",
      "1104:         table.validate(full=True)",
      "1105:         assert table.column(0).type == list_array.type",
      "1106:         assert table == orig_table",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1017:     pq.write_table(orig_table, filename)",
      "1019:     table = pq.read_table(filename)",
      "1024: @pytest.mark.parquet",
      "",
      "[Removed Lines]",
      "1020:     assert table.column(0).type == list_array.type",
      "1021:     assert table == orig_table",
      "",
      "[Added Lines]",
      "1116:     table.validate(full=True)",
      "1117:     assert table.column(0).type == pa.large_list(pa.int64())",
      "1118:     with registered_extension_type(ext_type):",
      "1119:         table = pq.read_table(filename)",
      "1120:         table.validate(full=True)",
      "1121:         assert table.column(0).type == list_array.type",
      "1122:         assert table == orig_table",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1040:     pq.write_table(orig_table, filename)",
      "1042:     table = pq.read_table(filename)",
      "1047: def test_to_numpy():",
      "",
      "[Removed Lines]",
      "1043:     assert table.column(0).type == mylist_array.type",
      "1044:     assert table == orig_table",
      "",
      "[Added Lines]",
      "1144:     assert table.column(0).type == pa.list_(pa.int64())",
      "1145:     with registered_extension_type(mylist_array.type):",
      "1146:         with registered_extension_type(inner_ext_array.type):",
      "1147:             table = pq.read_table(filename)",
      "1148:             assert table.column(0).type == mylist_array.type",
      "1149:             assert table == orig_table",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1370: def test_tensor_type_str(tensor_type, text):",
      "1371:     tensor_type_str = tensor_type.__str__()",
      "1372:     assert text in tensor_type_str",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1480: def test_legacy_int_type():",
      "1481:     with pytest.warns(FutureWarning, match=\"PyExtensionType is deprecated\"):",
      "1482:         ext_ty = LegacyIntType()",
      "1483:     arr = pa.array([1, 2, 3], type=ext_ty.storage_type)",
      "1484:     ext_arr = pa.ExtensionArray.from_storage(ext_ty, arr)",
      "1485:     batch = pa.RecordBatch.from_arrays([ext_arr], names=['ext'])",
      "1486:     buf = ipc_write_batch(batch)",
      "1488:     with pytest.warns(",
      "1489:             RuntimeWarning,",
      "1490:             match=\"pickle-based deserialization of pyarrow.PyExtensionType \"",
      "1491:                   \"subclasses is disabled by default\"):",
      "1492:         batch = ipc_read_batch(buf)",
      "1493:         assert isinstance(batch.column(0).type, pa.UnknownExtensionType)",
      "1495:     with enabled_auto_load():",
      "1496:         with pytest.warns(FutureWarning, match=\"PyExtensionType is deprecated\"):",
      "1497:             batch = ipc_read_batch(buf)",
      "1498:             assert isinstance(batch.column(0).type, LegacyIntType)",
      "1499:             assert batch.column(0) == ext_arr",
      "",
      "---------------"
    ],
    "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py": [
      "File: python/pyarrow/tests/test_pandas.py -> python/pyarrow/tests/test_pandas.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "4096:     assert result.equals(expected2)",
      "4101:     def __init__(self):",
      "4108: def PandasArray__arrow_array__(self, type=None):",
      "",
      "[Removed Lines]",
      "4099: class DummyExtensionType(pa.PyExtensionType):",
      "4102:         pa.PyExtensionType.__init__(self, pa.int64())",
      "4104:     def __reduce__(self):",
      "4105:         return DummyExtensionType, ()",
      "",
      "[Added Lines]",
      "4099: class DummyExtensionType(pa.ExtensionType):",
      "4102:         super().__init__(pa.int64(),",
      "4103:                          'pyarrow.tests.test_pandas.DummyExtensionType')",
      "4105:     def __arrow_ext_serialize__(self):",
      "4106:         return b''",
      "4108:     @classmethod",
      "4109:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "4110:         assert serialized == b''",
      "4111:         assert storage_type == pa.int64()",
      "4112:         return cls()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4198:     assert not isinstance(_get_mgr(result).blocks[0], _int.ExtensionBlock)",
      "4203:     def __init__(self):",
      "4209:     def to_pandas_dtype(self):",
      "4210:         return pd.Int64Dtype()",
      "",
      "[Removed Lines]",
      "4201: class MyCustomIntegerType(pa.PyExtensionType):",
      "4204:         pa.PyExtensionType.__init__(self, pa.int64())",
      "4206:     def __reduce__(self):",
      "4207:         return MyCustomIntegerType, ()",
      "",
      "[Added Lines]",
      "4208: class MyCustomIntegerType(pa.ExtensionType):",
      "4211:         super().__init__(pa.int64(),",
      "4212:                          'pyarrow.tests.test_pandas.MyCustomIntegerType')",
      "4214:     def __arrow_ext_serialize__(self):",
      "4215:         return b''",
      "",
      "---------------"
    ],
    "python/pyarrow/types.pxi||python/pyarrow/types.pxi": [
      "File: python/pyarrow/types.pxi -> python/pyarrow/types.pxi",
      "--- Hunk 1 ---",
      "[Context before]",
      "1437:     Parameters",
      "1438:     ----------",
      "1439:     storage_type : DataType",
      "1440:     extension_name : str",
      "1442:     Examples",
      "1443:     --------",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1440:         The underlying storage type for the extension type.",
      "1442:         A unique name distinguishing this extension type. The name will be",
      "1443:         used when deserializing IPC data.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1671:                                     self.dim_names, self.permutation)",
      "1674: cdef class PyExtensionType(ExtensionType):",
      "1675:     \"\"\"",
      "1676:     Concrete base class for Python-defined extension types based on pickle",
      "1677:     for (de)serialization.",
      "1679:     Parameters",
      "1680:     ----------",
      "1681:     storage_type : DataType",
      "1682:         The storage type for which the extension is built.",
      "1728:     \"\"\"",
      "1730:     def __cinit__(self):",
      "",
      "[Removed Lines]",
      "1684:     Examples",
      "1685:     --------",
      "1686:     Define a UuidType extension type subclassing PyExtensionType:",
      "1688:     >>> import pyarrow as pa",
      "1689:     >>> class UuidType(pa.PyExtensionType):",
      "1690:     ...     def __init__(self):",
      "1691:     ...         pa.PyExtensionType.__init__(self, pa.binary(16))",
      "1692:     ...     def __reduce__(self):",
      "1693:     ...         return UuidType, ()",
      "1694:     ...",
      "1696:     Create an instance of UuidType extension type:",
      "1698:     >>> uuid_type = UuidType() # doctest: +SKIP",
      "1699:     >>> uuid_type # doctest: +SKIP",
      "1700:     UuidType(FixedSizeBinaryType(fixed_size_binary[16]))",
      "1702:     Inspect the extension type:",
      "1704:     >>> uuid_type.extension_name # doctest: +SKIP",
      "1705:     'arrow.py_extension_type'",
      "1706:     >>> uuid_type.storage_type # doctest: +SKIP",
      "1707:     FixedSizeBinaryType(fixed_size_binary[16])",
      "1709:     Wrap an array as an extension array:",
      "1711:     >>> import uuid",
      "1712:     >>> storage_array = pa.array([uuid.uuid4().bytes for _ in range(4)],",
      "1713:     ...                          pa.binary(16)) # doctest: +SKIP",
      "1714:     >>> uuid_type.wrap_array(storage_array) # doctest: +SKIP",
      "1715:     <pyarrow.lib.ExtensionArray object at ...>",
      "1716:     [",
      "1717:       ...",
      "1718:     ]",
      "1720:     Or do the same with creating an ExtensionArray:",
      "1722:     >>> pa.ExtensionArray.from_storage(uuid_type,",
      "1723:     ...                                storage_array) # doctest: +SKIP",
      "1724:     <pyarrow.lib.ExtensionArray object at ...>",
      "1725:     [",
      "1726:       ...",
      "1727:     ]",
      "",
      "[Added Lines]",
      "1677: _py_extension_type_auto_load = False",
      "1685:     .. warning::",
      "1686:        This class is deprecated and its deserialization is disabled by default.",
      "1687:        :class:`ExtensionType` is recommended instead.",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1733:                             \"PyExtensionType\")",
      "1735:     def __init__(self, DataType storage_type):",
      "1736:         ExtensionType.__init__(self, storage_type, \"arrow.py_extension_type\")",
      "1738:     def __reduce__(self):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1701:         warnings.warn(",
      "1702:             \"pyarrow.PyExtensionType is deprecated \"",
      "1703:             \"and will refuse deserialization by default. \"",
      "1704:             \"Instead, please derive from pyarrow.ExtensionType and implement \"",
      "1705:             \"your own serialization mechanism.\",",
      "1706:             FutureWarning)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1745:     @classmethod",
      "1746:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
      "1747:         try:",
      "1748:             ty = pickle.loads(serialized)",
      "1749:         except Exception:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1718:         if not _py_extension_type_auto_load:",
      "1719:             warnings.warn(",
      "1720:                 \"pickle-based deserialization of pyarrow.PyExtensionType subclasses \"",
      "1721:                 \"is disabled by default; if you only ingest \"",
      "1722:                 \"trusted data files, you may re-enable this using \"",
      "1723:                 \"`pyarrow.PyExtensionType.set_auto_load(True)`.\\n\"",
      "1724:                 \"In the future, Python-defined extension subclasses should \"",
      "1725:                 \"derive from pyarrow.ExtensionType (not pyarrow.PyExtensionType) \"",
      "1726:                 \"and implement their own serialization mechanism.\\n\",",
      "1727:                 RuntimeWarning)",
      "1728:             return UnknownExtensionType(storage_type, serialized)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1759:                             .format(ty.storage_type, storage_type))",
      "1760:         return ty",
      "1763: cdef class UnknownExtensionType(PyExtensionType):",
      "1764:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1744:     # XXX Cython marks extension types as immutable, so cannot expose this",
      "1745:     # as a writable class attribute.",
      "1746:     @classmethod",
      "1747:     def set_auto_load(cls, value):",
      "1748:         \"\"\"",
      "1749:         Enable or disable auto-loading of serialized PyExtensionType instances.",
      "1751:         Parameters",
      "1752:         ----------",
      "1753:         value : bool",
      "1754:             Whether to enable auto-loading.",
      "1755:         \"\"\"",
      "1756:         global _py_extension_type_auto_load",
      "1757:         assert isinstance(value, bool)",
      "1758:         _py_extension_type_auto_load = value",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c73cb13b9f89493f9fb91da854f95aa38bd86cc7",
      "candidate_info": {
        "commit_hash": "c73cb13b9f89493f9fb91da854f95aa38bd86cc7",
        "repo": "apache/arrow",
        "commit_url": "https://github.com/apache/arrow/commit/c73cb13b9f89493f9fb91da854f95aa38bd86cc7",
        "files": [
          "docs/source/python/extending_types.rst",
          "python/pyarrow/tests/test_cffi.py",
          "python/pyarrow/tests/test_extension_type.py",
          "python/pyarrow/tests/test_pandas.py",
          "python/pyarrow/types.pxi"
        ],
        "message": "GH-38607: [Python] Disable PyExtensionType autoload (#38608)\n\n### Rationale for this change\n\nPyExtensionType autoload is really a misfeature. It creates PyArrow-specific extension types, though using ExtensionType is almost the same complexity while allowing deserialization from non-PyArrow software.\n\n### What changes are included in this PR?\n\n* Disable PyExtensionType autoloading and deprecate PyExtensionType instantiation.\n* Update the docs to emphasize ExtensionType.\n\n### Are these changes tested?\n\nYes.\n\n### Are there any user-facing changes?\n\nYes.\n\n* Closes: #38607\n\nAuthored-by: Antoine Pitrou <antoine@python.org>\nSigned-off-by: Ra\u00fal Cumplido <raulcumplido@gmail.com>",
        "before_after_code_files": [
          "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py",
          "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py",
          "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py",
          "python/pyarrow/types.pxi||python/pyarrow/types.pxi"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py",
            "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py",
            "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py",
            "python/pyarrow/types.pxi||python/pyarrow/types.pxi"
          ],
          "candidate": [
            "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py",
            "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py",
            "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py",
            "python/pyarrow/types.pxi||python/pyarrow/types.pxi"
          ]
        }
      },
      "candidate_diff": {
        "python/pyarrow/tests/test_cffi.py||python/pyarrow/tests/test_cffi.py": [
          "File: python/pyarrow/tests/test_cffi.py -> python/pyarrow/tests/test_cffi.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: # specific language governing permissions and limitations",
          "17: # under the License.",
          "19: import ctypes",
          "20: import gc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: import contextlib",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:     return ctypes.pythonapi.PyCapsule_IsValid(ctypes.py_object(capsule), name) == 1",
          "56:     def __init__(self, width):",
          "57:         self._width = width",
          "60:     @property",
          "61:     def width(self):",
          "62:         return self._width",
          "68: def make_schema():",
          "",
          "[Removed Lines]",
          "54: class ParamExtType(pa.PyExtensionType):",
          "58:         pa.PyExtensionType.__init__(self, pa.binary(width))",
          "64:     def __reduce__(self):",
          "65:         return ParamExtType, (self.width,)",
          "",
          "[Added Lines]",
          "55: @contextlib.contextmanager",
          "56: def registered_extension_type(ext_type):",
          "57:     pa.register_extension_type(ext_type)",
          "58:     try:",
          "59:         yield",
          "60:     finally:",
          "61:         pa.unregister_extension_type(ext_type.extension_name)",
          "64: class ParamExtType(pa.ExtensionType):",
          "68:         super().__init__(pa.binary(width),",
          "69:                          \"pyarrow.tests.test_cffi.ParamExtType\")",
          "75:     def __arrow_ext_serialize__(self):",
          "76:         return str(self.width).encode()",
          "78:     @classmethod",
          "79:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "80:         width = int(serialized.decode())",
          "81:         return cls(width)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75:                      metadata={b'key1': b'value1'})",
          "78: def make_batch():",
          "79:     return pa.record_batch([[[1], [2, 42]]], make_schema())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94: def make_extension_storage_schema():",
          "95:     # Should be kept in sync with make_extension_schema",
          "96:     return pa.schema([('ext', ParamExtType(3).storage_type)],",
          "97:                      metadata={b'key1': b'value1'})",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "204:         pa.Array._import_from_c(ptr_array, ptr_schema)",
          "208:     c_schema = ffi.new(\"struct ArrowSchema*\")",
          "209:     ptr_schema = int(ffi.cast(\"uintptr_t\", c_schema))",
          "",
          "[Removed Lines]",
          "207: def check_export_import_schema(schema_factory):",
          "",
          "[Added Lines]",
          "229: def check_export_import_schema(schema_factory, expected_schema_factory=None):",
          "230:     if expected_schema_factory is None:",
          "231:         expected_schema_factory = schema_factory",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "215:     assert pa.total_allocated_bytes() > old_allocated",
          "216:     # Delete and recreate C++ object from exported pointer",
          "217:     schema_new = pa.Schema._import_from_c(ptr_schema)",
          "219:     assert pa.total_allocated_bytes() == old_allocated",
          "220:     del schema_new",
          "221:     assert pa.total_allocated_bytes() == old_allocated",
          "",
          "[Removed Lines]",
          "218:     assert schema_new == schema_factory()",
          "",
          "[Added Lines]",
          "243:     assert schema_new == expected_schema_factory()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "241: @needs_cffi",
          "242: def test_export_import_schema_with_extension():",
          "246: @needs_cffi",
          "",
          "[Removed Lines]",
          "243:     check_export_import_schema(make_extension_schema)",
          "",
          "[Added Lines]",
          "268:     # Extension type is unregistered => the storage type is imported",
          "269:     check_export_import_schema(make_extension_schema,",
          "270:                                make_extension_storage_schema)",
          "272:     # Extension type is registered => the extension type is imported",
          "273:     with registered_extension_type(ParamExtType(1)):",
          "274:         check_export_import_schema(make_extension_schema)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "320: @needs_cffi",
          "321: def test_export_import_batch_with_extension():",
          "325: def _export_import_batch_reader(ptr_stream, reader_factory):",
          "",
          "[Removed Lines]",
          "322:     check_export_import_batch(make_extension_batch)",
          "",
          "[Added Lines]",
          "353:     with registered_extension_type(ParamExtType(1)):",
          "354:         check_export_import_batch(make_extension_batch)",
          "",
          "---------------"
        ],
        "python/pyarrow/tests/test_extension_type.py||python/pyarrow/tests/test_extension_type.py": [
          "File: python/pyarrow/tests/test_extension_type.py -> python/pyarrow/tests/test_extension_type.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: # specific language governing permissions and limitations",
          "16: # under the License.",
          "18: import os",
          "19: import shutil",
          "20: import subprocess",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: import contextlib",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: import pytest",
          "34:     def __init__(self):",
          "43:     def __init__(self):",
          "52:     def __init__(self):",
          "59: class UuidScalarType(pa.ExtensionScalar):",
          "",
          "[Removed Lines]",
          "32: class TinyIntType(pa.PyExtensionType):",
          "35:         pa.PyExtensionType.__init__(self, pa.int8())",
          "37:     def __reduce__(self):",
          "38:         return TinyIntType, ()",
          "41: class IntegerType(pa.PyExtensionType):",
          "44:         pa.PyExtensionType.__init__(self, pa.int64())",
          "46:     def __reduce__(self):",
          "47:         return IntegerType, ()",
          "50: class IntegerEmbeddedType(pa.PyExtensionType):",
          "53:         pa.PyExtensionType.__init__(self, IntegerType())",
          "55:     def __reduce__(self):",
          "56:         return IntegerEmbeddedType, ()",
          "",
          "[Added Lines]",
          "33: @contextlib.contextmanager",
          "34: def registered_extension_type(ext_type):",
          "35:     pa.register_extension_type(ext_type)",
          "36:     try:",
          "37:         yield",
          "38:     finally:",
          "39:         pa.unregister_extension_type(ext_type.extension_name)",
          "42: @contextlib.contextmanager",
          "43: def enabled_auto_load():",
          "44:     pa.PyExtensionType.set_auto_load(True)",
          "45:     try:",
          "46:         yield",
          "47:     finally:",
          "48:         pa.PyExtensionType.set_auto_load(False)",
          "51: class TinyIntType(pa.ExtensionType):",
          "54:         super().__init__(pa.int8(), 'pyarrow.tests.TinyIntType')",
          "56:     def __arrow_ext_serialize__(self):",
          "57:         return b''",
          "59:     @classmethod",
          "60:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "61:         assert serialized == b''",
          "62:         assert storage_type == pa.int8()",
          "63:         return cls()",
          "66: class IntegerType(pa.ExtensionType):",
          "69:         super().__init__(pa.int64(), 'pyarrow.tests.IntegerType')",
          "71:     def __arrow_ext_serialize__(self):",
          "72:         return b''",
          "74:     @classmethod",
          "75:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "76:         assert serialized == b''",
          "77:         assert storage_type == pa.int64()",
          "78:         return cls()",
          "81: class IntegerEmbeddedType(pa.ExtensionType):",
          "84:         super().__init__(IntegerType(), 'pyarrow.tests.IntegerType')",
          "86:     def __arrow_ext_serialize__(self):",
          "87:         # XXX pa.BaseExtensionType should expose C++ serialization method",
          "88:         return self.storage_type.__arrow_ext_serialize__()",
          "90:     @classmethod",
          "91:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "92:         deserialized_storage_type = storage_type.__arrow_ext_deserialize__(",
          "93:             serialized)",
          "94:         assert deserialized_storage_type == storage_type",
          "95:         return cls()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:         return None if self.value is None else UUID(bytes=self.value.as_py())",
          "66:     def __init__(self):",
          "72:     def __arrow_ext_scalar_class__(self):",
          "73:         return UuidScalarType",
          "78:     def __init__(self):",
          "87:     def __init__(self):",
          "96:     def __init__(self, width):",
          "97:         self._width = width",
          "100:     @property",
          "101:     def width(self):",
          "102:         return self._width",
          "109:     storage_type = pa.struct([('left', pa.int64()),",
          "110:                               ('right', pa.int64())])",
          "112:     def __init__(self):",
          "121:     def __init__(self, storage_type):",
          "129:     \"\"\"",
          "130:     Generic extension type that can store any storage type.",
          "131:     \"\"\"",
          "133:     def __init__(self, storage_type, annotation):",
          "134:         self.annotation = annotation",
          "137:     def __reduce__(self):",
          "141: def ipc_write_batch(batch):",
          "",
          "[Removed Lines]",
          "64: class UuidType(pa.PyExtensionType):",
          "67:         pa.PyExtensionType.__init__(self, pa.binary(16))",
          "69:     def __reduce__(self):",
          "70:         return UuidType, ()",
          "76: class UuidType2(pa.PyExtensionType):",
          "79:         pa.PyExtensionType.__init__(self, pa.binary(16))",
          "81:     def __reduce__(self):",
          "82:         return UuidType2, ()",
          "85: class LabelType(pa.PyExtensionType):",
          "88:         pa.PyExtensionType.__init__(self, pa.string())",
          "90:     def __reduce__(self):",
          "91:         return LabelType, ()",
          "94: class ParamExtType(pa.PyExtensionType):",
          "98:         pa.PyExtensionType.__init__(self, pa.binary(width))",
          "104:     def __reduce__(self):",
          "105:         return ParamExtType, (self.width,)",
          "108: class MyStructType(pa.PyExtensionType):",
          "113:         pa.PyExtensionType.__init__(self, self.storage_type)",
          "115:     def __reduce__(self):",
          "116:         return MyStructType, ()",
          "119: class MyListType(pa.PyExtensionType):",
          "122:         pa.PyExtensionType.__init__(self, storage_type)",
          "124:     def __reduce__(self):",
          "125:         return MyListType, (self.storage_type,)",
          "128: class AnnotatedType(pa.PyExtensionType):",
          "135:         super().__init__(storage_type)",
          "138:         return AnnotatedType, (self.storage_type, self.annotation)",
          "",
          "[Added Lines]",
          "103: class UuidType(pa.ExtensionType):",
          "106:         super().__init__(pa.binary(16), 'pyarrow.tests.UuidType')",
          "111:     def __arrow_ext_serialize__(self):",
          "112:         return b''",
          "114:     @classmethod",
          "115:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "116:         return cls()",
          "119: class UuidType2(pa.ExtensionType):",
          "122:         super().__init__(pa.binary(16), 'pyarrow.tests.UuidType2')",
          "124:     def __arrow_ext_serialize__(self):",
          "125:         return b''",
          "127:     @classmethod",
          "128:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "129:         return cls()",
          "132: class LabelType(pa.ExtensionType):",
          "135:         super().__init__(pa.string(), 'pyarrow.tests.LabelType')",
          "137:     def __arrow_ext_serialize__(self):",
          "138:         return b''",
          "140:     @classmethod",
          "141:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "142:         return cls()",
          "145: class ParamExtType(pa.ExtensionType):",
          "149:         super().__init__(pa.binary(width), 'pyarrow.tests.ParamExtType')",
          "155:     def __arrow_ext_serialize__(self):",
          "156:         return str(self._width).encode()",
          "158:     @classmethod",
          "159:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "160:         width = int(serialized.decode())",
          "161:         assert storage_type == pa.binary(width)",
          "162:         return cls(width)",
          "165: class MyStructType(pa.ExtensionType):",
          "170:         super().__init__(self.storage_type, 'pyarrow.tests.MyStructType')",
          "172:     def __arrow_ext_serialize__(self):",
          "173:         return b''",
          "175:     @classmethod",
          "176:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "177:         assert serialized == b''",
          "178:         assert storage_type == cls.storage_type",
          "179:         return cls()",
          "182: class MyListType(pa.ExtensionType):",
          "185:         assert isinstance(storage_type, pa.ListType)",
          "186:         super().__init__(storage_type, 'pyarrow.tests.MyListType')",
          "188:     def __arrow_ext_serialize__(self):",
          "189:         return b''",
          "191:     @classmethod",
          "192:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "193:         assert serialized == b''",
          "194:         return cls(storage_type)",
          "197: class AnnotatedType(pa.ExtensionType):",
          "204:         super().__init__(storage_type, 'pyarrow.tests.AnnotatedType')",
          "206:     def __arrow_ext_serialize__(self):",
          "207:         return b''",
          "209:     @classmethod",
          "210:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "211:         assert serialized == b''",
          "212:         return cls(storage_type)",
          "215: class LegacyIntType(pa.PyExtensionType):",
          "217:     def __init__(self):",
          "218:         pa.PyExtensionType.__init__(self, pa.int8())",
          "221:         return LegacyIntType, ()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154: def test_ext_type_basics():",
          "155:     ty = UuidType()",
          "159: def test_ext_type_str():",
          "160:     ty = IntegerType()",
          "162:     assert str(ty) == expected",
          "163:     assert pa.DataType.__str__(ty) == expected",
          "",
          "[Removed Lines]",
          "156:     assert ty.extension_name == \"arrow.py_extension_type\"",
          "161:     expected = \"extension<arrow.py_extension_type<IntegerType>>\"",
          "",
          "[Added Lines]",
          "239:     assert ty.extension_name == \"pyarrow.tests.UuidType\"",
          "244:     expected = \"extension<pyarrow.tests.IntegerType<IntegerType>>\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "223:         del ty",
          "224:         ty = pickle_module.loads(ser)",
          "225:         wr = weakref.ref(ty)",
          "227:         del ty",
          "228:         assert wr() is None",
          "",
          "[Removed Lines]",
          "226:         assert ty.extension_name == \"arrow.py_extension_type\"",
          "",
          "[Added Lines]",
          "309:         assert ty.extension_name == \"pyarrow.tests.UuidType\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "571:     assert tiny_int_arr.type == TinyIntType()",
          "573:     # Casting between extension types w/ different storage types not okay.",
          "575:            \"to different extension type \"",
          "577:            \"One can first cast to the storage type, \"",
          "578:            \"then to the extension type.\"",
          "579:            )",
          "",
          "[Removed Lines]",
          "574:     msg = (\"Casting from 'extension<arrow.py_extension_type<TinyIntType>>' \"",
          "576:            \"'extension<arrow.py_extension_type<IntegerType>>' not permitted. \"",
          "",
          "[Added Lines]",
          "657:     msg = (\"Casting from 'extension<.*?<TinyIntType>>' \"",
          "659:            \"'extension<.*?<IntegerType>>' not permitted. \"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "660:     return pa.RecordBatch.from_arrays([arr], [\"exts\"])",
          "664:     arr = batch.column(0)",
          "668:     return arr",
          "672:     batch = example_batch()",
          "673:     buf = ipc_write_batch(batch)",
          "674:     del batch",
          "676:     batch = ipc_read_batch(buf)",
          "692:         batch = ipc_read_batch(buf)",
          "712: class PeriodArray(pa.ExtensionArray):",
          "",
          "[Removed Lines]",
          "663: def check_example_batch(batch):",
          "665:     assert isinstance(arr, pa.ExtensionArray)",
          "666:     assert arr.type.storage_type == pa.binary(3)",
          "667:     assert arr.storage.to_pylist() == [b\"foo\", b\"bar\"]",
          "671: def test_ipc():",
          "677:     arr = check_example_batch(batch)",
          "678:     assert arr.type == ParamExtType(3)",
          "681: def test_ipc_unknown_type():",
          "682:     batch = example_batch()",
          "683:     buf = ipc_write_batch(batch)",
          "684:     del batch",
          "686:     orig_type = ParamExtType",
          "687:     try:",
          "688:         # Simulate the original Python type being unavailable.",
          "689:         # Deserialization should not fail but return a placeholder type.",
          "690:         del globals()['ParamExtType']",
          "693:         arr = check_example_batch(batch)",
          "694:         assert isinstance(arr.type, pa.UnknownExtensionType)",
          "696:         # Can be serialized again",
          "697:         buf2 = ipc_write_batch(batch)",
          "698:         del batch, arr",
          "700:         batch = ipc_read_batch(buf2)",
          "701:         arr = check_example_batch(batch)",
          "702:         assert isinstance(arr.type, pa.UnknownExtensionType)",
          "703:     finally:",
          "704:         globals()['ParamExtType'] = orig_type",
          "706:     # Deserialize again with the type restored",
          "707:     batch = ipc_read_batch(buf2)",
          "708:     arr = check_example_batch(batch)",
          "709:     assert arr.type == ParamExtType(3)",
          "",
          "[Added Lines]",
          "746: def check_example_batch(batch, *, expect_extension):",
          "748:     if expect_extension:",
          "749:         assert isinstance(arr, pa.ExtensionArray)",
          "750:         assert arr.type.storage_type == pa.binary(3)",
          "751:         assert arr.storage.to_pylist() == [b\"foo\", b\"bar\"]",
          "752:     else:",
          "753:         assert arr.type == pa.binary(3)",
          "754:         assert arr.to_pylist() == [b\"foo\", b\"bar\"]",
          "758: def test_ipc_unregistered():",
          "764:     batch.validate(full=True)",
          "765:     check_example_batch(batch, expect_extension=False)",
          "768: def test_ipc_registered():",
          "769:     with registered_extension_type(ParamExtType(1)):",
          "770:         batch = example_batch()",
          "771:         buf = ipc_write_batch(batch)",
          "772:         del batch",
          "775:         batch.validate(full=True)",
          "776:         arr = check_example_batch(batch, expect_extension=True)",
          "777:         assert arr.type == ParamExtType(3)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "931:     # When reading in, properly create extension type if it is registered",
          "932:     result = pq.read_table(filename)",
          "933:     assert result.schema.field(\"ext\").type == period_type",
          "934:     assert result.schema.field(\"ext\").metadata == {}",
          "935:     # Get the exact array class defined by the registered type.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1001:     result.validate(full=True)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "939:     # When the type is not registered, read in as storage type",
          "940:     pa.unregister_extension_type(period_type.extension_name)",
          "941:     result = pq.read_table(filename)",
          "942:     assert result.schema.field(\"ext\").type == pa.int64()",
          "943:     # The extension metadata is present for roundtripping.",
          "944:     assert result.schema.field(\"ext\").metadata == {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1011:     result.validate(full=True)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "967:     filename = tmpdir / 'nested_extension_storage.parquet'",
          "968:     pq.write_table(orig_table, filename)",
          "970:     table = pq.read_table(filename)",
          "979: @pytest.mark.parquet",
          "",
          "[Removed Lines]",
          "971:     assert table.column('structs').type == mystruct_array.type",
          "972:     assert table.column('lists').type == mylist_array.type",
          "973:     assert table == orig_table",
          "975:     with pytest.raises(pa.ArrowInvalid, match='without all of its fields'):",
          "976:         pq.ParquetFile(filename).read(columns=['structs.left'])",
          "",
          "[Added Lines]",
          "1040:     # Unregistered",
          "1042:     table.validate(full=True)",
          "1043:     assert table.column('structs').type == struct_array.type",
          "1044:     assert table.column('structs').combine_chunks() == struct_array",
          "1045:     assert table.column('lists').type == list_array.type",
          "1046:     assert table.column('lists').combine_chunks() == list_array",
          "1048:     # Registered",
          "1049:     with registered_extension_type(mystruct_array.type):",
          "1050:         with registered_extension_type(mylist_array.type):",
          "1051:             table = pq.read_table(filename)",
          "1052:             table.validate(full=True)",
          "1053:             assert table.column('structs').type == mystruct_array.type",
          "1054:             assert table.column('lists').type == mylist_array.type",
          "1055:             assert table == orig_table",
          "1057:             # Cannot select a subfield of an extension type with",
          "1058:             # a struct storage type.",
          "1059:             with pytest.raises(pa.ArrowInvalid,",
          "1060:                                match='without all of its fields'):",
          "1061:                 pq.ParquetFile(filename).read(columns=['structs.left'])",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "995:     pq.write_table(orig_table, filename)",
          "997:     table = pq.read_table(filename)",
          "1001:     # List of extensions",
          "1002:     list_array = pa.ListArray.from_arrays([0, 1, None, 3], ext_array)",
          "",
          "[Removed Lines]",
          "998:     assert table.column(0).type == struct_array.type",
          "999:     assert table == orig_table",
          "",
          "[Added Lines]",
          "1083:     table.validate(full=True)",
          "1084:     assert table.column(0).type == pa.struct({'ints': pa.int64(),",
          "1085:                                               'exts': pa.int64()})",
          "1086:     with registered_extension_type(ext_type):",
          "1087:         table = pq.read_table(filename)",
          "1088:         table.validate(full=True)",
          "1089:         assert table.column(0).type == struct_array.type",
          "1090:         assert table == orig_table",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1006:     pq.write_table(orig_table, filename)",
          "1008:     table = pq.read_table(filename)",
          "1012:     # Large list of extensions",
          "1013:     list_array = pa.LargeListArray.from_arrays([0, 1, None, 3], ext_array)",
          "",
          "[Removed Lines]",
          "1009:     assert table.column(0).type == list_array.type",
          "1010:     assert table == orig_table",
          "",
          "[Added Lines]",
          "1100:     table.validate(full=True)",
          "1101:     assert table.column(0).type == pa.list_(pa.int64())",
          "1102:     with registered_extension_type(ext_type):",
          "1103:         table = pq.read_table(filename)",
          "1104:         table.validate(full=True)",
          "1105:         assert table.column(0).type == list_array.type",
          "1106:         assert table == orig_table",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1017:     pq.write_table(orig_table, filename)",
          "1019:     table = pq.read_table(filename)",
          "1024: @pytest.mark.parquet",
          "",
          "[Removed Lines]",
          "1020:     assert table.column(0).type == list_array.type",
          "1021:     assert table == orig_table",
          "",
          "[Added Lines]",
          "1116:     table.validate(full=True)",
          "1117:     assert table.column(0).type == pa.large_list(pa.int64())",
          "1118:     with registered_extension_type(ext_type):",
          "1119:         table = pq.read_table(filename)",
          "1120:         table.validate(full=True)",
          "1121:         assert table.column(0).type == list_array.type",
          "1122:         assert table == orig_table",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1040:     pq.write_table(orig_table, filename)",
          "1042:     table = pq.read_table(filename)",
          "1047: def test_to_numpy():",
          "",
          "[Removed Lines]",
          "1043:     assert table.column(0).type == mylist_array.type",
          "1044:     assert table == orig_table",
          "",
          "[Added Lines]",
          "1144:     assert table.column(0).type == pa.list_(pa.int64())",
          "1145:     with registered_extension_type(mylist_array.type):",
          "1146:         with registered_extension_type(inner_ext_array.type):",
          "1147:             table = pq.read_table(filename)",
          "1148:             assert table.column(0).type == mylist_array.type",
          "1149:             assert table == orig_table",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1370: def test_tensor_type_str(tensor_type, text):",
          "1371:     tensor_type_str = tensor_type.__str__()",
          "1372:     assert text in tensor_type_str",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1480: def test_legacy_int_type():",
          "1481:     with pytest.warns(FutureWarning, match=\"PyExtensionType is deprecated\"):",
          "1482:         ext_ty = LegacyIntType()",
          "1483:     arr = pa.array([1, 2, 3], type=ext_ty.storage_type)",
          "1484:     ext_arr = pa.ExtensionArray.from_storage(ext_ty, arr)",
          "1485:     batch = pa.RecordBatch.from_arrays([ext_arr], names=['ext'])",
          "1486:     buf = ipc_write_batch(batch)",
          "1488:     with pytest.warns(",
          "1489:             RuntimeWarning,",
          "1490:             match=\"pickle-based deserialization of pyarrow.PyExtensionType \"",
          "1491:                   \"subclasses is disabled by default\"):",
          "1492:         batch = ipc_read_batch(buf)",
          "1493:         assert isinstance(batch.column(0).type, pa.UnknownExtensionType)",
          "1495:     with enabled_auto_load():",
          "1496:         with pytest.warns(FutureWarning, match=\"PyExtensionType is deprecated\"):",
          "1497:             batch = ipc_read_batch(buf)",
          "1498:             assert isinstance(batch.column(0).type, LegacyIntType)",
          "1499:             assert batch.column(0) == ext_arr",
          "",
          "---------------"
        ],
        "python/pyarrow/tests/test_pandas.py||python/pyarrow/tests/test_pandas.py": [
          "File: python/pyarrow/tests/test_pandas.py -> python/pyarrow/tests/test_pandas.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4096:     assert result.equals(expected2)",
          "4101:     def __init__(self):",
          "4108: def PandasArray__arrow_array__(self, type=None):",
          "",
          "[Removed Lines]",
          "4099: class DummyExtensionType(pa.PyExtensionType):",
          "4102:         pa.PyExtensionType.__init__(self, pa.int64())",
          "4104:     def __reduce__(self):",
          "4105:         return DummyExtensionType, ()",
          "",
          "[Added Lines]",
          "4099: class DummyExtensionType(pa.ExtensionType):",
          "4102:         super().__init__(pa.int64(),",
          "4103:                          'pyarrow.tests.test_pandas.DummyExtensionType')",
          "4105:     def __arrow_ext_serialize__(self):",
          "4106:         return b''",
          "4108:     @classmethod",
          "4109:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "4110:         assert serialized == b''",
          "4111:         assert storage_type == pa.int64()",
          "4112:         return cls()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4198:     assert not isinstance(_get_mgr(result).blocks[0], _int.ExtensionBlock)",
          "4203:     def __init__(self):",
          "4209:     def to_pandas_dtype(self):",
          "4210:         return pd.Int64Dtype()",
          "",
          "[Removed Lines]",
          "4201: class MyCustomIntegerType(pa.PyExtensionType):",
          "4204:         pa.PyExtensionType.__init__(self, pa.int64())",
          "4206:     def __reduce__(self):",
          "4207:         return MyCustomIntegerType, ()",
          "",
          "[Added Lines]",
          "4208: class MyCustomIntegerType(pa.ExtensionType):",
          "4211:         super().__init__(pa.int64(),",
          "4212:                          'pyarrow.tests.test_pandas.MyCustomIntegerType')",
          "4214:     def __arrow_ext_serialize__(self):",
          "4215:         return b''",
          "",
          "---------------"
        ],
        "python/pyarrow/types.pxi||python/pyarrow/types.pxi": [
          "File: python/pyarrow/types.pxi -> python/pyarrow/types.pxi",
          "--- Hunk 1 ---",
          "[Context before]",
          "1437:     Parameters",
          "1438:     ----------",
          "1439:     storage_type : DataType",
          "1440:     extension_name : str",
          "1442:     Examples",
          "1443:     --------",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1440:         The underlying storage type for the extension type.",
          "1442:         A unique name distinguishing this extension type. The name will be",
          "1443:         used when deserializing IPC data.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1671:                                     self.dim_names, self.permutation)",
          "1674: cdef class PyExtensionType(ExtensionType):",
          "1675:     \"\"\"",
          "1676:     Concrete base class for Python-defined extension types based on pickle",
          "1677:     for (de)serialization.",
          "1679:     Parameters",
          "1680:     ----------",
          "1681:     storage_type : DataType",
          "1682:         The storage type for which the extension is built.",
          "1728:     \"\"\"",
          "1730:     def __cinit__(self):",
          "",
          "[Removed Lines]",
          "1684:     Examples",
          "1685:     --------",
          "1686:     Define a UuidType extension type subclassing PyExtensionType:",
          "1688:     >>> import pyarrow as pa",
          "1689:     >>> class UuidType(pa.PyExtensionType):",
          "1690:     ...     def __init__(self):",
          "1691:     ...         pa.PyExtensionType.__init__(self, pa.binary(16))",
          "1692:     ...     def __reduce__(self):",
          "1693:     ...         return UuidType, ()",
          "1694:     ...",
          "1696:     Create an instance of UuidType extension type:",
          "1698:     >>> uuid_type = UuidType() # doctest: +SKIP",
          "1699:     >>> uuid_type # doctest: +SKIP",
          "1700:     UuidType(FixedSizeBinaryType(fixed_size_binary[16]))",
          "1702:     Inspect the extension type:",
          "1704:     >>> uuid_type.extension_name # doctest: +SKIP",
          "1705:     'arrow.py_extension_type'",
          "1706:     >>> uuid_type.storage_type # doctest: +SKIP",
          "1707:     FixedSizeBinaryType(fixed_size_binary[16])",
          "1709:     Wrap an array as an extension array:",
          "1711:     >>> import uuid",
          "1712:     >>> storage_array = pa.array([uuid.uuid4().bytes for _ in range(4)],",
          "1713:     ...                          pa.binary(16)) # doctest: +SKIP",
          "1714:     >>> uuid_type.wrap_array(storage_array) # doctest: +SKIP",
          "1715:     <pyarrow.lib.ExtensionArray object at ...>",
          "1716:     [",
          "1717:       ...",
          "1718:     ]",
          "1720:     Or do the same with creating an ExtensionArray:",
          "1722:     >>> pa.ExtensionArray.from_storage(uuid_type,",
          "1723:     ...                                storage_array) # doctest: +SKIP",
          "1724:     <pyarrow.lib.ExtensionArray object at ...>",
          "1725:     [",
          "1726:       ...",
          "1727:     ]",
          "",
          "[Added Lines]",
          "1677: _py_extension_type_auto_load = False",
          "1685:     .. warning::",
          "1686:        This class is deprecated and its deserialization is disabled by default.",
          "1687:        :class:`ExtensionType` is recommended instead.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1733:                             \"PyExtensionType\")",
          "1735:     def __init__(self, DataType storage_type):",
          "1736:         ExtensionType.__init__(self, storage_type, \"arrow.py_extension_type\")",
          "1738:     def __reduce__(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1701:         warnings.warn(",
          "1702:             \"pyarrow.PyExtensionType is deprecated \"",
          "1703:             \"and will refuse deserialization by default. \"",
          "1704:             \"Instead, please derive from pyarrow.ExtensionType and implement \"",
          "1705:             \"your own serialization mechanism.\",",
          "1706:             FutureWarning)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1745:     @classmethod",
          "1746:     def __arrow_ext_deserialize__(cls, storage_type, serialized):",
          "1747:         try:",
          "1748:             ty = pickle.loads(serialized)",
          "1749:         except Exception:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1718:         if not _py_extension_type_auto_load:",
          "1719:             warnings.warn(",
          "1720:                 \"pickle-based deserialization of pyarrow.PyExtensionType subclasses \"",
          "1721:                 \"is disabled by default; if you only ingest \"",
          "1722:                 \"trusted data files, you may re-enable this using \"",
          "1723:                 \"`pyarrow.PyExtensionType.set_auto_load(True)`.\\n\"",
          "1724:                 \"In the future, Python-defined extension subclasses should \"",
          "1725:                 \"derive from pyarrow.ExtensionType (not pyarrow.PyExtensionType) \"",
          "1726:                 \"and implement their own serialization mechanism.\\n\",",
          "1727:                 RuntimeWarning)",
          "1728:             return UnknownExtensionType(storage_type, serialized)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1759:                             .format(ty.storage_type, storage_type))",
          "1760:         return ty",
          "1763: cdef class UnknownExtensionType(PyExtensionType):",
          "1764:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1744:     # XXX Cython marks extension types as immutable, so cannot expose this",
          "1745:     # as a writable class attribute.",
          "1746:     @classmethod",
          "1747:     def set_auto_load(cls, value):",
          "1748:         \"\"\"",
          "1749:         Enable or disable auto-loading of serialized PyExtensionType instances.",
          "1751:         Parameters",
          "1752:         ----------",
          "1753:         value : bool",
          "1754:             Whether to enable auto-loading.",
          "1755:         \"\"\"",
          "1756:         global _py_extension_type_auto_load",
          "1757:         assert isinstance(value, bool)",
          "1758:         _py_extension_type_auto_load = value",
          "",
          "---------------"
        ]
      }
    }
  ]
}
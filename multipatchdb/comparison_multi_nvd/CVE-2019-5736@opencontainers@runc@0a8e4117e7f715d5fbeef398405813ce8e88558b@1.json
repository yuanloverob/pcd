{
  "cve_id": "CVE-2019-5736",
  "cve_desc": "runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe.",
  "repo": "opencontainers/runc",
  "patch_hash": "0a8e4117e7f715d5fbeef398405813ce8e88558b",
  "patch_info": {
    "commit_hash": "0a8e4117e7f715d5fbeef398405813ce8e88558b",
    "repo": "opencontainers/runc",
    "commit_url": "https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b",
    "files": [
      "libcontainer/nsenter/cloned_binary.c",
      "libcontainer/nsenter/nsexec.c"
    ],
    "message": "nsenter: clone /proc/self/exe to avoid exposing host binary to container\n\nThere are quite a few circumstances where /proc/self/exe pointing to a\npretty important container binary is a _bad_ thing, so to avoid this we\nhave to make a copy (preferably doing self-clean-up and not being\nwriteable).\n\nWe require memfd_create(2) -- though there is an O_TMPFILE fallback --\nbut we can always extend this to use a scratch MNT_DETACH overlayfs or\ntmpfs. The main downside to this approach is no page-cache sharing for\nthe runc binary (which overlayfs would give us) but this is far less\ncomplicated.\n\nThis is only done during nsenter so that it happens transparently to the\nGo code, and any libcontainer users benefit from it. This also makes\nExtraFiles and --preserve-fds handling trivial (because we don't need to\nworry about it).\n\nFixes: CVE-2019-5736\nCo-developed-by: Christian Brauner <christian.brauner@ubuntu.com>\nSigned-off-by: Aleksa Sarai <asarai@suse.de>",
    "before_after_code_files": [
      "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c",
      "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
    ]
  },
  "patch_diff": {
    "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
      "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "18: #define _GNU_SOURCE",
      "19: #include <unistd.h>",
      "20: #include <stdio.h>",
      "21: #include <stdlib.h>",
      "22: #include <stdbool.h>",
      "23: #include <string.h>",
      "24: #include <limits.h>",
      "25: #include <fcntl.h>",
      "26: #include <errno.h>",
      "28: #include <sys/types.h>",
      "29: #include <sys/stat.h>",
      "30: #include <sys/vfs.h>",
      "31: #include <sys/mman.h>",
      "32: #include <sys/sendfile.h>",
      "33: #include <sys/syscall.h>",
      "36: #if !defined(SYS_memfd_create) && defined(__NR_memfd_create)",
      "37: #  define SYS_memfd_create __NR_memfd_create",
      "38: #endif",
      "39: #ifdef SYS_memfd_create",
      "40: #  define HAVE_MEMFD_CREATE",
      "42: #  ifndef MFD_CLOEXEC",
      "43: #    define MFD_CLOEXEC       0x0001U",
      "44: #    define MFD_ALLOW_SEALING 0x0002U",
      "45: #  endif",
      "46: int memfd_create(const char *name, unsigned int flags)",
      "47: {",
      "48:  return syscall(SYS_memfd_create, name, flags);",
      "49: }",
      "50: #endif",
      "53: #ifndef F_LINUX_SPECIFIC_BASE",
      "54: #  define F_LINUX_SPECIFIC_BASE 1024",
      "55: #endif",
      "56: #ifndef F_ADD_SEALS",
      "57: #  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)",
      "58: #  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)",
      "59: #endif",
      "60: #ifndef F_SEAL_SEAL",
      "65: #endif",
      "68: #ifdef HAVE_MEMFD_CREATE",
      "69: #  define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"",
      "70: #  define RUNC_MEMFD_SEALS \\",
      "71:  (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)",
      "72: #endif",
      "74: static void *must_realloc(void *ptr, size_t size)",
      "75: {",
      "76:  void *old = ptr;",
      "77:  do {",
      "78:   ptr = realloc(old, size);",
      "79:  } while(!ptr);",
      "80:  return ptr;",
      "81: }",
      "88: static int is_self_cloned(void)",
      "89: {",
      "90:  int fd, ret, is_cloned = 0;",
      "92:  fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);",
      "93:  if (fd < 0)",
      "94:   return -ENOTRECOVERABLE;",
      "96: #ifdef HAVE_MEMFD_CREATE",
      "97:  ret = fcntl(fd, F_GET_SEALS);",
      "98:  is_cloned = (ret == RUNC_MEMFD_SEALS);",
      "99: #else",
      "100:  struct stat statbuf = {0};",
      "101:  ret = fstat(fd, &statbuf);",
      "102:  if (ret >= 0)",
      "103:   is_cloned = (statbuf.st_nlink == 0);",
      "104: #endif",
      "105:  close(fd);",
      "106:  return is_cloned;",
      "107: }",
      "113: static char *read_file(char *path, size_t *length)",
      "114: {",
      "115:  int fd;",
      "116:  char buf[4096], *copy = NULL;",
      "118:  if (!length)",
      "119:   return NULL;",
      "121:  fd = open(path, O_RDONLY | O_CLOEXEC);",
      "122:  if (fd < 0)",
      "123:   return NULL;",
      "126:  for (;;) {",
      "127:   int n;",
      "129:   n = read(fd, buf, sizeof(buf));",
      "130:   if (n < 0)",
      "131:    goto error;",
      "132:   if (!n)",
      "133:    break;",
      "135:   copy = must_realloc(copy, (*length + n) * sizeof(*copy));",
      "136:   memcpy(copy + *length, buf, n);",
      "138:  }",
      "139:  close(fd);",
      "140:  return copy;",
      "142: error:",
      "143:  close(fd);",
      "144:  free(copy);",
      "145:  return NULL;",
      "146: }",
      "153: static int parse_xargs(char *data, int data_length, char ***output)",
      "154: {",
      "155:  int num = 0;",
      "156:  char *cur = data;",
      "158:  if (!data || *output != NULL)",
      "159:   return -1;",
      "161:  while (cur < data + data_length) {",
      "162:   num++;",
      "164:   (*output)[num - 1] = cur;",
      "165:   cur += strlen(cur) + 1;",
      "166:  }",
      "167:  (*output)[num] = NULL;",
      "168:  return num;",
      "169: }",
      "176: static int fetchve(char ***argv, char ***envp)",
      "177: {",
      "178:  char *cmdline = NULL, *environ = NULL;",
      "179:  size_t cmdline_size, environ_size;",
      "181:  cmdline = read_file(\"/proc/self/cmdline\", &cmdline_size);",
      "182:  if (!cmdline)",
      "183:   goto error;",
      "184:  environ = read_file(\"/proc/self/environ\", &environ_size);",
      "185:  if (!environ)",
      "186:   goto error;",
      "188:  if (parse_xargs(cmdline, cmdline_size, argv) <= 0)",
      "189:   goto error;",
      "190:  if (parse_xargs(environ, environ_size, envp) <= 0)",
      "191:   goto error;",
      "193:  return 0;",
      "195: error:",
      "196:  free(environ);",
      "197:  free(cmdline);",
      "198:  return -EINVAL;",
      "199: }",
      "201: static int clone_binary(void)",
      "202: {",
      "203:  int binfd, memfd;",
      "204:  ssize_t sent = 0;",
      "206: #ifdef HAVE_MEMFD_CREATE",
      "207:  memfd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);",
      "208: #else",
      "209:  memfd = open(\"/tmp\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0711);",
      "210: #endif",
      "211:  if (memfd < 0)",
      "212:   return -ENOTRECOVERABLE;",
      "214:  binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);",
      "215:  if (binfd < 0)",
      "216:   goto error;",
      "218:  sent = sendfile(memfd, binfd, NULL, RUNC_SENDFILE_MAX);",
      "219:  close(binfd);",
      "220:  if (sent < 0)",
      "221:   goto error;",
      "223: #ifdef HAVE_MEMFD_CREATE",
      "224:  int err = fcntl(memfd, F_ADD_SEALS, RUNC_MEMFD_SEALS);",
      "225:  if (err < 0)",
      "226:   goto error;",
      "227: #else",
      "229:  int newfd;",
      "230:  char *fdpath = NULL;",
      "232:  if (asprintf(&fdpath, \"/proc/self/fd/%d\", memfd) < 0)",
      "233:   goto error;",
      "234:  newfd = open(fdpath, O_RDONLY | O_CLOEXEC);",
      "235:  free(fdpath);",
      "236:  if (newfd < 0)",
      "237:   goto error;",
      "239:  close(memfd);",
      "240:  memfd = newfd;",
      "241: #endif",
      "242:  return memfd;",
      "244: error:",
      "245:  close(memfd);",
      "246:  return -EIO;",
      "247: }",
      "249: int ensure_cloned_binary(void)",
      "250: {",
      "251:  int execfd;",
      "252:  char **argv = NULL, **envp = NULL;",
      "255:  int cloned = is_self_cloned();",
      "256:  if (cloned > 0 || cloned == -ENOTRECOVERABLE)",
      "257:   return cloned;",
      "259:  if (fetchve(&argv, &envp) < 0)",
      "260:   return -EINVAL;",
      "262:  execfd = clone_binary();",
      "263:  if (execfd < 0)",
      "264:   return -EIO;",
      "266:  fexecve(execfd, argv, envp);",
      "267:  return -ENOEXEC;",
      "268: }",
      "",
      "---------------"
    ],
    "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
      "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "534:  free(namespaces);",
      "535: }",
      "537: void nsexec(void)",
      "538: {",
      "539:  int pipenum;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "538: extern int ensure_cloned_binary(void);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "549:  if (pipenum == -1)",
      "550:   return;",
      "553:  nl_parse(pipenum, &config);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "560:  if (ensure_cloned_binary() < 0)",
      "561:   bail(\"could not ensure we are a cloned binary\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2e8efc1bc72ed20aac5182b442d3103c554497e0",
      "candidate_info": {
        "commit_hash": "2e8efc1bc72ed20aac5182b442d3103c554497e0",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/2e8efc1bc72ed20aac5182b442d3103c554497e0",
        "files": [
          "libcontainer/nsenter/cloned_binary.c"
        ],
        "message": "add prompt when rootless users have no read access to runc bin\n\nSigned-off-by: Lifubang <lifubang@acmcoder.com>",
        "before_after_code_files": [
          "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ],
          "candidate": [
            "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/cloned_binary.c||libcontainer/nsenter/cloned_binary.c": [
          "File: libcontainer/nsenter/cloned_binary.c -> libcontainer/nsenter/cloned_binary.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  struct statfs fsbuf = {};",
          "97:  fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);",
          "99:   return -ENOTRECOVERABLE;",
          "",
          "[Removed Lines]",
          "98:  if (fd < 0)",
          "",
          "[Added Lines]",
          "98:  if (fd < 0) {",
          "99:   fprintf(stderr, \"you have no read access to runc binary file\\n\");",
          "101:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
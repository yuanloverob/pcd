{
  "cve_id": "CVE-2014-1904",
  "cve_desc": "Cross-site scripting (XSS) vulnerability in web/servlet/tags/form/FormTag.java in Spring MVC in Spring Framework 3.0.0 before 3.2.8 and 4.0.0 before 4.0.2 allows remote attackers to inject arbitrary web script or HTML via the requested URI in a default action.",
  "repo": "spring-projects/spring-framework",
  "patch_hash": "741b4b229ae032bd17175b46f98673ce0bd2d485",
  "patch_info": {
    "commit_hash": "741b4b229ae032bd17175b46f98673ce0bd2d485",
    "repo": "spring-projects/spring-framework",
    "commit_url": "https://github.com/spring-projects/spring-framework/commit/741b4b229ae032bd17175b46f98673ce0bd2d485",
    "files": [
      "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
      "spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java"
    ],
    "message": "Add encoding for the default action in FormTag\n\nIssue: SPR-11426",
    "before_after_code_files": [
      "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
      "spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java||spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java"
    ]
  },
  "patch_diff": {
    "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java": [
      "File: spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java -> spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: package org.springframework.web.servlet.tags.form;",
      "19: import java.util.Map;",
      "21: import javax.servlet.ServletRequest;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: import java.io.UnsupportedEncodingException;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "32: import org.springframework.util.StringUtils;",
      "33: import org.springframework.web.servlet.support.RequestDataValueProcessor;",
      "34: import org.springframework.web.util.HtmlUtils;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "36: import org.springframework.web.util.UriUtils;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "442:   }",
      "443:   else {",
      "444:    String requestUri = getRequestContext().getRequestUri();",
      "445:    ServletResponse response = this.pageContext.getResponse();",
      "446:    if (response instanceof HttpServletResponse) {",
      "447:     requestUri = ((HttpServletResponse) response).encodeURL(requestUri);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "447:    String encoding = pageContext.getResponse().getCharacterEncoding();",
      "448:    try {",
      "449:     requestUri = UriUtils.encodePath(requestUri, encoding);",
      "450:    }",
      "451:    catch (UnsupportedEncodingException e) {",
      "452:     throw new JspException(e);",
      "453:    }",
      "",
      "---------------"
    ],
    "spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java||spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java": [
      "File: spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java -> spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "340:   assertFormTagClosed(output);",
      "341:  }",
      "343:  private String getFormTag(String output) {",
      "344:   int inputStart = output.indexOf(\"<\", 1);",
      "345:   int inputEnd = output.lastIndexOf(\">\", output.length() - 2);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "343:  public void testDefaultActionEncoded() throws Exception {",
      "345:   this.request.setRequestURI(\"/a b c\");",
      "346:   request.setQueryString(\"\");",
      "348:   this.tag.doStartTag();",
      "349:   this.tag.doEndTag();",
      "350:   this.tag.doFinally();",
      "352:   String output = getOutput();",
      "353:   String formOutput = getFormTag(output);",
      "355:   assertContainsAttribute(formOutput, \"action\", \"/a%20b%20c\");",
      "356:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "14e5a02870f9ef90df6171c63ee23d0db5c29809",
      "candidate_info": {
        "commit_hash": "14e5a02870f9ef90df6171c63ee23d0db5c29809",
        "repo": "spring-projects/spring-framework",
        "commit_url": "https://github.com/spring-projects/spring-framework/commit/14e5a02870f9ef90df6171c63ee23d0db5c29809",
        "files": [
          "spring-context/src/main/java/org/springframework/cache/CacheManager.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
          "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java",
          "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
        ],
        "message": "Mixed polishing along with recent changes",
        "before_after_code_files": [
          "spring-context/src/main/java/org/springframework/cache/CacheManager.java||spring-context/src/main/java/org/springframework/cache/CacheManager.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
          "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
          "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java||spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java||spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java",
          "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java||spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java||spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
          ],
          "candidate": [
            "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
          ]
        }
      },
      "candidate_diff": {
        "spring-context/src/main/java/org/springframework/cache/CacheManager.java||spring-context/src/main/java/org/springframework/cache/CacheManager.java": [
          "File: spring-context/src/main/java/org/springframework/cache/CacheManager.java -> spring-context/src/main/java/org/springframework/cache/CacheManager.java"
        ],
        "spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java": [
          "File: spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java -> spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: public class CompoundExpression extends SpelNodeImpl {",
          "32:  public CompoundExpression(int pos,SpelNodeImpl... expressionComponents) {",
          "36:   }",
          "37:  }",
          "",
          "[Removed Lines]",
          "33:   super(pos,expressionComponents);",
          "34:   if (expressionComponents.length<2) {",
          "35:    throw new IllegalStateException(\"Dont build compound expression less than one entry: \"+expressionComponents.length);",
          "",
          "[Added Lines]",
          "33:   super(pos, expressionComponents);",
          "34:   if (expressionComponents.length < 2) {",
          "35:    throw new IllegalStateException(\"Do not build compound expression less than one entry: \" +",
          "36:      expressionComponents.length);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:   if (getChildCount() == 1) {",
          "43:    return this.children[0].getValueRef(state);",
          "44:   }",
          "47:   try {",
          "50:    int cc = getChildCount();",
          "51:    for (int i = 1; i < cc - 1; i++) {",
          "52:     try {",
          "",
          "[Removed Lines]",
          "45:   TypedValue result = null;",
          "46:   SpelNodeImpl nextNode = null;",
          "48:    nextNode = this.children[0];",
          "49:    result = nextNode.getValueInternal(state);",
          "",
          "[Added Lines]",
          "46:   SpelNodeImpl nextNode = this.children[0];",
          "48:    TypedValue result = nextNode.getValueInternal(state);",
          "",
          "---------------"
        ],
        "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java": [
          "File: spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java -> spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  }",
          "91:  private class ArrayIndexingValueRef implements ValueRef {",
          "93:   private final TypeConverter typeConverter;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:  @Override",
          "92:  protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {",
          "93:   TypedValue context = state.getActiveContextObject();",
          "94:   Object targetObject = context.getValue();",
          "95:   TypeDescriptor targetObjectTypeDescriptor = context.getTypeDescriptor();",
          "96:   TypedValue indexValue = null;",
          "97:   Object index = null;",
          "101:   if (targetObject instanceof Map && (this.children[0] instanceof PropertyOrFieldReference)) {",
          "102:    PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];",
          "103:    index = reference.getName();",
          "104:    indexValue = new TypedValue(index);",
          "105:   }",
          "106:   else {",
          "109:    try {",
          "110:     state.pushActiveContextObject(state.getRootContextObject());",
          "111:     indexValue = this.children[0].getValueInternal(state);",
          "112:     index = indexValue.getValue();",
          "113:    }",
          "114:    finally {",
          "115:     state.popActiveContextObject();",
          "116:    }",
          "117:   }",
          "120:   if (targetObject instanceof Map) {",
          "121:    Object key = index;",
          "122:    if (targetObjectTypeDescriptor.getMapKeyTypeDescriptor() != null) {",
          "123:     key = state.convertValue(key, targetObjectTypeDescriptor.getMapKeyTypeDescriptor());",
          "124:    }",
          "125:    return new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) targetObject, key,",
          "126:      targetObjectTypeDescriptor);",
          "127:   }",
          "129:   if (targetObject == null) {",
          "130:    throw new SpelEvaluationException(getStartPosition(), SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);",
          "131:   }",
          "135:   if (targetObject.getClass().isArray() || targetObject instanceof Collection || targetObject instanceof String) {",
          "136:    int idx = (Integer) state.convertValue(index, TypeDescriptor.valueOf(Integer.class));",
          "137:    if (targetObject.getClass().isArray()) {",
          "138:     return new ArrayIndexingValueRef(state.getTypeConverter(), targetObject, idx, targetObjectTypeDescriptor);",
          "139:    }",
          "140:    else if (targetObject instanceof Collection) {",
          "141:     return new CollectionIndexingValueRef((Collection<?>) targetObject, idx, targetObjectTypeDescriptor,",
          "142:       state.getTypeConverter(), state.getConfiguration().isAutoGrowCollections(),",
          "143:       state.getConfiguration().getMaximumAutoGrowSize());",
          "144:    }",
          "145:    else if (targetObject instanceof String) {",
          "146:     return new StringIndexingLValue((String) targetObject, idx, targetObjectTypeDescriptor);",
          "147:    }",
          "148:   }",
          "152:   if (indexValue.getTypeDescriptor().getType() == String.class) {",
          "153:    return new PropertyIndexingValueRef(targetObject, (String) indexValue.getValue(),",
          "154:      state.getEvaluationContext(), targetObjectTypeDescriptor);",
          "155:   }",
          "157:   throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,",
          "158:     targetObjectTypeDescriptor.toString());",
          "159:  }",
          "161:  @Override",
          "162:  public String toStringAST() {",
          "163:   StringBuilder sb = new StringBuilder();",
          "164:   sb.append(\"[\");",
          "165:   for (int i = 0; i < getChildCount(); i++) {",
          "166:    if (i > 0) {",
          "167:     sb.append(\",\");",
          "168:    }",
          "169:    sb.append(getChild(i).toStringAST());",
          "170:   }",
          "171:   sb.append(\"]\");",
          "172:   return sb.toString();",
          "173:  }",
          "175:  private void setArrayElement(TypeConverter converter, Object ctx, int idx, Object newValue,",
          "176:    Class<?> arrayComponentType) throws EvaluationException {",
          "178:   if (arrayComponentType == Integer.TYPE) {",
          "179:    int[] array = (int[]) ctx;",
          "180:    checkAccess(array.length, idx);",
          "181:    array[idx] = (Integer) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "182:      TypeDescriptor.valueOf(Integer.class));",
          "183:   }",
          "184:   else if (arrayComponentType == Boolean.TYPE) {",
          "185:    boolean[] array = (boolean[]) ctx;",
          "186:    checkAccess(array.length, idx);",
          "187:    array[idx] = (Boolean) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "188:      TypeDescriptor.valueOf(Boolean.class));",
          "189:   }",
          "190:   else if (arrayComponentType == Character.TYPE) {",
          "191:    char[] array = (char[]) ctx;",
          "192:    checkAccess(array.length, idx);",
          "193:    array[idx] = (Character) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "194:      TypeDescriptor.valueOf(Character.class));",
          "195:   }",
          "196:   else if (arrayComponentType == Long.TYPE) {",
          "197:    long[] array = (long[]) ctx;",
          "198:    checkAccess(array.length, idx);",
          "199:    array[idx] = (Long) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "200:      TypeDescriptor.valueOf(Long.class));",
          "201:   }",
          "202:   else if (arrayComponentType == Short.TYPE) {",
          "203:    short[] array = (short[]) ctx;",
          "204:    checkAccess(array.length, idx);",
          "205:    array[idx] = (Short) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "206:      TypeDescriptor.valueOf(Short.class));",
          "207:   }",
          "208:   else if (arrayComponentType == Double.TYPE) {",
          "209:    double[] array = (double[]) ctx;",
          "210:    checkAccess(array.length, idx);",
          "211:    array[idx] = (Double) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "212:      TypeDescriptor.valueOf(Double.class));",
          "213:   }",
          "214:   else if (arrayComponentType == Float.TYPE) {",
          "215:    float[] array = (float[]) ctx;",
          "216:    checkAccess(array.length, idx);",
          "217:    array[idx] = (Float) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "218:      TypeDescriptor.valueOf(Float.class));",
          "219:   }",
          "220:   else if (arrayComponentType == Byte.TYPE) {",
          "221:    byte[] array = (byte[]) ctx;",
          "222:    checkAccess(array.length, idx);",
          "223:    array[idx] = (Byte) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "224:      TypeDescriptor.valueOf(Byte.class));",
          "225:   }",
          "226:   else {",
          "227:    Object[] array = (Object[]) ctx;",
          "228:    checkAccess(array.length, idx);",
          "229:    array[idx] = converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "230:      TypeDescriptor.valueOf(arrayComponentType));",
          "231:   }",
          "232:  }",
          "234:  private Object accessArrayElement(Object ctx, int idx) throws SpelEvaluationException {",
          "235:   Class<?> arrayComponentType = ctx.getClass().getComponentType();",
          "236:   if (arrayComponentType == Integer.TYPE) {",
          "237:    int[] array = (int[]) ctx;",
          "238:    checkAccess(array.length, idx);",
          "239:    return array[idx];",
          "240:   }",
          "241:   else if (arrayComponentType == Boolean.TYPE) {",
          "242:    boolean[] array = (boolean[]) ctx;",
          "243:    checkAccess(array.length, idx);",
          "244:    return array[idx];",
          "245:   }",
          "246:   else if (arrayComponentType == Character.TYPE) {",
          "247:    char[] array = (char[]) ctx;",
          "248:    checkAccess(array.length, idx);",
          "249:    return array[idx];",
          "250:   }",
          "251:   else if (arrayComponentType == Long.TYPE) {",
          "252:    long[] array = (long[]) ctx;",
          "253:    checkAccess(array.length, idx);",
          "254:    return array[idx];",
          "255:   }",
          "256:   else if (arrayComponentType == Short.TYPE) {",
          "257:    short[] array = (short[]) ctx;",
          "258:    checkAccess(array.length, idx);",
          "259:    return array[idx];",
          "260:   }",
          "261:   else if (arrayComponentType == Double.TYPE) {",
          "262:    double[] array = (double[]) ctx;",
          "263:    checkAccess(array.length, idx);",
          "264:    return array[idx];",
          "265:   }",
          "266:   else if (arrayComponentType == Float.TYPE) {",
          "267:    float[] array = (float[]) ctx;",
          "268:    checkAccess(array.length, idx);",
          "269:    return array[idx];",
          "270:   }",
          "271:   else if (arrayComponentType == Byte.TYPE) {",
          "272:    byte[] array = (byte[]) ctx;",
          "273:    checkAccess(array.length, idx);",
          "274:    return array[idx];",
          "275:   }",
          "276:   else {",
          "277:    Object[] array = (Object[]) ctx;",
          "278:    checkAccess(array.length, idx);",
          "279:    return array[idx];",
          "280:   }",
          "281:  }",
          "283:  private void checkAccess(int arrayLength, int index) throws SpelEvaluationException {",
          "284:   if (index > arrayLength) {",
          "285:    throw new SpelEvaluationException(getStartPosition(), SpelMessage.ARRAY_INDEX_OUT_OF_BOUNDS,",
          "286:      arrayLength, index);",
          "287:   }",
          "288:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "129:  @SuppressWarnings({\"rawtypes\", \"unchecked\"})",
          "132:   private final TypeConverter typeConverter;",
          "",
          "[Removed Lines]",
          "130:  private class MapIndexingValueRef implements ValueRef {",
          "",
          "[Added Lines]",
          "330:  private static class MapIndexingValueRef implements ValueRef {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138:   private final TypeDescriptor mapEntryTypeDescriptor;",
          "143:    this.typeConverter = typeConverter;",
          "144:    this.map = map;",
          "145:    this.key = key;",
          "146:    this.mapEntryTypeDescriptor = mapEntryTypeDescriptor;",
          "147:   }",
          "150:   @Override",
          "151:   public TypedValue getValue() {",
          "152:    Object value = this.map.get(this.key);",
          "",
          "[Removed Lines]",
          "141:   MapIndexingValueRef(TypeConverter typeConverter, Map map, Object key,",
          "142:     TypeDescriptor mapEntryTypeDescriptor) {",
          "",
          "[Added Lines]",
          "340:   public MapIndexingValueRef(TypeConverter typeConverter, Map map, Object key, TypeDescriptor mapEntryTypeDescriptor) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "194:   public TypedValue getValue() {",
          "195:    Class<?> targetObjectRuntimeClass = getObjectClass(this.targetObject);",
          "196:    try {",
          "198:       Indexer.this.cachedReadTargetType.equals(targetObjectRuntimeClass)) {",
          "200:      return Indexer.this.cachedReadAccessor.read(this.evaluationContext, this.targetObject, this.name);",
          "201:     }",
          "203:     List<PropertyAccessor> accessorsToTry = AstUtils.getPropertyAccessorsToTry(",
          "204:       targetObjectRuntimeClass, this.evaluationContext.getPropertyAccessors());",
          "206:     if (accessorsToTry != null) {",
          "207:      for (PropertyAccessor accessor : accessorsToTry) {",
          "208:       if (accessor.canRead(this.evaluationContext, this.targetObject, this.name)) {",
          "",
          "[Removed Lines]",
          "197:     if (Indexer.this.cachedReadName != null && Indexer.this.cachedReadName.equals(this.name) && Indexer.this.cachedReadTargetType != null &&",
          "",
          "[Added Lines]",
          "393:     if (Indexer.this.cachedReadName != null && Indexer.this.cachedReadName.equals(this.name) &&",
          "394:       Indexer.this.cachedReadTargetType != null &&",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "230:   public void setValue(Object newValue) {",
          "231:    Class<?> contextObjectClass = getObjectClass(this.targetObject);",
          "232:    try {",
          "234:       Indexer.this.cachedWriteTargetType.equals(contextObjectClass)) {",
          "236:      Indexer.this.cachedWriteAccessor.write(this.evaluationContext, this.targetObject, this.name, newValue);",
          "237:      return;",
          "238:     }",
          "",
          "[Removed Lines]",
          "233:     if (Indexer.this.cachedWriteName != null && Indexer.this.cachedWriteName.equals(this.name) && Indexer.this.cachedWriteTargetType != null &&",
          "",
          "[Added Lines]",
          "428:     if (Indexer.this.cachedWriteName != null && Indexer.this.cachedWriteName.equals(this.name) &&",
          "429:       Indexer.this.cachedWriteTargetType != null &&",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "271:   private final int index;",
          "275:   private final TypeConverter typeConverter;",
          "",
          "[Removed Lines]",
          "273:   private final TypeDescriptor collectionEntryTypeDescriptor;",
          "",
          "[Added Lines]",
          "469:   private final TypeDescriptor collectionEntryDescriptor;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "279:   private final int maximumSize;",
          "283:     TypeConverter typeConverter, boolean growCollection, int maximumSize) {",
          "284:    this.collection = collection;",
          "285:    this.index = index;",
          "287:    this.typeConverter = typeConverter;",
          "288:    this.growCollection = growCollection;",
          "289:    this.maximumSize = maximumSize;",
          "",
          "[Removed Lines]",
          "282:   CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryTypeDescriptor,",
          "286:    this.collectionEntryTypeDescriptor = collectionEntryTypeDescriptor;",
          "",
          "[Added Lines]",
          "477:   public CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryTypeDescriptor,",
          "481:    this.collectionEntryDescriptor = collectionEntryTypeDescriptor;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "295:    growCollectionIfNecessary();",
          "296:    if (this.collection instanceof List) {",
          "297:     Object o = ((List) this.collection).get(this.index);",
          "299:    }",
          "300:    int pos = 0;",
          "301:    for (Object o : this.collection) {",
          "302:     if (pos == this.index) {",
          "304:     }",
          "305:     pos++;",
          "306:    }",
          "",
          "[Removed Lines]",
          "298:     return new TypedValue(o, this.collectionEntryTypeDescriptor.elementTypeDescriptor(o));",
          "303:      return new TypedValue(o, this.collectionEntryTypeDescriptor.elementTypeDescriptor(o));",
          "",
          "[Added Lines]",
          "493:     return new TypedValue(o, this.collectionEntryDescriptor.elementTypeDescriptor(o));",
          "498:      return new TypedValue(o, this.collectionEntryDescriptor.elementTypeDescriptor(o));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "312:    growCollectionIfNecessary();",
          "313:    if (this.collection instanceof List) {",
          "314:     List list = (List) this.collection;",
          "316:      newValue = this.typeConverter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "318:     }",
          "319:     list.set(this.index, newValue);",
          "320:    }",
          "321:    else {",
          "322:     throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,",
          "324:    }",
          "325:   }",
          "327:   private void growCollectionIfNecessary() {",
          "328:    if (this.index >= this.collection.size()) {",
          "330:     if (!this.growCollection) {",
          "331:      throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,",
          "332:        this.collection.size(), this.index);",
          "333:     }",
          "335:     if(this.index >= this.maximumSize) {",
          "336:      throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION);",
          "337:     }",
          "340:      throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);",
          "341:     }",
          "344:     try {",
          "345:      int newElements = this.index - this.collection.size();",
          "346:      while (newElements >= 0) {",
          "",
          "[Removed Lines]",
          "315:     if (this.collectionEntryTypeDescriptor.getElementTypeDescriptor() != null) {",
          "317:        this.collectionEntryTypeDescriptor.getElementTypeDescriptor());",
          "323:       this.collectionEntryTypeDescriptor.toString());",
          "339:     if (this.collectionEntryTypeDescriptor.getElementTypeDescriptor() == null) {",
          "343:     TypeDescriptor elementType = this.collectionEntryTypeDescriptor.getElementTypeDescriptor();",
          "",
          "[Added Lines]",
          "510:     if (this.collectionEntryDescriptor.getElementTypeDescriptor() != null) {",
          "512:        this.collectionEntryDescriptor.getElementTypeDescriptor());",
          "518:       this.collectionEntryDescriptor.toString());",
          "531:     if (this.collectionEntryDescriptor.getElementTypeDescriptor() == null) {",
          "534:     TypeDescriptor elementType = this.collectionEntryDescriptor.getElementTypeDescriptor();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "398:   }",
          "399:  }",
          "601: }",
          "",
          "[Removed Lines]",
          "401:  @Override",
          "402:  protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {",
          "404:   TypedValue context = state.getActiveContextObject();",
          "405:   Object targetObject = context.getValue();",
          "406:   TypeDescriptor targetObjectTypeDescriptor = context.getTypeDescriptor();",
          "407:   TypedValue indexValue = null;",
          "408:   Object index = null;",
          "412:   if (targetObject instanceof Map && (this.children[0] instanceof PropertyOrFieldReference)) {",
          "413:    PropertyOrFieldReference reference = (PropertyOrFieldReference) this.children[0];",
          "414:    index = reference.getName();",
          "415:    indexValue = new TypedValue(index);",
          "416:   }",
          "417:   else {",
          "420:    try {",
          "421:     state.pushActiveContextObject(state.getRootContextObject());",
          "422:     indexValue = this.children[0].getValueInternal(state);",
          "423:     index = indexValue.getValue();",
          "424:    }",
          "425:    finally {",
          "426:     state.popActiveContextObject();",
          "427:    }",
          "428:   }",
          "431:   if (targetObject instanceof Map) {",
          "432:    Object key = index;",
          "433:    if (targetObjectTypeDescriptor.getMapKeyTypeDescriptor() != null) {",
          "434:     key = state.convertValue(key, targetObjectTypeDescriptor.getMapKeyTypeDescriptor());",
          "435:    }",
          "436:    return new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) targetObject, key,",
          "437:      targetObjectTypeDescriptor);",
          "438:   }",
          "440:   if (targetObject == null) {",
          "441:    throw new SpelEvaluationException(getStartPosition(), SpelMessage.CANNOT_INDEX_INTO_NULL_VALUE);",
          "442:   }",
          "446:   if (targetObject.getClass().isArray() || targetObject instanceof Collection || targetObject instanceof String) {",
          "447:    int idx = (Integer) state.convertValue(index, TypeDescriptor.valueOf(Integer.class));",
          "448:    if (targetObject.getClass().isArray()) {",
          "449:     return new ArrayIndexingValueRef(state.getTypeConverter(), targetObject, idx, targetObjectTypeDescriptor);",
          "450:    }",
          "451:    else if (targetObject instanceof Collection) {",
          "452:     return new CollectionIndexingValueRef((Collection<?>) targetObject, idx, targetObjectTypeDescriptor,",
          "453:       state.getTypeConverter(), state.getConfiguration().isAutoGrowCollections(),",
          "454:       state.getConfiguration().getMaximumAutoGrowSize());",
          "455:    }",
          "456:    else if (targetObject instanceof String) {",
          "457:     return new StringIndexingLValue((String) targetObject, idx, targetObjectTypeDescriptor);",
          "458:    }",
          "459:   }",
          "463:   if (indexValue.getTypeDescriptor().getType() == String.class) {",
          "464:    return new PropertyIndexingValueRef(targetObject, (String) indexValue.getValue(),",
          "465:      state.getEvaluationContext(), targetObjectTypeDescriptor);",
          "466:   }",
          "468:   throw new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,",
          "469:     targetObjectTypeDescriptor.toString());",
          "470:  }",
          "472:  @Override",
          "473:  public String toStringAST() {",
          "474:   StringBuilder sb = new StringBuilder();",
          "475:   sb.append(\"[\");",
          "476:   for (int i = 0; i < getChildCount(); i++) {",
          "477:    if (i > 0) {",
          "478:     sb.append(\",\");",
          "479:    }",
          "480:    sb.append(getChild(i).toStringAST());",
          "481:   }",
          "482:   sb.append(\"]\");",
          "483:   return sb.toString();",
          "484:  }",
          "486:  private void setArrayElement(TypeConverter converter, Object ctx, int idx, Object newValue, Class<?> clazz)",
          "487:    throws EvaluationException {",
          "488:   Class<?> arrayComponentType = clazz;",
          "489:   if (arrayComponentType == Integer.TYPE) {",
          "490:    int[] array = (int[]) ctx;",
          "491:    checkAccess(array.length, idx);",
          "492:    array[idx] = (Integer) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "493:      TypeDescriptor.valueOf(Integer.class));",
          "494:   }",
          "495:   else if (arrayComponentType == Boolean.TYPE) {",
          "496:    boolean[] array = (boolean[]) ctx;",
          "497:    checkAccess(array.length, idx);",
          "498:    array[idx] = (Boolean) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "499:      TypeDescriptor.valueOf(Boolean.class));",
          "500:   }",
          "501:   else if (arrayComponentType == Character.TYPE) {",
          "502:    char[] array = (char[]) ctx;",
          "503:    checkAccess(array.length, idx);",
          "504:    array[idx] = (Character) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "505:      TypeDescriptor.valueOf(Character.class));",
          "506:   }",
          "507:   else if (arrayComponentType == Long.TYPE) {",
          "508:    long[] array = (long[]) ctx;",
          "509:    checkAccess(array.length, idx);",
          "510:    array[idx] = (Long) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "511:      TypeDescriptor.valueOf(Long.class));",
          "512:   }",
          "513:   else if (arrayComponentType == Short.TYPE) {",
          "514:    short[] array = (short[]) ctx;",
          "515:    checkAccess(array.length, idx);",
          "516:    array[idx] = (Short) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "517:      TypeDescriptor.valueOf(Short.class));",
          "518:   }",
          "519:   else if (arrayComponentType == Double.TYPE) {",
          "520:    double[] array = (double[]) ctx;",
          "521:    checkAccess(array.length, idx);",
          "522:    array[idx] = (Double) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "523:      TypeDescriptor.valueOf(Double.class));",
          "524:   }",
          "525:   else if (arrayComponentType == Float.TYPE) {",
          "526:    float[] array = (float[]) ctx;",
          "527:    checkAccess(array.length, idx);",
          "528:    array[idx] = (Float) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "529:      TypeDescriptor.valueOf(Float.class));",
          "530:   }",
          "531:   else if (arrayComponentType == Byte.TYPE) {",
          "532:    byte[] array = (byte[]) ctx;",
          "533:    checkAccess(array.length, idx);",
          "534:    array[idx] = (Byte) converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "535:      TypeDescriptor.valueOf(Byte.class));",
          "536:   }",
          "537:   else {",
          "538:    Object[] array = (Object[]) ctx;",
          "539:    checkAccess(array.length, idx);",
          "540:    array[idx] = converter.convertValue(newValue, TypeDescriptor.forObject(newValue),",
          "541:      TypeDescriptor.valueOf(clazz));",
          "542:   }",
          "543:  }",
          "545:  private Object accessArrayElement(Object ctx, int idx) throws SpelEvaluationException {",
          "546:   Class<?> arrayComponentType = ctx.getClass().getComponentType();",
          "547:   if (arrayComponentType == Integer.TYPE) {",
          "548:    int[] array = (int[]) ctx;",
          "549:    checkAccess(array.length, idx);",
          "550:    return array[idx];",
          "551:   }",
          "552:   else if (arrayComponentType == Boolean.TYPE) {",
          "553:    boolean[] array = (boolean[]) ctx;",
          "554:    checkAccess(array.length, idx);",
          "555:    return array[idx];",
          "556:   }",
          "557:   else if (arrayComponentType == Character.TYPE) {",
          "558:    char[] array = (char[]) ctx;",
          "559:    checkAccess(array.length, idx);",
          "560:    return array[idx];",
          "561:   }",
          "562:   else if (arrayComponentType == Long.TYPE) {",
          "563:    long[] array = (long[]) ctx;",
          "564:    checkAccess(array.length, idx);",
          "565:    return array[idx];",
          "566:   }",
          "567:   else if (arrayComponentType == Short.TYPE) {",
          "568:    short[] array = (short[]) ctx;",
          "569:    checkAccess(array.length, idx);",
          "570:    return array[idx];",
          "571:   }",
          "572:   else if (arrayComponentType == Double.TYPE) {",
          "573:    double[] array = (double[]) ctx;",
          "574:    checkAccess(array.length, idx);",
          "575:    return array[idx];",
          "576:   }",
          "577:   else if (arrayComponentType == Float.TYPE) {",
          "578:    float[] array = (float[]) ctx;",
          "579:    checkAccess(array.length, idx);",
          "580:    return array[idx];",
          "581:   }",
          "582:   else if (arrayComponentType == Byte.TYPE) {",
          "583:    byte[] array = (byte[]) ctx;",
          "584:    checkAccess(array.length, idx);",
          "585:    return array[idx];",
          "586:   }",
          "587:   else {",
          "588:    Object[] array = (Object[]) ctx;",
          "589:    checkAccess(array.length, idx);",
          "590:    return array[idx];",
          "591:   }",
          "592:  }",
          "594:  private void checkAccess(int arrayLength, int index) throws SpelEvaluationException {",
          "595:   if (index > arrayLength) {",
          "596:    throw new SpelEvaluationException(getStartPosition(), SpelMessage.ARRAY_INDEX_OUT_OF_BOUNDS,",
          "597:      arrayLength, index);",
          "598:   }",
          "599:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java||spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java": [
          "File: spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java -> spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:   return ExpressionUtils.convertTypedValue(state.getEvaluationContext(), getValueInternal(state), desiredReturnType);",
          "153:  }",
          "160:  @Override",
          "161:  public int getStartPosition() {",
          "163:  }",
          "165:  @Override",
          "166:  public int getEndPosition() {",
          "168:  }",
          "170:  protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {",
          "172:  }",
          "173: }",
          "",
          "[Removed Lines]",
          "155:  public abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;",
          "157:  @Override",
          "158:  public abstract String toStringAST();",
          "162:   return (this.pos>>16);",
          "167:   return (this.pos&0xffff);",
          "171:   throw new SpelEvaluationException(this.pos,SpelMessage.NOT_ASSIGNABLE,toStringAST());",
          "",
          "[Added Lines]",
          "158:   return (this.pos >> 16);",
          "163:   return (this.pos & 0xffff);",
          "167:   throw new SpelEvaluationException(this.pos, SpelMessage.NOT_ASSIGNABLE, toStringAST());",
          "171:  public abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;",
          "",
          "---------------"
        ],
        "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java||spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java": [
          "File: spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java -> spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:   Object bean = new TestBean(\"name1\", new TestBean(\"name2\", null, \"Description 2\", 15, props1), \"description 1\", 6, props1);",
          "83:   ExpressionParser parser = new SpelExpressionParser();",
          "87:  }",
          "",
          "[Removed Lines]",
          "84:   Expression exp = parser.parseExpression(\"testBean.properties['key2']\");",
          "85:   String key = (String) exp.getValue(bean);",
          "86:   assertNotNull(key);",
          "",
          "[Added Lines]",
          "84:   Expression expr = parser.parseExpression(\"testBean.properties['key2']\");",
          "85:   assertEquals(\"value2\", expr.getValue(bean));",
          "86:  }",
          "88:  @Test",
          "89:  public void testGetValueFromRootMap() {",
          "90:   Map<String, String> map = new HashMap<String, String>();",
          "91:   map.put(\"key\", \"value\");",
          "92:   EvaluationContext context = new StandardEvaluationContext(map);",
          "94:   ExpressionParser spelExpressionParser = new SpelExpressionParser();",
          "95:   Expression expr = spelExpressionParser.parseExpression(\"#root['key']\");",
          "96:   assertEquals(\"value\", expr.getValue(map));",
          "",
          "---------------"
        ],
        "spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java||spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java": [
          "File: spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java -> spring-messaging/src/main/java/org/springframework/messaging/simp/user/UserDestinationMessageHandler.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: import org.springframework.messaging.simp.SimpMessageType;",
          "32: import org.springframework.messaging.simp.SimpMessagingTemplate;",
          "33: import org.springframework.messaging.support.MessageBuilder;",
          "35: import org.springframework.util.Assert;",
          "",
          "[Removed Lines]",
          "34: import org.springframework.messaging.support.MessageHeaderAccessor;",
          "36: import org.springframework.util.CollectionUtils;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:  private final UserDestinationResolver userDestinationResolver;",
          "65:  private volatile boolean running = false;",
          "",
          "[Removed Lines]",
          "63:  private Object lifecycleMonitor = new Object();",
          "",
          "[Added Lines]",
          "61:  private final Object lifecycleMonitor = new Object();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:   this.userDestinationResolver = userDestinationResolver;",
          "86:  }",
          "",
          "[Removed Lines]",
          "91:  public UserDestinationResolver getUserDestinationResolver() {",
          "92:   return this.userDestinationResolver;",
          "93:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "100:   return this.brokerMessagingTemplate;",
          "101:  }",
          "106:  }",
          "108:  @Override",
          "109:  public int getPhase() {",
          "110:   return Integer.MAX_VALUE;",
          "111:  }",
          "113:  @Override",
          "114:  public final boolean isRunning() {",
          "115:   synchronized (this.lifecycleMonitor) {",
          "",
          "[Removed Lines]",
          "103:  @Override",
          "104:  public boolean isAutoStartup() {",
          "105:   return true;",
          "",
          "[Added Lines]",
          "98:  public UserDestinationResolver getUserDestinationResolver() {",
          "99:   return this.userDestinationResolver;",
          "108:  @Override",
          "109:  public boolean isAutoStartup() {",
          "110:   return true;",
          "111:  }",
          "",
          "---------------"
        ],
        "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java||spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java": [
          "File: spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java -> spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package org.springframework.transaction.interceptor;",
          "21: import java.io.Serializable;",
          "",
          "[Removed Lines]",
          "19: import org.springframework.util.Assert;",
          "",
          "[Added Lines]",
          "21: import org.springframework.util.Assert;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:  public RollbackRuleAttribute(Class<?> clazz) {",
          "64:   if (!Throwable.class.isAssignableFrom(clazz)) {",
          "65:    throw new IllegalArgumentException(",
          "66:      \"Cannot construct rollback rule from [\" + clazz.getName() + \"]: it's not a Throwable\");",
          "",
          "[Removed Lines]",
          "63:   Assert.notNull(clazz, \"'clazz' cannot be null.\");",
          "",
          "[Added Lines]",
          "63:   Assert.notNull(clazz, \"'clazz' cannot be null\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:  public RollbackRuleAttribute(String exceptionName) {",
          "91:   this.exceptionName = exceptionName;",
          "92:  }",
          "",
          "[Removed Lines]",
          "90:   Assert.hasText(exceptionName, \"'exceptionName' cannot be null or empty.\");",
          "",
          "[Added Lines]",
          "90:   Assert.hasText(exceptionName, \"'exceptionName' cannot be null or empty\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:  private int getDepth(Class<?> exceptionClass, int depth) {",
          "116:    return depth;",
          "117:   }",
          "",
          "[Removed Lines]",
          "114:   if (exceptionClass.getName().indexOf(this.exceptionName) != -1) {",
          "",
          "[Added Lines]",
          "114:   if (exceptionClass.getName().contains(this.exceptionName)) {",
          "",
          "---------------"
        ],
        "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java||spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java": [
          "File: spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java -> spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: import java.io.IOException;",
          "20: import java.io.InputStream;",
          "21: import java.io.Reader;",
          "23: import java.security.Principal;",
          "24: import java.time.ZoneId;",
          "25: import java.util.Locale;",
          "",
          "[Removed Lines]",
          "22: import java.lang.reflect.Method;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:   else if (HttpSession.class.isAssignableFrom(paramType)) {",
          "102:    return request.getSession();",
          "103:   }",
          "104:   else if (Principal.class.isAssignableFrom(paramType)) {",
          "105:    return request.getUserPrincipal();",
          "106:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103:   else if (HttpMethod.class.equals(paramType)) {",
          "104:    return ((ServletWebRequest) webRequest).getHttpMethod();",
          "105:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "120:   else if (Reader.class.isAssignableFrom(paramType)) {",
          "121:    return request.getReader();",
          "122:   }",
          "126:   else {",
          "130:   }",
          "131:  }",
          "",
          "[Removed Lines]",
          "123:   else if (HttpMethod.class.equals(paramType)) {",
          "124:    return ((ServletWebRequest) webRequest).getHttpMethod();",
          "125:   }",
          "128:    Method method = parameter.getMethod();",
          "129:    throw new UnsupportedOperationException(\"Unknown parameter type: \" + paramType + \" in method: \" + method);",
          "",
          "[Added Lines]",
          "127:    throw new UnsupportedOperationException(",
          "128:      \"Unknown parameter type: \" + paramType + \" in method: \" + parameter.getMethod());",
          "",
          "---------------"
        ],
        "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java": [
          "File: spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java -> spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "436:   }",
          "437:   else if (StringUtils.hasText(servletRelativeAction)) {",
          "438:    String pathToServlet = getRequestContext().getPathToServlet();",
          "440:     servletRelativeAction = pathToServlet + servletRelativeAction;",
          "441:    }",
          "442:    servletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));",
          "",
          "[Removed Lines]",
          "439:    if (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {",
          "",
          "[Added Lines]",
          "437:    if (servletRelativeAction.startsWith(\"/\") &&",
          "438:      !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "444:   }",
          "445:   else {",
          "446:    String requestUri = getRequestContext().getRequestUri();",
          "448:    try {",
          "449:     requestUri = UriUtils.encodePath(requestUri, encoding);",
          "450:    }",
          "453:    }",
          "454:    ServletResponse response = this.pageContext.getResponse();",
          "455:    if (response instanceof HttpServletResponse) {",
          "",
          "[Removed Lines]",
          "447:    String encoding = pageContext.getResponse().getCharacterEncoding();",
          "451:    catch (UnsupportedEncodingException e) {",
          "452:     throw new JspException(e);",
          "",
          "[Added Lines]",
          "446:    String encoding = this.pageContext.getResponse().getCharacterEncoding();",
          "450:    catch (UnsupportedEncodingException ex) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "476:  private String processAction(String action) {",
          "477:   RequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();",
          "478:   ServletRequest request = this.pageContext.getRequest();",
          "480:    action = processor.processAction((HttpServletRequest) request, action, getHttpMethod());",
          "481:   }",
          "482:   return action;",
          "",
          "[Removed Lines]",
          "479:   if ((processor != null) && (request instanceof HttpServletRequest)) {",
          "",
          "[Added Lines]",
          "478:   if (processor != null && request instanceof HttpServletRequest) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "75e08695a04980dbceae6789364717e9d8764d58",
      "candidate_info": {
        "commit_hash": "75e08695a04980dbceae6789364717e9d8764d58",
        "repo": "spring-projects/spring-framework",
        "commit_url": "https://github.com/spring-projects/spring-framework/commit/75e08695a04980dbceae6789364717e9d8764d58",
        "files": [
          "spring-context/src/main/java/org/springframework/cache/CacheManager.java",
          "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
        ],
        "message": "Mixed polishing along with recent changes (cherry picked from commit 14e5a02)",
        "before_after_code_files": [
          "spring-context/src/main/java/org/springframework/cache/CacheManager.java||spring-context/src/main/java/org/springframework/cache/CacheManager.java",
          "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java||spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java||spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java||spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
          ],
          "candidate": [
            "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java"
          ]
        }
      },
      "candidate_diff": {
        "spring-context/src/main/java/org/springframework/cache/CacheManager.java||spring-context/src/main/java/org/springframework/cache/CacheManager.java": [
          "File: spring-context/src/main/java/org/springframework/cache/CacheManager.java -> spring-context/src/main/java/org/springframework/cache/CacheManager.java"
        ],
        "spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java||spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java": [
          "File: spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java -> spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:   Object bean = new TestBean(\"name1\", new TestBean(\"name2\", null, \"Description 2\", 15, props1), \"description 1\", 6, props1);",
          "83:   ExpressionParser parser = new SpelExpressionParser();",
          "87:  }",
          "",
          "[Removed Lines]",
          "84:   Expression exp = parser.parseExpression(\"testBean.properties['key2']\");",
          "85:   String key = (String) exp.getValue(bean);",
          "86:   assertNotNull(key);",
          "",
          "[Added Lines]",
          "84:   Expression expr = parser.parseExpression(\"testBean.properties['key2']\");",
          "85:   assertEquals(\"value2\", expr.getValue(bean));",
          "86:  }",
          "88:  @Test",
          "89:  public void testGetValueFromRootMap() {",
          "90:   Map<String, String> map = new HashMap<String, String>();",
          "91:   map.put(\"key\", \"value\");",
          "92:   EvaluationContext context = new StandardEvaluationContext(map);",
          "94:   ExpressionParser spelExpressionParser = new SpelExpressionParser();",
          "95:   Expression expr = spelExpressionParser.parseExpression(\"#root['key']\");",
          "96:   assertEquals(\"value\", expr.getValue(map));",
          "",
          "---------------"
        ],
        "spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java||spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java": [
          "File: spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java -> spring-tx/src/main/java/org/springframework/transaction/interceptor/RollbackRuleAttribute.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package org.springframework.transaction.interceptor;",
          "21: import java.io.Serializable;",
          "",
          "[Removed Lines]",
          "19: import org.springframework.util.Assert;",
          "",
          "[Added Lines]",
          "21: import org.springframework.util.Assert;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   if (!Throwable.class.isAssignableFrom(clazz)) {",
          "65:    throw new IllegalArgumentException(",
          "66:      \"Cannot construct rollback rule from [\" + clazz.getName() + \"]: it's not a Throwable\");",
          "",
          "[Removed Lines]",
          "62:  public RollbackRuleAttribute(Class clazz) {",
          "63:   Assert.notNull(clazz, \"'clazz' cannot be null.\");",
          "",
          "[Added Lines]",
          "62:  public RollbackRuleAttribute(Class<?> clazz) {",
          "63:   Assert.notNull(clazz, \"'clazz' cannot be null\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:  public RollbackRuleAttribute(String exceptionName) {",
          "91:   this.exceptionName = exceptionName;",
          "92:  }",
          "",
          "[Removed Lines]",
          "90:   Assert.hasText(exceptionName, \"'exceptionName' cannot be null or empty.\");",
          "",
          "[Added Lines]",
          "90:   Assert.hasText(exceptionName, \"'exceptionName' cannot be null or empty\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "110:  }",
          "116:    return depth;",
          "117:   }",
          "",
          "[Removed Lines]",
          "113:  private int getDepth(Class exceptionClass, int depth) {",
          "114:   if (exceptionClass.getName().indexOf(this.exceptionName) != -1) {",
          "",
          "[Added Lines]",
          "113:  private int getDepth(Class<?> exceptionClass, int depth) {",
          "114:   if (exceptionClass.getName().contains(this.exceptionName)) {",
          "",
          "---------------"
        ],
        "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java||spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java": [
          "File: spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java -> spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: import java.io.IOException;",
          "20: import java.io.InputStream;",
          "21: import java.io.Reader;",
          "23: import java.security.Principal;",
          "24: import java.util.Locale;",
          "",
          "[Removed Lines]",
          "22: import java.lang.reflect.Method;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:    return request.getReader();",
          "103:   }",
          "104:   else {",
          "108:   }",
          "109:  }",
          "",
          "[Removed Lines]",
          "106:    Method method = parameter.getMethod();",
          "107:    throw new UnsupportedOperationException(\"Unknown parameter type: \" + paramType + \" in method: \" + method);",
          "",
          "[Added Lines]",
          "105:    throw new UnsupportedOperationException(",
          "106:      \"Unknown parameter type: \" + paramType + \" in method: \" + parameter.getMethod());",
          "",
          "---------------"
        ],
        "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java||spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java": [
          "File: spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java -> spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package org.springframework.web.servlet.tags.form;",
          "19: import java.util.Map;",
          "21: import javax.servlet.ServletRequest;",
          "22: import javax.servlet.ServletResponse;",
          "23: import javax.servlet.http.HttpServletRequest;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: import java.io.UnsupportedEncodingException;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: import org.springframework.util.StringUtils;",
          "33: import org.springframework.web.servlet.support.RequestDataValueProcessor;",
          "34: import org.springframework.web.util.HtmlUtils;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: import org.springframework.web.util.UriUtils;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "352:   tagWriter.startTag(FORM_TAG);",
          "353:   writeDefaultAttributes(tagWriter);",
          "354:   tagWriter.writeAttribute(ACTION_ATTRIBUTE, resolveAction());",
          "357:   writeOptionalAttribute(tagWriter, TARGET_ATTRIBUTE, getTarget());",
          "358:   writeOptionalAttribute(tagWriter, ENCTYPE_ATTRIBUTE, getEnctype());",
          "359:   writeOptionalAttribute(tagWriter, ACCEPT_CHARSET_ATTRIBUTE, getAcceptCharset());",
          "",
          "[Removed Lines]",
          "355:   writeOptionalAttribute(tagWriter, METHOD_ATTRIBUTE,",
          "356:     isMethodBrowserSupported(getMethod()) ? getMethod() : DEFAULT_METHOD);",
          "",
          "[Added Lines]",
          "356:   writeOptionalAttribute(tagWriter, METHOD_ATTRIBUTE, getHttpMethod());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "389:   return EVAL_BODY_INCLUDE;",
          "390:  }",
          "392:  private void assertHttpMethod(String method) {",
          "393:   for (HttpMethod httpMethod : HttpMethod.values()) {",
          "394:    if (httpMethod.name().equalsIgnoreCase(method)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392:  private String getHttpMethod() {",
          "393:   return (isMethodBrowserSupported(getMethod()) ? getMethod() : DEFAULT_METHOD);",
          "394:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "438:   }",
          "439:   else if (StringUtils.hasText(servletRelativeAction)) {",
          "440:    String pathToServlet = getRequestContext().getPathToServlet();",
          "442:     servletRelativeAction = pathToServlet + servletRelativeAction;",
          "443:    }",
          "444:    servletRelativeAction = getDisplayString(evaluate(ACTION_ATTRIBUTE, servletRelativeAction));",
          "",
          "[Removed Lines]",
          "441:    if (servletRelativeAction.startsWith(\"/\") && !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {",
          "",
          "[Added Lines]",
          "444:    if (servletRelativeAction.startsWith(\"/\") &&",
          "445:      !servletRelativeAction.startsWith(getRequestContext().getContextPath())) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "446:   }",
          "447:   else {",
          "448:    String requestUri = getRequestContext().getRequestUri();",
          "449:    ServletResponse response = this.pageContext.getResponse();",
          "450:    if (response instanceof HttpServletResponse) {",
          "451:     requestUri = ((HttpServletResponse) response).encodeURL(requestUri);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "453:    String encoding = this.pageContext.getResponse().getCharacterEncoding();",
          "454:    try {",
          "455:     requestUri = UriUtils.encodePath(requestUri, encoding);",
          "456:    }",
          "457:    catch (UnsupportedEncodingException ex) {",
          "459:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "471:  private String processAction(String action) {",
          "472:   RequestDataValueProcessor processor = getRequestContext().getRequestDataValueProcessor();",
          "473:   ServletRequest request = this.pageContext.getRequest();",
          "475:    action = processor.processAction((HttpServletRequest) request, action);",
          "476:   }",
          "477:   return action;",
          "",
          "[Removed Lines]",
          "474:   if ((processor != null) && (request instanceof HttpServletRequest)) {",
          "",
          "[Added Lines]",
          "485:   if (processor != null && request instanceof HttpServletRequest) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
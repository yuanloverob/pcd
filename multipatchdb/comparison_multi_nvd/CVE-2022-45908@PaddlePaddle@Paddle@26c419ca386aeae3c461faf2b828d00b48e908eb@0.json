{
  "cve_id": "CVE-2022-45908",
  "cve_desc": "In PaddlePaddle before 2.4, paddle.audio.functional.get_window is vulnerable to code injection because it calls eval on a user-supplied winstr. This may lead to arbitrary code execution.",
  "repo": "PaddlePaddle/Paddle",
  "patch_hash": "26c419ca386aeae3c461faf2b828d00b48e908eb",
  "patch_info": {
    "commit_hash": "26c419ca386aeae3c461faf2b828d00b48e908eb",
    "repo": "PaddlePaddle/Paddle",
    "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb",
    "files": [
      "python/paddle/audio/functional/window.py"
    ],
    "message": "[audio]fix audio get_window security error (#47386)\n\n* fix window security error\n\n* format",
    "before_after_code_files": [
      "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
    ]
  },
  "patch_diff": {
    "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
      "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: from paddle import Tensor",
      "22: def _cat(x: List[Tensor], data_type: str) -> Tensor:",
      "23:     l = [paddle.to_tensor(_, data_type) for _ in x]",
      "24:     return paddle.concat(l)",
      "27: def _acosh(x: Union[Tensor, float]) -> Tensor:",
      "28:     if isinstance(x, float):",
      "29:         return math.log(x + math.sqrt(x**2 - 1))",
      "30:     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
      "33: def _extend(M: int, sym: bool) -> bool:",
      "34:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
      "35:     if not sym:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "22: class WindowFunctionRegister(object):",
      "23:     def __init__(self):",
      "24:         self._functions_dict = dict()",
      "26:     def register(self, func=None):",
      "27:         def add_subfunction(func):",
      "28:             name = func.__name__",
      "29:             self._functions_dict[name] = func",
      "30:             return func",
      "32:         return add_subfunction",
      "34:     def get(self, name):",
      "35:         return self._functions_dict[name]",
      "38: window_function_register = WindowFunctionRegister()",
      "41: @window_function_register.register()",
      "47: @window_function_register.register()",
      "54: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:         return M, False",
      "41: def _len_guards(M: int) -> bool:",
      "42:     \"\"\"Handle small or incorrect window lengths.\"\"\"",
      "43:     if int(M) != M or M < 0:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "46:     return M <= 1",
      "49: def _truncate(w: Tensor, needed: bool) -> Tensor:",
      "50:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
      "51:     if needed:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "72: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "54:         return w",
      "57: def _general_gaussian(",
      "58:     M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
      "59: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "81: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "70:     return _truncate(w, needs_trunc)",
      "73: def _general_cosine(",
      "74:     M: int, a: float, sym: bool = True, dtype: str = 'float64'",
      "75: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "98: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "86:     return _truncate(w, needs_trunc)",
      "89: def _general_hamming(",
      "90:     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
      "91: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "95:     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
      "98: def _taylor(",
      "99:     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
      "100: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "125: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "151:     return _truncate(w, needs_trunc)",
      "154: def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "155:     \"\"\"Compute a Hamming window.",
      "156:     The Hamming window is a taper formed by using a raised cosine with",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "182: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "159:     return _general_hamming(M, 0.54, sym, dtype=dtype)",
      "162: def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "163:     \"\"\"Compute a Hann window.",
      "164:     The Hann window is a taper formed by using a raised cosine or sine-squared",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "191: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "167:     return _general_hamming(M, 0.5, sym, dtype=dtype)",
      "170: def _tukey(",
      "171:     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
      "172: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "200: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "200:     return _truncate(w, needs_trunc)",
      "203: def _kaiser(",
      "204:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
      "205: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "234: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "209:     raise NotImplementedError()",
      "212: def _gaussian(",
      "213:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
      "214: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "244: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "226:     return _truncate(w, needs_trunc)",
      "229: def _exponential(",
      "230:     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
      "231: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "262: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "245:     return _truncate(w, needs_trunc)",
      "248: def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "249:     \"\"\"Compute a triangular window.\"\"\"",
      "250:     if _len_guards(M):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "262:     return _truncate(w, needs_trunc)",
      "265: def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "266:     \"\"\"Compute a Bohman window.",
      "267:     The Bohman window is the autocorrelation of a cosine window.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "300: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "279:     return _truncate(w, needs_trunc)",
      "282: def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "283:     \"\"\"Compute a Blackman window.",
      "284:     The Blackman window is a taper formed by using the first three terms of",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "318: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "289:     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
      "292: def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "293:     \"\"\"Compute a window with a simple cosine shape.\"\"\"",
      "294:     if _len_guards(M):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "329: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "308:     \"\"\"Return a window of a given length and type.",
      "310:     Args:",
      "312:         win_length (int): Number of samples.",
      "313:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
      "314:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
      "",
      "[Removed Lines]",
      "311:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
      "",
      "[Added Lines]",
      "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "348:         )",
      "350:     try:",
      "353:         raise ValueError(\"Unknown window type.\") from e",
      "355:     params = (win_length,) + args",
      "",
      "[Removed Lines]",
      "351:         winfunc = eval('_' + winstr)",
      "352:     except NameError as e:",
      "",
      "[Added Lines]",
      "389:         winfunc = window_function_register.get('_' + winstr)",
      "390:     except KeyError as e:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
      "candidate_info": {
        "commit_hash": "d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
        "repo": "PaddlePaddle/Paddle",
        "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
        "files": [
          "python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py"
        ],
        "message": "[audio] rm kaiser window in audio get_window function && rm audio utils (#47469)\n\n* rm kaiser window in audio window function\n\n* rm paddle audio utils which is redundant\n\n* rm kaiser in test_audio_functions.py",
        "before_after_code_files": [
          "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ],
          "candidate": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ]
        }
      },
      "candidate_diff": {
        "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
          "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:     return _truncate(w, needs_trunc)",
          "244: @window_function_register.register()",
          "245: def _gaussian(",
          "246:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
          "",
          "[Removed Lines]",
          "234: @window_function_register.register()",
          "235: def _kaiser(",
          "236:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
          "237: ) -> Tensor:",
          "238:     \"\"\"Compute a Kaiser window.",
          "239:     The Kaiser window is a taper formed by using a Bessel function.",
          "240:     \"\"\"",
          "241:     raise NotImplementedError()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:     \"\"\"Return a window of a given length and type.",
          "348:     Args:",
          "350:         win_length (int): Number of samples.",
          "351:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
          "352:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
          "",
          "[Removed Lines]",
          "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "[Added Lines]",
          "339:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "363:             cosine_window = paddle.audio.functional.get_window('cosine', n_fft)",
          "365:             std = 7",
          "367:     \"\"\"",
          "368:     sym = not fftbins",
          "",
          "[Removed Lines]",
          "366:             gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
          "",
          "[Added Lines]",
          "356:             gaussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py": [
          "File: python/paddle/audio/utils/__init__.py -> python/paddle/audio/utils/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py": [
          "File: python/paddle/audio/utils/error.py -> python/paddle/audio/utils/error.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py": [
          "File: python/paddle/tests/test_audio_functions.py -> python/paddle/tests/test_audio_functions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:         np.testing.assert_array_almost_equal(",
          "179:             window_scipy_exp, window_paddle_exp.numpy(), decimal=5",
          "180:         )",
          "188:         try:",
          "189:             window_paddle = paddle.audio.functional.get_window(\"hann\", -1)",
          "190:         except ValueError:",
          "",
          "[Removed Lines]",
          "181:         try:",
          "182:             window_paddle = paddle.audio.functional.get_window(",
          "183:                 (\"kaiser\", 1.0), self.n_fft",
          "184:             )",
          "185:         except NotImplementedError:",
          "186:             pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26465cdbd609a6bce4f1f6333619f5d961be43bd",
      "candidate_info": {
        "commit_hash": "26465cdbd609a6bce4f1f6333619f5d961be43bd",
        "repo": "PaddlePaddle/Paddle",
        "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/26465cdbd609a6bce4f1f6333619f5d961be43bd",
        "files": [
          "python/paddle/audio/functional/window.py"
        ],
        "message": "fix paddle.audio.function.get_window security error (#47453)",
        "before_after_code_files": [
          "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ],
          "candidate": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ]
        }
      },
      "candidate_diff": {
        "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
          "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: from paddle import Tensor",
          "22: def _cat(x: List[Tensor], data_type: str) -> Tensor:",
          "23:     l = [paddle.to_tensor(_, data_type) for _ in x]",
          "24:     return paddle.concat(l)",
          "27: def _acosh(x: Union[Tensor, float]) -> Tensor:",
          "28:     if isinstance(x, float):",
          "29:         return math.log(x + math.sqrt(x**2 - 1))",
          "30:     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
          "33: def _extend(M: int, sym: bool) -> bool:",
          "35:     if not sym:",
          "36:         return M + 1, True",
          "37:     else:",
          "38:         return M, False",
          "41: def _len_guards(M: int) -> bool:",
          "43:     if int(M) != M or M < 0:",
          "44:         raise ValueError('Window length M must be a non-negative integer')",
          "46:     return M <= 1",
          "49: def _truncate(w: Tensor, needed: bool) -> Tensor:",
          "51:     if needed:",
          "52:         return w[:-1]",
          "53:     else:",
          "54:         return w",
          "62:     \"\"\"Compute a window with a generalized Gaussian shape.",
          "63:     This function is consistent with scipy.signal.windows.general_gaussian().",
          "64:     \"\"\"",
          "65:     if _len_guards(M):",
          "67:     M, needs_trunc = _extend(M, sym)",
          "69:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "72:     return _truncate(w, needs_trunc)",
          "79:     \"\"\"Compute a generic weighted sum of cosine terms window.",
          "80:     This function is consistent with scipy.signal.windows.general_cosine().",
          "81:     \"\"\"",
          "82:     if _len_guards(M):",
          "84:     M, needs_trunc = _extend(M, sym)",
          "85:     fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)",
          "87:     for k in range(len(a)):",
          "88:         w += a[k] * paddle.cos(k * fac)",
          "89:     return _truncate(w, needs_trunc)",
          "96:     \"\"\"Compute a generalized Hamming window.",
          "97:     This function is consistent with scipy.signal.windows.general_hamming()",
          "98:     \"\"\"",
          "108:     \"\"\"Compute a Taylor window.",
          "109:     The Taylor window taper function approximates the Dolph-Chebyshev window's",
          "110:     constant sidelobe level for a parameterized number of near-in sidelobes.",
          "111:     \"\"\"",
          "112:     if _len_guards(M):",
          "114:     M, needs_trunc = _extend(M, sym)",
          "115:     # Original text uses a negative sidelobe level parameter and then negates",
          "116:     # it in the calculation of B. To keep consistent with other methods we",
          "117:     # assume the sidelobe level parameter to be positive.",
          "119:     A = _acosh(B) / math.pi",
          "121:     ma = paddle.arange(1, nbar, dtype=dtype)",
          "124:     signs = paddle.empty_like(ma)",
          "125:     signs[::2] = 1",
          "126:     signs[1::2] = -1",
          "127:     m2 = ma * ma",
          "128:     for mi in range(len(ma)):",
          "131:         if mi == 0:",
          "133:         elif mi == len(ma) - 1:",
          "134:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])",
          "135:         else:",
          "139:         Fm[mi] = numer / denom",
          "141:     def W(n):",
          "142:         return 1 + 2 * paddle.matmul(",
          "143:             Fm.unsqueeze(0),",
          "146:     w = W(paddle.arange(0, M, dtype=dtype))",
          "",
          "[Removed Lines]",
          "34:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "42:     \"\"\"Handle small or incorrect window lengths. \"\"\"",
          "50:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "57: def _general_gaussian(M: int,",
          "58:                       p,",
          "59:                       sig,",
          "60:                       sym: bool = True,",
          "61:                       dtype: str = 'float64') -> Tensor:",
          "66:         return paddle.ones((M, ), dtype=dtype)",
          "70:     w = paddle.exp(-0.5 * paddle.abs(n / sig)**(2 * p))",
          "75: def _general_cosine(M: int,",
          "76:                     a: float,",
          "77:                     sym: bool = True,",
          "78:                     dtype: str = 'float64') -> Tensor:",
          "83:         return paddle.ones((M, ), dtype=dtype)",
          "86:     w = paddle.zeros((M, ), dtype=dtype)",
          "92: def _general_hamming(M: int,",
          "93:                      alpha: float,",
          "94:                      sym: bool = True,",
          "95:                      dtype: str = 'float64') -> Tensor:",
          "99:     return _general_cosine(M, [alpha, 1. - alpha], sym, dtype=dtype)",
          "102: def _taylor(M: int,",
          "103:             nbar=4,",
          "104:             sll=30,",
          "105:             norm=True,",
          "106:             sym: bool = True,",
          "107:             dtype: str = 'float64') -> Tensor:",
          "113:         return paddle.ones((M, ), dtype=dtype)",
          "118:     B = 10**(sll / 20)",
          "120:     s2 = nbar**2 / (A**2 + (nbar - 0.5)**2)",
          "123:     Fm = paddle.empty((nbar - 1, ), dtype=dtype)",
          "129:         numer = signs[mi] * paddle.prod(1 - m2[mi] / s2 / (A**2 +",
          "130:                                                            (ma - 0.5)**2))",
          "132:             denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1:])",
          "136:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi]) * paddle.prod(",
          "137:                 1 - m2[mi] / m2[mi + 1:])",
          "144:             paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2. + 0.5) / M))",
          "",
          "[Added Lines]",
          "22: class WindowFunctionRegister(object):",
          "23:     def __init__(self):",
          "24:         self._functions_dict = dict()",
          "26:     def register(self, func=None):",
          "27:         def add_subfunction(func):",
          "28:             name = func.__name__",
          "29:             self._functions_dict[name] = func",
          "30:             return func",
          "32:         return add_subfunction",
          "34:     def get(self, name):",
          "35:         return self._functions_dict[name]",
          "38: window_function_register = WindowFunctionRegister()",
          "41: @window_function_register.register()",
          "47: @window_function_register.register()",
          "54: @window_function_register.register()",
          "56:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
          "63: @window_function_register.register()",
          "65:     \"\"\"Handle small or incorrect window lengths.\"\"\"",
          "72: @window_function_register.register()",
          "74:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
          "81: @window_function_register.register()",
          "82: def _general_gaussian(",
          "83:     M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
          "84: ) -> Tensor:",
          "89:         return paddle.ones((M,), dtype=dtype)",
          "93:     w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))",
          "98: @window_function_register.register()",
          "99: def _general_cosine(",
          "100:     M: int, a: float, sym: bool = True, dtype: str = 'float64'",
          "101: ) -> Tensor:",
          "106:         return paddle.ones((M,), dtype=dtype)",
          "109:     w = paddle.zeros((M,), dtype=dtype)",
          "115: @window_function_register.register()",
          "116: def _general_hamming(",
          "117:     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
          "118: ) -> Tensor:",
          "122:     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
          "125: @window_function_register.register()",
          "126: def _taylor(",
          "127:     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
          "128: ) -> Tensor:",
          "134:         return paddle.ones((M,), dtype=dtype)",
          "139:     B = 10 ** (sll / 20)",
          "141:     s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)",
          "144:     Fm = paddle.empty((nbar - 1,), dtype=dtype)",
          "150:         numer = signs[mi] * paddle.prod(",
          "151:             1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)",
          "152:         )",
          "154:             denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
          "158:             denom = (",
          "159:                 2",
          "162:             )",
          "169:             paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),",
          "170:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:     return _truncate(w, needs_trunc)",
          "156: def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "157:     \"\"\"Compute a Hamming window.",
          "158:     The Hamming window is a taper formed by using a raised cosine with",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:     return _general_hamming(M, 0.54, sym, dtype=dtype)",
          "164: def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "165:     \"\"\"Compute a Hann window.",
          "166:     The Hann window is a taper formed by using a raised cosine or sine-squared",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:     return _general_hamming(M, 0.5, sym, dtype=dtype)",
          "176:     \"\"\"Compute a Tukey window.",
          "177:     The Tukey window is also known as a tapered cosine window.",
          "178:     \"\"\"",
          "179:     if _len_guards(M):",
          "182:     if alpha <= 0:",
          "184:     elif alpha >= 1.0:",
          "185:         return hann(M, sym=sym)",
          "",
          "[Removed Lines]",
          "172: def _tukey(M: int,",
          "173:            alpha=0.5,",
          "174:            sym: bool = True,",
          "175:            dtype: str = 'float64') -> Tensor:",
          "180:         return paddle.ones((M, ), dtype=dtype)",
          "183:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "200: @window_function_register.register()",
          "201: def _tukey(",
          "202:     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
          "203: ) -> Tensor:",
          "208:         return paddle.ones((M,), dtype=dtype)",
          "211:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "189:     n = paddle.arange(0, M, dtype=dtype)",
          "190:     width = int(alpha * (M - 1) / 2.0)",
          "195:     w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))",
          "196:     w2 = paddle.ones(n2.shape, dtype=dtype)",
          "199:     w = paddle.concat([w1, w2, w3])",
          "201:     return _truncate(w, needs_trunc)",
          "208:     \"\"\"Compute a Kaiser window.",
          "209:     The Kaiser window is a taper formed by using a Bessel function.",
          "210:     \"\"\"",
          "211:     raise NotImplementedError()",
          "218:     \"\"\"Compute a Gaussian window.",
          "219:     The Gaussian widows has a Gaussian shape defined by the standard deviation(std).",
          "220:     \"\"\"",
          "221:     if _len_guards(M):",
          "223:     M, needs_trunc = _extend(M, sym)",
          "225:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "226:     sig2 = 2 * std * std",
          "229:     return _truncate(w, needs_trunc)",
          "238:     if sym and center is not None:",
          "239:         raise ValueError(\"If sym==True, center must be None.\")",
          "240:     if _len_guards(M):",
          "242:     M, needs_trunc = _extend(M, sym)",
          "244:     if center is None:",
          "",
          "[Removed Lines]",
          "191:     n1 = n[0:width + 1]",
          "192:     n2 = n[width + 1:M - width - 1]",
          "193:     n3 = n[M - width - 1:]",
          "197:     w3 = 0.5 * (1 + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha /",
          "198:                                           (M - 1))))",
          "204: def _kaiser(M: int,",
          "205:             beta: float,",
          "206:             sym: bool = True,",
          "207:             dtype: str = 'float64') -> Tensor:",
          "214: def _gaussian(M: int,",
          "215:               std: float,",
          "216:               sym: bool = True,",
          "217:               dtype: str = 'float64') -> Tensor:",
          "222:         return paddle.ones((M, ), dtype=dtype)",
          "227:     w = paddle.exp(-n**2 / sig2)",
          "232: def _exponential(M: int,",
          "233:                  center=None,",
          "234:                  tau=1.,",
          "235:                  sym: bool = True,",
          "236:                  dtype: str = 'float64') -> Tensor:",
          "237:     \"\"\"Compute an exponential (or Poisson) window. \"\"\"",
          "241:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "219:     n1 = n[0 : width + 1]",
          "220:     n2 = n[width + 1 : M - width - 1]",
          "221:     n3 = n[M - width - 1 :]",
          "225:     w3 = 0.5 * (",
          "226:         1",
          "227:         + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))",
          "228:     )",
          "234: @window_function_register.register()",
          "235: def _kaiser(",
          "236:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
          "237: ) -> Tensor:",
          "244: @window_function_register.register()",
          "245: def _gaussian(",
          "246:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
          "247: ) -> Tensor:",
          "252:         return paddle.ones((M,), dtype=dtype)",
          "257:     w = paddle.exp(-(n**2) / sig2)",
          "262: @window_function_register.register()",
          "263: def _exponential(",
          "264:     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
          "265: ) -> Tensor:",
          "266:     \"\"\"Compute an exponential (or Poisson) window.\"\"\"",
          "270:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "250:     return _truncate(w, needs_trunc)",
          "253: def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "256:     if _len_guards(M):",
          "258:     M, needs_trunc = _extend(M, sym)",
          "260:     n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)",
          "",
          "[Removed Lines]",
          "254:     \"\"\"Compute a triangular window.",
          "255:     \"\"\"",
          "257:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "282: @window_function_register.register()",
          "284:     \"\"\"Compute a triangular window.\"\"\"",
          "286:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "268:     return _truncate(w, needs_trunc)",
          "271: def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "272:     \"\"\"Compute a Bohman window.",
          "273:     The Bohman window is the autocorrelation of a cosine window.",
          "274:     \"\"\"",
          "275:     if _len_guards(M):",
          "277:     M, needs_trunc = _extend(M, sym)",
          "279:     fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])",
          "280:     w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(",
          "282:     w = _cat([0, w, 0], dtype)",
          "284:     return _truncate(w, needs_trunc)",
          "287: def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "288:     \"\"\"Compute a Blackman window.",
          "289:     The Blackman window is a taper formed by using the first three terms of",
          "",
          "[Removed Lines]",
          "276:         return paddle.ones((M, ), dtype=dtype)",
          "281:         math.pi * fac)",
          "",
          "[Added Lines]",
          "300: @window_function_register.register()",
          "306:         return paddle.ones((M,), dtype=dtype)",
          "311:         math.pi * fac",
          "312:     )",
          "318: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "294:     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
          "297: def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "300:     if _len_guards(M):",
          "302:     M, needs_trunc = _extend(M, sym)",
          "305:     return _truncate(w, needs_trunc)",
          "312:     \"\"\"Return a window of a given length and type.",
          "314:     Args:",
          "316:         win_length (int): Number of samples.",
          "317:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
          "318:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
          "",
          "[Removed Lines]",
          "298:     \"\"\"Compute a window with a simple cosine shape.",
          "299:     \"\"\"",
          "301:         return paddle.ones((M, ), dtype=dtype)",
          "303:     w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + .5))",
          "308: def get_window(window: Union[str, Tuple[str, float]],",
          "309:                win_length: int,",
          "310:                fftbins: bool = True,",
          "311:                dtype: str = 'float64') -> Tensor:",
          "315:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "[Added Lines]",
          "329: @window_function_register.register()",
          "331:     \"\"\"Compute a window with a simple cosine shape.\"\"\"",
          "333:         return paddle.ones((M,), dtype=dtype)",
          "335:     w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))",
          "340: def get_window(",
          "341:     window: Union[str, Tuple[str, float]],",
          "342:     win_length: int,",
          "343:     fftbins: bool = True,",
          "344:     dtype: str = 'float64',",
          "345: ) -> Tensor:",
          "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "340:             args = window[1:]",
          "341:     elif isinstance(window, str):",
          "342:         if window in ['gaussian', 'exponential']:",
          "345:         else:",
          "346:             winstr = window",
          "347:     else:",
          "351:     try:",
          "354:         raise ValueError(\"Unknown window type.\") from e",
          "357:     kwargs = {'sym': sym}",
          "358:     return winfunc(*params, dtype=dtype, **kwargs)",
          "",
          "[Removed Lines]",
          "343:             raise ValueError(\"The '\" + window + \"' window needs one or \"",
          "344:                              \"more parameters -- pass a tuple.\")",
          "348:         raise ValueError(\"%s as window type is not supported.\" %",
          "349:                          str(type(window)))",
          "352:         winfunc = eval('_' + winstr)",
          "353:     except NameError as e:",
          "356:     params = (win_length, ) + args",
          "",
          "[Added Lines]",
          "377:             raise ValueError(",
          "378:                 \"The '\" + window + \"' window needs one or \"",
          "379:                 \"more parameters -- pass a tuple.\"",
          "380:             )",
          "384:         raise ValueError(",
          "385:             \"%s as window type is not supported.\" % str(type(window))",
          "386:         )",
          "389:         winfunc = window_function_register.get('_' + winstr)",
          "390:     except KeyError as e:",
          "393:     params = (win_length,) + args",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-7750",
  "cve_desc": "transport.py in the SSH server implementation of Paramiko before 1.17.6, 1.18.x before 1.18.5, 2.0.x before 2.0.8, 2.1.x before 2.1.5, 2.2.x before 2.2.3, 2.3.x before 2.3.2, and 2.4.x before 2.4.1 does not properly check whether authentication is completed before processing other requests, as demonstrated by channel-open. A customized SSH client can simply skip the authentication step.",
  "repo": "paramiko/paramiko",
  "patch_hash": "fa29bd8446c8eab237f5187d28787727b4610516",
  "patch_info": {
    "commit_hash": "fa29bd8446c8eab237f5187d28787727b4610516",
    "repo": "paramiko/paramiko",
    "commit_url": "https://github.com/paramiko/paramiko/commit/fa29bd8446c8eab237f5187d28787727b4610516",
    "files": [
      "paramiko/common.py",
      "paramiko/transport.py"
    ],
    "message": "Fixes CVE-2018-7750 / #1175\n\nAt least, insofar as the new tests pass...!",
    "before_after_code_files": [
      "paramiko/common.py||paramiko/common.py",
      "paramiko/transport.py||paramiko/transport.py"
    ]
  },
  "patch_diff": {
    "paramiko/common.py||paramiko/common.py": [
      "File: paramiko/common.py -> paramiko/common.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: MSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN = range(60, 62)",
      "33: MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, MSG_USERAUTH_GSSAPI_ERROR,\\",
      "34:     MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC = range(63, 67)",
      "35: MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE = range(80, 83)",
      "36: MSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE, \\",
      "37:     MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA, \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "35: HIGHEST_USERAUTH_MESSAGE_ID = 79",
      "",
      "---------------"
    ],
    "paramiko/transport.py||paramiko/transport.py": [
      "File: paramiko/transport.py -> paramiko/transport.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "49:     MSG_CHANNEL_FAILURE, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA,",
      "50:     MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_REQUEST, MSG_CHANNEL_EOF,",
      "51:     MSG_CHANNEL_CLOSE, MIN_WINDOW_SIZE, MIN_PACKET_SIZE, MAX_WINDOW_SIZE,",
      "53: )",
      "54: from paramiko.compress import ZlibCompressor, ZlibDecompressor",
      "55: from paramiko.dsskey import DSSKey",
      "",
      "[Removed Lines]",
      "52:     DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE,",
      "",
      "[Added Lines]",
      "52:     DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE, HIGHEST_USERAUTH_MESSAGE_ID,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1760:             max_packet_size = self.default_max_packet_size",
      "1761:         return clamp_value(MIN_PACKET_SIZE, max_packet_size, MAX_WINDOW_SIZE)",
      "1764:     def run(self):",
      "1765:         # (use the exposed \"run\" method, because if we specify a thread target",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1763:     def _ensure_authed(self, ptype, message):",
      "1764:         \"\"\"",
      "1765:         Checks message type against current auth state.",
      "1767:         If server mode, and auth has not succeeded, and the message is of a",
      "1768:         post-auth type (channel open or global request) an appropriate error",
      "1769:         response Message is crafted and returned to caller for sending.",
      "1771:         Otherwise (client mode, authed, or pre-auth message) returns None.",
      "1772:         \"\"\"",
      "1773:         if (",
      "1774:             not self.server_mode",
      "1775:             or ptype <= HIGHEST_USERAUTH_MESSAGE_ID",
      "1776:             or self.is_authenticated()",
      "1777:         ):",
      "1778:             return None",
      "1779:         # WELP. We must be dealing with someone trying to do non-auth things",
      "1780:         # without being authed. Tell them off, based on message class.",
      "1781:         reply = Message()",
      "1782:         # Global requests have no details, just failure.",
      "1783:         if ptype == MSG_GLOBAL_REQUEST:",
      "1784:             reply.add_byte(cMSG_REQUEST_FAILURE)",
      "1785:         # Channel opens let us reject w/ a specific type + message.",
      "1786:         elif ptype == MSG_CHANNEL_OPEN:",
      "1787:             kind = message.get_text()",
      "1788:             chanid = message.get_int()",
      "1789:             reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)",
      "1790:             reply.add_int(chanid)",
      "1791:             reply.add_int(OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED)",
      "1792:             reply.add_string('')",
      "1793:             reply.add_string('en')",
      "1794:         # NOTE: Post-open channel messages do not need checking; the above will",
      "1795:         # reject attemps to open channels, meaning that even if a malicious",
      "1796:         # user tries to send a MSG_CHANNEL_REQUEST, it will simply fall under",
      "1797:         # the logic that handles unknown channel IDs (as the channel list will",
      "1798:         # be empty.)",
      "1799:         return reply",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1820:                             continue",
      "1822:                     if ptype in self._handler_table:",
      "1824:                     elif ptype in self._channel_handler_table:",
      "1825:                         chanid = m.get_int()",
      "1826:                         chan = self._channels.get(chanid)",
      "",
      "[Removed Lines]",
      "1823:                         self._handler_table[ptype](self, m)",
      "",
      "[Added Lines]",
      "1860:                         error_msg = self._ensure_authed(ptype, m)",
      "1861:                         if error_msg:",
      "1862:                             self._send_message(error_msg)",
      "1863:                         else:",
      "1864:                             self._handler_table[ptype](self, m)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "07dbaa585ab22c12658832f17529eef69223081e",
      "candidate_info": {
        "commit_hash": "07dbaa585ab22c12658832f17529eef69223081e",
        "repo": "paramiko/paramiko",
        "commit_url": "https://github.com/paramiko/paramiko/commit/07dbaa585ab22c12658832f17529eef69223081e",
        "files": [
          "tests/test_transport.py"
        ],
        "message": "Initial tests proving CVE-2018-7750 / #1175",
        "before_after_code_files": [
          "tests/test_transport.py||tests/test_transport.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/test_transport.py||tests/test_transport.py": [
          "File: tests/test_transport.py -> tests/test_transport.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: from paramiko import (",
          "35:     Transport, SecurityOptions, ServerInterface, RSAKey, DSSKey, SSHException,",
          "37: )",
          "38: from paramiko import AUTH_FAILED, AUTH_SUCCESSFUL",
          "39: from paramiko import OPEN_SUCCEEDED, OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED",
          "",
          "[Removed Lines]",
          "36:     ChannelException, Packetizer,",
          "",
          "[Added Lines]",
          "36:     ChannelException, Packetizer, Channel,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:     def check_global_request(self, kind, msg):",
          "93:         self._global_request = kind",
          "96:     def check_channel_x11_request(self, channel, single_connection, auth_protocol, auth_cookie, screen_number):",
          "97:         self._x11_single_connection = single_connection",
          "",
          "[Removed Lines]",
          "94:         return False",
          "",
          "[Added Lines]",
          "94:         # NOTE: for w/e reason, older impl of this returned False always, even",
          "95:         # tho that's only supposed to occur if the request cannot be served.",
          "96:         # For now, leaving that the default unless test supplies specific",
          "97:         # 'acceptable' request kind",
          "98:         return kind == 'acceptable'",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "934:             # sendall() accepts a memoryview instance",
          "935:             chan.sendall(memoryview(data))",
          "936:             self.assertEqual(sfile.read(len(data)), data)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "942:     def test_server_rejects_open_channel_without_auth(self):",
          "943:         try:",
          "944:             self.setup_test_server(connect_kwargs={})",
          "945:             self.tc.open_session()",
          "946:         except ChannelException as e:",
          "947:             assert e.code == OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED",
          "948:         else:",
          "949:             assert False, \"Did not raise ChannelException!\"",
          "951:     def test_server_rejects_arbitrary_global_request_without_auth(self):",
          "952:         self.setup_test_server(connect_kwargs={})",
          "953:         # NOTE: this dummy global request kind would normally pass muster",
          "954:         # from the test server.",
          "955:         self.tc.global_request('acceptable')",
          "956:         # Global requests never raise exceptions, even on failure (not sure why",
          "957:         # this was the original design...ugh.) Best we can do to tell failure",
          "958:         # happened is that the client transport's global_response was set back",
          "959:         # to None; if it had succeeded, it would be the response Message.",
          "960:         err = \"Unauthed global response incorrectly succeeded!\"",
          "961:         assert self.tc.global_response is None, err",
          "963:     def test_server_rejects_port_forward_without_auth(self):",
          "964:         # NOTE: at protocol level port forward requests are treated same as a",
          "965:         # regular global request, but Paramiko server implements a special-case",
          "966:         # method for it, so it gets its own test. (plus, THAT actually raises",
          "967:         # an exception on the client side, unlike the general case...)",
          "968:         self.setup_test_server(connect_kwargs={})",
          "969:         try:",
          "970:             self.tc.request_port_forward('localhost', 1234)",
          "971:         except SSHException as e:",
          "972:             assert \"forwarding request denied\" in str(e)",
          "973:         else:",
          "974:             assert False, \"Did not raise SSHException!\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e6791c17a5e9ea00f292c2e2eb43488e9303efe1",
      "candidate_info": {
        "commit_hash": "e6791c17a5e9ea00f292c2e2eb43488e9303efe1",
        "repo": "paramiko/paramiko",
        "commit_url": "https://github.com/paramiko/paramiko/commit/e6791c17a5e9ea00f292c2e2eb43488e9303efe1",
        "files": [
          "paramiko/transport.py"
        ],
        "message": "flake8",
        "before_after_code_files": [
          "paramiko/transport.py||paramiko/transport.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "paramiko/transport.py||paramiko/transport.py"
          ],
          "candidate": [
            "paramiko/transport.py||paramiko/transport.py"
          ]
        }
      },
      "candidate_diff": {
        "paramiko/transport.py||paramiko/transport.py": [
          "File: paramiko/transport.py -> paramiko/transport.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1771:         Otherwise (client mode, authed, or pre-auth message) returns None.",
          "1772:         \"\"\"",
          "1773:         if (",
          "1777:         ):",
          "1778:             return None",
          "1779:         # WELP. We must be dealing with someone trying to do non-auth things",
          "",
          "[Removed Lines]",
          "1774:             not self.server_mode",
          "1775:             or ptype <= HIGHEST_USERAUTH_MESSAGE_ID",
          "1776:             or self.is_authenticated()",
          "",
          "[Added Lines]",
          "1774:             not self.server_mode or",
          "1775:             ptype <= HIGHEST_USERAUTH_MESSAGE_ID or",
          "1776:             self.is_authenticated()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1784:             reply.add_byte(cMSG_REQUEST_FAILURE)",
          "1785:         # Channel opens let us reject w/ a specific type + message.",
          "1786:         elif ptype == MSG_CHANNEL_OPEN:",
          "1788:             chanid = message.get_int()",
          "1789:             reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)",
          "1790:             reply.add_int(chanid)",
          "",
          "[Removed Lines]",
          "1787:             kind = message.get_text()",
          "",
          "[Added Lines]",
          "1787:             kind = message.get_text() # noqa",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e9dfd854bdaf8af15d7834f7502a0451d217bb8c",
      "candidate_info": {
        "commit_hash": "e9dfd854bdaf8af15d7834f7502a0451d217bb8c",
        "repo": "paramiko/paramiko",
        "commit_url": "https://github.com/paramiko/paramiko/commit/e9dfd854bdaf8af15d7834f7502a0451d217bb8c",
        "files": [
          "paramiko/common.py",
          "paramiko/transport.py"
        ],
        "message": "Fixes CVE-2018-7750 / #1175\n\nAt least, insofar as the new tests pass...!",
        "before_after_code_files": [
          "paramiko/common.py||paramiko/common.py",
          "paramiko/transport.py||paramiko/transport.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "paramiko/common.py||paramiko/common.py",
            "paramiko/transport.py||paramiko/transport.py"
          ],
          "candidate": [
            "paramiko/common.py||paramiko/common.py",
            "paramiko/transport.py||paramiko/transport.py"
          ]
        }
      },
      "candidate_diff": {
        "paramiko/common.py||paramiko/common.py": [
          "File: paramiko/common.py -> paramiko/common.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: MSG_USERAUTH_GSSAPI_RESPONSE, MSG_USERAUTH_GSSAPI_TOKEN = range(60, 62)",
          "33: MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, MSG_USERAUTH_GSSAPI_ERROR,\\",
          "34: MSG_USERAUTH_GSSAPI_ERRTOK, MSG_USERAUTH_GSSAPI_MIC = range(63, 67)",
          "35: MSG_GLOBAL_REQUEST, MSG_REQUEST_SUCCESS, MSG_REQUEST_FAILURE = range(80, 83)",
          "36: MSG_CHANNEL_OPEN, MSG_CHANNEL_OPEN_SUCCESS, MSG_CHANNEL_OPEN_FAILURE, \\",
          "37:     MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_DATA, MSG_CHANNEL_EXTENDED_DATA, \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: HIGHEST_USERAUTH_MESSAGE_ID = 79",
          "",
          "---------------"
        ],
        "paramiko/transport.py||paramiko/transport.py": [
          "File: paramiko/transport.py -> paramiko/transport.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:     MSG_CHANNEL_SUCCESS, MSG_CHANNEL_FAILURE, MSG_CHANNEL_DATA, \\",
          "46:     MSG_CHANNEL_EXTENDED_DATA, MSG_CHANNEL_WINDOW_ADJUST, MSG_CHANNEL_REQUEST, \\",
          "47:     MSG_CHANNEL_EOF, MSG_CHANNEL_CLOSE, MIN_WINDOW_SIZE, MIN_PACKET_SIZE, \\",
          "49: from paramiko.compress import ZlibCompressor, ZlibDecompressor",
          "50: from paramiko.dsskey import DSSKey",
          "51: from paramiko.kex_gex import KexGex, KexGexSHA256",
          "",
          "[Removed Lines]",
          "48:     MAX_WINDOW_SIZE, DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE",
          "",
          "[Added Lines]",
          "48:     MAX_WINDOW_SIZE, DEFAULT_WINDOW_SIZE, DEFAULT_MAX_PACKET_SIZE, \\",
          "49:     HIGHEST_USERAUTH_MESSAGE_ID",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1702:             max_packet_size = self.default_max_packet_size",
          "1703:         return clamp_value(MIN_PACKET_SIZE, max_packet_size, MAX_WINDOW_SIZE)",
          "1706:     def run(self):",
          "1707:         # (use the exposed \"run\" method, because if we specify a thread target",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1706:     def _ensure_authed(self, ptype, message):",
          "1707:         \"\"\"",
          "1708:         Checks message type against current auth state.",
          "1710:         If server mode, and auth has not succeeded, and the message is of a",
          "1711:         post-auth type (channel open or global request) an appropriate error",
          "1712:         response Message is crafted and returned to caller for sending.",
          "1714:         Otherwise (client mode, authed, or pre-auth message) returns None.",
          "1715:         \"\"\"",
          "1716:         if (",
          "1717:             not self.server_mode",
          "1718:             or ptype <= HIGHEST_USERAUTH_MESSAGE_ID",
          "1719:             or self.is_authenticated()",
          "1720:         ):",
          "1721:             return None",
          "1722:         # WELP. We must be dealing with someone trying to do non-auth things",
          "1723:         # without being authed. Tell them off, based on message class.",
          "1724:         reply = Message()",
          "1725:         # Global requests have no details, just failure.",
          "1726:         if ptype == MSG_GLOBAL_REQUEST:",
          "1727:             reply.add_byte(cMSG_REQUEST_FAILURE)",
          "1728:         # Channel opens let us reject w/ a specific type + message.",
          "1729:         elif ptype == MSG_CHANNEL_OPEN:",
          "1730:             kind = message.get_text()",
          "1731:             chanid = message.get_int()",
          "1732:             reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)",
          "1733:             reply.add_int(chanid)",
          "1734:             reply.add_int(OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED)",
          "1735:             reply.add_string('')",
          "1736:             reply.add_string('en')",
          "1737:         # NOTE: Post-open channel messages do not need checking; the above will",
          "1738:         # reject attemps to open channels, meaning that even if a malicious",
          "1739:         # user tries to send a MSG_CHANNEL_REQUEST, it will simply fall under",
          "1740:         # the logic that handles unknown channel IDs (as the channel list will",
          "1741:         # be empty.)",
          "1742:         return reply",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1761:                             continue",
          "1763:                     if ptype in self._handler_table:",
          "1765:                     elif ptype in self._channel_handler_table:",
          "1766:                         chanid = m.get_int()",
          "1767:                         chan = self._channels.get(chanid)",
          "",
          "[Removed Lines]",
          "1764:                         self._handler_table[ptype](self, m)",
          "",
          "[Added Lines]",
          "1802:                         error_msg = self._ensure_authed(ptype, m)",
          "1803:                         if error_msg:",
          "1804:                             self._send_message(error_msg)",
          "1805:                         else:",
          "1806:                             self._handler_table[ptype](self, m)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
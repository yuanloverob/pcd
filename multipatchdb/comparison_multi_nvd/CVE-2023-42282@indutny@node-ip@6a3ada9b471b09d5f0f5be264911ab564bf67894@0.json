{
  "cve_id": "CVE-2023-42282",
  "cve_desc": "The ip package before 1.1.9 for Node.js might allow SSRF because some IP addresses (such as 0x7f.1) are improperly categorized as globally routable via isPublic.",
  "repo": "indutny/node-ip",
  "patch_hash": "6a3ada9b471b09d5f0f5be264911ab564bf67894",
  "patch_info": {
    "commit_hash": "6a3ada9b471b09d5f0f5be264911ab564bf67894",
    "repo": "indutny/node-ip",
    "commit_url": "https://github.com/indutny/node-ip/commit/6a3ada9b471b09d5f0f5be264911ab564bf67894",
    "files": [
      "lib/ip.js",
      "test/api-test.js"
    ],
    "message": "lib: fixed CVE-2023-42282 and added unit test",
    "before_after_code_files": [
      "lib/ip.js||lib/ip.js",
      "test/api-test.js||test/api-test.js"
    ]
  },
  "patch_diff": {
    "lib/ip.js||lib/ip.js": [
      "File: lib/ip.js -> lib/ip.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "311: };",
      "313: ip.isPrivate = function (addr) {",
      "316:     || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
      "317:     || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i",
      "318:       .test(addr)",
      "320:     || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
      "321:     || /^f[cd][0-9a-f]{2}:/i.test(addr)",
      "322:     || /^fe80:/i.test(addr)",
      "",
      "[Removed Lines]",
      "314:   return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i",
      "315:     .test(addr)",
      "319:     || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
      "",
      "[Added Lines]",
      "315:   if (ip.isLoopback(addr)) {",
      "316:     return true;",
      "317:   }",
      "320:   if (!ip.isV6Format(addr)) {",
      "321:     const ipl = ip.normalizeToLong(addr);",
      "322:     if (ipl < 0) {",
      "323:       throw new Error('invalid ipv4 address');",
      "324:     }",
      "326:     addr = ip.fromLong(ipl);",
      "327:   }",
      "330:   return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "329: };",
      "331: ip.isLoopback = function (addr) {",
      "332:   return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/",
      "333:     .test(addr)",
      "335:     || /^::1$/.test(addr)",
      "336:     || /^::$/.test(addr);",
      "337: };",
      "",
      "[Removed Lines]",
      "334:     || /^fe80::1$/.test(addr)",
      "",
      "[Added Lines]",
      "347:   if (!/\\./.test(addr) && !/:/.test(addr)) {",
      "348:     addr = ip.fromLong(Number(addr));",
      "349:   }",
      "353:     || /^0177\\./.test(addr)",
      "354:     || /^0x7f\\./i.test(addr)",
      "355:     || /^fe80::1$/i.test(addr)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "425:     ipl >> 8 & 255}.${",
      "426:     ipl & 255}`);",
      "427: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "450: ip.normalizeToLong = function (addr) {",
      "451:   const parts = addr.split('.').map(part => {",
      "453:     if (part.startsWith('0x') || part.startsWith('0X')) {",
      "454:       return parseInt(part, 16);",
      "455:     }",
      "457:     else if (part.startsWith('0') && part !== '0' && /^[0-7]+$/.test(part)) {",
      "458:       return parseInt(part, 8);",
      "459:     }",
      "461:     else if (/^[1-9]\\d*$/.test(part) || part === '0') {",
      "462:       return parseInt(part, 10);",
      "463:     }",
      "465:     else {",
      "466:       return NaN;",
      "467:     }",
      "468:   });",
      "470:   if (parts.some(isNaN)) return -1; // Indicate error with -1",
      "472:   let val = 0;",
      "473:   const n = parts.length;",
      "475:   switch (n) {",
      "476:   case 1:",
      "477:     val = parts[0];",
      "478:     break;",
      "479:   case 2:",
      "480:     if (parts[0] > 0xff || parts[1] > 0xffffff) return -1;",
      "481:     val = (parts[0] << 24) | (parts[1] & 0xffffff);",
      "482:     break;",
      "483:   case 3:",
      "484:     if (parts[0] > 0xff || parts[1] > 0xff || parts[2] > 0xffff) return -1;",
      "485:     val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] & 0xffff);",
      "486:     break;",
      "487:   case 4:",
      "488:     if (parts.some(part => part > 0xff)) return -1;",
      "489:     val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3];",
      "490:     break;",
      "491:   default:",
      "492:     return -1; // Error case",
      "493:   }",
      "495:   return val >>> 0;",
      "496: };",
      "",
      "---------------"
    ],
    "test/api-test.js||test/api-test.js": [
      "File: test/api-test.js -> test/api-test.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "251:     });",
      "252:   });",
      "254:   describe('isPrivate() method', () => {",
      "255:     it('should check if an address is localhost', () => {",
      "256:       assert.equal(ip.isPrivate('127.0.0.1'), true);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "254:   describe('normalizeIpv4() method', () => {",
      "256:     it('should correctly normalize \"127.0.0.1\"', () => {",
      "257:       assert.equal(ip.normalizeToLong('127.0.0.1'), 2130706433);",
      "258:     });",
      "260:     it('should correctly handle \"127.1\" as two parts', () => {",
      "261:       assert.equal(ip.normalizeToLong('127.1'), 2130706433);",
      "262:     });",
      "264:     it('should correctly handle \"127.0.1\" as three parts', () => {",
      "265:       assert.equal(ip.normalizeToLong('127.0.1'), 2130706433);",
      "266:     });",
      "269:     it('should correctly handle hexadecimal notation \"0x7f.0x0.0x0.0x1\"', () => {",
      "270:       assert.equal(ip.normalizeToLong('0x7f.0x0.0x0.0x1'), 2130706433);",
      "271:     });",
      "274:     it('should correctly handle \"0x7f000001\" as a single part', () => {",
      "275:       assert.equal(ip.normalizeToLong('0x7f000001'), 2130706433);",
      "276:     });",
      "278:     it('should correctly handle octal notation \"010.0.0.01\"', () => {",
      "279:       assert.equal(ip.normalizeToLong('010.0.0.01'), 134217729);",
      "280:     });",
      "283:     it('should return -1 for an invalid address \"256.100.50.25\"', () => {",
      "284:       assert.equal(ip.normalizeToLong('256.100.50.25'), -1);",
      "285:     });",
      "287:     it('should return -1 for an address with invalid octal \"019.0.0.1\"', () => {",
      "288:       assert.equal(ip.normalizeToLong('019.0.0.1'), -1);",
      "289:     });",
      "291:     it('should return -1 for an address with invalid hex \"0xGG.0.0.1\"', () => {",
      "292:       assert.equal(ip.normalizeToLong('0xGG.0.0.1'), -1);",
      "293:     });",
      "296:     it('should return -1 for an empty string', () => {",
      "297:       assert.equal(ip.normalizeToLong(''), -1);",
      "298:     });",
      "300:     it('should return -1 for a string with too many parts \"192.168.0.1.100\"', () => {",
      "301:       assert.equal(ip.normalizeToLong('192.168.0.1.100'), -1);",
      "302:     });",
      "303:   });",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "300:       assert.equal(ip.isPrivate('::1'), true);",
      "301:       assert.equal(ip.isPrivate('fe80::1'), true);",
      "302:     });",
      "303:   });",
      "305:   describe('loopback() method', () => {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "355:     it('should correctly identify hexadecimal IP addresses like \\'0x7f.1\\' as private', () => {",
      "356:       assert.equal(ip.isPrivate('0x7f.1'), true);",
      "357:     });",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "413:       assert.equal(ip.fromLong(4294967295), '255.255.255.255');",
      "414:     });",
      "415:   });",
      "416: });",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "473:   it('should return true for octal representation \"0177.0.0.1\"', () => {",
      "474:     assert.equal(ip.isLoopback('0177.0.0.1'), true);",
      "475:   });",
      "477:   it('should return true for octal representation \"0177.0.1\"', () => {",
      "478:     assert.equal(ip.isLoopback('0177.0.1'), true);",
      "479:   });",
      "481:   it('should return true for octal representation \"0177.1\"', () => {",
      "482:     assert.equal(ip.isLoopback('0177.1'), true);",
      "483:   });",
      "486:   it('should return true for hexadecimal representation \"0x7f.0.0.1\"', () => {",
      "487:     assert.equal(ip.isLoopback('0x7f.0.0.1'), true);",
      "488:   });",
      "491:   it('should return true for hexadecimal representation \"0x7f.0.1\"', () => {",
      "492:     assert.equal(ip.isLoopback('0x7f.0.1'), true);",
      "493:   });",
      "496:   it('should return true for hexadecimal representation \"0x7f.1\"', () => {",
      "497:     assert.equal(ip.isLoopback('0x7f.1'), true);",
      "498:   });",
      "501:   it('should return true for single long integer representation \"2130706433\"', () => {",
      "502:     assert.equal(ip.isLoopback('2130706433'), true);",
      "503:   });",
      "506:   it('should return false for \"192.168.1.1\"', () => {",
      "507:     assert.equal(ip.isLoopback('192.168.1.1'), false);",
      "508:   });",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "32f468f1245574785ec080705737a579be1223aa",
      "candidate_info": {
        "commit_hash": "32f468f1245574785ec080705737a579be1223aa",
        "repo": "indutny/node-ip",
        "commit_url": "https://github.com/indutny/node-ip/commit/32f468f1245574785ec080705737a579be1223aa",
        "files": [
          "lib/ip.js",
          "test/api-test.js"
        ],
        "message": "lib: fixed CVE-2023-42282 and added unit test",
        "before_after_code_files": [
          "lib/ip.js||lib/ip.js",
          "test/api-test.js||test/api-test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/ip.js||lib/ip.js",
            "test/api-test.js||test/api-test.js"
          ],
          "candidate": [
            "lib/ip.js||lib/ip.js",
            "test/api-test.js||test/api-test.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/ip.js||lib/ip.js": [
          "File: lib/ip.js -> lib/ip.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "306: };",
          "308: ip.isPrivate = function (addr) {",
          "311:     || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
          "312:     || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i",
          "313:       .test(addr)",
          "315:     || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
          "316:     || /^f[cd][0-9a-f]{2}:/i.test(addr)",
          "317:     || /^fe80:/i.test(addr)",
          "",
          "[Removed Lines]",
          "309:   return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i",
          "310:     .test(addr)",
          "314:     || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
          "",
          "[Added Lines]",
          "310:   if (ip.isLoopback(addr)) {",
          "311:     return true;",
          "312:   }",
          "315:   if (!ip.isV6Format(addr)) {",
          "316:     const ipl = ip.normalizeToLong(addr);",
          "317:     if (ipl < 0) {",
          "318:       throw new Error('invalid ipv4 address');",
          "319:     }",
          "321:     addr = ip.fromLong(ipl);",
          "322:   }",
          "325:   return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "324: };",
          "326: ip.isLoopback = function (addr) {",
          "327:   return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/",
          "328:     .test(addr)",
          "330:     || /^::1$/.test(addr)",
          "331:     || /^::$/.test(addr);",
          "332: };",
          "",
          "[Removed Lines]",
          "329:     || /^fe80::1$/.test(addr)",
          "",
          "[Added Lines]",
          "342:   if (!/\\./.test(addr) && !/:/.test(addr)) {",
          "343:     addr = ip.fromLong(Number(addr));",
          "344:   }",
          "348:     || /^0177\\./.test(addr)",
          "349:     || /^0x7f\\./i.test(addr)",
          "350:     || /^fe80::1$/i.test(addr)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:     ipl >> 8 & 255}.${",
          "421:     ipl & 255}`);",
          "422: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "445: ip.normalizeToLong = function (addr) {",
          "446:   const parts = addr.split('.').map(part => {",
          "448:     if (part.startsWith('0x') || part.startsWith('0X')) {",
          "449:       return parseInt(part, 16);",
          "450:     }",
          "452:     else if (part.startsWith('0') && part !== '0' && /^[0-7]+$/.test(part)) {",
          "453:       return parseInt(part, 8);",
          "454:     }",
          "456:     else if (/^[1-9]\\d*$/.test(part) || part === '0') {",
          "457:       return parseInt(part, 10);",
          "458:     }",
          "460:     else {",
          "461:       return NaN;",
          "462:     }",
          "463:   });",
          "465:   if (parts.some(isNaN)) return -1; // Indicate error with -1",
          "467:   let val = 0;",
          "468:   const n = parts.length;",
          "470:   switch (n) {",
          "471:   case 1:",
          "472:     val = parts[0];",
          "473:     break;",
          "474:   case 2:",
          "475:     if (parts[0] > 0xff || parts[1] > 0xffffff) return -1;",
          "476:     val = (parts[0] << 24) | (parts[1] & 0xffffff);",
          "477:     break;",
          "478:   case 3:",
          "479:     if (parts[0] > 0xff || parts[1] > 0xff || parts[2] > 0xffff) return -1;",
          "480:     val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] & 0xffff);",
          "481:     break;",
          "482:   case 4:",
          "483:     if (parts.some(part => part > 0xff)) return -1;",
          "484:     val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3];",
          "485:     break;",
          "486:   default:",
          "487:     return -1; // Error case",
          "488:   }",
          "490:   return val >>> 0;",
          "491: };",
          "",
          "---------------"
        ],
        "test/api-test.js||test/api-test.js": [
          "File: test/api-test.js -> test/api-test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "251:     });",
          "252:   });",
          "254:   describe('isPrivate() method', () => {",
          "255:     it('should check if an address is localhost', () => {",
          "256:       assert.equal(ip.isPrivate('127.0.0.1'), true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "254:   describe('normalizeIpv4() method', () => {",
          "256:     it('should correctly normalize \"127.0.0.1\"', () => {",
          "257:       assert.equal(ip.normalizeToLong('127.0.0.1'), 2130706433);",
          "258:     });",
          "260:     it('should correctly handle \"127.1\" as two parts', () => {",
          "261:       assert.equal(ip.normalizeToLong('127.1'), 2130706433);",
          "262:     });",
          "264:     it('should correctly handle \"127.0.1\" as three parts', () => {",
          "265:       assert.equal(ip.normalizeToLong('127.0.1'), 2130706433);",
          "266:     });",
          "269:     it('should correctly handle hexadecimal notation \"0x7f.0x0.0x0.0x1\"', () => {",
          "270:       assert.equal(ip.normalizeToLong('0x7f.0x0.0x0.0x1'), 2130706433);",
          "271:     });",
          "274:     it('should correctly handle \"0x7f000001\" as a single part', () => {",
          "275:       assert.equal(ip.normalizeToLong('0x7f000001'), 2130706433);",
          "276:     });",
          "278:     it('should correctly handle octal notation \"010.0.0.01\"', () => {",
          "279:       assert.equal(ip.normalizeToLong('010.0.0.01'), 134217729);",
          "280:     });",
          "283:     it('should return -1 for an invalid address \"256.100.50.25\"', () => {",
          "284:       assert.equal(ip.normalizeToLong('256.100.50.25'), -1);",
          "285:     });",
          "287:     it('should return -1 for an address with invalid octal \"019.0.0.1\"', () => {",
          "288:       assert.equal(ip.normalizeToLong('019.0.0.1'), -1);",
          "289:     });",
          "291:     it('should return -1 for an address with invalid hex \"0xGG.0.0.1\"', () => {",
          "292:       assert.equal(ip.normalizeToLong('0xGG.0.0.1'), -1);",
          "293:     });",
          "296:     it('should return -1 for an empty string', () => {",
          "297:       assert.equal(ip.normalizeToLong(''), -1);",
          "298:     });",
          "300:     it('should return -1 for a string with too many parts \"192.168.0.1.100\"', () => {",
          "301:       assert.equal(ip.normalizeToLong('192.168.0.1.100'), -1);",
          "302:     });",
          "303:   });",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "300:       assert.equal(ip.isPrivate('::1'), true);",
          "301:       assert.equal(ip.isPrivate('fe80::1'), true);",
          "302:     });",
          "303:   });",
          "305:   describe('loopback() method', () => {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:     it('should correctly identify hexadecimal IP addresses like \\'0x7f.1\\' as private', () => {",
          "356:       assert.equal(ip.isPrivate('0x7f.1'), true);",
          "357:     });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "413:       assert.equal(ip.fromLong(4294967295), '255.255.255.255');",
          "414:     });",
          "415:   });",
          "416: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "473:   it('should return true for octal representation \"0177.0.0.1\"', () => {",
          "474:     assert.equal(ip.isLoopback('0177.0.0.1'), true);",
          "475:   });",
          "477:   it('should return true for octal representation \"0177.0.1\"', () => {",
          "478:     assert.equal(ip.isLoopback('0177.0.1'), true);",
          "479:   });",
          "481:   it('should return true for octal representation \"0177.1\"', () => {",
          "482:     assert.equal(ip.isLoopback('0177.1'), true);",
          "483:   });",
          "486:   it('should return true for hexadecimal representation \"0x7f.0.0.1\"', () => {",
          "487:     assert.equal(ip.isLoopback('0x7f.0.0.1'), true);",
          "488:   });",
          "491:   it('should return true for hexadecimal representation \"0x7f.0.1\"', () => {",
          "492:     assert.equal(ip.isLoopback('0x7f.0.1'), true);",
          "493:   });",
          "496:   it('should return true for hexadecimal representation \"0x7f.1\"', () => {",
          "497:     assert.equal(ip.isLoopback('0x7f.1'), true);",
          "498:   });",
          "501:   it('should return true for single long integer representation \"2130706433\"', () => {",
          "502:     assert.equal(ip.isLoopback('2130706433'), true);",
          "503:   });",
          "506:   it('should return false for \"192.168.1.1\"', () => {",
          "507:     assert.equal(ip.isLoopback('192.168.1.1'), false);",
          "508:   });",
          "",
          "---------------"
        ]
      }
    }
  ]
}
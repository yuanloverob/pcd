{
  "cve_id": "CVE-2024-29034",
  "cve_desc": "CarrierWave is a solution for file uploads for Rails, Sinatra and other Ruby web frameworks. The vulnerability CVE-2023-49090 wasn't fully addressed. This vulnerability is caused by the fact that when uploading to object storage, including Amazon S3, it is possible to set a Content-Type value that is interpreted by browsers to be different from what's allowed by `content_type_allowlist`, by providing multiple values separated by commas. This bypassed value can be used to cause XSS. Upgrade to 3.0.7 or 2.2.6.\n",
  "repo": "carrierwaveuploader/carrierwave",
  "patch_hash": "25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
  "patch_info": {
    "commit_hash": "25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
    "repo": "carrierwaveuploader/carrierwave",
    "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
    "files": [
      "lib/carrierwave/sanitized_file.rb",
      "spec/sanitized_file_spec.rb",
      "spec/uploader/content_type_allowlist_spec.rb"
    ],
    "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
    "before_after_code_files": [
      "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
      "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
      "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
    ]
  },
  "patch_diff": {
    "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
      "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "307:     def declared_content_type",
      "308:       @declared_content_type ||",
      "309:         if @file.respond_to?(:content_type) && @file.content_type",
      "311:         end",
      "312:     end",
      "",
      "[Removed Lines]",
      "310:           @file.content_type.to_s.chomp",
      "",
      "[Added Lines]",
      "310:           Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
      "",
      "---------------"
    ],
    "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
      "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "327:       expect { sanitized_file.content_type }.not_to raise_error",
      "328:     end",
      "329:   end",
      "331:   describe \"#content_type=\" do",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "330:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
      "331:       file = File.open(file_path(\"bork.txt\"))",
      "332:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
      "334:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "336:       expect(sanitized_file.content_type).to eq(\"image/png\")",
      "337:     end",
      "339:     it \"uses the first one when multiple mime types are given using a comma\" do",
      "340:       file = File.open(file_path(\"bork.txt\"))",
      "341:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
      "343:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "345:       expect(sanitized_file.content_type).to eq(\"image/png\")",
      "346:     end",
      "348:     it \"drops content type parameters\" do",
      "349:       file = File.open(file_path(\"bork.txt\"))",
      "350:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
      "352:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "354:       expect(sanitized_file.content_type).to eq(\"text/html\")",
      "355:     end",
      "",
      "---------------"
    ],
    "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb": [
      "File: spec/uploader/content_type_allowlist_spec.rb -> spec/uploader/content_type_allowlist_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
      "88:         end",
      "89:       end",
      "106:     end",
      "108:     context \"when there is a whitelist\" do",
      "",
      "[Removed Lines]",
      "91:       context \"when the allowlist contains charset\" do",
      "92:         before do",
      "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
      "94:         end",
      "96:         it \"accepts the content with allowed charset\" do",
      "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
      "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
      "99:         end",
      "101:         it \"rejects the content without charset\" do",
      "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
      "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
      "104:         end",
      "105:       end",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "431787193795dda9b01a0ee748bd93e2ec7101c2",
      "candidate_info": {
        "commit_hash": "431787193795dda9b01a0ee748bd93e2ec7101c2",
        "repo": "carrierwaveuploader/carrierwave",
        "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/431787193795dda9b01a0ee748bd93e2ec7101c2",
        "files": [
          "lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_whitelist_spec.rb"
        ],
        "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
        "before_after_code_files": [
          "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_whitelist_spec.rb||spec/uploader/content_type_whitelist_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ],
          "candidate": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
          "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "325:     def existing_content_type",
          "326:       if @file.respond_to?(:content_type) && @file.content_type",
          "328:       end",
          "329:     end",
          "",
          "[Removed Lines]",
          "327:         @file.content_type.to_s.chomp",
          "",
          "[Added Lines]",
          "327:         Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
          "",
          "---------------"
        ],
        "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
          "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:       expect { sanitized_file.content_type }.not_to raise_error",
          "276:     end",
          "277:   end",
          "279:   describe \"#content_type=\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "278:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
          "279:       file = File.open(file_path(\"bork.txt\"))",
          "280:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
          "282:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "284:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "285:     end",
          "287:     it \"uses the first one when multiple mime types are given using a comma\" do",
          "288:       file = File.open(file_path(\"bork.txt\"))",
          "289:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
          "291:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "293:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "294:     end",
          "296:     it \"drops content type parameters\" do",
          "297:       file = File.open(file_path(\"bork.txt\"))",
          "298:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
          "300:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "302:       expect(sanitized_file.content_type).to eq(\"text/html\")",
          "303:     end",
          "",
          "---------------"
        ],
        "spec/uploader/content_type_whitelist_spec.rb||spec/uploader/content_type_whitelist_spec.rb": [
          "File: spec/uploader/content_type_whitelist_spec.rb -> spec/uploader/content_type_whitelist_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "88:         end",
          "89:       end",
          "106:     end",
          "108:     context \"when there is a whitelist\" do",
          "",
          "[Removed Lines]",
          "91:       context \"when the allowlist contains charset\" do",
          "92:         before do",
          "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
          "94:         end",
          "96:         it \"accepts the content with allowed charset\" do",
          "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
          "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
          "99:         end",
          "101:         it \"rejects the content without charset\" do",
          "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
          "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "104:         end",
          "105:       end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00676e23d7f4beac12beddee6f2486b686fb7e46",
      "candidate_info": {
        "commit_hash": "00676e23d7f4beac12beddee6f2486b686fb7e46",
        "repo": "carrierwaveuploader/carrierwave",
        "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/00676e23d7f4beac12beddee6f2486b686fb7e46",
        "files": [
          "lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_allowlist_spec.rb"
        ],
        "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
        "before_after_code_files": [
          "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
            "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
          ],
          "candidate": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
            "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
          "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:     def declared_content_type",
          "308:       @declared_content_type ||",
          "309:         if @file.respond_to?(:content_type) && @file.content_type",
          "311:         end",
          "312:     end",
          "",
          "[Removed Lines]",
          "310:           @file.content_type.to_s.chomp",
          "",
          "[Added Lines]",
          "310:           Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
          "",
          "---------------"
        ],
        "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
          "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:       expect { sanitized_file.content_type }.not_to raise_error",
          "308:     end",
          "309:   end",
          "311:   describe \"#content_type=\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
          "311:       file = File.open(file_path(\"bork.txt\"))",
          "312:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
          "314:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "316:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "317:     end",
          "319:     it \"uses the first one when multiple mime types are given using a comma\" do",
          "320:       file = File.open(file_path(\"bork.txt\"))",
          "321:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
          "323:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "325:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "326:     end",
          "328:     it \"drops content type parameters\" do",
          "329:       file = File.open(file_path(\"bork.txt\"))",
          "330:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
          "332:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "334:       expect(sanitized_file.content_type).to eq(\"text/html\")",
          "335:     end",
          "",
          "---------------"
        ],
        "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb": [
          "File: spec/uploader/content_type_allowlist_spec.rb -> spec/uploader/content_type_allowlist_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "88:         end",
          "89:       end",
          "106:     end",
          "108:     context \"when there is a whitelist\" do",
          "",
          "[Removed Lines]",
          "91:       context \"when the allowlist contains charset\" do",
          "92:         before do",
          "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
          "94:         end",
          "96:         it \"accepts the content with allowed charset\" do",
          "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
          "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
          "99:         end",
          "101:         it \"rejects the content without charset\" do",
          "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
          "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "104:         end",
          "105:       end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-32675",
  "cve_desc": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In contracts with more than one regular nonpayable function, it is possible to send funds to the default function, even if the default function is marked `nonpayable`. This applies to contracts compiled with vyper versions prior to 0.3.8. This issue was fixed by the removal of the global `calldatasize` check in commit `02339dfda`. Users are advised to upgrade to version 0.3.8. Users unable to upgrade should avoid use of nonpayable default functions.",
  "repo": "vyperlang/vyper",
  "patch_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
  "patch_info": {
    "commit_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
    "repo": "vyperlang/vyper",
    "commit_url": "https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520",
    "files": [
      "tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py"
    ],
    "message": "refactor: optimize calldatasize check (#3104)\n\nthis changes the calldatasize check from a global/contract-entry check\nto a function-local check - the calldatasize check only needs to be\npresent if a selector is 0. this maintains the invariant protecting\nagainst the bug in #1603 while being more efficient.\n\nCo-authored-by: Charles Cooper <cooper.charles.m@gmail.com>",
    "before_after_code_files": [
      "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py||vyper/codegen/module.py"
    ]
  },
  "patch_diff": {
    "tests/parser/features/test_init.py||tests/parser/features/test_init.py": [
      "File: tests/parser/features/test_init.py -> tests/parser/features/test_init.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:     assert c.val() == 123",
      "17:     # Make sure the init code does not access calldata",
      "26: def test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):",
      "",
      "[Removed Lines]",
      "18:     opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")",
      "19:     ir_return_idx = opcodes.index(\"JUMP\")",
      "21:     assert \"CALLDATALOAD\" in opcodes",
      "22:     assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]",
      "23:     assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]",
      "",
      "[Added Lines]",
      "18:     assembly = vyper.compile_code(code, [\"asm\"])[\"asm\"].split(\" \")",
      "19:     ir_return_idx_start = assembly.index(\"{\")",
      "20:     ir_return_idx_end = assembly.index(\"}\")",
      "22:     assert \"CALLDATALOAD\" in assembly",
      "23:     assert \"CALLDATACOPY\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "24:     assert \"CALLDATALOAD\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "",
      "---------------"
    ],
    "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
      "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "124:         ret.append([\"goto\", sig.external_function_base_entry_label])",
      "127:         return ret",
      "129:     ret = [\"seq\"]",
      "",
      "[Removed Lines]",
      "126:         ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]",
      "",
      "[Added Lines]",
      "126:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
      "128:         # if there is a function whose selector is 0, it won't be distinguished",
      "129:         # from the case where nil calldata is supplied, b/c calldataload loads",
      "130:         # 0s past the end of physical calldata (cf. yellow paper).",
      "131:         # since supplying 0 calldata is expected to trigger the fallback fn,",
      "132:         # we check that calldatasize > 0, which distinguishes the 0 selector",
      "133:         # from the fallback function \"selector\"",
      "134:         # (equiv. to \"all selectors not in the selector table\").",
      "136:         # note: cases where not enough calldata is supplied (besides",
      "137:         # calldatasize==0) are not addressed here b/c a calldatasize",
      "138:         # well-formedness check is already present in the function body",
      "139:         # as part of abi validation",
      "140:         if method_id.value == 0:",
      "141:             method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
      "143:         ret = [\"if\", method_id_check, ret]",
      "",
      "---------------"
    ],
    "vyper/codegen/module.py||vyper/codegen/module.py": [
      "File: vyper/codegen/module.py -> vyper/codegen/module.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:     runtime = [",
      "122:         \"seq\",",
      "126:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
      "127:         close_selector_section,",
      "128:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
      "",
      "[Removed Lines]",
      "123:         # check that calldatasize is at least 4, otherwise",
      "124:         # calldataload will load zeros (cf. yellow paper).",
      "125:         [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "33c247151cfed13999289c08f3c35d70fa83394d",
      "candidate_info": {
        "commit_hash": "33c247151cfed13999289c08f3c35d70fa83394d",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/33c247151cfed13999289c08f3c35d70fa83394d",
        "files": [
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/module.py"
        ],
        "message": "fix: add back global calldatasize check (#3463)\n\nprevent a performance regression for sending eth to contracts with a\npayable default function by (mostly) reverting the changes introduced in\n9ecb97b4b6f and 02339dfda0. the `skip_nonpayable_check=False` for the\ndefault function is introduced to address GHSA-vxmm-cwh2-q762 (which\n02339dfda0 inadvertently fixed, and a test for which was added in\n903727006c).",
        "before_after_code_files": [
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/module.py||vyper/codegen/module.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:         calldata_min_size = args_abi_t.min_size() + 4",
          "91:         # note we don't need the check if calldata_min_size == 4,",
          "94:         if calldata_min_size > 4:",
          "95:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Removed Lines]",
          "92:         # because the selector checks later in this routine ensure",
          "93:         # that calldatasize >= 4.",
          "",
          "[Added Lines]",
          "92:         # because the global calldatasize check ensures that already.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "127:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "150:         ret = [\"if\", method_id_check, ret]",
          "151:         return ret",
          "",
          "[Removed Lines]",
          "129:         # if there is a function whose selector is 0 or has trailing 0s, it",
          "130:         # might not be distinguished from the case where insufficient calldata",
          "131:         # is supplied, b/c calldataload loads 0s past the end of physical",
          "132:         # calldata (cf. yellow paper).",
          "133:         # since the expected behavior of supplying insufficient calldata",
          "134:         # is to trigger the fallback fn, we add to the selector check that",
          "135:         # calldatasize >= 4, which distinguishes any selector with trailing",
          "136:         # 0 bytes from the fallback function \"selector\" (equiv. to \"all",
          "137:         # selectors not in the selector table\").",
          "138:         #",
          "139:         # note that the inclusion of this check means that, we are always",
          "140:         # guaranteed that the calldata is at least 4 bytes - either we have",
          "141:         # the explicit `calldatasize >= 4` condition in the selector check,",
          "142:         # or there are no trailing zeroes in the selector, (so the selector",
          "143:         # is impossible to match without calldatasize being at least 4).",
          "144:         method_id_bytes = util.method_id(abi_sig)",
          "145:         assert len(method_id_bytes) == 4",
          "146:         has_trailing_zeroes = method_id_bytes.endswith(b\"\\x00\")",
          "147:         if has_trailing_zeroes:",
          "148:             method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:         selector_section.append(func_ir)",
          "109:     if default_function:",
          "111:     else:",
          "112:         fallback_ir = IRnode.from_list(",
          "113:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "",
          "[Removed Lines]",
          "110:         fallback_ir = generate_ir_for_function(default_function, global_ctx, skip_nonpayable_check)",
          "",
          "[Added Lines]",
          "110:         fallback_ir = generate_ir_for_function(",
          "111:             default_function, global_ctx, skip_nonpayable_check=False",
          "112:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:     # fallback label is the immediate next instruction,",
          "120:     close_selector_section = [\"goto\", \"fallback\"]",
          "122:     runtime = [",
          "123:         \"seq\",",
          "124:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
          "125:         close_selector_section,",
          "126:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:     global_calldatasize_check = [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]]",
          "128:         global_calldatasize_check,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
      "candidate_info": {
        "commit_hash": "9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
        "files": [
          "tests/parser/functions/test_default_function.py",
          "vyper/codegen/function_definitions/external_function.py"
        ],
        "message": "fix: calldatasize < 4 reverting instead of going to fallback (#3408)\n\nin the case that a selector matches calldata with less than 4 bytes, it\ncurrently will revert instead of going to the fallback. this can happen\nif the selector has trailing zeroes. this commit fixes the behavior for\nselectors with trailing zeroes, and improves code size and gas for those\nwithout trailing zeroes.",
        "before_after_code_files": [
          "tests/parser/functions/test_default_function.py||tests/parser/functions/test_default_function.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/parser/functions/test_default_function.py||tests/parser/functions/test_default_function.py": [
          "File: tests/parser/functions/test_default_function.py -> tests/parser/functions/test_default_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:     assert_compile_failed(lambda: get_contract_with_gas_estimation(code))",
          "104:     code = \"\"\"",
          "105: event Sent:",
          "106:     sig: uint256",
          "",
          "[Removed Lines]",
          "103: def test_zero_method_id(w3, get_logs, get_contract_with_gas_estimation):",
          "",
          "[Added Lines]",
          "103: def test_zero_method_id(w3, get_logs, get_contract, assert_tx_failed):",
          "104:     # test a method with 0x00000000 selector,",
          "105:     # expects at least 36 bytes of calldata.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116: def __default__():",
          "117:     log Sent(1)",
          "118:     \"\"\"",
          "122:     assert c.blockHashAskewLimitary(0) == 7",
          "",
          "[Removed Lines]",
          "120:     c = get_contract_with_gas_estimation(code)",
          "124:     logs = get_logs(w3.eth.send_transaction({\"to\": c.address, \"value\": 0}), c, \"Sent\")",
          "125:     assert 1 == logs[0].args.sig",
          "127:     logs = get_logs(",
          "128:         # call blockHashAskewLimitary",
          "129:         w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": \"0x\" + \"00\" * 36}),",
          "130:         c,",
          "131:         \"Sent\",",
          "132:     )",
          "133:     assert 2 == logs[0].args.sig",
          "",
          "[Added Lines]",
          "121:     c = get_contract(code)",
          "125:     def _call_with_bytes(hexstr):",
          "126:         # call our special contract and return the logged value",
          "127:         logs = get_logs(",
          "128:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "129:         )",
          "130:         return logs[0].args.sig",
          "132:     assert 1 == _call_with_bytes(\"0x\")",
          "134:     # call blockHashAskewLimitary with proper calldata",
          "135:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 36)",
          "137:     # call blockHashAskewLimitary with extra trailing bytes in calldata",
          "138:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 37)",
          "140:     for i in range(4):",
          "141:         # less than 4 bytes of calldata doesn't match the 0 selector and goes to default",
          "142:         assert 1 == _call_with_bytes(\"0x\" + \"00\" * i)",
          "144:     for i in range(4, 36):",
          "145:         # match the full 4 selector bytes, but revert due to malformed (short) calldata",
          "146:         assert_tx_failed(lambda: _call_with_bytes(\"0x\" + \"00\" * i))",
          "149: def test_another_zero_method_id(w3, get_logs, get_contract, assert_tx_failed):",
          "150:     # test another zero method id but which only expects 4 bytes of calldata",
          "151:     code = \"\"\"",
          "152: event Sent:",
          "153:     sig: uint256",
          "155: @external",
          "156: @payable",
          "157: # function selector: 0x00000000",
          "158: def wycpnbqcyf() -> uint256:",
          "159:     log Sent(2)",
          "160:     return 7",
          "162: @external",
          "163: def __default__():",
          "164:     log Sent(1)",
          "165:     \"\"\"",
          "166:     c = get_contract(code)",
          "168:     assert c.wycpnbqcyf() == 7",
          "170:     def _call_with_bytes(hexstr):",
          "171:         # call our special contract and return the logged value",
          "172:         logs = get_logs(",
          "173:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "174:         )",
          "175:         return logs[0].args.sig",
          "177:     assert 1 == _call_with_bytes(\"0x\")",
          "179:     # call wycpnbqcyf",
          "180:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 4)",
          "182:     # too many bytes ok",
          "183:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 5)",
          "185:     # \"right\" method id but by accident - not enough bytes.",
          "186:     for i in range(4):",
          "187:         assert 1 == _call_with_bytes(\"0x\" + \"00\" * i)",
          "190: def test_partial_selector_match_trailing_zeroes(w3, get_logs, get_contract):",
          "191:     code = \"\"\"",
          "192: event Sent:",
          "193:     sig: uint256",
          "195: @external",
          "196: @payable",
          "197: # function selector: 0xd88e0b00",
          "198: def fow() -> uint256:",
          "199:     log Sent(2)",
          "200:     return 7",
          "202: @external",
          "203: def __default__():",
          "204:     log Sent(1)",
          "205:     \"\"\"",
          "206:     c = get_contract(code)",
          "208:     # sanity check - we can call c.fow()",
          "209:     assert c.fow() == 7",
          "211:     def _call_with_bytes(hexstr):",
          "212:         # call our special contract and return the logged value",
          "213:         logs = get_logs(",
          "214:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "215:         )",
          "216:         return logs[0].args.sig",
          "218:     # check we can call default function",
          "219:     assert 1 == _call_with_bytes(\"0x\")",
          "221:     # check fow() selector is 0xd88e0b00",
          "222:     assert 2 == _call_with_bytes(\"0xd88e0b00\")",
          "224:     # check calling d88e0b with no trailing zero goes to fallback instead of reverting",
          "225:     assert 1 == _call_with_bytes(\"0xd88e0b\")",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:         # ensure calldata is at least of minimum length",
          "89:         args_abi_t = calldata_args_t.abi_type",
          "90:         calldata_min_size = args_abi_t.min_size() + 4",
          "93:         # TODO optimize make_setter by using",
          "94:         # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
          "",
          "[Removed Lines]",
          "91:         ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Added Lines]",
          "92:         # note we don't need the check if calldata_min_size == 4,",
          "93:         # because the selector checks later in this routine ensure",
          "94:         # that calldatasize >= 4.",
          "95:         if calldata_min_size > 4:",
          "96:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "142:         ret = [\"if\", method_id_check, ret]",
          "143:         return ret",
          "",
          "[Removed Lines]",
          "127:         # if there is a function whose selector is 0, it won't be distinguished",
          "128:         # from the case where nil calldata is supplied, b/c calldataload loads",
          "129:         # 0s past the end of physical calldata (cf. yellow paper).",
          "130:         # since supplying 0 calldata is expected to trigger the fallback fn,",
          "131:         # we check that calldatasize > 0, which distinguishes the 0 selector",
          "132:         # from the fallback function \"selector\"",
          "133:         # (equiv. to \"all selectors not in the selector table\").",
          "135:         # note: cases where not enough calldata is supplied (besides",
          "136:         # calldatasize==0) are not addressed here b/c a calldatasize",
          "137:         # well-formedness check is already present in the function body",
          "138:         # as part of abi validation",
          "139:         if method_id.value == 0:",
          "140:             method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
          "",
          "[Added Lines]",
          "132:         # if there is a function whose selector is 0 or has trailing 0s, it",
          "133:         # might not be distinguished from the case where insufficient calldata",
          "134:         # is supplied, b/c calldataload loads 0s past the end of physical",
          "135:         # calldata (cf. yellow paper).",
          "136:         # since the expected behavior of supplying insufficient calldata",
          "137:         # is to trigger the fallback fn, we add to the selector check that",
          "138:         # calldatasize >= 4, which distinguishes any selector with trailing",
          "139:         # 0 bytes from the fallback function \"selector\" (equiv. to \"all",
          "140:         # selectors not in the selector table\").",
          "141:         #",
          "142:         # note that the inclusion of this check means that, we are always",
          "143:         # guaranteed that the calldata is at least 4 bytes - either we have",
          "144:         # the explicit `calldatasize >= 4` condition in the selector check,",
          "145:         # or there are no trailing zeroes in the selector, (so the selector",
          "146:         # is impossible to match without calldatasize being at least 4).",
          "147:         method_id_bytes = util.method_id(abi_sig)",
          "148:         assert len(method_id_bytes) == 4",
          "149:         has_trailing_zeroes = method_id_bytes.endswith(b\"\\x00\")",
          "150:         if has_trailing_zeroes:",
          "151:             method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "408929fa31ae01dde4f7566bb7babbc7da5b6620",
      "candidate_info": {
        "commit_hash": "408929fa31ae01dde4f7566bb7babbc7da5b6620",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/408929fa31ae01dde4f7566bb7babbc7da5b6620",
        "files": [
          ".github/workflows/test.yml",
          "docs/compiling-a-contract.rst",
          "docs/structure-of-a-contract.rst",
          "tests/base_conftest.py",
          "tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "tests/compiler/__init__.py",
          "tests/compiler/test_default_settings.py",
          "tests/conftest.py",
          "tests/parser/functions/test_slice.py",
          "tests/parser/test_selector_table.py",
          "tox.ini",
          "vyper/ast/grammar.lark",
          "vyper/cli/vyper_compile.py",
          "vyper/cli/vyper_ir.py",
          "vyper/codegen/core.py",
          "vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/ir_node.py",
          "vyper/codegen/jumptable_utils.py",
          "vyper/codegen/module.py",
          "vyper/compiler/output.py",
          "vyper/compiler/settings.py",
          "vyper/ir/compile_ir.py"
        ],
        "message": "feat: O(1) selector tables (#3496)\n\nthis commit replaces the existing linear entry point search with an O(1)\nimplementation. there are two methods depending on whether optimizing\nfor code size or gas, hash table with probing and perfect hashing using\na two-level technique.\n\nthe first method divides the selectors into buckets, uses\n`method_id % n_buckets` as a \"guess\" to where to enter the selector\ntable and then jumps there and performs the familiar linear search for\nthe selector (\"probing\"). to avoid too large buckets, the jumptable\ngenerator searches a range from ~`n_buckets * 0.85` to\n`n_buckets * 1.15` to minimize worst-case probe depth; the average worst\ncase for 80-100 methods is 3 items per bucket and the worst worst case\nis 4 items per bucket (presumably if you get really unlucky), see\n`_bench_sparse()` in `vyper/codegen/jumptable_utils.py`. the average\nbucket size is 1.6 methods.\n\nthe second method uses a perfect hashing technique. finding a single\nmagic which produces a perfect hash is infeasible for large `N`\n(exponential, and in practice seems to run off a cliff around 10\n methods). to \"get around\" this, the methods are divided into buckets of\nroughly size 10, and a magic is computed per bucket. several `n_buckets`\nare tried, trying to minimize `n_buckets`. the code size overhead of\neach bucket is roughly 5 bytes per bucket, which works out to ~20% per\nmethod, see `_bench_dense()` in `vyper/codegen/jumptable_utils.py`.\nthen, the function selector is looked up in two steps - it loads the\nmagic for the bucket given by `method_id % n_buckets`, and then uses the\nmagic to compute the location of the function selector (and associated\nmetadata) in the data section. from there it loads the function\nmetadata, performs the calldatasize, callvalue and method id checks and\njumps into the function.\n\nthere is a gas vs code size tradeoff between the two methods - roughly\nspeaking, the sparse method requires ~69 gas in the best case (~109 gas\nin the \"average\" case) and 12-22 bytes of code per method, while the\ndense method requires ~212 gas across the board, and ~8 bytes of code\nper method.\n\nto accomplish this implementation-wise, the jumptable info is generated\nin a new helper module, `vyper/codegen/jumptable_utils.py`. some\nrefactoring had to be additionally done to pull the calldatasize,\ncallvalue and method id checks from external function generation out\ninto a new selector section construction step in\n`vyper/codegen/module.py`.\n\nadditionally, a new IR \"data\" directive was added, and an associated\nassembly directive. the data segments in assembly are moved to the end\nof the bytecode to ensure that data bytes which happen to look like\n`PUSH` instructions do not mangle valid bytecode which comes after the\ndata section.",
        "before_after_code_files": [
          "tests/base_conftest.py||tests/base_conftest.py",
          "tests/cli/vyper_json/test_parse_args_vyperjson.py||tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "tests/compiler/__init__.py||tests/compiler/__init__.py",
          "tests/compiler/test_default_settings.py||tests/compiler/test_default_settings.py",
          "tests/conftest.py||tests/conftest.py",
          "tests/parser/functions/test_slice.py||tests/parser/functions/test_slice.py",
          "tests/parser/test_selector_table.py||tests/parser/test_selector_table.py",
          "vyper/ast/grammar.lark||vyper/ast/grammar.lark",
          "vyper/cli/vyper_compile.py||vyper/cli/vyper_compile.py",
          "vyper/cli/vyper_ir.py||vyper/cli/vyper_ir.py",
          "vyper/codegen/core.py||vyper/codegen/core.py",
          "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py",
          "vyper/codegen/jumptable_utils.py||vyper/codegen/jumptable_utils.py",
          "vyper/codegen/module.py||vyper/codegen/module.py",
          "vyper/compiler/output.py||vyper/compiler/output.py",
          "vyper/compiler/settings.py||vyper/compiler/settings.py",
          "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/base_conftest.py||tests/base_conftest.py": [
          "File: tests/base_conftest.py -> tests/base_conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:     return w3",
          "116:     settings = Settings()",
          "117:     settings.evm_version = kwargs.pop(\"evm_version\", None)",
          "119:     out = compiler.compile_code(",
          "120:         source_code,",
          "121:         # test that metadata gets generated",
          "",
          "[Removed Lines]",
          "115: def _get_contract(w3, source_code, optimize, *args, **kwargs):",
          "118:     settings.optimize = optimize",
          "",
          "[Added Lines]",
          "115: def _get_contract(w3, source_code, optimize, *args, override_opt_level=None, **kwargs):",
          "118:     settings.optimize = override_opt_level or optimize",
          "",
          "---------------"
        ],
        "tests/cli/vyper_json/test_parse_args_vyperjson.py||tests/cli/vyper_json/test_parse_args_vyperjson.py": [
          "File: tests/cli/vyper_json/test_parse_args_vyperjson.py -> tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     _parse_args([path.absolute().as_posix()])",
          "58:     out, _ = capfd.readouterr()",
          "59:     output_json = json.loads(out)",
          "61:     assert \"contracts/foo.vy\" in output_json[\"sources\"]",
          "62:     assert \"contracts/bar.vy\" in output_json[\"sources\"]",
          "",
          "[Removed Lines]",
          "60:     assert _no_errors(output_json)",
          "",
          "[Added Lines]",
          "60:     assert _no_errors(output_json), (INPUT_JSON, output_json)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:     assert output_path.exists()",
          "72:     with output_path.open() as fp:",
          "73:         output_json = json.load(fp)",
          "75:     assert \"contracts/foo.vy\" in output_json[\"sources\"]",
          "76:     assert \"contracts/bar.vy\" in output_json[\"sources\"]",
          "",
          "[Removed Lines]",
          "74:     assert _no_errors(output_json)",
          "",
          "[Added Lines]",
          "74:     assert _no_errors(output_json), (INPUT_JSON, output_json)",
          "",
          "---------------"
        ],
        "tests/compiler/__init__.py||tests/compiler/__init__.py": [
          "File: tests/compiler/__init__.py -> tests/compiler/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # prevent module name collision between tests/compiler/test_pre_parser.py",
          "2: # and tests/ast/test_pre_parser.py",
          "",
          "---------------"
        ],
        "tests/compiler/test_default_settings.py||tests/compiler/test_default_settings.py": [
          "File: tests/compiler/test_default_settings.py -> tests/compiler/test_default_settings.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: from vyper.codegen import core",
          "2: from vyper.compiler.phases import CompilerData",
          "3: from vyper.compiler.settings import OptimizationLevel, _is_debug_mode",
          "6: def test_default_settings():",
          "7:     source_code = \"\"",
          "8:     compiler_data = CompilerData(source_code)",
          "9:     _ = compiler_data.vyper_module  # force settings to be computed",
          "11:     assert compiler_data.settings.optimize == OptimizationLevel.GAS",
          "14: def test_default_opt_level():",
          "15:     assert OptimizationLevel.default() == OptimizationLevel.GAS",
          "18: def test_codegen_opt_level():",
          "19:     assert core._opt_level == OptimizationLevel.GAS",
          "20:     assert core._opt_gas() is True",
          "21:     assert core._opt_none() is False",
          "22:     assert core._opt_codesize() is False",
          "25: def test_debug_mode(pytestconfig):",
          "26:     debug_mode = pytestconfig.getoption(\"enable_compiler_debug_mode\")",
          "27:     assert _is_debug_mode() == debug_mode",
          "",
          "---------------"
        ],
        "tests/conftest.py||tests/conftest.py": [
          "File: tests/conftest.py -> tests/conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: from vyper import compiler",
          "12: from vyper.codegen.ir_node import IRnode",
          "14: from vyper.ir import compile_ir, optimizer",
          "16: from .base_conftest import VyperContract, _get_contract, zero_gas_price_strategy",
          "",
          "[Removed Lines]",
          "13: from vyper.compiler.settings import OptimizationLevel",
          "",
          "[Added Lines]",
          "13: from vyper.compiler.settings import OptimizationLevel, _set_debug_mode",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:         default=\"gas\",",
          "44:         help=\"change optimization mode\",",
          "45:     )",
          "48: @pytest.fixture(scope=\"module\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     parser.addoption(\"--enable-compiler-debug-mode\", action=\"store_true\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51:     return OptimizationLevel.from_string(flag)",
          "54: @pytest.fixture",
          "55: def keccak():",
          "56:     return Web3.keccak",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: @pytest.fixture(scope=\"session\", autouse=True)",
          "56: def debug(pytestconfig):",
          "57:     debug = pytestconfig.getoption(\"enable_compiler_debug_mode\")",
          "58:     assert isinstance(debug, bool)",
          "59:     _set_debug_mode(debug)",
          "",
          "---------------"
        ],
        "tests/parser/functions/test_slice.py||tests/parser/functions/test_slice.py": [
          "File: tests/parser/functions/test_slice.py -> tests/parser/functions/test_slice.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import pytest",
          "3: from hypothesis import given, settings",
          "5: from vyper.exceptions import ArgumentException, TypeMismatch",
          "7: _fun_bytes32_bounds = [(0, 32), (3, 29), (27, 5), (0, 5), (5, 3), (30, 2)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: from vyper.compiler.settings import OptimizationLevel",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: @pytest.mark.parametrize(\"literal_start\", (True, False))",
          "35: @pytest.mark.parametrize(\"literal_length\", (True, False))",
          "36: @given(start=_draw_1024, length=_draw_1024, length_bound=_draw_1024_1, bytesdata=_bytes_1024)",
          "38: def test_slice_immutable(",
          "39:     get_contract,",
          "40:     assert_compile_failed,",
          "41:     assert_tx_failed,",
          "42:     bytesdata,",
          "43:     start,",
          "44:     literal_start,",
          "",
          "[Removed Lines]",
          "37: @settings(max_examples=25, deadline=None)",
          "",
          "[Added Lines]",
          "37: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "39: @settings(max_examples=100, deadline=None)",
          "40: @pytest.mark.fuzzing",
          "45:     opt_level,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:     \"\"\"",
          "66:     def _get_contract():",
          "69:     if (",
          "70:         (start + length > length_bound and literal_start and literal_length)",
          "",
          "[Removed Lines]",
          "67:         return get_contract(code, bytesdata, start, length)",
          "",
          "[Added Lines]",
          "71:         return get_contract(code, bytesdata, start, length, override_opt_level=opt_level)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84: @pytest.mark.parametrize(\"location\", (\"storage\", \"calldata\", \"memory\", \"literal\", \"code\"))",
          "85: @pytest.mark.parametrize(\"literal_start\", (True, False))",
          "86: @pytest.mark.parametrize(\"literal_length\", (True, False))",
          "87: @given(start=_draw_1024, length=_draw_1024, length_bound=_draw_1024_1, bytesdata=_bytes_1024)",
          "89: def test_slice_bytes(",
          "90:     get_contract,",
          "91:     assert_compile_failed,",
          "92:     assert_tx_failed,",
          "93:     location,",
          "94:     bytesdata,",
          "95:     start,",
          "",
          "[Removed Lines]",
          "88: @settings(max_examples=25, deadline=None)",
          "",
          "[Added Lines]",
          "91: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "93: @settings(max_examples=100, deadline=None)",
          "94: @pytest.mark.fuzzing",
          "99:     opt_level,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:     \"\"\"",
          "135:     def _get_contract():",
          "138:     data_length = len(bytesdata) if location == \"literal\" else length_bound",
          "139:     if (",
          "",
          "[Removed Lines]",
          "136:         return get_contract(code, bytesdata)",
          "",
          "[Added Lines]",
          "143:         return get_contract(code, bytesdata, override_opt_level=opt_level)",
          "",
          "---------------"
        ],
        "tests/parser/test_selector_table.py||tests/parser/test_selector_table.py": [
          "File: tests/parser/test_selector_table.py -> tests/parser/test_selector_table.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import hypothesis.strategies as st",
          "2: import pytest",
          "3: from hypothesis import given, settings",
          "5: import vyper.utils as utils",
          "6: from vyper.codegen.jumptable_utils import (",
          "7:     generate_dense_jumptable_info,",
          "8:     generate_sparse_jumptable_buckets,",
          "9: )",
          "10: from vyper.compiler.settings import OptimizationLevel",
          "13: @given(",
          "14:     n_methods=st.integers(min_value=1, max_value=100),",
          "15:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "16: )",
          "17: @pytest.mark.fuzzing",
          "18: @settings(max_examples=10, deadline=None)",
          "19: def test_sparse_jumptable_probe_depth(n_methods, seed):",
          "20:     sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "21:     _, buckets = generate_sparse_jumptable_buckets(sigs)",
          "22:     bucket_sizes = [len(bucket) for bucket in buckets.values()]",
          "24:     # generally bucket sizes should be bounded at around 4, but",
          "25:     # just test that they don't get really out of hand",
          "26:     assert max(bucket_sizes) <= 8",
          "28:     # generally mean bucket size should be around 1.6, here just",
          "29:     # test they don't get really out of hand",
          "30:     assert sum(bucket_sizes) / len(bucket_sizes) <= 4",
          "33: @given(",
          "34:     n_methods=st.integers(min_value=4, max_value=100),",
          "35:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "36: )",
          "37: @pytest.mark.fuzzing",
          "38: @settings(max_examples=10, deadline=None)",
          "39: def test_dense_jumptable_bucket_size(n_methods, seed):",
          "40:     sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "41:     n = len(sigs)",
          "42:     buckets = generate_dense_jumptable_info(sigs)",
          "43:     n_buckets = len(buckets)",
          "45:     # generally should be around 14 buckets per 100 methods, here",
          "46:     # we test they don't get really out of hand",
          "47:     assert n_buckets / n < 0.4 or n < 10",
          "50: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "51: # dense selector table packing boundaries at 256 and 65336",
          "52: @pytest.mark.parametrize(\"max_calldata_bytes\", [255, 256, 65336])",
          "53: @settings(max_examples=5, deadline=None)",
          "54: @given(",
          "55:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "56:     max_default_args=st.integers(min_value=0, max_value=4),",
          "57:     default_fn_mutability=st.sampled_from([\"\", \"@pure\", \"@view\", \"@nonpayable\", \"@payable\"]),",
          "58: )",
          "59: @pytest.mark.fuzzing",
          "60: def test_selector_table_fuzz(",
          "61:     max_calldata_bytes,",
          "62:     seed,",
          "63:     max_default_args,",
          "64:     opt_level,",
          "65:     default_fn_mutability,",
          "66:     w3,",
          "67:     get_contract,",
          "68:     assert_tx_failed,",
          "69:     get_logs,",
          "70: ):",
          "71:     def abi_sig(calldata_words, i, n_default_args):",
          "72:         args = [] if not calldata_words else [f\"uint256[{calldata_words}]\"]",
          "73:         args.extend([\"uint256\"] * n_default_args)",
          "74:         argstr = \",\".join(args)",
          "75:         return f\"foo{seed + i}({argstr})\"",
          "77:     def generate_func_def(mutability, calldata_words, i, n_default_args):",
          "78:         arglist = [] if not calldata_words else [f\"x: uint256[{calldata_words}]\"]",
          "79:         for j in range(n_default_args):",
          "80:             arglist.append(f\"x{j}: uint256 = 0\")",
          "81:         args = \", \".join(arglist)",
          "82:         _log_return = f\"log _Return({i})\" if mutability == \"@payable\" else \"\"",
          "84:         return f\"\"\"",
          "85: @external",
          "86: {mutability}",
          "87: def foo{seed + i}({args}) -> uint256:",
          "88:     {_log_return}",
          "89:     return {i}",
          "90:     \"\"\"",
          "92:     @given(",
          "93:         methods=st.lists(",
          "94:             st.tuples(",
          "95:                 st.sampled_from([\"@pure\", \"@view\", \"@nonpayable\", \"@payable\"]),",
          "96:                 st.integers(min_value=0, max_value=max_calldata_bytes // 32),",
          "97:                 # n bytes to strip from calldata",
          "98:                 st.integers(min_value=1, max_value=4),",
          "99:                 # n default args",
          "100:                 st.integers(min_value=0, max_value=max_default_args),",
          "101:             ),",
          "102:             min_size=1,",
          "103:             max_size=100,",
          "104:         )",
          "105:     )",
          "106:     @settings(max_examples=25)",
          "107:     def _test(methods):",
          "108:         func_defs = \"\\n\".join(",
          "109:             generate_func_def(m, s, i, d) for i, (m, s, _, d) in enumerate(methods)",
          "110:         )",
          "112:         if default_fn_mutability == \"\":",
          "113:             default_fn_code = \"\"",
          "114:         elif default_fn_mutability in (\"@nonpayable\", \"@payable\"):",
          "115:             default_fn_code = f\"\"\"",
          "116: @external",
          "117: {default_fn_mutability}",
          "118: def __default__():",
          "119:     log CalledDefault()",
          "120:             \"\"\"",
          "121:         else:",
          "122:             # can't log from pure/view functions, just test that it returns",
          "123:             default_fn_code = \"\"\"",
          "124: @external",
          "125: def __default__():",
          "126:     pass",
          "127:             \"\"\"",
          "129:         code = f\"\"\"",
          "130: event CalledDefault:",
          "131:     pass",
          "133: event _Return:",
          "134:     val: uint256",
          "136: {func_defs}",
          "138: {default_fn_code}",
          "139:         \"\"\"",
          "141:         c = get_contract(code, override_opt_level=opt_level)",
          "143:         for i, (mutability, n_calldata_words, n_strip_bytes, n_default_args) in enumerate(methods):",
          "144:             funcname = f\"foo{seed + i}\"",
          "145:             func = getattr(c, funcname)",
          "147:             for j in range(n_default_args + 1):",
          "148:                 args = [[1] * n_calldata_words] if n_calldata_words else []",
          "149:                 args.extend([1] * j)",
          "151:                 # check the function returns as expected",
          "152:                 assert func(*args) == i",
          "154:                 method_id = utils.method_id(abi_sig(n_calldata_words, i, j))",
          "156:                 argsdata = b\"\\x00\" * (n_calldata_words * 32 + j * 32)",
          "158:                 # do payable check",
          "159:                 if mutability == \"@payable\":",
          "160:                     tx = func(*args, transact={\"value\": 1})",
          "161:                     (event,) = get_logs(tx, c, \"_Return\")",
          "162:                     assert event.args.val == i",
          "163:                 else:",
          "164:                     hexstr = (method_id + argsdata).hex()",
          "165:                     txdata = {\"to\": c.address, \"data\": hexstr, \"value\": 1}",
          "166:                     assert_tx_failed(lambda: w3.eth.send_transaction(txdata))",
          "168:                 # now do calldatasize check",
          "169:                 # strip some bytes",
          "170:                 calldata = (method_id + argsdata)[:-n_strip_bytes]",
          "171:                 hexstr = calldata.hex()",
          "172:                 tx_params = {\"to\": c.address, \"data\": hexstr}",
          "173:                 if n_calldata_words == 0 and j == 0:",
          "174:                     # no args, hit default function",
          "175:                     if default_fn_mutability == \"\":",
          "176:                         assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "177:                     elif default_fn_mutability == \"@payable\":",
          "178:                         # we should be able to send eth to it",
          "179:                         tx_params[\"value\"] = 1",
          "180:                         tx = w3.eth.send_transaction(tx_params)",
          "181:                         logs = get_logs(tx, c, \"CalledDefault\")",
          "182:                         assert len(logs) == 1",
          "183:                     else:",
          "184:                         tx = w3.eth.send_transaction(tx_params)",
          "186:                         # note: can't emit logs from view/pure functions,",
          "187:                         # so the logging is not tested.",
          "188:                         if default_fn_mutability == \"@nonpayable\":",
          "189:                             logs = get_logs(tx, c, \"CalledDefault\")",
          "190:                             assert len(logs) == 1",
          "192:                         # check default function reverts",
          "193:                         tx_params[\"value\"] = 1",
          "194:                         assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "195:                 else:",
          "196:                     assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "198:     _test()",
          "",
          "---------------"
        ],
        "vyper/ast/grammar.lark||vyper/ast/grammar.lark": [
          "File: vyper/ast/grammar.lark -> vyper/ast/grammar.lark",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: _EVENT_DECL: \"event\"",
          "73: event_member: NAME \":\" type",
          "74: indexed_event_arg: NAME \":\" \"indexed\" \"(\" type \")\"",
          "77: event_def: _EVENT_DECL NAME \":\" ( event_body | _PASS )",
          "",
          "[Removed Lines]",
          "75: event_body: _NEWLINE _INDENT ((event_member | indexed_event_arg) _NEWLINE)+ _DEDENT",
          "",
          "[Added Lines]",
          "76: event_body: _NEWLINE _INDENT (((event_member | indexed_event_arg ) _NEWLINE)+ | _PASS _NEWLINE) _DEDENT",
          "",
          "---------------"
        ],
        "vyper/cli/vyper_compile.py||vyper/cli/vyper_compile.py": [
          "File: vyper/cli/vyper_compile.py -> vyper/cli/vyper_compile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: import vyper.codegen.ir_node as ir_node",
          "12: from vyper.cli import vyper_json",
          "13: from vyper.cli.utils import extract_file_interface_imports, get_interface_file_path",
          "15: from vyper.evm.opcodes import DEFAULT_EVM_VERSION, EVM_VERSIONS",
          "16: from vyper.typing import ContractCodes, ContractPath, OutputFormats",
          "",
          "[Removed Lines]",
          "14: from vyper.compiler.settings import VYPER_TRACEBACK_LIMIT, OptimizationLevel, Settings",
          "",
          "[Added Lines]",
          "14: from vyper.compiler.settings import (",
          "15:     VYPER_TRACEBACK_LIMIT,",
          "16:     OptimizationLevel,",
          "17:     Settings,",
          "18:     _set_debug_mode,",
          "19: )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:         dest=\"evm_version\",",
          "106:     )",
          "107:     parser.add_argument(\"--no-optimize\", help=\"Do not optimize\", action=\"store_true\")",
          "109:     parser.add_argument(",
          "110:         \"--no-bytecode-metadata\", help=\"Do not add metadata to bytecode\", action=\"store_true\"",
          "111:     )",
          "",
          "[Removed Lines]",
          "108:     parser.add_argument(\"--optimize\", help=\"Optimization flag\", choices=[\"gas\", \"codesize\", \"none\"])",
          "",
          "[Added Lines]",
          "113:     parser.add_argument(",
          "114:         \"--optimize\",",
          "115:         help=\"Optimization flag (defaults to 'gas')\",",
          "116:         choices=[\"gas\", \"codesize\", \"none\"],",
          "117:     )",
          "118:     parser.add_argument(\"--debug\", help=\"Compile in debug mode\", action=\"store_true\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:     output_formats = tuple(uniq(args.format.split(\",\")))",
          "154:     if args.no_optimize and args.optimize:",
          "155:         raise ValueError(\"Cannot use `--no-optimize` and `--optimize` at the same time!\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:     if args.debug:",
          "165:         _set_debug_mode(True)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165:         settings.evm_version = args.evm_version",
          "167:     if args.verbose:",
          "170:     compiled = compile_files(",
          "171:         args.input_files,",
          "",
          "[Removed Lines]",
          "168:         print(f\"using `{settings}`\", file=sys.stderr)",
          "",
          "[Added Lines]",
          "181:         print(f\"cli specified: `{settings}`\", file=sys.stderr)",
          "",
          "---------------"
        ],
        "vyper/cli/vyper_ir.py||vyper/cli/vyper_ir.py": [
          "File: vyper/cli/vyper_ir.py -> vyper/cli/vyper_ir.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:         compiler_data[\"asm\"] = asm",
          "57:     if \"bytecode\" in output_formats:",
          "59:         compiler_data[\"bytecode\"] = \"0x\" + bytecode.hex()",
          "61:     return compiler_data",
          "",
          "[Removed Lines]",
          "58:         (bytecode, _srcmap) = compile_ir.assembly_to_evm(asm)",
          "",
          "[Added Lines]",
          "58:         bytecode, _ = compile_ir.assembly_to_evm(asm)",
          "",
          "---------------"
        ],
        "vyper/codegen/core.py||vyper/codegen/core.py": [
          "File: vyper/codegen/core.py -> vyper/codegen/core.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1033:     return None",
          "1037: def is_return_from_function(node):",
          "1038:     if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") in (",
          "1039:         \"raw_revert\",",
          "",
          "[Removed Lines]",
          "1036: # TODO move return checks to vyper/semantics/validation",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1045:     return False",
          "1048: def check_single_exit(fn_node):",
          "1049:     _check_return_body(fn_node, fn_node.body)",
          "1050:     for node in fn_node.get_descendants(vy_ast.If):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1047: # TODO this is almost certainly duplicated with check_terminus_node",
          "1048: # in vyper/semantics/analysis/local.py",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py": [
          "File: vyper/codegen/function_definitions/__init__.py -> vyper/codegen/function_definitions/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: from .common import generate_ir_for_function  # noqa",
          "",
          "[Added Lines]",
          "1: from .common import FuncIR, generate_ir_for_function  # noqa",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py": [
          "File: vyper/codegen/function_definitions/common.py -> vyper/codegen/function_definitions/common.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: import vyper.ast as vy_ast",
          "6: from vyper.codegen.context import Constancy, Context",
          "8: from vyper.codegen.function_definitions.external_function import generate_ir_for_external_function",
          "9: from vyper.codegen.function_definitions.internal_function import generate_ir_for_internal_function",
          "10: from vyper.codegen.global_context import GlobalContext",
          "",
          "[Removed Lines]",
          "7: from vyper.codegen.core import check_single_exit, getpos",
          "",
          "[Added Lines]",
          "7: from vyper.codegen.core import check_single_exit",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:         return self.ir_identifier + suffix",
          "66: def generate_ir_for_function(",
          "72:     \"\"\"",
          "73:     Parse a function and produce IR code for the function, includes:",
          "74:         - Signature method if statement",
          "",
          "[Removed Lines]",
          "67:     code: vy_ast.FunctionDef,",
          "68:     global_ctx: GlobalContext,",
          "69:     skip_nonpayable_check: bool,",
          "70:     is_ctor_context: bool = False,",
          "71: ) -> IRnode:",
          "",
          "[Added Lines]",
          "66: class FuncIR:",
          "67:     pass",
          "70: @dataclass",
          "71: class EntryPointInfo:",
          "72:     func_t: ContractFunctionT",
          "73:     min_calldatasize: int  # the min calldata required for this entry point",
          "74:     ir_node: IRnode  # the ir for this entry point",
          "77: @dataclass",
          "78: class ExternalFuncIR(FuncIR):",
          "79:     entry_points: dict[str, EntryPointInfo]  # map from abi sigs to entry points",
          "80:     common_ir: IRnode  # the \"common\" code for the function",
          "83: @dataclass",
          "84: class InternalFuncIR(FuncIR):",
          "85:     func_ir: IRnode  # the code for the function",
          "88: # TODO: should split this into external and internal ir generation?",
          "90:     code: vy_ast.FunctionDef, global_ctx: GlobalContext, is_ctor_context: bool = False",
          "91: ) -> FuncIR:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "82:     func_t._ir_info = _FuncIRInfo(func_t)",
          "84:     # Validate return statements.",
          "85:     check_single_exit(code)",
          "87:     callees = func_t.called_functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105:     # XXX: This should really be in semantics pass.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106:     )",
          "108:     if func_t.is_internal:",
          "111:     else:",
          "118:     frame_size = context.memory_allocator.size_of_mem - MemoryPositions.RESERVED_MEMORY",
          "120:     frame_info = FrameInfo(allocate_start, frame_size, context.vars)",
          "122:     if func_t._ir_info.frame_info is None:",
          "123:         func_t._ir_info.set_frame_info(frame_info)",
          "124:     else:",
          "",
          "[Removed Lines]",
          "109:         assert skip_nonpayable_check is False",
          "110:         o = generate_ir_for_internal_function(code, func_t, context)",
          "112:         if func_t.is_payable:",
          "113:             assert skip_nonpayable_check is False  # nonsense",
          "114:         o = generate_ir_for_external_function(code, func_t, context, skip_nonpayable_check)",
          "116:     o.source_pos = getpos(code)",
          "",
          "[Added Lines]",
          "130:         ret: FuncIR = InternalFuncIR(generate_ir_for_internal_function(code, func_t, context))",
          "131:         func_t._ir_info.gas_estimate = ret.func_ir.gas  # type: ignore",
          "133:         kwarg_handlers, common = generate_ir_for_external_function(code, func_t, context)",
          "134:         entry_points = {",
          "135:             k: EntryPointInfo(func_t, mincalldatasize, ir_node)",
          "136:             for k, (mincalldatasize, ir_node) in kwarg_handlers.items()",
          "137:         }",
          "138:         ret = ExternalFuncIR(entry_points, common)",
          "139:         # note: this ignores the cost of traversing selector table",
          "140:         func_t._ir_info.gas_estimate = ret.common_ir.gas",
          "146:     # XXX: when can this happen?",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:         # adjust gas estimate to include cost of mem expansion",
          "129:         # frame_size of external function includes all private functions called",
          "130:         # (note: internal functions do not need to adjust gas estimate since",
          "",
          "[Removed Lines]",
          "131:         # it is already accounted for by the caller.)",
          "132:         o.add_gas_estimate += calc_mem_gas(func_t._ir_info.frame_info.mem_used)  # type: ignore",
          "134:     func_t._ir_info.gas_estimate = o.gas",
          "136:     return o",
          "",
          "[Added Lines]",
          "156:         mem_expansion_cost = calc_mem_gas(func_t._ir_info.frame_info.mem_used)  # type: ignore",
          "157:         ret.common_ir.add_gas_estimate += mem_expansion_cost  # type: ignore",
          "159:     return ret",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: from vyper.codegen.abi_encoder import abi_encoding_matches_vyper",
          "5: from vyper.codegen.context import Context, VariableRecord",
          "6: from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp",
          "",
          "[Removed Lines]",
          "1: from typing import Any, List",
          "3: import vyper.utils as util",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16: # register function args with the local calling context.",
          "17: # also allocate the ones that live in memory (i.e. kwargs)",
          "19:     ret = []",
          "20:     # the type of the calldata",
          "21:     base_args_t = TupleT(tuple(arg.typ for arg in func_t.positional_args))",
          "",
          "[Removed Lines]",
          "18: def _register_function_args(func_t: ContractFunctionT, context: Context) -> List[IRnode]:",
          "",
          "[Added Lines]",
          "15: def _register_function_args(func_t: ContractFunctionT, context: Context) -> list[IRnode]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:     return ret",
          "62:     # generate kwarg handlers.",
          "63:     # since they might come in thru calldata or be default,",
          "64:     # allocate them in memory and then fill it in based on calldata or default,",
          "",
          "[Removed Lines]",
          "55: def _annotated_method_id(abi_sig):",
          "56:     method_id = util.method_id_int(abi_sig)",
          "57:     annotation = f\"{hex(method_id)}: {abi_sig}\"",
          "58:     return IRnode(method_id, annotation=annotation)",
          "61: def _generate_kwarg_handlers(func_t: ContractFunctionT, context: Context) -> List[Any]:",
          "",
          "[Added Lines]",
          "52: def _generate_kwarg_handlers(",
          "53:     func_t: ContractFunctionT, context: Context",
          "54: ) -> dict[str, tuple[int, IRnode]]:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "75:         calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))",
          "77:         abi_sig = func_t.abi_signature_for_kwargs(calldata_kwargs)",
          "80:         calldata_kwargs_ofst = IRnode(",
          "81:             4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI",
          "",
          "[Removed Lines]",
          "78:         method_id = _annotated_method_id(abi_sig)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "88:         args_abi_t = calldata_args_t.abi_type",
          "89:         calldata_min_size = args_abi_t.min_size() + 4",
          "96:         # TODO optimize make_setter by using",
          "97:         # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
          "98:         # (must ensure memory area is contiguous)",
          "",
          "[Removed Lines]",
          "91:         # note we don't need the check if calldata_min_size == 4,",
          "92:         # because the global calldatasize check ensures that already.",
          "93:         if calldata_min_size > 4:",
          "94:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "124:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "132:     keyword_args = func_t.keyword_args",
          "",
          "[Removed Lines]",
          "126:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "127:         ret = [\"if\", method_id_check, ret]",
          "128:         return ret",
          "130:     ret = [\"seq\"]",
          "",
          "[Added Lines]",
          "113:         # return something we can turn into ExternalFuncIR",
          "114:         return abi_sig, calldata_min_size, ret",
          "116:     ret = {}",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "139:         calldata_kwargs = keyword_args[:i]",
          "140:         default_kwargs = keyword_args[i:]",
          "146:     return ret",
          "",
          "[Removed Lines]",
          "142:         ret.append(handler_for(calldata_kwargs, default_kwargs))",
          "144:     ret.append(handler_for(keyword_args, []))",
          "",
          "[Added Lines]",
          "128:         sig, calldata_min_size, ir_node = handler_for(calldata_kwargs, default_kwargs)",
          "129:         ret[sig] = calldata_min_size, ir_node",
          "131:     sig, calldata_min_size, ir_node = handler_for(keyword_args, [])",
          "133:     ret[sig] = calldata_min_size, ir_node",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "149: # TODO it would be nice if this returned a data structure which were",
          "150: # amenable to generating a jump table instead of the linear search for",
          "151: # method_id we have now.",
          "153:     # TODO type hints:",
          "154:     # def generate_ir_for_external_function(",
          "155:     #    code: vy_ast.FunctionDef,",
          "",
          "[Removed Lines]",
          "152: def generate_ir_for_external_function(code, func_t, context, skip_nonpayable_check):",
          "",
          "[Added Lines]",
          "141: def generate_ir_for_external_function(code, func_t, context):",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "174:     # generate the main body of the function",
          "175:     body += handle_base_args",
          "185:     body += nonreentrant_pre",
          "187:     body += [parse_body(code.body, context, ensure_terminated=True)]",
          "",
          "[Removed Lines]",
          "177:     if not func_t.is_payable and not skip_nonpayable_check:",
          "178:         # if the contract contains payable functions, but this is not one of them",
          "179:         # add an assertion that the value of the call is zero",
          "180:         nonpayable_check = IRnode.from_list(",
          "181:             [\"assert\", [\"iszero\", \"callvalue\"]], error_msg=\"nonpayable check\"",
          "182:         )",
          "183:         body.append(nonpayable_check)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "201:     if context.return_type is not None:",
          "202:         exit_sequence_args += [\"ret_ofst\", \"ret_len\"]",
          "203:     # wrap the exit in a labeled block",
          "206:     # the ir which comprises the main body of the function,",
          "207:     # besides any kwarg handling",
          "",
          "[Removed Lines]",
          "204:     exit = [\"label\", func_t._ir_info.exit_sequence_label, exit_sequence_args, exit_sequence]",
          "208:     func_common_ir = [\"seq\", body, exit]",
          "210:     if func_t.is_fallback or func_t.is_constructor:",
          "211:         ret = [\"seq\"]",
          "212:         # add a goto to make the function entry look like other functions",
          "213:         # (for zksync interpreter)",
          "214:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "215:         ret.append(func_common_ir)",
          "216:     else:",
          "217:         ret = kwarg_handlers",
          "218:         # sneak the base code into the kwarg handler",
          "219:         # TODO rethink this / make it clearer",
          "220:         ret[-1][-1].append(func_common_ir)",
          "222:     return IRnode.from_list(ret, source_pos=getpos(code))",
          "",
          "[Added Lines]",
          "185:     exit_ = [\"label\", func_t._ir_info.exit_sequence_label, exit_sequence_args, exit_sequence]",
          "189:     func_common_ir = IRnode.from_list([\"seq\", body, exit_], source_pos=getpos(code))",
          "191:     return kwarg_handlers, func_common_ir",
          "",
          "---------------"
        ],
        "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py": [
          "File: vyper/codegen/ir_node.py -> vyper/codegen/ir_node.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:             self.valency = 1",
          "150:             self._gas = 5",
          "151:         elif isinstance(self.value, str):",
          "152:             # Opcodes and pseudo-opcodes (e.g. clamp)",
          "153:             if self.value.upper() in get_ir_opcodes():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:         elif isinstance(self.value, bytes):",
          "152:             # a literal bytes value, probably inside a \"data\" node.",
          "153:             _check(len(self.args) == 0, \"bytes can't have arguments\")",
          "155:             self.valency = 0",
          "156:             self._gas = 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:                 self.valency = 0",
          "265:                 self._gas = sum([arg.gas for arg in self.args])",
          "266:             elif self.value == \"label\":",
          "269:                 self.valency = 0",
          "270:                 self._gas = 1 + sum(t.gas for t in self.args)",
          "271:             elif self.value == \"unique_symbol\":",
          "",
          "[Removed Lines]",
          "267:                 if not self.args[1].value == \"var_list\":",
          "268:                     raise CodegenPanic(f\"2nd argument to label must be var_list, {self}\")",
          "",
          "[Added Lines]",
          "274:                 _check(",
          "275:                     self.args[1].value == \"var_list\",",
          "276:                     f\"2nd argument to label must be var_list, {self}\",",
          "277:                 )",
          "278:                 _check(len(args) == 3, f\"label should have 3 args but has {len(args)}, {self}\")",
          "",
          "---------------"
        ],
        "vyper/codegen/jumptable_utils.py||vyper/codegen/jumptable_utils.py": [
          "File: vyper/codegen/jumptable_utils.py -> vyper/codegen/jumptable_utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # helper module which implements jumptable for function selection",
          "2: import math",
          "3: from dataclasses import dataclass",
          "5: from vyper.utils import method_id_int",
          "8: @dataclass",
          "9: class Signature:",
          "10:     method_id: int",
          "11:     payable: bool",
          "14: # bucket for dense function",
          "15: @dataclass",
          "16: class Bucket:",
          "17:     bucket_id: int",
          "18:     magic: int",
          "19:     method_ids: list[int]",
          "21:     @property",
          "22:     def image(self):",
          "23:         return _image_of([s for s in self.method_ids], self.magic)",
          "25:     @property",
          "26:     # return method ids, sorted by by their image",
          "27:     def method_ids_image_order(self):",
          "28:         return [x[1] for x in sorted(zip(self.image, self.method_ids))]",
          "30:     @property",
          "31:     def bucket_size(self):",
          "32:         return len(self.method_ids)",
          "35: BITS_MAGIC = 24  # a constant which produced good results, see _bench_dense()",
          "38: def _image_of(xs, magic):",
          "39:     bits_shift = BITS_MAGIC",
          "41:     # take the upper bits from the multiplication for more entropy",
          "42:     # can we do better using primes of some sort?",
          "43:     return [((x * magic) >> bits_shift) % len(xs) for x in xs]",
          "46: class _Failure(Exception):",
          "47:     pass",
          "50: def find_magic_for(xs):",
          "51:     for m in range(2**16):",
          "52:         test = _image_of(xs, m)",
          "53:         if len(test) == len(set(test)):",
          "54:             return m",
          "56:     raise _Failure(f\"Could not find hash for {xs}\")",
          "59: def _mk_buckets(method_ids, n_buckets):",
          "60:     buckets = {}",
          "61:     for x in method_ids:",
          "62:         t = x % n_buckets",
          "63:         buckets.setdefault(t, [])",
          "64:         buckets[t].append(x)",
          "65:     return buckets",
          "68: # two layer method for generating perfect hash",
          "69: # first get \"reasonably good\" distribution by using",
          "70: # method_id % len(method_ids)",
          "71: # second, get the magic for the bucket.",
          "72: def _dense_jumptable_info(method_ids, n_buckets):",
          "73:     buckets = _mk_buckets(method_ids, n_buckets)",
          "75:     ret = {}",
          "76:     for bucket_id, method_ids in buckets.items():",
          "77:         magic = find_magic_for(method_ids)",
          "78:         ret[bucket_id] = Bucket(bucket_id, magic, method_ids)",
          "80:     return ret",
          "83: START_BUCKET_SIZE = 5",
          "86: # this is expensive! for 80 methods, costs about 350ms and probably",
          "87: # linear in # of methods.",
          "88: # see _bench_perfect()",
          "89: # note the buckets are NOT in order!",
          "90: def generate_dense_jumptable_info(signatures):",
          "91:     method_ids = [method_id_int(sig) for sig in signatures]",
          "92:     n = len(signatures)",
          "93:     # start at bucket size of 5 and try to improve (generally",
          "94:     # speaking we want as few buckets as possible)",
          "95:     n_buckets = (n // START_BUCKET_SIZE) + 1",
          "96:     ret = None",
          "97:     tried_exhaustive = False",
          "98:     while n_buckets > 0:",
          "99:         try:",
          "100:             # print(f\"trying {n_buckets} (bucket size {n // n_buckets})\")",
          "101:             ret = _dense_jumptable_info(method_ids, n_buckets)",
          "102:         except _Failure:",
          "103:             if ret is not None:",
          "104:                 break",
          "106:             # we have not tried exhaustive search. try really hard",
          "107:             # to find a valid jumptable at the cost of performance",
          "108:             if not tried_exhaustive:",
          "109:                 # print(\"failed with guess! trying exhaustive search.\")",
          "110:                 n_buckets = n",
          "111:                 tried_exhaustive = True",
          "112:                 continue",
          "113:             else:",
          "114:                 raise RuntimeError(f\"Could not generate jumptable! {signatures}\")",
          "115:         n_buckets -= 1",
          "117:     return ret",
          "120: # note the buckets are NOT in order!",
          "121: def generate_sparse_jumptable_buckets(signatures):",
          "122:     method_ids = [method_id_int(sig) for sig in signatures]",
          "123:     n = len(signatures)",
          "125:     # search a range of buckets to try to minimize bucket size",
          "126:     # (doing the range search improves worst worst bucket size from 9 to 4,",
          "127:     # see _bench_sparse)",
          "128:     lo = max(1, math.floor(n * 0.85))",
          "129:     hi = max(1, math.ceil(n * 1.15))",
          "130:     stats = {}",
          "131:     for i in range(lo, hi + 1):",
          "132:         buckets = _mk_buckets(method_ids, i)",
          "134:         stats[i] = buckets",
          "136:     min_max_bucket_size = hi + 1  # smallest max_bucket_size",
          "137:     # find the smallest i which gives us the smallest max_bucket_size",
          "138:     for i, buckets in stats.items():",
          "139:         max_bucket_size = max(len(bucket) for bucket in buckets.values())",
          "140:         if max_bucket_size < min_max_bucket_size:",
          "141:             min_max_bucket_size = max_bucket_size",
          "142:             ret = i, buckets",
          "144:     assert ret is not None",
          "145:     return ret",
          "148: # benchmark for quality of buckets",
          "149: def _bench_dense(N=1_000, n_methods=100):",
          "150:     import random",
          "152:     stats = []",
          "153:     for i in range(N):",
          "154:         seed = random.randint(0, 2**64 - 1)",
          "155:         # \"large\" contracts in prod hit about ~50 methods, test with",
          "156:         # double the limit",
          "157:         sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "159:         xs = generate_dense_jumptable_info(sigs)",
          "160:         print(f\"found. n buckets {len(xs)}\")",
          "161:         stats.append(xs)",
          "163:     def mean(xs):",
          "164:         return sum(xs) / len(xs)",
          "166:     avg_n_buckets = mean([len(jt) for jt in stats])",
          "167:     # usually around ~14 buckets per 100 sigs",
          "168:     # N=10, time=3.6s",
          "169:     print(f\"average N buckets: {avg_n_buckets}\")",
          "172: def _bench_sparse(N=10_000, n_methods=80):",
          "173:     import random",
          "175:     stats = []",
          "176:     for _ in range(N):",
          "177:         seed = random.randint(0, 2**64 - 1)",
          "178:         sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "179:         _, buckets = generate_sparse_jumptable_buckets(sigs)",
          "181:         bucket_sizes = [len(bucket) for bucket in buckets.values()]",
          "182:         worst_bucket_size = max(bucket_sizes)",
          "183:         mean_bucket_size = sum(bucket_sizes) / len(bucket_sizes)",
          "184:         stats.append((worst_bucket_size, mean_bucket_size))",
          "186:     # N=10_000, time=9s",
          "187:     # range 0.85*n - 1.15*n",
          "188:     # worst worst bucket size: 4",
          "189:     # avg worst bucket size: 3.0018",
          "190:     # worst mean bucket size: 2.0",
          "191:     # avg mean bucket size: 1.579112583664968",
          "192:     print(\"worst worst bucket size:\", max(x[0] for x in stats))",
          "193:     print(\"avg worst bucket size:\", sum(x[0] for x in stats) / len(stats))",
          "194:     print(\"worst mean bucket size:\", max(x[1] for x in stats))",
          "195:     print(\"avg mean bucket size:\", sum(x[1] for x in stats) / len(stats))",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: from typing import Any, List",
          "5: from vyper.codegen.core import shr",
          "6: from vyper.codegen.function_definitions import generate_ir_for_function",
          "7: from vyper.codegen.global_context import GlobalContext",
          "8: from vyper.codegen.ir_node import IRnode",
          "9: from vyper.exceptions import CompilerPanic",
          "12: def _topsort_helper(functions, lookup):",
          "",
          "[Removed Lines]",
          "1: # a contract.vy -- all functions and constructor",
          "",
          "[Added Lines]",
          "1: # a compilation unit -- all functions and constructor",
          "5: from vyper.codegen import core, jumptable_utils",
          "10: from vyper.compiler.settings import _is_debug_mode",
          "12: from vyper.utils import method_id_int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     return func_ast._metadata[\"type\"].is_payable",
          "76:     if len(external_functions) == 0:",
          "101:         )",
          "138: # take a GlobalContext, and generate the runtime and deploy IR",
          "",
          "[Removed Lines]",
          "50: # codegen for all runtime functions + callvalue/calldata checks + method selector routines",
          "51: def _runtime_ir(runtime_functions, global_ctx):",
          "52:     # categorize the runtime functions because we will organize the runtime",
          "53:     # code into the following sections:",
          "54:     # payable functions, nonpayable functions, fallback function, internal_functions",
          "55:     internal_functions = [f for f in runtime_functions if _is_internal(f)]",
          "57:     external_functions = [f for f in runtime_functions if not _is_internal(f)]",
          "58:     default_function = next((f for f in external_functions if _is_fallback(f)), None)",
          "60:     # functions that need to go exposed in the selector section",
          "61:     regular_functions = [f for f in external_functions if not _is_fallback(f)]",
          "62:     payables = [f for f in regular_functions if _is_payable(f)]",
          "63:     nonpayables = [f for f in regular_functions if not _is_payable(f)]",
          "65:     # create a map of the IR functions since they might live in both",
          "66:     # runtime and deploy code (if init function calls them)",
          "67:     internal_functions_ir: list[IRnode] = []",
          "69:     for func_ast in internal_functions:",
          "70:         func_ir = generate_ir_for_function(func_ast, global_ctx, False)",
          "71:         internal_functions_ir.append(func_ir)",
          "73:     # for some reason, somebody may want to deploy a contract with no",
          "74:     # external functions, or more likely, a \"pure data\" contract which",
          "75:     # contains immutables",
          "77:         # TODO: prune internal functions in this case? dead code eliminator",
          "78:         # might not eliminate them, since internal function jumpdest is at the",
          "79:         # first instruction in the contract.",
          "80:         runtime = [\"seq\"] + internal_functions_ir",
          "81:         return runtime",
          "83:     # note: if the user does not provide one, the default fallback function",
          "84:     # reverts anyway. so it does not hurt to batch the payable check.",
          "85:     default_is_nonpayable = default_function is None or not _is_payable(default_function)",
          "87:     # when a contract has a nonpayable default function,",
          "88:     # we can do a single check for all nonpayable functions",
          "89:     batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable",
          "90:     skip_nonpayable_check = batch_payable_check",
          "92:     selector_section = [\"seq\"]",
          "94:     for func_ast in payables:",
          "95:         func_ir = generate_ir_for_function(func_ast, global_ctx, False)",
          "96:         selector_section.append(func_ir)",
          "98:     if batch_payable_check:",
          "99:         nonpayable_check = IRnode.from_list(",
          "100:             [\"assert\", [\"iszero\", \"callvalue\"]], error_msg=\"nonpayable check\"",
          "102:         selector_section.append(nonpayable_check)",
          "104:     for func_ast in nonpayables:",
          "105:         func_ir = generate_ir_for_function(func_ast, global_ctx, skip_nonpayable_check)",
          "106:         selector_section.append(func_ir)",
          "108:     if default_function:",
          "109:         fallback_ir = generate_ir_for_function(",
          "110:             default_function, global_ctx, skip_nonpayable_check=False",
          "111:         )",
          "112:     else:",
          "113:         fallback_ir = IRnode.from_list(",
          "114:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "115:         )",
          "117:     # ensure the external jumptable section gets closed out",
          "118:     # (for basic block hygiene and also for zksync interpreter)",
          "119:     # NOTE: this jump gets optimized out in assembly since the",
          "120:     # fallback label is the immediate next instruction,",
          "121:     close_selector_section = [\"goto\", \"fallback\"]",
          "123:     global_calldatasize_check = [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]]",
          "125:     runtime = [",
          "126:         \"seq\",",
          "127:         global_calldatasize_check,",
          "128:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
          "129:         close_selector_section,",
          "130:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "131:     ]",
          "133:     runtime.extend(internal_functions_ir)",
          "135:     return runtime",
          "",
          "[Added Lines]",
          "53: def _annotated_method_id(abi_sig):",
          "54:     method_id = method_id_int(abi_sig)",
          "55:     annotation = f\"{hex(method_id)}: {abi_sig}\"",
          "56:     return IRnode(method_id, annotation=annotation)",
          "59: def label_for_entry_point(abi_sig, entry_point):",
          "60:     method_id = method_id_int(abi_sig)",
          "61:     return f\"{entry_point.func_t._ir_info.ir_identifier}{method_id}\"",
          "64: # adapt whatever generate_ir_for_function gives us into an IR node",
          "65: def _ir_for_fallback_or_ctor(func_ast, *args, **kwargs):",
          "66:     func_t = func_ast._metadata[\"type\"]",
          "67:     assert func_t.is_fallback or func_t.is_constructor",
          "69:     ret = [\"seq\"]",
          "70:     if not func_t.is_payable:",
          "71:         callvalue_check = [\"assert\", [\"iszero\", \"callvalue\"]]",
          "72:         ret.append(IRnode.from_list(callvalue_check, error_msg=\"nonpayable check\"))",
          "74:     func_ir = generate_ir_for_function(func_ast, *args, **kwargs)",
          "75:     assert len(func_ir.entry_points) == 1",
          "77:     # add a goto to make the function entry look like other functions",
          "78:     # (for zksync interpreter)",
          "79:     ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "80:     ret.append(func_ir.common_ir)",
          "82:     return IRnode.from_list(ret)",
          "85: def _ir_for_internal_function(func_ast, *args, **kwargs):",
          "86:     return generate_ir_for_function(func_ast, *args, **kwargs).func_ir",
          "89: def _generate_external_entry_points(external_functions, global_ctx):",
          "90:     entry_points = {}  # map from ABI sigs to ir code",
          "91:     sig_of = {}  # reverse map from method ids to abi sig",
          "93:     for code in external_functions:",
          "94:         func_ir = generate_ir_for_function(code, global_ctx)",
          "95:         for abi_sig, entry_point in func_ir.entry_points.items():",
          "96:             assert abi_sig not in entry_points",
          "97:             entry_points[abi_sig] = entry_point",
          "98:             sig_of[method_id_int(abi_sig)] = abi_sig",
          "100:         # stick function common body into final entry point to save a jump",
          "101:         ir_node = IRnode.from_list([\"seq\", entry_point.ir_node, func_ir.common_ir])",
          "102:         entry_point.ir_node = ir_node",
          "104:     return entry_points, sig_of",
          "107: # codegen for all runtime functions + callvalue/calldata checks,",
          "108: # with O(1) jumptable for selector table.",
          "109: # uses two level strategy: uses `method_id % n_buckets` to descend",
          "110: # into a bucket (of about 8-10 items), and then uses perfect hash",
          "111: # to select the final function.",
          "112: # costs about 212 gas for typical function and 8 bytes of code (+ ~87 bytes of global overhead)",
          "113: def _selector_section_dense(external_functions, global_ctx):",
          "114:     function_irs = []",
          "117:         return IRnode.from_list([\"seq\"])",
          "119:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "121:     # generate the label so the jumptable works",
          "122:     for abi_sig, entry_point in entry_points.items():",
          "123:         label = label_for_entry_point(abi_sig, entry_point)",
          "124:         ir_node = [\"label\", label, [\"var_list\"], entry_point.ir_node]",
          "125:         function_irs.append(IRnode.from_list(ir_node))",
          "127:     jumptable_info = jumptable_utils.generate_dense_jumptable_info(entry_points.keys())",
          "128:     n_buckets = len(jumptable_info)",
          "130:     #  bucket magic <2 bytes> | bucket location <2 bytes> | bucket size <1 byte>",
          "131:     # TODO: can make it smaller if the largest bucket magic <= 255",
          "132:     SZ_BUCKET_HEADER = 5",
          "134:     selector_section = [\"seq\"]",
          "136:     bucket_id = [\"mod\", \"_calldata_method_id\", n_buckets]",
          "137:     bucket_hdr_location = [",
          "138:         \"add\",",
          "139:         [\"symbol\", \"BUCKET_HEADERS\"],",
          "140:         [\"mul\", bucket_id, SZ_BUCKET_HEADER],",
          "141:     ]",
          "142:     # get bucket header",
          "143:     dst = 32 - SZ_BUCKET_HEADER",
          "144:     assert dst >= 0",
          "146:     if _is_debug_mode():",
          "147:         selector_section.append([\"assert\", [\"eq\", \"msize\", 0]])",
          "149:     selector_section.append([\"codecopy\", dst, bucket_hdr_location, SZ_BUCKET_HEADER])",
          "151:     # figure out the minimum number of bytes we can use to encode",
          "152:     # min_calldatasize in function info",
          "153:     largest_mincalldatasize = max(f.min_calldatasize for f in entry_points.values())",
          "154:     FN_METADATA_BYTES = (largest_mincalldatasize.bit_length() + 7) // 8",
          "156:     func_info_size = 4 + 2 + FN_METADATA_BYTES",
          "157:     # grab function info.",
          "158:     # method id <4 bytes> | label <2 bytes> | func info <1-3 bytes>",
          "159:     # func info (1-3 bytes, packed) for: expected calldatasize, is_nonpayable bit",
          "160:     # NOTE: might be able to improve codesize if we use variable # of bytes",
          "161:     # per bucket",
          "163:     hdr_info = IRnode.from_list([\"mload\", 0])",
          "164:     with hdr_info.cache_when_complex(\"hdr_info\") as (b1, hdr_info):",
          "165:         bucket_location = [\"and\", 0xFFFF, shr(8, hdr_info)]",
          "166:         bucket_magic = shr(24, hdr_info)",
          "167:         bucket_size = [\"and\", 0xFF, hdr_info]",
          "168:         # ((method_id * bucket_magic) >> BITS_MAGIC) % bucket_size",
          "169:         func_id = [",
          "170:             \"mod\",",
          "171:             shr(jumptable_utils.BITS_MAGIC, [\"mul\", bucket_magic, \"_calldata_method_id\"]),",
          "172:             bucket_size,",
          "173:         ]",
          "174:         func_info_location = [\"add\", bucket_location, [\"mul\", func_id, func_info_size]]",
          "175:         dst = 32 - func_info_size",
          "176:         assert func_info_size >= SZ_BUCKET_HEADER  # otherwise mload will have dirty bytes",
          "177:         assert dst >= 0",
          "178:         selector_section.append(b1.resolve([\"codecopy\", dst, func_info_location, func_info_size]))",
          "180:     func_info = IRnode.from_list([\"mload\", 0])",
          "181:     fn_metadata_mask = 2 ** (FN_METADATA_BYTES * 8) - 1",
          "182:     calldatasize_mask = fn_metadata_mask - 1  # ex. 0xFFFE",
          "183:     with func_info.cache_when_complex(\"func_info\") as (b1, func_info):",
          "184:         x = [\"seq\"]",
          "186:         # expected calldatasize always satisfies (x - 4) % 32 == 0",
          "187:         # the lower 5 bits are always 0b00100, so we can use those",
          "188:         # bits for other purposes.",
          "189:         is_nonpayable = [\"and\", 1, func_info]",
          "190:         expected_calldatasize = [\"and\", calldatasize_mask, func_info]",
          "192:         label_bits_ofst = FN_METADATA_BYTES * 8",
          "193:         function_label = [\"and\", 0xFFFF, shr(label_bits_ofst, func_info)]",
          "194:         method_id_bits_ofst = (FN_METADATA_BYTES + 2) * 8",
          "195:         function_method_id = shr(method_id_bits_ofst, func_info)",
          "197:         # check method id is right, if not then fallback.",
          "198:         # need to check calldatasize >= 4 in case there are",
          "199:         # trailing 0s in the method id.",
          "200:         calldatasize_valid = [\"gt\", \"calldatasize\", 3]",
          "201:         method_id_correct = [\"eq\", function_method_id, \"_calldata_method_id\"]",
          "202:         should_fallback = [\"iszero\", [\"and\", calldatasize_valid, method_id_correct]]",
          "203:         x.append([\"if\", should_fallback, [\"goto\", \"fallback\"]])",
          "205:         # assert callvalue == 0 if nonpayable",
          "206:         bad_callvalue = [\"mul\", is_nonpayable, \"callvalue\"]",
          "207:         # assert calldatasize at least minimum for the abi type",
          "208:         bad_calldatasize = [\"lt\", \"calldatasize\", expected_calldatasize]",
          "209:         failed_entry_conditions = [\"or\", bad_callvalue, bad_calldatasize]",
          "210:         check_entry_conditions = IRnode.from_list(",
          "211:             [\"assert\", [\"iszero\", failed_entry_conditions]],",
          "212:             error_msg=\"bad calldatasize or callvalue\",",
          "214:         x.append(check_entry_conditions)",
          "215:         x.append([\"jump\", function_label])",
          "216:         selector_section.append(b1.resolve(x))",
          "218:     bucket_headers = [\"data\", \"BUCKET_HEADERS\"]",
          "220:     for bucket_id, bucket in sorted(jumptable_info.items()):",
          "221:         bucket_headers.append(bucket.magic.to_bytes(2, \"big\"))",
          "222:         bucket_headers.append([\"symbol\", f\"bucket_{bucket_id}\"])",
          "223:         # note: buckets are usually ~10 items. to_bytes would",
          "224:         # fail if the int is too big.",
          "225:         bucket_headers.append(bucket.bucket_size.to_bytes(1, \"big\"))",
          "227:     selector_section.append(bucket_headers)",
          "229:     for bucket_id, bucket in jumptable_info.items():",
          "230:         function_infos = [\"data\", f\"bucket_{bucket_id}\"]",
          "231:         # sort function infos by their image.",
          "232:         for method_id in bucket.method_ids_image_order:",
          "233:             abi_sig = sig_of[method_id]",
          "234:             entry_point = entry_points[abi_sig]",
          "236:             method_id_bytes = method_id.to_bytes(4, \"big\")",
          "237:             symbol = [\"symbol\", label_for_entry_point(abi_sig, entry_point)]",
          "238:             func_metadata_int = entry_point.min_calldatasize | int(",
          "239:                 not entry_point.func_t.is_payable",
          "240:             )",
          "241:             func_metadata = func_metadata_int.to_bytes(FN_METADATA_BYTES, \"big\")",
          "243:             function_infos.extend([method_id_bytes, symbol, func_metadata])",
          "245:         selector_section.append(function_infos)",
          "247:     ret = [\"seq\", [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section]]",
          "249:     ret.extend(function_irs)",
          "251:     return ret",
          "254: # codegen for all runtime functions + callvalue/calldata checks,",
          "255: # with O(1) jumptable for selector table.",
          "256: # uses two level strategy: uses `method_id % n_methods` to calculate",
          "257: # a bucket, and then descends into linear search from there.",
          "258: # costs about 126 gas for typical (nonpayable, >0 args, avg bucket size 1.5)",
          "259: # function and 24 bytes of code (+ ~23 bytes of global overhead)",
          "260: def _selector_section_sparse(external_functions, global_ctx):",
          "261:     ret = [\"seq\"]",
          "263:     if len(external_functions) == 0:",
          "264:         return ret",
          "266:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "268:     n_buckets, buckets = jumptable_utils.generate_sparse_jumptable_buckets(entry_points.keys())",
          "270:     # 2 bytes for bucket location",
          "271:     SZ_BUCKET_HEADER = 2",
          "273:     if n_buckets > 1:",
          "274:         bucket_id = [\"mod\", \"_calldata_method_id\", n_buckets]",
          "275:         bucket_hdr_location = [",
          "276:             \"add\",",
          "277:             [\"symbol\", \"selector_buckets\"],",
          "278:             [\"mul\", bucket_id, SZ_BUCKET_HEADER],",
          "279:         ]",
          "280:         # get bucket header",
          "281:         dst = 32 - SZ_BUCKET_HEADER",
          "282:         assert dst >= 0",
          "284:         if _is_debug_mode():",
          "285:             ret.append([\"assert\", [\"eq\", \"msize\", 0]])",
          "287:         ret.append([\"codecopy\", dst, bucket_hdr_location, SZ_BUCKET_HEADER])",
          "289:         jumpdest = IRnode.from_list([\"mload\", 0])",
          "290:         # don't particularly like using `jump` here since it can cause",
          "291:         # issues for other backends, consider changing `goto` to allow",
          "292:         # dynamic jumps, or adding some kind of jumptable instruction",
          "293:         ret.append([\"jump\", jumpdest])",
          "295:         jumptable_data = [\"data\", \"selector_buckets\"]",
          "296:         for i in range(n_buckets):",
          "297:             if i in buckets:",
          "298:                 bucket_label = f\"selector_bucket_{i}\"",
          "299:                 jumptable_data.append([\"symbol\", bucket_label])",
          "300:             else:",
          "301:                 # empty bucket",
          "302:                 jumptable_data.append([\"symbol\", \"fallback\"])",
          "304:         ret.append(jumptable_data)",
          "306:     for bucket_id, bucket in buckets.items():",
          "307:         bucket_label = f\"selector_bucket_{bucket_id}\"",
          "308:         ret.append([\"label\", bucket_label, [\"var_list\"], [\"seq\"]])",
          "310:         handle_bucket = [\"seq\"]",
          "312:         for method_id in bucket:",
          "313:             sig = sig_of[method_id]",
          "314:             entry_point = entry_points[sig]",
          "315:             func_t = entry_point.func_t",
          "316:             expected_calldatasize = entry_point.min_calldatasize",
          "318:             dispatch = [\"seq\"]  # code to dispatch into the function",
          "319:             skip_callvalue_check = func_t.is_payable",
          "320:             skip_calldatasize_check = expected_calldatasize == 4",
          "321:             bad_callvalue = [0] if skip_callvalue_check else [\"callvalue\"]",
          "322:             bad_calldatasize = (",
          "323:                 [0] if skip_calldatasize_check else [\"lt\", \"calldatasize\", expected_calldatasize]",
          "324:             )",
          "326:             dispatch.append(",
          "327:                 IRnode.from_list(",
          "328:                     [\"assert\", [\"iszero\", [\"or\", bad_callvalue, bad_calldatasize]]],",
          "329:                     error_msg=\"bad calldatasize or callvalue\",",
          "330:                 )",
          "331:             )",
          "332:             # we could skip a jumpdest per method if we out-lined the entry point",
          "333:             # so the dispatcher looks just like -",
          "334:             # ```(if (eq <calldata_method_id> method_id)",
          "335:             #   (goto entry_point_label))```",
          "336:             # it would another optimization for patterns like",
          "337:             # `if ... (goto)` though.",
          "338:             dispatch.append(entry_point.ir_node)",
          "340:             method_id_check = [\"eq\", \"_calldata_method_id\", _annotated_method_id(sig)]",
          "341:             has_trailing_zeroes = method_id.to_bytes(4, \"big\").endswith(b\"\\x00\")",
          "342:             if has_trailing_zeroes:",
          "343:                 # if the method id check has trailing 0s, we need to include",
          "344:                 # a calldatasize check to distinguish from when not enough",
          "345:                 # bytes are provided for the method id in calldata.",
          "346:                 method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "347:             handle_bucket.append([\"if\", method_id_check, dispatch])",
          "349:         # close out the bucket with a goto fallback so we don't keep searching",
          "350:         handle_bucket.append([\"goto\", \"fallback\"])",
          "352:         ret.append(handle_bucket)",
          "354:     ret = [\"seq\", [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), ret]]",
          "356:     return ret",
          "359: # codegen for all runtime functions + callvalue/calldata checks,",
          "360: # O(n) linear search for the method id",
          "361: # mainly keep this in for backends which cannot handle the indirect jump",
          "362: # in selector_section_dense and selector_section_sparse",
          "363: def _selector_section_linear(external_functions, global_ctx):",
          "364:     ret = [\"seq\"]",
          "365:     if len(external_functions) == 0:",
          "366:         return ret",
          "368:     ret.append([\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]])",
          "370:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "372:     dispatcher = [\"seq\"]",
          "374:     for sig, entry_point in entry_points.items():",
          "375:         func_t = entry_point.func_t",
          "376:         expected_calldatasize = entry_point.min_calldatasize",
          "378:         dispatch = [\"seq\"]  # code to dispatch into the function",
          "380:         if not func_t.is_payable:",
          "381:             callvalue_check = [\"assert\", [\"iszero\", \"callvalue\"]]",
          "382:             dispatch.append(IRnode.from_list(callvalue_check, error_msg=\"nonpayable check\"))",
          "384:         good_calldatasize = [\"ge\", \"calldatasize\", expected_calldatasize]",
          "385:         calldatasize_check = [\"assert\", good_calldatasize]",
          "386:         dispatch.append(IRnode.from_list(calldatasize_check, error_msg=\"calldatasize check\"))",
          "388:         dispatch.append(entry_point.ir_node)",
          "390:         method_id_check = [\"eq\", \"_calldata_method_id\", _annotated_method_id(sig)]",
          "391:         dispatcher.append([\"if\", method_id_check, dispatch])",
          "393:     ret.append([\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), dispatcher])",
          "395:     return ret",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143:     runtime_functions = [f for f in function_defs if not _is_constructor(f)]",
          "144:     init_function = next((f for f in function_defs if _is_constructor(f)), None)",
          "148:     deploy_code: List[Any] = [\"seq\"]",
          "149:     immutables_len = global_ctx.immutable_section_bytes",
          "150:     if init_function:",
          "151:         # TODO might be cleaner to separate this into an _init_ir helper func",
          "156:         # pass the amount of memory allocated for the init function",
          "157:         # so that deployment does not clobber while preparing immutables",
          "",
          "[Removed Lines]",
          "146:     runtime = _runtime_ir(runtime_functions, global_ctx)",
          "152:         init_func_ir = generate_ir_for_function(",
          "153:             init_function, global_ctx, skip_nonpayable_check=False, is_ctor_context=True",
          "154:         )",
          "",
          "[Added Lines]",
          "406:     internal_functions = [f for f in runtime_functions if _is_internal(f)]",
          "408:     external_functions = [",
          "409:         f for f in runtime_functions if not _is_internal(f) and not _is_fallback(f)",
          "410:     ]",
          "411:     default_function = next((f for f in runtime_functions if _is_fallback(f)), None)",
          "413:     internal_functions_ir: list[IRnode] = []",
          "415:     # compile internal functions first so we have the function info",
          "416:     for func_ast in internal_functions:",
          "417:         func_ir = _ir_for_internal_function(func_ast, global_ctx, False)",
          "418:         internal_functions_ir.append(IRnode.from_list(func_ir))",
          "420:     if core._opt_none():",
          "421:         selector_section = _selector_section_linear(external_functions, global_ctx)",
          "422:     # dense vs sparse global overhead is amortized after about 4 methods.",
          "423:     # (--debug will force dense selector table anyway if _opt_codesize is selected.)",
          "424:     elif core._opt_codesize() and (len(external_functions) > 4 or _is_debug_mode()):",
          "425:         selector_section = _selector_section_dense(external_functions, global_ctx)",
          "426:     else:",
          "427:         selector_section = _selector_section_sparse(external_functions, global_ctx)",
          "429:     if default_function:",
          "430:         fallback_ir = _ir_for_fallback_or_ctor(default_function, global_ctx)",
          "431:     else:",
          "432:         fallback_ir = IRnode.from_list(",
          "433:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "434:         )",
          "436:     runtime = [\"seq\", selector_section]",
          "437:     runtime.append([\"goto\", \"fallback\"])",
          "438:     runtime.append([\"label\", \"fallback\", [\"var_list\"], fallback_ir])",
          "440:     runtime.extend(internal_functions_ir)",
          "446:         init_func_ir = _ir_for_fallback_or_ctor(init_function, global_ctx, is_ctor_context=True)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184:         for f in internal_functions:",
          "185:             init_func_t = init_function._metadata[\"type\"]",
          "186:             if f.name not in init_func_t.recursive_calls:",
          "188:                 continue",
          "193:             deploy_code.append(func_ir)",
          "195:     else:",
          "",
          "[Removed Lines]",
          "187:                 # unreachable",
          "190:             func_ir = generate_ir_for_function(",
          "191:                 f, global_ctx, skip_nonpayable_check=False, is_ctor_context=True",
          "192:             )",
          "",
          "[Added Lines]",
          "479:                 # unreachable code, delete it",
          "482:             func_ir = _ir_for_internal_function(f, global_ctx, is_ctor_context=True)",
          "",
          "---------------"
        ],
        "vyper/compiler/output.py||vyper/compiler/output.py": [
          "File: vyper/compiler/output.py -> vyper/compiler/output.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:     while bytecode_sequence:",
          "302:         op = bytecode_sequence.popleft()",
          "304:         if \"PUSH\" in opcode_output[-1] and opcode_output[-1] != \"PUSH0\":",
          "305:             push_len = int(opcode_map[op][4:])",
          "306:             push_values = [hex(bytecode_sequence.popleft())[2:] for i in range(push_len)]",
          "307:             opcode_output.append(f\"0x{''.join(push_values).upper()}\")",
          "",
          "[Removed Lines]",
          "303:         opcode_output.append(opcode_map[op])",
          "",
          "[Added Lines]",
          "303:         opcode_output.append(opcode_map.get(op, f\"VERBATIM_{hex(op)}\"))",
          "306:             # we can have push_len > len(bytecode_sequence) when there is data",
          "307:             # (instead of code) at end of contract",
          "308:             # CMC 2023-07-13 maybe just strip known data segments?",
          "309:             push_len = min(push_len, len(bytecode_sequence))",
          "",
          "---------------"
        ],
        "vyper/compiler/settings.py||vyper/compiler/settings.py": [
          "File: vyper/compiler/settings.py -> vyper/compiler/settings.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     compiler_version: Optional[str] = None",
          "43:     optimize: Optional[OptimizationLevel] = None",
          "44:     evm_version: Optional[str] = None",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: _DEBUG = False",
          "50: def _is_debug_mode():",
          "51:     global _DEBUG",
          "52:     return _DEBUG",
          "55: def _set_debug_mode(dbg: bool = False) -> None:",
          "56:     global _DEBUG",
          "57:     _DEBUG = dbg",
          "",
          "---------------"
        ],
        "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py": [
          "File: vyper/ir/compile_ir.py -> vyper/ir/compile_ir.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:         to_append.extend(_revert_string)",
          "160:     if len(to_append) > 0:",
          "161:         # for some reason there might not be a STOP at the end of asm_ops.",
          "162:         # (generally vyper programs will have it but raw IR might not).",
          "163:         asm_ops.append(\"STOP\")",
          "164:         asm_ops.extend(to_append)",
          "166:     # need to do this recursively since every sublist is basically",
          "167:     # treated as its own program (there are no global labels.)",
          "168:     for t in asm_ops:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:         # insert the postambles *before* runtime code",
          "162:         # so the data section of the runtime code can't bork the postambles.",
          "163:         runtime = None",
          "164:         if isinstance(asm_ops[-1], list) and isinstance(asm_ops[-1][0], _RuntimeHeader):",
          "165:             runtime = asm_ops.pop()",
          "172:         if runtime:",
          "173:             asm_ops.append(runtime)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:     res = _compile_to_assembly(code)",
          "215:     _add_postambles(res)",
          "216:     if optimize != OptimizationLevel.NONE:",
          "217:         _optimize_assembly(res)",
          "218:     return res",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:     _relocate_segments(res)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "500:         assert isinstance(memsize, int), \"non-int memsize\"",
          "501:         assert isinstance(padding, int), \"non-int padding\"",
          "505:         subcode = _compile_to_assembly(ir)",
          "507:         o = []",
          "509:         # COPY the code to memory for deploy",
          "512:         # calculate the len of runtime code",
          "513:         o.extend([\"_OFST\", \"_sym_subcode_size\", padding])  # stack: len",
          "",
          "[Removed Lines]",
          "503:         begincode = mksymbol(\"runtime_begin\")",
          "510:         o.extend([\"_sym_subcode_size\", begincode, \"_mem_deploy_start\", \"CODECOPY\"])",
          "",
          "[Added Lines]",
          "515:         runtime_begin = mksymbol(\"runtime_begin\")",
          "522:         o.extend([\"_sym_subcode_size\", runtime_begin, \"_mem_deploy_start\", \"CODECOPY\"])",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "517:         # since the asm data structures are very primitive, to make sure",
          "518:         # assembly_to_evm is able to calculate data offsets correctly,",
          "519:         # we pass the memsize via magic opcodes to the subcode",
          "522:         # append the runtime code after the ctor code",
          "524:         # `append(...)` call here is intentional.",
          "525:         # each sublist is essentially its own program with its",
          "526:         # own symbols.",
          "",
          "[Removed Lines]",
          "520:         subcode = [f\"_DEPLOY_MEM_OFST_{memsize}\"] + subcode",
          "523:         o.extend([begincode, \"BLANK\"])",
          "",
          "[Added Lines]",
          "532:         subcode = [_RuntimeHeader(runtime_begin, memsize)] + subcode",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "661:             height,",
          "662:         )",
          "664:     # jump to a symbol, and push variable # of arguments onto stack",
          "665:     elif code.value == \"goto\":",
          "666:         o = []",
          "667:         for i, c in enumerate(reversed(code.args[1:])):",
          "668:             o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))",
          "670:         return o",
          "671:     # push a literal symbol",
          "672:     elif code.value == \"symbol\":",
          "674:     # set a symbol as a location.",
          "675:     elif code.value == \"label\":",
          "676:         label_name = code.args[0].value",
          "",
          "[Removed Lines]",
          "669:         o.extend([\"_sym_\" + str(code.args[0]), \"JUMP\"])",
          "673:         return [\"_sym_\" + str(code.args[0])]",
          "",
          "[Added Lines]",
          "675:     elif code.value == \"data\":",
          "676:         data_node = [_DataHeader(\"_sym_\" + code.args[0].value)]",
          "678:         for c in code.args[1:]:",
          "679:             if isinstance(c.value, int):",
          "680:                 assert 0 <= c < 256, f\"invalid data byte {c}\"",
          "681:                 data_node.append(c.value)",
          "682:             elif isinstance(c.value, bytes):",
          "683:                 data_node.append(c.value)",
          "684:             elif isinstance(c, IRnode):",
          "685:                 assert c.value == \"symbol\"",
          "686:                 data_node.extend(",
          "687:                     _compile_to_assembly(c, withargs, existing_labels, break_dest, height)",
          "688:                 )",
          "689:             else:",
          "690:                 raise ValueError(f\"Invalid data: {type(c)} {c}\")",
          "692:         # intentionally return a sublist.",
          "693:         return [data_node]",
          "700:         o.extend([\"_sym_\" + code.args[0].value, \"JUMP\"])",
          "704:         return [\"_sym_\" + code.args[0].value]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "728:     # inject debug opcode.",
          "729:     elif code.value == \"pc_debugger\":",
          "730:         return mkdebug(pc_debugger=True, source_pos=code.source_pos)",
          "735: def note_line_num(line_number_map, item, pos):",
          "",
          "[Removed Lines]",
          "731:     else:",
          "732:         raise Exception(\"Weird code element: \" + repr(code))",
          "",
          "[Added Lines]",
          "762:     else:  # pragma: no cover",
          "763:         raise ValueError(f\"Weird code element: {type(code)} {code}\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "766: def _prune_unreachable_code(assembly):",
          "772:     changed = False",
          "773:     i = 0",
          "774:     while i < len(assembly) - 2:",
          "",
          "[Removed Lines]",
          "767:     # In converting IR to assembly we sometimes end up with unreachable",
          "768:     # instructions - POPing to clear the stack or STOPing execution at the",
          "769:     # end of a function that has already returned or reverted. This should",
          "770:     # be addressed in the IR, but for now we do a final sanity check here",
          "771:     # to avoid unnecessary bytecode bloat.",
          "",
          "[Added Lines]",
          "798:     # delete code between terminal ops and JUMPDESTS as those are",
          "799:     # unreachable",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "777:             instr = assembly[i][-1]",
          "779:         if assembly[i] in _TERMINAL_OPS and not (",
          "781:         ):",
          "782:             changed = True",
          "783:             del assembly[i + 1]",
          "",
          "[Removed Lines]",
          "780:             is_symbol(assembly[i + 1]) and assembly[i + 2] in (\"JUMPDEST\", \"BLANK\")",
          "",
          "[Added Lines]",
          "808:             is_symbol(assembly[i + 1]) or isinstance(assembly[i + 1], list)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "889:     return changed",
          "892: def _prune_unused_jumpdests(assembly):",
          "893:     changed = False",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "920: # a symbol _sym_x in assembly can either mean to push _sym_x to the stack,",
          "921: # or it can precede a location in code which we want to add to symbol map.",
          "922: # this helper function tells us if we want to add the previous instruction",
          "923: # to the symbol map.",
          "924: def is_symbol_map_indicator(asm_node):",
          "925:     return asm_node == \"JUMPDEST\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "897:     # find all used jumpdests",
          "898:     for i in range(len(assembly) - 1):",
          "900:             used_jumpdests.add(assembly[i])",
          "902:     # delete jumpdests that aren't used",
          "903:     i = 0",
          "904:     while i < len(assembly) - 2:",
          "",
          "[Removed Lines]",
          "899:         if is_symbol(assembly[i]) and assembly[i + 1] != \"JUMPDEST\":",
          "",
          "[Added Lines]",
          "935:         if is_symbol(assembly[i]) and not is_symbol_map_indicator(assembly[i + 1]):",
          "938:     for item in assembly:",
          "939:         if isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "940:             # add symbols used in data sections as they are likely",
          "941:             # used for a jumptable.",
          "942:             for t in item:",
          "943:                 if is_symbol(t):",
          "944:                     used_jumpdests.add(t)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "937: # optimize assembly, in place",
          "938: def _optimize_assembly(assembly):",
          "939:     for x in assembly:",
          "941:             _optimize_assembly(x)",
          "943:     for _ in range(1024):",
          "",
          "[Removed Lines]",
          "940:         if isinstance(x, list):",
          "",
          "[Added Lines]",
          "984:         if isinstance(x, list) and isinstance(x[0], _RuntimeHeader):",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "970:     return ret",
          "973: def assembly_to_evm(assembly, pc_ofst=0, insert_vyper_signature=False):",
          "974:     \"\"\"",
          "975:     Assembles assembly into EVM",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1017: SYMBOL_SIZE = 2  # size of a PUSH instruction for a code symbol",
          "1020: def _data_to_evm(assembly, symbol_map):",
          "1021:     ret = bytearray()",
          "1022:     assert isinstance(assembly[0], _DataHeader)",
          "1023:     for item in assembly[1:]:",
          "1024:         if is_symbol(item):",
          "1025:             symbol = symbol_map[item].to_bytes(SYMBOL_SIZE, \"big\")",
          "1026:             ret.extend(symbol)",
          "1027:         elif isinstance(item, int):",
          "1028:             ret.append(item)",
          "1029:         elif isinstance(item, bytes):",
          "1030:             ret.extend(item)",
          "1031:         else:",
          "1032:             raise ValueError(f\"invalid data {type(item)} {item}\")",
          "1034:     return ret",
          "1037: # predict what length of an assembly [data] node will be in bytecode",
          "1038: def _length_of_data(assembly):",
          "1039:     ret = 0",
          "1040:     assert isinstance(assembly[0], _DataHeader)",
          "1041:     for item in assembly[1:]:",
          "1042:         if is_symbol(item):",
          "1043:             ret += SYMBOL_SIZE",
          "1044:         elif isinstance(item, int):",
          "1045:             assert 0 <= item < 256, f\"invalid data byte {item}\"",
          "1046:             ret += 1",
          "1047:         elif isinstance(item, bytes):",
          "1048:             ret += len(item)",
          "1049:         else:",
          "1050:             raise ValueError(f\"invalid data {type(item)} {item}\")",
          "1052:     return ret",
          "1055: class _RuntimeHeader:",
          "1056:     def __init__(self, label, ctor_mem_size):",
          "1057:         self.label = label",
          "1058:         self.ctor_mem_size = ctor_mem_size",
          "1060:     def __repr__(self):",
          "1061:         return f\"<RUNTIME {self.label} mem @{self.ctor_mem_size}>\"",
          "1064: class _DataHeader:",
          "1065:     def __init__(self, label):",
          "1066:         self.label = label",
          "1068:     def __repr__(self):",
          "1069:         return f\"DATA {self.label}\"",
          "1072: def _relocate_segments(assembly):",
          "1073:     # relocate all data segments to the end, otherwise data could be",
          "1074:     # interpreted as PUSH instructions and mangle otherwise valid jumpdests",
          "1075:     # relocate all runtime segments to the end as well",
          "1076:     data_segments = []",
          "1077:     non_data_segments = []",
          "1078:     code_segments = []",
          "1079:     for t in assembly:",
          "1080:         if isinstance(t, list):",
          "1081:             if isinstance(t[0], _DataHeader):",
          "1082:                 data_segments.append(t)",
          "1083:             else:",
          "1084:                 _relocate_segments(t)  # recurse",
          "1085:                 assert isinstance(t[0], _RuntimeHeader)",
          "1086:                 code_segments.append(t)",
          "1087:         else:",
          "1088:             non_data_segments.append(t)",
          "1089:     assembly.clear()",
          "1090:     assembly.extend(non_data_segments)",
          "1091:     assembly.extend(code_segments)",
          "1092:     assembly.extend(data_segments)",
          "1095: # TODO: change API to split assembly_to_evm and assembly_to_source/symbol_maps",
          "1097:     bytecode, source_maps, _ = assembly_to_evm_with_symbol_map(",
          "1098:         assembly, pc_ofst=pc_ofst, insert_vyper_signature=insert_vyper_signature",
          "1099:     )",
          "1100:     return bytecode, source_maps",
          "1103: def assembly_to_evm_with_symbol_map(assembly, pc_ofst=0, insert_vyper_signature=False):",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "999:         bytecode_suffix += b\"\\xa1\\x65vyper\\x83\" + bytes(list(version_tuple))",
          "1000:         bytecode_suffix += len(bytecode_suffix).to_bytes(2, \"big\")",
          "1004:     # to optimize the size of deploy code - we want to use the smallest",
          "1005:     # PUSH instruction possible which can support all memory symbols",
          "1006:     # (and also works with linear pass symbol resolution)",
          "",
          "[Removed Lines]",
          "1002:     CODE_OFST_SIZE = 2  # size of a PUSH instruction for a code symbol",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1009:     mem_ofst_size, ctor_mem_size = None, None",
          "1010:     max_mem_ofst = 0",
          "1011:     for i, item in enumerate(assembly):",
          "1013:             assert runtime_code is None, \"Multiple subcodes\"",
          "1017:             assert ctor_mem_size is None",
          "1020:             runtime_code_start, runtime_code_end = _runtime_code_offsets(",
          "1021:                 ctor_mem_size, len(runtime_code)",
          "",
          "[Removed Lines]",
          "1012:         if isinstance(item, list):",
          "1014:             runtime_code, runtime_map = assembly_to_evm(item)",
          "1016:             assert item[0].startswith(\"_DEPLOY_MEM_OFST_\")",
          "1018:             ctor_mem_size = int(item[0][len(\"_DEPLOY_MEM_OFST_\") :])",
          "",
          "[Added Lines]",
          "1140:         if isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1144:             ctor_mem_size = item[0].ctor_mem_size",
          "1146:             runtime_code, runtime_map = assembly_to_evm(item[1:])",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1054:         # update pc",
          "1055:         if is_symbol(item):",
          "1057:                 # Don't increment pc as the symbol itself doesn't go into code",
          "1058:                 if item in symbol_map:",
          "1059:                     raise CompilerPanic(f\"duplicate jumpdest {item}\")",
          "1061:                 symbol_map[item] = pc",
          "1062:             else:",
          "1064:         elif is_mem_sym(item):",
          "1065:             # PUSH<n> item",
          "1066:             pc += mem_ofst_size + 1",
          "",
          "[Removed Lines]",
          "1056:             if assembly[i + 1] == \"JUMPDEST\" or assembly[i + 1] == \"BLANK\":",
          "1063:                 pc += CODE_OFST_SIZE + 1  # PUSH2 highbits lowbits",
          "",
          "[Added Lines]",
          "1184:             if is_symbol_map_indicator(assembly[i + 1]):",
          "1191:                 pc += SYMBOL_SIZE + 1  # PUSH2 highbits lowbits",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1070:             # [_OFST, _sym_foo, bar] -> PUSH2 (foo+bar)",
          "1071:             # [_OFST, _mem_foo, bar] -> PUSHN (foo+bar)",
          "1072:             pc -= 1",
          "1080:             # add source map for all items in the runtime map",
          "1081:             t = adjust_pc_maps(runtime_map, pc)",
          "1082:             for key in line_number_map:",
          "1083:                 line_number_map[key].update(t[key])",
          "1084:             pc += len(runtime_code)",
          "1086:         else:",
          "1087:             pc += 1",
          "",
          "[Removed Lines]",
          "1073:         elif item == \"BLANK\":",
          "1074:             pc += 0",
          "1075:         elif isinstance(item, str) and item.startswith(\"_DEPLOY_MEM_OFST_\"):",
          "1076:             # _DEPLOY_MEM_OFST is assembly magic which will",
          "1077:             # get removed during final assembly-to-bytecode",
          "1078:             pc += 0",
          "1079:         elif isinstance(item, list):",
          "",
          "[Added Lines]",
          "1201:         elif isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1202:             symbol_map[item[0].label] = pc",
          "1208:         elif isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "1209:             symbol_map[item[0].label] = pc",
          "1210:             pc += _length_of_data(item)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1094:     if runtime_code is not None:",
          "1095:         symbol_map[\"_sym_subcode_size\"] = len(runtime_code)",
          "1105:     # now that all symbols have been resolved, generate bytecode",
          "1106:     # using the symbol map",
          "",
          "[Removed Lines]",
          "1097:     # (NOTE CMC 2022-06-17 this way of generating bytecode did not",
          "1098:     # seem to be a perf hotspot. if it is, may want to use bytearray()",
          "1099:     # instead).",
          "1101:     # TODO refactor into two functions, create posmap and assemble",
          "1103:     o = b\"\"",
          "",
          "[Added Lines]",
          "1222:     # TODO refactor into two functions, create symbol_map and assemble",
          "1224:     ret = bytearray()",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1110:             to_skip -= 1",
          "1111:             continue",
          "1114:             continue  # skippable opcodes",
          "1119:         elif is_symbol(item):",
          "1124:         elif is_mem_sym(item):",
          "1125:             bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=mem_ofst_size))",
          "1128:         elif is_ofst(item):",
          "1129:             # _OFST _sym_foo 32",
          "1130:             ofst = symbol_map[assembly[i + 1]] + assembly[i + 2]",
          "1132:             bytecode, _ = assembly_to_evm(PUSH_N(ofst, n))",
          "1134:             to_skip = 2",
          "1136:         elif isinstance(item, int):",
          "1138:         elif isinstance(item, str) and item.upper() in get_opcodes():",
          "1140:         elif item[:4] == \"PUSH\":",
          "1142:         elif item[:3] == \"DUP\":",
          "1144:         elif item[:4] == \"SWAP\":",
          "1154:     line_number_map[\"breakpoints\"] = list(line_number_map[\"breakpoints\"])",
          "1155:     line_number_map[\"pc_breakpoints\"] = list(line_number_map[\"pc_breakpoints\"])",
          "",
          "[Removed Lines]",
          "1113:         if item in (\"DEBUG\", \"BLANK\"):",
          "1116:         elif isinstance(item, str) and item.startswith(\"_DEPLOY_MEM_OFST_\"):",
          "1117:             continue",
          "1120:             if assembly[i + 1] != \"JUMPDEST\" and assembly[i + 1] != \"BLANK\":",
          "1121:                 bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=CODE_OFST_SIZE))",
          "1122:                 o += bytecode",
          "1126:             o += bytecode",
          "1131:             n = mem_ofst_size if is_mem_sym(assembly[i + 1]) else CODE_OFST_SIZE",
          "1133:             o += bytecode",
          "1137:             o += bytes([item])",
          "1139:             o += bytes([get_opcodes()[item.upper()][0]])",
          "1141:             o += bytes([PUSH_OFFSET + int(item[4:])])",
          "1143:             o += bytes([DUP_OFFSET + int(item[3:])])",
          "1145:             o += bytes([SWAP_OFFSET + int(item[4:])])",
          "1146:         elif isinstance(item, list):",
          "1147:             o += runtime_code",
          "1148:         else:",
          "1149:             # Should never reach because, assembly is create in _compile_to_assembly.",
          "1150:             raise Exception(\"Weird symbol in assembly: \" + str(item))  # pragma: no cover",
          "1152:     o += bytecode_suffix",
          "1156:     return o, line_number_map",
          "",
          "[Added Lines]",
          "1234:         if item in (\"DEBUG\",):",
          "1238:             # push a symbol to stack",
          "1239:             if not is_symbol_map_indicator(assembly[i + 1]):",
          "1240:                 bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=SYMBOL_SIZE))",
          "1241:                 ret.extend(bytecode)",
          "1245:             ret.extend(bytecode)",
          "1250:             n = mem_ofst_size if is_mem_sym(assembly[i + 1]) else SYMBOL_SIZE",
          "1252:             ret.extend(bytecode)",
          "1256:             ret.append(item)",
          "1258:             ret.append(get_opcodes()[item.upper()][0])",
          "1260:             ret.append(PUSH_OFFSET + int(item[4:]))",
          "1262:             ret.append(DUP_OFFSET + int(item[3:]))",
          "1264:             ret.append(SWAP_OFFSET + int(item[4:]))",
          "1265:         elif isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1266:             ret.extend(runtime_code)",
          "1267:         elif isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "1268:             ret.extend(_data_to_evm(item, symbol_map))",
          "1269:         else:  # pragma: no cover",
          "1270:             # unreachable",
          "1271:             raise ValueError(f\"Weird symbol in assembly: {type(item)} {item}\")",
          "1273:     ret.extend(bytecode_suffix)",
          "1277:     return bytes(ret), line_number_map, symbol_map",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-6327",
  "cve_desc": "drivers/infiniband/ulp/srpt/ib_srpt.c in the Linux kernel before 4.5.1 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an ABORT_TASK command to abort a device write operation.",
  "repo": "torvalds/linux",
  "patch_hash": "51093254bf879bc9ce96590400a87897c7498463",
  "patch_info": {
    "commit_hash": "51093254bf879bc9ce96590400a87897c7498463",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/51093254bf879bc9ce96590400a87897c7498463",
    "files": [
      "drivers/infiniband/ulp/srpt/ib_srpt.c"
    ],
    "message": "IB/srpt: Simplify srpt_handle_tsk_mgmt()\n\nLet the target core check task existence instead of the SRP target\ndriver. Additionally, let the target core check the validity of the\ntask management request instead of the ib_srpt driver.\n\nThis patch fixes the following kernel crash:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000001\nIP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]\nOops: 0002 [#1] SMP\nCall Trace:\n [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]\n [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]\n [<ffffffff8109726f>] kthread+0xcf/0xe0\n [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0\n\nSigned-off-by: Bart Van Assche <bart.vanassche@sandisk.com>\nFixes: 3e4f574857ee (\"ib_srpt: Convert TMR path to target_submit_tmr\")\nTested-by: Alex Estrin <alex.estrin@intel.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: Nicholas Bellinger <nab@linux-iscsi.org>\nCc: Sagi Grimberg <sagig@mellanox.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
    "before_after_code_files": [
      "drivers/infiniband/ulp/srpt/ib_srpt.c||drivers/infiniband/ulp/srpt/ib_srpt.c"
    ]
  },
  "patch_diff": {
    "drivers/infiniband/ulp/srpt/ib_srpt.c||drivers/infiniband/ulp/srpt/ib_srpt.c": [
      "File: drivers/infiniband/ulp/srpt/ib_srpt.c -> drivers/infiniband/ulp/srpt/ib_srpt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1670:  return -1;",
      "1671: }",
      "1714: static int srp_tmr_to_tcm(int fn)",
      "1715: {",
      "1716:  switch (fn) {",
      "",
      "[Removed Lines]",
      "1686: static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)",
      "1687: {",
      "1688:  struct srpt_device *sdev;",
      "1689:  struct srpt_rdma_ch *ch;",
      "1690:  struct srpt_send_ioctx *target;",
      "1691:  int ret, i;",
      "1693:  ret = -EINVAL;",
      "1694:  ch = ioctx->ch;",
      "1695:  BUG_ON(!ch);",
      "1696:  BUG_ON(!ch->sport);",
      "1697:  sdev = ch->sport->sdev;",
      "1698:  BUG_ON(!sdev);",
      "1699:  spin_lock_irq(&sdev->spinlock);",
      "1700:  for (i = 0; i < ch->rq_size; ++i) {",
      "1701:   target = ch->ioctx_ring[i];",
      "1702:   if (target->cmd.se_lun == ioctx->cmd.se_lun &&",
      "1703:       target->cmd.tag == tag &&",
      "1704:       srpt_get_cmd_state(target) != SRPT_STATE_DONE) {",
      "1705:    ret = 0;",
      "1707:    break;",
      "1708:   }",
      "1709:  }",
      "1710:  spin_unlock_irq(&sdev->spinlock);",
      "1711:  return ret;",
      "1712: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1745:  struct se_cmd *cmd;",
      "1746:  struct se_session *sess = ch->sess;",
      "1747:  uint64_t unpacked_lun;",
      "1749:  int tcm_tmr;",
      "1750:  int rc;",
      "",
      "[Removed Lines]",
      "1748:  uint32_t tag = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1761:  srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);",
      "1762:  send_ioctx->cmd.tag = srp_tsk->tag;",
      "1763:  tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);",
      "1769:  unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,",
      "1770:            sizeof(srp_tsk->lun));",
      "1781:  rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,",
      "1783:     TARGET_SCF_ACK_KREF);",
      "1784:  if (rc != 0) {",
      "1785:   send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;",
      "",
      "[Removed Lines]",
      "1764:  if (tcm_tmr < 0) {",
      "1765:   send_ioctx->cmd.se_tmr_req->response =",
      "1766:    TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;",
      "1767:   goto fail;",
      "1768:  }",
      "1772:  if (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {",
      "1773:   rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);",
      "1774:   if (rc < 0) {",
      "1775:    send_ioctx->cmd.se_tmr_req->response =",
      "1776:      TMR_TASK_DOES_NOT_EXIST;",
      "1777:    goto fail;",
      "1778:   }",
      "1779:   tag = srp_tsk->task_tag;",
      "1780:  }",
      "1782:     srp_tsk, tcm_tmr, GFP_KERNEL, tag,",
      "",
      "[Added Lines]",
      "1725:     srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "048b31ca97eaa33a74237ed7ef542503da9c0505",
      "candidate_info": {
        "commit_hash": "048b31ca97eaa33a74237ed7ef542503da9c0505",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/048b31ca97eaa33a74237ed7ef542503da9c0505",
        "files": [
          "drivers/iommu/io-pgtable-arm-v7s.c"
        ],
        "message": "iommu/io-pgtable-armv7s: Fix kmem_cache_alloc() flags\n\nWhilst the default SLUB allocator happily just merges the original\nallocation flags from kmem_cache_create() with those passed through\nkmem_cache_alloc(), there is a code path in the SLAB allocator which\nwill aggressively BUG_ON() if the cache was created with SLAB_CACHE_DMA\nbut GFP_DMA is not specified for an allocation:\n\n  kernel BUG at mm/slab.c:2536!\n  Internal error: Oops - BUG: 0 [#1] SMP ARM\n  Modules linked in:[    1.299311] Modules linked in:\n\n  CPU: 1 PID: 1 Comm: swapper/0 Not tainted\n  4.5.0-rc6-koelsch-05892-ge7e45ad53ab6795e #2270\n  Hardware name: Generic R8A7791 (Flattened Device Tree)\n  task: ef422040 ti: ef442000 task.ti: ef442000\n  PC is at cache_alloc_refill+0x2a0/0x530\n  LR is at _raw_spin_unlock+0x8/0xc\n...\n  [<c02c6928>] (cache_alloc_refill) from [<c02c6630>] (kmem_cache_alloc+0x7c/0xd4)\n  [<c02c6630>] (kmem_cache_alloc) from [<c04444bc>]\n  (__arm_v7s_alloc_table+0x5c/0x278)\n  [<c04444bc>] (__arm_v7s_alloc_table) from [<c0444e1c>]\n  (__arm_v7s_map.constprop.6+0x68/0x25c)\n  [<c0444e1c>] (__arm_v7s_map.constprop.6) from [<c0445044>]\n  (arm_v7s_map+0x34/0xa4)\n  [<c0445044>] (arm_v7s_map) from [<c0c18ee4>] (arm_v7s_do_selftests+0x140/0x418)\n  [<c0c18ee4>] (arm_v7s_do_selftests) from [<c0201760>]\n  (do_one_initcall+0x100/0x1b4)\n  [<c0201760>] (do_one_initcall) from [<c0c00d4c>]\n  (kernel_init_freeable+0x120/0x1e8)\n  [<c0c00d4c>] (kernel_init_freeable) from [<c067a364>] (kernel_init+0x8/0xec)\n  [<c067a364>] (kernel_init) from [<c0206b68>] (ret_from_fork+0x14/0x2c)\n  Code: 1a000003 e7f001f2 e3130001 0a000000 (e7f001f2)\n  ---[ end trace 190f6f6b84352efd ]---\n\nKeep the peace by adding GFP_DMA when allocating a table.\n\nReported-by: Geert Uytterhoeven <geert@linux-m68k.org>\nAcked-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Robin Murphy <robin.murphy@arm.com>\nTested-by: Geert Uytterhoeven <geert+renesas@glider.be>\nSigned-off-by: Joerg Roedel <jroedel@suse.de>",
        "before_after_code_files": [
          "drivers/iommu/io-pgtable-arm-v7s.c||drivers/iommu/io-pgtable-arm-v7s.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/iommu/io-pgtable-arm-v7s.c||drivers/iommu/io-pgtable-arm-v7s.c": [
          "File: drivers/iommu/io-pgtable-arm-v7s.c -> drivers/iommu/io-pgtable-arm-v7s.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "192:  if (lvl == 1)",
          "193:   table = (void *)__get_dma_pages(__GFP_ZERO, get_order(size));",
          "194:  else if (lvl == 2)",
          "196:  if (table && !selftest_running) {",
          "197:   dma = dma_map_single(dev, table, size, DMA_TO_DEVICE);",
          "198:   if (dma_mapping_error(dev, dma))",
          "",
          "[Removed Lines]",
          "195:   table = kmem_cache_zalloc(data->l2_tables, gfp);",
          "",
          "[Added Lines]",
          "195:   table = kmem_cache_zalloc(data->l2_tables, gfp | GFP_DMA);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "79e3f4a853ed161cd4c06d84b50beebf961a47c6",
      "candidate_info": {
        "commit_hash": "79e3f4a853ed161cd4c06d84b50beebf961a47c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/79e3f4a853ed161cd4c06d84b50beebf961a47c6",
        "files": [
          "drivers/pci/host/pci-keystone-dw.c"
        ],
        "message": "PCI: keystone: Fix MSI code that retrieves struct pcie_port pointer\n\nCommit cbce7900598c (\"PCI: designware: Make driver arch-agnostic\") changed\nthe host bridge sysdata pointer from the ARM pci_sys_data to the DesignWare\npcie_port structure, and changed pcie-designware.c to reflect that.  But it\ndid not change the corresponding code in pci-keystone-dw.c, so it caused\ncrashes on Keystone:\n\n  Unable to handle kernel NULL pointer dereference at virtual address 00000030\n  pgd = c0003000\n  [00000030] *pgd=80000800004003, *pmd=00000000\n  Internal error: Oops: 206 [#1] PREEMPT SMP ARM\n  CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.4.2-00139-gb74f926 #2\n  Hardware name: Keystone\n  PC is at ks_dw_pcie_msi_irq_unmask+0x24/0x58\n\nChange pci-keystone-dw.c to expect sysdata to be the struct pcie_port\npointer.\n\n[bhelgaas: changelog]\nFixes: cbce7900598c (\"PCI: designware: Make driver arch-agnostic\")\nSigned-off-by: Murali Karicheri <m-karicheri2@ti.com>\nSigned-off-by: Bjorn Helgaas <bhelgaas@google.com>\nCC: stable@vger.kernel.org\t# v4.4+\nCC: Zhou Wang <wangzhou1@hisilicon.com>",
        "before_after_code_files": [
          "drivers/pci/host/pci-keystone-dw.c||drivers/pci/host/pci-keystone-dw.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/pci/host/pci-keystone-dw.c||drivers/pci/host/pci-keystone-dw.c": [
          "File: drivers/pci/host/pci-keystone-dw.c -> drivers/pci/host/pci-keystone-dw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: #define to_keystone_pcie(x) container_of(x, struct keystone_pcie, pp)",
          "66: static inline void update_reg_offset_bit_pos(u32 offset, u32 *reg_offset,",
          "67:           u32 *bit_pos)",
          "68: {",
          "",
          "[Removed Lines]",
          "61: static inline struct pcie_port *sys_to_pcie(struct pci_sys_data *sys)",
          "62: {",
          "63:  return sys->private_data;",
          "64: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:  struct pcie_port *pp;",
          "110:  msi = irq_data_get_msi_desc(d);",
          "112:  ks_pcie = to_keystone_pcie(pp);",
          "113:  offset = d->irq - irq_linear_revmap(pp->irq_domain, 0);",
          "114:  update_reg_offset_bit_pos(offset, &reg_offset, &bit_pos);",
          "",
          "[Removed Lines]",
          "111:  pp = sys_to_pcie(msi_desc_to_pci_sysdata(msi));",
          "",
          "[Added Lines]",
          "106:  pp = (struct pcie_port *) msi_desc_to_pci_sysdata(msi);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:  u32 offset;",
          "148:  msi = irq_data_get_msi_desc(d);",
          "150:  ks_pcie = to_keystone_pcie(pp);",
          "151:  offset = d->irq - irq_linear_revmap(pp->irq_domain, 0);",
          "",
          "[Removed Lines]",
          "149:  pp = sys_to_pcie(msi_desc_to_pci_sysdata(msi));",
          "",
          "[Added Lines]",
          "144:  pp = (struct pcie_port *) msi_desc_to_pci_sysdata(msi);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "167:  u32 offset;",
          "169:  msi = irq_data_get_msi_desc(d);",
          "171:  ks_pcie = to_keystone_pcie(pp);",
          "172:  offset = d->irq - irq_linear_revmap(pp->irq_domain, 0);",
          "",
          "[Removed Lines]",
          "170:  pp = sys_to_pcie(msi_desc_to_pci_sysdata(msi));",
          "",
          "[Added Lines]",
          "165:  pp = (struct pcie_port *) msi_desc_to_pci_sysdata(msi);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "90c83176e5cfa666bb2e7643d74ca87e08e171cb",
      "candidate_info": {
        "commit_hash": "90c83176e5cfa666bb2e7643d74ca87e08e171cb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/90c83176e5cfa666bb2e7643d74ca87e08e171cb",
        "files": [
          "drivers/video/fbdev/bt431.h",
          "drivers/video/fbdev/pmag-aa-fb.c"
        ],
        "message": "video: fbdev: pmag-aa-fb: Adapt to current APIs\n\nRework the driver to use the current frambuffer and TURBOchannel APIs,\nincluding proper resource management and using the new framework for\nhardware cursor support.\n\nNB two Bt431 cursor generators are included onboard, both responding at\nthe same TURBOchannel bus addresses and with their host data buses wired\nto byte lanes #0 and #1 respectively of the 32-bit bus.  Therefore both\ncan be accessed simultaneously with 16-bit data transfers.  Cursor\noutputs of the chip wired to lane #0 drive the respective overlay select\ninputs of the Bt455 RAMDAC, whereas cursor outputs of the chip wired to\nlane #1 drive the respective P3 pixel select inputs of the RAMDAC.\n\nSo 5 (out of 17) Bt455 color registers are usable with this board:\npalette entries #0 and #1 for frame buffer pixel data driven while\nneither cursor generator is active, palette entries #8 and #9 for frame\nbuffer pixel data driven while cursor generator #1 is active only and\nthe overlay entry while cursor generator #0 is active.\n\nSigned-off-by: Maciej W. Rozycki <macro@linux-mips.org>\nSigned-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>",
        "before_after_code_files": [
          "drivers/video/fbdev/bt431.h||drivers/video/fbdev/bt431.h",
          "drivers/video/fbdev/pmag-aa-fb.c||drivers/video/fbdev/pmag-aa-fb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/video/fbdev/bt431.h||drivers/video/fbdev/bt431.h": [
          "File: drivers/video/fbdev/bt431.h -> drivers/video/fbdev/bt431.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <linux/types.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #define BT431_CURSOR_SIZE 64",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197: }",
          "201: {",
          "202:  int i;",
          "206:  bt431_select_reg(regs, BT431_REG_CRAM_BASE);",
          "221: }",
          "223: static inline void bt431_init_cursor(struct bt431_regs *regs)",
          "",
          "[Removed Lines]",
          "199: static inline void bt431_set_font(struct bt431_regs *regs, u8 fgc,",
          "200:       u16 width, u16 height)",
          "203:  u16 fgp = fgc ? 0xffff : 0x0000;",
          "204:  u16 bgp = fgc ? 0x0000 : 0xffff;",
          "207:  for (i = BT431_REG_CRAM_BASE; i <= BT431_REG_CRAM_END; i++) {",
          "208:   u16 value;",
          "210:   if (height << 6 <= i << 3)",
          "211:    value = bgp;",
          "212:   else if (width <= i % 8 << 3)",
          "213:    value = bgp;",
          "214:   else if (((width >> 3) & 0xffff) > i % 8)",
          "215:    value = fgp;",
          "216:   else",
          "217:    value = fgp & ~(bgp << (width % 8 << 1));",
          "219:   bt431_write_cmap_inc(regs, value);",
          "220:  }",
          "",
          "[Added Lines]",
          "202: static inline void bt431_set_cursor(struct bt431_regs *regs,",
          "203:         const char *data, const char *mask,",
          "204:         u16 rop, u16 width, u16 height)",
          "206:  u16 x, y;",
          "209:  i = 0;",
          "210:  width = DIV_ROUND_UP(width, 8);",
          "212:  for (y = 0; y < BT431_CURSOR_SIZE; y++)",
          "213:   for (x = 0; x < BT431_CURSOR_SIZE / 8; x++) {",
          "214:    u16 val = 0;",
          "216:    if (y < height && x < width) {",
          "217:     val = mask[i];",
          "218:     if (rop == ROP_XOR)",
          "219:      val = (val << 8) | (val ^ data[i]);",
          "220:     else",
          "221:      val = (val << 8) | (val & data[i]);",
          "222:     i++;",
          "223:    }",
          "224:    bt431_write_cmap_inc(regs, val);",
          "225:   }",
          "",
          "---------------"
        ],
        "drivers/video/fbdev/pmag-aa-fb.c||drivers/video/fbdev/pmag-aa-fb.c": [
          "File: drivers/video/fbdev/pmag-aa-fb.c -> drivers/video/fbdev/pmag-aa-fb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <linux/errno.h>",
          "33: #include <linux/fb.h>",
          "43: #include \"bt455.h\"",
          "44: #include \"bt431.h\"",
          "48: #define DRIVER_AUTHOR \"Karsten Merker <merker@linuxtag.org>\"",
          "49: #define DRIVER_DESCRIPTION \"PMAG-AA Framebuffer Driver\"",
          "",
          "[Removed Lines]",
          "25: #include <linux/module.h>",
          "26: #include <linux/kernel.h>",
          "28: #include <linux/string.h>",
          "29: #include <linux/timer.h>",
          "30: #include <linux/mm.h>",
          "31: #include <linux/delay.h>",
          "32: #include <linux/init.h>",
          "34: #include <linux/console.h>",
          "36: #include <asm/bootinfo.h>",
          "37: #include <asm/dec/machtype.h>",
          "38: #include <asm/dec/tc.h>",
          "40: #include <video/fbcon.h>",
          "41: #include <video/fbcon-cfb8.h>",
          "47: #define DRIVER_VERSION \"0.02\"",
          "52: static int aafb_set_var(struct fb_var_screeninfo *var, int con,",
          "53:    struct fb_info *info);",
          "",
          "[Added Lines]",
          "30: #include <linux/compiler.h>",
          "33: #include <linux/init.h>",
          "34: #include <linux/io.h>",
          "35: #include <linux/kernel.h>",
          "36: #include <linux/module.h>",
          "37: #include <linux/tc.h>",
          "38: #include <linux/timer.h>",
          "44: #define DRIVER_VERSION \"0.03\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69: #define PMAG_AA_ONBOARD_FBMEM_OFFSET 0x200000",
          "78: };",
          "93: };",
          "149: {",
          "155:   return -EINVAL;",
          "177:  }",
          "280:  return 0;",
          "281: }",
          "306: {",
          "318:  return 0;",
          "319: }",
          "353: {",
          "386:  return 0;",
          "465: }",
          "468: {",
          "474:  return 0;",
          "475: }",
          "492: }",
          "494: static void __exit pmagaafb_exit(void)",
          "495: {",
          "502: }",
          "504: MODULE_AUTHOR(DRIVER_AUTHOR);",
          "505: MODULE_DESCRIPTION(DRIVER_DESCRIPTION);",
          "506: MODULE_LICENSE(\"GPL\");",
          "",
          "[Removed Lines]",
          "71: struct aafb_cursor {",
          "72:  struct timer_list timer;",
          "73:  int enable;",
          "74:  int on;",
          "75:  int vbl_cnt;",
          "76:  int blink_rate;",
          "77:  u16 x, y, width, height;",
          "80: #define CURSOR_TIMER_FREQ (HZ / 50)",
          "81: #define CURSOR_BLINK_RATE (20)",
          "82: #define CURSOR_DRAW_DELAY (2)",
          "84: struct aafb_info {",
          "85:  struct fb_info info;",
          "86:  struct display disp;",
          "87:  struct aafb_cursor cursor;",
          "88:  struct bt455_regs *bt455;",
          "89:  struct bt431_regs *bt431;",
          "90:  unsigned long fb_start;",
          "91:  unsigned long fb_size;",
          "92:  unsigned long fb_line_length;",
          "98: static struct aafb_info my_fb_info[3];",
          "100: static struct aafb_par {",
          "101: } current_par;",
          "103: static int currcon = -1;",
          "105: static void aafb_set_cursor(struct aafb_info *info, int on)",
          "106: {",
          "107:  struct aafb_cursor *c = &info->cursor;",
          "109:  if (on) {",
          "110:   bt431_position_cursor(info->bt431, c->x, c->y);",
          "111:   bt431_enable_cursor(info->bt431);",
          "112:  } else",
          "113:   bt431_erase_cursor(info->bt431);",
          "114: }",
          "116: static void aafbcon_cursor(struct display *disp, int mode, int x, int y)",
          "117: {",
          "118:  struct aafb_info *info = (struct aafb_info *)disp->fb_info;",
          "119:  struct aafb_cursor *c = &info->cursor;",
          "121:  x *= fontwidth(disp);",
          "122:  y *= fontheight(disp);",
          "124:  if (c->x == x && c->y == y && (mode == CM_ERASE) == !c->enable)",
          "125:   return;",
          "127:  c->enable = 0;",
          "128:  if (c->on)",
          "129:   aafb_set_cursor(info, 0);",
          "130:  c->x = x - disp->var.xoffset;",
          "131:  c->y = y - disp->var.yoffset;",
          "133:  switch (mode) {",
          "134:   case CM_ERASE:",
          "135:    c->on = 0;",
          "136:    break;",
          "137:   case CM_DRAW:",
          "138:   case CM_MOVE:",
          "139:    if (c->on)",
          "140:     aafb_set_cursor(info, c->on);",
          "141:    else",
          "142:     c->vbl_cnt = CURSOR_DRAW_DELAY;",
          "143:    c->enable = 1;",
          "144:    break;",
          "145:  }",
          "146: }",
          "148: static int aafbcon_set_font(struct display *disp, int width, int height)",
          "150:  struct aafb_info *info = (struct aafb_info *)disp->fb_info;",
          "151:  struct aafb_cursor *c = &info->cursor;",
          "152:  u8 fgc = ~attr_bgcol_ec(disp, disp->conp, &info->info);",
          "154:  if (width > 64 || height > 64 || width < 0 || height < 0)",
          "157:  c->height = height;",
          "158:  c->width = width;",
          "160:  bt431_set_font(info->bt431, fgc, width, height);",
          "162:  return 1;",
          "163: }",
          "165: static void aafb_cursor_timer_handler(unsigned long data)",
          "166: {",
          "167:  struct aafb_info *info = (struct aafb_info *)data;",
          "168:  struct aafb_cursor *c = &info->cursor;",
          "170:  if (!c->enable)",
          "171:   goto out;",
          "173:  if (c->vbl_cnt && --c->vbl_cnt == 0) {",
          "174:   c->on ^= 1;",
          "175:   aafb_set_cursor(info, c->on);",
          "176:   c->vbl_cnt = c->blink_rate;",
          "179: out:",
          "180:  c->timer.expires = jiffies + CURSOR_TIMER_FREQ;",
          "181:  add_timer(&c->timer);",
          "182: }",
          "184: static void __init aafb_cursor_init(struct aafb_info *info)",
          "185: {",
          "186:  struct aafb_cursor *c = &info->cursor;",
          "188:  c->enable = 1;",
          "189:  c->on = 1;",
          "190:  c->x = c->y = 0;",
          "191:  c->width = c->height = 0;",
          "192:  c->vbl_cnt = CURSOR_DRAW_DELAY;",
          "193:  c->blink_rate = CURSOR_BLINK_RATE;",
          "195:  init_timer(&c->timer);",
          "196:  c->timer.data = (unsigned long)info;",
          "197:  c->timer.function = aafb_cursor_timer_handler;",
          "198:  mod_timer(&c->timer, jiffies + CURSOR_TIMER_FREQ);",
          "199: }",
          "201: static void __exit aafb_cursor_exit(struct aafb_info *info)",
          "202: {",
          "203:  struct aafb_cursor *c = &info->cursor;",
          "205:  del_timer_sync(&c->timer);",
          "206: }",
          "208: static struct display_switch aafb_switch8 = {",
          "209:  .setup = fbcon_cfb8_setup,",
          "210:  .bmove = fbcon_cfb8_bmove,",
          "211:  .clear = fbcon_cfb8_clear,",
          "212:  .putc = fbcon_cfb8_putc,",
          "213:  .putcs = fbcon_cfb8_putcs,",
          "214:  .revc = fbcon_cfb8_revc,",
          "215:  .cursor = aafbcon_cursor,",
          "216:  .set_font = aafbcon_set_font,",
          "217:  .clear_margins = fbcon_cfb8_clear_margins,",
          "218:  .fontwidthmask = FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)",
          "219: };",
          "221: static void aafb_get_par(struct aafb_par *par)",
          "222: {",
          "224: }",
          "226: static int aafb_get_fix(struct fb_fix_screeninfo *fix, int con,",
          "227:    struct fb_info *info)",
          "228: {",
          "229:  struct aafb_info *ip = (struct aafb_info *)info;",
          "231:  memset(fix, 0, sizeof(struct fb_fix_screeninfo));",
          "232:  strcpy(fix->id, \"PMAG-AA\");",
          "233:  fix->smem_start = ip->fb_start;",
          "234:  fix->smem_len = ip->fb_size;",
          "235:  fix->type = FB_TYPE_PACKED_PIXELS;",
          "236:  fix->ypanstep = 1;",
          "237:  fix->ywrapstep = 1;",
          "238:  fix->visual = FB_VISUAL_MONO10;",
          "239:  fix->line_length = 1280;",
          "240:  fix->accel = FB_ACCEL_NONE;",
          "242:  return 0;",
          "243: }",
          "245: static void aafb_set_disp(struct display *disp, int con,",
          "246:      struct aafb_info *info)",
          "247: {",
          "248:  struct fb_fix_screeninfo fix;",
          "250:  disp->fb_info = &info->info;",
          "251:  aafb_set_var(&disp->var, con, &info->info);",
          "252:  if (disp->conp && disp->conp->vc_sw && disp->conp->vc_sw->con_cursor)",
          "253:   disp->conp->vc_sw->con_cursor(disp->conp, CM_ERASE);",
          "254:  disp->dispsw = &aafb_switch8;",
          "255:  disp->dispsw_data = 0;",
          "257:  aafb_get_fix(&fix, con, &info->info);",
          "258:  disp->screen_base = (u8 *) fix.smem_start;",
          "259:  disp->visual = fix.visual;",
          "260:  disp->type = fix.type;",
          "261:  disp->type_aux = fix.type_aux;",
          "262:  disp->ypanstep = fix.ypanstep;",
          "263:  disp->ywrapstep = fix.ywrapstep;",
          "264:  disp->line_length = fix.line_length;",
          "265:  disp->next_line = 2048;",
          "266:  disp->can_soft_blank = 1;",
          "267:  disp->inverse = 0;",
          "268:  disp->scrollmode = SCROLL_YREDRAW;",
          "270:  aafbcon_set_font(disp, fontwidth(disp), fontheight(disp));",
          "271: }",
          "273: static int aafb_get_cmap(struct fb_cmap *cmap, int kspc, int con,",
          "274:     struct fb_info *info)",
          "275: {",
          "276:  static u16 color[2] = {0x0000, 0x000f};",
          "277:  static struct fb_cmap aafb_cmap = {0, 2, color, color, color, NULL};",
          "279:  fb_copy_cmap(&aafb_cmap, cmap, kspc ? 0 : 2);",
          "283: static int aafb_set_cmap(struct fb_cmap *cmap, int kspc, int con,",
          "284:     struct fb_info *info)",
          "285: {",
          "286:  u16 color[2] = {0x0000, 0x000f};",
          "288:  if (cmap->start == 0",
          "289:      && cmap->len == 2",
          "290:      && memcmp(cmap->red, color, sizeof(color)) == 0",
          "291:      && memcmp(cmap->green, color, sizeof(color)) == 0",
          "292:      && memcmp(cmap->blue, color, sizeof(color)) == 0",
          "293:      && cmap->transp == NULL)",
          "294:   return 0;",
          "295:  else",
          "296:   return -EINVAL;",
          "297: }",
          "299: static int aafb_ioctl(struct fb_info *info, u32 cmd, unsigned long arg)",
          "300: {",
          "302:  return -ENOIOCTLCMD;",
          "303: }",
          "305: static int aafb_switch(int con, struct fb_info *info)",
          "307:  struct aafb_info *ip = (struct aafb_info *)info;",
          "308:  struct display *old = (currcon < 0) ? &ip->disp : (fb_display + currcon);",
          "309:  struct display *new = (con < 0) ? &ip->disp : (fb_display + con);",
          "311:  if (old->conp && old->conp->vc_sw && old->conp->vc_sw->con_cursor)",
          "312:   old->conp->vc_sw->con_cursor(old->conp, CM_ERASE);",
          "315:  currcon = con;",
          "316:  aafb_set_disp(new, con, ip);",
          "321: static void aafb_encode_var(struct fb_var_screeninfo *var,",
          "322:        struct aafb_par *par)",
          "323: {",
          "324:  var->xres = 1280;",
          "325:  var->yres = 1024;",
          "326:  var->xres_virtual = 2048;",
          "327:  var->yres_virtual = 1024;",
          "328:  var->xoffset = 0;",
          "329:  var->yoffset = 0;",
          "330:  var->bits_per_pixel = 8;",
          "331:  var->grayscale = 1;",
          "332:  var->red.offset = 0;",
          "333:  var->red.length = 0;",
          "334:  var->red.msb_right = 0;",
          "335:  var->green.offset = 0;",
          "336:  var->green.length = 1;",
          "337:  var->green.msb_right = 0;",
          "338:  var->blue.offset = 0;",
          "339:  var->blue.length = 0;",
          "340:  var->blue.msb_right = 0;",
          "341:  var->transp.offset = 0;",
          "342:  var->transp.length = 0;",
          "343:  var->transp.msb_right = 0;",
          "344:  var->nonstd = 0;",
          "345:  var->activate &= ~FB_ACTIVATE_MASK & FB_ACTIVATE_NOW;",
          "346:  var->accel_flags = 0;",
          "347:  var->sync = FB_SYNC_ON_GREEN;",
          "348:  var->vmode &= ~FB_VMODE_MASK & FB_VMODE_NONINTERLACED;",
          "349: }",
          "351: static int aafb_get_var(struct fb_var_screeninfo *var, int con,",
          "352:    struct fb_info *info)",
          "354:  if (con < 0) {",
          "355:   struct aafb_par par;",
          "357:   memset(var, 0, sizeof(struct fb_var_screeninfo));",
          "358:   aafb_get_par(&par);",
          "359:   aafb_encode_var(var, &par);",
          "360:  } else",
          "363:  return 0;",
          "364: }",
          "366: static int aafb_set_var(struct fb_var_screeninfo *var, int con,",
          "367:    struct fb_info *info)",
          "368: {",
          "369:  struct aafb_par par;",
          "371:  aafb_get_par(&par);",
          "372:  aafb_encode_var(var, &par);",
          "373:  info->var = *var;",
          "375:  return 0;",
          "376: }",
          "378: static int aafb_update_var(int con, struct fb_info *info)",
          "379: {",
          "380:  struct aafb_info *ip = (struct aafb_info *)info;",
          "381:  struct display *disp = (con < 0) ? &ip->disp : (fb_display + con);",
          "383:  if (con == currcon)",
          "384:   aafbcon_cursor(disp, CM_ERASE, ip->cursor.x, ip->cursor.y);",
          "387: }",
          "391: static void aafb_blank(int blank, struct fb_info *info)",
          "392: {",
          "393:  struct aafb_info *ip = (struct aafb_info *)info;",
          "394:  u8 val = blank ? 0x00 : 0x0f;",
          "396:  bt455_write_cmap_entry(ip->bt455, 1, val, val, val);",
          "397:  aafbcon_cursor(&ip->disp, CM_ERASE, ip->cursor.x, ip->cursor.y);",
          "398: }",
          "400: static struct fb_ops aafb_ops = {",
          "401:  .owner = THIS_MODULE,",
          "402:  .fb_get_fix = aafb_get_fix,",
          "403:  .fb_get_var = aafb_get_var,",
          "404:  .fb_set_var = aafb_set_var,",
          "405:  .fb_get_cmap = aafb_get_cmap,",
          "406:  .fb_set_cmap = aafb_set_cmap,",
          "407:  .fb_ioctl = aafb_ioctl",
          "408: };",
          "410: static int __init init_one(int slot)",
          "411: {",
          "412:  unsigned long base_addr = CKSEG1ADDR(get_tc_base_addr(slot));",
          "413:  struct aafb_info *ip = &my_fb_info[slot];",
          "415:  memset(ip, 0, sizeof(struct aafb_info));",
          "420:  ip->bt455 = (struct bt455_regs *) (base_addr + PMAG_AA_BT455_OFFSET);",
          "421:  ip->bt431 = (struct bt431_regs *) (base_addr + PMAG_AA_BT431_OFFSET);",
          "422:  ip->fb_start = base_addr + PMAG_AA_ONBOARD_FBMEM_OFFSET;",
          "423:  ip->fb_size = 2048 * 1024; /* fb_fix_screeninfo.smem_length",
          "425:  ip->fb_line_length = 2048;",
          "430:  strcpy(ip->info.modename, \"PMAG-AA\");",
          "431:  ip->info.node = -1;",
          "432:  ip->info.flags = FBINFO_FLAG_DEFAULT;",
          "433:  ip->info.fbops = &aafb_ops;",
          "434:  ip->info.disp = &ip->disp;",
          "435:  ip->info.changevar = NULL;",
          "436:  ip->info.switch_con = &aafb_switch;",
          "437:  ip->info.updatevar = &aafb_update_var;",
          "438:  ip->info.blank = &aafb_blank;",
          "440:  aafb_set_disp(&ip->disp, currcon, ip);",
          "445:  bt455_erase_cursor(ip->bt455);",
          "448:  bt455_write_cmap_entry(ip->bt455, 0, 0x00, 0x00, 0x00);",
          "449:  bt455_write_cmap_entry(ip->bt455, 1, 0x0f, 0x0f, 0x0f);",
          "452:  bt431_init_cursor(ip->bt431);",
          "453:  aafb_cursor_init(ip);",
          "456:  memset ((void *)ip->fb_start, 0, ip->fb_size);",
          "458:  if (register_framebuffer(&ip->info) < 0)",
          "459:   return -EINVAL;",
          "461:  printk(KERN_INFO \"fb%d: %s frame buffer in TC slot %d\\n\",",
          "462:         GET_FB_IDX(ip->info.node), ip->info.modename, slot);",
          "464:  return 0;",
          "467: static int __exit exit_one(int slot)",
          "469:  struct aafb_info *ip = &my_fb_info[slot];",
          "471:  if (unregister_framebuffer(&ip->info) < 0)",
          "472:   return -EINVAL;",
          "480: int __init pmagaafb_init(void)",
          "481: {",
          "482:  int sid;",
          "483:  int found = 0;",
          "485:  while ((sid = search_tc_card(\"PMAG-AA\")) >= 0) {",
          "486:   found = 1;",
          "487:   claim_tc_card(sid);",
          "488:   init_one(sid);",
          "489:  }",
          "491:  return found ? 0 : -ENXIO;",
          "496:  int sid;",
          "498:  while ((sid = search_tc_card(\"PMAG-AA\")) >= 0) {",
          "499:   exit_one(sid);",
          "500:   release_tc_card(sid);",
          "501:  }",
          "507: #ifdef MODULE",
          "508: module_init(pmagaafb_init);",
          "509: module_exit(pmagaafb_exit);",
          "510: #endif",
          "",
          "[Added Lines]",
          "64: struct aafb_par {",
          "65:  void __iomem *mmio;",
          "66:  struct bt455_regs __iomem *bt455;",
          "67:  struct bt431_regs __iomem *bt431;",
          "70: static struct fb_var_screeninfo aafb_defined = {",
          "71:  .xres  = 1280,",
          "72:  .yres  = 1024,",
          "73:  .xres_virtual = 2048,",
          "74:  .yres_virtual = 1024,",
          "75:  .bits_per_pixel = 8,",
          "76:  .grayscale = 1,",
          "77:  .red.length = 0,",
          "78:  .green.length = 1,",
          "79:  .blue.length = 0,",
          "80:  .activate = FB_ACTIVATE_NOW,",
          "81:  .accel_flags = FB_ACCEL_NONE,",
          "82:  .sync  = FB_SYNC_ON_GREEN,",
          "83:  .vmode  = FB_VMODE_NONINTERLACED,",
          "86: static struct fb_fix_screeninfo aafb_fix = {",
          "87:  .id  = \"PMAG-AA\",",
          "88:  .smem_len = (2048 * 1024),",
          "89:  .type  = FB_TYPE_PACKED_PIXELS,",
          "90:  .visual  = FB_VISUAL_MONO10,",
          "91:  .ypanstep = 1,",
          "92:  .ywrapstep = 1,",
          "93:  .line_length = 2048,",
          "94:  .mmio_len = PMAG_AA_ONBOARD_FBMEM_OFFSET - PMAG_AA_BT455_OFFSET,",
          "95: };",
          "97: static int aafb_cursor(struct fb_info *info, struct fb_cursor *cursor)",
          "99:  struct aafb_par *par = info->par;",
          "101:  if (cursor->image.height > BT431_CURSOR_SIZE ||",
          "102:      cursor->image.width > BT431_CURSOR_SIZE) {",
          "103:   bt431_erase_cursor(par->bt431);",
          "107:  if (!cursor->enable)",
          "108:   bt431_erase_cursor(par->bt431);",
          "110:  if (cursor->set & FB_CUR_SETPOS)",
          "111:   bt431_position_cursor(par->bt431,",
          "112:           cursor->image.dx, cursor->image.dy);",
          "113:  if (cursor->set & FB_CUR_SETCMAP) {",
          "114:   u8 fg = cursor->image.fg_color ? 0xf : 0x0;",
          "115:   u8 bg = cursor->image.bg_color ? 0xf : 0x0;",
          "117:   bt455_write_cmap_entry(par->bt455, 8, 0, bg, 0);",
          "118:   bt455_write_cmap_entry(par->bt455, 9, 0, bg, 0);",
          "119:   bt455_write_ovly_entry(par->bt455, 0, 0, fg, 0);",
          "120:  }",
          "121:  if (cursor->set & (FB_CUR_SETSIZE | FB_CUR_SETSHAPE | FB_CUR_SETIMAGE))",
          "122:   bt431_set_cursor(par->bt431,",
          "123:      cursor->image.data, cursor->mask, cursor->rop,",
          "124:      cursor->image.width, cursor->image.height);",
          "126:  if (cursor->enable)",
          "127:   bt431_enable_cursor(par->bt431);",
          "134: static int aafb_blank(int blank, struct fb_info *info)",
          "136:  struct aafb_par *par = info->par;",
          "137:  u8 val = blank ? 0x00 : 0x0f;",
          "139:  bt455_write_cmap_entry(par->bt455, 1, val, val, val);",
          "143: static struct fb_ops aafb_ops = {",
          "144:  .owner  = THIS_MODULE,",
          "145:  .fb_blank = aafb_blank,",
          "146:  .fb_fillrect = cfb_fillrect,",
          "147:  .fb_copyarea = cfb_copyarea,",
          "148:  .fb_imageblit = cfb_imageblit,",
          "149:  .fb_cursor = aafb_cursor,",
          "150: };",
          "152: static int pmagaafb_probe(struct device *dev)",
          "154:  struct tc_dev *tdev = to_tc_dev(dev);",
          "155:  resource_size_t start, len;",
          "156:  struct fb_info *info;",
          "157:  struct aafb_par *par;",
          "158:  int err;",
          "160:  info = framebuffer_alloc(sizeof(struct aafb_par), dev);",
          "161:  if (!info) {",
          "162:   printk(KERN_ERR \"%s: Cannot allocate memory\\n\", dev_name(dev));",
          "163:   return -ENOMEM;",
          "164:  }",
          "166:  par = info->par;",
          "167:  dev_set_drvdata(dev, info);",
          "169:  info->fbops = &aafb_ops;",
          "170:  info->fix = aafb_fix;",
          "171:  info->var = aafb_defined;",
          "172:  info->flags = FBINFO_DEFAULT;",
          "175:  start = tdev->resource.start;",
          "176:  len = tdev->resource.end - start + 1;",
          "177:  if (!request_mem_region(start, len, dev_name(dev))) {",
          "178:   printk(KERN_ERR \"%s: Cannot reserve FB region\\n\",",
          "179:          dev_name(dev));",
          "180:   err = -EBUSY;",
          "181:   goto err_alloc;",
          "182:  }",
          "185:  info->fix.mmio_start = start + PMAG_AA_BT455_OFFSET;",
          "186:  par->mmio = ioremap_nocache(info->fix.mmio_start, info->fix.mmio_len);",
          "187:  if (!par->mmio) {",
          "188:   printk(KERN_ERR \"%s: Cannot map MMIO\\n\", dev_name(dev));",
          "189:   err = -ENOMEM;",
          "190:   goto err_resource;",
          "191:  }",
          "192:  par->bt455 = par->mmio - PMAG_AA_BT455_OFFSET + PMAG_AA_BT455_OFFSET;",
          "193:  par->bt431 = par->mmio - PMAG_AA_BT455_OFFSET + PMAG_AA_BT431_OFFSET;",
          "196:  info->fix.smem_start = start + PMAG_AA_ONBOARD_FBMEM_OFFSET;",
          "197:  info->screen_base = ioremap_nocache(info->fix.smem_start,",
          "198:          info->fix.smem_len);",
          "199:  if (!info->screen_base) {",
          "200:   printk(KERN_ERR \"%s: Cannot map FB\\n\", dev_name(dev));",
          "201:   err = -ENOMEM;",
          "202:   goto err_mmio_map;",
          "203:  }",
          "204:  info->screen_size = info->fix.smem_len;",
          "207:  bt455_write_cmap_entry(par->bt455, 0, 0x00, 0x00, 0x00);",
          "208:  bt455_write_cmap_entry(par->bt455, 1, 0x0f, 0x0f, 0x0f);",
          "211:  bt431_erase_cursor(par->bt431);",
          "212:  bt431_init_cursor(par->bt431);",
          "214:  err = register_framebuffer(info);",
          "215:  if (err < 0) {",
          "216:   printk(KERN_ERR \"%s: Cannot register framebuffer\\n\",",
          "217:          dev_name(dev));",
          "218:   goto err_smem_map;",
          "219:  }",
          "221:  get_device(dev);",
          "223:  pr_info(\"fb%d: %s frame buffer device at %s\\n\",",
          "224:   info->node, info->fix.id, dev_name(dev));",
          "229: err_smem_map:",
          "230:  iounmap(info->screen_base);",
          "232: err_mmio_map:",
          "233:  iounmap(par->mmio);",
          "235: err_resource:",
          "236:  release_mem_region(start, len);",
          "238: err_alloc:",
          "239:  framebuffer_release(info);",
          "240:  return err;",
          "243: static int __exit pmagaafb_remove(struct device *dev)",
          "245:  struct tc_dev *tdev = to_tc_dev(dev);",
          "246:  struct fb_info *info = dev_get_drvdata(dev);",
          "247:  struct aafb_par *par = info->par;",
          "248:  resource_size_t start, len;",
          "250:  put_device(dev);",
          "251:  unregister_framebuffer(info);",
          "252:  iounmap(info->screen_base);",
          "253:  iounmap(par->mmio);",
          "254:  start = tdev->resource.start;",
          "255:  len = tdev->resource.end - start + 1;",
          "256:  release_mem_region(start, len);",
          "257:  framebuffer_release(info);",
          "264: static const struct tc_device_id pmagaafb_tc_table[] = {",
          "265:  { \"DEC     \", \"PMAG-AA \" },",
          "266:  { }",
          "267: };",
          "268: MODULE_DEVICE_TABLE(tc, pmagaafb_tc_table);",
          "270: static struct tc_driver pmagaafb_driver = {",
          "271:  .id_table = pmagaafb_tc_table,",
          "272:  .driver  = {",
          "273:   .name = \"pmagaafb\",",
          "274:   .bus = &tc_bus_type,",
          "275:   .probe = pmagaafb_probe,",
          "276:   .remove = __exit_p(pmagaafb_remove),",
          "277:  },",
          "278: };",
          "280: static int __init pmagaafb_init(void)",
          "281: {",
          "282: #ifndef MODULE",
          "283:  if (fb_get_options(\"pmagaafb\", NULL))",
          "284:   return -ENXIO;",
          "285: #endif",
          "286:  return tc_register_driver(&pmagaafb_driver);",
          "291:  tc_unregister_driver(&pmagaafb_driver);",
          "294: module_init(pmagaafb_init);",
          "295: module_exit(pmagaafb_exit);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ec9a1ae1e30c733077c0b288c4301b66b7a81f2",
      "candidate_info": {
        "commit_hash": "1ec9a1ae1e30c733077c0b288c4301b66b7a81f2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1ec9a1ae1e30c733077c0b288c4301b66b7a81f2",
        "files": [
          "fs/btrfs/ioctl.c",
          "fs/btrfs/tree-log.c",
          "fs/btrfs/tree-log.h"
        ],
        "message": "Btrfs: fix unreplayable log after snapshot delete + parent dir fsync\n\nIf we delete a snapshot, fsync its parent directory and crash/power fail\nbefore the next transaction commit, on the next mount when we attempt to\nreplay the log tree of the root containing the parent directory we will\nfail and prevent the filesystem from mounting, which is solvable by wiping\nout the log trees with the btrfs-zero-log tool but very inconvenient as\nwe will lose any data and metadata fsynced before the parent directory\nwas fsynced.\n\nFor example:\n\n  $ mkfs.btrfs -f /dev/sdc\n  $ mount /dev/sdc /mnt\n  $ mkdir /mnt/testdir\n  $ btrfs subvolume snapshot /mnt /mnt/testdir/snap\n  $ btrfs subvolume delete /mnt/testdir/snap\n  $ xfs_io -c \"fsync\" /mnt/testdir\n  < crash / power failure and reboot >\n  $ mount /dev/sdc /mnt\n  mount: mount(2) failed: No such file or directory\n\nAnd in dmesg/syslog we get the following message and trace:\n\n[192066.361162] BTRFS info (device dm-0): failed to delete reference to snap, inode 257 parent 257\n[192066.363010] ------------[ cut here ]------------\n[192066.365268] WARNING: CPU: 4 PID: 5130 at fs/btrfs/inode.c:3986 __btrfs_unlink_inode+0x17a/0x354 [btrfs]()\n[192066.367250] BTRFS: Transaction aborted (error -2)\n[192066.368401] Modules linked in: btrfs dm_flakey dm_mod ppdev sha256_generic xor raid6_pq hmac drbg ansi_cprng aesni_intel acpi_cpufreq tpm_tis aes_x86_64 tpm ablk_helper evdev cryptd sg parport_pc i2c_piix4 psmouse lrw parport i2c_core pcspkr gf128mul processor serio_raw glue_helper button loop autofs4 ext4 crc16 mbcache jbd2 sd_mod sr_mod cdrom ata_generic virtio_scsi ata_piix libata virtio_pci virtio_ring crc32c_intel scsi_mod e1000 virtio floppy [last unloaded: btrfs]\n[192066.377154] CPU: 4 PID: 5130 Comm: mount Tainted: G        W       4.4.0-rc6-btrfs-next-20+ #1\n[192066.378875] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS by qemu-project.org 04/01/2014\n[192066.380889]  0000000000000000 ffff880143923670 ffffffff81257570 ffff8801439236b8\n[192066.382561]  ffff8801439236a8 ffffffff8104ec07 ffffffffa039dc2c 00000000fffffffe\n[192066.384191]  ffff8801ed31d000 ffff8801b9fc9c88 ffff8801086875e0 ffff880143923710\n[192066.385827] Call Trace:\n[192066.386373]  [<ffffffff81257570>] dump_stack+0x4e/0x79\n[192066.387387]  [<ffffffff8104ec07>] warn_slowpath_common+0x99/0xb2\n[192066.388429]  [<ffffffffa039dc2c>] ? __btrfs_unlink_inode+0x17a/0x354 [btrfs]\n[192066.389236]  [<ffffffff8104ec68>] warn_slowpath_fmt+0x48/0x50\n[192066.389884]  [<ffffffffa039dc2c>] __btrfs_unlink_inode+0x17a/0x354 [btrfs]\n[192066.390621]  [<ffffffff81184b55>] ? iput+0xb0/0x266\n[192066.391200]  [<ffffffffa039ea25>] btrfs_unlink_inode+0x1c/0x3d [btrfs]\n[192066.391930]  [<ffffffffa03ca623>] check_item_in_log+0x1fe/0x29b [btrfs]\n[192066.392715]  [<ffffffffa03ca827>] replay_dir_deletes+0x167/0x1cf [btrfs]\n[192066.393510]  [<ffffffffa03cccc7>] replay_one_buffer+0x417/0x570 [btrfs]\n[192066.394241]  [<ffffffffa03ca164>] walk_up_log_tree+0x10e/0x1dc [btrfs]\n[192066.394958]  [<ffffffffa03cac72>] walk_log_tree+0xa5/0x190 [btrfs]\n[192066.395628]  [<ffffffffa03ce8b8>] btrfs_recover_log_trees+0x239/0x32c [btrfs]\n[192066.396790]  [<ffffffffa03cc8b0>] ? replay_one_extent+0x50a/0x50a [btrfs]\n[192066.397891]  [<ffffffffa0394041>] open_ctree+0x1d8b/0x2167 [btrfs]\n[192066.398897]  [<ffffffffa03706e1>] btrfs_mount+0x5ef/0x729 [btrfs]\n[192066.399823]  [<ffffffff8108ad98>] ? trace_hardirqs_on+0xd/0xf\n[192066.400739]  [<ffffffff8108959b>] ? lockdep_init_map+0xb9/0x1b3\n[192066.401700]  [<ffffffff811714b9>] mount_fs+0x67/0x131\n[192066.402482]  [<ffffffff81188560>] vfs_kern_mount+0x6c/0xde\n[192066.403930]  [<ffffffffa03702bd>] btrfs_mount+0x1cb/0x729 [btrfs]\n[192066.404831]  [<ffffffff8108ad98>] ? trace_hardirqs_on+0xd/0xf\n[192066.405726]  [<ffffffff8108959b>] ? lockdep_init_map+0xb9/0x1b3\n[192066.406621]  [<ffffffff811714b9>] mount_fs+0x67/0x131\n[192066.407401]  [<ffffffff81188560>] vfs_kern_mount+0x6c/0xde\n[192066.408247]  [<ffffffff8118ae36>] do_mount+0x893/0x9d2\n[192066.409047]  [<ffffffff8113009b>] ? strndup_user+0x3f/0x8c\n[192066.409842]  [<ffffffff8118b187>] SyS_mount+0x75/0xa1\n[192066.410621]  [<ffffffff8147e517>] entry_SYSCALL_64_fastpath+0x12/0x6b\n[192066.411572] ---[ end trace 2de42126c1e0a0f0 ]---\n[192066.412344] BTRFS: error (device dm-0) in __btrfs_unlink_inode:3986: errno=-2 No such entry\n[192066.413748] BTRFS: error (device dm-0) in btrfs_replay_log:2464: errno=-2 No such entry (Failed to recover log tree)\n[192066.415458] BTRFS error (device dm-0): cleaner transaction attach returned -30\n[192066.444613] BTRFS: open_ctree failed\n\nThis happens because when we are replaying the log and processing the\ndirectory entry pointing to the snapshot in the subvolume tree, we treat\nits btrfs_dir_item item as having a location with a key type matching\nBTRFS_INODE_ITEM_KEY, which is wrong because the type matches\nBTRFS_ROOT_ITEM_KEY and therefore must be processed differently, as the\nobject id refers to a root number and not to an inode in the root\ncontaining the parent directory.\n\nSo fix this by triggering a transaction commit if an fsync against the\nparent directory is requested after deleting a snapshot. This is the\nsimplest approach for a rare use case. Some alternative that avoids the\ntransaction commit would require more code to explicitly delete the\nsnapshot at log replay time (factoring out common code from ioctl.c:\nbtrfs_ioctl_snap_destroy()), special care at fsync time to remove the\nlog tree of the snapshot's root from the log root of the root of tree\nroots, amongst other steps.\n\nA test case for xfstests that triggers the issue follows.\n\n  seq=`basename $0`\n  seqres=$RESULT_DIR/$seq\n  echo \"QA output created by $seq\"\n  tmp=/tmp/$$\n  status=1\t# failure is the default!\n  trap \"_cleanup; exit \\$status\" 0 1 2 3 15\n\n  _cleanup()\n  {\n      _cleanup_flakey\n      cd /\n      rm -f $tmp.*\n  }\n\n  # get standard environment, filters and checks\n  . ./common/rc\n  . ./common/filter\n  . ./common/dmflakey\n\n  # real QA test starts here\n  _need_to_be_root\n  _supported_fs btrfs\n  _supported_os Linux\n  _require_scratch\n  _require_dm_target flakey\n  _require_metadata_journaling $SCRATCH_DEV\n\n  rm -f $seqres.full\n\n  _scratch_mkfs >>$seqres.full 2>&1\n  _init_flakey\n  _mount_flakey\n\n  # Create a snapshot at the root of our filesystem (mount point path), delete it,\n  # fsync the mount point path, crash and mount to replay the log. This should\n  # succeed and after the filesystem is mounted the snapshot should not be visible\n  # anymore.\n  _run_btrfs_util_prog subvolume snapshot $SCRATCH_MNT $SCRATCH_MNT/snap1\n  _run_btrfs_util_prog subvolume delete $SCRATCH_MNT/snap1\n  $XFS_IO_PROG -c \"fsync\" $SCRATCH_MNT\n  _flakey_drop_and_remount\n  [ -e $SCRATCH_MNT/snap1 ] && \\\n      echo \"Snapshot snap1 still exists after log replay\"\n\n  # Similar scenario as above, but this time the snapshot is created inside a\n  # directory and not directly under the root (mount point path).\n  mkdir $SCRATCH_MNT/testdir\n  _run_btrfs_util_prog subvolume snapshot $SCRATCH_MNT $SCRATCH_MNT/testdir/snap2\n  _run_btrfs_util_prog subvolume delete $SCRATCH_MNT/testdir/snap2\n  $XFS_IO_PROG -c \"fsync\" $SCRATCH_MNT/testdir\n  _flakey_drop_and_remount\n  [ -e $SCRATCH_MNT/testdir/snap2 ] && \\\n      echo \"Snapshot snap2 still exists after log replay\"\n\n  _unmount_flakey\n\n  echo \"Silence is golden\"\n  status=0\n  exit\n\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nTested-by: Liu Bo <bo.li.liu@oracle.com>\nReviewed-by: Liu Bo <bo.li.liu@oracle.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
        "before_after_code_files": [
          "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c",
          "fs/btrfs/tree-log.c||fs/btrfs/tree-log.c",
          "fs/btrfs/tree-log.h||fs/btrfs/tree-log.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c": [
          "File: fs/btrfs/ioctl.c -> fs/btrfs/ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: #include \"props.h\"",
          "60: #include \"sysfs.h\"",
          "61: #include \"qgroup.h\"",
          "63: #ifdef CONFIG_64BIT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #include \"tree-log.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2521: out_end_trans:",
          "2522:  trans->block_rsv = NULL;",
          "2523:  trans->bytes_reserved = 0;",
          "2524:  ret = btrfs_end_transaction(trans, root);",
          "2525:  if (ret && !err)",
          "2526:   err = ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2525:  if (!err)",
          "2526:   btrfs_record_snapshot_destroy(trans, dir);",
          "",
          "---------------"
        ],
        "fs/btrfs/tree-log.c||fs/btrfs/tree-log.c": [
          "File: fs/btrfs/tree-log.c -> fs/btrfs/tree-log.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5497:  BTRFS_I(dir)->last_unlink_trans = trans->transid;",
          "5498: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5498: }",
          "5509: void btrfs_record_snapshot_destroy(struct btrfs_trans_handle *trans,",
          "5510:        struct inode *dir)",
          "5511: {",
          "5512:  BTRFS_I(dir)->last_unlink_trans = trans->transid;",
          "",
          "---------------"
        ],
        "fs/btrfs/tree-log.h||fs/btrfs/tree-log.h": [
          "File: fs/btrfs/tree-log.h -> fs/btrfs/tree-log.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: void btrfs_record_unlink_dir(struct btrfs_trans_handle *trans,",
          "80:         struct inode *dir, struct inode *inode,",
          "81:         int for_rename);",
          "82: int btrfs_log_new_name(struct btrfs_trans_handle *trans,",
          "83:    struct inode *inode, struct inode *old_dir,",
          "84:    struct dentry *parent);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82: void btrfs_record_snapshot_destroy(struct btrfs_trans_handle *trans,",
          "83:        struct inode *dir);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "deb7deff2f00bdbbcb3d560dad2a89ef37df837d",
      "candidate_info": {
        "commit_hash": "deb7deff2f00bdbbcb3d560dad2a89ef37df837d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/deb7deff2f00bdbbcb3d560dad2a89ef37df837d",
        "files": [
          "fs/cifs/smb2pdu.c"
        ],
        "message": "cifs: fix out-of-bounds access in lease parsing\n\nWhen opening a file, SMB2_open() attempts to parse the lease state from the\nSMB2 CREATE Response.  However, the parsing code was not careful to ensure\nthat the create contexts are not empty or invalid, which can lead to out-\nof-bounds memory access.  This can be seen easily by trying\nto read a file from a OSX 10.11 SMB3 server.  Here is sample crash output:\n\nBUG: unable to handle kernel paging request at ffff8800a1a77cc6\nIP: [<ffffffff8828a734>] SMB2_open+0x804/0x960\nPGD 8f77067 PUD 0\nOops: 0000 [#1] SMP\nModules linked in:\nCPU: 3 PID: 2876 Comm: cp Not tainted 4.5.0-rc3.x86_64.1+ #14\nHardware name: NETGEAR ReadyNAS 314          /ReadyNAS 314          , BIOS 4.6.5 10/11/2012\ntask: ffff880073cdc080 ti: ffff88005b31c000 task.ti: ffff88005b31c000\nRIP: 0010:[<ffffffff8828a734>]  [<ffffffff8828a734>] SMB2_open+0x804/0x960\nRSP: 0018:ffff88005b31fa08  EFLAGS: 00010282\nRAX: 0000000000000015 RBX: 0000000000000000 RCX: 0000000000000006\nRDX: 0000000000000000 RSI: 0000000000000246 RDI: ffff88007eb8c8b0\nRBP: ffff88005b31fad8 R08: 666666203d206363 R09: 6131613030383866\nR10: 3030383866666666 R11: 00000000000002b0 R12: ffff8800660fd800\nR13: ffff8800a1a77cc2 R14: 00000000424d53fe R15: ffff88005f5a28c0\nFS:  00007f7c8a2897c0(0000) GS:ffff88007eb80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: ffff8800a1a77cc6 CR3: 000000005b281000 CR4: 00000000000006e0\nStack:\n ffff88005b31fa70 ffffffff88278789 00000000000001d3 ffff88005f5a2a80\n ffffffff00000003 ffff88005d029d00 ffff88006fde05a0 0000000000000000\n ffff88005b31fc78 ffff88006fde0780 ffff88005b31fb2f 0000000100000fe0\nCall Trace:\n [<ffffffff88278789>] ? cifsConvertToUTF16+0x159/0x2d0\n [<ffffffff8828cf68>] smb2_open_file+0x98/0x210\n [<ffffffff8811e80c>] ? __kmalloc+0x1c/0xe0\n [<ffffffff882685f4>] cifs_open+0x2a4/0x720\n [<ffffffff88122cef>] do_dentry_open+0x1ff/0x310\n [<ffffffff88268350>] ? cifsFileInfo_get+0x30/0x30\n [<ffffffff88123d92>] vfs_open+0x52/0x60\n [<ffffffff88131dd0>] path_openat+0x170/0xf70\n [<ffffffff88097d48>] ? remove_wait_queue+0x48/0x50\n [<ffffffff88133a29>] do_filp_open+0x79/0xd0\n [<ffffffff8813f2ca>] ? __alloc_fd+0x3a/0x170\n [<ffffffff881240c4>] do_sys_open+0x114/0x1e0\n [<ffffffff881241a9>] SyS_open+0x19/0x20\n [<ffffffff8896e257>] entry_SYSCALL_64_fastpath+0x12/0x6a\nCode: 4d 8d 6c 07 04 31 c0 4c 89 ee e8 47 6f e5 ff 31 c9 41 89 ce 44 89 f1 48 c7 c7 28 b1 bd 88 31 c0 49 01 cd 4c 89 ee e8 2b 6f e5 ff <45> 0f b7 75 04 48 c7 c7 31 b1 bd 88 31 c0 4d 01 ee 4c 89 f6 e8\nRIP  [<ffffffff8828a734>] SMB2_open+0x804/0x960\n RSP <ffff88005b31fa08>\nCR2: ffff8800a1a77cc6\n---[ end trace d9f69ba64feee469 ]---\n\nSigned-off-by: Justin Maggard <jmaggard@netgear.com>\nSigned-off-by: Steve French <smfrench@gmail.com>\nCC: Stable <stable@vger.kernel.org>",
        "before_after_code_files": [
          "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c": [
          "File: fs/cifs/smb2pdu.c -> fs/cifs/smb2pdu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1106: {",
          "1107:  char *data_offset;",
          "1108:  struct create_context *cc;",
          "1110:  char *name;",
          "1112:  data_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);",
          "1113:  cc = (struct create_context *)data_offset;",
          "1116:   name = le16_to_cpu(cc->NameOffset) + (char *)cc;",
          "1125:  return 0;",
          "1126: }",
          "",
          "[Removed Lines]",
          "1109:  unsigned int next = 0;",
          "1114:  do {",
          "1115:   cc = (struct create_context *)((char *)cc + next);",
          "1117:   if (le16_to_cpu(cc->NameLength) != 4 ||",
          "1118:       strncmp(name, \"RqLs\", 4)) {",
          "1119:    next = le32_to_cpu(cc->Next);",
          "1120:    continue;",
          "1121:   }",
          "1122:   return server->ops->parse_lease_buf(cc, epoch);",
          "1123:  } while (next != 0);",
          "",
          "[Added Lines]",
          "1109:  unsigned int next;",
          "1110:  unsigned int remaining;",
          "1114:  remaining = le32_to_cpu(rsp->CreateContextsLength);",
          "1116:  while (remaining >= sizeof(struct create_context)) {",
          "1118:   if (le16_to_cpu(cc->NameLength) == 4 &&",
          "1119:       strncmp(name, \"RqLs\", 4) == 0)",
          "1120:    return server->ops->parse_lease_buf(cc, epoch);",
          "1122:   next = le32_to_cpu(cc->Next);",
          "1123:   if (!next)",
          "1124:    break;",
          "1125:   remaining -= next;",
          "1126:   cc = (struct create_context *)((char *)cc + next);",
          "1127:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
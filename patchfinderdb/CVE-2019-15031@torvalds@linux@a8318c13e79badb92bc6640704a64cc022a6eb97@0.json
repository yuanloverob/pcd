{
  "cve_id": "CVE-2019-15031",
  "cve_desc": "In the Linux kernel through 5.2.14 on the powerpc platform, a local user can read vector registers of other users' processes via an interrupt. To exploit the venerability, a local user starts a transaction (via the hardware transactional memory instruction tbegin) and then accesses vector registers. At some point, the vector registers will be corrupted with the values from a different local Linux process, because MSR_TM_ACTIVE is misused in arch/powerpc/kernel/process.c.",
  "repo": "torvalds/linux",
  "patch_hash": "a8318c13e79badb92bc6640704a64cc022a6eb97",
  "patch_info": {
    "commit_hash": "a8318c13e79badb92bc6640704a64cc022a6eb97",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a8318c13e79badb92bc6640704a64cc022a6eb97",
    "files": [
      "arch/powerpc/kernel/process.c"
    ],
    "message": "powerpc/tm: Fix restoring FP/VMX facility incorrectly on interrupts\n\nWhen in userspace and MSR FP=0 the hardware FP state is unrelated to\nthe current process. This is extended for transactions where if tbegin\nis run with FP=0, the hardware checkpoint FP state will also be\nunrelated to the current process. Due to this, we need to ensure this\nhardware checkpoint is updated with the correct state before we enable\nFP for this process.\n\nUnfortunately we get this wrong when returning to a process from a\nhardware interrupt. A process that starts a transaction with FP=0 can\ntake an interrupt. When the kernel returns back to that process, we\nchange to FP=1 but with hardware checkpoint FP state not updated. If\nthis transaction is then rolled back, the FP registers now contain the\nwrong state.\n\nThe process looks like this:\n   Userspace:                      Kernel\n\n               Start userspace\n                with MSR FP=0 TM=1\n                  < -----\n   ...\n   tbegin\n   bne\n               Hardware interrupt\n                   ---- >\n                                    <do_IRQ...>\n                                    ....\n                                    ret_from_except\n                                      restore_math()\n\t\t\t\t        /* sees FP=0 */\n                                        restore_fp()\n                                          tm_active_with_fp()\n\t\t\t\t\t    /* sees FP=1 (Incorrect) */\n                                          load_fp_state()\n                                        FP = 0 -> 1\n                  < -----\n               Return to userspace\n                 with MSR TM=1 FP=1\n                 with junk in the FP TM checkpoint\n   TM rollback\n   reads FP junk\n\nWhen returning from the hardware exception, tm_active_with_fp() is\nincorrectly making restore_fp() call load_fp_state() which is setting\nFP=1.\n\nThe fix is to remove tm_active_with_fp().\n\ntm_active_with_fp() is attempting to handle the case where FP state\nhas been changed inside a transaction. In this case the checkpointed\nand transactional FP state is different and hence we must restore the\nFP state (ie. we can't do lazy FP restore inside a transaction that's\nused FP). It's safe to remove tm_active_with_fp() as this case is\nhandled by restore_tm_state(). restore_tm_state() detects if FP has\nbeen using inside a transaction and will set load_fp and call\nrestore_math() to ensure the FP state (checkpoint and transaction) is\nrestored.\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nSimilarly for VMX.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nThis fixes CVE-2019-15031.\n\nFixes: a7771176b439 (\"powerpc: Don't enable FP/Altivec if not checkpointed\")\nCc: stable@vger.kernel.org # 4.15+\nSigned-off-by: Gustavo Romero <gromero@linux.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-2-gromero@linux.vnet.ibm.com",
    "before_after_code_files": [
      "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c"
    ]
  },
  "patch_diff": {
    "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c": [
      "File: arch/powerpc/kernel/process.c -> arch/powerpc/kernel/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "101:  }",
      "102: }",
      "115: #else",
      "116: static inline void check_if_tm_restore_required(struct task_struct *tsk) { }",
      "121: bool strict_msr_control;",
      "",
      "[Removed Lines]",
      "104: static bool tm_active_with_fp(struct task_struct *tsk)",
      "105: {",
      "106:  return MSR_TM_ACTIVE(tsk->thread.regs->msr) &&",
      "107:   (tsk->thread.ckpt_regs.msr & MSR_FP);",
      "108: }",
      "110: static bool tm_active_with_altivec(struct task_struct *tsk)",
      "111: {",
      "112:  return MSR_TM_ACTIVE(tsk->thread.regs->msr) &&",
      "113:   (tsk->thread.ckpt_regs.msr & MSR_VEC);",
      "114: }",
      "117: static inline bool tm_active_with_fp(struct task_struct *tsk) { return false; }",
      "118: static inline bool tm_active_with_altivec(struct task_struct *tsk) { return false; }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "253: static int restore_fp(struct task_struct *tsk)",
      "254: {",
      "256:   load_fp_state(&current->thread.fp_state);",
      "257:   current->thread.load_fp++;",
      "258:   return 1;",
      "",
      "[Removed Lines]",
      "255:  if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {",
      "",
      "[Added Lines]",
      "242:  if (tsk->thread.load_fp) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "335: static int restore_altivec(struct task_struct *tsk)",
      "336: {",
      "339:   load_vr_state(&tsk->thread.vr_state);",
      "340:   tsk->thread.used_vr = 1;",
      "341:   tsk->thread.load_vec++;",
      "",
      "[Removed Lines]",
      "337:  if (cpu_has_feature(CPU_FTR_ALTIVEC) &&",
      "338:   (tsk->thread.load_vec || tm_active_with_altivec(tsk))) {",
      "",
      "[Added Lines]",
      "324:  if (cpu_has_feature(CPU_FTR_ALTIVEC) && (tsk->thread.load_vec)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5c784c8414fba11b62e12439f11e109fb5751f38",
      "candidate_info": {
        "commit_hash": "5c784c8414fba11b62e12439f11e109fb5751f38",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5c784c8414fba11b62e12439f11e109fb5751f38",
        "files": [
          "arch/powerpc/include/asm/reg.h",
          "arch/powerpc/kernel/process.c"
        ],
        "message": "powerpc/tm: Remove msr_tm_active()\n\nCurrently msr_tm_active() is a wrapper around MSR_TM_ACTIVE() if\nCONFIG_PPC_TRANSACTIONAL_MEM is set, or it is just a function that\nreturns false if CONFIG_PPC_TRANSACTIONAL_MEM is not set.\n\nThis function is not necessary, since MSR_TM_ACTIVE() just do the same and\ncould be used, removing the dualism and simplifying the code.\n\nThis patchset remove every instance of msr_tm_active() and replaced it\nby MSR_TM_ACTIVE().\n\nSigned-off-by: Breno Leitao <leitao@debian.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/include/asm/reg.h||arch/powerpc/include/asm/reg.h",
          "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c"
          ],
          "candidate": [
            "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/powerpc/include/asm/reg.h||arch/powerpc/include/asm/reg.h": [
          "File: arch/powerpc/include/asm/reg.h -> arch/powerpc/include/asm/reg.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "123: #define MSR_TM_TRANSACTIONAL(x) (((x) & MSR_TS_MASK) == MSR_TS_T)",
          "124: #define MSR_TM_SUSPENDED(x) (((x) & MSR_TS_MASK) == MSR_TS_S)",
          "126: #if defined(CONFIG_PPC_BOOK3S_64)",
          "127: #define MSR_64BIT MSR_SF",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125: #ifdef CONFIG_PPC_TRANSACTIONAL_MEM",
          "127: #else",
          "128: #define MSR_TM_ACTIVE(x) 0",
          "129: #endif",
          "",
          "---------------"
        ],
        "arch/powerpc/kernel/process.c||arch/powerpc/kernel/process.c": [
          "File: arch/powerpc/kernel/process.c -> arch/powerpc/kernel/process.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "102:  }",
          "103: }",
          "110: static bool tm_active_with_fp(struct task_struct *tsk)",
          "111: {",
          "113:   (tsk->thread.ckpt_regs.msr & MSR_FP);",
          "114: }",
          "116: static bool tm_active_with_altivec(struct task_struct *tsk)",
          "117: {",
          "119:   (tsk->thread.ckpt_regs.msr & MSR_VEC);",
          "120: }",
          "121: #else",
          "123: static inline void check_if_tm_restore_required(struct task_struct *tsk) { }",
          "124: static inline bool tm_active_with_fp(struct task_struct *tsk) { return false; }",
          "125: static inline bool tm_active_with_altivec(struct task_struct *tsk) { return false; }",
          "",
          "[Removed Lines]",
          "105: static inline bool msr_tm_active(unsigned long msr)",
          "106: {",
          "107:  return MSR_TM_ACTIVE(msr);",
          "108: }",
          "112:  return msr_tm_active(tsk->thread.regs->msr) &&",
          "118:  return msr_tm_active(tsk->thread.regs->msr) &&",
          "122: static inline bool msr_tm_active(unsigned long msr) { return false; }",
          "",
          "[Added Lines]",
          "107:  return MSR_TM_ACTIVE(tsk->thread.regs->msr) &&",
          "113:  return MSR_TM_ACTIVE(tsk->thread.regs->msr) &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "251:    return;",
          "252:   __giveup_fpu(current);",
          "253:  }",
          "",
          "[Removed Lines]",
          "250:   if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))",
          "",
          "[Added Lines]",
          "244:   if (!MSR_TM_ACTIVE(cpumsr) &&",
          "245:        MSR_TM_ACTIVE(current->thread.regs->msr))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "315:    return;",
          "316:   __giveup_altivec(current);",
          "317:  }",
          "",
          "[Removed Lines]",
          "314:   if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))",
          "",
          "[Added Lines]",
          "309:   if (!MSR_TM_ACTIVE(cpumsr) &&",
          "310:        MSR_TM_ACTIVE(current->thread.regs->msr))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "401:    return;",
          "402:   __giveup_vsx(current);",
          "403:  }",
          "",
          "[Removed Lines]",
          "400:   if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))",
          "",
          "[Added Lines]",
          "396:   if (!MSR_TM_ACTIVE(cpumsr) &&",
          "397:        MSR_TM_ACTIVE(current->thread.regs->msr))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "530: {",
          "531:  unsigned long msr;",
          "534:   !current->thread.load_fp && !loadvec(current->thread))",
          "535:   return;",
          "",
          "[Removed Lines]",
          "533:  if (!msr_tm_active(regs->msr) &&",
          "",
          "[Added Lines]",
          "530:  if (!MSR_TM_ACTIVE(regs->msr) &&",
          "",
          "---------------"
        ]
      }
    }
  ]
}
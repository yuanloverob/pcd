{
  "cve_id": "CVE-2020-15194",
  "cve_desc": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "390611e0d45c5793c7066110af37c8514e6a6c54",
  "patch_info": {
    "commit_hash": "390611e0d45c5793c7066110af37c8514e6a6c54",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/390611e0d45c5793c7066110af37c8514e6a6c54",
    "files": [
      "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
      "tensorflow/python/ops/sparse_ops_test.py"
    ],
    "message": "Fix heap buffer overflow in `tf.raw_ops.SparseFillEmptyRowsGrad`.\n\nAlso add tests as they were lacking\n\nPiperOrigin-RevId: 332566071\nChange-Id: I44277578e26ff5fb3fdb0dcbba6e91b2ec3e7859",
    "before_after_code_files": [
      "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
      "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
      "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "236:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
      "237:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
      "238:                                 reverse_index_map_t->shape().DebugString()));",
      "240:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
      "241:     const auto grad_values = grad_values_t->vec<T>();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "239:     OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),",
      "240:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
      "241:                                         grad_values_t->shape().DebugString()));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "269:     }",
      "270:     for (int j = 0; j < N_full; ++j) {",
      "",
      "[Removed Lines]",
      "267:       d_values(i) = grad_values(reverse_index_map(i));",
      "268:       visited(reverse_index_map(i)) = true;",
      "",
      "[Added Lines]",
      "270:       int64 reverse_index = reverse_index_map(i);",
      "271:       OP_REQUIRES(",
      "272:           context, 0 <= reverse_index && reverse_index < N_full,",
      "273:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
      "274:                                   N_full, \") but got \", reverse_index));",
      "275:       d_values(i) = grad_values(reverse_index);",
      "276:       visited(reverse_index) = true;",
      "",
      "---------------"
    ],
    "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py": [
      "File: tensorflow/python/ops/sparse_ops_test.py -> tensorflow/python/ops/sparse_ops_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "21: from absl.testing import parameterized",
      "22: import numpy as np",
      "24: from tensorflow.python.framework import constant_op",
      "25: from tensorflow.python.framework import dtypes",
      "26: from tensorflow.python.framework import errors",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "24: from tensorflow.python.eager import context",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30: # Need array_grad to register gradient for Identity.",
      "31: from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
      "32: from tensorflow.python.ops import array_ops",
      "33: from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
      "34: from tensorflow.python.ops import math_ops",
      "35: # Need sparse_grad to register gradient for SparseToDense.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: from tensorflow.python.ops import gen_sparse_ops",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "234:     self.assertAllEqual([5], result.dense_shape)",
      "237: if __name__ == '__main__':",
      "238:   googletest.main()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "239: @test_util.run_all_in_graph_and_eager_modes",
      "240: class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
      "242:   def testSparseFillEmptyRowsGrad(self):",
      "243:     reverse_index_map = [2, 1]",
      "244:     grad_values = [0, 1, 2, 3]",
      "245:     d_values, d_default_value = self.evaluate(",
      "246:         gen_sparse_ops.SparseFillEmptyRowsGrad(",
      "247:             reverse_index_map=reverse_index_map, grad_values=grad_values))",
      "248:     self.assertAllEqual([2, 1], d_values)",
      "249:     self.assertEqual(3, d_default_value)",
      "251:   def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):",
      "252:     reverse_index_map = [2, -1]",
      "253:     grad_values = [0, 1, 2, 3]",
      "254:     with self.assertRaisesRegex(",
      "255:         errors.InvalidArgumentError,",
      "256:         r'Elements in reverse index must be in \\[0, 4\\)'):",
      "257:       self.evaluate(",
      "258:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
      "259:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
      "261:   def testSparseFillEmptyRowsGradLargeIndexMapValue(self):",
      "262:     reverse_index_map = [2, 10]",
      "263:     grad_values = [0, 1, 2, 3]",
      "264:     with self.assertRaisesRegex(",
      "265:         errors.InvalidArgumentError,",
      "266:         r'Elements in reverse index must be in \\[0, 4\\)'):",
      "267:       self.evaluate(",
      "268:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
      "269:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
      "271:   def testSparseFillEmptyRowsGradMatrix(self):",
      "272:     reverse_index_map = [0, 1]",
      "273:     grad_values = [[0, 1], [2, 3]]",
      "274:     # Note: Eager mode and graph mode throw different errors here. Graph mode",
      "275:     # will fail with a ValueError from the shape checking logic, while Eager",
      "276:     # will fail with an InvalidArgumentError from the kernel itself.",
      "277:     if context.executing_eagerly():",
      "278:       with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "279:                                   r'grad_values must be a vector'):",
      "280:         self.evaluate(",
      "281:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
      "282:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
      "283:     else:",
      "284:       with self.assertRaisesRegex(ValueError,",
      "285:                                   r'Shape must be rank 1 but is rank 2'):",
      "286:         self.evaluate(",
      "287:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
      "288:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5bd220564ebf66b438f09b119ae9a0bfbf59aa22",
      "candidate_info": {
        "commit_hash": "5bd220564ebf66b438f09b119ae9a0bfbf59aa22",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/5bd220564ebf66b438f09b119ae9a0bfbf59aa22",
        "files": [
          "tensorflow/core/kernels/BUILD",
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.h"
        ],
        "message": "Rollback of: PR #44719: Refactor SparseFillEmptyRows[Grad] CPU kernels into classes\n\nPiperOrigin-RevId: 345543822\nChange-Id: I1566d828a4be164e81bd074b5f2c35d43f53232e",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.h||tensorflow/core/kernels/sparse_fill_empty_rows_op.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #define EIGEN_USE_THREADS",
          "20: #include <algorithm>",
          "21: #include <numeric>",
          "22: #include <unordered_map>",
          "",
          "[Removed Lines]",
          "18: #include \"tensorflow/core/kernels/sparse_fill_empty_rows_op.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36: using CPUDevice = Eigen::ThreadPoolDevice;",
          "45:     const int kOutputIndicesOutput = 0;",
          "46:     const int kOutputValuesOutput = 1;",
          "47:     const int kEmptyRowIndicatorOutput = 2;",
          "48:     const int kReverseIndexMapOutput = 3;",
          "50:     const T& default_value = default_value_t.scalar<T>()();",
          "52:     const auto values = values_t.vec<T>();",
          "58:     bool* empty_row_indicator = nullptr;",
          "59:     if (context->output_required(kEmptyRowIndicatorOutput)) {",
          "60:       Tensor* empty_row_indicator_t = nullptr;",
          "64:       empty_row_indicator = empty_row_indicator_t->vec<bool>().data();",
          "65:     }",
          "67:     if (context->output_required(kReverseIndexMapOutput)) {",
          "68:       Tensor* reverse_index_map_t = nullptr;",
          "72:     }",
          "74:     int rank = indices_t.shape().dim_size(1);",
          "76:     if (dense_rows == 0) {",
          "83:       Tensor* output_indices_t;",
          "84:       TensorShape output_indices_shape({0, rank});",
          "87:       Tensor* output_values_t;",
          "93:     }",
          "95:     bool rows_are_ordered = true;",
          "98:     for (int i = 0; i < N; ++i) {",
          "104:       ++csr_offset[row];",
          "105:       rows_are_ordered = rows_are_ordered & (row >= last_indices_row);",
          "106:       last_indices_row = row;",
          "",
          "[Removed Lines]",
          "38: namespace functor {",
          "40: template <typename T, typename Tindex>",
          "41: struct SparseFillEmptyRows<CPUDevice, T, Tindex> {",
          "42:   Status operator()(OpKernelContext* context, const Tensor& default_value_t,",
          "43:                     const Tensor& indices_t, const Tensor& values_t,",
          "44:                     const Tensor& dense_shape_t) {",
          "51:     const auto indices = indices_t.matrix<Tindex>();",
          "53:     const auto dense_shape = dense_shape_t.vec<Tindex>();",
          "55:     const Tindex N = indices_t.shape().dim_size(0);",
          "56:     const Tindex dense_rows = dense_shape(0);",
          "61:       TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,",
          "62:                                                   TensorShape({dense_rows}),",
          "63:                                                   &empty_row_indicator_t));",
          "66:     Tindex* reverse_index_map = nullptr;",
          "69:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "70:           kReverseIndexMapOutput, TensorShape({N}), &reverse_index_map_t));",
          "71:       reverse_index_map = reverse_index_map_t->vec<Tindex>().data();",
          "77:       if (N != 0) {",
          "78:         return errors::InvalidArgument(",
          "79:             \"Received SparseTensor with dense_shape[0] = 0 but \"",
          "80:             \"indices.shape[0] = \",",
          "81:             N);",
          "82:       }",
          "85:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "86:           kOutputIndicesOutput, output_indices_shape, &output_indices_t));",
          "88:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "89:           kOutputValuesOutput, TensorShape({0}), &output_values_t));",
          "92:       return Status::OK();",
          "96:     Tindex last_indices_row = 0;",
          "97:     std::vector<Tindex> csr_offset(dense_rows, 0);",
          "99:       const Tindex row = indices(i, 0);",
          "100:       if (row < 0 || row >= dense_rows) {",
          "101:         return errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \", row,",
          "102:                                        \" >= \", dense_rows);",
          "103:       }",
          "",
          "[Added Lines]",
          "36: template <typename T>",
          "37: class SparseFillEmptyRowsOp : public OpKernel {",
          "38:  public:",
          "39:   explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)",
          "40:       : OpKernel(context) {}",
          "42:   void Compute(OpKernelContext* context) override {",
          "43:     const int kIndicesInput = 0;",
          "44:     const int kValuesInput = 1;",
          "45:     const int kDenseShapeInput = 2;",
          "46:     const int kDefaultValueInput = 3;",
          "53:     const Tensor& indices_t = context->input(kIndicesInput);",
          "54:     const Tensor& values_t = context->input(kValuesInput);",
          "55:     const Tensor& dense_shape_t = context->input(kDenseShapeInput);",
          "56:     const Tensor& default_value_t = context->input(kDefaultValueInput);",
          "58:     OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),",
          "59:                 errors::InvalidArgument(\"dense_shape must be a vector, saw: \",",
          "60:                                         dense_shape_t.shape().DebugString()));",
          "61:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),",
          "62:                 errors::InvalidArgument(\"indices must be a matrix, saw: \",",
          "63:                                         indices_t.shape().DebugString()));",
          "64:     OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),",
          "65:                 errors::InvalidArgument(\"values must be a vector, saw: \",",
          "66:                                         values_t.shape().DebugString()));",
          "67:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),",
          "68:                 errors::InvalidArgument(\"default_value must be a scalar, saw: \",",
          "69:                                         default_value_t.shape().DebugString()));",
          "74:     const auto indices = indices_t.matrix<int64>();",
          "76:     const auto dense_shape = dense_shape_t.vec<int64>();",
          "78:     const int64 N = indices_t.shape().dim_size(0);",
          "79:     const int64 dense_rows = dense_shape(0);",
          "84:       OP_REQUIRES_OK(context,",
          "85:                      context->allocate_output(kEmptyRowIndicatorOutput,",
          "86:                                               TensorShape({dense_rows}),",
          "87:                                               &empty_row_indicator_t));",
          "90:     int64* reverse_index_map = nullptr;",
          "93:       OP_REQUIRES_OK(context, context->allocate_output(kReverseIndexMapOutput,",
          "94:                                                        TensorShape({N}),",
          "95:                                                        &reverse_index_map_t));",
          "96:       reverse_index_map = reverse_index_map_t->vec<int64>().data();",
          "102:       OP_REQUIRES(",
          "103:           context, N == 0,",
          "104:           errors::InvalidArgument(\"Received SparseTensor with dense_shape[0] = \"",
          "105:                                   \"0 but indices.shape[0] = \",",
          "106:                                   N));",
          "109:       OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,",
          "110:                                                        output_indices_shape,",
          "111:                                                        &output_indices_t));",
          "113:       OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,",
          "114:                                                        TensorShape({0}),",
          "115:                                                        &output_values_t));",
          "118:       return;",
          "122:     int64 last_indices_row = 0;",
          "123:     std::vector<int64> csr_offset(dense_rows, 0);",
          "125:       const int64 row = indices(i, 0);",
          "126:       OP_REQUIRES(context, row >= 0 && row < dense_rows,",
          "127:                   errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \",",
          "128:                                           row, \" >= \", dense_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "114:       }",
          "115:       all_rows_full = all_rows_full & !row_empty;",
          "",
          "[Removed Lines]",
          "117:       csr_offset[row] = std::max(csr_offset[row], Tindex{1});",
          "",
          "[Added Lines]",
          "142:       csr_offset[row] = std::max(csr_offset[row], int64{1});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "130:       context->set_output(kOutputIndicesOutput, indices_t);",
          "131:       context->set_output(kOutputValuesOutput, values_t);",
          "132:       if (reverse_index_map) {",
          "134:           reverse_index_map[i] = i;",
          "135:         }",
          "136:       }",
          "137:     } else {",
          "138:       Tensor* output_indices_t;",
          "140:       TensorShape output_indices_shape({N_full, rank});",
          "145:       Tensor* output_values_t;",
          "148:       auto output_values = output_values_t->vec<T>();",
          "157:         offset++;  // Increment the filled count for this row.",
          "158:         std::copy_n(&indices(i, 0), rank, &output_indices(output_i, 0));",
          "159:         output_values(output_i) = values(i);",
          "",
          "[Removed Lines]",
          "133:         for (Tindex i = 0; i < N; ++i) {",
          "139:       const Tindex N_full = csr_offset[dense_rows - 1];",
          "141:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "142:           kOutputIndicesOutput, output_indices_shape, &output_indices_t));",
          "143:       auto output_indices = output_indices_t->matrix<Tindex>();",
          "146:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "147:           kOutputValuesOutput, TensorShape({N_full}), &output_values_t));",
          "150:       std::vector<Tindex> filled_count(dense_rows, 0);",
          "153:       for (Tindex i = 0; i < N; ++i) {",
          "154:         const Tindex row = indices(i, 0);",
          "155:         Tindex& offset = filled_count[row];",
          "156:         const Tindex output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;",
          "",
          "[Added Lines]",
          "158:         for (int64 i = 0; i < N; ++i) {",
          "164:       const int64 N_full = csr_offset[dense_rows - 1];",
          "166:       OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,",
          "167:                                                        output_indices_shape,",
          "168:                                                        &output_indices_t));",
          "169:       auto output_indices = output_indices_t->matrix<int64>();",
          "172:       OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,",
          "173:                                                        TensorShape({N_full}),",
          "174:                                                        &output_values_t));",
          "177:       std::vector<int64> filled_count(dense_rows, 0);",
          "180:       for (int64 i = 0; i < N; ++i) {",
          "181:         const int64 row = indices(i, 0);",
          "182:         int64& offset = filled_count[row];",
          "183:         const int64 output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "164:       }",
          "169:         if (row_count == 0) {  // We haven't filled this row",
          "173:           output_indices(starting_index, 0) = row;",
          "175:             output_indices(starting_index, col) = 0;",
          "176:           }",
          "177:           output_values(starting_index) = default_value;",
          "178:         }",
          "179:       }",
          "180:     }",
          "183:   }",
          "184: };",
          "237: #undef REGISTER_KERNELS",
          "289: class SparseFillEmptyRowsGradOp : public OpKernel {",
          "290:  public:",
          "291:   explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)",
          "",
          "[Removed Lines]",
          "167:       for (Tindex row = 0; row < dense_rows; ++row) {",
          "168:         const Tindex row_count = filled_count[row];",
          "170:           const Tindex starting_index = (row == 0) ? 0 : csr_offset[row - 1];",
          "174:           for (Tindex col = 1; col < rank; ++col) {",
          "182:     return Status::OK();",
          "186: }  // namespace functor",
          "188: template <typename Device, typename T, typename Tindex>",
          "189: class SparseFillEmptyRowsOp : public OpKernel {",
          "190:  public:",
          "191:   explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)",
          "192:       : OpKernel(context) {}",
          "194:   void Compute(OpKernelContext* context) override {",
          "195:     const int kIndicesInput = 0;",
          "196:     const int kValuesInput = 1;",
          "197:     const int kDenseShapeInput = 2;",
          "198:     const int kDefaultValueInput = 3;",
          "200:     const Tensor& indices_t = context->input(kIndicesInput);",
          "201:     const Tensor& values_t = context->input(kValuesInput);",
          "202:     const Tensor& dense_shape_t = context->input(kDenseShapeInput);",
          "203:     const Tensor& default_value_t = context->input(kDefaultValueInput);",
          "205:     OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),",
          "206:                 errors::InvalidArgument(\"dense_shape must be a vector, saw: \",",
          "207:                                         dense_shape_t.shape().DebugString()));",
          "208:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),",
          "209:                 errors::InvalidArgument(\"indices must be a matrix, saw: \",",
          "210:                                         indices_t.shape().DebugString()));",
          "211:     OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),",
          "212:                 errors::InvalidArgument(\"values must be a vector, saw: \",",
          "213:                                         values_t.shape().DebugString()));",
          "214:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),",
          "215:                 errors::InvalidArgument(\"default_value must be a scalar, saw: \",",
          "216:                                         default_value_t.shape().DebugString()));",
          "220:     OP_REQUIRES_OK(context, functor::SparseFillEmptyRows<Device, T, Tindex>()(",
          "221:                                 context, default_value_t, indices_t, values_t,",
          "222:                                 dense_shape_t));",
          "223:   }",
          "224: };",
          "226: #define REGISTER_KERNELS(D, T, Tindex)                   \\",
          "227:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")    \\",
          "228:                               .Device(DEVICE_##D)        \\",
          "229:                               .HostMemory(\"dense_shape\") \\",
          "230:                               .TypeConstraint<T>(\"T\"),   \\",
          "231:                           SparseFillEmptyRowsOp<D##Device, T, Tindex>)",
          "233: #define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)",
          "234: TF_CALL_ALL_TYPES(REGISTER_CPU_KERNELS);",
          "235: #undef REGISTER_CPU_KERNELS",
          "239: namespace functor {",
          "241: template <typename T, typename Tindex>",
          "242: struct SparseFillEmptyRowsGrad<CPUDevice, T, Tindex> {",
          "243:   Status operator()(OpKernelContext* context,",
          "244:                     typename TTypes<Tindex>::ConstVec reverse_index_map,",
          "245:                     typename TTypes<T>::ConstVec grad_values,",
          "246:                     typename TTypes<T>::Vec d_values,",
          "247:                     typename TTypes<T>::Scalar d_default_value) {",
          "248:     const CPUDevice& device = context->eigen_device<CPUDevice>();",
          "249:     const Tindex N = reverse_index_map.dimension(0);",
          "250:     const Tindex N_full = grad_values.dimension(0);",
          "252:     T& d_default_value_scalar = d_default_value();",
          "253:     d_default_value_scalar = T();",
          "255:     Tensor visited_t;",
          "256:     TF_RETURN_IF_ERROR(",
          "257:         context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));",
          "258:     auto visited = visited_t.vec<bool>();",
          "259:     visited.device(device) = visited.constant(false);",
          "261:     for (int i = 0; i < N; ++i) {",
          "265:       int64 reverse_index = reverse_index_map(i);",
          "266:       if (reverse_index < 0 || reverse_index >= N_full) {",
          "267:         return errors::InvalidArgument(",
          "268:             \"Elements in reverse index must be in [0, \", N_full, \") but got \",",
          "269:             reverse_index);",
          "270:       }",
          "271:       d_values(i) = grad_values(reverse_index);",
          "272:       visited(reverse_index) = true;",
          "273:     }",
          "274:     for (int j = 0; j < N_full; ++j) {",
          "278:       if (!visited(j)) {",
          "279:         d_default_value_scalar += grad_values(j);",
          "280:       }",
          "281:     }",
          "282:     return Status::OK();",
          "283:   }",
          "284: };",
          "286: }  // namespace functor",
          "288: template <typename Device, typename T, typename Tindex>",
          "",
          "[Added Lines]",
          "194:       for (int64 row = 0; row < dense_rows; ++row) {",
          "195:         const int64 row_count = filled_count[row];",
          "197:           const int64 starting_index = (row == 0) ? 0 : csr_offset[row - 1];",
          "201:           for (int64 col = 1; col < rank; ++col) {",
          "211: #define REGISTER_KERNELS(type)                            \\",
          "212:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")     \\",
          "213:                               .Device(DEVICE_CPU)         \\",
          "214:                               .TypeConstraint<type>(\"T\"), \\",
          "215:                           SparseFillEmptyRowsOp<type>)",
          "217: TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "220: template <typename T>",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "298:                    context->input(\"reverse_index_map\", &reverse_index_map_t));",
          "299:     OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));",
          "301:     OP_REQUIRES(",
          "302:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
          "303:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:     const CPUDevice& d = context->eigen_device<CPUDevice>();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "306:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
          "307:                                         grad_values_t->shape().DebugString()));",
          "310:     const auto grad_values = grad_values_t->vec<T>();",
          "314:     Tensor* d_values_t;",
          "315:     OP_REQUIRES_OK(context, context->allocate_output(",
          "",
          "[Removed Lines]",
          "309:     const auto reverse_index_map = reverse_index_map_t->vec<Tindex>();",
          "312:     const Tindex N = reverse_index_map_t->shape().dim_size(0);",
          "",
          "[Added Lines]",
          "243:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
          "246:     const int64 N = reverse_index_map_t->shape().dim_size(0);",
          "247:     const int64 N_full = grad_values_t->shape().dim_size(0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "319:     OP_REQUIRES_OK(context,",
          "320:                    context->allocate_output(\"d_default_value\", TensorShape({}),",
          "321:                                             &d_default_value_t));",
          "328:   }",
          "329: };",
          "332:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRowsGrad\") \\",
          "341: #undef REGISTER_KERNELS",
          "342: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "322:     auto d_default_value = d_default_value_t->scalar<T>();",
          "324:     OP_REQUIRES_OK(context,",
          "325:                    functor::SparseFillEmptyRowsGrad<Device, T, Tindex>()(",
          "326:                        context, reverse_index_map, grad_values, d_values,",
          "327:                        d_default_value));",
          "331: #define REGISTER_KERNELS(D, T, Tindex)                    \\",
          "333:                               .Device(DEVICE_##D)         \\",
          "334:                               .TypeConstraint<T>(\"T\"),    \\",
          "335:                           SparseFillEmptyRowsGradOp<D##Device, T, Tindex>)",
          "337: #define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)",
          "338: TF_CALL_NUMBER_TYPES(REGISTER_CPU_KERNELS);",
          "339: #undef REGISTER_CPU_KERNELS",
          "",
          "[Added Lines]",
          "257:     T& d_default_value = d_default_value_t->scalar<T>()();",
          "258:     d_default_value = T();",
          "260:     Tensor visited_t;",
          "261:     OP_REQUIRES_OK(context, context->allocate_temp(",
          "262:                                 DT_BOOL, TensorShape({N_full}), &visited_t));",
          "263:     auto visited = visited_t.vec<bool>();",
          "264:     visited.device(d) = visited.constant(false);",
          "266:     for (int i = 0; i < N; ++i) {",
          "270:       int64 reverse_index = reverse_index_map(i);",
          "271:       OP_REQUIRES(",
          "272:           context, 0 <= reverse_index && reverse_index < N_full,",
          "273:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
          "274:                                   N_full, \") but got \", reverse_index));",
          "275:       d_values(i) = grad_values(reverse_index);",
          "276:       visited(reverse_index) = true;",
          "277:     }",
          "278:     for (int j = 0; j < N_full; ++j) {",
          "282:       if (!visited(j)) {",
          "283:         d_default_value += grad_values(j);",
          "284:       }",
          "285:     }",
          "289: #define REGISTER_KERNELS(type)                            \\",
          "291:                               .Device(DEVICE_CPU)         \\",
          "292:                               .TypeConstraint<type>(\"T\"), \\",
          "293:                           SparseFillEmptyRowsGradOp<type>)",
          "295: TF_CALL_NUMBER_TYPES(REGISTER_KERNELS);",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.h||tensorflow/core/kernels/sparse_fill_empty_rows_op.h": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.h -> tensorflow/core/kernels/sparse_fill_empty_rows_op.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "492d57aa2528b5faa1a4af279dcd6ab98b6c3dd2",
      "candidate_info": {
        "commit_hash": "492d57aa2528b5faa1a4af279dcd6ab98b6c3dd2",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/492d57aa2528b5faa1a4af279dcd6ab98b6c3dd2",
        "files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.h"
        ],
        "message": "Refactor SparseFillEmptyRows CPU kernel into class\n\n- This is a NFC in preparation for adding a GPU implementation.\n- Also includes the Grad kernel.\n- Also generalizes int64 indexing to template type Tindex.",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.h||tensorflow/core/kernels/sparse_fill_empty_rows_op.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #define EIGEN_USE_THREADS",
          "18: #include <algorithm>",
          "19: #include <numeric>",
          "20: #include <unordered_map>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include \"tensorflow/core/kernels/sparse_fill_empty_rows_op.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: using CPUDevice = Eigen::ThreadPoolDevice;",
          "48:     const int kOutputIndicesOutput = 0;",
          "49:     const int kOutputValuesOutput = 1;",
          "50:     const int kEmptyRowIndicatorOutput = 2;",
          "51:     const int kReverseIndexMapOutput = 3;",
          "73:     const T& default_value = default_value_t.scalar<T>()();",
          "75:     const auto values = values_t.vec<T>();",
          "81:     bool* empty_row_indicator = nullptr;",
          "82:     if (context->output_required(kEmptyRowIndicatorOutput)) {",
          "83:       Tensor* empty_row_indicator_t = nullptr;",
          "88:       empty_row_indicator = empty_row_indicator_t->vec<bool>().data();",
          "89:     }",
          "91:     if (context->output_required(kReverseIndexMapOutput)) {",
          "92:       Tensor* reverse_index_map_t = nullptr;",
          "97:     }",
          "99:     int rank = indices_t.shape().dim_size(1);",
          "101:     if (dense_rows == 0) {",
          "107:       Tensor* output_indices_t;",
          "108:       TensorShape output_indices_shape({0, rank});",
          "112:       Tensor* output_values_t;",
          "119:     }",
          "121:     bool rows_are_ordered = true;",
          "124:     for (int i = 0; i < N; ++i) {",
          "129:       ++csr_offset[row];",
          "130:       rows_are_ordered = rows_are_ordered & (row >= last_indices_row);",
          "131:       last_indices_row = row;",
          "",
          "[Removed Lines]",
          "36: template <typename T>",
          "37: class SparseFillEmptyRowsOp : public OpKernel {",
          "38:  public:",
          "39:   explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)",
          "40:       : OpKernel(context) {}",
          "42:   void Compute(OpKernelContext* context) override {",
          "43:     const int kIndicesInput = 0;",
          "44:     const int kValuesInput = 1;",
          "45:     const int kDenseShapeInput = 2;",
          "46:     const int kDefaultValueInput = 3;",
          "53:     const Tensor& indices_t = context->input(kIndicesInput);",
          "54:     const Tensor& values_t = context->input(kValuesInput);",
          "55:     const Tensor& dense_shape_t = context->input(kDenseShapeInput);",
          "56:     const Tensor& default_value_t = context->input(kDefaultValueInput);",
          "58:     OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),",
          "59:                 errors::InvalidArgument(\"dense_shape must be a vector, saw: \",",
          "60:                                         dense_shape_t.shape().DebugString()));",
          "61:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),",
          "62:                 errors::InvalidArgument(\"indices must be a matrix, saw: \",",
          "63:                                         indices_t.shape().DebugString()));",
          "64:     OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),",
          "65:                 errors::InvalidArgument(\"values must be a vector, saw: \",",
          "66:                                         values_t.shape().DebugString()));",
          "67:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),",
          "68:                 errors::InvalidArgument(\"default_value must be a scalar, saw: \",",
          "69:                                         default_value_t.shape().DebugString()));",
          "74:     const auto indices = indices_t.matrix<int64>();",
          "76:     const auto dense_shape = dense_shape_t.vec<int64>();",
          "78:     const int64 N = indices_t.shape().dim_size(0);",
          "79:     const int64 dense_rows = dense_shape(0);",
          "84:       OP_REQUIRES_OK(context,",
          "85:                      context->allocate_output(kEmptyRowIndicatorOutput,",
          "86:                                               TensorShape({dense_rows}),",
          "87:                                               &empty_row_indicator_t));",
          "90:     int64* reverse_index_map = nullptr;",
          "93:       OP_REQUIRES_OK(context, context->allocate_output(kReverseIndexMapOutput,",
          "94:                                                        TensorShape({N}),",
          "95:                                                        &reverse_index_map_t));",
          "96:       reverse_index_map = reverse_index_map_t->vec<int64>().data();",
          "102:       OP_REQUIRES(",
          "103:           context, N == 0,",
          "104:           errors::InvalidArgument(\"Received SparseTensor with dense_shape[0] = \"",
          "105:                                   \"0 but indices.shape[0] = \",",
          "106:                                   N));",
          "109:       OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,",
          "110:                                                        output_indices_shape,",
          "111:                                                        &output_indices_t));",
          "113:       OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,",
          "114:                                                        TensorShape({0}),",
          "115:                                                        &output_values_t));",
          "118:       return;",
          "122:     int64 last_indices_row = 0;",
          "123:     std::vector<int64> csr_offset(dense_rows, 0);",
          "125:       const int64 row = indices(i, 0);",
          "126:       OP_REQUIRES(context, row >= 0 && row < dense_rows,",
          "127:                   errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \",",
          "128:                                           row, \" >= \", dense_rows));",
          "",
          "[Added Lines]",
          "38: namespace functor {",
          "40: template <typename T, typename Tindex>",
          "41: struct SparseFillEmptyRows<CPUDevice, T, Tindex> {",
          "42:   Status operator()(OpKernelContext* context, const Tensor& default_value_t,",
          "43:                     const Tensor& indices_t, const Tensor& values_t,",
          "44:                     const Tensor& dense_shape_t) {",
          "51:     const auto indices = indices_t.matrix<Tindex>();",
          "53:     const auto dense_shape = dense_shape_t.vec<Tindex>();",
          "55:     const Tindex N = indices_t.shape().dim_size(0);",
          "56:     const Tindex dense_rows = dense_shape(0);",
          "61:       TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,",
          "62:                                                   TensorShape({dense_rows}),",
          "63:                                                   &empty_row_indicator_t));",
          "66:     Tindex* reverse_index_map = nullptr;",
          "69:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "70:           kReverseIndexMapOutput, TensorShape({N}), &reverse_index_map_t));",
          "71:       reverse_index_map = reverse_index_map_t->vec<Tindex>().data();",
          "77:       if (N != 0) {",
          "78:         errors::InvalidArgument(",
          "79:             \"Received SparseTensor with dense_shape[0] = 0 but \"",
          "80:             \"indices.shape[0] = \",",
          "81:             N);",
          "82:       }",
          "85:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "86:           kOutputIndicesOutput, output_indices_shape, &output_indices_t));",
          "88:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "89:           kOutputValuesOutput, TensorShape({0}), &output_values_t));",
          "92:       return Status::OK();",
          "96:     Tindex last_indices_row = 0;",
          "97:     std::vector<Tindex> csr_offset(dense_rows, 0);",
          "99:       const Tindex row = indices(i, 0);",
          "100:       if (row < 0 || row >= dense_rows) {",
          "101:         errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \", row,",
          "102:                                 \" >= \", dense_rows);",
          "103:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "139:       }",
          "140:       all_rows_full = all_rows_full & !row_empty;",
          "",
          "[Removed Lines]",
          "142:       csr_offset[row] = std::max(csr_offset[row], int64{1});",
          "",
          "[Added Lines]",
          "117:       csr_offset[row] = std::max(csr_offset[row], Tindex{1});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:       context->set_output(kOutputIndicesOutput, indices_t);",
          "156:       context->set_output(kOutputValuesOutput, values_t);",
          "157:       if (reverse_index_map) {",
          "159:           reverse_index_map[i] = i;",
          "160:         }",
          "161:       }",
          "162:     } else {",
          "163:       Tensor* output_indices_t;",
          "165:       TensorShape output_indices_shape({N_full, rank});",
          "171:       Tensor* output_values_t;",
          "175:       auto output_values = output_values_t->vec<T>();",
          "184:         offset++;  // Increment the filled count for this row.",
          "185:         std::copy_n(&indices(i, 0), rank, &output_indices(output_i, 0));",
          "186:         output_values(output_i) = values(i);",
          "",
          "[Removed Lines]",
          "158:         for (int64 i = 0; i < N; ++i) {",
          "164:       const int64 N_full = csr_offset[dense_rows - 1];",
          "166:       OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,",
          "167:                                                        output_indices_shape,",
          "168:                                                        &output_indices_t));",
          "169:       auto output_indices = output_indices_t->matrix<int64>();",
          "172:       OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,",
          "173:                                                        TensorShape({N_full}),",
          "174:                                                        &output_values_t));",
          "177:       std::vector<int64> filled_count(dense_rows, 0);",
          "180:       for (int64 i = 0; i < N; ++i) {",
          "181:         const int64 row = indices(i, 0);",
          "182:         int64& offset = filled_count[row];",
          "183:         const int64 output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;",
          "",
          "[Added Lines]",
          "133:         for (Tindex i = 0; i < N; ++i) {",
          "139:       const Tindex N_full = csr_offset[dense_rows - 1];",
          "141:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "142:           kOutputIndicesOutput, output_indices_shape, &output_indices_t));",
          "143:       auto output_indices = output_indices_t->matrix<Tindex>();",
          "146:       TF_RETURN_IF_ERROR(context->allocate_output(",
          "147:           kOutputValuesOutput, TensorShape({N_full}), &output_values_t));",
          "150:       std::vector<Tindex> filled_count(dense_rows, 0);",
          "153:       for (Tindex i = 0; i < N; ++i) {",
          "154:         const Tindex row = indices(i, 0);",
          "155:         Tindex& offset = filled_count[row];",
          "156:         const Tindex output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "191:       }",
          "196:         if (row_count == 0) {  // We haven't filled this row",
          "200:           output_indices(starting_index, 0) = row;",
          "202:             output_indices(starting_index, col) = 0;",
          "203:           }",
          "204:           output_values(starting_index) = default_value;",
          "205:         }",
          "206:       }",
          "207:     }",
          "208:   }",
          "209: };",
          "218: #undef REGISTER_KERNELS",
          "221: class SparseFillEmptyRowsGradOp : public OpKernel {",
          "222:  public:",
          "223:   explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)",
          "",
          "[Removed Lines]",
          "194:       for (int64 row = 0; row < dense_rows; ++row) {",
          "195:         const int64 row_count = filled_count[row];",
          "197:           const int64 starting_index = (row == 0) ? 0 : csr_offset[row - 1];",
          "201:           for (int64 col = 1; col < rank; ++col) {",
          "211: #define REGISTER_KERNELS(type)                            \\",
          "212:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")     \\",
          "213:                               .Device(DEVICE_CPU)         \\",
          "214:                               .TypeConstraint<type>(\"T\"), \\",
          "215:                           SparseFillEmptyRowsOp<type>)",
          "217: TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "220: template <typename T>",
          "",
          "[Added Lines]",
          "167:       for (Tindex row = 0; row < dense_rows; ++row) {",
          "168:         const Tindex row_count = filled_count[row];",
          "170:           const Tindex starting_index = (row == 0) ? 0 : csr_offset[row - 1];",
          "174:           for (Tindex col = 1; col < rank; ++col) {",
          "182:     return Status::OK();",
          "183:   }",
          "184: };",
          "186: }  // namespace functor",
          "188: template <typename Device, typename T, typename Tindex>",
          "189: class SparseFillEmptyRowsOp : public OpKernel {",
          "190:  public:",
          "191:   explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)",
          "192:       : OpKernel(context) {}",
          "194:   void Compute(OpKernelContext* context) override {",
          "195:     const int kIndicesInput = 0;",
          "196:     const int kValuesInput = 1;",
          "197:     const int kDenseShapeInput = 2;",
          "198:     const int kDefaultValueInput = 3;",
          "200:     const int kOutputIndicesOutput = 0;",
          "201:     const int kOutputValuesOutput = 1;",
          "202:     const int kEmptyRowIndicatorOutput = 2;",
          "203:     const int kReverseIndexMapOutput = 3;",
          "205:     const Tensor& indices_t = context->input(kIndicesInput);",
          "206:     const Tensor& values_t = context->input(kValuesInput);",
          "207:     const Tensor& dense_shape_t = context->input(kDenseShapeInput);",
          "208:     const Tensor& default_value_t = context->input(kDefaultValueInput);",
          "210:     OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),",
          "211:                 errors::InvalidArgument(\"dense_shape must be a vector, saw: \",",
          "212:                                         dense_shape_t.shape().DebugString()));",
          "213:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),",
          "214:                 errors::InvalidArgument(\"indices must be a matrix, saw: \",",
          "215:                                         indices_t.shape().DebugString()));",
          "216:     OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),",
          "217:                 errors::InvalidArgument(\"values must be a vector, saw: \",",
          "218:                                         values_t.shape().DebugString()));",
          "219:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),",
          "220:                 errors::InvalidArgument(\"default_value must be a scalar, saw: \",",
          "221:                                         default_value_t.shape().DebugString()));",
          "225:     OP_REQUIRES_OK(context, functor::SparseFillEmptyRows<Device, T, Tindex>()(",
          "226:                                 context, default_value_t, indices_t, values_t,",
          "227:                                 dense_shape_t));",
          "231: #define REGISTER_KERNELS(D, T, Tindex)                   \\",
          "232:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")    \\",
          "233:                               .Device(DEVICE_##D)        \\",
          "234:                               .HostMemory(\"dense_shape\") \\",
          "235:                               .TypeConstraint<T>(\"T\"),   \\",
          "236:                           SparseFillEmptyRowsOp<D##Device, T, Tindex>)",
          "238: #define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)",
          "239: TF_CALL_ALL_TYPES(REGISTER_CPU_KERNELS);",
          "240: #undef REGISTER_CPU_KERNELS",
          "244: namespace functor {",
          "246: template <typename T, typename Tindex>",
          "247: struct SparseFillEmptyRowsGrad<CPUDevice, T, Tindex> {",
          "248:   Status operator()(OpKernelContext* context,",
          "249:                     typename TTypes<Tindex>::ConstVec reverse_index_map,",
          "250:                     typename TTypes<T>::ConstVec grad_values,",
          "251:                     typename TTypes<T>::Vec d_values,",
          "252:                     typename TTypes<T>::Scalar d_default_value) {",
          "253:     const CPUDevice& device = context->eigen_device<CPUDevice>();",
          "254:     const Tindex N = reverse_index_map.dimension(0);",
          "255:     const Tindex N_full = grad_values.dimension(0);",
          "257:     T& d_default_value_scalar = d_default_value();",
          "258:     d_default_value_scalar = T();",
          "260:     Tensor visited_t;",
          "261:     TF_RETURN_IF_ERROR(",
          "262:         context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));",
          "263:     auto visited = visited_t.vec<bool>();",
          "264:     visited.device(device) = visited.constant(false);",
          "266:     for (int i = 0; i < N; ++i) {",
          "270:       int64 reverse_index = reverse_index_map(i);",
          "271:       if (reverse_index < 0 || reverse_index >= N_full) {",
          "272:         return errors::InvalidArgument(",
          "273:             \"Elements in reverse index must be in [0, \", N_full, \") but got \",",
          "274:             reverse_index);",
          "275:       }",
          "276:       d_values(i) = grad_values(reverse_index);",
          "277:       visited(reverse_index) = true;",
          "278:     }",
          "279:     for (int j = 0; j < N_full; ++j) {",
          "283:       if (!visited(j)) {",
          "284:         d_default_value_scalar += grad_values(j);",
          "285:       }",
          "286:     }",
          "287:     return Status::OK();",
          "288:   }",
          "289: };",
          "291: }  // namespace functor",
          "293: template <typename Device, typename T, typename Tindex>",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "230:                    context->input(\"reverse_index_map\", &reverse_index_map_t));",
          "231:     OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));",
          "235:     OP_REQUIRES(",
          "236:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
          "237:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
          "",
          "[Removed Lines]",
          "233:     const CPUDevice& d = context->eigen_device<CPUDevice>();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "240:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
          "241:                                         grad_values_t->shape().DebugString()));",
          "244:     const auto grad_values = grad_values_t->vec<T>();",
          "249:     Tensor* d_values_t;",
          "250:     OP_REQUIRES_OK(context, context->allocate_output(",
          "",
          "[Removed Lines]",
          "243:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
          "246:     const int64 N = reverse_index_map_t->shape().dim_size(0);",
          "247:     const int64 N_full = grad_values_t->shape().dim_size(0);",
          "",
          "[Added Lines]",
          "314:     const auto reverse_index_map = reverse_index_map_t->vec<Tindex>();",
          "317:     const Tindex N = reverse_index_map_t->shape().dim_size(0);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "254:     OP_REQUIRES_OK(context,",
          "255:                    context->allocate_output(\"d_default_value\", TensorShape({}),",
          "256:                                             &d_default_value_t));",
          "286:   }",
          "287: };",
          "290:   REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRowsGrad\") \\",
          "296: #undef REGISTER_KERNELS",
          "297: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "257:     T& d_default_value = d_default_value_t->scalar<T>()();",
          "258:     d_default_value = T();",
          "260:     Tensor visited_t;",
          "261:     OP_REQUIRES_OK(context, context->allocate_temp(",
          "262:                                 DT_BOOL, TensorShape({N_full}), &visited_t));",
          "263:     auto visited = visited_t.vec<bool>();",
          "264:     visited.device(d) = visited.constant(false);",
          "266:     for (int i = 0; i < N; ++i) {",
          "270:       int64 reverse_index = reverse_index_map(i);",
          "271:       OP_REQUIRES(",
          "272:           context, 0 <= reverse_index && reverse_index < N_full,",
          "273:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
          "274:                                   N_full, \") but got \", reverse_index));",
          "275:       d_values(i) = grad_values(reverse_index);",
          "276:       visited(reverse_index) = true;",
          "277:     }",
          "278:     for (int j = 0; j < N_full; ++j) {",
          "282:       if (!visited(j)) {",
          "283:         d_default_value += grad_values(j);",
          "284:       }",
          "285:     }",
          "289: #define REGISTER_KERNELS(type)                            \\",
          "291:                               .Device(DEVICE_CPU)         \\",
          "292:                               .TypeConstraint<type>(\"T\"), \\",
          "293:                           SparseFillEmptyRowsGradOp<type>)",
          "295: TF_CALL_NUMBER_TYPES(REGISTER_KERNELS);",
          "",
          "[Added Lines]",
          "327:     auto d_default_value = d_default_value_t->scalar<T>();",
          "329:     OP_REQUIRES_OK(context,",
          "330:                    functor::SparseFillEmptyRowsGrad<Device, T, Tindex>()(",
          "331:                        context, reverse_index_map, grad_values, d_values,",
          "332:                        d_default_value));",
          "336: #define REGISTER_KERNELS(D, T, Tindex)                    \\",
          "338:                               .Device(DEVICE_##D)         \\",
          "339:                               .TypeConstraint<T>(\"T\"),    \\",
          "340:                           SparseFillEmptyRowsGradOp<D##Device, T, Tindex>)",
          "342: #define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)",
          "343: TF_CALL_NUMBER_TYPES(REGISTER_CPU_KERNELS);",
          "344: #undef REGISTER_CPU_KERNELS",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.h||tensorflow/core/kernels/sparse_fill_empty_rows_op.h": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.h -> tensorflow/core/kernels/sparse_fill_empty_rows_op.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: you may not use this file except in compliance with the License.",
          "5: You may obtain a copy of the License at",
          "7:     http://www.apache.org/licenses/LICENSE-2.0",
          "9: Unless required by applicable law or agreed to in writing, software",
          "10: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: See the License for the specific language governing permissions and",
          "13: limitations under the License.",
          "16: #ifndef TENSORFLOW_CORE_KERNELS_SPARSE_FILL_EMPTY_ROWS_OP_H_",
          "17: #define TENSORFLOW_CORE_KERNELS_SPARSE_FILL_EMPTY_ROWS_OP_H_",
          "19: #include \"tensorflow/core/framework/op_kernel.h\"",
          "20: #include \"tensorflow/core/framework/tensor_types.h\"",
          "21: #include \"tensorflow/core/lib/core/status.h\"",
          "23: namespace tensorflow {",
          "25: namespace functor {",
          "27: template <typename Device, typename T, typename Tindex>",
          "28: struct SparseFillEmptyRows {",
          "29:   Status operator()(OpKernelContext* context, const Tensor& default_value_t,",
          "30:                     const Tensor& indices_t, const Tensor& values_t,",
          "31:                     const Tensor& dense_shape_t);",
          "32: };",
          "34: template <typename Device, typename T, typename Tindex>",
          "35: struct SparseFillEmptyRowsGrad {",
          "36:   Status operator()(OpKernelContext* context,",
          "37:                     typename TTypes<Tindex>::ConstVec reverse_index_map,",
          "38:                     typename TTypes<T>::ConstVec grad_values,",
          "39:                     typename TTypes<T>::Vec d_values,",
          "40:                     typename TTypes<T>::Scalar d_default_value);",
          "41: };",
          "43: }  // namespace functor",
          "45: }  // namespace tensorflow",
          "47: #endif  // TENSORFLOW_CORE_KERNELS_SPARSE_FILL_EMPTY_ROWS_OP_H_",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3535c02c716b81f1f12022380530ac50628a476",
      "candidate_info": {
        "commit_hash": "f3535c02c716b81f1f12022380530ac50628a476",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/f3535c02c716b81f1f12022380530ac50628a476",
        "files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py"
        ],
        "message": "Fix heap buffer overflow in `tf.raw_ops.SparseFillEmptyRowsGrad`.\n\nAlso add tests as they were lacking\n\nPiperOrigin-RevId: 332566071\nChange-Id: I44277578e26ff5fb3fdb0dcbba6e91b2ec3e7859",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
          "233:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
          "234:                                 reverse_index_map_t->shape().DebugString()));",
          "236:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
          "237:     const auto grad_values = grad_values_t->vec<T>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "235:     OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),",
          "236:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
          "237:                                         grad_values_t->shape().DebugString()));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "265:     }",
          "266:     for (int j = 0; j < N_full; ++j) {",
          "",
          "[Removed Lines]",
          "263:       d_values(i) = grad_values(reverse_index_map(i));",
          "264:       visited(reverse_index_map(i)) = true;",
          "",
          "[Added Lines]",
          "266:       int64 reverse_index = reverse_index_map(i);",
          "267:       OP_REQUIRES(",
          "268:           context, 0 <= reverse_index && reverse_index < N_full,",
          "269:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
          "270:                                   N_full, \") but got \", reverse_index));",
          "271:       d_values(i) = grad_values(reverse_index);",
          "272:       visited(reverse_index) = true;",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py": [
          "File: tensorflow/python/ops/sparse_ops_test.py -> tensorflow/python/ops/sparse_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from absl.testing import parameterized",
          "22: import numpy as np",
          "24: from tensorflow.python.framework import constant_op",
          "25: from tensorflow.python.framework import dtypes",
          "26: from tensorflow.python.framework import ops",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: from tensorflow.python.eager import context",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: # Need array_grad to register gradient for Identity.",
          "30: from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
          "31: from tensorflow.python.ops import array_ops",
          "32: from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
          "33: from tensorflow.python.ops import math_ops",
          "34: # Need sparse_grad to register gradient for SparseToDense.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: from tensorflow.python.ops import gen_sparse_ops",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:     self.assertAllEqual(expected, result)",
          "184: if __name__ == '__main__':",
          "185:   googletest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: @test_util.run_all_in_graph_and_eager_modes",
          "187: class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
          "189:   def testSparseFillEmptyRowsGrad(self):",
          "190:     reverse_index_map = [2, 1]",
          "191:     grad_values = [0, 1, 2, 3]",
          "192:     d_values, d_default_value = self.evaluate(",
          "193:         gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "194:             reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "195:     self.assertAllEqual([2, 1], d_values)",
          "196:     self.assertEqual(3, d_default_value)",
          "198:   def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):",
          "199:     reverse_index_map = [2, -1]",
          "200:     grad_values = [0, 1, 2, 3]",
          "201:     with self.assertRaisesRegex(",
          "202:         errors.InvalidArgumentError,",
          "203:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "204:       self.evaluate(",
          "205:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "206:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "208:   def testSparseFillEmptyRowsGradLargeIndexMapValue(self):",
          "209:     reverse_index_map = [2, 10]",
          "210:     grad_values = [0, 1, 2, 3]",
          "211:     with self.assertRaisesRegex(",
          "212:         errors.InvalidArgumentError,",
          "213:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "214:       self.evaluate(",
          "215:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "216:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "218:   def testSparseFillEmptyRowsGradMatrix(self):",
          "219:     reverse_index_map = [0, 1]",
          "220:     grad_values = [[0, 1], [2, 3]]",
          "221:     # Note: Eager mode and graph mode throw different errors here. Graph mode",
          "222:     # will fail with a ValueError from the shape checking logic, while Eager",
          "223:     # will fail with an InvalidArgumentError from the kernel itself.",
          "224:     if context.executing_eagerly():",
          "225:       with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "226:                                   r'grad_values must be a vector'):",
          "227:         self.evaluate(",
          "228:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "229:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "230:     else:",
          "231:       with self.assertRaisesRegex(ValueError,",
          "232:                                   r'Shape must be rank 1 but is rank 2'):",
          "233:         self.evaluate(",
          "234:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "235:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd8e10fb9017783b019fdf4c3bcfa452a79e0c32",
      "candidate_info": {
        "commit_hash": "fd8e10fb9017783b019fdf4c3bcfa452a79e0c32",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/fd8e10fb9017783b019fdf4c3bcfa452a79e0c32",
        "files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py"
        ],
        "message": "Fix heap buffer overflow in `tf.raw_ops.SparseFillEmptyRowsGrad`.\n\nAlso add tests as they were lacking\n\nPiperOrigin-RevId: 332566071\nChange-Id: I44277578e26ff5fb3fdb0dcbba6e91b2ec3e7859",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "213:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
          "214:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
          "215:                                 reverse_index_map_t->shape().DebugString()));",
          "217:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
          "218:     const auto grad_values = grad_values_t->vec<T>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:     OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),",
          "217:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
          "218:                                         grad_values_t->shape().DebugString()));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246:     }",
          "247:     for (int j = 0; j < N_full; ++j) {",
          "",
          "[Removed Lines]",
          "244:       d_values(i) = grad_values(reverse_index_map(i));",
          "245:       visited(reverse_index_map(i)) = true;",
          "",
          "[Added Lines]",
          "247:       int64 reverse_index = reverse_index_map(i);",
          "248:       OP_REQUIRES(",
          "249:           context, 0 <= reverse_index && reverse_index < N_full,",
          "250:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
          "251:                                   N_full, \") but got \", reverse_index));",
          "252:       d_values(i) = grad_values(reverse_index);",
          "253:       visited(reverse_index) = true;",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py": [
          "File: tensorflow/python/ops/sparse_ops_test.py -> tensorflow/python/ops/sparse_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from absl.testing import parameterized",
          "22: import numpy as np",
          "24: from tensorflow.python.framework import constant_op",
          "25: from tensorflow.python.framework import dtypes",
          "26: from tensorflow.python.framework import sparse_tensor",
          "27: from tensorflow.python.framework import test_util",
          "28: # Need array_grad to register gradient for Identity.",
          "29: from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
          "30: from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
          "31: from tensorflow.python.ops import math_ops",
          "32: # Need sparse_grad to register gradient for SparseToDense.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: from tensorflow.python.eager import context",
          "31: from tensorflow.python.ops import gen_sparse_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:     self.assertAllEqual(expected_dense, result_dense)",
          "137: if __name__ == '__main__':",
          "138:   googletest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139: @test_util.run_all_in_graph_and_eager_modes",
          "140: class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
          "142:   def testSparseFillEmptyRowsGrad(self):",
          "143:     reverse_index_map = [2, 1]",
          "144:     grad_values = [0, 1, 2, 3]",
          "145:     d_values, d_default_value = self.evaluate(",
          "146:         gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "147:             reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "148:     self.assertAllEqual([2, 1], d_values)",
          "149:     self.assertEqual(3, d_default_value)",
          "151:   def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):",
          "152:     reverse_index_map = [2, -1]",
          "153:     grad_values = [0, 1, 2, 3]",
          "154:     with self.assertRaisesRegex(",
          "155:         errors.InvalidArgumentError,",
          "156:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "157:       self.evaluate(",
          "158:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "159:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "161:   def testSparseFillEmptyRowsGradLargeIndexMapValue(self):",
          "162:     reverse_index_map = [2, 10]",
          "163:     grad_values = [0, 1, 2, 3]",
          "164:     with self.assertRaisesRegex(",
          "165:         errors.InvalidArgumentError,",
          "166:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "167:       self.evaluate(",
          "168:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "169:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "171:   def testSparseFillEmptyRowsGradMatrix(self):",
          "172:     reverse_index_map = [0, 1]",
          "173:     grad_values = [[0, 1], [2, 3]]",
          "174:     # Note: Eager mode and graph mode throw different errors here. Graph mode",
          "175:     # will fail with a ValueError from the shape checking logic, while Eager",
          "176:     # will fail with an InvalidArgumentError from the kernel itself.",
          "177:     if context.executing_eagerly():",
          "178:       with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "179:                                   r'grad_values must be a vector'):",
          "180:         self.evaluate(",
          "181:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "182:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "183:     else:",
          "184:       with self.assertRaisesRegex(ValueError,",
          "185:                                   r'Shape must be rank 1 but is rank 2'):",
          "186:         self.evaluate(",
          "187:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "188:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "156872df9bbf3c237e6eb9ff226837a03ff479ef",
      "candidate_info": {
        "commit_hash": "156872df9bbf3c237e6eb9ff226837a03ff479ef",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/156872df9bbf3c237e6eb9ff226837a03ff479ef",
        "files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py"
        ],
        "message": "Fix heap buffer overflow in `tf.raw_ops.SparseFillEmptyRowsGrad`.\n\nAlso add tests as they were lacking\n\nPiperOrigin-RevId: 332566071\nChange-Id: I44277578e26ff5fb3fdb0dcbba6e91b2ec3e7859",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
            "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_fill_empty_rows_op.cc||tensorflow/core/kernels/sparse_fill_empty_rows_op.cc": [
          "File: tensorflow/core/kernels/sparse_fill_empty_rows_op.cc -> tensorflow/core/kernels/sparse_fill_empty_rows_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),",
          "233:         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",",
          "234:                                 reverse_index_map_t->shape().DebugString()));",
          "236:     const auto reverse_index_map = reverse_index_map_t->vec<int64>();",
          "237:     const auto grad_values = grad_values_t->vec<T>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "235:     OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),",
          "236:                 errors::InvalidArgument(\"grad_values must be a vector, saw: \",",
          "237:                                         grad_values_t->shape().DebugString()));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "265:     }",
          "266:     for (int j = 0; j < N_full; ++j) {",
          "",
          "[Removed Lines]",
          "263:       d_values(i) = grad_values(reverse_index_map(i));",
          "264:       visited(reverse_index_map(i)) = true;",
          "",
          "[Added Lines]",
          "266:       int64 reverse_index = reverse_index_map(i);",
          "267:       OP_REQUIRES(",
          "268:           context, 0 <= reverse_index && reverse_index < N_full,",
          "269:           errors::InvalidArgument(\"Elements in reverse index must be in [0, \",",
          "270:                                   N_full, \") but got \", reverse_index));",
          "271:       d_values(i) = grad_values(reverse_index);",
          "272:       visited(reverse_index) = true;",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/sparse_ops_test.py||tensorflow/python/ops/sparse_ops_test.py": [
          "File: tensorflow/python/ops/sparse_ops_test.py -> tensorflow/python/ops/sparse_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: from absl.testing import parameterized",
          "22: import numpy as np",
          "24: from tensorflow.python.framework import constant_op",
          "25: from tensorflow.python.framework import dtypes",
          "26: from tensorflow.python.framework import ops",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: from tensorflow.python.eager import context",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: # Need array_grad to register gradient for Identity.",
          "30: from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
          "31: from tensorflow.python.ops import array_ops",
          "32: from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
          "33: from tensorflow.python.ops import math_ops",
          "34: # Need sparse_grad to register gradient for SparseToDense.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: from tensorflow.python.ops import gen_sparse_ops",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:     self.assertAllEqual(expected, result)",
          "184: if __name__ == '__main__':",
          "185:   googletest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: @test_util.run_all_in_graph_and_eager_modes",
          "187: class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
          "189:   def testSparseFillEmptyRowsGrad(self):",
          "190:     reverse_index_map = [2, 1]",
          "191:     grad_values = [0, 1, 2, 3]",
          "192:     d_values, d_default_value = self.evaluate(",
          "193:         gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "194:             reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "195:     self.assertAllEqual([2, 1], d_values)",
          "196:     self.assertEqual(3, d_default_value)",
          "198:   def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):",
          "199:     reverse_index_map = [2, -1]",
          "200:     grad_values = [0, 1, 2, 3]",
          "201:     with self.assertRaisesRegex(",
          "202:         errors.InvalidArgumentError,",
          "203:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "204:       self.evaluate(",
          "205:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "206:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "208:   def testSparseFillEmptyRowsGradLargeIndexMapValue(self):",
          "209:     reverse_index_map = [2, 10]",
          "210:     grad_values = [0, 1, 2, 3]",
          "211:     with self.assertRaisesRegex(",
          "212:         errors.InvalidArgumentError,",
          "213:         r'Elements in reverse index must be in \\[0, 4\\)'):",
          "214:       self.evaluate(",
          "215:           gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "216:               reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "218:   def testSparseFillEmptyRowsGradMatrix(self):",
          "219:     reverse_index_map = [0, 1]",
          "220:     grad_values = [[0, 1], [2, 3]]",
          "221:     # Note: Eager mode and graph mode throw different errors here. Graph mode",
          "222:     # will fail with a ValueError from the shape checking logic, while Eager",
          "223:     # will fail with an InvalidArgumentError from the kernel itself.",
          "224:     if context.executing_eagerly():",
          "225:       with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "226:                                   r'grad_values must be a vector'):",
          "227:         self.evaluate(",
          "228:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "229:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "230:     else:",
          "231:       with self.assertRaisesRegex(ValueError,",
          "232:                                   r'Shape must be rank 1 but is rank 2'):",
          "233:         self.evaluate(",
          "234:             gen_sparse_ops.SparseFillEmptyRowsGrad(",
          "235:                 reverse_index_map=reverse_index_map, grad_values=grad_values))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
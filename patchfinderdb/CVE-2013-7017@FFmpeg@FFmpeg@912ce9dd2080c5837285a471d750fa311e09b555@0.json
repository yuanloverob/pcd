{
  "cve_id": "CVE-2013-7017",
  "cve_desc": "libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "912ce9dd2080c5837285a471d750fa311e09b555",
  "patch_info": {
    "commit_hash": "912ce9dd2080c5837285a471d750fa311e09b555",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/912ce9dd2080c5837285a471d750fa311e09b555",
    "files": [
      "libavcodec/jpeg2000.c"
    ],
    "message": "jpeg2000: fix dereferencing invalid pointers\n\nFound-by: Laurent Butti <laurentb@gmail.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
    ]
  },
  "patch_diff": {
    "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c": [
      "File: libavcodec/jpeg2000.c -> libavcodec/jpeg2000.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "272:                                         reslevel->log2_prec_height) -",
      "273:                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);",
      "276:         if (!reslevel->band)",
      "277:             return AVERROR(ENOMEM);",
      "",
      "[Removed Lines]",
      "275:         reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));",
      "",
      "[Added Lines]",
      "275:         reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "368:             for (j = 0; j < 2; j++)",
      "369:                 band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);",
      "372:                                          (uint64_t)reslevel->num_precincts_y,",
      "373:                                          sizeof(*band->prec));",
      "374:             if (!band->prec)",
      "",
      "[Removed Lines]",
      "371:             band->prec = av_malloc_array(reslevel->num_precincts_x *",
      "",
      "[Added Lines]",
      "371:             band->prec = av_calloc(reslevel->num_precincts_x *",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "509:         for (bandno = 0; bandno < reslevel->nbands; bandno++) {",
      "510:             Jpeg2000Band *band = reslevel->band + bandno;",
      "511:             for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {",
      "516:             }",
      "518:             av_freep(&band->prec);",
      "",
      "[Removed Lines]",
      "512:                 Jpeg2000Prec *prec = band->prec + precno;",
      "513:                 av_freep(&prec->zerobits);",
      "514:                 av_freep(&prec->cblkincl);",
      "515:                 av_freep(&prec->cblk);",
      "",
      "[Added Lines]",
      "512:                 if (band->prec) {",
      "513:                     Jpeg2000Prec *prec = band->prec + precno;",
      "514:                     av_freep(&prec->zerobits);",
      "515:                     av_freep(&prec->cblkincl);",
      "516:                     av_freep(&prec->cblk);",
      "517:                 }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a1b32533aa7f31224f8f0be05d2cf020159e2e90",
      "candidate_info": {
        "commit_hash": "a1b32533aa7f31224f8f0be05d2cf020159e2e90",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a1b32533aa7f31224f8f0be05d2cf020159e2e90",
        "files": [
          "libavcodec/jpeg2000.c"
        ],
        "message": "jpeg2000: fix dereferencing invalid pointers\n\nFound-by: Laurent Butti <laurentb@gmail.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 912ce9dd2080c5837285a471d750fa311e09b555)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ],
          "candidate": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c": [
          "File: libavcodec/jpeg2000.c -> libavcodec/jpeg2000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:                                         reslevel->log2_prec_height) -",
          "273:                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);",
          "276:         if (!reslevel->band)",
          "277:             return AVERROR(ENOMEM);",
          "",
          "[Removed Lines]",
          "275:         reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));",
          "",
          "[Added Lines]",
          "275:         reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "368:             for (j = 0; j < 2; j++)",
          "369:                 band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);",
          "372:                                          (uint64_t)reslevel->num_precincts_y,",
          "373:                                          sizeof(*band->prec));",
          "374:             if (!band->prec)",
          "",
          "[Removed Lines]",
          "371:             band->prec = av_malloc_array(reslevel->num_precincts_x *",
          "",
          "[Added Lines]",
          "371:             band->prec = av_calloc(reslevel->num_precincts_x *",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "509:         for (bandno = 0; bandno < reslevel->nbands; bandno++) {",
          "510:             Jpeg2000Band *band = reslevel->band + bandno;",
          "511:             for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {",
          "516:             }",
          "518:             av_freep(&band->prec);",
          "",
          "[Removed Lines]",
          "512:                 Jpeg2000Prec *prec = band->prec + precno;",
          "513:                 av_freep(&prec->zerobits);",
          "514:                 av_freep(&prec->cblkincl);",
          "515:                 av_freep(&prec->cblk);",
          "",
          "[Added Lines]",
          "512:                 if (band->prec) {",
          "513:                     Jpeg2000Prec *prec = band->prec + precno;",
          "514:                     av_freep(&prec->zerobits);",
          "515:                     av_freep(&prec->cblkincl);",
          "516:                     av_freep(&prec->cblk);",
          "517:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9e477a37703318cb86d8ed1d426929235aa02b67",
      "candidate_info": {
        "commit_hash": "9e477a37703318cb86d8ed1d426929235aa02b67",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9e477a37703318cb86d8ed1d426929235aa02b67",
        "files": [
          "libavcodec/jpeg2000.c"
        ],
        "message": "jpeg2000: fix null pointer dereference in case of malloc failure\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ],
          "candidate": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c": [
          "File: libavcodec/jpeg2000.c -> libavcodec/jpeg2000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "507:         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;",
          "509:         for (bandno = 0; bandno < reslevel->nbands; bandno++) {",
          "517:                 }",
          "521:         }",
          "522:         av_freep(&reslevel->band);",
          "523:     }",
          "",
          "[Removed Lines]",
          "510:             Jpeg2000Band *band = reslevel->band + bandno;",
          "511:             for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {",
          "512:                 if (band->prec) {",
          "513:                     Jpeg2000Prec *prec = band->prec + precno;",
          "514:                     av_freep(&prec->zerobits);",
          "515:                     av_freep(&prec->cblkincl);",
          "516:                     av_freep(&prec->cblk);",
          "518:             }",
          "520:             av_freep(&band->prec);",
          "",
          "[Added Lines]",
          "510:             if (reslevel->band) {",
          "511:                 Jpeg2000Band *band = reslevel->band + bandno;",
          "512:                 for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {",
          "513:                     if (band->prec) {",
          "514:                         Jpeg2000Prec *prec = band->prec + precno;",
          "515:                         av_freep(&prec->zerobits);",
          "516:                         av_freep(&prec->cblkincl);",
          "517:                         av_freep(&prec->cblk);",
          "518:                     }",
          "521:                 av_freep(&band->prec);",
          "522:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c81a70638116eaf4251075475e5cbb600a33c5ec",
      "candidate_info": {
        "commit_hash": "c81a70638116eaf4251075475e5cbb600a33c5ec",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c81a70638116eaf4251075475e5cbb600a33c5ec",
        "files": [
          "Changelog",
          "doc/general.texi",
          "libavcodec/Makefile",
          "libavcodec/allcodecs.c",
          "libavcodec/avcodec.h",
          "libavcodec/jpeg2000.c",
          "libavcodec/jpeg2000.h",
          "libavcodec/jpeg2000dec.c",
          "libavcodec/jpeg2000dwt.c",
          "libavcodec/jpeg2000dwt.h",
          "libavcodec/mqc.c",
          "libavcodec/mqc.h",
          "libavcodec/mqcdec.c",
          "tests/fate/video.mak",
          "tests/ref/fate/jpeg2000-dcinema"
        ],
        "message": "JPEG 2000 decoder for DCinema\n\nBased on the 2007 GSoC project from Kamil Nowosad <k.nowosad@students.mimuw.edu.pl>\nUpdated to current programming standards, style and many more small\nfixes by Diego Biurrun <diego@biurrun.de>.\n\nSigned-off-by: Diego Biurrun <diego@biurrun.de>",
        "before_after_code_files": [
          "libavcodec/allcodecs.c||libavcodec/allcodecs.c",
          "libavcodec/avcodec.h||libavcodec/avcodec.h",
          "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c",
          "libavcodec/jpeg2000.h||libavcodec/jpeg2000.h",
          "libavcodec/jpeg2000dec.c||libavcodec/jpeg2000dec.c",
          "libavcodec/jpeg2000dwt.c||libavcodec/jpeg2000dwt.c",
          "libavcodec/jpeg2000dwt.h||libavcodec/jpeg2000dwt.h",
          "libavcodec/mqc.c||libavcodec/mqc.c",
          "libavcodec/mqc.h||libavcodec/mqc.h",
          "libavcodec/mqcdec.c||libavcodec/mqcdec.c",
          "tests/fate/video.mak||tests/fate/video.mak"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ],
          "candidate": [
            "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/allcodecs.c||libavcodec/allcodecs.c": [
          "File: libavcodec/allcodecs.c -> libavcodec/allcodecs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160:     REGISTER_DECODER(INDEO4,            indeo4);",
          "161:     REGISTER_DECODER(INDEO5,            indeo5);",
          "162:     REGISTER_DECODER(INTERPLAY_VIDEO,   interplay_video);",
          "163:     REGISTER_ENCDEC (JPEGLS,            jpegls);",
          "164:     REGISTER_DECODER(JV,                jv);",
          "165:     REGISTER_DECODER(KGV1,              kgv1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     REGISTER_DECODER(JPEG2000,          jpeg2000);",
          "",
          "---------------"
        ],
        "libavcodec/avcodec.h||libavcodec/avcodec.h": [
          "File: libavcodec/avcodec.h -> libavcodec/avcodec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2570: #define FF_PROFILE_MPEG4_SIMPLE_STUDIO             14",
          "2571: #define FF_PROFILE_MPEG4_ADVANCED_SIMPLE           15",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2573: #define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0   0",
          "2574: #define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1   1",
          "2575: #define FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION  2",
          "2576: #define FF_PROFILE_JPEG2000_DCINEMA_2K              3",
          "2577: #define FF_PROFILE_JPEG2000_DCINEMA_4K              4",
          "",
          "---------------"
        ],
        "libavcodec/jpeg2000.c||libavcodec/jpeg2000.c": [
          "File: libavcodec/jpeg2000.c -> libavcodec/jpeg2000.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/common.h\"",
          "29: #include \"libavutil/mem.h\"",
          "30: #include \"avcodec.h\"",
          "31: #include \"jpeg2000.h\"",
          "33: #define SHL(a, n) ((n) >= 0 ? (a) << (n) : (a) >> -(n))",
          "38: static int32_t tag_tree_size(uint16_t w, uint16_t h)",
          "39: {",
          "40:     uint32_t res = 0;",
          "41:     while (w > 1 || h > 1) {",
          "42:         res += w * h;",
          "43:         if (res + 1 >= INT32_MAX)",
          "44:             return -1;",
          "45:         w = (w + 1) >> 1;",
          "46:         h = (h + 1) >> 1;",
          "47:     }",
          "48:     return (int32_t)(res + 1);",
          "49: }",
          "51: static Jpeg2000TgtNode *ff_jpeg2000_tag_tree_init(int w, int h)",
          "52: {",
          "53:     int pw = w, ph = h;",
          "54:     Jpeg2000TgtNode *res, *t, *t2;",
          "55:     int32_t tt_size;",
          "57:     tt_size = tag_tree_size(w, h);",
          "58:     if (tt_size == -1)",
          "59:         return NULL;",
          "61:     t = res = av_mallocz_array(tt_size, sizeof(*t));",
          "62:     if (!res)",
          "63:         return NULL;",
          "65:     while (w > 1 || h > 1) {",
          "66:         int i, j;",
          "67:         pw = w;",
          "68:         ph = h;",
          "70:         w  = (w + 1) >> 1;",
          "71:         h  = (h + 1) >> 1;",
          "72:         t2 = t + pw * ph;",
          "74:         for (i = 0; i < ph; i++)",
          "75:             for (j = 0; j < pw; j++)",
          "76:                 t[i * pw + j].parent = &t2[(i >> 1) * w + (j >> 1)];",
          "78:         t = t2;",
          "79:     }",
          "80:     t[0].parent = NULL;",
          "81:     return res;",
          "82: }",
          "84: uint8_t ff_jpeg2000_sigctxno_lut[256][4];",
          "86: static int getsigctxno(int flag, int bandno)",
          "87: {",
          "88:     int h, v, d;",
          "90:     h = ((flag & JPEG2000_T1_SIG_E)  ? 1 : 0) +",
          "91:         ((flag & JPEG2000_T1_SIG_W)  ? 1 : 0);",
          "92:     v = ((flag & JPEG2000_T1_SIG_N)  ? 1 : 0) +",
          "93:         ((flag & JPEG2000_T1_SIG_S)  ? 1 : 0);",
          "94:     d = ((flag & JPEG2000_T1_SIG_NE) ? 1 : 0) +",
          "95:         ((flag & JPEG2000_T1_SIG_NW) ? 1 : 0) +",
          "96:         ((flag & JPEG2000_T1_SIG_SE) ? 1 : 0) +",
          "97:         ((flag & JPEG2000_T1_SIG_SW) ? 1 : 0);",
          "98:     if (bandno < 3) {",
          "99:         if (bandno == 1)",
          "100:             FFSWAP(int, h, v);",
          "101:         if (h == 2)",
          "102:             return 8;",
          "103:         if (h == 1) {",
          "104:             if (v >= 1)",
          "105:                 return 7;",
          "106:             if (d >= 1)",
          "107:                 return 6;",
          "108:             return 5;",
          "109:         }",
          "110:         if (v == 2)",
          "111:             return 4;",
          "112:         if (v == 1)",
          "113:             return 3;",
          "114:         if (d >= 2)",
          "115:             return 2;",
          "116:         if (d == 1)",
          "117:             return 1;",
          "118:         return 0;",
          "119:     } else {",
          "120:         if (d >= 3)",
          "121:             return 8;",
          "122:         if (d == 2) {",
          "123:             if (h + v >= 1)",
          "124:                 return 7;",
          "125:             return 6;",
          "126:         }",
          "127:         if (d == 1) {",
          "128:             if (h + v >= 2)",
          "129:                 return 5;",
          "130:             if (h + v == 1)",
          "131:                 return 4;",
          "132:             return 3;",
          "133:         }",
          "134:         if (h + v >= 2)",
          "135:             return 2;",
          "136:         if (h + v == 1)",
          "137:             return 1;",
          "138:         return 0;",
          "139:     }",
          "140:     return 0;",
          "141: }",
          "143: uint8_t ff_jpeg2000_sgnctxno_lut[16][16], ff_jpeg2000_xorbit_lut[16][16];",
          "145: static const int contribtab[3][3] = { {  0, -1,  1 }, { -1, -1,  0 }, {  1,  0,  1 } };",
          "146: static const int  ctxlbltab[3][3] = { { 13, 12, 11 }, { 10,  9, 10 }, { 11, 12, 13 } };",
          "147: static const int  xorbittab[3][3] = { {  1,  1,  1 }, {  1,  0,  0 }, {  0,  0,  0 } };",
          "149: static int getsgnctxno(int flag, uint8_t *xorbit)",
          "150: {",
          "151:     int vcontrib, hcontrib;",
          "153:     hcontrib = contribtab[flag & JPEG2000_T1_SIG_E ? flag & JPEG2000_T1_SGN_E ? 1 : 2 : 0]",
          "154:                          [flag & JPEG2000_T1_SIG_W ? flag & JPEG2000_T1_SGN_W ? 1 : 2 : 0] + 1;",
          "155:     vcontrib = contribtab[flag & JPEG2000_T1_SIG_S ? flag & JPEG2000_T1_SGN_S ? 1 : 2 : 0]",
          "156:                          [flag & JPEG2000_T1_SIG_N ? flag & JPEG2000_T1_SGN_N ? 1 : 2 : 0] + 1;",
          "159:     return ctxlbltab[hcontrib][vcontrib];",
          "160: }",
          "162: void ff_jpeg2000_init_tier1_luts(void)",
          "163: {",
          "164:     int i, j;",
          "165:     for (i = 0; i < 256; i++)",
          "166:         for (j = 0; j < 4; j++)",
          "167:             ff_jpeg2000_sigctxno_lut[i][j] = getsigctxno(i, j);",
          "168:     for (i = 0; i < 16; i++)",
          "169:         for (j = 0; j < 16; j++)",
          "170:             ff_jpeg2000_sgnctxno_lut[i][j] =",
          "171:                 getsgnctxno(i + (j << 8), &ff_jpeg2000_xorbit_lut[i][j]);",
          "172: }",
          "174: void ff_jpeg2000_set_significance(Jpeg2000T1Context *t1, int x, int y,",
          "175:                                   int negative)",
          "176: {",
          "177:     x++;",
          "178:     y++;",
          "179:     t1->flags[y][x] |= JPEG2000_T1_SIG;",
          "180:     if (negative) {",
          "181:         t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W | JPEG2000_T1_SGN_W;",
          "182:         t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E | JPEG2000_T1_SGN_E;",
          "183:         t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N | JPEG2000_T1_SGN_N;",
          "184:         t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S | JPEG2000_T1_SGN_S;",
          "185:     } else {",
          "186:         t1->flags[y][x + 1] |= JPEG2000_T1_SIG_W;",
          "187:         t1->flags[y][x - 1] |= JPEG2000_T1_SIG_E;",
          "188:         t1->flags[y + 1][x] |= JPEG2000_T1_SIG_N;",
          "189:         t1->flags[y - 1][x] |= JPEG2000_T1_SIG_S;",
          "190:     }",
          "191:     t1->flags[y + 1][x + 1] |= JPEG2000_T1_SIG_NW;",
          "192:     t1->flags[y + 1][x - 1] |= JPEG2000_T1_SIG_NE;",
          "193:     t1->flags[y - 1][x + 1] |= JPEG2000_T1_SIG_SW;",
          "194:     t1->flags[y - 1][x - 1] |= JPEG2000_T1_SIG_SE;",
          "195: }",
          "197: static const uint8_t lut_gain[2][4] = { { 0, 0, 0, 0 }, { 0, 1, 1, 2 } };",
          "199: int ff_jpeg2000_init_component(Jpeg2000Component *comp,",
          "200:                                Jpeg2000CodingStyle *codsty,",
          "201:                                Jpeg2000QuantStyle *qntsty,",
          "202:                                int cbps, int dx, int dy,",
          "203:                                AVCodecContext *avctx)",
          "204: {",
          "205:     uint8_t log2_band_prec_width, log2_band_prec_height;",
          "206:     int reslevelno, bandno, gbandno = 0, ret, i, j;",
          "207:     uint32_t csize = 1;",
          "209:     if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,",
          "210:                                    codsty->nreslevels2decode - 1,",
          "211:                                    codsty->transform))",
          "212:         return ret;",
          "214:     csize = (comp->coord[0][1] - comp->coord[0][0]) *",
          "215:             (comp->coord[1][1] - comp->coord[1][0]);",
          "217:     comp->data = av_malloc_array(csize, sizeof(*comp->data));",
          "218:     if (!comp->data)",
          "219:         return AVERROR(ENOMEM);",
          "220:     comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));",
          "221:     if (!comp->reslevel)",
          "222:         return AVERROR(ENOMEM);",
          "224:     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {",
          "225:         int declvl = codsty->nreslevels - reslevelno;    // N_L -r see  ISO/IEC 15444-1:2002 B.5",
          "226:         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;",
          "231:         for (i = 0; i < 2; i++)",
          "232:             for (j = 0; j < 2; j++)",
          "233:                 reslevel->coord[i][j] =",
          "234:                     ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);",
          "236:         reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];",
          "237:         reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];",
          "240:         if (reslevelno == 0)",
          "241:             reslevel->nbands = 1;",
          "242:         else",
          "243:             reslevel->nbands = 3;",
          "252:         if (reslevel->coord[0][1] == reslevel->coord[0][0])",
          "253:             reslevel->num_precincts_x = 0;",
          "254:         else",
          "255:             reslevel->num_precincts_x =",
          "256:                 ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],",
          "257:                                         reslevel->log2_prec_width) -",
          "258:                 (reslevel->coord[0][0] >> reslevel->log2_prec_width);",
          "260:         if (reslevel->coord[1][1] == reslevel->coord[1][0])",
          "261:             reslevel->num_precincts_y = 0;",
          "262:         else",
          "263:             reslevel->num_precincts_y =",
          "264:                 ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],",
          "265:                                         reslevel->log2_prec_height) -",
          "266:                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);",
          "268:         reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));",
          "269:         if (!reslevel->band)",
          "270:             return AVERROR(ENOMEM);",
          "272:         for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {",
          "273:             Jpeg2000Band *band = reslevel->band + bandno;",
          "274:             int cblkno, precno;",
          "275:             int nb_precincts;",
          "279:             switch (qntsty->quantsty) {",
          "280:                 uint8_t gain;",
          "281:                 int numbps;",
          "282:             case JPEG2000_QSTY_NONE:",
          "284:                 numbps = cbps +",
          "285:                          lut_gain[codsty->transform][bandno + reslevelno > 0];",
          "286:                 band->stepsize = (float)SHL(2048 + qntsty->mant[gbandno],",
          "287:                                             2 + numbps - qntsty->expn[gbandno]);",
          "288:                 break;",
          "289:             case JPEG2000_QSTY_SI:",
          "291:                 band->stepsize = (float) (1 << 13);",
          "292:                 break;",
          "293:             case JPEG2000_QSTY_SE:",
          "302:                 gain            = cbps;",
          "303:                 band->stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);",
          "304:                 band->stepsize *= (float)qntsty->mant[gbandno] / 2048.0 + 1.0;",
          "307:                 band->stepsize *= 0.5;",
          "308:                 break;",
          "309:             default:",
          "310:                 band->stepsize = 0;",
          "311:                 av_log(avctx, AV_LOG_ERROR, \"Unknown quantization format\\n\");",
          "312:                 break;",
          "313:             }",
          "315:             if (avctx->flags & CODEC_FLAG_BITEXACT)",
          "316:                 band->stepsize = (int32_t)(band->stepsize * (1 << 16));",
          "322:             if (reslevelno == 0) {",
          "324:                 for (i = 0; i < 2; i++)",
          "325:                     for (j = 0; j < 2; j++)",
          "326:                         band->coord[i][j] =",
          "327:                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j],",
          "328:                                                     declvl - 1);",
          "330:                 log2_band_prec_width  = reslevel->log2_prec_width;",
          "331:                 log2_band_prec_height = reslevel->log2_prec_height;",
          "333:                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,",
          "334:                                                reslevel->log2_prec_width);",
          "335:                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,",
          "336:                                                reslevel->log2_prec_height);",
          "337:             } else {",
          "340:                 for (i = 0; i < 2; i++)",
          "341:                     for (j = 0; j < 2; j++)",
          "343:                         band->coord[i][j] =",
          "344:                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] -",
          "345:                                                     (((bandno + 1 >> i) & 1) << declvl - 1),",
          "346:                                                     declvl);",
          "351:                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,",
          "352:                                                reslevel->log2_prec_width - 1);",
          "353:                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,",
          "354:                                                reslevel->log2_prec_height - 1);",
          "356:                 log2_band_prec_width  = reslevel->log2_prec_width  - 1;",
          "357:                 log2_band_prec_height = reslevel->log2_prec_height - 1;",
          "358:             }",
          "360:             band->prec = av_malloc_array(reslevel->num_precincts_x *",
          "361:                                          reslevel->num_precincts_y,",
          "362:                                          sizeof(*band->prec));",
          "363:             if (!band->prec)",
          "364:                 return AVERROR(ENOMEM);",
          "366:             nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;",
          "368:             for (precno = 0; precno < nb_precincts; precno++) {",
          "369:                 Jpeg2000Prec *prec = band->prec + precno;",
          "375:                 prec->coord[0][0] = (precno % reslevel->num_precincts_x) *",
          "376:                                     (1 << log2_band_prec_width);",
          "377:                 prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);",
          "380:                 prec->coord[1][0] = (precno / reslevel->num_precincts_x) *",
          "381:                                     (1 << log2_band_prec_height);",
          "382:                 prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);",
          "385:                 prec->coord[0][1] = prec->coord[0][0] +",
          "386:                                     (1 << log2_band_prec_width);",
          "387:                 prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);",
          "390:                 prec->coord[1][1] = prec->coord[1][0] +",
          "391:                                     (1 << log2_band_prec_height);",
          "392:                 prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);",
          "394:                 prec->nb_codeblocks_width =",
          "395:                     ff_jpeg2000_ceildivpow2(prec->coord[0][1] -",
          "396:                                             prec->coord[0][0],",
          "397:                                             band->log2_cblk_width);",
          "398:                 prec->nb_codeblocks_height =",
          "399:                     ff_jpeg2000_ceildivpow2(prec->coord[1][1] -",
          "400:                                             prec->coord[1][0],",
          "401:                                             band->log2_cblk_height);",
          "404:                 prec->cblkincl =",
          "405:                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,",
          "406:                                               prec->nb_codeblocks_height);",
          "407:                 if (!prec->cblkincl)",
          "408:                     return AVERROR(ENOMEM);",
          "410:                 prec->zerobits =",
          "411:                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,",
          "412:                                               prec->nb_codeblocks_height);",
          "413:                 if (!prec->zerobits)",
          "414:                     return AVERROR(ENOMEM);",
          "416:                 prec->cblk = av_malloc_array(prec->nb_codeblocks_width *",
          "417:                                              prec->nb_codeblocks_height,",
          "418:                                              sizeof(*prec->cblk));",
          "419:                 if (!prec->cblk)",
          "420:                     return AVERROR(ENOMEM);",
          "421:                 for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {",
          "422:                     Jpeg2000Cblk *cblk = prec->cblk + cblkno;",
          "423:                     uint16_t Cx0, Cy0;",
          "427:                     Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;",
          "428:                     Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);",
          "429:                     cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);",
          "432:                     Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;",
          "433:                     Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);",
          "434:                     cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);",
          "437:                     cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),",
          "438:                                               prec->coord[0][1]);",
          "441:                     cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),",
          "442:                                               prec->coord[1][1]);",
          "443:                     cblk->zero      = 0;",
          "444:                     cblk->lblock    = 3;",
          "445:                     cblk->length    = 0;",
          "446:                     cblk->lengthinc = 0;",
          "447:                     cblk->npasses   = 0;",
          "448:                 }",
          "449:             }",
          "450:         }",
          "451:     }",
          "452:     return 0;",
          "453: }",
          "455: void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)",
          "456: {",
          "457:     int reslevelno, bandno, precno;",
          "458:     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {",
          "459:         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;",
          "461:         for (bandno = 0; bandno < reslevel->nbands; bandno++) {",
          "462:             Jpeg2000Band *band = reslevel->band + bandno;",
          "463:             for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {",
          "464:                 Jpeg2000Prec *prec = band->prec + precno;",
          "465:                 av_freep(&prec->zerobits);",
          "466:                 av_freep(&prec->cblkincl);",
          "467:                 av_freep(&prec->cblk);",
          "468:             }",
          "470:             av_freep(&band->prec);",
          "471:         }",
          "472:         av_freep(&reslevel->band);",
          "473:     }",
          "475:     ff_dwt_destroy(&comp->dwt);",
          "476:     av_freep(&comp->reslevel);",
          "477:     av_freep(&comp->data);",
          "478: }",
          "",
          "---------------"
        ],
        "libavcodec/jpeg2000.h||libavcodec/jpeg2000.h": [
          "File: libavcodec/jpeg2000.h -> libavcodec/jpeg2000.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #ifndef AVCODEC_JPEG2000_H",
          "24: #define AVCODEC_JPEG2000_H",
          "32: #include <stdint.h>",
          "34: #include \"avcodec.h\"",
          "35: #include \"mqc.h\"",
          "36: #include \"jpeg2000dwt.h\"",
          "38: enum Jpeg2000Markers {",
          "39:     JPEG2000_SOC = 0xff4f, // start of codestream",
          "40:     JPEG2000_SIZ = 0xff51, // image and tile size",
          "41:     JPEG2000_COD,          // coding style default",
          "42:     JPEG2000_COC,          // coding style component",
          "43:     JPEG2000_TLM = 0xff55, // packed packet headers, tile-part header",
          "44:     JPEG2000_PLM = 0xff57, // tile-part lengths",
          "45:     JPEG2000_PLT,          // packet length, main header",
          "46:     JPEG2000_QCD = 0xff5c, // quantization default",
          "47:     JPEG2000_QCC,          // quantization component",
          "48:     JPEG2000_RGN,          // region of interest",
          "49:     JPEG2000_POC,          // progression order change",
          "50:     JPEG2000_PPM,          // packet length, tile-part header",
          "51:     JPEG2000_PPT,          // packed packet headers, main header",
          "52:     JPEG2000_CRG = 0xff63, // component registration",
          "53:     JPEG2000_COM,          // comment",
          "54:     JPEG2000_SOT = 0xff90, // start of tile-part",
          "55:     JPEG2000_SOP,          // start of packet",
          "56:     JPEG2000_EPH,          // end of packet header",
          "57:     JPEG2000_SOD,          // start of data",
          "58:     JPEG2000_EOC = 0xffd9, // end of codestream",
          "59: };",
          "61: enum Jpeg2000Quantsty { // quantization style",
          "62:     JPEG2000_QSTY_NONE, // no quantization",
          "63:     JPEG2000_QSTY_SI,   // scalar derived",
          "64:     JPEG2000_QSTY_SE    // scalar expounded",
          "65: };",
          "67: #define JPEG2000_MAX_CBLKW 64",
          "68: #define JPEG2000_MAX_CBLKH 64",
          "70: #define JPEG2000_MAX_RESLEVELS 33",
          "74: #define JPEG2000_T1_SIG_N  0x0001",
          "75: #define JPEG2000_T1_SIG_E  0x0002",
          "76: #define JPEG2000_T1_SIG_W  0x0004",
          "77: #define JPEG2000_T1_SIG_S  0x0008",
          "78: #define JPEG2000_T1_SIG_NE 0x0010",
          "79: #define JPEG2000_T1_SIG_NW 0x0020",
          "80: #define JPEG2000_T1_SIG_SE 0x0040",
          "81: #define JPEG2000_T1_SIG_SW 0x0080",
          "82: #define JPEG2000_T1_SIG_NB (JPEG2000_T1_SIG_N  | JPEG2000_T1_SIG_E  |   \\",
          "83:                             JPEG2000_T1_SIG_S  | JPEG2000_T1_SIG_W  |   \\",
          "84:                             JPEG2000_T1_SIG_NE | JPEG2000_T1_SIG_NW |   \\",
          "85:                             JPEG2000_T1_SIG_SE | JPEG2000_T1_SIG_SW)",
          "87: #define JPEG2000_T1_SGN_N  0x0100",
          "88: #define JPEG2000_T1_SGN_S  0x0200",
          "89: #define JPEG2000_T1_SGN_W  0x0400",
          "90: #define JPEG2000_T1_SGN_E  0x0800",
          "92: #define JPEG2000_T1_VIS    0x1000",
          "93: #define JPEG2000_T1_SIG    0x2000",
          "94: #define JPEG2000_T1_REF    0x4000",
          "96: #define JPEG2000_T1_SGN    0x8000",
          "99: #define JPEG2000_CBLK_BYPASS    0x01 // Selective arithmetic coding bypass",
          "100: #define JPEG2000_CBLK_RESET     0x02 // Reset context probabilities",
          "101: #define JPEG2000_CBLK_TERMALL   0x04 // Terminate after each coding pass",
          "102: #define JPEG2000_CBLK_VSC       0x08 // Vertical stripe causal context formation",
          "103: #define JPEG2000_CBLK_PREDTERM  0x10 // Predictable termination",
          "104: #define JPEG2000_CBLK_SEGSYM    0x20 // Segmentation symbols present",
          "107: #define JPEG2000_CSTY_PREC      0x01 // Precincts defined in coding style",
          "108: #define JPEG2000_CSTY_SOP       0x02 // SOP marker present",
          "109: #define JPEG2000_CSTY_EPH       0x04 // EPH marker present",
          "112: #define JPEG2000_PGOD_LRCP      0x00  // Layer-resolution level-component-position progression",
          "113: #define JPEG2000_PGOD_RLCP      0x01  // Resolution level-layer-component-position progression",
          "114: #define JPEG2000_PGOD_RPCL      0x02  // Resolution level-position-component-layer progression",
          "115: #define JPEG2000_PGOD_PCRL      0x03  // Position-component-resolution level-layer progression",
          "116: #define JPEG2000_PGOD_CPRL      0x04  // Component-position-resolution level-layer progression",
          "118: typedef struct Jpeg2000T1Context {",
          "119:     int data[JPEG2000_MAX_CBLKW][JPEG2000_MAX_CBLKH];",
          "120:     int flags[JPEG2000_MAX_CBLKW + 2][JPEG2000_MAX_CBLKH + 2];",
          "121:     MqcState mqc;",
          "122: } Jpeg2000T1Context;",
          "124: typedef struct Jpeg2000TgtNode {",
          "125:     uint8_t val;",
          "126:     uint8_t vis;",
          "127:     struct Jpeg2000TgtNode *parent;",
          "128: } Jpeg2000TgtNode;",
          "130: typedef struct Jpeg2000CodingStyle {",
          "131:     uint8_t nreslevels;       // number of resolution levels",
          "132:     uint8_t nreslevels2decode; // number of resolution levels to decode",
          "133:     uint8_t log2_cblk_width,",
          "134:             log2_cblk_height; // exponent of codeblock size",
          "135:     uint8_t transform;        // DWT type",
          "136:     uint8_t csty;             // coding style",
          "137:     uint8_t log2_prec_width,",
          "138:             log2_prec_height; // precinct size",
          "139:     uint8_t nlayers;          // number of layers",
          "140:     uint8_t mct;              // multiple component transformation",
          "141:     uint8_t cblk_style;       // codeblock coding style",
          "142:     uint8_t prog_order;       // progression order",
          "143:     uint8_t log2_prec_widths[JPEG2000_MAX_RESLEVELS];  // precincts size according resolution levels",
          "144:     uint8_t log2_prec_heights[JPEG2000_MAX_RESLEVELS]; // TODO: initialize prec_size array with 0?",
          "145: } Jpeg2000CodingStyle;",
          "147: typedef struct Jpeg2000QuantStyle {",
          "148:     uint8_t expn[32 * 3];  // quantization exponent",
          "149:     uint32_t mant[32 * 3]; // quantization mantissa",
          "150:     uint8_t quantsty;      // quantization style",
          "151:     uint8_t nguardbits;    // number of guard bits",
          "152: } Jpeg2000QuantStyle;",
          "154: typedef struct Jpeg2000Pass {",
          "155:     uint16_t rate;",
          "156:     int64_t disto;",
          "157: } Jpeg2000Pass;",
          "159: typedef struct Jpeg2000Cblk {",
          "160:     uint8_t npasses;",
          "161:     uint8_t ninclpasses; // number coding of passes included in codestream",
          "162:     uint8_t nonzerobits;",
          "163:     uint16_t length;",
          "164:     uint16_t lengthinc;",
          "165:     uint8_t lblock;",
          "166:     uint8_t zero;",
          "167:     uint8_t data[8192];",
          "168:     Jpeg2000Pass passes[100];",
          "169:     uint16_t coord[2][2]; // border coordinates {{x0, x1}, {y0, y1}}",
          "170: } Jpeg2000Cblk; // code block",
          "172: typedef struct Jpeg2000Prec {",
          "173:     uint16_t xi0, yi0; // codeblock indexes ([xi0, xi1))",
          "174:     uint16_t nb_codeblocks_width;",
          "175:     uint16_t nb_codeblocks_height;",
          "176:     Jpeg2000TgtNode *zerobits;",
          "177:     Jpeg2000TgtNode *cblkincl;",
          "178:     Jpeg2000Cblk *cblk;",
          "179:     uint16_t coord[2][2]; // border coordinates {{x0, x1}, {y0, y1}}",
          "180: } Jpeg2000Prec; // precinct",
          "184: typedef struct Jpeg2000Band {",
          "185:     uint16_t coord[2][2]; // border coordinates {{x0, x1}, {y0, y1}}",
          "186:     uint16_t log2_cblk_width, log2_cblk_height;",
          "187:     uint16_t cblknx, cblkny;",
          "188:     float stepsize; // quantization stepsize",
          "189:     Jpeg2000Prec *prec;",
          "190: } Jpeg2000Band; // subband",
          "192: typedef struct Jpeg2000ResLevel {",
          "193:     uint8_t nbands;",
          "194:     uint16_t coord[2][2]; // border coordinates {{x0, x1}, {y0, y1}}",
          "195:     uint16_t num_precincts_x, num_precincts_y; // number of precincts in x/y direction",
          "196:     uint8_t log2_prec_width, log2_prec_height; // exponent of precinct size",
          "197:     Jpeg2000Band *band;",
          "198: } Jpeg2000ResLevel; // resolution level",
          "203: typedef struct Jpeg2000Component {",
          "204:     Jpeg2000ResLevel *reslevel;",
          "205:     DWTContext dwt;",
          "206:     float *data;",
          "207:     uint16_t coord[2][2];   // border coordinates {{x0, x1}, {y0, y1}} -- can be reduced with lowres option",
          "208:     uint16_t coord_o[2][2]; // border coordinates {{x0, x1}, {y0, y1}} -- original values from jpeg2000 headers",
          "209: } Jpeg2000Component;",
          "212: static inline int ff_jpeg2000_ceildivpow2(int a, int b)",
          "213: {",
          "214:     return (a + (1 << b) - 1) >> b;",
          "215: }",
          "217: static inline int ff_jpeg2000_ceildiv(int a, int b)",
          "218: {",
          "219:     return (a + b - 1) / b;",
          "220: }",
          "225: void ff_jpeg2000_init_tier1_luts(void);",
          "229: void ff_jpeg2000_set_significance(Jpeg2000T1Context *t1,",
          "230:                                   int x, int y, int negative);",
          "232: extern uint8_t ff_jpeg2000_sigctxno_lut[256][4];",
          "236: static inline int ff_jpeg2000_getsigctxno(int flag, int bandno)",
          "237: {",
          "238:     return ff_jpeg2000_sigctxno_lut[flag & 255][bandno];",
          "239: }",
          "241: static const uint8_t refctxno_lut[2][2] = { { 14, 15 }, { 16, 16 } };",
          "245: static inline int ff_jpeg2000_getrefctxno(int flag)",
          "246: {",
          "247:     return refctxno_lut[(flag >> 14) & 1][(flag & 255) != 0];",
          "248: }",
          "250: extern uint8_t ff_jpeg2000_sgnctxno_lut[16][16];",
          "251: extern uint8_t ff_jpeg2000_xorbit_lut[16][16];",
          "254: static inline int ff_jpeg2000_getsgnctxno(int flag, int *xorbit)",
          "255: {",
          "257:     return ff_jpeg2000_sgnctxno_lut[flag & 15][(flag >> 8) & 15];",
          "258: }",
          "260: int ff_jpeg2000_init_component(Jpeg2000Component *comp,",
          "261:                                Jpeg2000CodingStyle *codsty,",
          "262:                                Jpeg2000QuantStyle *qntsty,",
          "263:                                int cbps, int dx, int dy,",
          "264:                                AVCodecContext *ctx);",
          "266: void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty);",
          "",
          "---------------"
        ],
        "libavcodec/jpeg2000dec.c||libavcodec/jpeg2000dec.c": [
          "File: libavcodec/jpeg2000dec.c -> libavcodec/jpeg2000dec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/common.h\"",
          "29: #include \"libavutil/opt.h\"",
          "30: #include \"avcodec.h\"",
          "31: #include \"bytestream.h\"",
          "32: #include \"internal.h\"",
          "33: #include \"jpeg2000.h\"",
          "35: #define JP2_SIG_TYPE    0x6A502020",
          "36: #define JP2_SIG_VALUE   0x0D0A870A",
          "37: #define JP2_CODESTREAM  0x6A703263",
          "39: #define HAD_COC 0x01",
          "40: #define HAD_QCC 0x02",
          "42: typedef struct Jpeg2000TilePart {",
          "43:     uint16_t tp_idx;                    // Tile-part index",
          "44:     uint8_t tile_index;                 // Tile index who refers the tile-part",
          "45:     uint32_t tp_len;                    // Length of tile-part",
          "46:     const uint8_t *tp_start_bstrm;      // Start address bit stream in tile-part",
          "47:     const uint8_t *tp_end_bstrm;        // End address of the bit stream tile part",
          "48: } Jpeg2000TilePart;",
          "52: typedef struct Jpeg2000Tile {",
          "53:     Jpeg2000Component   *comp;",
          "54:     uint8_t             properties[4];",
          "55:     Jpeg2000CodingStyle codsty[4];",
          "56:     Jpeg2000QuantStyle  qntsty[4];",
          "57:     Jpeg2000TilePart    tile_part[3];",
          "58: } Jpeg2000Tile;",
          "60: typedef struct Jpeg2000DecoderContext {",
          "61:     AVClass         *class;",
          "62:     AVCodecContext  *avctx;",
          "64:     int             width, height;",
          "65:     int             image_offset_x, image_offset_y;",
          "66:     int             tile_offset_x, tile_offset_y;",
          "67:     uint8_t         cbps[4];    // bits per sample in particular components",
          "68:     uint8_t         sgnd[4];    // if a component is signed",
          "69:     uint8_t         properties[4];",
          "70:     int             cdx[4], cdy[4];",
          "71:     int             precision;",
          "72:     int             ncomponents;",
          "73:     int             tile_width, tile_height;",
          "74:     int             numXtiles, numYtiles;",
          "75:     int             maxtilelen;",
          "77:     Jpeg2000CodingStyle codsty[4];",
          "78:     Jpeg2000QuantStyle  qntsty[4];",
          "80:     const uint8_t   *buf_start;",
          "81:     const uint8_t   *buf;",
          "82:     const uint8_t   *buf_end;",
          "83:     int             bit_index;",
          "85:     int16_t         curtileno;",
          "86:     Jpeg2000Tile    *tile;",
          "89:     int16_t         lowres;",
          "90:     int16_t         reduction_factor;",
          "91: } Jpeg2000DecoderContext;",
          "97: static int get_bits(Jpeg2000DecoderContext *s, int n)",
          "98: {",
          "99:     int res = 0;",
          "100:     if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))",
          "101:         return AVERROR(EINVAL);",
          "102:     while (--n >= 0) {",
          "103:         res <<= 1;",
          "104:         if (s->bit_index == 0) {",
          "105:             s->bit_index = 7 + (*s->buf != 0xff);",
          "106:             s->buf++;",
          "107:         }",
          "108:         s->bit_index--;",
          "109:         res |= (*s->buf >> s->bit_index) & 1;",
          "110:     }",
          "111:     return res;",
          "112: }",
          "114: static void jpeg2000_flush(Jpeg2000DecoderContext *s)",
          "115: {",
          "116:     if (*s->buf == 0xff)",
          "117:         s->buf++;",
          "118:     s->bit_index = 8;",
          "119:     s->buf++;",
          "120: }",
          "123: static int tag_tree_decode(Jpeg2000DecoderContext *s, Jpeg2000TgtNode *node,",
          "124:                            int threshold)",
          "125: {",
          "126:     Jpeg2000TgtNode *stack[30];",
          "127:     int sp = -1, curval = 0;",
          "129:     while (node && !node->vis) {",
          "130:         stack[++sp] = node;",
          "131:         node        = node->parent;",
          "132:     }",
          "134:     if (node)",
          "135:         curval = node->val;",
          "136:     else",
          "137:         curval = stack[sp]->val;",
          "139:     while (curval < threshold && sp >= 0) {",
          "140:         if (curval < stack[sp]->val)",
          "141:             curval = stack[sp]->val;",
          "142:         while (curval < threshold) {",
          "143:             int ret;",
          "144:             if ((ret = get_bits(s, 1)) > 0) {",
          "145:                 stack[sp]->vis++;",
          "146:                 break;",
          "147:             } else if (!ret)",
          "148:                 curval++;",
          "149:             else",
          "150:                 return ret;",
          "151:         }",
          "152:         stack[sp]->val = curval;",
          "153:         sp--;",
          "154:     }",
          "155:     return curval;",
          "156: }",
          "160: static int get_siz(Jpeg2000DecoderContext *s)",
          "161: {",
          "162:     int i;",
          "164:     if (s->buf_end - s->buf < 36)",
          "165:         return AVERROR(EINVAL);",
          "167:     s->avctx->profile = bytestream_get_be16(&s->buf); // Rsiz",
          "168:     s->width          = bytestream_get_be32(&s->buf); // Width",
          "169:     s->height         = bytestream_get_be32(&s->buf); // Height",
          "170:     s->image_offset_x = bytestream_get_be32(&s->buf); // X0Siz",
          "171:     s->image_offset_y = bytestream_get_be32(&s->buf); // Y0Siz",
          "172:     s->tile_width     = bytestream_get_be32(&s->buf); // XTSiz",
          "173:     s->tile_height    = bytestream_get_be32(&s->buf); // YTSiz",
          "174:     s->tile_offset_x  = bytestream_get_be32(&s->buf); // XT0Siz",
          "175:     s->tile_offset_y  = bytestream_get_be32(&s->buf); // YT0Siz",
          "176:     s->ncomponents    = bytestream_get_be16(&s->buf); // CSiz",
          "178:     if (s->buf_end - s->buf < 2 * s->ncomponents)",
          "179:         return AVERROR(EINVAL);",
          "181:     for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i",
          "182:         uint8_t x = bytestream_get_byte(&s->buf);",
          "183:         s->cbps[i]   = (x & 0x7f) + 1;",
          "184:         s->precision = FFMAX(s->cbps[i], s->precision);",
          "185:         s->sgnd[i]   = (x & 0x80) == 1;",
          "186:         s->cdx[i]    = bytestream_get_byte(&s->buf);",
          "187:         s->cdy[i]    = bytestream_get_byte(&s->buf);",
          "188:     }",
          "190:     s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);",
          "191:     s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);",
          "193:     s->tile = av_mallocz(s->numXtiles * s->numYtiles * sizeof(*s->tile));",
          "194:     if (!s->tile)",
          "195:         return AVERROR(ENOMEM);",
          "197:     for (i = 0; i < s->numXtiles * s->numYtiles; i++) {",
          "198:         Jpeg2000Tile *tile = s->tile + i;",
          "200:         tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));",
          "201:         if (!tile->comp)",
          "202:             return AVERROR(ENOMEM);",
          "203:     }",
          "206:     s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,",
          "207:                                                s->reduction_factor);",
          "208:     s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,",
          "209:                                                s->reduction_factor);",
          "211:     switch (s->avctx->profile) {",
          "212:     case FF_PROFILE_JPEG2000_DCINEMA_2K:",
          "213:     case FF_PROFILE_JPEG2000_DCINEMA_4K:",
          "215:         s->avctx->pix_fmt = AV_PIX_FMT_XYZ12LE;",
          "216:         break;",
          "217:     default:",
          "220:         switch (s->ncomponents) {",
          "221:         case 1:",
          "222:             if (s->precision > 8)",
          "223:                 s->avctx->pix_fmt = AV_PIX_FMT_GRAY16;",
          "224:             else",
          "225:                 s->avctx->pix_fmt = AV_PIX_FMT_GRAY8;",
          "226:             break;",
          "227:         case 3:",
          "228:             if (s->precision > 8)",
          "229:                 s->avctx->pix_fmt = AV_PIX_FMT_RGB48;",
          "230:             else",
          "231:                 s->avctx->pix_fmt = AV_PIX_FMT_RGB24;",
          "232:             break;",
          "233:         case 4:",
          "234:             s->avctx->pix_fmt = AV_PIX_FMT_BGRA;",
          "235:             break;",
          "236:         default:",
          "238:             s->avctx->pix_fmt = AV_PIX_FMT_NONE;",
          "239:             break;",
          "240:         }",
          "241:         break;",
          "242:     }",
          "243:     return 0;",
          "244: }",
          "247: static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)",
          "248: {",
          "249:     uint8_t byte;",
          "251:     if (s->buf_end - s->buf < 5)",
          "252:         return AVERROR(EINVAL);",
          "253:     c->nreslevels = bytestream_get_byte(&s->buf) + 1; // num of resolution levels - 1",
          "256:     if (c->nreslevels < s->reduction_factor)",
          "257:         c->nreslevels2decode = 1;",
          "258:     else",
          "259:         c->nreslevels2decode = c->nreslevels - s->reduction_factor;",
          "261:     c->log2_cblk_width  = bytestream_get_byte(&s->buf) + 2; // cblk width",
          "262:     c->log2_cblk_height = bytestream_get_byte(&s->buf) + 2; // cblk height",
          "264:     c->cblk_style = bytestream_get_byte(&s->buf);",
          "265:     if (c->cblk_style != 0) { // cblk style",
          "266:         av_log(s->avctx, AV_LOG_ERROR, \"no extra cblk styles supported\\n\");",
          "267:         return -1;",
          "268:     }",
          "269:     c->transform = bytestream_get_byte(&s->buf); // DWT transformation type",
          "271:     if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))",
          "272:         c->transform = FF_DWT97_INT;",
          "274:     if (c->csty & JPEG2000_CSTY_PREC) {",
          "275:         int i;",
          "276:         for (i = 0; i < c->nreslevels; i++) {",
          "277:             byte = bytestream_get_byte(&s->buf);",
          "278:             c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx",
          "279:             c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy",
          "280:         }",
          "281:     }",
          "282:     return 0;",
          "283: }",
          "286: static int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,",
          "287:                    uint8_t *properties)",
          "288: {",
          "289:     Jpeg2000CodingStyle tmp;",
          "290:     int compno;",
          "292:     if (s->buf_end - s->buf < 5)",
          "293:         return AVERROR(EINVAL);",
          "295:     tmp.log2_prec_width  =",
          "296:     tmp.log2_prec_height = 15;",
          "298:     tmp.csty = bytestream_get_byte(&s->buf);",
          "301:     tmp.prog_order = bytestream_get_byte(&s->buf);",
          "303:     tmp.nlayers = bytestream_get_be16(&s->buf);",
          "304:     tmp.mct     = bytestream_get_byte(&s->buf); // multiple component transformation",
          "306:     get_cox(s, &tmp);",
          "307:     for (compno = 0; compno < s->ncomponents; compno++)",
          "308:         if (!(properties[compno] & HAD_COC))",
          "309:             memcpy(c + compno, &tmp, sizeof(tmp));",
          "310:     return 0;",
          "311: }",
          "315: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,",
          "316:                    uint8_t *properties)",
          "317: {",
          "318:     int compno;",
          "320:     if (s->buf_end - s->buf < 2)",
          "321:         return AVERROR(EINVAL);",
          "323:     compno = bytestream_get_byte(&s->buf);",
          "325:     c      += compno;",
          "326:     c->csty = bytestream_get_byte(&s->buf);",
          "327:     get_cox(s, c);",
          "329:     properties[compno] |= HAD_COC;",
          "330:     return 0;",
          "331: }",
          "334: static int get_qcx(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q)",
          "335: {",
          "336:     int i, x;",
          "338:     if (s->buf_end - s->buf < 1)",
          "339:         return AVERROR(EINVAL);",
          "341:     x = bytestream_get_byte(&s->buf); // Sqcd",
          "343:     q->nguardbits = x >> 5;",
          "344:     q->quantsty   = x & 0x1f;",
          "346:     if (q->quantsty == JPEG2000_QSTY_NONE) {",
          "347:         n -= 3;",
          "348:         if (s->buf_end - s->buf < n)",
          "349:             return AVERROR(EINVAL);",
          "350:         for (i = 0; i < n; i++)",
          "351:             q->expn[i] = bytestream_get_byte(&s->buf) >> 3;",
          "352:     } else if (q->quantsty == JPEG2000_QSTY_SI) {",
          "353:         if (s->buf_end - s->buf < 2)",
          "354:             return AVERROR(EINVAL);",
          "355:         x          = bytestream_get_be16(&s->buf);",
          "356:         q->expn[0] = x >> 11;",
          "357:         q->mant[0] = x & 0x7ff;",
          "358:         for (i = 1; i < 32 * 3; i++) {",
          "359:             int curexpn = FFMAX(0, q->expn[0] - (i - 1) / 3);",
          "360:             q->expn[i] = curexpn;",
          "361:             q->mant[i] = q->mant[0];",
          "362:         }",
          "363:     } else {",
          "364:         n = (n - 3) >> 1;",
          "365:         if (s->buf_end - s->buf < n)",
          "366:             return AVERROR(EINVAL);",
          "367:         for (i = 0; i < n; i++) {",
          "368:             x          = bytestream_get_be16(&s->buf);",
          "369:             q->expn[i] = x >> 11;",
          "370:             q->mant[i] = x & 0x7ff;",
          "371:         }",
          "372:     }",
          "373:     return 0;",
          "374: }",
          "377: static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,",
          "378:                    uint8_t *properties)",
          "379: {",
          "380:     Jpeg2000QuantStyle tmp;",
          "381:     int compno;",
          "383:     if (get_qcx(s, n, &tmp))",
          "384:         return -1;",
          "385:     for (compno = 0; compno < s->ncomponents; compno++)",
          "386:         if (!(properties[compno] & HAD_QCC))",
          "387:             memcpy(q + compno, &tmp, sizeof(tmp));",
          "388:     return 0;",
          "389: }",
          "393: static int get_qcc(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,",
          "394:                    uint8_t *properties)",
          "395: {",
          "396:     int compno;",
          "398:     if (s->buf_end - s->buf < 1)",
          "399:         return AVERROR(EINVAL);",
          "401:     compno              = bytestream_get_byte(&s->buf);",
          "402:     properties[compno] |= HAD_QCC;",
          "403:     return get_qcx(s, n - 1, q + compno);",
          "404: }",
          "407: static uint8_t get_sot(Jpeg2000DecoderContext *s, int n)",
          "408: {",
          "409:     Jpeg2000TilePart *tp;",
          "410:     uint16_t Isot;",
          "411:     uint32_t Psot;",
          "412:     uint8_t TPsot;",
          "414:     if (s->buf_end - s->buf < 4)",
          "415:         return AVERROR(EINVAL);",
          "417:     Isot = bytestream_get_be16(&s->buf);        // Isot",
          "418:     if (Isot) {",
          "419:         av_log(s->avctx, AV_LOG_ERROR,",
          "420:                \"Not a DCINEMA JP2K file: more than one tile\\n\");",
          "421:         return -1;",
          "422:     }",
          "423:     Psot  = bytestream_get_be32(&s->buf);       // Psot",
          "424:     TPsot = bytestream_get_byte(&s->buf);       // TPsot",
          "427:     bytestream_get_byte(&s->buf);               // TNsot",
          "429:     tp             = s->tile[s->curtileno].tile_part + TPsot;",
          "430:     tp->tile_index = Isot;",
          "431:     tp->tp_len     = Psot;",
          "432:     tp->tp_idx     = TPsot;",
          "436:     if (JPEG2000_SOD == bytestream_get_be16(&s->buf))",
          "437:         tp->tp_start_bstrm = s->buf;",
          "438:     else {",
          "439:         av_log(s->avctx, AV_LOG_ERROR, \"SOD marker not found \\n\");",
          "440:         return -1;",
          "441:     }",
          "446:     tp->tp_end_bstrm = s->buf + (tp->tp_len - n - 4);",
          "449:     s->buf = tp->tp_end_bstrm;",
          "451:     return 0;",
          "452: }",
          "462: static uint8_t get_tlm(Jpeg2000DecoderContext *s, int n)",
          "463: {",
          "464:     uint8_t Stlm, ST, SP, tile_tlm, i;",
          "466:     Stlm = bytestream_get_byte(&s->buf);",
          "469:     ST = (Stlm >> 4) & 0x03;",
          "471:     SP       = (Stlm >> 6) & 0x01;",
          "472:     tile_tlm = (n - 4) / ((SP + 1) * 2 + ST);",
          "473:     for (i = 0; i < tile_tlm; i++) {",
          "474:         switch (ST) {",
          "475:         case 0:",
          "476:             break;",
          "477:         case 1:",
          "478:             bytestream_get_byte(&s->buf);",
          "479:             break;",
          "480:         case 2:",
          "481:             bytestream_get_be16(&s->buf);",
          "482:             break;",
          "483:         case 3:",
          "484:             bytestream_get_be32(&s->buf);",
          "485:             break;",
          "486:         }",
          "487:         if (SP == 0) {",
          "488:             bytestream_get_be16(&s->buf);",
          "489:         } else {",
          "490:             bytestream_get_be32(&s->buf);",
          "491:         }",
          "492:     }",
          "493:     return 0;",
          "494: }",
          "496: static int init_tile(Jpeg2000DecoderContext *s, int tileno)",
          "497: {",
          "498:     int compno;",
          "499:     int tilex = tileno % s->numXtiles;",
          "500:     int tiley = tileno / s->numXtiles;",
          "501:     Jpeg2000Tile *tile = s->tile + tileno;",
          "502:     Jpeg2000CodingStyle *codsty;",
          "503:     Jpeg2000QuantStyle  *qntsty;",
          "505:     if (!tile->comp)",
          "506:         return AVERROR(ENOMEM);",
          "511:     memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(*codsty));",
          "512:     memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(*qntsty));",
          "514:     for (compno = 0; compno < s->ncomponents; compno++) {",
          "515:         Jpeg2000Component *comp = tile->comp + compno;",
          "516:         int ret; // global bandno",
          "517:         codsty = tile->codsty + compno;",
          "518:         qntsty = tile->qntsty + compno;",
          "520:         comp->coord_o[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);",
          "521:         comp->coord_o[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);",
          "522:         comp->coord_o[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);",
          "523:         comp->coord_o[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);",
          "527:         comp->coord[0][0] = 0;",
          "528:         comp->coord[0][1] = s->avctx->width;",
          "529:         comp->coord[1][0] = 0;",
          "530:         comp->coord[1][1] = s->avctx->height;",
          "532:         if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,",
          "533:                                              s->cbps[compno], s->cdx[compno],",
          "534:                                              s->cdy[compno], s->avctx))",
          "535:             return ret;",
          "536:     }",
          "537:     return 0;",
          "538: }",
          "541: static int getnpasses(Jpeg2000DecoderContext *s)",
          "542: {",
          "543:     int num;",
          "544:     if (!get_bits(s, 1))",
          "545:         return 1;",
          "546:     if (!get_bits(s, 1))",
          "547:         return 2;",
          "548:     if ((num = get_bits(s, 2)) != 3)",
          "549:         return num < 0 ? num : 3 + num;",
          "550:     if ((num = get_bits(s, 5)) != 31)",
          "551:         return num < 0 ? num : 6 + num;",
          "552:     num = get_bits(s, 7);",
          "553:     return num < 0 ? num : 37 + num;",
          "554: }",
          "556: static int getlblockinc(Jpeg2000DecoderContext *s)",
          "557: {",
          "558:     int res = 0, ret;",
          "559:     while (ret = get_bits(s, 1)) {",
          "560:         if (ret < 0)",
          "561:             return ret;",
          "562:         res++;",
          "563:     }",
          "564:     return res;",
          "565: }",
          "567: static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s,",
          "568:                                   Jpeg2000CodingStyle *codsty,",
          "569:                                   Jpeg2000ResLevel *rlevel, int precno,",
          "570:                                   int layno, uint8_t *expn, int numgbits)",
          "571: {",
          "572:     int bandno, cblkno, ret, nb_code_blocks;",
          "574:     if (!(ret = get_bits(s, 1))) {",
          "575:         jpeg2000_flush(s);",
          "576:         return 0;",
          "577:     } else if (ret < 0)",
          "578:         return ret;",
          "580:     for (bandno = 0; bandno < rlevel->nbands; bandno++) {",
          "581:         Jpeg2000Band *band = rlevel->band + bandno;",
          "582:         Jpeg2000Prec *prec = band->prec + precno;",
          "584:         if (band->coord[0][0] == band->coord[0][1] ||",
          "585:             band->coord[1][0] == band->coord[1][1])",
          "586:             continue;",
          "587:         prec->yi0 = 0;",
          "588:         prec->xi0 = 0;",
          "589:         nb_code_blocks =  prec->nb_codeblocks_height *",
          "590:                           prec->nb_codeblocks_width;",
          "591:         for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {",
          "592:             Jpeg2000Cblk *cblk = prec->cblk + cblkno;",
          "593:             int incl, newpasses, llen;",
          "595:             if (cblk->npasses)",
          "596:                 incl = get_bits(s, 1);",
          "597:             else",
          "598:                 incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;",
          "599:             if (!incl)",
          "600:                 continue;",
          "601:             else if (incl < 0)",
          "602:                 return incl;",
          "604:             if (!cblk->npasses)",
          "605:                 cblk->nonzerobits = expn[bandno] + numgbits - 1 -",
          "606:                                     tag_tree_decode(s, prec->zerobits + cblkno,",
          "607:                                                     100);",
          "608:             if ((newpasses = getnpasses(s)) < 0)",
          "609:                 return newpasses;",
          "610:             if ((llen = getlblockinc(s)) < 0)",
          "611:                 return llen;",
          "612:             cblk->lblock += llen;",
          "613:             if ((ret = get_bits(s, av_log2(newpasses) + cblk->lblock)) < 0)",
          "614:                 return ret;",
          "615:             cblk->lengthinc = ret;",
          "616:             cblk->npasses  += newpasses;",
          "617:         }",
          "618:     }",
          "619:     jpeg2000_flush(s);",
          "621:     if (codsty->csty & JPEG2000_CSTY_EPH) {",
          "622:         if (AV_RB16(s->buf) == JPEG2000_EPH)",
          "623:             s->buf += 2;",
          "624:         else",
          "625:             av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found.\\n\");",
          "626:     }",
          "628:     for (bandno = 0; bandno < rlevel->nbands; bandno++) {",
          "629:         Jpeg2000Band *band = rlevel->band + bandno;",
          "630:         Jpeg2000Prec *prec = band->prec + precno;",
          "632:         nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;",
          "633:         for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {",
          "634:             Jpeg2000Cblk *cblk = prec->cblk + cblkno;",
          "635:             if (s->buf_end - s->buf < cblk->lengthinc)",
          "636:                 return AVERROR(EINVAL);",
          "637:             bytestream_get_buffer(&s->buf, cblk->data, cblk->lengthinc);",
          "638:             cblk->length   += cblk->lengthinc;",
          "639:             cblk->lengthinc = 0;",
          "640:         }",
          "641:     }",
          "642:     return 0;",
          "643: }",
          "645: static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)",
          "646: {",
          "647:     int layno, reslevelno, compno, precno, ok_reslevel;",
          "648:     uint8_t prog_order = tile->codsty[0].prog_order;",
          "649:     uint16_t x;",
          "650:     uint16_t y;",
          "652:     s->bit_index = 8;",
          "653:     switch (prog_order) {",
          "654:     case JPEG2000_PGOD_LRCP:",
          "655:         for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {",
          "656:             ok_reslevel = 1;",
          "657:             for (reslevelno = 0; ok_reslevel; reslevelno++) {",
          "658:                 ok_reslevel = 0;",
          "659:                 for (compno = 0; compno < s->ncomponents; compno++) {",
          "660:                     Jpeg2000CodingStyle *codsty = tile->codsty + compno;",
          "661:                     Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;",
          "662:                     if (reslevelno < codsty->nreslevels) {",
          "663:                         Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +",
          "664:                                                    reslevelno;",
          "665:                         ok_reslevel = 1;",
          "666:                         for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)",
          "667:                             if (jpeg2000_decode_packet(s,",
          "668:                                                        codsty, rlevel,",
          "669:                                                        precno, layno,",
          "670:                                                        qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),",
          "671:                                                        qntsty->nguardbits))",
          "672:                                 return -1;",
          "673:                     }",
          "674:                 }",
          "675:             }",
          "676:         }",
          "677:         break;",
          "679:     case JPEG2000_PGOD_CPRL:",
          "680:         for (compno = 0; compno < s->ncomponents; compno++) {",
          "681:             Jpeg2000CodingStyle *codsty = tile->codsty + compno;",
          "682:             Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;",
          "687:             s->buf = tile->tile_part[compno].tp_start_bstrm;",
          "692:             for (y = 0; y < s->height; y += 256) {",
          "696:                 for (x = 0; x < s->width; x += 256) {",
          "697:                     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {",
          "698:                         uint16_t prcx, prcy;",
          "699:                         uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r",
          "700:                         Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;",
          "702:                         if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||",
          "703:                               (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema",
          "704:                             continue;",
          "706:                         if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||",
          "707:                               (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema",
          "708:                             continue;",
          "711:                         prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;",
          "712:                         prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;",
          "713:                         precno = prcx + rlevel->num_precincts_x * prcy;",
          "714:                         for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {",
          "715:                             if (jpeg2000_decode_packet(s, codsty, rlevel,",
          "716:                                                        precno, layno,",
          "717:                                                        qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),",
          "718:                                                        qntsty->nguardbits))",
          "719:                                 return -1;",
          "720:                         }",
          "721:                     }",
          "722:                 }",
          "723:             }",
          "724:         }",
          "725:         break;",
          "727:     default:",
          "728:         break;",
          "729:     }",
          "732:     s->buf += 2;",
          "734:     return 0;",
          "735: }",
          "738: static void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,",
          "739:                            int bpno, int bandno)",
          "740: {",
          "741:     int mask = 3 << (bpno - 1), y0, x, y;",
          "743:     for (y0 = 0; y0 < height; y0 += 4)",
          "744:         for (x = 0; x < width; x++)",
          "745:             for (y = y0; y < height && y < y0 + 4; y++)",
          "746:                 if ((t1->flags[y + 1][x + 1] & JPEG2000_T1_SIG_NB)",
          "747:                     && !(t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {",
          "748:                     if (ff_mqc_decode(&t1->mqc,",
          "749:                                       t1->mqc.cx_states +",
          "750:                                       ff_jpeg2000_getsigctxno(t1->flags[y + 1][x + 1],",
          "751:                                                              bandno))) {",
          "752:                         int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y + 1][x + 1],",
          "753:                                                                     &xorbit);",
          "755:                         t1->data[y][x] =",
          "756:                             (ff_mqc_decode(&t1->mqc,",
          "757:                                            t1->mqc.cx_states + ctxno) ^ xorbit)",
          "758:                             ? -mask : mask;",
          "760:                         ff_jpeg2000_set_significance(t1, x, y,",
          "761:                                                      t1->data[y][x] < 0);",
          "762:                     }",
          "763:                     t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;",
          "764:                 }",
          "765: }",
          "767: static void decode_refpass(Jpeg2000T1Context *t1, int width, int height,",
          "768:                            int bpno)",
          "769: {",
          "770:     int phalf, nhalf;",
          "771:     int y0, x, y;",
          "773:     phalf = 1 << (bpno - 1);",
          "774:     nhalf = -phalf;",
          "776:     for (y0 = 0; y0 < height; y0 += 4)",
          "777:         for (x = 0; x < width; x++)",
          "778:             for (y = y0; y < height && y < y0 + 4; y++)",
          "779:                 if ((t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)) == JPEG2000_T1_SIG) {",
          "780:                     int ctxno = ff_jpeg2000_getrefctxno(t1->flags[y + 1][x + 1]);",
          "781:                     int r     = ff_mqc_decode(&t1->mqc,",
          "782:                                               t1->mqc.cx_states + ctxno)",
          "783:                                 ? phalf : nhalf;",
          "784:                     t1->data[y][x]          += t1->data[y][x] < 0 ? -r : r;",
          "785:                     t1->flags[y + 1][x + 1] |= JPEG2000_T1_REF;",
          "786:                 }",
          "787: }",
          "789: static void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,",
          "790:                            int width, int height, int bpno, int bandno,",
          "791:                            int seg_symbols)",
          "792: {",
          "793:     int mask = 3 << (bpno - 1), y0, x, y, runlen, dec;",
          "795:     for (y0 = 0; y0 < height; y0 += 4)",
          "796:         for (x = 0; x < width; x++) {",
          "797:             if (y0 + 3 < height &&",
          "798:                 !((t1->flags[y0 + 1][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||",
          "799:                   (t1->flags[y0 + 2][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||",
          "800:                   (t1->flags[y0 + 3][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||",
          "801:                   (t1->flags[y0 + 4][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)))) {",
          "802:                 if (!ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL))",
          "803:                     continue;",
          "804:                 runlen = ff_mqc_decode(&t1->mqc,",
          "805:                                        t1->mqc.cx_states + MQC_CX_UNI);",
          "806:                 runlen = (runlen << 1) | ff_mqc_decode(&t1->mqc,",
          "807:                                                        t1->mqc.cx_states +",
          "808:                                                        MQC_CX_UNI);",
          "809:                 dec = 1;",
          "810:             } else {",
          "811:                 runlen = 0;",
          "812:                 dec    = 0;",
          "813:             }",
          "815:             for (y = y0 + runlen; y < y0 + 4 && y < height; y++) {",
          "816:                 if (!dec) {",
          "817:                     if (!(t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)))",
          "818:                         dec = ff_mqc_decode(&t1->mqc,",
          "819:                                             t1->mqc.cx_states +",
          "820:                                             ff_jpeg2000_getsigctxno(t1->flags[y + 1][x + 1],",
          "821:                                                                    bandno));",
          "822:                 }",
          "823:                 if (dec) {",
          "824:                     int xorbit;",
          "825:                     int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y + 1][x + 1],",
          "826:                                                         &xorbit);",
          "827:                     t1->data[y][x] = (ff_mqc_decode(&t1->mqc,",
          "828:                                                     t1->mqc.cx_states + ctxno) ^",
          "829:                                       xorbit)",
          "830:                                      ? -mask : mask;",
          "831:                     ff_jpeg2000_set_significance(t1, x, y, t1->data[y][x] < 0);",
          "832:                 }",
          "833:                 dec = 0;",
          "834:                 t1->flags[y + 1][x + 1] &= ~JPEG2000_T1_VIS;",
          "835:             }",
          "836:         }",
          "837:     if (seg_symbols) {",
          "838:         int val;",
          "839:         val = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);",
          "840:         val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);",
          "841:         val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);",
          "842:         val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);",
          "843:         if (val != 0xa)",
          "844:             av_log(s->avctx, AV_LOG_ERROR,",
          "845:                    \"Segmentation symbol value incorrect\\n\");",
          "846:     }",
          "847: }",
          "849: static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,",
          "850:                        Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,",
          "851:                        int width, int height, int bandpos)",
          "852: {",
          "853:     int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;",
          "855:     for (y = 0; y < height + 2; y++)",
          "856:         memset(t1->flags[y], 0, (width + 2) * sizeof(width));",
          "858:     for (y = 0; y < height; y++)",
          "859:         memset(t1->data[y], 0, width * sizeof(width));",
          "861:     ff_mqc_initdec(&t1->mqc, cblk->data);",
          "862:     cblk->data[cblk->length]     = 0xff;",
          "863:     cblk->data[cblk->length + 1] = 0xff;",
          "865:     while (passno--) {",
          "866:         switch (pass_t) {",
          "867:         case 0:",
          "868:             decode_sigpass(t1, width, height, bpno + 1, bandpos);",
          "869:             break;",
          "870:         case 1:",
          "871:             decode_refpass(t1, width, height, bpno + 1);",
          "872:             break;",
          "873:         case 2:",
          "874:             decode_clnpass(s, t1, width, height, bpno + 1, bandpos,",
          "875:                            codsty->cblk_style & JPEG2000_CBLK_SEGSYM);",
          "876:             break;",
          "877:         }",
          "879:         pass_t++;",
          "880:         if (pass_t == 3) {",
          "881:             bpno--;",
          "882:             pass_t = 0;",
          "883:         }",
          "884:     }",
          "885:     return 0;",
          "886: }",
          "895: static void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,",
          "896:                                  Jpeg2000Component *comp,",
          "897:                                  Jpeg2000T1Context *t1, Jpeg2000Band *band)",
          "898: {",
          "899:     int i, j, idx;",
          "900:     float *datap = &comp->data[(comp->coord[0][1] - comp->coord[0][0]) * y + x];",
          "901:     for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j)",
          "902:         for (i = 0; i < (cblk->coord[0][1] - cblk->coord[0][0]); ++i) {",
          "903:             idx        = (comp->coord[0][1] - comp->coord[0][0]) * j + i;",
          "904:             datap[idx] = (float)(t1->data[j][i]) * ((float)band->stepsize);",
          "905:         }",
          "906:     return;",
          "907: }",
          "910: static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,",
          "911:                                Jpeg2000Component *comp,",
          "912:                                Jpeg2000T1Context *t1, Jpeg2000Band *band)",
          "913: {",
          "914:     int i, j, idx;",
          "915:     int32_t *datap =",
          "916:         (int32_t *) &comp->data[(comp->coord[0][1] - comp->coord[0][0]) * y + x];",
          "917:     for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j)",
          "918:         for (i = 0; i < (cblk->coord[0][1] - cblk->coord[0][0]); ++i) {",
          "919:             idx        = (comp->coord[0][1] - comp->coord[0][0]) * j + i;",
          "920:             datap[idx] =",
          "921:                 ((int32_t)(t1->data[j][i]) * ((int32_t)band->stepsize) + (1 << 15)) >> 16;",
          "922:         }",
          "923:     return;",
          "924: }",
          "928: static const float f_ict_params[4] = {",
          "929:     1.402f,",
          "930:     0.34413f,",
          "931:     0.71414f,",
          "932:     1.772f",
          "933: };",
          "934: static const int   i_ict_params[4] = {",
          "935:      91881,",
          "936:      22553,",
          "937:      46802,",
          "938:     116130",
          "939: };",
          "941: static int mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)",
          "942: {",
          "943:     int i, csize = 1;",
          "944:     int ret = 0;",
          "945:     int32_t *src[3],  i0,  i1,  i2;",
          "946:     float   *srcf[3], i0f, i1f, i2f;",
          "948:     for (i = 0; i < 3; i++)",
          "949:         if (tile->codsty[0].transform == FF_DWT97)",
          "950:             srcf[i] = tile->comp[i].data;",
          "951:         else",
          "952:             src[i] = (int32_t *)tile->comp[i].data;",
          "954:     for (i = 0; i < 2; i++)",
          "955:         csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];",
          "956:     switch (tile->codsty[0].transform) {",
          "957:     case FF_DWT97:",
          "958:         for (i = 0; i < csize; i++) {",
          "959:             i0f = *srcf[0] + (f_ict_params[0] * *srcf[2]);",
          "960:             i1f = *srcf[0] - (f_ict_params[1] * *srcf[1])",
          "961:                            - (f_ict_params[2] * *srcf[2]);",
          "962:             i2f = *srcf[0] + (f_ict_params[3] * *srcf[1]);",
          "966:         }",
          "967:         break;",
          "968:     case FF_DWT97_INT:",
          "969:         for (i = 0; i < csize; i++) {",
          "970:             i0 = *src[0] + (((i_ict_params[0] * *src[2]) + (1 << 15)) >> 16);",
          "971:             i1 = *src[0] - (((i_ict_params[1] * *src[1]) + (1 << 15)) >> 16)",
          "972:                          - (((i_ict_params[2] * *src[2]) + (1 << 15)) >> 16);",
          "973:             i2 = *src[0] + (((i_ict_params[3] * *src[1]) + (1 << 15)) >> 16);",
          "977:         }",
          "978:         break;",
          "979:     case FF_DWT53:",
          "980:         for (i = 0; i < csize; i++) {",
          "981:             i1 = *src[0] - (*src[2] + *src[1] >> 2);",
          "982:             i0 = i1 + *src[2];",
          "983:             i2 = i1 + *src[1];",
          "987:         }",
          "988:         break;",
          "989:     }",
          "990:     return ret;",
          "991: }",
          "993: static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,",
          "994:                                 AVFrame *picture)",
          "995: {",
          "996:     int compno, reslevelno, bandno;",
          "997:     int x, y;",
          "999:     uint8_t *line;",
          "1000:     Jpeg2000T1Context t1;",
          "1003:     for (compno = 0; compno < s->ncomponents; compno++) {",
          "1004:         Jpeg2000Component *comp     = tile->comp + compno;",
          "1005:         Jpeg2000CodingStyle *codsty = tile->codsty + compno;",
          "1007:         for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {",
          "1008:             Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;",
          "1010:             for (bandno = 0; bandno < rlevel->nbands; bandno++) {",
          "1011:                 uint16_t nb_precincts, precno;",
          "1012:                 Jpeg2000Band *band = rlevel->band + bandno;",
          "1013:                 int cblkno = 0, bandpos;",
          "1014:                 bandpos = bandno + (reslevelno > 0);",
          "1016:                 nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;",
          "1018:                 for (precno = 0; precno < nb_precincts; precno++) {",
          "1019:                     Jpeg2000Prec *prec = band->prec + precno;",
          "1022:                     for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {",
          "1023:                         int x, y;",
          "1024:                         Jpeg2000Cblk *cblk = prec->cblk + cblkno;",
          "1025:                         decode_cblk(s, codsty, &t1, cblk,",
          "1026:                                     cblk->coord[0][1] - cblk->coord[0][0],",
          "1027:                                     cblk->coord[1][1] - cblk->coord[1][0],",
          "1028:                                     bandpos);",
          "1031:                         x = cblk->coord[0][0];",
          "1032:                         y = cblk->coord[1][0];",
          "1033:                         if ((reslevelno > 0) && ((bandno + 1) & 1)) {",
          "1034:                             Jpeg2000ResLevel *pres = comp->reslevel + (reslevelno - 1);",
          "1035:                             x += pres->coord[0][1] - pres->coord[0][0];",
          "1036:                         }",
          "1037:                         if ((reslevelno > 0) && ((bandno + 1) & 2)) {",
          "1038:                             Jpeg2000ResLevel *pres = comp->reslevel + (reslevelno - 1);",
          "1039:                             y += pres->coord[1][1] - pres->coord[1][0];",
          "1040:                         }",
          "1042:                         if (s->avctx->flags & CODEC_FLAG_BITEXACT)",
          "1043:                             dequantization_int(x, y, cblk, comp, &t1, band);",
          "1044:                         else",
          "1045:                             dequantization_float(x, y, cblk, comp, &t1, band);",
          "1052:         ff_dwt_decode(&comp->dwt, comp->data);",
          "1056:     if (tile->codsty[0].mct)",
          "1057:         mct_decode(s, tile);",
          "1059:     if (s->avctx->pix_fmt == PIX_FMT_BGRA) // RGBA -> BGRA",
          "1060:         FFSWAP(float *, tile->comp[0].data, tile->comp[2].data);",
          "1062:     if (s->precision <= 8) {",
          "1063:         for (compno = 0; compno < s->ncomponents; compno++) {",
          "1064:             Jpeg2000Component *comp = tile->comp + compno;",
          "1065:             int32_t *datap = (int32_t *)comp->data;",
          "1066:             y    = tile->comp[compno].coord[1][0] - s->image_offset_y;",
          "1067:             line = picture->data[0] + y * picture->linesize[0];",
          "1068:             for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {",
          "1069:                 uint8_t *dst;",
          "1071:                 x   = tile->comp[compno].coord[0][0] - s->image_offset_x;",
          "1072:                 dst = line + x * s->ncomponents + compno;",
          "1074:                 for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {",
          "1076:                     if (*datap < 0)",
          "1078:                     else if (*datap >= (1 << s->cbps[compno]))",
          "1081:                     dst += s->ncomponents;",
          "1082:                 }",
          "1083:                 line += picture->linesize[0];",
          "1084:             }",
          "1085:         }",
          "1086:     } else {",
          "1087:         for (compno = 0; compno < s->ncomponents; compno++) {",
          "1088:             Jpeg2000Component *comp = tile->comp + compno;",
          "1089:             float *datap = comp->data;",
          "1090:             int32_t *i_datap = (int32_t *) comp->data;",
          "1091:             uint16_t *linel;",
          "1093:             y     = tile->comp[compno].coord[1][0] - s->image_offset_y;",
          "1094:             linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);",
          "1095:             for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {",
          "1096:                 uint16_t *dst;",
          "1097:                 x   = tile->comp[compno].coord[0][0] - s->image_offset_x;",
          "1098:                 dst = linel + (x * s->ncomponents + compno);",
          "1099:                 for (; x < s->avctx->width; x += s->cdx[compno]) {",
          "1100:                     int16_t val;",
          "1102:                     if (s->avctx->flags & CODEC_FLAG_BITEXACT)",
          "1103:                         val = *i_datap + (1 << (s->cbps[compno] - 1));",
          "1104:                     else",
          "1105:                         val = lrintf(*datap) + (1 << (s->cbps[compno] - 1));",
          "1106:                     val = av_clip(val, 0, (1 << s->cbps[compno]) - 1);",
          "1109:                     datap++;",
          "1110:                     i_datap++;",
          "1111:                     dst += s->ncomponents;",
          "1112:                 }",
          "1113:                 linel += picture->linesize[0] >> 1;",
          "1114:             }",
          "1115:         }",
          "1116:     }",
          "1117:     return 0;",
          "1118: }",
          "1120: static void jpeg2000_dec_cleanup(Jpeg2000DecoderContext *s)",
          "1121: {",
          "1122:     int tileno, compno;",
          "1123:     for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {",
          "1124:         for (compno = 0; compno < s->ncomponents; compno++) {",
          "1125:             Jpeg2000Component *comp     = s->tile[tileno].comp   + compno;",
          "1126:             Jpeg2000CodingStyle *codsty = s->tile[tileno].codsty + compno;",
          "1128:             ff_jpeg2000_cleanup(comp, codsty);",
          "1129:         }",
          "1130:         av_freep(&s->tile[tileno].comp);",
          "1131:     }",
          "1132:     av_freep(&s->tile);",
          "1133: }",
          "1135: static int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)",
          "1136: {",
          "1137:     Jpeg2000CodingStyle *codsty = s->codsty;",
          "1138:     Jpeg2000QuantStyle *qntsty  = s->qntsty;",
          "1139:     uint8_t *properties         = s->properties;",
          "1141:     for (;;) {",
          "1142:         int len, ret = 0;",
          "1143:         uint16_t marker;",
          "1144:         const uint8_t *oldbuf;",
          "1146:         if (s->buf_end - s->buf < 2) {",
          "1147:             av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");",
          "1148:             break;",
          "1149:         }",
          "1151:         marker = bytestream_get_be16(&s->buf);",
          "1152:         oldbuf = s->buf;",
          "1154:         if (marker == JPEG2000_EOC)",
          "1155:             break;",
          "1157:         if (s->buf_end - s->buf < 2)",
          "1158:             return AVERROR(EINVAL);",
          "1159:         len = bytestream_get_be16(&s->buf);",
          "1160:         switch (marker) {",
          "1161:         case JPEG2000_SIZ:",
          "1162:             ret = get_siz(s);",
          "1163:             break;",
          "1164:         case JPEG2000_COC:",
          "1165:             ret = get_coc(s, codsty, properties);",
          "1166:             break;",
          "1167:         case JPEG2000_COD:",
          "1168:             ret = get_cod(s, codsty, properties);",
          "1169:             break;",
          "1170:         case JPEG2000_QCC:",
          "1171:             ret = get_qcc(s, len, qntsty, properties);",
          "1172:             break;",
          "1173:         case JPEG2000_QCD:",
          "1174:             ret = get_qcd(s, len, qntsty, properties);",
          "1175:             break;",
          "1176:         case JPEG2000_SOT:",
          "1177:             ret = get_sot(s, len);",
          "1178:             break;",
          "1179:         case JPEG2000_COM:",
          "1181:             s->buf += len - 2;",
          "1182:             break;",
          "1183:         case JPEG2000_TLM:",
          "1185:             ret = get_tlm(s, len);",
          "1186:             break;",
          "1187:         default:",
          "1188:             av_log(s->avctx, AV_LOG_ERROR,",
          "1189:                    \"unsupported marker 0x%.4X at pos 0x%lX\\n\",",
          "1190:                    marker, (uint64_t)(s->buf - s->buf_start - 4));",
          "1191:             s->buf += len - 2;",
          "1192:             break;",
          "1193:         }",
          "1194:         if (((s->buf - oldbuf != len) && (marker != JPEG2000_SOT)) || ret) {",
          "1195:             av_log(s->avctx, AV_LOG_ERROR,",
          "1196:                    \"error during processing marker segment %.4x\\n\", marker);",
          "1197:             return ret ? ret : -1;",
          "1198:         }",
          "1199:     }",
          "1200:     return 0;",
          "1201: }",
          "1204: static int jpeg2000_read_bitstream_packets(Jpeg2000DecoderContext *s)",
          "1205: {",
          "1206:     int ret = 0;",
          "1207:     Jpeg2000Tile *tile = s->tile + s->curtileno;",
          "1209:     if (ret = init_tile(s, s->curtileno))",
          "1210:         return ret;",
          "1211:     if (ret = jpeg2000_decode_packets(s, tile))",
          "1212:         return ret;",
          "1214:     return 0;",
          "1215: }",
          "1217: static int jp2_find_codestream(Jpeg2000DecoderContext *s)",
          "1218: {",
          "1219:     int32_t atom_size;",
          "1220:     int found_codestream = 0, search_range = 10;",
          "1223:     s->buf += 12;",
          "1225:     while (!found_codestream && search_range) {",
          "1226:         atom_size = AV_RB32(s->buf);",
          "1227:         if (AV_RB32(s->buf + 4) == JP2_CODESTREAM) {",
          "1228:             found_codestream = 1;",
          "1229:             s->buf += 8;",
          "1230:         } else {",
          "1231:             s->buf += atom_size;",
          "1232:             search_range--;",
          "1233:         }",
          "1234:     }",
          "1236:     if (found_codestream)",
          "1237:         return 1;",
          "1238:     return 0;",
          "1239: }",
          "1241: static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,",
          "1242:                                  int *got_frame, AVPacket *avpkt)",
          "1243: {",
          "1244:     Jpeg2000DecoderContext *s = avctx->priv_data;",
          "1245:     AVFrame *picture = data;",
          "1246:     int tileno, ret;",
          "1248:     s->avctx     = avctx;",
          "1249:     s->buf       = s->buf_start = avpkt->data;",
          "1250:     s->buf_end   = s->buf_start + avpkt->size;",
          "1251:     s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles",
          "1254:     s->reduction_factor = s->lowres;",
          "1256:     ff_jpeg2000_init_tier1_luts();",
          "1258:     if (s->buf_end - s->buf < 2)",
          "1259:         return AVERROR(EINVAL);",
          "1262:     if ((AV_RB32(s->buf) == 12) &&",
          "1263:         (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&",
          "1264:         (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {",
          "1265:         if (!jp2_find_codestream(s)) {",
          "1266:             av_log(avctx, AV_LOG_ERROR,",
          "1267:                    \"couldn't find jpeg2k codestream atom\\n\");",
          "1268:             return -1;",
          "1269:         }",
          "1270:     }",
          "1272:     if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {",
          "1273:         av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");",
          "1274:         return -1;",
          "1275:     }",
          "1276:     if (ret = jpeg2000_read_main_headers(s))",
          "1277:         return ret;",
          "1280:     if ((ret = ff_get_buffer(avctx, picture, 0)) < 0) {",
          "1281:         av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer() failed\\n\");",
          "1282:         return ret;",
          "1283:     }",
          "1284:     picture->pict_type = AV_PICTURE_TYPE_I;",
          "1285:     picture->key_frame = 1;",
          "1287:     if (ret = jpeg2000_read_bitstream_packets(s))",
          "1288:         return ret;",
          "1289:     for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)",
          "1290:         if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))",
          "1291:             return ret;",
          "1292:     jpeg2000_dec_cleanup(s);",
          "1296:     return s->buf - s->buf_start;",
          "1297: }",
          "1299: #define OFFSET(x) offsetof(Jpeg2000DecoderContext, x)",
          "1300: #define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM",
          "1302: static const AVOption options[] = {",
          "1303:     { \"lowres\",  \"Lower the decoding resolution by a power of two\",",
          "1304:         OFFSET(lowres), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, JPEG2000_MAX_RESLEVELS - 1, VD },",
          "1305:     { NULL },",
          "1306: };",
          "1308: static const AVProfile profiles[] = {",
          "1309:     { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0,  \"JPEG 2000 codestream restriction 0\"   },",
          "1310:     { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1,  \"JPEG 2000 codestream restriction 1\"   },",
          "1311:     { FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION, \"JPEG 2000 no codestream restrictions\" },",
          "1312:     { FF_PROFILE_JPEG2000_DCINEMA_2K,             \"JPEG 2000 digital cinema 2K\"          },",
          "1313:     { FF_PROFILE_JPEG2000_DCINEMA_4K,             \"JPEG 2000 digital cinema 4K\"          },",
          "1314:     { FF_PROFILE_UNKNOWN },",
          "1315: };",
          "1317: static const AVClass class = {",
          "1318:     .class_name = \"jpeg2000\",",
          "1319:     .item_name  = av_default_item_name,",
          "1320:     .option     = options,",
          "1321:     .version    = LIBAVUTIL_VERSION_INT,",
          "1322: };",
          "1324: AVCodec ff_jpeg2000_decoder = {",
          "1325:     .name           = \"jpeg2000\",",
          "1326:     .long_name      = NULL_IF_CONFIG_SMALL(\"JPEG 2000\"),",
          "1327:     .type           = AVMEDIA_TYPE_VIDEO,",
          "1328:     .id             = AV_CODEC_ID_JPEG2000,",
          "1329:     .priv_data_size = sizeof(Jpeg2000DecoderContext),",
          "1330:     .decode         = jpeg2000_decode_frame,",
          "1331:     .priv_class     = &class,",
          "1332:     .pix_fmts       = (enum PixelFormat[]) { AV_PIX_FMT_XYZ12,",
          "1333:                                              AV_PIX_FMT_GRAY8,",
          "1334:                                              -1 },",
          "1335:     .profiles       = NULL_IF_CONFIG_SMALL(profiles)",
          "1336: };",
          "",
          "---------------"
        ],
        "libavcodec/jpeg2000dwt.c||libavcodec/jpeg2000dwt.c": [
          "File: libavcodec/jpeg2000dwt.c -> libavcodec/jpeg2000dwt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"libavutil/common.h\"",
          "29: #include \"libavutil/mem.h\"",
          "30: #include \"jpeg2000dwt.h\"",
          "31: #include \"internal.h\"",
          "35: #define F_LFTG_ALPHA  1.586134342059924f",
          "36: #define F_LFTG_BETA   0.052980118572961f",
          "37: #define F_LFTG_GAMMA  0.882911075530934f",
          "38: #define F_LFTG_DELTA  0.443506852043971f",
          "39: #define F_LFTG_K      1.230174104914001f",
          "40: #define F_LFTG_X      1.625732422f",
          "47: #define I_LFTG_ALPHA  103949",
          "48: #define I_LFTG_BETA     3472",
          "49: #define I_LFTG_GAMMA   57862",
          "50: #define I_LFTG_DELTA   29066",
          "51: #define I_LFTG_K       80621",
          "52: #define I_LFTG_X      106544",
          "55: static inline void extend53(int *p, int i0, int i1)",
          "56: {",
          "57:     p[i0 - 1] = p[i0 + 1];",
          "58:     p[i1]     = p[i1 - 2];",
          "59:     p[i0 - 2] = p[i0 + 2];",
          "60:     p[i1 + 1] = p[i1 - 3];",
          "61: }",
          "63: static inline void extend97_float(float *p, int i0, int i1)",
          "64: {",
          "65:     int i;",
          "67:     for (i = 1; i <= 4; i++) {",
          "68:         p[i0 - i]     = p[i0 + i];",
          "69:         p[i1 + i - 1] = p[i1 - i - 1];",
          "70:     }",
          "71: }",
          "73: static inline void extend97_int(int32_t *p, int i0, int i1)",
          "74: {",
          "75:     int i;",
          "77:     for (i = 1; i <= 4; i++) {",
          "78:         p[i0 - i]     = p[i0 + i];",
          "79:         p[i1 + i - 1] = p[i1 - i - 1];",
          "80:     }",
          "81: }",
          "83: static void sr_1d53(int *p, int i0, int i1)",
          "84: {",
          "85:     int i;",
          "87:     if (i1 == i0 + 1)",
          "88:         return;",
          "90:     extend53(p, i0, i1);",
          "92:     for (i = i0 / 2; i < i1 / 2 + 1; i++)",
          "93:         p[2 * i] -= (p[2 * i - 1] + p[2 * i + 1] + 2) >> 2;",
          "94:     for (i = i0 / 2; i < i1 / 2; i++)",
          "95:         p[2 * i + 1] += (p[2 * i] + p[2 * i + 2]) >> 1;",
          "96: }",
          "98: static void dwt_decode53(DWTContext *s, int *t)",
          "99: {",
          "100:     int lev;",
          "101:     int w     = s->linelen[s->ndeclevels - 1][0];",
          "102:     int32_t *line = s->i_linebuf;",
          "103:     line += 3;",
          "105:     for (lev = 0; lev < s->ndeclevels; lev++) {",
          "106:         int lh = s->linelen[lev][0],",
          "107:             lv = s->linelen[lev][1],",
          "108:             mh = s->mod[lev][0],",
          "109:             mv = s->mod[lev][1],",
          "110:             lp;",
          "111:         int *l;",
          "114:         l = line + mh;",
          "115:         for (lp = 0; lp < lv; lp++) {",
          "116:             int i, j = 0;",
          "118:             for (i = mh; i < lh; i += 2, j++)",
          "119:                 l[i] = t[w * lp + j];",
          "120:             for (i = 1 - mh; i < lh; i += 2, j++)",
          "121:                 l[i] = t[w * lp + j];",
          "123:             sr_1d53(line, mh, mh + lh);",
          "125:             for (i = 0; i < lh; i++)",
          "126:                 t[w * lp + i] = l[i];",
          "127:         }",
          "130:         l = line + mv;",
          "131:         for (lp = 0; lp < lh; lp++) {",
          "132:             int i, j = 0;",
          "134:             for (i = mv; i < lv; i += 2, j++)",
          "135:                 l[i] = t[w * j + lp];",
          "136:             for (i = 1 - mv; i < lv; i += 2, j++)",
          "137:                 l[i] = t[w * j + lp];",
          "139:             sr_1d53(line, mv, mv + lv);",
          "141:             for (i = 0; i < lv; i++)",
          "142:                 t[w * i + lp] = l[i];",
          "143:         }",
          "144:     }",
          "145: }",
          "147: static void sr_1d97_float(float *p, int i0, int i1)",
          "148: {",
          "149:     int i;",
          "151:     if (i1 == i0 + 1)",
          "152:         return;",
          "154:     extend97_float(p, i0, i1);",
          "157:     for (i = i0 / 2 - 1; i < i1 / 2 + 2; i++)",
          "158:         p[2 * i]     *= F_LFTG_K;",
          "160:     for (i = i0 / 2 - 2; i < i1 / 2 + 2; i++)",
          "161:         p[2 * i + 1] *= F_LFTG_X;",
          "163:     for (i = i0 / 2 - 1; i < i1 / 2 + 2; i++)",
          "164:         p[2 * i]     -= F_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]);",
          "166:     for (i = i0 / 2 - 1; i < i1 / 2 + 1; i++)",
          "167:         p[2 * i + 1] -= F_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]);",
          "169:     for (i = i0 / 2; i < i1 / 2 + 1; i++)",
          "170:         p[2 * i]     += F_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]);",
          "172:     for (i = i0 / 2; i < i1 / 2; i++)",
          "173:         p[2 * i + 1] += F_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]);",
          "174: }",
          "176: static void dwt_decode97_float(DWTContext *s, float *t)",
          "177: {",
          "178:     int lev;",
          "179:     int w       = s->linelen[s->ndeclevels - 1][0];",
          "180:     float *line = s->f_linebuf;",
          "181:     float *data = t;",
          "183:     line += 5;",
          "185:     for (lev = 0; lev < s->ndeclevels; lev++) {",
          "186:         int lh = s->linelen[lev][0],",
          "187:             lv = s->linelen[lev][1],",
          "188:             mh = s->mod[lev][0],",
          "189:             mv = s->mod[lev][1],",
          "190:             lp;",
          "191:         float *l;",
          "193:         l = line + mh;",
          "194:         for (lp = 0; lp < lv; lp++) {",
          "195:             int i, j = 0;",
          "197:             for (i = mh; i < lh; i += 2, j++)",
          "198:                 l[i] = data[w * lp + j];",
          "199:             for (i = 1 - mh; i < lh; i += 2, j++)",
          "200:                 l[i] = data[w * lp + j];",
          "202:             sr_1d97_float(line, mh, mh + lh);",
          "204:             for (i = 0; i < lh; i++)",
          "205:                 data[w * lp + i] = l[i];",
          "206:         }",
          "209:         l = line + mv;",
          "210:         for (lp = 0; lp < lh; lp++) {",
          "211:             int i, j = 0;",
          "213:             for (i = mv; i < lv; i += 2, j++)",
          "214:                 l[i] = data[w * j + lp];",
          "215:             for (i = 1 - mv; i < lv; i += 2, j++)",
          "216:                 l[i] = data[w * j + lp];",
          "218:             sr_1d97_float(line, mv, mv + lv);",
          "220:             for (i = 0; i < lv; i++)",
          "221:                 data[w * i + lp] = l[i];",
          "222:         }",
          "223:     }",
          "224: }",
          "226: static void sr_1d97_int(int32_t *p, int i0, int i1)",
          "227: {",
          "228:     int i;",
          "230:     if (i1 == i0 + 1)",
          "231:         return;",
          "233:     extend97_int(p, i0, i1);",
          "236:     for (i = i0 / 2 - 1; i < i1 / 2 + 2; i++)",
          "237:         p[2 * i]      = ((p[2 * i] * I_LFTG_K)     + (1 << 15)) >> 16;",
          "239:     for (i = i0 / 2 - 2; i < i1 / 2 + 2; i++)",
          "240:         p[2 * i + 1]  = ((p[2 * i + 1] * I_LFTG_X) + (1 << 15)) >> 16;",
          "242:     for (i = i0 / 2 - 1; i < i1 / 2 + 2; i++)",
          "243:         p[2 * i]     -= (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;",
          "245:     for (i = i0 / 2 - 1; i < i1 / 2 + 1; i++)",
          "246:         p[2 * i + 1] -= (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;",
          "248:     for (i = i0 / 2; i < i1 / 2 + 1; i++)",
          "249:         p[2 * i]     += (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;",
          "251:     for (i = i0 / 2; i < i1 / 2; i++)",
          "252:         p[2 * i + 1] += (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;",
          "253: }",
          "255: static void dwt_decode97_int(DWTContext *s, int32_t *t)",
          "256: {",
          "257:     int lev;",
          "258:     int w       = s->linelen[s->ndeclevels - 1][0];",
          "259:     int32_t *line = s->i_linebuf;",
          "260:     int32_t *data = t;",
          "262:     line += 5;",
          "264:     for (lev = 0; lev < s->ndeclevels; lev++) {",
          "265:         int lh = s->linelen[lev][0],",
          "266:             lv = s->linelen[lev][1],",
          "267:             mh = s->mod[lev][0],",
          "268:             mv = s->mod[lev][1],",
          "269:             lp;",
          "270:         int32_t *l;",
          "272:         l = line + mh;",
          "273:         for (lp = 0; lp < lv; lp++) {",
          "274:             int i, j = 0;",
          "276:             for (i = mh; i < lh; i += 2, j++)",
          "277:                 l[i] = data[w * lp + j];",
          "278:             for (i = 1 - mh; i < lh; i += 2, j++)",
          "279:                 l[i] = data[w * lp + j];",
          "281:             sr_1d97_int(line, mh, mh + lh);",
          "283:             for (i = 0; i < lh; i++)",
          "284:                 data[w * lp + i] = l[i];",
          "285:         }",
          "288:         l = line + mv;",
          "289:         for (lp = 0; lp < lh; lp++) {",
          "290:             int i, j = 0;",
          "292:             for (i = mv; i < lv; i += 2, j++)",
          "293:                 l[i] = data[w * j + lp];",
          "294:             for (i = 1 - mv; i < lv; i += 2, j++)",
          "295:                 l[i] = data[w * j + lp];",
          "297:             sr_1d97_int(line, mv, mv + lv);",
          "299:             for (i = 0; i < lv; i++)",
          "300:                 data[w * i + lp] = l[i];",
          "301:         }",
          "302:     }",
          "303: }",
          "305: int ff_jpeg2000_dwt_init(DWTContext *s, uint16_t border[2][2],",
          "306:                          int decomp_levels, int type)",
          "307: {",
          "308:     int i, j, lev = decomp_levels, maxlen,",
          "309:         b[2][2];",
          "311:     s->ndeclevels = decomp_levels;",
          "312:     s->type       = type;",
          "314:     for (i = 0; i < 2; i++)",
          "315:         for (j = 0; j < 2; j++)",
          "316:             b[i][j] = border[i][j];",
          "318:     maxlen = FFMAX(b[0][1] - b[0][0],",
          "319:                    b[1][1] - b[1][0]);",
          "320:     while (--lev >= 0)",
          "321:         for (i = 0; i < 2; i++) {",
          "322:             s->linelen[lev][i] = b[i][1] - b[i][0];",
          "323:             s->mod[lev][i]     = b[i][0] & 1;",
          "324:             for (j = 0; j < 2; j++)",
          "325:                 b[i][j] = (b[i][j] + 1) >> 1;",
          "326:         }",
          "327:     switch (type) {",
          "328:     case FF_DWT97:",
          "329:         s->f_linebuf = av_malloc((maxlen + 12) * sizeof(*s->f_linebuf));",
          "330:         if (!s->f_linebuf)",
          "331:             return AVERROR(ENOMEM);",
          "332:         break;",
          "333:      case FF_DWT97_INT:",
          "334:         s->i_linebuf = av_malloc((maxlen + 12) * sizeof(*s->i_linebuf));",
          "335:         if (!s->i_linebuf)",
          "336:             return AVERROR(ENOMEM);",
          "337:         break;",
          "338:     case FF_DWT53:",
          "339:         s->i_linebuf = av_malloc((maxlen +  6) * sizeof(*s->i_linebuf));",
          "340:         if (!s->i_linebuf)",
          "341:             return AVERROR(ENOMEM);",
          "342:         break;",
          "343:     default:",
          "344:         return -1;",
          "345:     }",
          "346:     return 0;",
          "347: }",
          "349: int ff_dwt_decode(DWTContext *s, void *t)",
          "350: {",
          "351:     switch (s->type) {",
          "352:     case FF_DWT97:",
          "353:         dwt_decode97_float(s, t);",
          "354:         break;",
          "355:     case FF_DWT97_INT:",
          "356:         dwt_decode97_int(s, t);",
          "357:         break;",
          "358:     case FF_DWT53:",
          "359:         dwt_decode53(s, t);",
          "360:         break;",
          "361:     default:",
          "362:         return -1;",
          "363:     }",
          "364:     return 0;",
          "365: }",
          "367: void ff_dwt_destroy(DWTContext *s)",
          "368: {",
          "369:     av_freep(&s->f_linebuf);",
          "370:     av_freep(&s->i_linebuf);",
          "371: }",
          "",
          "---------------"
        ],
        "libavcodec/jpeg2000dwt.h||libavcodec/jpeg2000dwt.h": [
          "File: libavcodec/jpeg2000dwt.h -> libavcodec/jpeg2000dwt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #ifndef AVCODEC_JPEG2000DWT_H",
          "23: #define AVCODEC_JPEG2000DWT_H",
          "30: #include <stdint.h>",
          "32: #define FF_DWT_MAX_DECLVLS 32 ///< max number of decomposition levels",
          "34: enum DWTType {",
          "35:     FF_DWT97,",
          "36:     FF_DWT53,",
          "37:     FF_DWT97_INT",
          "38: };",
          "40: typedef struct DWTContext {",
          "42:     uint16_t linelen[FF_DWT_MAX_DECLVLS][2];",
          "43:     uint8_t mod[FF_DWT_MAX_DECLVLS][2];  ///< coordinates (x0, y0) of decomp. levels mod 2",
          "44:     uint8_t ndeclevels;                  ///< number of decomposition levels",
          "45:     uint8_t type;                        ///< 0 for 9/7; 1 for 5/3",
          "46:     int32_t *i_linebuf;                  ///< int buffer used by transform",
          "47:     float   *f_linebuf;                  ///< float buffer used by transform",
          "48: } DWTContext;",
          "57: int ff_jpeg2000_dwt_init(DWTContext *s, uint16_t border[2][2],",
          "58:                          int decomp_levels, int type);",
          "60: int ff_dwt_decode(DWTContext *s, void *t);",
          "62: void ff_dwt_destroy(DWTContext *s);",
          "",
          "---------------"
        ],
        "libavcodec/mqc.c||libavcodec/mqc.c": [
          "File: libavcodec/mqc.c -> libavcodec/mqc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <string.h>",
          "29: #include <stdint.h>",
          "31: #include \"mqc.h\"",
          "34: typedef struct MqcCxState {",
          "35:     uint16_t qe;",
          "36:     uint8_t  nmps;",
          "37:     uint8_t  nlps;",
          "38:     uint8_t  sw;",
          "39: } MqcCxState;",
          "41: static const MqcCxState cx_states[47] = {",
          "42:     { 0x5601,  1,  1, 1 },",
          "43:     { 0x3401,  2,  6, 0 },",
          "44:     { 0x1801,  3,  9, 0 },",
          "45:     { 0x0AC1,  4, 12, 0 },",
          "46:     { 0x0521,  5, 29, 0 },",
          "47:     { 0x0221, 38, 33, 0 },",
          "48:     { 0x5601,  7,  6, 1 },",
          "49:     { 0x5401,  8, 14, 0 },",
          "50:     { 0x4801,  9, 14, 0 },",
          "51:     { 0x3801, 10, 14, 0 },",
          "52:     { 0x3001, 11, 17, 0 },",
          "53:     { 0x2401, 12, 18, 0 },",
          "54:     { 0x1C01, 13, 20, 0 },",
          "55:     { 0x1601, 29, 21, 0 },",
          "56:     { 0x5601, 15, 14, 1 },",
          "57:     { 0x5401, 16, 14, 0 },",
          "58:     { 0x5101, 17, 15, 0 },",
          "59:     { 0x4801, 18, 16, 0 },",
          "60:     { 0x3801, 19, 17, 0 },",
          "61:     { 0x3401, 20, 18, 0 },",
          "62:     { 0x3001, 21, 19, 0 },",
          "63:     { 0x2801, 22, 19, 0 },",
          "64:     { 0x2401, 23, 20, 0 },",
          "65:     { 0x2201, 24, 21, 0 },",
          "66:     { 0x1C01, 25, 22, 0 },",
          "67:     { 0x1801, 26, 23, 0 },",
          "68:     { 0x1601, 27, 24, 0 },",
          "69:     { 0x1401, 28, 25, 0 },",
          "70:     { 0x1201, 29, 26, 0 },",
          "71:     { 0x1101, 30, 27, 0 },",
          "72:     { 0x0AC1, 31, 28, 0 },",
          "73:     { 0x09C1, 32, 29, 0 },",
          "74:     { 0x08A1, 33, 30, 0 },",
          "75:     { 0x0521, 34, 31, 0 },",
          "76:     { 0x0441, 35, 32, 0 },",
          "77:     { 0x02A1, 36, 33, 0 },",
          "78:     { 0x0221, 37, 34, 0 },",
          "79:     { 0x0141, 38, 35, 0 },",
          "80:     { 0x0111, 39, 36, 0 },",
          "81:     { 0x0085, 40, 37, 0 },",
          "82:     { 0x0049, 41, 38, 0 },",
          "83:     { 0x0025, 42, 39, 0 },",
          "84:     { 0x0015, 43, 40, 0 },",
          "85:     { 0x0009, 44, 41, 0 },",
          "86:     { 0x0005, 45, 42, 0 },",
          "87:     { 0x0001, 45, 43, 0 },",
          "88:     { 0x5601, 46, 46, 0 }",
          "89: };",
          "91: uint16_t ff_mqc_qe [2 * 47];",
          "92: uint8_t ff_mqc_nlps[2 * 47];",
          "93: uint8_t ff_mqc_nmps[2 * 47];",
          "95: void ff_mqc_init_contexts(MqcState *mqc)",
          "96: {",
          "97:     int i;",
          "98:     memset(mqc->cx_states, 0, sizeof(mqc->cx_states));",
          "99:     mqc->cx_states[MQC_CX_UNI] = 2 * 46;",
          "100:     mqc->cx_states[MQC_CX_RL]  = 2 * 3;",
          "101:     mqc->cx_states[0]          = 2 * 4;",
          "103:     for (i = 0; i < 47; i++) {",
          "104:         ff_mqc_qe[2 * i]     =",
          "105:         ff_mqc_qe[2 * i + 1] = cx_states[i].qe;",
          "107:         ff_mqc_nlps[2 * i]     = 2 * cx_states[i].nlps + cx_states[i].sw;",
          "108:         ff_mqc_nlps[2 * i + 1] = 2 * cx_states[i].nlps + 1 - cx_states[i].sw;",
          "109:         ff_mqc_nmps[2 * i]     = 2 * cx_states[i].nmps;",
          "110:         ff_mqc_nmps[2 * i + 1] = 2 * cx_states[i].nmps + 1;",
          "111:     }",
          "112: }",
          "",
          "---------------"
        ],
        "libavcodec/mqc.h||libavcodec/mqc.h": [
          "File: libavcodec/mqc.h -> libavcodec/mqc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #ifndef AVCODEC_MQC_H",
          "23: #define AVCODEC_MQC_H",
          "31: #include <stdint.h>",
          "33: #define MQC_CX_UNI 17",
          "34: #define MQC_CX_RL  18",
          "36: extern uint16_t ff_mqc_qe[2 * 47];",
          "37: extern uint8_t  ff_mqc_nlps[2 * 47];",
          "38: extern uint8_t  ff_mqc_nmps[2 * 47];",
          "40: typedef struct MqcState {",
          "41:     uint8_t *bp, *bpstart;",
          "42:     unsigned int a;",
          "43:     unsigned int c;",
          "44:     unsigned int ct;",
          "45:     uint8_t cx_states[19];",
          "46: } MqcState;",
          "55: void ff_mqc_initdec(MqcState *mqc, uint8_t *bp);",
          "63: int ff_mqc_decode(MqcState *mqc, uint8_t *cxstate);",
          "71: void ff_mqc_init_contexts(MqcState *mqc);",
          "",
          "---------------"
        ],
        "libavcodec/mqcdec.c||libavcodec/mqcdec.c": [
          "File: libavcodec/mqcdec.c -> libavcodec/mqcdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"mqc.h\"",
          "30: static void bytein(MqcState *mqc)",
          "31: {",
          "32:     if (*mqc->bp == 0xff) {",
          "33:         if (*(mqc->bp + 1) > 0x8f)",
          "34:             mqc->c++;",
          "35:         else {",
          "36:             mqc->bp++;",
          "37:             mqc->c += 2 + 0xfe00 - (*mqc->bp << 9);",
          "38:         }",
          "39:     } else {",
          "40:         mqc->bp++;",
          "41:         mqc->c += 1 + 0xff00 - (*mqc->bp << 8);",
          "42:     }",
          "43: }",
          "45: static int exchange(MqcState *mqc, uint8_t *cxstate, int lps)",
          "46: {",
          "47:     int d;",
          "48:     if ((mqc->a < ff_mqc_qe[*cxstate]) ^ (!lps)) {",
          "49:         if (lps)",
          "50:             mqc->a = ff_mqc_qe[*cxstate];",
          "51:         d = *cxstate & 1;",
          "53:     } else {",
          "54:         if (lps)",
          "55:             mqc->a = ff_mqc_qe[*cxstate];",
          "56:         d = 1 - (*cxstate & 1);",
          "58:     }",
          "60:     do {",
          "61:         if (!(mqc->c & 0xff)) {",
          "62:             mqc->c -= 0x100;",
          "63:             bytein(mqc);",
          "64:         }",
          "65:         mqc->a += mqc->a;",
          "66:         mqc->c += mqc->c;",
          "67:     } while (!(mqc->a & 0x8000));",
          "68:     return d;",
          "69: }",
          "71: void ff_mqc_initdec(MqcState *mqc, uint8_t *bp)",
          "72: {",
          "73:     ff_mqc_init_contexts(mqc);",
          "74:     mqc->bp = bp;",
          "75:     mqc->c  = (*mqc->bp ^ 0xff) << 16;",
          "76:     bytein(mqc);",
          "77:     mqc->c = mqc->c << 7;",
          "78:     mqc->a = 0x8000;",
          "79: }",
          "81: int ff_mqc_decode(MqcState *mqc, uint8_t *cxstate)",
          "82: {",
          "83:     mqc->a -= ff_mqc_qe[*cxstate];",
          "84:     if ((mqc->c >> 16) < mqc->a) {",
          "85:         if (mqc->a & 0x8000)",
          "86:             return *cxstate & 1;",
          "87:         else",
          "88:             return exchange(mqc, cxstate, 0);",
          "89:     } else {",
          "90:         mqc->c -= mqc->a << 16;",
          "91:         return exchange(mqc, cxstate, 1);",
          "92:     }",
          "93: }",
          "",
          "---------------"
        ],
        "tests/fate/video.mak||tests/fate/video.mak": [
          "File: tests/fate/video.mak -> tests/fate/video.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: FATE_SAMPLES_AVCONV-$(call DEMDEC, IPMOVIE, INTERPLAY_VIDEO) += fate-interplay-mve-16bit",
          "152: fate-interplay-mve-16bit: CMD = framecrc -i $(SAMPLES)/interplay-mve/descent3-level5-16bit-partial.mve -pix_fmt rgb24 -an",
          "154: FATE_SAMPLES_AVCONV-$(call DEMDEC, AVI, KGV1) += fate-kgv1",
          "155: fate-kgv1: CMD = framecrc -i $(SAMPLES)/kega/kgv1.avi -pix_fmt rgb555le -an",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154: FATE_SAMPLES_AVCONV-$(call DEMDEC, MXF, JPEG2000) += fate-jpeg2000-dcinema",
          "155: fate-jpeg2000-dcinema: CMD = framecrc -flags +bitexact -i $(SAMPLES)/jpeg2000/chiens_dcinema2K.mxf",
          "",
          "---------------"
        ]
      }
    }
  ]
}
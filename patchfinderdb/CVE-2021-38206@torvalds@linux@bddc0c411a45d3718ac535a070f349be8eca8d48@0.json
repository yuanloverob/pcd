{
  "cve_id": "CVE-2021-38206",
  "cve_desc": "The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates.",
  "repo": "torvalds/linux",
  "patch_hash": "bddc0c411a45d3718ac535a070f349be8eca8d48",
  "patch_info": {
    "commit_hash": "bddc0c411a45d3718ac535a070f349be8eca8d48",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bddc0c411a45d3718ac535a070f349be8eca8d48",
    "files": [
      "include/net/mac80211.h",
      "net/mac80211/tx.c"
    ],
    "message": "mac80211: Fix NULL ptr deref for injected rate info\n\nThe commit cb17ed29a7a5 (\"mac80211: parse radiotap header when selecting Tx\nqueue\") moved the code to validate the radiotap header from\nieee80211_monitor_start_xmit to ieee80211_parse_tx_radiotap. This made is\npossible to share more code with the new Tx queue selection code for\ninjected frames. But at the same time, it now required the call of\nieee80211_parse_tx_radiotap at the beginning of functions which wanted to\nhandle the radiotap header. And this broke the rate parser for radiotap\nheader parser.\n\nThe radiotap parser for rates is operating most of the time only on the\ndata in the actual radiotap header. But for the 802.11a/b/g rates, it must\nalso know the selected band from the chandef information. But this\ninformation is only written to the ieee80211_tx_info at the end of the\nieee80211_monitor_start_xmit - long after ieee80211_parse_tx_radiotap was\nalready called. The info->band information was therefore always 0\n(NL80211_BAND_2GHZ) when the parser code tried to access it.\n\nFor a 5GHz only device, injecting a frame with 802.11a rates would cause a\nNULL pointer dereference because local->hw.wiphy->bands[NL80211_BAND_2GHZ]\nwould most likely have been NULL when the radiotap parser searched for the\ncorrect rate index of the driver.\n\nCc: stable@vger.kernel.org\nReported-by: Ben Greear <greearb@candelatech.com>\nFixes: cb17ed29a7a5 (\"mac80211: parse radiotap header when selecting Tx queue\")\nSigned-off-by: Mathy Vanhoef <Mathy.Vanhoef@kuleuven.be>\n[sven@narfation.org: added commit message]\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nLink: https://lore.kernel.org/r/20210530133226.40587-1-sven@narfation.org\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "before_after_code_files": [
      "include/net/mac80211.h||include/net/mac80211.h",
      "net/mac80211/tx.c||net/mac80211/tx.c"
    ]
  },
  "patch_diff": {
    "include/net/mac80211.h||include/net/mac80211.h": [
      "File: include/net/mac80211.h -> include/net/mac80211.h"
    ],
    "net/mac80211/tx.c||net/mac80211/tx.c": [
      "File: net/mac80211/tx.c -> net/mac80211/tx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2014:  ieee80211_tx(sdata, sta, skb, false);",
      "2015: }",
      "2017: bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,",
      "2018:      struct net_device *dev)",
      "2019: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2017: static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)",
      "2018: {",
      "2019:  struct ieee80211_radiotap_header *rthdr =",
      "2020:   (struct ieee80211_radiotap_header *)skb->data;",
      "2023:  if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))",
      "2027:  if (unlikely(rthdr->it_version))",
      "2031:  if (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))",
      "2034:  return true;",
      "2035: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2022:  struct ieee80211_radiotap_header *rthdr =",
      "2023:   (struct ieee80211_radiotap_header *) skb->data;",
      "2024:  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);",
      "2027:  int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,",
      "2028:          NULL);",
      "2029:  u16 txflags;",
      "",
      "[Removed Lines]",
      "2025:  struct ieee80211_supported_band *sband =",
      "2026:   local->hw.wiphy->bands[info->band];",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2036:  u8 vht_mcs = 0, vht_nss = 0;",
      "2037:  int i;",
      "2051:  info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |",
      "2052:          IEEE80211_TX_CTL_DONTFRAG;",
      "",
      "[Removed Lines]",
      "2040:  if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))",
      "2044:  if (unlikely(rthdr->it_version))",
      "2048:  if (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))",
      "",
      "[Added Lines]",
      "2057:  if (!ieee80211_validate_radiotap_len(skb))",
      "2058:   return false;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2186:   return false;",
      "2188:  if (rate_found) {",
      "2189:   info->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;",
      "2191:   for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2198:   struct ieee80211_supported_band *sband =",
      "2199:    local->hw.wiphy->bands[info->band];",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2199:   } else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {",
      "2200:    ieee80211_rate_set_vht(info->control.rates, vht_mcs,",
      "2201:             vht_nss);",
      "2203:    for (i = 0; i < sband->n_bitrates; i++) {",
      "2204:     if (rate * 5 != sband->bitrates[i].bitrate)",
      "2205:      continue;",
      "",
      "[Removed Lines]",
      "2202:   } else {",
      "",
      "[Added Lines]",
      "2214:   } else if (sband) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2236:  info->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |",
      "2237:         IEEE80211_TX_CTL_INJECTED;",
      "2241:   goto fail;",
      "",
      "[Removed Lines]",
      "2240:  if (!ieee80211_parse_tx_radiotap(skb, dev))",
      "",
      "[Added Lines]",
      "2252:  if (!ieee80211_validate_radiotap_len(skb))",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2351:  ieee80211_select_queue_80211(sdata, skb, hdr);",
      "2352:  skb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));",
      "2355:  skb_pull(skb, len_rthdr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2371:  if (!ieee80211_parse_tx_radiotap(skb, dev))",
      "2372:   goto fail_rcu;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cb17ed29a7a5fea8c9bf70e8a05757d71650e025",
      "candidate_info": {
        "commit_hash": "cb17ed29a7a5fea8c9bf70e8a05757d71650e025",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cb17ed29a7a5fea8c9bf70e8a05757d71650e025",
        "files": [
          "include/net/mac80211.h",
          "net/mac80211/iface.c",
          "net/mac80211/tx.c"
        ],
        "message": "mac80211: parse radiotap header when selecting Tx queue\n\nAlready parse the radiotap header in ieee80211_monitor_select_queue.\nIn a subsequent commit this will allow us to add a radiotap flag that\ninfluences the queue on which injected packets will be sent.\n\nThis also fixes the incomplete validation of the injected frame in\nieee80211_monitor_select_queue: currently an out of bounds memory\naccess may occur in in the called function ieee80211_select_queue_80211\nif the 802.11 header is too small.\n\nNote that in ieee80211_monitor_start_xmit the radiotap header is parsed\nagain, which is necessairy because ieee80211_monitor_select_queue is not\nalways called beforehand.\n\nSigned-off-by: Mathy Vanhoef <Mathy.Vanhoef@kuleuven.be>\nLink: https://lore.kernel.org/r/20200723100153.31631-6-Mathy.Vanhoef@kuleuven.be\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
        "before_after_code_files": [
          "include/net/mac80211.h||include/net/mac80211.h",
          "net/mac80211/iface.c||net/mac80211/iface.c",
          "net/mac80211/tx.c||net/mac80211/tx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/mac80211.h||include/net/mac80211.h",
            "net/mac80211/tx.c||net/mac80211/tx.c"
          ],
          "candidate": [
            "include/net/mac80211.h||include/net/mac80211.h",
            "net/mac80211/tx.c||net/mac80211/tx.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/mac80211.h||include/net/mac80211.h": [
          "File: include/net/mac80211.h -> include/net/mac80211.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6238:          struct ieee80211_vif *vif, struct sk_buff *skb,",
          "6239:          int band, struct ieee80211_sta **sta);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6246: bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,",
          "6247:      struct net_device *dev);",
          "",
          "---------------"
        ],
        "net/mac80211/iface.c||net/mac80211/iface.c": [
          "File: net/mac80211/iface.c -> net/mac80211/iface.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1183: {",
          "1184:  struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);",
          "1185:  struct ieee80211_local *local = sdata->local;",
          "1186:  struct ieee80211_hdr *hdr;",
          "1189:  if (local->hw.queues < IEEE80211_NUM_ACS)",
          "1190:   return 0;",
          "1198:  return ieee80211_select_queue_80211(sdata, skb, hdr);",
          "1199: }",
          "",
          "[Removed Lines]",
          "1187:  struct ieee80211_radiotap_header *rtap = (void *)skb->data;",
          "1192:  if (skb->len < 4 ||",
          "1193:      skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)",
          "1196:  hdr = (void *)((u8 *)skb->data + le16_to_cpu(rtap->it_len));",
          "",
          "[Added Lines]",
          "1186:  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);",
          "1188:  int len_rthdr;",
          "1194:  memset(info, 0, sizeof(*info));",
          "1196:  if (!ieee80211_parse_tx_radiotap(skb, dev))",
          "1199:  len_rthdr = ieee80211_get_radiotap_len(skb->data);",
          "1200:  hdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);",
          "1201:  if (skb->len < len_rthdr + 2 ||",
          "1202:      skb->len < len_rthdr + ieee80211_hdrlen(hdr->frame_control))",
          "",
          "---------------"
        ],
        "net/mac80211/tx.c||net/mac80211/tx.c": [
          "File: net/mac80211/tx.c -> net/mac80211/tx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2015:  ieee80211_tx(sdata, sta, skb, false);",
          "2016: }",
          "2020: {",
          "2021:  struct ieee80211_radiotap_iterator iterator;",
          "2022:  struct ieee80211_radiotap_header *rthdr =",
          "2023:   (struct ieee80211_radiotap_header *) skb->data;",
          "",
          "[Removed Lines]",
          "2018: static bool ieee80211_parse_tx_radiotap(struct ieee80211_local *local,",
          "2019:      struct sk_buff *skb)",
          "",
          "[Added Lines]",
          "2018: bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,",
          "2019:      struct net_device *dev)",
          "2021:  struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2036:  u8 vht_mcs = 0, vht_nss = 0;",
          "2037:  int i;",
          "2039:  info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |",
          "2040:          IEEE80211_TX_CTL_DONTFRAG;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2041:  if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))",
          "2045:  if (unlikely(rthdr->it_version))",
          "2049:  if (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2189:            local->hw.max_rate_tries);",
          "2190:  }",
          "2199:  return true;",
          "2200: }",
          "",
          "[Removed Lines]",
          "2197:  skb_pull(skb, iterator._max_length);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2204: {",
          "2205:  struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);",
          "2206:  struct ieee80211_chanctx_conf *chanctx_conf;",
          "2209:  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);",
          "2210:  struct ieee80211_hdr *hdr;",
          "2211:  struct ieee80211_sub_if_data *tmp_sdata, *sdata;",
          "",
          "[Removed Lines]",
          "2207:  struct ieee80211_radiotap_header *prthdr =",
          "2208:   (struct ieee80211_radiotap_header *)skb->data;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2213:  u16 len_rthdr;",
          "2214:  int hdrlen;",
          "2225:  len_rthdr = ieee80211_get_radiotap_len(skb->data);",
          "",
          "[Removed Lines]",
          "2217:  if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))",
          "2221:  if (unlikely(prthdr->it_version))",
          "2228:  if (unlikely(skb->len < len_rthdr))",
          "",
          "[Added Lines]",
          "2220:  memset(info, 0, sizeof(*info));",
          "2221:  info->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |",
          "2222:         IEEE80211_TX_CTL_INJECTED;",
          "2225:  if (!ieee80211_parse_tx_radiotap(skb, dev))",
          "2226:   goto fail;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2273:   skb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;",
          "2274:  }",
          "2281:  rcu_read_lock();",
          "",
          "[Removed Lines]",
          "2276:  memset(info, 0, sizeof(*info));",
          "2278:  info->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |",
          "2279:         IEEE80211_TX_CTL_INJECTED;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2344:  info->band = chandef->chan->band;",
          "2350:  ieee80211_xmit(sdata, NULL, skb);",
          "2351:  rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "2347:  if (!ieee80211_parse_tx_radiotap(local, skb))",
          "2348:   goto fail_rcu;",
          "",
          "[Added Lines]",
          "2342:  skb_pull(skb, len_rthdr);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
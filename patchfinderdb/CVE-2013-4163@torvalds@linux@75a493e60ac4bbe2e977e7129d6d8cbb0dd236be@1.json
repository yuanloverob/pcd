{
  "cve_id": "CVE-2013-4163",
  "cve_desc": "The ip6_append_data_mtu function in net/ipv6/ip6_output.c in the IPv6 implementation in the Linux kernel through 3.10.3 does not properly maintain information about whether the IPV6_MTU setsockopt option had been specified, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call.",
  "repo": "torvalds/linux",
  "patch_hash": "75a493e60ac4bbe2e977e7129d6d8cbb0dd236be",
  "patch_info": {
    "commit_hash": "75a493e60ac4bbe2e977e7129d6d8cbb0dd236be",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be",
    "files": [
      "net/ipv6/ip6_output.c"
    ],
    "message": "ipv6: ip6_append_data_mtu did not care about pmtudisc and frag_size\n\nIf the socket had an IPV6_MTU value set, ip6_append_data_mtu lost track\nof this when appending the second frame on a corked socket. This results\nin the following splat:\n\n[37598.993962] ------------[ cut here ]------------\n[37598.994008] kernel BUG at net/core/skbuff.c:2064!\n[37598.994008] invalid opcode: 0000 [#1] SMP\n[37598.994008] Modules linked in: tcp_lp uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media vfat fat usb_storage fuse ebtable_nat xt_CHECKSUM bridge stp llc ipt_MASQUERADE nf_conntrack_netbios_ns nf_conntrack_broadcast ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat\n+nf_nat_ipv4 nf_nat iptable_mangle nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables be2iscsi iscsi_boot_sysfs bnx2i cnic uio cxgb4i cxgb4 cxgb3i cxgb3 mdio libcxgbi ib_iser rdma_cm ib_addr iw_cm ib_cm ib_sa ib_mad ib_core iscsi_tcp libiscsi_tcp libiscsi\n+scsi_transport_iscsi rfcomm bnep iTCO_wdt iTCO_vendor_support snd_hda_codec_conexant arc4 iwldvm mac80211 snd_hda_intel acpi_cpufreq mperf coretemp snd_hda_codec microcode cdc_wdm cdc_acm\n[37598.994008]  snd_hwdep cdc_ether snd_seq snd_seq_device usbnet mii joydev btusb snd_pcm bluetooth i2c_i801 e1000e lpc_ich mfd_core ptp iwlwifi pps_core snd_page_alloc mei cfg80211 snd_timer thinkpad_acpi snd tpm_tis soundcore rfkill tpm tpm_bios vhost_net tun macvtap macvlan kvm_intel kvm uinput binfmt_misc\n+dm_crypt i915 i2c_algo_bit drm_kms_helper drm i2c_core wmi video\n[37598.994008] CPU 0\n[37598.994008] Pid: 27320, comm: t2 Not tainted 3.9.6-200.fc18.x86_64 #1 LENOVO 27744PG/27744PG\n[37598.994008] RIP: 0010:[<ffffffff815443a5>]  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325/0x330\n[37598.994008] RSP: 0018:ffff88003670da18  EFLAGS: 00010202\n[37598.994008] RAX: ffff88018105c018 RBX: 0000000000000004 RCX: 00000000000006c0\n[37598.994008] RDX: ffff88018105a6c0 RSI: ffff88018105a000 RDI: ffff8801e1b0aa00\n[37598.994008] RBP: ffff88003670da78 R08: 0000000000000000 R09: ffff88018105c040\n[37598.994008] R10: ffff8801e1b0aa00 R11: 0000000000000000 R12: 000000000000fff8\n[37598.994008] R13: 00000000000004fc R14: 00000000ffff0504 R15: 0000000000000000\n[37598.994008] FS:  00007f28eea59740(0000) GS:ffff88023bc00000(0000) knlGS:0000000000000000\n[37598.994008] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[37598.994008] CR2: 0000003d935789e0 CR3: 00000000365cb000 CR4: 00000000000407f0\n[37598.994008] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[37598.994008] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[37598.994008] Process t2 (pid: 27320, threadinfo ffff88003670c000, task ffff88022c162ee0)\n[37598.994008] Stack:\n[37598.994008]  ffff88022e098a00 ffff88020f973fc0 0000000000000008 00000000000004c8\n[37598.994008]  ffff88020f973fc0 00000000000004c4 ffff88003670da78 ffff8801e1b0a200\n[37598.994008]  0000000000000018 00000000000004c8 ffff88020f973fc0 00000000000004c4\n[37598.994008] Call Trace:\n[37598.994008]  [<ffffffff815fc21f>] ip6_append_data+0xccf/0xfe0\n[37598.994008]  [<ffffffff8158d9f0>] ? ip_copy_metadata+0x1a0/0x1a0\n[37598.994008]  [<ffffffff81661f66>] ? _raw_spin_lock_bh+0x16/0x40\n[37598.994008]  [<ffffffff8161548d>] udpv6_sendmsg+0x1ed/0xc10\n[37598.994008]  [<ffffffff812a2845>] ? sock_has_perm+0x75/0x90\n[37598.994008]  [<ffffffff815c3693>] inet_sendmsg+0x63/0xb0\n[37598.994008]  [<ffffffff812a2973>] ? selinux_socket_sendmsg+0x23/0x30\n[37598.994008]  [<ffffffff8153a450>] sock_sendmsg+0xb0/0xe0\n[37598.994008]  [<ffffffff810135d1>] ? __switch_to+0x181/0x4a0\n[37598.994008]  [<ffffffff8153d97d>] sys_sendto+0x12d/0x180\n[37598.994008]  [<ffffffff810dfb64>] ? __audit_syscall_entry+0x94/0xf0\n[37598.994008]  [<ffffffff81020ed1>] ? syscall_trace_enter+0x231/0x240\n[37598.994008]  [<ffffffff8166a7e7>] tracesys+0xdd/0xe2\n[37598.994008] Code: fe 07 00 00 48 c7 c7 04 28 a6 81 89 45 a0 4c 89 4d b8 44 89 5d a8 e8 1b ac b1 ff 44 8b 5d a8 4c 8b 4d b8 8b 45 a0 e9 cf fe ff ff <0f> 0b 66 0f 1f 84 00 00 00 00 00 66 66 66 66 90 55 48 89 e5 48\n[37598.994008] RIP  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325/0x330\n[37598.994008]  RSP <ffff88003670da18>\n[37599.007323] ---[ end trace d69f6a17f8ac8eee ]---\n\nWhile there, also check if path mtu discovery is activated for this\nsocket. The logic was adapted from ip6_append_data when first writing\non the corked socket.\n\nThis bug was introduced with commit\n0c1833797a5a6ec23ea9261d979aa18078720b74 (\"ipv6: fix incorrect ipsec\nfragment\").\n\nv2:\na) Replace IPV6_PMTU_DISC_DO with IPV6_PMTUDISC_PROBE.\nb) Don't pass ipv6_pinfo to ip6_append_data_mtu (suggestion by Gao\n   feng, thanks!).\nc) Change mtu to unsigned int, else we get a warning about\n   non-matching types because of the min()-macro type-check.\n\nAcked-by: Gao feng <gaofeng@cn.fujitsu.com>\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
      "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1093:  return src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;",
      "1094: }",
      "1097:     int *maxfraglen,",
      "1098:     unsigned int fragheaderlen,",
      "1099:     struct sk_buff *skb,",
      "1101: {",
      "1102:  if (!(rt->dst.flags & DST_XFRM_TUNNEL)) {",
      "1103:   if (skb == NULL) {",
      "",
      "[Removed Lines]",
      "1096: static void ip6_append_data_mtu(int *mtu,",
      "1100:     struct rt6_info *rt)",
      "",
      "[Added Lines]",
      "1096: static void ip6_append_data_mtu(unsigned int *mtu,",
      "1100:     struct rt6_info *rt,",
      "1101:     bool pmtuprobe)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1113:   }",
      "1115:          + fragheaderlen - sizeof(struct frag_hdr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1114:        rt->dst.dev->mtu :",
      "1115:        dst_mtu(rt->dst.path));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1126:  struct ipv6_pinfo *np = inet6_sk(sk);",
      "1127:  struct inet_cork *cork;",
      "1128:  struct sk_buff *skb, *skb_prev = NULL;",
      "1130:  int exthdrlen;",
      "1131:  int dst_exthdrlen;",
      "1132:  int hh_len;",
      "1134:  int copy;",
      "1135:  int err;",
      "1136:  int offset = 0;",
      "",
      "[Removed Lines]",
      "1129:  unsigned int maxfraglen, fragheaderlen;",
      "1133:  int mtu;",
      "",
      "[Added Lines]",
      "1132:  unsigned int maxfraglen, fragheaderlen, mtu;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1288:    if (skb == NULL || skb_prev == NULL)",
      "1289:     ip6_append_data_mtu(&mtu, &maxfraglen,",
      "1292:    skb_prev = skb;",
      "",
      "[Removed Lines]",
      "1290:           fragheaderlen, skb, rt);",
      "",
      "[Added Lines]",
      "1292:           fragheaderlen, skb, rt,",
      "1293:           np->pmtudisc ==",
      "1294:           IPV6_PMTUDISC_PROBE);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cce606feb425093c8371089d392e336d186e125b",
      "candidate_info": {
        "commit_hash": "cce606feb425093c8371089d392e336d186e125b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cce606feb425093c8371089d392e336d186e125b",
        "files": [
          "arch/powerpc/kernel/smp.c"
        ],
        "message": "powerpc: Set cpu sibling mask before online cpu\n\nIt seems following race is possible:\n\n\tcpu0\t\t\t\t\tcpux\nsmp_init->cpu_up->_cpu_up\n\t__cpu_up\n\t\tkick_cpu(1)\n-------------------------------------------------------------------------\n\t\twaiting online\t\t\t...\n\t\t...\t\t\t\tnotify CPU_STARTING\n\t\t\t\t\t\t\tset cpux active\n\t\t\t\t\t\tset cpux online\n-------------------------------------------------------------------------\n\t\tfinish waiting online\n\t\t...\nsched_init_smp\n\tinit_sched_domains(cpu_active_mask)\n\t\tbuild_sched_domains\n\t\t\t\t\t\tset cpux sibling info\n-------------------------------------------------------------------------\n\nExecution of cpu0 and cpux could be concurrent between two separator\nlines.\n\nSo if the cpux sibling information was set too late (normally\nimpossible, but could be triggered by adding some delay in\nstart_secondary, after setting cpu online), build_sched_domains()\nrunning on cpu0 might see cpux active, with an empty sibling mask, then\ncause some bad address accessing like following:\n\n[    0.099855] Unable to handle kernel paging request for data at address 0xc00000038518078f\n[    0.099868] Faulting instruction address: 0xc0000000000b7a64\n[    0.099883] Oops: Kernel access of bad area, sig: 11 [#1]\n[    0.099895] PREEMPT SMP NR_CPUS=16 DEBUG_PAGEALLOC NUMA pSeries\n[    0.099922] Modules linked in:\n[    0.099940] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.10.0-rc1-00120-gb973425-dirty #16\n[    0.099956] task: c0000001fed80000 ti: c0000001fed7c000 task.ti: c0000001fed7c000\n[    0.099971] NIP: c0000000000b7a64 LR: c0000000000b7a40 CTR: c0000000000b4934\n[    0.099985] REGS: c0000001fed7f760 TRAP: 0300   Not tainted  (3.10.0-rc1-00120-gb973425-dirty)\n[    0.099997] MSR: 8000000000009032 <SF,EE,ME,IR,DR,RI>  CR: 24272828  XER: 20000003\n[    0.100045] SOFTE: 1\n[    0.100053] CFAR: c000000000445ee8\n[    0.100064] DAR: c00000038518078f, DSISR: 40000000\n[    0.100073]\nGPR00: 0000000000000080 c0000001fed7f9e0 c000000000c84d48 0000000000000010\nGPR04: 0000000000000010 0000000000000000 c0000001fc55e090 0000000000000000\nGPR08: ffffffffffffffff c000000000b80b30 c000000000c962d8 00000003845ffc5f\nGPR12: 0000000000000000 c00000000f33d000 c00000000000b9e4 0000000000000000\nGPR16: 0000000000000000 0000000000000000 0000000000000001 0000000000000000\nGPR20: c000000000ccf750 0000000000000000 c000000000c94d48 c0000001fc504000\nGPR24: c0000001fc504000 c0000001fecef848 c000000000c94d48 c000000000ccf000\nGPR28: c0000001fc522090 0000000000000010 c0000001fecef848 c0000001fed7fae0\n[    0.100293] NIP [c0000000000b7a64] .get_group+0x84/0xc4\n[    0.100307] LR [c0000000000b7a40] .get_group+0x60/0xc4\n[    0.100318] Call Trace:\n[    0.100332] [c0000001fed7f9e0] [c0000000000dbce4] .lock_is_held+0xa8/0xd0 (unreliable)\n[    0.100354] [c0000001fed7fa70] [c0000000000bf62c] .build_sched_domains+0x728/0xd14\n[    0.100375] [c0000001fed7fbe0] [c000000000af67bc] .sched_init_smp+0x4fc/0x654\n[    0.100394] [c0000001fed7fce0] [c000000000adce24] .kernel_init_freeable+0x17c/0x30c\n[    0.100413] [c0000001fed7fdb0] [c00000000000ba08] .kernel_init+0x24/0x12c\n[    0.100431] [c0000001fed7fe30] [c000000000009f74] .ret_from_kernel_thread+0x5c/0x68\n[    0.100445] Instruction dump:\n[    0.100456] 38800010 38a00000 4838e3f5 60000000 7c6307b4 2fbf0000 419e0040 3d220001\n[    0.100496] 78601f24 39491590 e93e0008 7d6a002a <7d69582a> f97f0000 7d4a002a e93e0010\n[    0.100559] ---[ end trace 31fd0ba7d8756001 ]---\n\nThis patch tries to move the sibling maps updating before\nnotify_cpu_starting() and cpu online, and a write barrier there to make\nsure sibling maps are updated before active and online mask.\n\nSigned-off-by: Li Zhong <zhong@linux.vnet.ibm.com>\nReviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>\nSigned-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>",
        "before_after_code_files": [
          "arch/powerpc/kernel/smp.c||arch/powerpc/kernel/smp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/kernel/smp.c||arch/powerpc/kernel/smp.c": [
          "File: arch/powerpc/kernel/smp.c -> arch/powerpc/kernel/smp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:  vdso_getcpu_init();",
          "639: #endif",
          "643:  base = cpu_first_thread_sibling(cpu);",
          "644:  for (i = 0; i < threads_per_core; i++) {",
          "646:    continue;",
          "647:   cpumask_set_cpu(cpu, cpu_sibling_mask(base + i));",
          "648:   cpumask_set_cpu(base + i, cpu_sibling_mask(cpu));",
          "",
          "[Removed Lines]",
          "640:  notify_cpu_starting(cpu);",
          "641:  set_cpu_online(cpu, true);",
          "645:   if (cpu_is_offline(base + i))",
          "",
          "[Added Lines]",
          "643:   if (cpu_is_offline(base + i) && (cpu != base + i))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "667:  }",
          "668:  of_node_put(l2_cache);",
          "670:  local_irq_enable();",
          "672:  cpu_startup_entry(CPUHP_ONLINE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "668:  smp_wmb();",
          "669:  notify_cpu_starting(cpu);",
          "670:  set_cpu_online(cpu, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a008ffa73b4401251d548c10cadac6f8a67cfb5",
      "candidate_info": {
        "commit_hash": "5a008ffa73b4401251d548c10cadac6f8a67cfb5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5a008ffa73b4401251d548c10cadac6f8a67cfb5",
        "files": [
          "drivers/net/usb/qmi_wwan.c"
        ],
        "message": "net: qmi_wwan: fixup Sierra Wireless MC8305 entry\n\nThe MC8305 module got an additional entry added based solely on\ninformation from a Windows driver *.inf file. We now have the\nactual descriptor layout from one of these modules, and it\nconsists of two alternate configurations where cfg #1 is a\nnormal Gobi 2k layout and cfg #2 is MBIM only, using interface\nnumbers 5 and 6 for MBIM control and data. The extra Windows\ndriver entry for interface number 5 was most likely a bug.\n\nDeleting the bogus entry to avoid unnecessary qmi_wwan probe\nfailures when using the MBIM configuration.\n\nReported-by: Lana Black <sickmind@lavabit.com>\nSigned-off-by: Bj\u00f8rn Mork <bjorn@mork.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/usb/qmi_wwan.c||drivers/net/usb/qmi_wwan.c": [
          "File: drivers/net/usb/qmi_wwan.c -> drivers/net/usb/qmi_wwan.c"
        ]
      }
    },
    {
      "candidate_hash": "4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
      "candidate_info": {
        "commit_hash": "4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4008bab7b3969ad9f9dd1d02096a3f0aa5610bd2",
        "files": [
          "mm/page_alloc.c"
        ],
        "message": "mm/page_alloc: factor out setting of pcp->high and pcp->batch\n\n\"Problems\" with the current code:\n\n1: there is a lack of synchronization in setting ->high and ->batch in\n   percpu_pagelist_fraction_sysctl_handler()\n\n2: stop_machine() in zone_pcp_update() is unnecissary.\n\n3: zone_pcp_update() does not consider the case where\n   percpu_pagelist_fraction is non-zero\n\nTo fix:\n\n1: add memory barriers, a safe ->batch value, an update side mutex when\n   updating ->high and ->batch, and use ACCESS_ONCE() for ->batch users\n   that expect a stable value.\n\n2: avoid draining pages in zone_pcp_update(), rely upon the memory\n   barriers added to fix #1\n\n3: factor out quite a few functions, and then call the appropriate one.\n\nNote that it results in a change to the behavior of zone_pcp_update(),\nwhich is used by memory_hotplug.  I'm rather certain that I've diserned\n(and preserved) the essential behavior (changing ->high and ->batch), and\nonly eliminated unneeded actions (draining the per cpu pages), but this\nmay not be the case.\n\nFurther note that the draining of pages that previously took place in\nzone_pcp_update() occured after repeated draining when attempting to\noffline a page, and after the offline has \"succeeded\".  It appears that\nthe draining was added to zone_pcp_update() to avoid refactoring\nsetup_pageset() into 2 funtions.\n\nThis patch:\n\nCreates pageset_set_batch() for use in setup_pageset().\npageset_set_batch() imitates the functionality of\nsetup_pagelist_highmark(), but uses the boot time\n(percpu_pagelist_fraction == 0) calculations for determining ->high based\non ->batch.\n\nSigned-off-by: Cody P Schafer <cody@linux.vnet.ibm.com>\nCc: Gilad Ben-Yossef <gilad@benyossef.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@gmail.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Pekka Enberg <penberg@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/page_alloc.c||mm/page_alloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4032: #endif",
          "4033: }",
          "4035: static void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)",
          "4036: {",
          "4037:  struct per_cpu_pages *pcp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4036: static void pageset_set_batch(struct per_cpu_pageset *p, unsigned long batch)",
          "4037: {",
          "4038:  struct per_cpu_pages *pcp = &p->pcp;",
          "4039:  pcp->high = 6 * batch;",
          "4040:  pcp->batch = max(1UL, 1 * batch);",
          "4041: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4042:  pcp = &p->pcp;",
          "4043:  pcp->count = 0;",
          "4046:  for (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)",
          "4047:   INIT_LIST_HEAD(&pcp->lists[migratetype]);",
          "4048: }",
          "",
          "[Removed Lines]",
          "4044:  pcp->high = 6 * batch;",
          "4045:  pcp->batch = max(1UL, 1 * batch);",
          "",
          "[Added Lines]",
          "4052:  pageset_set_batch(p, batch);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e2bd416f6246d11be29999c177d2534943a5c2df",
      "candidate_info": {
        "commit_hash": "e2bd416f6246d11be29999c177d2534943a5c2df",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e2bd416f6246d11be29999c177d2534943a5c2df",
        "files": [
          "kernel/cgroup.c"
        ],
        "message": "cgroup: fix deadlock on cgroup_mutex via drop_parsed_module_refcounts()\n\neb178d06332 (\"cgroup: grab cgroup_mutex in\ndrop_parsed_module_refcounts()\") made drop_parsed_module_refcounts()\ngrab cgroup_mutex to make lockdep assertion in for_each_subsys()\nhappy.  Unfortunately, cgroup_remount() calls the function while\nholding cgroup_mutex in its failure path leading to the following\ndeadlock.\n\n# mount -t cgroup -o remount,memory,blkio cgroup blkio\n\n cgroup: option changes via remount are deprecated (pid=525 comm=mount)\n\n =============================================\n [ INFO: possible recursive locking detected ]\n 3.10.0-rc4-work+ #1 Not tainted\n ---------------------------------------------\n mount/525 is trying to acquire lock:\n  (cgroup_mutex){+.+.+.}, at: [<ffffffff8110a3e1>] drop_parsed_module_refcounts+0x21/0xb0\n\n but task is already holding lock:\n  (cgroup_mutex){+.+.+.}, at: [<ffffffff8110e4e1>] cgroup_remount+0x51/0x200\n\n other info that might help us debug this:\n  Possible unsafe locking scenario:\n\n\tCPU0\n\t----\n   lock(cgroup_mutex);\n   lock(cgroup_mutex);\n\n  *** DEADLOCK ***\n\n  May be due to missing lock nesting notation\n\n 4 locks held by mount/525:\n  #0:  (&type->s_umount_key#30){+.+...}, at: [<ffffffff811e9a0d>] do_mount+0x2bd/0xa30\n  #1:  (&sb->s_type->i_mutex_key#9){+.+.+.}, at: [<ffffffff8110e4d3>] cgroup_remount+0x43/0x200\n  #2:  (cgroup_mutex){+.+.+.}, at: [<ffffffff8110e4e1>] cgroup_remount+0x51/0x200\n  #3:  (cgroup_root_mutex){+.+.+.}, at: [<ffffffff8110e4ef>] cgroup_remount+0x5f/0x200\n\n stack backtrace:\n CPU: 2 PID: 525 Comm: mount Not tainted 3.10.0-rc4-work+ #1\n Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011\n  ffffffff829651f0 ffff88000ec2fc28 ffffffff81c24bb1 ffff88000ec2fce8\n  ffffffff810f420d 0000000000000006 0000000000000001 0000000000000056\n  ffff8800153b4640 ffff880000000000 ffffffff81c2e468 ffff8800153b4640\n Call Trace:\n  [<ffffffff81c24bb1>] dump_stack+0x19/0x1b\n  [<ffffffff810f420d>] __lock_acquire+0x15dd/0x1e60\n  [<ffffffff810f531c>] lock_acquire+0x9c/0x1f0\n  [<ffffffff81c2a805>] mutex_lock_nested+0x65/0x410\n  [<ffffffff8110a3e1>] drop_parsed_module_refcounts+0x21/0xb0\n  [<ffffffff8110e63e>] cgroup_remount+0x1ae/0x200\n  [<ffffffff811c9bb2>] do_remount_sb+0x82/0x190\n  [<ffffffff811e9d41>] do_mount+0x5f1/0xa30\n  [<ffffffff811ea203>] SyS_mount+0x83/0xc0\n  [<ffffffff81c2fb82>] system_call_fastpath+0x16/0x1b\n\nFix it by moving the drop_parsed_module_refcounts() invocation outside\ncgroup_mutex.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>",
        "before_after_code_files": [
          "kernel/cgroup.c||kernel/cgroup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/cgroup.c||kernel/cgroup.c": [
          "File: kernel/cgroup.c -> kernel/cgroup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1365:  if (opts.flags != root->flags ||",
          "1366:      (opts.name && strcmp(opts.name, root->name))) {",
          "1367:   ret = -EINVAL;",
          "1369:   goto out_unlock;",
          "1370:  }",
          "",
          "[Removed Lines]",
          "1368:   drop_parsed_module_refcounts(opts.subsys_mask);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1380:  if (ret) {",
          "1382:   cgroup_populate_dir(cgrp, false, removed_mask);",
          "1384:   goto out_unlock;",
          "1385:  }",
          "",
          "[Removed Lines]",
          "1383:   drop_parsed_module_refcounts(opts.subsys_mask);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1395:  mutex_unlock(&cgroup_root_mutex);",
          "1396:  mutex_unlock(&cgroup_mutex);",
          "1397:  mutex_unlock(&cgrp->dentry->d_inode->i_mutex);",
          "1398:  return ret;",
          "1399: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1396:  if (ret)",
          "1397:   drop_parsed_module_refcounts(opts.subsys_mask);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
      "candidate_info": {
        "commit_hash": "8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
        "files": [
          "include/net/udp.h",
          "net/ipv4/udp.c",
          "net/ipv6/udp.c"
        ],
        "message": "ipv6: call udp_push_pending_frames when uncorking a socket with AF_INET pending data\n\nWe accidentally call down to ip6_push_pending_frames when uncorking\npending AF_INET data on a ipv6 socket. This results in the following\nsplat (from Dave Jones):\n\nskbuff: skb_under_panic: text:ffffffff816765f6 len:48 put:40 head:ffff88013deb6df0 data:ffff88013deb6dec tail:0x2c end:0xc0 dev:<NULL>\n------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:126!\ninvalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\nModules linked in: dccp_ipv4 dccp 8021q garp bridge stp dlci mpoa snd_seq_dummy sctp fuse hidp tun bnep nfnetlink scsi_transport_iscsi rfcomm can_raw can_bcm af_802154 appletalk caif_socket can caif ipt_ULOG x25 rose af_key pppoe pppox ipx phonet irda llc2 ppp_generic slhc p8023 psnap p8022 llc crc_ccitt atm bluetooth\n+netrom ax25 nfc rfkill rds af_rxrpc coretemp hwmon kvm_intel kvm crc32c_intel snd_hda_codec_realtek ghash_clmulni_intel microcode pcspkr snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep usb_debug snd_seq snd_seq_device snd_pcm e1000e snd_page_alloc snd_timer ptp snd pps_core soundcore xfs libcrc32c\nCPU: 2 PID: 8095 Comm: trinity-child2 Not tainted 3.10.0-rc7+ #37\ntask: ffff8801f52c2520 ti: ffff8801e6430000 task.ti: ffff8801e6430000\nRIP: 0010:[<ffffffff816e759c>]  [<ffffffff816e759c>] skb_panic+0x63/0x65\nRSP: 0018:ffff8801e6431de8  EFLAGS: 00010282\nRAX: 0000000000000086 RBX: ffff8802353d3cc0 RCX: 0000000000000006\nRDX: 0000000000003b90 RSI: ffff8801f52c2ca0 RDI: ffff8801f52c2520\nRBP: ffff8801e6431e08 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff88022ea0c800\nR13: ffff88022ea0cdf8 R14: ffff8802353ecb40 R15: ffffffff81cc7800\nFS:  00007f5720a10740(0000) GS:ffff880244c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000005862000 CR3: 000000022843c000 CR4: 00000000001407e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nStack:\n ffff88013deb6dec 000000000000002c 00000000000000c0 ffffffff81a3f6e4\n ffff8801e6431e18 ffffffff8159a9aa ffff8801e6431e90 ffffffff816765f6\n ffffffff810b756b 0000000700000002 ffff8801e6431e40 0000fea9292aa8c0\nCall Trace:\n [<ffffffff8159a9aa>] skb_push+0x3a/0x40\n [<ffffffff816765f6>] ip6_push_pending_frames+0x1f6/0x4d0\n [<ffffffff810b756b>] ? mark_held_locks+0xbb/0x140\n [<ffffffff81694919>] udp_v6_push_pending_frames+0x2b9/0x3d0\n [<ffffffff81694660>] ? udplite_getfrag+0x20/0x20\n [<ffffffff8162092a>] udp_lib_setsockopt+0x1aa/0x1f0\n [<ffffffff811cc5e7>] ? fget_light+0x387/0x4f0\n [<ffffffff816958a4>] udpv6_setsockopt+0x34/0x40\n [<ffffffff815949f4>] sock_common_setsockopt+0x14/0x20\n [<ffffffff81593c31>] SyS_setsockopt+0x71/0xd0\n [<ffffffff816f5d54>] tracesys+0xdd/0xe2\nCode: 00 00 48 89 44 24 10 8b 87 d8 00 00 00 48 89 44 24 08 48 8b 87 e8 00 00 00 48 c7 c7 c0 04 aa 81 48 89 04 24 31 c0 e8 e1 7e ff ff <0f> 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55\nRIP  [<ffffffff816e759c>] skb_panic+0x63/0x65\n RSP <ffff8801e6431de8>\n\nThis patch adds a check if the pending data is of address family AF_INET\nand directly calls udp_push_ending_frames from udp_v6_push_pending_frames\nif that is the case.\n\nThis bug was found by Dave Jones with trinity.\n\n(Also move the initialization of fl6 below the AF_INET check, even if\nnot strictly necessary.)\n\nCc: Dave Jones <davej@redhat.com>\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/udp.h||include/net/udp.h",
          "net/ipv4/udp.c||net/ipv4/udp.c",
          "net/ipv6/udp.c||net/ipv6/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/udp.h||include/net/udp.h": [
          "File: include/net/udp.h -> include/net/udp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "181: extern void udp_err(struct sk_buff *, u32);",
          "182: extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,",
          "183:        struct msghdr *msg, size_t len);",
          "184: extern void udp_flush_pending_frames(struct sock *sk);",
          "185: extern int udp_rcv(struct sk_buff *skb);",
          "186: extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "184: extern int udp_push_pending_frames(struct sock *sk);",
          "",
          "---------------"
        ],
        "net/ipv4/udp.c||net/ipv4/udp.c": [
          "File: net/ipv4/udp.c -> net/ipv4/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "804: {",
          "805:  struct udp_sock  *up = udp_sk(sk);",
          "806:  struct inet_sock *inet = inet_sk(sk);",
          "",
          "[Removed Lines]",
          "803: static int udp_push_pending_frames(struct sock *sk)",
          "",
          "[Added Lines]",
          "803: int udp_push_pending_frames(struct sock *sk)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "819:  up->pending = 0;",
          "820:  return err;",
          "821: }",
          "823: int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,",
          "824:   size_t len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "822: EXPORT_SYMBOL(udp_push_pending_frames);",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "959:  struct udphdr *uh;",
          "960:  struct udp_sock  *up = udp_sk(sk);",
          "961:  struct inet_sock *inet = inet_sk(sk);",
          "963:  int err = 0;",
          "964:  int is_udplite = IS_UDPLITE(sk);",
          "965:  __wsum csum = 0;",
          "968:  if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)",
          "969:   goto out;",
          "",
          "[Removed Lines]",
          "962:  struct flowi6 *fl6 = &inet->cork.fl.u.ip6;",
          "",
          "[Added Lines]",
          "962:  struct flowi6 *fl6;",
          "967:  if (up->pending == AF_INET)",
          "968:   return udp_push_pending_frames(sk);",
          "970:  fl6 = &inet->cork.fl.u.ip6;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "349d25dccfacb314dc54a809f7b54b641a3ee172",
      "candidate_info": {
        "commit_hash": "349d25dccfacb314dc54a809f7b54b641a3ee172",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/349d25dccfacb314dc54a809f7b54b641a3ee172",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix # matching logic\n\nE.g. given the expression `foo/#`:\n\n- `foo/bar` matches\n- `foo/` should not match\n- `foo` should not match\n\nPUBLISHED_FROM=40f3290cb9a478b22d9f1ab6382884b5de70e266",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9706: int mg_mqtt_match_topic_expression(struct mg_str exp, struct mg_str topic) {",
          "9708:   if (memchr(exp.p, '#', exp.len)) {",
          "9712:     }",
          "9713:   }",
          "9714:   return strncmp(topic.p, exp.p, exp.len) == 0;",
          "9715: }",
          "",
          "[Removed Lines]",
          "9709:     exp.len -= 2;",
          "9710:     if (topic.len < exp.len) {",
          "9711:       exp.len = topic.len;",
          "",
          "[Added Lines]",
          "9710:     exp.len -= 1;",
          "9715:     if (topic.len <= exp.len) {",
          "9716:       return 0;",
          "9720:     topic.len = exp.len;",
          "9721:   }",
          "9722:   if (topic.len != exp.len) {",
          "9723:     return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "474e065a3069e8b8280d5638b3459c699aee69dc",
      "candidate_info": {
        "commit_hash": "474e065a3069e8b8280d5638b3459c699aee69dc",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/474e065a3069e8b8280d5638b3459c699aee69dc",
        "files": [
          "mongoose.c",
          "mongoose.h"
        ],
        "message": "MAX_PATH_SIZE -> MG_MAX_PATH\n\nPUBLISHED_FROM=32bda9e86a11cad3b908d211a1f7bc9d27312874",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6992: static void mg_print_dir_entry(struct mg_connection *nc, const char *file_name,",
          "6993:                                cs_stat_t *stp) {",
          "6995:   int64_t fsize = stp->st_size;",
          "6996:   int is_dir = S_ISDIR(stp->st_mode);",
          "6997:   const char *slash = is_dir ? \"/\" : \"\";",
          "",
          "[Removed Lines]",
          "6994:   char size[64], mod[64], href[MAX_PATH_SIZE * 3], path[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "6994:   char size[64], mod[64], href[MG_MAX_PATH * 3], path[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7027:                               const struct mg_serve_http_opts *opts,",
          "7028:                               void (*func)(struct mg_connection *, const char *,",
          "7029:                                            cs_stat_t *)) {",
          "7031:   cs_stat_t st;",
          "7032:   struct dirent *dp;",
          "7033:   DIR *dirp;",
          "",
          "[Removed Lines]",
          "7030:   char path[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "7030:   char path[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8136: }",
          "8138: static void mg_abs_path(const char *utf8_path, char *abs_path, size_t len) {",
          "8140:   to_wchar(utf8_path, buf, ARRAY_SIZE(buf));",
          "8141:   GetFullPathNameW(buf, ARRAY_SIZE(buf2), buf2, NULL);",
          "8142:   WideCharToMultiByte(CP_UTF8, 0, buf2, wcslen(buf2) + 1, abs_path, len, 0, 0);",
          "",
          "[Removed Lines]",
          "8139:   wchar_t buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8139:   wchar_t buf[MG_MAX_PATH], buf2[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8148:   STARTUPINFOW si;",
          "8149:   PROCESS_INFORMATION pi;",
          "8150:   HANDLE a[2], b[2], me = GetCurrentProcess();",
          "8154:   DWORD flags = DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS;",
          "8155:   FILE *fp;",
          "",
          "[Removed Lines]",
          "8151:   wchar_t wcmd[MAX_PATH_SIZE], full_dir[MAX_PATH_SIZE];",
          "8152:   char buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE], buf5[MAX_PATH_SIZE],",
          "8153:       buf4[MAX_PATH_SIZE], cmdline[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8151:   wchar_t wcmd[MG_MAX_PATH], full_dir[MG_MAX_PATH];",
          "8152:   char buf[MG_MAX_PATH], buf2[MG_MAX_PATH], buf5[MG_MAX_PATH],",
          "8153:       buf4[MG_MAX_PATH], cmdline[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "8476:                                const struct http_message *hm,",
          "8477:                                const struct mg_serve_http_opts *opts) {",
          "8478:   struct mg_cgi_env_block blk;",
          "8480:   const char *p;",
          "8481:   sock_t fds[2];",
          "",
          "[Removed Lines]",
          "8479:   char dir[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8479:   char dir[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8567: static void mg_do_ssi_include(struct mg_connection *nc, struct http_message *hm,",
          "8568:                               const char *ssi, char *tag, int include_level,",
          "8569:                               const struct mg_serve_http_opts *opts) {",
          "8571:   FILE *fp;",
          "",
          "[Removed Lines]",
          "8570:   char file_name[BUFSIZ], path[MAX_PATH_SIZE], *p;",
          "",
          "[Added Lines]",
          "8570:   char file_name[MG_MAX_PATH], path[MG_MAX_PATH], *p;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8784: static void mg_print_props(struct mg_connection *nc, const char *name,",
          "8785:                            cs_stat_t *stp) {",
          "8788:   mg_gmt_time_string(mtime, sizeof(mtime), &t);",
          "8789:   mg_url_encode(name, strlen(name), buf, sizeof(buf));",
          "",
          "[Removed Lines]",
          "8786:   char mtime[64], buf[MAX_PATH_SIZE * 3];",
          "",
          "[Added Lines]",
          "8786:   char mtime[64], buf[MG_MAX_PATH * 3];",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "8821:       strcmp(opts->enable_directory_listing, \"yes\") != 0) {",
          "8822:     mg_printf(nc, \"%s\", \"HTTP/1.1 403 Directory Listing Denied\\r\\n\\r\\n\");",
          "8823:   } else {",
          "8825:     mg_send(nc, header, sizeof(header) - 1);",
          "8826:     snprintf(uri, sizeof(uri), \"%.*s\", (int) hm->uri.len, hm->uri.p);",
          "8827:     mg_print_props(nc, uri, stp);",
          "",
          "[Removed Lines]",
          "8824:     char uri[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8824:     char uri[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8889: static int mg_remove_directory(const struct mg_serve_http_opts *opts,",
          "8890:                                const char *dir) {",
          "8892:   struct dirent *dp;",
          "8893:   cs_stat_t st;",
          "8894:   DIR *dirp;",
          "",
          "[Removed Lines]",
          "8891:   char path[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8891:   char path[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8923:     const char *p = (char *) memchr(dest->p, '/', dest->len);",
          "8924:     if (p != NULL && p[1] == '/' &&",
          "8925:         (p = (char *) memchr(p + 2, '/', dest->p + dest->len - p)) != NULL) {",
          "8927:       snprintf(buf, sizeof(buf), \"%s%.*s\", opts->dav_document_root,",
          "8928:                (int) (dest->p + dest->len - p), p);",
          "8929:       if (rename(path, buf) == 0) {",
          "",
          "[Removed Lines]",
          "8926:       char buf[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8926:       char buf[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8961:   for (s = path + 1; *s != '\\0'; s++) {",
          "8962:     if (*s == '/') {",
          "8964:       cs_stat_t st;",
          "8965:       snprintf(buf, sizeof(buf), \"%.*s\", (int) (s - path), path);",
          "8966:       buf[sizeof(buf) - 1] = '\\0';",
          "",
          "[Removed Lines]",
          "8963:       char buf[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "8963:       char buf[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "9457: #if MG_ENABLE_FILESYSTEM && !defined(MG_USER_FILE_FUNCTIONS)",
          "9458: int mg_stat(const char *path, cs_stat_t *st) {",
          "9459: #ifdef _WIN32",
          "9461:   to_wchar(path, wpath, ARRAY_SIZE(wpath));",
          "9462:   DBG((\"[%ls] -> %d\", wpath, _wstati64(wpath, st)));",
          "9463:   return _wstati64(wpath, st);",
          "",
          "[Removed Lines]",
          "9460:   wchar_t wpath[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "9460:   wchar_t wpath[MG_MAX_PATH];",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "9469: FILE *mg_fopen(const char *path, const char *mode) {",
          "9470: #ifdef _WIN32",
          "9472:   to_wchar(path, wpath, ARRAY_SIZE(wpath));",
          "9473:   to_wchar(mode, wmode, ARRAY_SIZE(wmode));",
          "9474:   return _wfopen(wpath, wmode);",
          "",
          "[Removed Lines]",
          "9471:   wchar_t wpath[MAX_PATH_SIZE], wmode[10];",
          "",
          "[Added Lines]",
          "9471:   wchar_t wpath[MG_MAX_PATH], wmode[10];",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "9481: #if defined(_WIN32) && !defined(WINCE)",
          "9483:   to_wchar(path, wpath, ARRAY_SIZE(wpath));",
          "9484:   return _wopen(wpath, flag, mode);",
          "9485: #else",
          "",
          "[Removed Lines]",
          "9482:   wchar_t wpath[MAX_PATH_SIZE];",
          "",
          "[Added Lines]",
          "9482:   wchar_t wpath[MG_MAX_PATH];",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3891: extern \"C\" {",
          "3896: #endif",
          "",
          "[Removed Lines]",
          "3894: #ifndef MAX_PATH_SIZE",
          "3895: #define MAX_PATH_SIZE 500",
          "",
          "[Added Lines]",
          "3894: #ifndef MG_MAX_PATH",
          "3895: #ifdef PATH_MAX",
          "3896: #define MG_MAX_PATH PATH_MAX",
          "3897: #else",
          "3898: #define MG_MAX_PATH 256",
          "3899: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4123: #define MG_MAX_HTTP_REQUEST_SIZE 1024",
          "4124: #endif",
          "4134: #ifndef MG_MAX_HTTP_SEND_MBUF",
          "4135: #define MG_MAX_HTTP_SEND_MBUF 1024",
          "4136: #endif",
          "",
          "[Removed Lines]",
          "4126: #ifndef MG_MAX_PATH",
          "4127: #ifdef PATH_MAX",
          "4128: #define MG_MAX_PATH PATH_MAX",
          "4129: #else",
          "4130: #define MG_MAX_PATH 256",
          "4131: #endif",
          "4132: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2e2ad9a459522611620f33899a337d8d2fbf3a5",
      "candidate_info": {
        "commit_hash": "b2e2ad9a459522611620f33899a337d8d2fbf3a5",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/b2e2ad9a459522611620f33899a337d8d2fbf3a5",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix hexdump on ESP8266, deliver MG_EV_SEND [...]\n\n[...] after handing data off to LWIP, do not wait for ACK.\nWe don't do it in net_if_socket, don't do it here either.\nAlso prevents multiple send attempt on the same send_mbuf data.\n\nPUBLISHED_FROM=4e5a677ebda84af1514f34299e53ce856a537883",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9591: void mg_hexdump_connection(struct mg_connection *nc, const char *path,",
          "9592:                            const void *buf, int num_bytes, int ev) {",
          "9593:   FILE *fp = NULL;",
          "9596:   const char *tag = NULL;",
          "9597:   switch (ev) {",
          "9598:     case MG_EV_RECV:",
          "",
          "[Removed Lines]",
          "9594:   char *hexbuf, src[60], dst[60];",
          "9595:   int buf_size = num_bytes * 5 + 100;",
          "",
          "[Added Lines]",
          "9592:   char src[60], dst[60];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9630:                                                 MG_SOCK_STRINGIFY_PORT |",
          "9631:                                                 MG_SOCK_STRINGIFY_REMOTE);",
          "9632:   fprintf(fp, \"%lu %p %s %s %s %d\\n\", (unsigned long) mg_time(), (void *) nc,",
          "9638:   }",
          "9640: }",
          "9641: #endif",
          "",
          "[Removed Lines]",
          "9633:           src, tag, dst, num_bytes);",
          "9634:   if (num_bytes > 0 && (hexbuf = (char *) MG_MALLOC(buf_size)) != NULL) {",
          "9635:     mg_hexdump(buf, num_bytes, hexbuf, buf_size);",
          "9636:     fprintf(fp, \"%s\", hexbuf);",
          "9637:     MG_FREE(hexbuf);",
          "9639:   if (fp != stdin && fp != stdout) fclose(fp);",
          "",
          "[Added Lines]",
          "9630:           src, tag, dst, (int) num_bytes);",
          "9631:   if (num_bytes > 0) {",
          "9632:     mg_hexdumpf(fp, buf, num_bytes);",
          "9634:   if (fp != stdout && fp != stderr) fclose(fp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "13983: enum mg_sig_type {",
          "13984:   MG_SIG_CONNECT_RESULT = 1,",
          "13985:   MG_SIG_RECV = 2,",
          "13990: };",
          "13992: void mg_lwip_post_signal(enum mg_sig_type sig, struct mg_connection *nc);",
          "",
          "[Removed Lines]",
          "13986:   MG_SIG_SENT_CB = 3,",
          "13987:   MG_SIG_CLOSE_CONN = 4,",
          "13988:   MG_SIG_TOMBSTONE = 5,",
          "13989:   MG_SIG_ACCEPT = 6,",
          "",
          "[Added Lines]",
          "13981:   MG_SIG_CLOSE_CONN = 3,",
          "13982:   MG_SIG_TOMBSTONE = 4,",
          "13983:   MG_SIG_ACCEPT = 5,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "14206:                                  u16_t num_sent) {",
          "14207:   struct mg_connection *nc = (struct mg_connection *) arg;",
          "14208:   DBG((\"%p %p %u\", nc, tpcb, num_sent));",
          "14212:   }",
          "14217:   return ERR_OK;",
          "14218: }",
          "",
          "[Removed Lines]",
          "14209:   if (nc == NULL) {",
          "14210:     tcp_abort(tpcb);",
          "14211:     return ERR_ABRT;",
          "14213:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14214:   cs->num_sent += num_sent;",
          "14216:   mg_lwip_post_signal(MG_SIG_SENT_CB, nc);",
          "",
          "[Added Lines]",
          "14203:   if ((nc->flags & MG_F_SEND_AND_CLOSE) && !(nc->flags & MG_F_WANT_WRITE) &&",
          "14204:       nc->send_mbuf.len == 0 && tpcb->unacked == 0) {",
          "14205:     mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "14436:     len = MIN(len, (TCP_MSS - tpcb->unsent->len));",
          "14437:   }",
          "14438: #endif",
          "14447:   }",
          "14448:   return len;",
          "14449: }",
          "14452:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14480:     DBG((\"%p socket is not connected\", nc));",
          "14482:   }",
          "14483:   struct udp_pcb *upcb = cs->pcb.udp;",
          "14484:   struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);",
          "",
          "[Removed Lines]",
          "14439:   err_t err = tcp_write(tpcb, data, len, TCP_WRITE_FLAG_COPY);",
          "14440:   DBG((\"%p tcp_write %u = %d\", tpcb, len, err));",
          "14441:   if (err != ERR_OK) {",
          "14446:     return (err == ERR_MEM ? 0 : -1);",
          "14451: static void mg_lwip_send_more(struct mg_connection *nc) {",
          "14453:   if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {",
          "14454:     DBG((\"%p invalid socket\", nc));",
          "14455:     return;",
          "14456:   }",
          "14457:   int num_written = mg_lwip_tcp_write(nc, nc->send_mbuf.buf, nc->send_mbuf.len);",
          "14458:   DBG((\"%p mg_lwip_tcp_write %u = %d\", nc, nc->send_mbuf.len, num_written));",
          "14459:   if (num_written == 0) return;",
          "14460:   if (num_written < 0) {",
          "14461:     mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);",
          "14462:   }",
          "14463: }",
          "14465: void mg_lwip_if_tcp_send(struct mg_connection *nc, const void *buf,",
          "14466:                          size_t len) {",
          "14467:   mbuf_append(&nc->send_mbuf, buf, len);",
          "14468:   mg_lwip_mgr_schedule_poll(nc->mgr);",
          "14469: }",
          "14471: void mg_lwip_if_udp_send(struct mg_connection *nc, const void *buf,",
          "14472:                          size_t len) {",
          "14473:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "14474:   if (nc->sock == INVALID_SOCKET || cs->pcb.udp == NULL) {",
          "14481:     return;",
          "",
          "[Added Lines]",
          "14429:   cs->err = tcp_write(tpcb, data, len, TCP_WRITE_FLAG_COPY);",
          "14430:   DBG((\"%p tcp_write %u = %d\", tpcb, len, cs->err));",
          "14431:   if (cs->err != ERR_OK) {",
          "14436:     return (cs->err == ERR_MEM ? 0 : -1);",
          "14441: static int mg_lwip_udp_send(struct mg_connection *nc, const void *data,",
          "14442:                             uint16_t len) {",
          "14444:   if (cs->pcb.udp == NULL) {",
          "14451:     return -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "14486:   u16_t port = ntohs(nc->sa.sin.sin_port);",
          "14487:   if (p == NULL) {",
          "14488:     DBG((\"OOM\"));",
          "14490:   }",
          "14492:   cs->err = udp_sendto(upcb, p, (ip_addr_t *) ip, port);",
          "14493:   DBG((\"%p udp_sendto = %d\", nc, cs->err));",
          "14494:   pbuf_free(p);",
          "14497:   } else {",
          "14500:   }",
          "14501: }",
          "14503: void mg_lwip_if_recved(struct mg_connection *nc, size_t len) {",
          "14504:   if (nc->flags & MG_F_UDP) return;",
          "14505:   struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;",
          "",
          "[Removed Lines]",
          "14489:     return;",
          "14491:   memcpy(p->payload, buf, len);",
          "14495:   if (cs->err != ERR_OK) {",
          "14496:     mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);",
          "14498:     cs->num_sent += len;",
          "14499:     mg_lwip_post_signal(MG_SIG_SENT_CB, nc);",
          "",
          "[Added Lines]",
          "14459:     return 0;",
          "14461:   memcpy(p->payload, data, len);",
          "14465:   return (cs->err == ERR_OK ? len : -1);",
          "14466: }",
          "14468: static void mg_lwip_send_more(struct mg_connection *nc) {",
          "14469:   int num_sent = 0;",
          "14470:   if (nc->sock == INVALID_SOCKET) return;",
          "14471:   if (nc->flags & MG_F_UDP) {",
          "14472:     num_sent = mg_lwip_udp_send(nc, nc->send_mbuf.buf, nc->send_mbuf.len);",
          "14473:     DBG((\"%p mg_lwip_udp_send %u = %d\", nc, nc->send_mbuf.len, num_sent));",
          "14474:   } else {",
          "14475:     num_sent = mg_lwip_tcp_write(nc, nc->send_mbuf.buf, nc->send_mbuf.len);",
          "14476:     DBG((\"%p mg_lwip_tcp_write %u = %d\", nc, nc->send_mbuf.len, num_sent));",
          "14477:   }",
          "14478:   if (num_sent == 0) return;",
          "14479:   if (num_sent > 0) {",
          "14480:     mg_if_sent_cb(nc, num_sent);",
          "14482:     mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);",
          "14486: void mg_lwip_if_tcp_send(struct mg_connection *nc, const void *buf,",
          "14487:                          size_t len) {",
          "14488:   mbuf_append(&nc->send_mbuf, buf, len);",
          "14489:   mg_lwip_mgr_schedule_poll(nc->mgr);",
          "14490: }",
          "14492: void mg_lwip_if_udp_send(struct mg_connection *nc, const void *buf,",
          "14493:                          size_t len) {",
          "14494:   mbuf_append(&nc->send_mbuf, buf, len);",
          "14495:   mg_lwip_mgr_schedule_poll(nc->mgr);",
          "14496: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "14697:         }",
          "14698:         break;",
          "14699:       }",
          "14711:       case MG_SIG_TOMBSTONE: {",
          "14712:         break;",
          "14713:       }",
          "",
          "[Removed Lines]",
          "14700:       case MG_SIG_SENT_CB: {",
          "14701:         mg_if_sent_cb(nc, cs->num_sent);",
          "14702:         cs->num_sent = 0;",
          "14704:         if (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE) &&",
          "14705:             !(nc->flags & MG_F_WANT_WRITE)) {",
          "14706:           mg_close_conn(nc);",
          "14707:         }",
          "14709:         break;",
          "14710:       }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "14791:     } else",
          "14793:     {",
          "14796:       }",
          "14797:     }",
          "14798:     if (nc->sock != INVALID_SOCKET &&",
          "",
          "[Removed Lines]",
          "14794:       if (!(nc->flags & (MG_F_CONNECTING | MG_F_UDP))) {",
          "14795:         if (nc->send_mbuf.len > 0) mg_lwip_send_more(nc);",
          "",
          "[Added Lines]",
          "14778:       if (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING)) {",
          "14779:         mg_lwip_send_more(nc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "60c16bbb5d4ca7c6dbc735c3f4e12e0566c923ef",
      "candidate_info": {
        "commit_hash": "60c16bbb5d4ca7c6dbc735c3f4e12e0566c923ef",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/60c16bbb5d4ca7c6dbc735c3f4e12e0566c923ef",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix mos docker image name\n\nPUBLISHED_FROM=91016ab1629a65976d2cc2f00aec4e1667cb4a8f",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5826:     mbuf_remove(io, req_len);",
          "5827:   }",
          "5829: }",
          "5831: #define CONTENT_DISPOSITION \"Content-Disposition: \"",
          "",
          "[Removed Lines]",
          "5828: exit_mp:;",
          "",
          "[Added Lines]",
          "5828: exit_mp:",
          "5829:   ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7188:             if (*p == '\\0' || *p == DIRSEP",
          "7189: #ifdef _WIN32",
          "7192: #endif",
          "7193:                 ) {",
          "7194:               ok = 0;",
          "",
          "[Removed Lines]",
          "7191:                 || *p == '/'",
          "",
          "[Added Lines]",
          "7192:                 ||",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f9596cc1db51e76e563cd6811af8b2e1cfd32d99",
      "candidate_info": {
        "commit_hash": "f9596cc1db51e76e563cd6811af8b2e1cfd32d99",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/f9596cc1db51e76e563cd6811af8b2e1cfd32d99",
        "files": [
          "mongoose.c"
        ],
        "message": "Perform endpoint auth check on multipart requests\n\nhttps://github.com/cesanta/mongoose-os/issues/229#issuecomment-293613426\n\nPUBLISHED_FROM=1c34db7ab2598eca1db0266cc6cdd31c32a16fff",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5824:   struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);",
          "5825:   struct mg_str *ct;",
          "5826:   struct mbuf *io = &nc->recv_mbuf;",
          "5829:   char boundary[100];",
          "5830:   int boundary_len;",
          "",
          "[Removed Lines]",
          "5827:   void *user_data = nc->user_data;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5871:     ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);",
          "5872:     if (ep != NULL) {",
          "5873:       pd->endpoint_handler = ep->handler;",
          "5877:     }",
          "5882:     mbuf_remove(io, req_len);",
          "5883:   }",
          "",
          "[Removed Lines]",
          "5874: #if MG_ENABLE_CALLBACK_USERDATA",
          "5875:       user_data = ep->user_data;",
          "5876: #endif",
          "5879:     mg_call(nc, pd->endpoint_handler, user_data, MG_EV_HTTP_MULTIPART_REQUEST,",
          "5880:             hm);",
          "",
          "[Added Lines]",
          "5875:     mg_http_call_endpoint_handler(nc, MG_EV_HTTP_MULTIPART_REQUEST, hm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7944:   struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);",
          "7945:   void *user_data = nc->user_data;",
          "7948:     struct mg_http_endpoint *ep =",
          "7949:         mg_http_get_endpoint_handler(nc->listener, &hm->uri);",
          "7950:     if (ep != NULL) {",
          "",
          "[Removed Lines]",
          "7947:   if (ev == MG_EV_HTTP_REQUEST) {",
          "",
          "[Added Lines]",
          "7942:   if (ev == MG_EV_HTTP_REQUEST",
          "7943: #if MG_ENABLE_HTTP_STREAMING_MULTIPART",
          "7944:       || ev == MG_EV_HTTP_MULTIPART_REQUEST",
          "7945: #endif",
          "7946:       ) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
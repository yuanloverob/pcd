{
  "cve_id": "CVE-2017-16996",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.",
  "repo": "torvalds/linux",
  "patch_hash": "0c17d1d2c61936401f4702e1846e2c19b200f958",
  "patch_info": {
    "commit_hash": "0c17d1d2c61936401f4702e1846e2c19b200f958",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0c17d1d2c61936401f4702e1846e2c19b200f958",
    "files": [
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix incorrect tracking of register size truncation\n\nProperly handle register truncation to a smaller size.\n\nThe old code first mirrors the clearing of the high 32 bits in the bitwise\ntristate representation, which is correct. But then, it computes the new\narithmetic bounds as the intersection between the old arithmetic bounds and\nthe bounds resulting from the bitwise tristate representation. Therefore,\nwhen coerce_reg_to_32() is called on a number with bounds\n[0xffff'fff8, 0x1'0000'0007], the verifier computes\n[0xffff'fff8, 0xffff'ffff] as bounds of the truncated number.\nThis is incorrect: The truncated number could also be in the range [0, 7],\nand no meaningful arithmetic bounds can be computed in that case apart from\nthe obvious [0, 0xffff'ffff].\n\nStarting with v4.14, this is exploitable by unprivileged users as long as\nthe unprivileged_bpf_disabled sysctl isn't set.\n\nDebian assigned CVE-2017-16996 for this issue.\n\nv2:\n - flip the mask during arithmetic bounds calculation (Ben Hutchings)\nv3:\n - add CVE number (Ben Hutchings)\n\nFixes: b03c9f9fdc37 (\"bpf/verifier: track signed and unsigned min/max values\")\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1067:         strict);",
      "1068: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1073: static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)",
      "1074: {",
      "1075:  u64 mask;",
      "1078:  reg->var_off = tnum_cast(reg->var_off, size);",
      "1081:  mask = ((u64)1 << (size * 8)) - 1;",
      "1082:  if ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {",
      "1083:   reg->umin_value &= mask;",
      "1084:   reg->umax_value &= mask;",
      "1085:  } else {",
      "1086:   reg->umin_value = 0;",
      "1087:   reg->umax_value = mask;",
      "1088:  }",
      "1089:  reg->smin_value = reg->umin_value;",
      "1090:  reg->smax_value = reg->umax_value;",
      "1091: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1200:  if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&",
      "1201:      regs[value_regno].type == SCALAR_VALUE) {",
      "1206:  }",
      "1207:  return err;",
      "1208: }",
      "",
      "[Removed Lines]",
      "1203:   regs[value_regno].var_off =",
      "1204:    tnum_cast(regs[value_regno].var_off, size);",
      "1205:   __update_reg_bounds(&regs[value_regno]);",
      "",
      "[Added Lines]",
      "1226:   coerce_reg_to_size(&regs[value_regno], size);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1772:  return 0;",
      "1773: }",
      "1783: static bool signed_add_overflows(s64 a, s64 b)",
      "1784: {",
      "",
      "[Removed Lines]",
      "1775: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
      "1776: {",
      "1778:  reg->var_off = tnum_cast(reg->var_off, 4);",
      "1780:  __update_reg_bounds(reg);",
      "1781: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2018:  if (BPF_CLASS(insn->code) != BPF_ALU64) {",
      "2022:  }",
      "2023:  smin_val = src_reg.smin_value;",
      "2024:  smax_val = src_reg.smax_value;",
      "",
      "[Removed Lines]",
      "2020:   coerce_reg_to_32(dst_reg);",
      "2021:   coerce_reg_to_32(&src_reg);",
      "",
      "[Added Lines]",
      "2033:   coerce_reg_to_size(dst_reg, 4);",
      "2034:   coerce_reg_to_size(&src_reg, 4);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2398:      return -EACCES;",
      "2399:     }",
      "2400:     mark_reg_unknown(env, regs, insn->dst_reg);",
      "2405:    }",
      "2406:   } else {",
      "",
      "[Removed Lines]",
      "2402:     regs[insn->dst_reg].var_off = tnum_cast(",
      "2403:       regs[insn->dst_reg].var_off, 4);",
      "2404:     __update_reg_bounds(&regs[insn->dst_reg]);",
      "",
      "[Added Lines]",
      "2414:     coerce_reg_to_size(&regs[insn->dst_reg], 4);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8fe2d6ccd52b086268f2f36e5e2fc0fe3aeffa80",
      "candidate_info": {
        "commit_hash": "8fe2d6ccd52b086268f2f36e5e2fc0fe3aeffa80",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8fe2d6ccd52b086268f2f36e5e2fc0fe3aeffa80",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: fix liveness marking\n\nwhile processing Rx = Ry instruction the verifier does\nregs[insn->dst_reg] = regs[insn->src_reg]\nwhich often clears write mark (when Ry doesn't have it)\nthat was just set by check_reg_arg(Rx) prior to the assignment.\nThat causes mark_reg_read() to keep marking Rx in this block as\nREG_LIVE_READ (since the logic incorrectly misses that it's\nscreened by the write) and in many of its parents (until lucky\nwrite into the same Rx or beginning of the program).\nThat causes is_state_visited() logic to miss many pruning opportunities.\n\nFurthermore mark_reg_read() logic propagates the read mark\nfor BPF_REG_FP as well (though it's readonly) which causes\nharmless but unnecssary work during is_state_visited().\nNote that do_propagate_liveness() skips FP correctly,\nso do the same in mark_reg_read() as well.\nIt saves 0.2 seconds for the test below\n\nprogram               before  after\nbpf_lb-DLB_L3.o       2604    2304\nbpf_lb-DLB_L4.o       11159   3723\nbpf_lb-DUNKNOWN.o     1116    1110\nbpf_lxc-DDROP_ALL.o   34566   28004\nbpf_lxc-DUNKNOWN.o    53267   39026\nbpf_netdev.o          17843   16943\nbpf_overlay.o         8672    7929\ntime                  ~11 sec  ~4 sec\n\nFixes: dc503a8ad984 (\"bpf/verifier: track liveness for pruning\")\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Edward Cree <ecree@solarflare.com>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "653: {",
          "654:  struct bpf_verifier_state *parent = state->parent;",
          "656:  while (parent) {",
          "658:   if (state->regs[regno].live & REG_LIVE_WRITTEN)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656:  if (regno == BPF_REG_FP)",
          "658:   return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2347:     regs[insn->dst_reg] = regs[insn->src_reg];",
          "2348:    } else {",
          "2350:     if (is_pointer_value(env, insn->src_reg)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2352:     regs[insn->dst_reg].live |= REG_LIVE_WRITTEN;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "81ed18ab3098b6519274545e80a29caacb77d160",
      "candidate_info": {
        "commit_hash": "81ed18ab3098b6519274545e80a29caacb77d160",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/81ed18ab3098b6519274545e80a29caacb77d160",
        "files": [
          "include/linux/bpf.h",
          "include/linux/bpf_verifier.h",
          "include/linux/filter.h",
          "kernel/bpf/arraymap.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: add helper inlining infra and optimize map_array lookup\n\nOptimize bpf_call -> bpf_map_lookup_elem() -> array_map_lookup_elem()\ninto a sequence of bpf instructions.\nWhen JIT is on the sequence of bpf instructions is the sequence\nof native cpu instructions with significantly faster performance\nthan indirect call and two function's prologue/epilogue.\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/bpf.h||include/linux/bpf.h",
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "include/linux/filter.h||include/linux/filter.h",
          "kernel/bpf/arraymap.c||kernel/bpf/arraymap.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf.h||include/linux/bpf.h": [
          "File: include/linux/bpf.h -> include/linux/bpf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:  void *(*map_fd_get_ptr)(struct bpf_map *map, struct file *map_file,",
          "36:     int fd);",
          "37:  void (*map_fd_put_ptr)(void *ptr);",
          "38: };",
          "40: struct bpf_map {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38:  u32 (*map_gen_lookup)(struct bpf_map *map, struct bpf_insn *insn_buf);",
          "",
          "---------------"
        ],
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: };",
          "68: struct bpf_insn_aux_data {",
          "70: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "69:  union {",
          "72:  };",
          "",
          "---------------"
        ],
        "include/linux/filter.h||include/linux/filter.h": [
          "File: include/linux/filter.h -> include/linux/filter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "693: # endif",
          "694: }",
          "696: static inline bool bpf_prog_ebpf_jited(const struct bpf_prog *fp)",
          "697: {",
          "698:  return fp->jited && bpf_jit_is_ebpf();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696: static inline bool ebpf_jit_enabled(void)",
          "697: {",
          "698:  return bpf_jit_enable && bpf_jit_is_ebpf();",
          "699: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "756: static inline bool bpf_prog_ebpf_jited(const struct bpf_prog *fp)",
          "757: {",
          "758:  return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "761: static inline bool ebpf_jit_enabled(void)",
          "762: {",
          "763:  return false;",
          "764: }",
          "",
          "---------------"
        ],
        "kernel/bpf/arraymap.c||kernel/bpf/arraymap.c": [
          "File: kernel/bpf/arraymap.c -> kernel/bpf/arraymap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:  return array->value + array->elem_size * index;",
          "114: }",
          "117: static void *percpu_array_map_lookup_elem(struct bpf_map *map, void *key)",
          "118: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118: static u32 array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)",
          "119: {",
          "120:  struct bpf_array *array = container_of(map, struct bpf_array, map);",
          "121:  struct bpf_insn *insn = insn_buf;",
          "122:  u32 elem_size = array->elem_size;",
          "123:  const int ret = BPF_REG_0;",
          "124:  const int map_ptr = BPF_REG_1;",
          "125:  const int index = BPF_REG_2;",
          "130:          elem_size == 1 ? 2 : 3);",
          "131:  if (elem_size == 1) {",
          "133:  } else if (is_power_of_2(elem_size)) {",
          "135:  } else {",
          "137:  }",
          "141:  return insn - insn_buf;",
          "142: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "267:  .map_lookup_elem = array_map_lookup_elem,",
          "268:  .map_update_elem = array_map_update_elem,",
          "269:  .map_delete_elem = array_map_delete_elem,",
          "270: };",
          "272: static struct bpf_map_type_list array_type __ro_after_init = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "298:  .map_gen_lookup = array_map_gen_lookup,",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1273:  }",
          "1274: }",
          "1277: {",
          "1278:  struct bpf_verifier_state *state = &env->cur_state;",
          "1279:  const struct bpf_func_proto *fn = NULL;",
          "",
          "[Removed Lines]",
          "1276: static int check_call(struct bpf_verifier_env *env, int func_id)",
          "",
          "[Added Lines]",
          "1276: static int check_call(struct bpf_verifier_env *env, int func_id, int insn_idx)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1369:   }",
          "1370:   regs[BPF_REG_0].map_ptr = meta.map_ptr;",
          "1371:   regs[BPF_REG_0].id = ++env->id_gen;",
          "1372:  } else {",
          "1373:   verbose(\"unknown return type %d of func %s#%d\\n\",",
          "1374:    fn->ret_type, func_id_name(func_id), func_id);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1372:   env->insn_aux_data[insn_idx].map_ptr = meta.map_ptr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2940:      return -EINVAL;",
          "2941:     }",
          "2944:     if (err)",
          "2945:      return err;",
          "",
          "[Removed Lines]",
          "2943:     err = check_call(env, insn->imm);",
          "",
          "[Added Lines]",
          "2944:     err = check_call(env, insn->imm, insn_idx);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3277:  struct bpf_insn *insn = prog->insnsi;",
          "3278:  const struct bpf_func_proto *fn;",
          "3279:  const int insn_cnt = prog->len;",
          "3282:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "3283:   if (insn->code != (BPF_JMP | BPF_CALL))",
          "",
          "[Removed Lines]",
          "3280:  int i;",
          "",
          "[Added Lines]",
          "3282:  struct bpf_insn insn_buf[16];",
          "3283:  struct bpf_prog *new_prog;",
          "3284:  struct bpf_map *map_ptr;",
          "3285:  int i, cnt, delta = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3300:    continue;",
          "3301:   }",
          "3303:   fn = prog->aux->ops->get_func_proto(insn->imm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3308:   if (ebpf_jit_enabled() && insn->imm == BPF_FUNC_map_lookup_elem) {",
          "3309:    map_ptr = env->insn_aux_data[i + delta].map_ptr;",
          "3310:    if (!map_ptr->ops->map_gen_lookup)",
          "3311:     goto patch_call_imm;",
          "3313:    cnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);",
          "3314:    if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {",
          "3315:     verbose(\"bpf verifier is misconfigured\\n\");",
          "3316:     return -EINVAL;",
          "3317:    }",
          "3319:    new_prog = bpf_patch_insn_data(env, i + delta, insn_buf,",
          "3320:              cnt);",
          "3321:    if (!new_prog)",
          "3322:     return -ENOMEM;",
          "3324:    delta += cnt - 1;",
          "3327:    env->prog = prog = new_prog;",
          "3328:    insn      = new_prog->insnsi + i + delta;",
          "3329:    continue;",
          "3330:   }",
          "3332: patch_call_imm:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
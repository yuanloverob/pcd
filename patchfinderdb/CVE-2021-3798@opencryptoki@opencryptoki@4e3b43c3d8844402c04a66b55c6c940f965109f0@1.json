{
  "cve_id": "CVE-2021-3798",
  "cve_desc": "A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.",
  "repo": "opencryptoki/opencryptoki",
  "patch_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "patch_info": {
    "commit_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "repo": "opencryptoki/opencryptoki",
    "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0",
    "files": [
      "usr/lib/soft_stdll/soft_specific.c"
    ],
    "message": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey\n\nWhen constructing an OpenSSL EC public or private key from PKCS#11\nattributes or ECDH public data, check that the key is valid, i.e. that\nthe point is on the curve.\n\nThis prevents one from creating an EC key object via C_CreateObject with\ninvalid key data. It also prevents C_DeriveKey to derive a secret using\nECDH with an EC public key (public data) that uses a different curve\nor is invalid by other means.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
    "before_after_code_files": [
      "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c"
    ]
  },
  "patch_diff": {
    "usr/lib/soft_stdll/soft_specific.c||usr/lib/soft_stdll/soft_specific.c": [
      "File: usr/lib/soft_stdll/soft_specific.c -> usr/lib/soft_stdll/soft_specific.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4365:         goto out;",
      "4366:     }",
      "4368: out:",
      "4369:     if (allocated && ecpoint != NULL)",
      "4370:         free(ecpoint);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4368:     if (!EC_KEY_check_key(ec_key)) {",
      "4369:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4370:         rc = CKR_PUBLIC_KEY_INVALID;",
      "4371:         goto out;",
      "4372:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4404:         goto out;",
      "4405:     }",
      "4407: out:",
      "4408:     if (point != NULL)",
      "4409:         EC_POINT_free(point);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4413:     if (!EC_KEY_check_key(ec_key)) {",
      "4414:         TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "4415:         rc = CKR_FUNCTION_FAILED;",
      "4416:         goto out;",
      "4417:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "05fcd2b1d8b2a913e1d616424d8b60301b5b1bbb",
      "candidate_info": {
        "commit_hash": "05fcd2b1d8b2a913e1d616424d8b60301b5b1bbb",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/05fcd2b1d8b2a913e1d616424d8b60301b5b1bbb",
        "files": [
          "usr/lib/ep11_stdll/ep11_specific.c"
        ],
        "message": "[EP11] Fix memory leak reported by LSAN\n\nLSAN on `pkcsconf -t` reported leak in EP11:\n\n```\n==571289==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 88 byte(s) in 1 object(s) allocated from:\n    #0 0x3ff915b085d in __interceptor_malloc (/usr/lib64/libasan.so.6+0xb085d)\n    #1 0x3ff89f191bf in build_attribute usr/lib/common/utility.c:520\n    #2 0x3ff89f5c9d5 in ep11tok_pkey_skey2pkey usr/lib/ep11_stdll/ep11_specific.c:698\n    #3 0x3ff89faedc7 in ep11tok_pkey_get_firmware_mk_vp usr/lib/ep11_stdll/ep11_specific.c:770\n    #4 0x3ff89fb10ad in ep11tok_init usr/lib/ep11_stdll/ep11_specific.c:2639\n    #5 0x3ff89f47987 in ST_Initialize usr/lib/ep11_stdll/new_host.c:163\n    #6 0x3ff8c45a6a1 in DL_Load_and_Init usr/lib/api/apiutil.c:599\n    #7 0x3ff8c452ea5 in C_Initialize usr/lib/api/api_interface.c:3009\n    #8 0x100b9e7 in init usr/sbin/pkcsconf/pkcsconf.c:1145\n    #9 0x100247b in main usr/sbin/pkcsconf/pkcsconf.c:186\n    #10 0x3ff904abdb3 in __libc_start_main (/usr/lib64/libc.so.6+0x2bdb3)\n    #11 0x1003aad  (/usr/local/sbin/pkcsconf+0x1003aad)\n```\n\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c": [
          "File: usr/lib/ep11_stdll/ep11_specific.c -> usr/lib/ep11_stdll/ep11_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "783:     if (blob_attr)",
          "784:         free(blob_attr);",
          "786:     put_target_info(tokdata, target_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "785:     if (pkey_attr)",
          "786:         free(pkey_attr);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dc851deba4abd523efed0086c800c638306187c8",
      "candidate_info": {
        "commit_hash": "dc851deba4abd523efed0086c800c638306187c8",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/dc851deba4abd523efed0086c800c638306187c8",
        "files": [
          "usr/lib/cca_stdll/cca_specific.c",
          "usr/lib/cca_stdll/cca_stdll.h",
          "usr/lib/common/key.c",
          "usr/lib/common/new_host.c",
          "usr/lib/common/template.c",
          "usr/lib/ep11_stdll/new_host.c",
          "usr/lib/icsf_stdll/new_host.c"
        ],
        "message": "CCA: support import of raw cca tokens with C_ObjectCreate via CKA_IBM_OPAQUE\n\nThe secure key blob for all the keys used with the CCA token is\nstored in an attribute CKA_IBM_OPAQUE. The content is a so called\nsecure CCA key token and a description can be found in the\n  \"Secure Key Solution with the Common Cryptographic\n   Architecture Application Programmer's Guide\".\n\nThere is a requirement to export and import these raw secure key token\nobjects. Export is simple: Just fetch the value the CKA_IBM_OPAQUE\nattribute for a key object and dump it for example into a file.\nImporting such a value was until now not supported. This patch\nenables the possibility to import such a raw CCA key token object with\nthe C_CreateObject() pkcs#11 function.\n\nTo import an CCA DES key token, use a template with these mandatory\nattributes:\n  CKA_CLASS = CKO_SECRET_KEY\n  CK_KEY_TYPE = CKK_DES\n  CKA_IBM_OPAQUE - with the CCA DES key token\n\nto import an CCA DES3 key token, use a template with these mandatory\nattributes:\n  CKA_CLASS = CKO_SECRET_KEY\n  CK_KEY_TYPE = CKK_DES3\n  CKA_IBM_OPAQUE - with the CCA DES3 key token\n\nto import an CCA AES data key token, use a template with these mandatory\nattributes:\n  CKA_CLASS = CKO_SECRET_KEY\n  CK_KEY_TYPE = CKK_AES\n  CKA_IBM_OPAQUE - with the CCA AES data key token\n\nCCA AES cipher key token import is not supported yet.\n\nto import an CCA internal RSA private key token, use a template with\nthese mandatory attributes:\n  CKA_CLASS = CKO_PRIVATE_KEY\n  CKA_KEY_TYPE = CKK_RSA\n  CKA_IBM_OPAQUE - with the CCA RSA private key token\n\nto import an CCA RSA public key token, use a template with these\nmandatory attributes:\n  CKA_CLASS = CKO_PUBLIC_KEY\n  CKA_KEY_TYPE = CKK_RSA\n  CKA_IBM_OPAQUE - with the CCA RSA public key token\n\nto import an CCA HMAC key token, use a template with these mandatory\nattributes:\n  CKA_CLASS = CKO_SECRET_KEY\n  CKA_KEY_TYPE = CKK_GENERIC_SECRET\n  CKA_VALUE - with a dummy value the size in bytes of the clear key\n\t      byte size.\n  CKA_IBM_OPAQUE with the CCA RSA private key token.\n\nto import an CCA internal EC private key token, use a template with\nthese mandatory attributes:\n  CKA_CLASS = CKO_PRIVATE_KEY\n  CKA_KEY_TYPE = CKK_EC\n  CKA_IBM_OPAQUE - with the CCA EC private key token\n\nto import an CCA EC public key token, use a template with these\nmandatory attributes:\n  CKA_CLASS = CKO_PUBLIC_KEY\n  CKA_KEY_TYPE = CKK_EC\n  CKA_IBM_OPAQUE - with the CCA EC public key token\n\nSigned-off-by: Harald Freudenberger <freude@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/cca_stdll/cca_specific.c||usr/lib/cca_stdll/cca_specific.c",
          "usr/lib/cca_stdll/cca_stdll.h||usr/lib/cca_stdll/cca_stdll.h",
          "usr/lib/common/key.c||usr/lib/common/key.c",
          "usr/lib/common/new_host.c||usr/lib/common/new_host.c",
          "usr/lib/common/template.c||usr/lib/common/template.c",
          "usr/lib/ep11_stdll/new_host.c||usr/lib/ep11_stdll/new_host.c",
          "usr/lib/icsf_stdll/new_host.c||usr/lib/icsf_stdll/new_host.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/cca_stdll/cca_specific.c||usr/lib/cca_stdll/cca_specific.c": [
          "File: usr/lib/cca_stdll/cca_specific.c -> usr/lib/cca_stdll/cca_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238: static const CK_ULONG cca_mech_list_len =",
          "239:                         (sizeof(cca_mech_list) / sizeof(MECH_LIST_ELEMENT));",
          "243: static CK_RV build_update_attribute(TEMPLATE * tmpl,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242: enum cca_token_type {",
          "243:     sec_des_data_key,",
          "244:     sec_aes_data_key,",
          "245:     sec_aes_cipher_key,",
          "246:     sec_hmac_key,",
          "247:     sec_rsa_priv_key,",
          "248:     sec_rsa_publ_key,",
          "249:     sec_ecc_priv_key,",
          "250:     sec_ecc_publ_key",
          "251: };",
          "258: static CK_BBOOL analyse_cca_key_token(const CK_BYTE *t, CK_ULONG tlen,",
          "259:                                       enum cca_token_type *keytype,",
          "260:                                       unsigned int *keybitsize)",
          "261: {",
          "262:     if (t[0] == 0x01 && (t[4] == 0x00 || t[4] == 0x01)) {",
          "264:         if (tlen != 64) {",
          "265:             TRACE_DEVEL(\"CCA DES token has invalid token size %lu != 64\\n\", tlen);",
          "266:             return FALSE;",
          "267:         }",
          "269:         if (t[4] == 0x00)",
          "271:         else if (t[59] == 0x10)",
          "273:         else if (t[59] == 0x20)",
          "275:         else {",
          "276:             TRACE_DEVEL(\"CCA DES data key token has invalid/unknown keysize 0x%02x\\n\", (int)t[59]);",
          "277:             return FALSE;",
          "278:         }",
          "279:         return TRUE;",
          "280:     }",
          "282:     if (t[0] == 0x01 && t[4] == 0x04) {",
          "284:         if (tlen != 64) {",
          "285:             TRACE_DEVEL(\"CCA AES data key token has invalid token size %lu != 64\\n\", tlen);",
          "286:             return FALSE;",
          "287:         }",
          "290:         if (*keybitsize != 128 && *keybitsize != 192 && *keybitsize != 256) {",
          "291:             TRACE_DEVEL(\"CCA AES data key token has invalid/unknown keybitsize %u\\n\", *keybitsize);",
          "292:             return FALSE;",
          "293:         }",
          "294:         return TRUE;",
          "295:     }",
          "297:     if (t[0] == 0x01 && t[4] == 0x05 && t[41] == 0x02) {",
          "299:         uint16_t key_type = *((uint16_t*)(t + 42));",
          "300:         if (key_type != 0x0001) {",
          "301:             TRACE_DEVEL(\"CCA AES cipher key token has invalid/unknown keytype 0x%04hx\\n\", key_type);",
          "302:             return FALSE;",
          "303:         }",
          "306:         return TRUE;",
          "307:     }",
          "309:     if (t[0] == 0x01 && t[4] == 0x05 && t[41] == 0x03) {",
          "311:         uint16_t key_type = *((uint16_t*)(t + 42));",
          "312:         if (key_type != 0x0002) {",
          "313:             TRACE_DEVEL(\"CCA HMAC key token has invalid/unknown keytype 0x%04hx\\n\", key_type);",
          "314:             return FALSE;",
          "315:         }",
          "316:         if (t[8] != 0x03) {",
          "317:             TRACE_DEVEL(\"CCA HMAC key token has unsupported format t[8]=%hhu != 0x03\\n\", t[8]);",
          "318:             return FALSE;",
          "319:         }",
          "320:         if (t[26] != 0x02) {",
          "321:             TRACE_DEVEL(\"CCA HMAC key token has unsupported format t[26]=%hhu != 0x02\\n\", t[26]);",
          "322:             return FALSE;",
          "323:         }",
          "324:         if (t[27] != 0x02) {",
          "325:             TRACE_DEVEL(\"CCA HMAC key token has unsupported format t[27]=%hhu != 0x02\\n\", t[26]);",
          "326:             return FALSE;",
          "327:         }",
          "328:         if (t[28] != 0x00) {",
          "329:             TRACE_DEVEL(\"CCA HMAC key token has unsupported format t[28]=%hhu != 0x00\\n\", t[26]);",
          "330:             return FALSE;",
          "331:         }",
          "335:         if (*keybitsize < 80 || *keybitsize > 2432) {",
          "336:             TRACE_DEVEL(\"CCA HMAC key token has invalid/unknown payload bit size %u\\n\", *keybitsize);",
          "337:             return FALSE;",
          "338:         }",
          "339:         return TRUE;",
          "340:     }",
          "342:     if (t[0] == 0x1f &&",
          "343:         (t[CCA_RSA_INTTOK_PRIVKEY_OFFSET] == 0x30 ||",
          "344:          t[CCA_RSA_INTTOK_PRIVKEY_OFFSET] == 0x31)) {",
          "346:         uint16_t n, privsec_len;",
          "347:         privsec_len = *((uint16_t *)(t + CCA_RSA_INTTOK_PRIVKEY_OFFSET + 2));",
          "348:         if (CCA_RSA_INTTOK_PRIVKEY_OFFSET + privsec_len >= (int) tlen) {",
          "349:             TRACE_DEVEL(\"CCA RSA key token has invalid priv section len or token size\\n\");",
          "350:             return FALSE;",
          "351:         }",
          "352:         if (t[CCA_RSA_INTTOK_PRIVKEY_OFFSET + privsec_len] != 0x04) {",
          "353:             TRACE_DEVEL(\"CCA RSA key token has invalid pub section marker\\n\");",
          "354:             return FALSE;",
          "355:         }",
          "356:         n = *((uint16_t *)(t + CCA_RSA_INTTOK_PRIVKEY_OFFSET + privsec_len + 8));",
          "359:         return TRUE;",
          "360:     }",
          "362:     if (t[0] == 0x1e && t[CCA_RSA_INTTOK_HDR_LENGTH] == 0x04) {",
          "364:         uint16_t n;",
          "365:         n = *((uint16_t *)(t + CCA_RSA_INTTOK_HDR_LENGTH + 8));",
          "368:         return TRUE;",
          "369:     }",
          "371:     if (t[0] == 0x1f && t[8] == 0x20) {",
          "373:         uint16_t ec_curve_bits;",
          "374:         if (t[8+4] != 0x01) {",
          "375:             TRACE_DEVEL(\"CCA private ECC key token has invalid wrapping method 0x%02hhx\\n\", t[8+4]);",
          "376:             return FALSE;",
          "377:         }",
          "378:         if (t[8+10] != 0x08) {",
          "379:             TRACE_DEVEL(\"CCA private ECC key token has invalid key format 0x%02hhx\\n\", t[8+10]);",
          "380:             return FALSE;",
          "381:         }",
          "382:         ec_curve_bits = *((uint16_t *)(t + 8 + 12));",
          "385:         return TRUE;",
          "386:     }",
          "388:     if (t[0] == 0x1e && t[8] == 0x21) {",
          "390:         uint16_t ec_curve_bits;",
          "391:         ec_curve_bits = *((uint16_t *)(t + 8 + 10));",
          "394:         return TRUE;",
          "395:     }",
          "397:     return FALSE;",
          "398: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "252:         return rv;",
          "253:     }",
          "254:     if ((rv = template_update_attribute(tmpl, attr))) {",
          "256:         return rv;",
          "257:     }",
          "",
          "[Removed Lines]",
          "255:  TRACE_DEVEL(\"Template update for type=%lu failed, rv=0x%lx\\n\", type, rv);",
          "",
          "[Added Lines]",
          "413:         TRACE_DEVEL(\"Template update for type=%lu failed, rv=0x%lx\\n\", type, rv);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "712:                                   out_data_len, key, init_v, encrypt);",
          "713: }",
          "716: {",
          "717:     return *(uint16_t *) & tok[CCA_RSA_INTTOK_PRIVKEY_LENGTH_OFFSET];",
          "718: }",
          "722: {",
          "723:     uint16_t n_length;",
          "727:     if (n_length > (*n_len)) {",
          "730:         return CKR_FUNCTION_FAILED;",
          "731:     }",
          "736:     return CKR_OK;",
          "737: }",
          "741: {",
          "742:     uint16_t e_length;",
          "746:     if (e_length > (*e_len)) {",
          "749:         return CKR_FUNCTION_FAILED;",
          "750:     }",
          "755:     return CKR_OK;",
          "756: }",
          "761: {",
          "762:     uint16_t privkey_len, pubkey_offset;",
          "763:     CK_BYTE n[CCATOK_MAX_N_LEN], e[CCATOK_MAX_E_LEN];",
          "",
          "[Removed Lines]",
          "715: uint16_t cca_inttok_privkey_get_len(CK_BYTE * tok)",
          "721: CK_RV cca_inttok_privkey_get_n(CK_BYTE * tok, CK_ULONG * n_len, CK_BYTE * n)",
          "725:     n_length = *(uint16_t *) &tok[CCA_RSA_INTTOK_PRIVKEY_N_LENGTH_OFFSET];",
          "728:         TRACE_ERROR(\"Not enough room to return n.(Got %lu, need %hu)\\n\",",
          "733:     memcpy(n, &tok[CCA_RSA_INTTOK_PRIVKEY_N_OFFSET], (size_t) n_length);",
          "740: static CK_RV cca_inttok_pubkey_get_e(CK_BYTE * tok, CK_ULONG * e_len, CK_BYTE * e)",
          "744:     e_length = *(uint16_t *) & tok[CCA_RSA_INTTOK_PUBKEY_E_LENGTH_OFFSET];",
          "747:         TRACE_ERROR(\"Not enough room to return e.(Got %lu, need %hu)\\n\",",
          "752:     memcpy(e, &tok[CCA_RSA_INTTOK_PUBKEY_E_OFFSET], (size_t) e_length);",
          "759: static CK_RV add_n_and_e_to_rsa_key_template(TEMPLATE * tmpl,",
          "760:                                              CK_BYTE *cca_rsa_priv_key_token)",
          "",
          "[Added Lines]",
          "873: static uint16_t cca_rsa_inttok_privkey_get_len(CK_BYTE * tok)",
          "879: static CK_RV cca_rsa_inttok_privkeysec_get_n(CK_BYTE *sec, CK_ULONG *n_len, CK_BYTE *n)",
          "881:     int n_len_offset, n_value_offset;",
          "884:     if (sec[0] == 0x30) {",
          "886:         n_len_offset = CCA_RSA_INTTOK_PRIVKEY_ME_N_LENGTH_OFFSET;",
          "887:         n_value_offset = CCA_RSA_INTTOK_PRIVKEY_ME_N_OFFSET;",
          "888:     } else if (sec[0] == 0x31) {",
          "890:         n_len_offset = CCA_RSA_INTTOK_PRIVKEY_CRT_N_LENGTH_OFFSET;",
          "891:         n_value_offset = CCA_RSA_INTTOK_PRIVKEY_CRT_N_OFFSET;",
          "892:     } else {",
          "893:         TRACE_ERROR(\"Invalid private key section identifier 0x%02hhx\\n\", sec[0]);",
          "894:         return CKR_FUNCTION_FAILED;",
          "895:     }",
          "897:     n_length = *(uint16_t *) &sec[n_len_offset];",
          "898:     if (n_length > (*n_len)) {",
          "899:         TRACE_ERROR(\"Not enough room to return n (Got %lu, need %hu).\\n\",",
          "901:         return CKR_FUNCTION_FAILED;",
          "902:     }",
          "904:     memcpy(n, &sec[n_value_offset], (size_t) n_length);",
          "907:     return CKR_OK;",
          "908: }",
          "911: static CK_RV cca_rsa_inttok_pubkeysec_get_e(CK_BYTE *sec, CK_ULONG *e_len, CK_BYTE *e)",
          "912: {",
          "913:     uint16_t e_length;",
          "915:     if (sec[0] != 0x04) {",
          "916:         TRACE_ERROR(\"Invalid public key section identifier 0x%02hhx\\n\", sec[0]);",
          "917:         return CKR_FUNCTION_FAILED;",
          "918:     }",
          "920:     e_length = *((uint16_t *) &sec[CCA_RSA_INTTOK_PUBKEY_E_LENGTH_OFFSET]);",
          "921:     if (e_length > (*e_len)) {",
          "922:         TRACE_ERROR(\"Not enough room to return e (Got %lu, need %hu).\\n\",",
          "924:         return CKR_FUNCTION_FAILED;",
          "925:     }",
          "927:     memcpy(e, &sec[CCA_RSA_INTTOK_PUBKEY_E_OFFSET], (size_t) e_length);",
          "930:     return CKR_OK;",
          "931: }",
          "934: static CK_RV cca_rsa_exttok_pubkeysec_get_n(CK_BYTE *sec, CK_ULONG *n_len, CK_BYTE *n)",
          "935: {",
          "936:     uint16_t e_length, n_length, n_offset;",
          "938:     if (sec[0] != 0x04) {",
          "939:         TRACE_ERROR(\"Invalid public key section identifier 0x%02hhx\\n\", sec[0]);",
          "940:         return CKR_FUNCTION_FAILED;",
          "941:     }",
          "943:     n_length = *((uint16_t *)&sec[CCA_RSA_EXTTOK_PUBKEY_N_LENGTH_OFFSET]);",
          "944:     e_length = *((uint16_t *)&sec[CCA_RSA_INTTOK_PUBKEY_E_LENGTH_OFFSET]);",
          "945:     n_offset = CCA_RSA_INTTOK_PUBKEY_E_OFFSET + e_length;",
          "947:     if (n_length == 0) {",
          "948:         TRACE_ERROR(\"n_length is 0 - pub section from priv key given ?!?.\\n\");",
          "949:         return CKR_FUNCTION_FAILED;",
          "950:     }",
          "952:         TRACE_ERROR(\"Not enough room to return n (Got %lu, need %hu).\\n\",",
          "957:     memcpy(n, &sec[n_offset], (size_t) n_length);",
          "964: static CK_RV cca_rsa_exttok_pubkeysec_get_e(CK_BYTE *sec, CK_ULONG *e_len, CK_BYTE *e)",
          "968:     if (sec[0] != 0x04) {",
          "969:         TRACE_ERROR(\"Invalid public key section identifier 0x%02hhx\\n\", sec[0]);",
          "970:         return CKR_FUNCTION_FAILED;",
          "971:     }",
          "973:     e_length = *((uint16_t *) &sec[CCA_RSA_INTTOK_PUBKEY_E_LENGTH_OFFSET]);",
          "975:         TRACE_ERROR(\"Not enough room to return e (Got %lu, need %hu).\\n\",",
          "980:     memcpy(e, &sec[CCA_RSA_INTTOK_PUBKEY_E_OFFSET], (size_t) e_length);",
          "987: static CK_RV add_n_and_e_from_rsa_priv_key_to_templ(TEMPLATE *tmpl,",
          "988:                                                     CK_BYTE *cca_rsa_priv_key_token)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "765:     CK_RV rv;",
          "766:     CK_BYTE *tok = cca_rsa_priv_key_token;",
          "768:     privkey_len =",
          "770:     pubkey_offset = privkey_len + CCA_RSA_INTTOK_HDR_LENGTH;",
          "775:         TRACE_DEVEL(\"cca_inttok_privkey_get_n() failed. rv=0x%lx\\n\", rv);",
          "776:         return rv;",
          "777:     }",
          "781:         TRACE_DEVEL(\"cca_inttok_pubkey_get_e() failed. rv=0x%lx\\n\", rv);",
          "782:         return rv;",
          "783:     }",
          "",
          "[Removed Lines]",
          "769:         cca_inttok_privkey_get_len(&tok[CCA_RSA_INTTOK_PRIVKEY_OFFSET]);",
          "773:     if ((rv = cca_inttok_privkey_get_n(&tok[CCA_RSA_INTTOK_PRIVKEY_OFFSET],",
          "774:                                        &n_len, n))) {",
          "780:     if ((rv = cca_inttok_pubkey_get_e(&tok[pubkey_offset], &e_len, e))) {",
          "",
          "[Added Lines]",
          "996:     if (tok[0] != 0x1F) {",
          "997:         TRACE_ERROR(\"Invalid cca rsa private key token identifier 0x%02hhx\\n\", tok[0]);",
          "998:         return CKR_FUNCTION_FAILED;",
          "999:     }",
          "1002:         cca_rsa_inttok_privkey_get_len(&tok[CCA_RSA_INTTOK_PRIVKEY_OFFSET]);",
          "1006:     rv = cca_rsa_inttok_privkeysec_get_n(&tok[CCA_RSA_INTTOK_PRIVKEY_OFFSET],",
          "1007:                                          &n_len, n);",
          "1008:     if (rv != CKR_OK) {",
          "1014:     if ((rv = cca_rsa_inttok_pubkeysec_get_e(&tok[pubkey_offset], &e_len, e))) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1000:                 publ_key_token_length);",
          "1004:     if (rv != CKR_OK) {",
          "1006:         return rv;",
          "1007:     }",
          "1008:     rv = build_update_attribute(priv_tmpl, CKA_IBM_OPAQUE,",
          "",
          "[Removed Lines]",
          "1003:     rv = add_n_and_e_to_rsa_key_template(priv_tmpl, priv_key_token);",
          "1005:         TRACE_DEVEL(\"add_n_and_e_to_rsa_key_template failed. rv:%lu\\n\", rv);",
          "",
          "[Added Lines]",
          "1237:     rv = add_n_and_e_from_rsa_priv_key_to_templ(priv_tmpl, priv_key_token);",
          "1239:         TRACE_DEVEL(\"add_n_and_e_from_rsa_priv_key_to_templ failed. rv:%lu\\n\", rv);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1014:     }",
          "1018:     if (rv != CKR_OK) {",
          "1020:         return rv;",
          "1021:     }",
          "1022:     rv = build_update_attribute(publ_tmpl, CKA_IBM_OPAQUE,",
          "",
          "[Removed Lines]",
          "1017:     rv = add_n_and_e_to_rsa_key_template(publ_tmpl, priv_key_token);",
          "1019:         TRACE_DEVEL(\"add_n_and_e_to_rsa_key_template failed. rv:%lu\\n\", rv);",
          "",
          "[Added Lines]",
          "1251:     rv = add_n_and_e_from_rsa_priv_key_to_templ(publ_tmpl, priv_key_token);",
          "1253:         TRACE_DEVEL(\"add_n_and_e_from_rsa_priv_key_to_templ failed. rv:%lu\\n\", rv);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1027:         return rv;",
          "1028:     }",
          "1030:     return CKR_OK;",
          "1031: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1264:     TRACE_DEBUG(\"%s: priv template attributes:\\n\", __func__);",
          "1265:     TRACE_DEBUG_DUMPTEMPL(priv_tmpl);",
          "1266:     TRACE_DEBUG(\"%s: publ template attributes:\\n\", __func__);",
          "1267:     TRACE_DEBUG_DUMPTEMPL(publ_tmpl);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1879:         TRACE_ERROR(\"Could not find CKA_IBM_OPAQUE for the key.\\n\");",
          "1880:         return rc;",
          "1881:     }",
          "1884:     rule_array_count = 4;",
          "1885:     memcpy(rule_array, \"AES     ECB     KEYIDENTINITIAL \",",
          "1886:            rule_array_count * (size_t) CCA_KEYWORD_SIZE);",
          "",
          "[Removed Lines]",
          "1883:     key_len = 64;",
          "",
          "[Added Lines]",
          "2121:     key_len = attr->ulValueLen;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1980:         TRACE_ERROR(\"Could not find CKA_IBM_OPAQUE for the key.\\n\");",
          "1981:         return rc;",
          "1982:     }",
          "1984:     if (in_data_len % 16 == 0) {",
          "1985:         rule_array_count = 3;",
          "1986:         memcpy(rule_array, \"AES     KEYIDENTINITIAL \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2222:     key_len = attr->ulValueLen;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2000:     }",
          "2002:     length = in_data_len;",
          "2004:     if (encrypt) {",
          "2005:         dll_CSNBSAE(&return_code,",
          "2006:                     &reason_code,",
          "",
          "[Removed Lines]",
          "2003:     key_len = 64;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2411:         return rv;",
          "2412:     }",
          "2414:     return rv;",
          "2415: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2653:     TRACE_DEBUG(\"%s: priv template attributes:\\n\", __func__);",
          "2654:     TRACE_DEBUG_DUMPTEMPL(priv_tmpl);",
          "2655:     TRACE_DEBUG(\"%s: publ template attributes:\\n\", __func__);",
          "2656:     TRACE_DEBUG_DUMPTEMPL(publ_tmpl);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3412:                              &sig_len, FALSE);",
          "3413: }",
          "3416: {",
          "3673:     }",
          "3679:     }",
          "3748:     }",
          "3750:     return CKR_OK;",
          "3751: }",
          "3753: static CK_RV import_symmetric_key(OBJECT * object, CK_ULONG keytype)",
          "3754: {",
          "3755:     CK_RV rc;",
          "3803:     }",
          "3808:     return CKR_OK;",
          "3809: }",
          "3812: static CK_RV import_generic_secret_key(OBJECT * object)",
          "3813: {",
          "3814:     CK_RV rc;",
          "3828:         TRACE_ERROR(\"Incomplete Generic Secret (HMAC) key template\\n\");",
          "3830:     }",
          "3836:         return CKR_KEY_SIZE_RANGE;",
          "3837:     }",
          "3891:     }",
          "3896:     return CKR_OK;",
          "3897: }",
          "",
          "[Removed Lines]",
          "3415: static CK_RV rsa_import_privkey_crt(TEMPLATE * priv_tmpl)",
          "3417:     long return_code, reason_code, rule_array_count, total = 0;",
          "3418:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "3420:     long offset, key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "3421:     long private_key_name_length, key_token_length, target_key_token_length;",
          "3423:     unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "3424:     unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "3425:     unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "3426:     unsigned char target_key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "3427:     unsigned char transport_key_identifier[CCA_KEY_ID_SIZE] = { 0, };",
          "3429:     uint16_t size_of_e;",
          "3430:     uint16_t mod_bits, mod_bytes, bytes;",
          "3431:     CK_ATTRIBUTE *opaque_key = NULL, *pub_exp = NULL, *mod = NULL,",
          "3433:         NULL, *priv_exp = NULL;",
          "3434:     CK_RV rc;",
          "3437:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_PRIME_1, &p_prime);",
          "3438:     if (rc != CKR_OK) {",
          "3439:         TRACE_ERROR(\"CKA_PRIME_1 attribute missing for CRT.\\n\");",
          "3440:         return rc;",
          "3441:     }",
          "3442:     total += p_prime->ulValueLen;",
          "3444:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_PRIME_2, &q_prime);",
          "3445:     if (rc != CKR_OK) {",
          "3446:         TRACE_ERROR(\"CKA_PRIME_2 attribute missing for CRT.\\n\");",
          "3447:         return rc;",
          "3448:     }",
          "3449:     total += q_prime->ulValueLen;",
          "3451:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_EXPONENT_1, &dmp1);",
          "3452:     if (rc != CKR_OK) {",
          "3453:         TRACE_ERROR(\"CKA_EXPONENT_1 attribute missing for CRT.\\n\");",
          "3454:         return rc;",
          "3455:     }",
          "3456:     total += dmp1->ulValueLen;",
          "3458:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_EXPONENT_2, &dmq1);",
          "3459:     if (rc != CKR_OK) {",
          "3460:         TRACE_ERROR(\"CKA_EXPONENT_2 attribute missing for CRT.\\n\");",
          "3461:         return rc;",
          "3462:     }",
          "3463:     total += dmq1->ulValueLen;",
          "3465:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_COEFFICIENT, &iqmp);",
          "3466:     if (rc != CKR_OK) {",
          "3467:         TRACE_ERROR(\"CKA_COEFFICIENT attribute missing for CRT.\\n\");",
          "3468:         return rc;",
          "3469:     }",
          "3470:     total += iqmp->ulValueLen;",
          "3472:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_PUBLIC_EXPONENT,",
          "3473:                                           &pub_exp);",
          "3474:     if (rc != CKR_OK) {",
          "3475:         TRACE_ERROR(\"CKA_PUBLIC_EXPONENT attribute missing for CRT.\\n\");",
          "3476:         return rc;",
          "3477:     }",
          "3478:     total += pub_exp->ulValueLen;",
          "3480:     rc = template_attribute_get_non_empty(priv_tmpl, CKA_MODULUS, &mod);",
          "3481:     if (rc != CKR_OK) {",
          "3482:         TRACE_ERROR(\"CKA_MODULUS attribute missing for CRT.\\n\");",
          "3483:         return rc;",
          "3484:     }",
          "3485:     total += mod->ulValueLen;",
          "3488:     if ((total + 18) > key_value_structure_length) {",
          "3489:         TRACE_ERROR(\"total length of key exceeds CCA_KEY_VALUE_STRUCT_SIZE.\\n\");",
          "3490:         return CKR_KEY_SIZE_RANGE;",
          "3491:     }",
          "3498:     memset(key_value_structure, 0, key_value_structure_length);",
          "3501:     mod_bits = htons(mod->ulValueLen * 8);",
          "3502:     memcpy(&key_value_structure[0], &mod_bits, sizeof(uint16_t));",
          "3505:     mod_bytes = htons(mod->ulValueLen);",
          "3506:     memcpy(&key_value_structure[2], &mod_bytes, sizeof(uint16_t));",
          "3509:     size_of_e = htons(pub_exp->ulValueLen);",
          "3510:     memcpy(&key_value_structure[4], &size_of_e, sizeof(uint16_t));",
          "3515:     bytes = htons(p_prime->ulValueLen);",
          "3516:     memcpy(&key_value_structure[8], &bytes, sizeof(uint16_t));",
          "3519:     bytes = htons(q_prime->ulValueLen);",
          "3520:     memcpy(&key_value_structure[10], &bytes, sizeof(uint16_t));",
          "3523:     bytes = htons(dmp1->ulValueLen);",
          "3524:     memcpy(&key_value_structure[12], &bytes, sizeof(uint16_t));",
          "3527:     bytes = htons(dmq1->ulValueLen);",
          "3528:     memcpy(&key_value_structure[14], &bytes, sizeof(uint16_t));",
          "3531:     bytes = htons(iqmp->ulValueLen);",
          "3532:     memcpy(&key_value_structure[16], &bytes, sizeof(uint16_t));",
          "3535:     memcpy(&key_value_structure[18], mod->pValue, mod_bytes);",
          "3537:     offset = 18 + mod_bytes;",
          "3540:     memcpy(&key_value_structure[offset], pub_exp->pValue, pub_exp->ulValueLen);",
          "3542:     offset += pub_exp->ulValueLen;",
          "3545:     memcpy(&key_value_structure[offset], p_prime->pValue, p_prime->ulValueLen);",
          "3547:     offset += p_prime->ulValueLen;",
          "3550:     memcpy(&key_value_structure[offset], q_prime->pValue, q_prime->ulValueLen);",
          "3552:     offset += q_prime->ulValueLen;",
          "3555:     memcpy(&key_value_structure[offset], dmp1->pValue, dmp1->ulValueLen);",
          "3557:     offset += dmp1->ulValueLen;",
          "3560:     memcpy(&key_value_structure[offset], dmq1->pValue, dmq1->ulValueLen);",
          "3562:     offset += dmq1->ulValueLen;",
          "3565:     memcpy(&key_value_structure[offset], iqmp->pValue, iqmp->ulValueLen);",
          "3569:     rule_array_count = 2;",
          "3570:     memcpy(rule_array, \"RSA-AESCKEY-MGMT\", (size_t) (CCA_KEYWORD_SIZE * 2));",
          "3572:     private_key_name_length = 0;",
          "3574:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3576:     dll_CSNDPKB(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3577:                 rule_array, &key_value_structure_length, key_value_structure,",
          "3578:                 &private_key_name_length, private_key_name, 0, NULL, 0, NULL,",
          "3579:                 0, NULL, 0, NULL, 0, NULL, &key_token_length, key_token);",
          "3581:     if (return_code != CCA_SUCCESS) {",
          "3582:         TRACE_ERROR(\"CSNDPKB (RSA KEY TOKEN BUILD RSA CRT) failed.\"",
          "3583:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3584:         rc = CKR_FUNCTION_FAILED;",
          "3585:         goto err;",
          "3586:     }",
          "3589:     rule_array_count = 0;",
          "3592:     target_key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3594:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3596:     dll_CSNDPKI(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3597:                 rule_array, &key_token_length, key_token,",
          "3598:                 transport_key_identifier, &target_key_token_length,",
          "3599:                 target_key_token);",
          "3601:     if (return_code != CCA_SUCCESS) {",
          "3602:         TRACE_ERROR(\"CSNDPKI (RSA KEY TOKEN IMPORT) failed.\"",
          "3603:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3604:         rc = CKR_FUNCTION_FAILED;",
          "3605:         goto err;",
          "3606:     }",
          "3609:     if ((rc = build_attribute(CKA_IBM_OPAQUE, target_key_token,",
          "3610:                               target_key_token_length, &opaque_key))) {",
          "3611:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "3612:         goto err;",
          "3613:     }",
          "3614:     rc = template_update_attribute(priv_tmpl, opaque_key);",
          "3615:     if (rc != CKR_OK) {",
          "3616:         TRACE_DEVEL(\"template_update_attribute failed\\n\");",
          "3617:         free(opaque_key);",
          "3618:         goto err;",
          "3619:     }",
          "3621:     OPENSSL_cleanse(p_prime->pValue, p_prime->ulValueLen);",
          "3622:     OPENSSL_cleanse(q_prime->pValue, q_prime->ulValueLen);",
          "3623:     OPENSSL_cleanse(dmp1->pValue, dmp1->ulValueLen);",
          "3624:     OPENSSL_cleanse(dmq1->pValue, dmq1->ulValueLen);",
          "3625:     OPENSSL_cleanse(iqmp->pValue, iqmp->ulValueLen);",
          "3626:     if (template_attribute_get_non_empty(priv_tmpl, CKA_PRIVATE_EXPONENT,",
          "3627:                                          &priv_exp) == CKR_OK) {",
          "3628:         OPENSSL_cleanse(priv_exp->pValue, priv_exp->ulValueLen);",
          "3629:     }",
          "3631:     rc = CKR_OK;",
          "3633: err:",
          "3634:     OPENSSL_cleanse(key_value_structure, sizeof(key_value_structure));",
          "3635:     return rc;",
          "3636: }",
          "3638: static CK_RV rsa_import_pubkey(TEMPLATE * publ_tmpl)",
          "3639: {",
          "3640:     long return_code, reason_code, rule_array_count;",
          "3641:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "3643:     long key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "3644:     long private_key_name_length, key_token_length;",
          "3645:     unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "3646:     unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "3647:     unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "3649:     uint16_t size_of_e;",
          "3650:     uint16_t mod_bits, mod_bytes;",
          "3651:     CK_ATTRIBUTE *opaque_key = NULL, *pub_exp = NULL;",
          "3652:     CK_ATTRIBUTE *pub_mod = NULL, *attr = NULL;",
          "3653:     CK_RV rc;",
          "3656:     rc = template_attribute_get_non_empty(publ_tmpl, CKA_PUBLIC_EXPONENT,",
          "3657:                                           &pub_exp);",
          "3658:     if (rc != CKR_OK) {",
          "3659:         TRACE_ERROR(\"CKA_PUBLIC_EXPONENT attribute missing.\\n\");",
          "3660:         return rc;",
          "3661:     }",
          "3663:     rc = template_attribute_get_non_empty(publ_tmpl, CKA_MODULUS, &pub_mod);",
          "3664:     if (rc != CKR_OK) {",
          "3665:         TRACE_ERROR(\"CKA_MODULUS attribute missing.\\n\");",
          "3666:         return rc;",
          "3667:     }",
          "3669:     rc = template_attribute_get_non_empty(publ_tmpl, CKA_MODULUS_BITS, &attr);",
          "3670:     if (rc != CKR_OK) {",
          "3671:         TRACE_ERROR(\"CKA_MODULUS_BITS attribute missing.\\n\");",
          "3672:         return rc;",
          "3676:     if ((pub_mod->ulValueLen + 8) > (CK_ULONG)key_value_structure_length) {",
          "3677:         TRACE_ERROR(\"total length of key exceeds CCA_KEY_VALUE_STRUCT_SIZE.\\n\");",
          "3678:         return CKR_KEY_SIZE_RANGE;",
          "3682:     if (*(CK_ULONG *) attr->pValue == 0)",
          "3683:         mod_bits = htons(pub_mod->ulValueLen * 8);",
          "3684:     else",
          "3685:         mod_bits = htons(*(CK_ULONG *) attr->pValue);",
          "3688:     memset(key_value_structure, 0, key_value_structure_length);",
          "3695:     memcpy(&key_value_structure[0], &mod_bits, sizeof(uint16_t));",
          "3698:     mod_bytes = htons(pub_mod->ulValueLen);",
          "3699:     memcpy(&key_value_structure[2], &mod_bytes, sizeof(uint16_t));",
          "3702:     size_of_e = htons((uint16_t) pub_exp->ulValueLen);",
          "3703:     memcpy(&key_value_structure[4], &size_of_e, sizeof(uint16_t));",
          "3708:     memcpy(&key_value_structure[8], pub_mod->pValue,",
          "3709:            (size_t) pub_mod->ulValueLen);",
          "3712:     memcpy(&key_value_structure[8 + mod_bytes],",
          "3713:            pub_exp->pValue, (size_t) pub_exp->ulValueLen);",
          "3717:     rule_array_count = 1;",
          "3718:     memcpy(rule_array, \"RSA-PUBL\", (size_t) (CCA_KEYWORD_SIZE * 1));",
          "3720:     private_key_name_length = 0;",
          "3722:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3726:     dll_CSNDPKB(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3727:                 rule_array, &key_value_structure_length, key_value_structure,",
          "3728:                 &private_key_name_length, private_key_name, 0, NULL, 0,",
          "3729:                 NULL, 0, NULL, 0, NULL, 0, NULL, &key_token_length, key_token);",
          "3731:     if (return_code != CCA_SUCCESS) {",
          "3732:         TRACE_ERROR(\"CSNDPKB (RSA KEY TOKEN BUILD RSA-PUBL) failed.\"",
          "3733:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3734:         return CKR_FUNCTION_FAILED;",
          "3735:     }",
          "3737:     if ((rc = build_attribute(CKA_IBM_OPAQUE, key_token, key_token_length,",
          "3738:                               &opaque_key))) {",
          "3739:         TRACE_DEVEL(\"build_attribute failed\\n\");",
          "3740:         return rc;",
          "3741:     }",
          "3743:     rc = template_update_attribute(publ_tmpl, opaque_key);",
          "3744:     if (rc != CKR_OK) {",
          "3745:         TRACE_DEVEL(\"template_update_attribute failed\\n\");",
          "3746:         free(opaque_key);",
          "3747:         return rc;",
          "3756:     long return_code, reason_code, rule_array_count;",
          "3757:     unsigned char target_key_id[CCA_KEY_ID_SIZE] = { 0 };",
          "3758:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0 };",
          "3759:     CK_ATTRIBUTE *opaque_key = NULL;",
          "3760:     CK_ATTRIBUTE *attr = NULL;",
          "3762:     rc = template_attribute_get_non_empty(object->template, CKA_VALUE, &attr);",
          "3763:     if (rc != CKR_OK) {",
          "3764:         TRACE_ERROR(\"Incomplete key template\\n\");",
          "3765:         return rc;",
          "3766:     }",
          "3768:     switch (keytype) {",
          "3769:     case CKK_AES:",
          "3770:         memcpy(rule_array, \"AES     \", CCA_KEYWORD_SIZE);",
          "3771:         break;",
          "3772:     case CKK_DES:",
          "3773:     case CKK_DES3:",
          "3774:         memcpy(rule_array, \"DES     \", CCA_KEYWORD_SIZE);",
          "3775:         break;",
          "3776:     default:",
          "3777:         return CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "3778:     }",
          "3780:     rule_array_count = 1;",
          "3782:     dll_CSNBCKM(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3783:                 rule_array, (long int *)&attr->ulValueLen, attr->pValue,",
          "3784:                 target_key_id);",
          "3786:     if (return_code != CCA_SUCCESS) {",
          "3787:         TRACE_ERROR(\"CSNBCKM failed. return:%ld, reason:%ld\\n\",",
          "3788:                     return_code, reason_code);",
          "3789:         return CKR_FUNCTION_FAILED;",
          "3790:     }",
          "3793:     if ((rc = build_attribute(CKA_IBM_OPAQUE, target_key_id,",
          "3794:                               CCA_KEY_ID_SIZE, &opaque_key))) {",
          "3795:         TRACE_DEVEL(\"build_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "3796:         return rc;",
          "3797:     }",
          "3798:     rc = template_update_attribute(object->template, opaque_key);",
          "3799:     if (rc != CKR_OK) {",
          "3800:         TRACE_DEVEL(\"template_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "3801:         free(opaque_key);",
          "3802:         return rc;",
          "3806:     OPENSSL_cleanse(attr->pValue, attr->ulValueLen);",
          "3815:     long return_code, reason_code, rule_array_count;",
          "3816:     unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0 };",
          "3817:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0 };",
          "3818:     long key_name_len = 0, clr_key_len = 0;",
          "3819:     long user_data_len = 0, key_part_len = 0;",
          "3820:     long token_data_len = 0, verb_data_len = 0;",
          "3821:     long key_token_len = sizeof(key_token);",
          "3822:     CK_ATTRIBUTE *opaque_key = NULL;",
          "3823:     CK_ATTRIBUTE *attr = NULL;",
          "3824:     CK_ULONG keylen;",
          "3826:     rc = template_attribute_get_non_empty(object->template, CKA_VALUE, &attr);",
          "3827:     if (rc != CKR_OK) {",
          "3829:         return rc;",
          "3831:     keylen = attr->ulValueLen;",
          "3833:     if (8 * keylen < 80 || 8 * keylen > 2048) {",
          "3834:         TRACE_ERROR(\"HMAC key size of %lu bits not within\"",
          "3835:                     \" CCA required range of 80-2048 bits\\n\", 8 * keylen);",
          "3839:     memcpy(rule_array, \"INTERNALNO-KEY  HMAC    MAC     GENERATE\",",
          "3840:            5 * CCA_KEYWORD_SIZE);",
          "3841:     rule_array_count = 5;",
          "3843:     dll_CSNBKTB2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3844:                  rule_array, &clr_key_len, NULL, &key_name_len, NULL,",
          "3845:                  &user_data_len, NULL, &token_data_len, NULL, &verb_data_len,",
          "3846:                  NULL, &key_token_len, key_token);",
          "3847:     if (return_code != CCA_SUCCESS) {",
          "3848:         TRACE_ERROR(\"CSNBKTB2 (HMAC KEY TOKEN BUILD) failed.\"",
          "3849:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3850:         return CKR_FUNCTION_FAILED;",
          "3851:     }",
          "3853:     memcpy(rule_array, \"HMAC    FIRST   MIN1PART\", 3 * CCA_KEYWORD_SIZE);",
          "3854:     rule_array_count = 3;",
          "3855:     key_part_len = keylen * 8;",
          "3856:     key_token_len = sizeof(key_token);",
          "3858:     dll_CSNBKPI2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3859:                  rule_array, &key_part_len, attr->pValue, &key_token_len,",
          "3860:                  key_token);",
          "3861:     if (return_code != CCA_SUCCESS) {",
          "3862:         TRACE_ERROR(\"CSNBKPI2 (HMAC KEY IMPORT FIRST) failed.\"",
          "3863:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3864:         return CKR_FUNCTION_FAILED;",
          "3865:     }",
          "3867:     memcpy(rule_array, \"HMAC    COMPLETE\", 2 * CCA_KEYWORD_SIZE);",
          "3868:     rule_array_count = 2;",
          "3869:     key_part_len = 0;",
          "3870:     key_token_len = sizeof(key_token);",
          "3872:     dll_CSNBKPI2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3873:                  rule_array, &key_part_len, NULL, &key_token_len, key_token);",
          "3874:     if (return_code != CCA_SUCCESS) {",
          "3875:         TRACE_ERROR(\"CSNBKPI2 (HMAC KEY IMPORT COMPLETE) failed.\"",
          "3876:                     \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3877:         return CKR_FUNCTION_FAILED;",
          "3878:     }",
          "3881:     if ((rc = build_attribute(CKA_IBM_OPAQUE, key_token, key_token_len,",
          "3882:                               &opaque_key))) {",
          "3883:         TRACE_DEVEL(\"build_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "3884:         return rc;",
          "3885:     }",
          "3886:     rc = template_update_attribute(object->template, opaque_key);",
          "3887:     if (rc != CKR_OK) {",
          "3888:         TRACE_DEVEL(\"template_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "3889:         free(opaque_key);",
          "3890:         return rc;",
          "3894:     OPENSSL_cleanse(attr->pValue, attr->ulValueLen);",
          "",
          "[Added Lines]",
          "3660: static CK_RV import_rsa_privkey(TEMPLATE * priv_tmpl)",
          "3662:     CK_RV rc;",
          "3663:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "3665:     rc = template_attribute_find(priv_tmpl, CKA_IBM_OPAQUE, &opaque_attr);",
          "3666:     if (rc == TRUE) {",
          "3672:         enum cca_token_type token_type;",
          "3673:         unsigned int token_keybitsize;",
          "3674:         CK_BYTE *t, n[CCATOK_MAX_N_LEN], e[CCATOK_MAX_E_LEN];",
          "3675:         CK_ULONG n_len = CCATOK_MAX_N_LEN, e_len = CCATOK_MAX_E_LEN;",
          "3676:         uint16_t privkey_len, pubkey_offset;",
          "3677:         CK_BBOOL true = TRUE;",
          "3679:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "3680:                                   &token_type, &token_keybitsize) != TRUE) {",
          "3681:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "3682:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "3683:         }",
          "3684:         if (token_type != sec_rsa_priv_key) {",
          "3685:             TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_RSA\\n\");",
          "3686:             return CKR_TEMPLATE_INCONSISTENT;",
          "3687:         }",
          "3689:         t = opaque_attr->pValue;",
          "3690:         privkey_len = cca_rsa_inttok_privkey_get_len(&t[CCA_RSA_INTTOK_PRIVKEY_OFFSET]);",
          "3691:         pubkey_offset = CCA_RSA_INTTOK_HDR_LENGTH + privkey_len;",
          "3694:         rc =  cca_rsa_inttok_privkeysec_get_n(&t[CCA_RSA_INTTOK_PRIVKEY_OFFSET], &n_len, n);",
          "3695:         if (rc != CKR_OK) {",
          "3696:             TRACE_DEVEL(\"cca_inttok_privkey_get_n() failed. rc=0x%lx\\n\", rc);",
          "3697:             return rc;",
          "3698:         }",
          "3701:         rc = build_update_attribute(priv_tmpl, CKA_SENSITIVE, &true, sizeof(CK_BBOOL));",
          "3702:         if (rc != CKR_OK) {",
          "3703:             TRACE_DEVEL(\"build_update_attribute for CKA_SENSITIVE failed. rc=0x%lx\\n\", rc);",
          "3704:             return rc;",
          "3705:         }",
          "3708:         rc = cca_rsa_inttok_pubkeysec_get_e(&t[pubkey_offset], &e_len, e);",
          "3709:         if (rc != CKR_OK) {",
          "3710:             TRACE_DEVEL(\"cca_inttok_pubkey_get_e() failed. rc=0x%lx\\n\", rc);",
          "3711:             return rc;",
          "3712:         }",
          "3715:         rc = build_update_attribute(priv_tmpl, CKA_MODULUS, n, n_len);",
          "3716:         if (rc != CKR_OK) {",
          "3717:             TRACE_DEVEL(\"build_update_attribute for n failed. rc=0x%lx\\n\", rc);",
          "3718:             return rc;",
          "3719:         }",
          "3722:         rc = build_update_attribute(priv_tmpl, CKA_PUBLIC_EXPONENT, e, e_len);",
          "3723:         if (rc != CKR_OK) {",
          "3724:             TRACE_DEVEL(\"build_update_attribute for e failed. rc=0x%lx\\n\", rc);",
          "3725:             return rc;",
          "3726:         }",
          "3729:         build_update_attribute(priv_tmpl, CKA_PRIVATE_EXPONENT, NULL, 0);",
          "3731:     } else {",
          "3737:         long return_code, reason_code, rule_array_count, total = 0;",
          "3738:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "3740:         long offset, key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "3741:         long private_key_name_length, key_token_length, target_key_token_length;",
          "3743:         unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "3744:         unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "3745:         unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "3746:         unsigned char target_key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "3747:         unsigned char transport_key_identifier[CCA_KEY_ID_SIZE] = { 0, };",
          "3749:         uint16_t size_of_e;",
          "3750:         uint16_t mod_bits, mod_bytes, bytes;",
          "3751:         CK_ATTRIBUTE *pub_exp = NULL, *mod = NULL,",
          "3753:             NULL, *priv_exp = NULL;",
          "3756:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_PRIME_1, &p_prime);",
          "3757:         if (rc != CKR_OK) {",
          "3758:             TRACE_ERROR(\"CKA_PRIME_1 attribute missing for CRT.\\n\");",
          "3759:             return rc;",
          "3760:         }",
          "3761:         total += p_prime->ulValueLen;",
          "3763:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_PRIME_2, &q_prime);",
          "3764:         if (rc != CKR_OK) {",
          "3765:             TRACE_ERROR(\"CKA_PRIME_2 attribute missing for CRT.\\n\");",
          "3766:             return rc;",
          "3767:         }",
          "3768:         total += q_prime->ulValueLen;",
          "3770:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_EXPONENT_1, &dmp1);",
          "3771:         if (rc != CKR_OK) {",
          "3772:             TRACE_ERROR(\"CKA_EXPONENT_1 attribute missing for CRT.\\n\");",
          "3773:             return rc;",
          "3774:         }",
          "3775:         total += dmp1->ulValueLen;",
          "3777:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_EXPONENT_2, &dmq1);",
          "3778:         if (rc != CKR_OK) {",
          "3779:             TRACE_ERROR(\"CKA_EXPONENT_2 attribute missing for CRT.\\n\");",
          "3780:             return rc;",
          "3781:         }",
          "3782:         total += dmq1->ulValueLen;",
          "3784:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_COEFFICIENT, &iqmp);",
          "3785:         if (rc != CKR_OK) {",
          "3786:             TRACE_ERROR(\"CKA_COEFFICIENT attribute missing for CRT.\\n\");",
          "3787:             return rc;",
          "3788:         }",
          "3789:         total += iqmp->ulValueLen;",
          "3791:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_PUBLIC_EXPONENT,",
          "3792:                                               &pub_exp);",
          "3793:         if (rc != CKR_OK) {",
          "3794:             TRACE_ERROR(\"CKA_PUBLIC_EXPONENT attribute missing for CRT.\\n\");",
          "3795:             return rc;",
          "3796:         }",
          "3797:         total += pub_exp->ulValueLen;",
          "3799:         rc = template_attribute_get_non_empty(priv_tmpl, CKA_MODULUS, &mod);",
          "3800:         if (rc != CKR_OK) {",
          "3801:             TRACE_ERROR(\"CKA_MODULUS attribute missing for CRT.\\n\");",
          "3802:             return rc;",
          "3803:         }",
          "3804:         total += mod->ulValueLen;",
          "3807:         if ((total + 18) > key_value_structure_length) {",
          "3808:             TRACE_ERROR(\"total length of key exceeds CCA_KEY_VALUE_STRUCT_SIZE.\\n\");",
          "3809:             return CKR_KEY_SIZE_RANGE;",
          "3810:         }",
          "3817:         memset(key_value_structure, 0, key_value_structure_length);",
          "3820:         mod_bits = htons(mod->ulValueLen * 8);",
          "3821:         memcpy(&key_value_structure[0], &mod_bits, sizeof(uint16_t));",
          "3824:         mod_bytes = htons(mod->ulValueLen);",
          "3825:         memcpy(&key_value_structure[2], &mod_bytes, sizeof(uint16_t));",
          "3828:         size_of_e = htons(pub_exp->ulValueLen);",
          "3829:         memcpy(&key_value_structure[4], &size_of_e, sizeof(uint16_t));",
          "3834:         bytes = htons(p_prime->ulValueLen);",
          "3835:         memcpy(&key_value_structure[8], &bytes, sizeof(uint16_t));",
          "3838:         bytes = htons(q_prime->ulValueLen);",
          "3839:         memcpy(&key_value_structure[10], &bytes, sizeof(uint16_t));",
          "3842:         bytes = htons(dmp1->ulValueLen);",
          "3843:         memcpy(&key_value_structure[12], &bytes, sizeof(uint16_t));",
          "3846:         bytes = htons(dmq1->ulValueLen);",
          "3847:         memcpy(&key_value_structure[14], &bytes, sizeof(uint16_t));",
          "3850:         bytes = htons(iqmp->ulValueLen);",
          "3851:         memcpy(&key_value_structure[16], &bytes, sizeof(uint16_t));",
          "3854:         memcpy(&key_value_structure[18], mod->pValue, mod_bytes);",
          "3856:         offset = 18 + mod_bytes;",
          "3859:         memcpy(&key_value_structure[offset], pub_exp->pValue, pub_exp->ulValueLen);",
          "3861:         offset += pub_exp->ulValueLen;",
          "3864:         memcpy(&key_value_structure[offset], p_prime->pValue, p_prime->ulValueLen);",
          "3866:         offset += p_prime->ulValueLen;",
          "3869:         memcpy(&key_value_structure[offset], q_prime->pValue, q_prime->ulValueLen);",
          "3871:         offset += q_prime->ulValueLen;",
          "3874:         memcpy(&key_value_structure[offset], dmp1->pValue, dmp1->ulValueLen);",
          "3876:         offset += dmp1->ulValueLen;",
          "3879:         memcpy(&key_value_structure[offset], dmq1->pValue, dmq1->ulValueLen);",
          "3881:         offset += dmq1->ulValueLen;",
          "3884:         memcpy(&key_value_structure[offset], iqmp->pValue, iqmp->ulValueLen);",
          "3888:         rule_array_count = 2;",
          "3889:         memcpy(rule_array, \"RSA-AESCKEY-MGMT\", (size_t) (CCA_KEYWORD_SIZE * 2));",
          "3891:         private_key_name_length = 0;",
          "3893:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3895:         dll_CSNDPKB(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3896:                     rule_array, &key_value_structure_length, key_value_structure,",
          "3897:                     &private_key_name_length, private_key_name, 0, NULL, 0, NULL,",
          "3898:                     0, NULL, 0, NULL, 0, NULL, &key_token_length, key_token);",
          "3900:         if (return_code != CCA_SUCCESS) {",
          "3901:             TRACE_ERROR(\"CSNDPKB (RSA KEY TOKEN BUILD RSA CRT) failed.\"",
          "3902:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3903:             rc = CKR_FUNCTION_FAILED;",
          "3904:             goto err;",
          "3905:         }",
          "3908:         rule_array_count = 0;",
          "3911:         target_key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3913:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "3915:         dll_CSNDPKI(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "3916:                     rule_array, &key_token_length, key_token,",
          "3917:                     transport_key_identifier, &target_key_token_length,",
          "3918:                     target_key_token);",
          "3920:         if (return_code != CCA_SUCCESS) {",
          "3921:             TRACE_ERROR(\"CSNDPKI (RSA KEY TOKEN IMPORT) failed.\"",
          "3922:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "3923:             rc = CKR_FUNCTION_FAILED;",
          "3924:             goto err;",
          "3925:         }",
          "3928:         if ((rc = build_update_attribute(priv_tmpl, CKA_IBM_OPAQUE,",
          "3929:                                          target_key_token,",
          "3930:                                          target_key_token_length))) {",
          "3931:             TRACE_DEVEL(\"build_update_attribute failed\\n\");",
          "3932:             goto err;",
          "3933:         }",
          "3935:         OPENSSL_cleanse(p_prime->pValue, p_prime->ulValueLen);",
          "3936:         OPENSSL_cleanse(q_prime->pValue, q_prime->ulValueLen);",
          "3937:         OPENSSL_cleanse(dmp1->pValue, dmp1->ulValueLen);",
          "3938:         OPENSSL_cleanse(dmq1->pValue, dmq1->ulValueLen);",
          "3939:         OPENSSL_cleanse(iqmp->pValue, iqmp->ulValueLen);",
          "3940:         if (template_attribute_get_non_empty(priv_tmpl, CKA_PRIVATE_EXPONENT,",
          "3941:                                              &priv_exp) == CKR_OK) {",
          "3942:             OPENSSL_cleanse(priv_exp->pValue, priv_exp->ulValueLen);",
          "3943:         }",
          "3945:         rc = CKR_OK;",
          "3947: err:",
          "3948:         OPENSSL_cleanse(key_value_structure, sizeof(key_value_structure));",
          "3951:     if (rc == CKR_OK) {",
          "3952:         TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "3953:  TRACE_DEBUG_DUMPTEMPL(priv_tmpl);",
          "3956:     return rc;",
          "3957: }",
          "3959: static CK_RV import_rsa_pubkey(TEMPLATE * publ_tmpl)",
          "3960: {",
          "3961:     CK_RV rc;",
          "3962:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "3964:     rc = template_attribute_find(publ_tmpl, CKA_IBM_OPAQUE, &opaque_attr);",
          "3965:     if (rc == TRUE) {",
          "3971:         enum cca_token_type token_type;",
          "3972:         unsigned int token_keybitsize;",
          "3973:         CK_BYTE *t, n[CCATOK_MAX_N_LEN], e[CCATOK_MAX_E_LEN];",
          "3974:         CK_ULONG n_len = CCATOK_MAX_N_LEN, e_len = CCATOK_MAX_E_LEN;",
          "3976:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "3977:                                   &token_type, &token_keybitsize) != TRUE) {",
          "3978:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "3979:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "3980:         }",
          "3981:         if (token_type != sec_rsa_publ_key) {",
          "3982:             TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_RSA\\n\");",
          "3983:             return CKR_TEMPLATE_INCONSISTENT;",
          "3984:         }",
          "3986:         t = opaque_attr->pValue;",
          "3989:         rc = cca_rsa_exttok_pubkeysec_get_n(&t[CCA_RSA_EXTTOK_PUBKEY_OFFSET], &n_len, n);",
          "3990:         if (rc != CKR_OK) {",
          "3991:             TRACE_DEVEL(\"cca_exttok_pubkey_get_n() failed. rc=0x%lx\\n\", rc);",
          "3992:             return rc;",
          "3993:         }",
          "3996:         rc = cca_rsa_exttok_pubkeysec_get_e(&t[CCA_RSA_EXTTOK_PUBKEY_OFFSET], &e_len, e);",
          "3997:         if (rc != CKR_OK) {",
          "3998:             TRACE_DEVEL(\"cca_exttok_pubkey_get_e() failed. rc=0x%lx\\n\", rc);",
          "3999:             return rc;",
          "4000:         }",
          "4003:         rc = build_update_attribute(publ_tmpl, CKA_MODULUS, n, n_len);",
          "4004:         if (rc != CKR_OK) {",
          "4005:             TRACE_DEVEL(\"build_update_attribute for n failed. rc=0x%lx\\n\", rc);",
          "4006:             return rc;",
          "4007:         }",
          "4010:         rc = build_update_attribute(publ_tmpl, CKA_PUBLIC_EXPONENT, e, e_len);",
          "4011:         if (rc != CKR_OK) {",
          "4012:             TRACE_DEVEL(\"build_update_attribute for e failed. rc=0x%lx\\n\", rc);",
          "4013:             return rc;",
          "4014:         }",
          "4016:     } else {",
          "4022:         long return_code, reason_code, rule_array_count;",
          "4023:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "4025:         long key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "4026:         long private_key_name_length, key_token_length;",
          "4027:         unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "4028:         unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "4029:         unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4031:         uint16_t size_of_e;",
          "4032:         uint16_t mod_bits, mod_bytes;",
          "4033:         CK_ATTRIBUTE *pub_exp = NULL;",
          "4034:         CK_ATTRIBUTE *pub_mod = NULL, *attr = NULL;",
          "4037:         rc = template_attribute_get_non_empty(publ_tmpl, CKA_PUBLIC_EXPONENT,",
          "4038:                                               &pub_exp);",
          "4039:         if (rc != CKR_OK) {",
          "4040:             TRACE_ERROR(\"CKA_PUBLIC_EXPONENT attribute missing.\\n\");",
          "4041:             return rc;",
          "4042:         }",
          "4044:         rc = template_attribute_get_non_empty(publ_tmpl, CKA_MODULUS, &pub_mod);",
          "4045:         if (rc != CKR_OK) {",
          "4046:             TRACE_ERROR(\"CKA_MODULUS attribute missing.\\n\");",
          "4047:             return rc;",
          "4048:         }",
          "4050:         rc = template_attribute_get_non_empty(publ_tmpl, CKA_MODULUS_BITS, &attr);",
          "4051:         if (rc != CKR_OK) {",
          "4052:             TRACE_ERROR(\"CKA_MODULUS_BITS attribute missing.\\n\");",
          "4053:             return rc;",
          "4054:         }",
          "4057:         if ((pub_mod->ulValueLen + 8) > (CK_ULONG)key_value_structure_length) {",
          "4058:             TRACE_ERROR(\"total length of key exceeds CCA_KEY_VALUE_STRUCT_SIZE.\\n\");",
          "4059:             return CKR_KEY_SIZE_RANGE;",
          "4060:         }",
          "4063:         if (*(CK_ULONG *) attr->pValue == 0)",
          "4064:             mod_bits = htons(pub_mod->ulValueLen * 8);",
          "4065:         else",
          "4066:             mod_bits = htons(*(CK_ULONG *) attr->pValue);",
          "4069:         memset(key_value_structure, 0, key_value_structure_length);",
          "4076:         memcpy(&key_value_structure[0], &mod_bits, sizeof(uint16_t));",
          "4079:         mod_bytes = htons(pub_mod->ulValueLen);",
          "4080:         memcpy(&key_value_structure[2], &mod_bytes, sizeof(uint16_t));",
          "4083:         size_of_e = htons((uint16_t) pub_exp->ulValueLen);",
          "4084:         memcpy(&key_value_structure[4], &size_of_e, sizeof(uint16_t));",
          "4089:         memcpy(&key_value_structure[8], pub_mod->pValue,",
          "4090:                (size_t) pub_mod->ulValueLen);",
          "4093:         memcpy(&key_value_structure[8 + mod_bytes],",
          "4094:                pub_exp->pValue, (size_t) pub_exp->ulValueLen);",
          "4098:         rule_array_count = 1;",
          "4099:         memcpy(rule_array, \"RSA-PUBL\", (size_t) (CCA_KEYWORD_SIZE * 1));",
          "4101:         private_key_name_length = 0;",
          "4103:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4107:         dll_CSNDPKB(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "4108:                     rule_array, &key_value_structure_length, key_value_structure,",
          "4109:                     &private_key_name_length, private_key_name, 0, NULL, 0,",
          "4110:                     NULL, 0, NULL, 0, NULL, 0, NULL, &key_token_length, key_token);",
          "4112:         if (return_code != CCA_SUCCESS) {",
          "4113:             TRACE_ERROR(\"CSNDPKB (RSA KEY TOKEN BUILD RSA-PUBL) failed.\"",
          "4114:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "4115:             return CKR_FUNCTION_FAILED;",
          "4116:         }",
          "4118:         if ((rc = build_update_attribute(publ_tmpl, CKA_IBM_OPAQUE,",
          "4119:                                          key_token, key_token_length))) {",
          "4120:             TRACE_DEVEL(\"build_update_attribute failed\\n\");",
          "4121:             return rc;",
          "4122:         }",
          "4125:     TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "4126:     TRACE_DEBUG_DUMPTEMPL(publ_tmpl);",
          "4134:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "4136:     rc = template_attribute_find(object->template, CKA_IBM_OPAQUE, &opaque_attr);",
          "4137:     if (rc == TRUE) {",
          "4146:         enum cca_token_type token_type;",
          "4147:         unsigned int token_keybitsize;",
          "4148:         CK_BYTE zorro[32] = { 0 };",
          "4149:         CK_BBOOL true = TRUE;",
          "4151:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "4152:                                   &token_type, &token_keybitsize) != TRUE) {",
          "4153:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "4154:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4155:         }",
          "4157:         if (keytype == CKK_DES) {",
          "4158:             if (token_type != sec_des_data_key) {",
          "4159:                 TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_DES\\n\");",
          "4160:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4161:             }",
          "4162:             if (token_keybitsize != 8 * 8) {",
          "4163:                 TRACE_ERROR(\"CCA token keybitsize %u does not match to keytype CKK_DES\\n\",",
          "4164:                             token_keybitsize);",
          "4165:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4166:             }",
          "4167:         } else if (keytype == CKK_DES3) {",
          "4168:             if (token_type != sec_des_data_key) {",
          "4169:                 TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_DES3\\n\");",
          "4170:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4171:             }",
          "4172:             if (token_keybitsize != 8 * 24) {",
          "4173:                 TRACE_ERROR(\"CCA token keybitsize %u does not match to keytype CKK_DES3\\n\",",
          "4174:                             token_keybitsize);",
          "4175:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4176:             }",
          "4177:         } else if (keytype == CKK_AES) {",
          "4178:             if (token_type == sec_aes_data_key) {",
          "4180:                 ;",
          "4181:             } else if (token_type == sec_aes_cipher_key) {",
          "4183:                 TRACE_ERROR(\"CCA AES cipher key import is not supported\\n\");",
          "4184:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4185:             } else {",
          "4186:                 TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_AES\\n\");",
          "4187:                 return CKR_TEMPLATE_INCONSISTENT;",
          "4188:             }",
          "4189:         } else {",
          "4190:             TRACE_DEBUG(\"Unknown/unsupported keytype in function %s line %d\\n\", __func__, __LINE__);",
          "4191:             return CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "4192:         }",
          "4195:         if ((rc = build_update_attribute(object->template, CKA_VALUE,",
          "4196:                                          zorro, token_keybitsize / 8))) {",
          "4197:             TRACE_DEVEL(\"build_update_attribute(CKA_VALUE) failed\\n\");",
          "4198:             return rc;",
          "4199:         }",
          "4202:         rc = build_update_attribute(object->template, CKA_SENSITIVE, &true, sizeof(CK_BBOOL));",
          "4203:         if (rc != CKR_OK) {",
          "4204:             TRACE_DEVEL(\"build_update_attribute for CKA_SENSITIVE failed. rc=0x%lx\\n\", rc);",
          "4205:             return rc;",
          "4206:         }",
          "4208:     } else {",
          "4214:         long return_code, reason_code, rule_array_count;",
          "4215:         unsigned char target_key_id[CCA_KEY_ID_SIZE] = { 0 };",
          "4216:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0 };",
          "4217:         CK_ATTRIBUTE *value_attr = NULL;",
          "4219:         rc = template_attribute_get_non_empty(object->template, CKA_VALUE, &value_attr);",
          "4220:         if (rc != CKR_OK) {",
          "4221:             TRACE_ERROR(\"Incomplete key template\\n\");",
          "4222:             return CKR_TEMPLATE_INCOMPLETE;",
          "4223:         }",
          "4225:         switch (keytype) {",
          "4226:         case CKK_AES:",
          "4227:             memcpy(rule_array, \"AES     \", CCA_KEYWORD_SIZE);",
          "4228:             break;",
          "4229:         case CKK_DES:",
          "4230:         case CKK_DES3:",
          "4231:             memcpy(rule_array, \"DES     \", CCA_KEYWORD_SIZE);",
          "4232:             break;",
          "4233:         default:",
          "4234:             return CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "4235:         }",
          "4237:         rule_array_count = 1;",
          "4239:         dll_CSNBCKM(&return_code, &reason_code, NULL, NULL,",
          "4240:                     &rule_array_count, rule_array,",
          "4241:                     (long int *)&value_attr->ulValueLen, value_attr->pValue,",
          "4242:                     target_key_id);",
          "4244:         if (return_code != CCA_SUCCESS) {",
          "4245:             TRACE_ERROR(\"CSNBCKM failed. return:%ld, reason:%ld\\n\",",
          "4246:                         return_code, reason_code);",
          "4247:             return CKR_FUNCTION_FAILED;",
          "4248:         }",
          "4251:         if ((rc = build_update_attribute(object->template, CKA_IBM_OPAQUE,",
          "4252:                                          target_key_id, CCA_KEY_ID_SIZE))) {",
          "4253:             TRACE_DEVEL(\"build_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4254:             return rc;",
          "4255:         }",
          "4258:         OPENSSL_cleanse(value_attr->pValue, value_attr->ulValueLen);",
          "4261:     TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "4262:     TRACE_DEBUG_DUMPTEMPL(object->template);",
          "4270:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "4271:     CK_ATTRIBUTE *value_attr = NULL;",
          "4272:     CK_ULONG keylen, keybitlen;",
          "4274:     rc = template_attribute_find(object->template, CKA_VALUE, &value_attr);",
          "4275:     if (rc == FALSE) {",
          "4277:         return CKR_TEMPLATE_INCOMPLETE;",
          "4279:     keylen = value_attr->ulValueLen;",
          "4280:     keybitlen = 8 * keylen;",
          "4283:     if (keybitlen < 80 || keybitlen > 2048) {",
          "4284:         TRACE_ERROR(\"HMAC key bit size of %lu not within CCA range (80-2048 bits)\\n\", keybitlen);",
          "4288:     rc = template_attribute_find(object->template, CKA_IBM_OPAQUE, &opaque_attr);",
          "4289:     if (rc == TRUE) {",
          "4298:         enum cca_token_type token_type;",
          "4299:         unsigned int token_payloadbitsize, plbitsize;",
          "4300:         CK_BBOOL true = TRUE;",
          "4302:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "4303:                                   &token_type, &token_payloadbitsize) != TRUE) {",
          "4304:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "4305:         return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4306:         }",
          "4308:         if (token_type != sec_hmac_key) {",
          "4309:             TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to\"",
          "4310:                         \" keytype CKK_GENERIC_SECRET\\n\");",
          "4311:             return CKR_TEMPLATE_INCONSISTENT;",
          "4312:         }",
          "4315:         plbitsize = (((keybitlen + 32) + 63) & (~63)) + 320;",
          "4317:         if (plbitsize != token_payloadbitsize) {",
          "4318:             TRACE_ERROR(\"CCA HMAC token payload size and keysize do not match\\n\");",
          "4319:             return CKR_TEMPLATE_INCONSISTENT;",
          "4320:         }",
          "4323:         rc = build_update_attribute(object->template, CKA_SENSITIVE, &true, sizeof(CK_BBOOL));",
          "4324:         if (rc != CKR_OK) {",
          "4325:             TRACE_DEVEL(\"build_update_attribute for CKA_SENSITIVE failed. rc=0x%lx\\n\", rc);",
          "4326:             return rc;",
          "4327:         }",
          "4329:     } else {",
          "4335:         long return_code, reason_code, rule_array_count;",
          "4336:         unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0 };",
          "4337:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0 };",
          "4338:         long key_name_len = 0, clr_key_len = 0;",
          "4339:         long user_data_len = 0, key_part_len = 0;",
          "4340:         long token_data_len = 0, verb_data_len = 0;",
          "4341:         long key_token_len = sizeof(key_token);",
          "4343:         memcpy(rule_array, \"INTERNALNO-KEY  HMAC    MAC     GENERATE\",",
          "4344:                5 * CCA_KEYWORD_SIZE);",
          "4345:         rule_array_count = 5;",
          "4347:         dll_CSNBKTB2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "4348:                      rule_array, &clr_key_len, NULL, &key_name_len, NULL,",
          "4349:                      &user_data_len, NULL, &token_data_len, NULL, &verb_data_len,",
          "4350:                      NULL, &key_token_len, key_token);",
          "4351:         if (return_code != CCA_SUCCESS) {",
          "4352:             TRACE_ERROR(\"CSNBKTB2 (HMAC KEY TOKEN BUILD) failed.\"",
          "4353:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "4354:             return CKR_FUNCTION_FAILED;",
          "4355:         }",
          "4357:         memcpy(rule_array, \"HMAC    FIRST   MIN1PART\", 3 * CCA_KEYWORD_SIZE);",
          "4358:         rule_array_count = 3;",
          "4359:         key_part_len = keylen * 8;",
          "4360:         key_token_len = sizeof(key_token);",
          "4362:         dll_CSNBKPI2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "4363:                      rule_array, &key_part_len, value_attr->pValue,",
          "4364:                      &key_token_len, key_token);",
          "4365:         if (return_code != CCA_SUCCESS) {",
          "4366:             TRACE_ERROR(\"CSNBKPI2 (HMAC KEY IMPORT FIRST) failed.\"",
          "4367:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "4368:             return CKR_FUNCTION_FAILED;",
          "4369:         }",
          "4371:         memcpy(rule_array, \"HMAC    COMPLETE\", 2 * CCA_KEYWORD_SIZE);",
          "4372:         rule_array_count = 2;",
          "4373:         key_part_len = 0;",
          "4374:         key_token_len = sizeof(key_token);",
          "4376:         dll_CSNBKPI2(&return_code, &reason_code, NULL, NULL, &rule_array_count,",
          "4377:                      rule_array, &key_part_len, NULL, &key_token_len, key_token);",
          "4378:         if (return_code != CCA_SUCCESS) {",
          "4379:             TRACE_ERROR(\"CSNBKPI2 (HMAC KEY IMPORT COMPLETE) failed.\"",
          "4380:                         \" return:%ld, reason:%ld\\n\", return_code, reason_code);",
          "4381:             return CKR_FUNCTION_FAILED;",
          "4382:         }",
          "4385:         if ((rc = build_update_attribute(object->template, CKA_IBM_OPAQUE,",
          "4386:                                          key_token, key_token_len))) {",
          "4387:             TRACE_DEVEL(\"build_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4388:             return rc;",
          "4389:         }",
          "4393:     OPENSSL_cleanse(value_attr->pValue, value_attr->ulValueLen);",
          "4395:     TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "4396:     TRACE_DEBUG_DUMPTEMPL(object->template);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3988:     return CKR_OK;",
          "3989: }",
          "3992: {",
          "4007:     CK_RV rc;",
          "4017:     }",
          "4021:     if (rc != CKR_OK) {",
          "4023:         return rc;",
          "4024:     }",
          "4110:     }",
          "4115:     return CKR_OK;",
          "4116: }",
          "4119: {",
          "4120:     CK_RV rc;",
          "4207:     }",
          "4209:     return CKR_OK;",
          "4210: }",
          "4212: CK_RV token_specific_object_add(STDLL_TokData_t *tokdata, SESSION *sess, OBJECT *object)",
          "4213: {",
          "4226:     rc = template_attribute_get_ulong(object->template, CKA_KEY_TYPE, &keytype);",
          "4227:     if (rc != CKR_OK) {",
          "4237:         if (rc != CKR_OK) {",
          "4239:             return rc;",
          "4240:         }",
          "4285:         if (rc != CKR_OK) {",
          "4287:             return rc;",
          "4288:         }",
          "4290:         switch(keyclass) {",
          "4291:         case CKO_PUBLIC_KEY:",
          "4294:             break;",
          "4295:         case CKO_PRIVATE_KEY:",
          "4298:             break;",
          "4299:         default:",
          "4300:             TRACE_ERROR(\"%s\\n\", ock_err(ERR_KEY_TYPE_INCONSISTENT));",
          "4301:             return CKR_KEY_TYPE_INCONSISTENT;",
          "4302:         }",
          "4308:         break;",
          "4316: }",
          "4318: CK_RV token_specific_generic_secret_key_gen(STDLL_TokData_t * tokdata,",
          "",
          "[Removed Lines]",
          "3991: static CK_RV ec_import_privkey(TEMPLATE *priv_templ)",
          "3993:     long private_key_name_length, key_token_length, target_key_token_length;",
          "3994:     long return_code, reason_code, rule_array_count, exit_data_len = 0;",
          "3995:     long key_value_structure_length, param1=0;",
          "3996:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "3997:     unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "3998:     unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "3999:     unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4000:     unsigned char transport_key_identifier[CCA_KEY_ID_SIZE] = { 0, };",
          "4001:     unsigned char target_key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4002:     unsigned char *exit_data = NULL;",
          "4003:     unsigned char *param2=NULL;",
          "4004:     CK_BYTE *privkey = NULL, *pubkey = NULL;",
          "4005:     CK_ATTRIBUTE *attr = NULL, *opaque_key;",
          "4006:     CK_ULONG privlen = 0, publen = 0;",
          "4008:     uint8_t curve_type;",
          "4009:     uint16_t curve_bitlen;",
          "4010:     CK_ULONG field_len;",
          "4013:     rc = curve_supported(priv_templ, &curve_type, &curve_bitlen);",
          "4014:     if (rc != CKR_OK) {",
          "4015:         TRACE_ERROR(\"Curve not supported by this token.\\n\");",
          "4016:         return rc;",
          "4020:     rc = template_attribute_get_non_empty(priv_templ, CKA_VALUE, &attr);",
          "4022:         TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");",
          "4026:     privlen = attr->ulValueLen;",
          "4027:     privkey = attr->pValue;",
          "4030:     rc = template_attribute_get_non_empty(priv_templ, CKA_EC_POINT, &attr);",
          "4031:     if (rc != CKR_OK) {",
          "4032:         TRACE_ERROR(\"Could not find CKA_EC_POINT for the key.\\n\");",
          "4033:         return rc;",
          "4034:     }",
          "4036:     rc = ber_decode_OCTET_STRING(attr->pValue, &pubkey, &publen,",
          "4037:                                  &field_len);",
          "4038:     if (rc != CKR_OK || attr->ulValueLen != field_len) {",
          "4039:         TRACE_DEVEL(\"ber decoding of public key failed\\n\");",
          "4040:         return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4041:     }",
          "4044:     memset(key_value_structure, 0, CCA_KEY_VALUE_STRUCT_SIZE);",
          "4046:     rc = build_private_EC_key_value_structure(privkey, privlen,",
          "4047:             pubkey, publen, curve_type, curve_bitlen,",
          "4048:             (unsigned char *)&key_value_structure,",
          "4049:             &key_value_structure_length);",
          "4050:     if (rc != CKR_OK)",
          "4051:         return rc;",
          "4054:     rule_array_count = 1;",
          "4055:     memcpy(rule_array, \"ECC-PAIR\", (size_t)(CCA_KEYWORD_SIZE));",
          "4056:     private_key_name_length = 0;",
          "4057:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4058:     key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "4060:     dll_CSNDPKB(&return_code, &reason_code,",
          "4061:             &exit_data_len, exit_data,",
          "4062:             &rule_array_count, rule_array,",
          "4063:             &key_value_structure_length, key_value_structure,",
          "4064:             &private_key_name_length, private_key_name,",
          "4065:             &param1, param2, &param1, param2, &param1, param2,",
          "4066:             &param1, param2, &param1, param2,",
          "4067:             &key_token_length,",
          "4068:             key_token);",
          "4070:     if (return_code != CCA_SUCCESS) {",
          "4071:         TRACE_ERROR(\"CSNDPKB (EC KEY TOKEN BUILD) failed. return:%ld,\"",
          "4072:                 \" reason:%ld\\n\", return_code, reason_code);",
          "4073:         if (is_curve_error(return_code, reason_code))",
          "4074:             return CKR_CURVE_NOT_SUPPORTED;",
          "4075:         return CKR_FUNCTION_FAILED;",
          "4076:     }",
          "4079:     rule_array_count = 1;",
          "4080:     memcpy(rule_array, \"ECC     \", (size_t)(CCA_KEYWORD_SIZE));",
          "4081:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4082:     target_key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4084:     dll_CSNDPKI(&return_code, &reason_code, NULL, NULL,",
          "4085:             &rule_array_count, rule_array,",
          "4086:             &key_token_length, key_token,",
          "4087:             transport_key_identifier,",
          "4088:             &target_key_token_length, target_key_token);",
          "4090:     if (return_code != CCA_SUCCESS) {",
          "4091:         TRACE_ERROR(\"CSNDPKI (EC KEY TOKEN IMPORT) failed.\" \" return:%ld, reason:%ld\\n\",",
          "4092:                 return_code, reason_code);",
          "4093:         if (is_curve_error(return_code, reason_code))",
          "4094:             return CKR_CURVE_NOT_SUPPORTED;",
          "4095:         return CKR_FUNCTION_FAILED;",
          "4096:     }",
          "4099:     if ((rc = build_attribute(CKA_IBM_OPAQUE, target_key_token,",
          "4100:                         target_key_token_length, &opaque_key))) {",
          "4101:         TRACE_DEVEL(\"build_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4102:         return rc;",
          "4103:     }",
          "4105:     rc = template_update_attribute(priv_templ, opaque_key);",
          "4106:     if (rc != CKR_OK) {",
          "4107:         TRACE_DEVEL(\"template_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4108:         free(opaque_key);",
          "4109:         return rc;",
          "4113:     OPENSSL_cleanse(privkey, privlen);",
          "4118: static CK_RV ec_import_pubkey(TEMPLATE *pub_templ)",
          "4121:     long return_code, reason_code, rule_array_count, exit_data_len = 0;",
          "4122:     long private_key_name_length, key_token_length;",
          "4123:     unsigned char *exit_data = NULL;",
          "4124:     unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "4125:     long key_value_structure_length;",
          "4126:     unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "4127:     unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "4128:     unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4129:     CK_ATTRIBUTE *opaque_key;",
          "4130:     long param1=0;",
          "4131:     unsigned char *param2=NULL;",
          "4132:     uint8_t curve_type;",
          "4133:     uint16_t curve_bitlen;",
          "4134:     CK_BYTE *pubkey = NULL;",
          "4135:     CK_ULONG publen = 0;",
          "4136:     CK_ATTRIBUTE *attr = NULL;",
          "4137:     CK_ULONG field_len;",
          "4140:     rc = curve_supported(pub_templ, &curve_type, &curve_bitlen);",
          "4141:     if (rc != CKR_OK) {",
          "4142:         TRACE_ERROR(\"Curve not supported by this token.\\n\");",
          "4143:         return rc;",
          "4144:     }",
          "4147:     rc = template_attribute_get_non_empty(pub_templ, CKA_EC_POINT, &attr);",
          "4148:     if (rc != CKR_OK) {",
          "4149:         TRACE_ERROR(\"Could not find CKA_EC_POINT for the key.\\n\");",
          "4150:         return rc;",
          "4151:     }",
          "4153:     rc = ber_decode_OCTET_STRING(attr->pValue, &pubkey, &publen,",
          "4154:                                  &field_len);",
          "4155:     if (rc != CKR_OK || attr->ulValueLen != field_len) {",
          "4156:         TRACE_DEVEL(\"ber decoding of public key failed\\n\");",
          "4157:         return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4158:     }",
          "4161:     memset(key_value_structure, 0, CCA_KEY_VALUE_STRUCT_SIZE);",
          "4163:     rc = build_public_EC_key_value_structure(pubkey, publen,",
          "4164:             curve_type, curve_bitlen,",
          "4165:             (unsigned char *)&key_value_structure,",
          "4166:             &key_value_structure_length);",
          "4167:     if (rc != CKR_OK)",
          "4168:         return rc;",
          "4171:     rule_array_count = 1;",
          "4172:     memcpy(rule_array, \"ECC-PUBL\", (size_t)(CCA_KEYWORD_SIZE));",
          "4173:     private_key_name_length = 0;",
          "4174:     key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4175:     key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "4177:     dll_CSNDPKB(&return_code, &reason_code,",
          "4178:             &exit_data_len, exit_data,",
          "4179:             &rule_array_count, rule_array,",
          "4180:             &key_value_structure_length, key_value_structure,",
          "4181:             &private_key_name_length, private_key_name,",
          "4182:             &param1, param2, &param1, param2, &param1, param2,",
          "4183:             &param1, param2, &param1, param2,",
          "4184:             &key_token_length,",
          "4185:             key_token);",
          "4187:     if (return_code != CCA_SUCCESS) {",
          "4188:         TRACE_ERROR(\"CSNDPKB (EC KEY TOKEN BUILD) failed. return:%ld,\"",
          "4189:                 \" reason:%ld\\n\", return_code, reason_code);",
          "4190:         if (is_curve_error(return_code, reason_code))",
          "4191:             return CKR_CURVE_NOT_SUPPORTED;",
          "4192:         return CKR_FUNCTION_FAILED;",
          "4193:     }",
          "4197:     if ((rc = build_attribute(CKA_IBM_OPAQUE, key_token, key_token_length,",
          "4198:                               &opaque_key))) {",
          "4199:         TRACE_DEVEL(\"build_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4200:         return rc;",
          "4201:     }",
          "4202:     rc = template_update_attribute(pub_templ, opaque_key);",
          "4203:     if (rc != CKR_OK) {",
          "4204:         TRACE_DEVEL(\"template_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4205:         free(opaque_key);",
          "4206:         return rc;",
          "4214:  CK_RV rc;",
          "4215:  CK_KEY_TYPE keytype;",
          "4216:  CK_OBJECT_CLASS keyclass;",
          "4218:  UNUSED(tokdata);",
          "4219:  UNUSED(sess);",
          "4221:  if (!object) {",
          "4222:   TRACE_ERROR(\"Invalid argument\\n\");",
          "4223:   return CKR_FUNCTION_FAILED;",
          "4224:  }",
          "4229:   TRACE_DEVEL(\"object not a key, no need to import.\\n\");",
          "4230:   return CKR_OK;",
          "4231:  }",
          "4233:  switch (keytype) {",
          "4234:  case CKK_RSA:",
          "4235:         rc = template_attribute_get_ulong(object->template, CKA_CLASS,",
          "4236:                                           &keyclass);",
          "4238:             TRACE_ERROR(\"Could not find CKA_CLASS for the key.\\n\");",
          "4242:   switch(keyclass) {",
          "4243:   case CKO_PUBLIC_KEY:",
          "4245:    rc = rsa_import_pubkey(object->template);",
          "4246:    break;",
          "4247:   case CKO_PRIVATE_KEY:",
          "4249:    rc = rsa_import_privkey_crt(object->template);",
          "4250:    break;",
          "4251:   default:",
          "4252:    TRACE_ERROR(\"%s\\n\", ock_err(ERR_KEY_TYPE_INCONSISTENT));",
          "4253:    return CKR_KEY_TYPE_INCONSISTENT;",
          "4254:   }",
          "4256:   if (rc != CKR_OK) {",
          "4257:    TRACE_DEVEL(\"rsa import failed\\n\");",
          "4258:    return rc;",
          "4259:   }",
          "4261:   break;",
          "4262:  case CKK_AES:",
          "4263:  case CKK_DES:",
          "4264:  case CKK_DES3:",
          "4265:   rc = import_symmetric_key(object, keytype);",
          "4266:   if (rc != CKR_OK) {",
          "4267:    TRACE_DEVEL(\"Symmetric key import failed, rc=0x%lx\\n\",",
          "4268:          rc);",
          "4269:    return rc;",
          "4270:   }",
          "4271:   TRACE_INFO(\"symmetric key successful imported\\n\");",
          "4272:   break;",
          "4273:  case CKK_GENERIC_SECRET:",
          "4274:   rc = import_generic_secret_key(object);",
          "4275:   if (rc != CKR_OK) {",
          "4276:    TRACE_DEVEL(\"Generic Secret (HMAC) key import failed \"",
          "4277:         \" with rc=0x%lx\\n\", rc);",
          "4278:    return rc;",
          "4279:   }",
          "4280:   TRACE_INFO(\"Generic Secret (HMAC) key successfully imported\\n\");",
          "4281:   break;",
          "4282:     case CKK_EC:",
          "4283:         rc = template_attribute_get_ulong(object->template, CKA_CLASS,",
          "4284:                                           &keyclass);",
          "4286:             TRACE_ERROR(\"Could not find CKA_CLASS for the key.\\n\");",
          "4293:             rc = ec_import_pubkey(object->template);",
          "4297:             rc = ec_import_privkey(object->template);",
          "4304:         if (rc != CKR_OK) {",
          "4305:             TRACE_DEVEL(\"ec import failed\\n\");",
          "4306:             return rc;",
          "4307:         }",
          "4309:  default:",
          "4311:   TRACE_ERROR(\"Unknown/unsupported key type 0x%lx\\n\", keytype);",
          "4312:   return CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "4313:  }",
          "4315:  return CKR_OK;",
          "",
          "[Added Lines]",
          "4494: static CK_RV check_cca_ec_type_and_add_params(uint8_t cca_ec_type,",
          "4495:                                               uint16_t cca_ec_bits,",
          "4496:                                               TEMPLATE *templ)",
          "4500:     switch (cca_ec_type) {",
          "4502:         switch (cca_ec_bits) {",
          "4503:         case 192:",
          "4504:             {",
          "4505:                 CK_BYTE curve[] = OCK_PRIME192V1;",
          "4506:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4507:             }",
          "4508:             break;",
          "4509:         case 224:",
          "4510:             {",
          "4511:                 CK_BYTE curve[] = OCK_SECP224R1;",
          "4512:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4513:             }",
          "4514:             break;",
          "4515:         case 256:",
          "4516:             {",
          "4517:                 CK_BYTE curve[] = OCK_PRIME256V1;",
          "4518:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4519:             }",
          "4520:             break;",
          "4521:         case 384:",
          "4522:             {",
          "4523:                 CK_BYTE curve[] = OCK_SECP384R1;",
          "4524:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4525:             }",
          "4526:             break;",
          "4527:         case 521:",
          "4528:             {",
          "4529:                 CK_BYTE curve[] = OCK_SECP521R1;",
          "4530:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4531:             }",
          "4532:             break;",
          "4533:         default:",
          "4534:             TRACE_ERROR(\"CCA token type with unknown prime curve bits %hu\\n\", cca_ec_bits);",
          "4535:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4536:         }",
          "4537:         break;",
          "4539:         switch (cca_ec_bits) {",
          "4540:         case 160:",
          "4541:             {",
          "4542:                 CK_BYTE curve[] = OCK_BRAINPOOL_P160R1;",
          "4543:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4544:             }",
          "4545:             break;",
          "4546:         case 192:",
          "4547:             {",
          "4548:                 CK_BYTE curve[] = OCK_BRAINPOOL_P192R1;",
          "4549:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4550:             }",
          "4551:             break;",
          "4552:         case 224:",
          "4553:             {",
          "4554:                 CK_BYTE curve[] = OCK_BRAINPOOL_P224R1;",
          "4555:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4556:             }",
          "4557:             break;",
          "4558:         case 256:",
          "4559:             {",
          "4560:                 CK_BYTE curve[] = OCK_BRAINPOOL_P256R1;",
          "4561:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4562:             }",
          "4563:             break;",
          "4564:         case 320:",
          "4565:             {",
          "4566:                 CK_BYTE curve[] = OCK_BRAINPOOL_P320R1;",
          "4567:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4568:             }",
          "4569:             break;",
          "4570:         case 384:",
          "4571:             {",
          "4572:                 CK_BYTE curve[] = OCK_BRAINPOOL_P384R1;",
          "4573:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4574:             }",
          "4575:             break;",
          "4576:         case 512:",
          "4577:             {",
          "4578:                 CK_BYTE curve[] = OCK_BRAINPOOL_P512R1;",
          "4579:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4580:             }",
          "4581:             break;",
          "4582:         default:",
          "4583:             TRACE_ERROR(\"CCA token type with unknown brainpool curve bits %hu\\n\", cca_ec_bits);",
          "4584:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4585:         }",
          "4586:         break;",
          "4588:         switch (cca_ec_bits) {",
          "4589:         case 255:",
          "4590:             {",
          "4591:                 CK_BYTE curve[] = OCK_ED25519;",
          "4592:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4593:             }",
          "4594:             break;",
          "4595:         case 448:",
          "4596:             {",
          "4597:                 CK_BYTE curve[] = OCK_ED448;",
          "4598:                 rc = build_update_attribute(templ, CKA_EC_PARAMS, curve, sizeof(curve));",
          "4599:             }",
          "4600:             break;",
          "4601:         default:",
          "4602:             TRACE_ERROR(\"CCA token type with unknown edwards curve bits %hu\\n\", cca_ec_bits);",
          "4603:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4604:         }",
          "4605:         break;",
          "4606:     default:",
          "4607:         TRACE_ERROR(\"CCA token type with invalid/unknown curve type %hhu\\n\", cca_ec_type);",
          "4608:         return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4612:         TRACE_DEVEL(\"build_update_attribute(CKA_EC_PARAMS) failed\\n\");",
          "4616:     return CKR_OK;",
          "4617: }",
          "4619: static CK_RV import_ec_privkey(TEMPLATE *priv_templ)",
          "4620: {",
          "4621:     CK_RV rc;",
          "4622:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "4624:     rc = template_attribute_find(priv_templ, CKA_IBM_OPAQUE, &opaque_attr);",
          "4625:     if (rc == TRUE) {",
          "4630:         enum cca_token_type token_type;",
          "4631:         unsigned int token_keybitsize;",
          "4632:         CK_BBOOL true = TRUE;",
          "4633:         CK_BYTE *t;",
          "4635:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "4636:                                   &token_type, &token_keybitsize) != TRUE) {",
          "4637:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "4638:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4639:         }",
          "4640:         if (token_type != sec_ecc_priv_key) {",
          "4641:             TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_EC\\n\");",
          "4642:             return CKR_TEMPLATE_INCONSISTENT;",
          "4643:         }",
          "4646:         t = opaque_attr->pValue;",
          "4647:         rc = check_cca_ec_type_and_add_params(t[8+9], token_keybitsize, priv_templ);",
          "4648:         if (rc != CKR_OK)",
          "4649:             return rc;",
          "4652:         rc = build_update_attribute(priv_templ, CKA_SENSITIVE, &true, sizeof(CK_BBOOL));",
          "4653:         if (rc != CKR_OK) {",
          "4654:             TRACE_DEVEL(\"build_update_attribute for CKA_SENSITIVE failed. rc=0x%lx\\n\", rc);",
          "4655:             return rc;",
          "4656:         }",
          "4658:     } else {",
          "4664:         long private_key_name_length, key_token_length, target_key_token_length;",
          "4665:         long return_code, reason_code, rule_array_count, exit_data_len = 0;",
          "4666:         long key_value_structure_length, param1=0;",
          "4667:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "4668:         unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "4669:         unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "4670:         unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4671:         unsigned char transport_key_identifier[CCA_KEY_ID_SIZE] = { 0, };",
          "4672:         unsigned char target_key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4673:         unsigned char *exit_data = NULL;",
          "4674:         unsigned char *param2=NULL;",
          "4675:         CK_BYTE *privkey = NULL, *pubkey = NULL;",
          "4676:         CK_ATTRIBUTE *attr = NULL;",
          "4677:         CK_ULONG privlen = 0, publen = 0;",
          "4678:         uint8_t curve_type;",
          "4679:         uint16_t curve_bitlen;",
          "4680:         CK_ULONG field_len;",
          "4683:         rc = curve_supported(priv_templ, &curve_type, &curve_bitlen);",
          "4684:         if (rc != CKR_OK) {",
          "4685:             TRACE_ERROR(\"Curve not supported by this token.\\n\");",
          "4686:             return rc;",
          "4687:         }",
          "4690:         rc = template_attribute_get_non_empty(priv_templ, CKA_VALUE, &attr);",
          "4691:         if (rc != CKR_OK) {",
          "4692:             TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");",
          "4693:             return rc;",
          "4694:         }",
          "4696:         privlen = attr->ulValueLen;",
          "4697:         privkey = attr->pValue;",
          "4700:         rc = template_attribute_get_non_empty(priv_templ, CKA_EC_POINT, &attr);",
          "4701:         if (rc != CKR_OK) {",
          "4702:             TRACE_ERROR(\"Could not find CKA_EC_POINT for the key.\\n\");",
          "4703:             return rc;",
          "4704:         }",
          "4706:         rc = ber_decode_OCTET_STRING(attr->pValue, &pubkey, &publen,",
          "4707:                                      &field_len);",
          "4708:         if (rc != CKR_OK || attr->ulValueLen != field_len) {",
          "4709:             TRACE_DEVEL(\"ber decoding of public key failed\\n\");",
          "4710:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4711:         }",
          "4714:         memset(key_value_structure, 0, CCA_KEY_VALUE_STRUCT_SIZE);",
          "4716:         rc = build_private_EC_key_value_structure(privkey, privlen,",
          "4717:                                                   pubkey, publen, curve_type, curve_bitlen,",
          "4718:                                                   (unsigned char *)&key_value_structure,",
          "4719:                                                   &key_value_structure_length);",
          "4720:         if (rc != CKR_OK)",
          "4721:             return rc;",
          "4724:         rule_array_count = 1;",
          "4725:         memcpy(rule_array, \"ECC-PAIR\", (size_t)(CCA_KEYWORD_SIZE));",
          "4726:         private_key_name_length = 0;",
          "4727:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4728:         key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "4730:         dll_CSNDPKB(&return_code, &reason_code,",
          "4731:                     &exit_data_len, exit_data,",
          "4732:                     &rule_array_count, rule_array,",
          "4733:                     &key_value_structure_length, key_value_structure,",
          "4734:                     &private_key_name_length, private_key_name,",
          "4735:                     &param1, param2, &param1, param2, &param1, param2,",
          "4736:                     &param1, param2, &param1, param2,",
          "4737:                     &key_token_length,",
          "4738:                     key_token);",
          "4740:         if (return_code != CCA_SUCCESS) {",
          "4741:             TRACE_ERROR(\"CSNDPKB (EC KEY TOKEN BUILD) failed. return:%ld,\"",
          "4742:                         \" reason:%ld\\n\", return_code, reason_code);",
          "4743:             if (is_curve_error(return_code, reason_code))",
          "4744:                 return CKR_CURVE_NOT_SUPPORTED;",
          "4745:             return CKR_FUNCTION_FAILED;",
          "4746:         }",
          "4749:         rule_array_count = 1;",
          "4750:         memcpy(rule_array, \"ECC     \", (size_t)(CCA_KEYWORD_SIZE));",
          "4751:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4752:         target_key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4754:         dll_CSNDPKI(&return_code, &reason_code, NULL, NULL,",
          "4755:                     &rule_array_count, rule_array,",
          "4756:                     &key_token_length, key_token,",
          "4757:                     transport_key_identifier,",
          "4758:                     &target_key_token_length, target_key_token);",
          "4760:         if (return_code != CCA_SUCCESS) {",
          "4761:             TRACE_ERROR(\"CSNDPKI (EC KEY TOKEN IMPORT) failed.\" \" return:%ld, reason:%ld\\n\",",
          "4762:                         return_code, reason_code);",
          "4763:             if (is_curve_error(return_code, reason_code))",
          "4764:                 return CKR_CURVE_NOT_SUPPORTED;",
          "4765:             return CKR_FUNCTION_FAILED;",
          "4766:         }",
          "4769:         if ((rc = build_update_attribute(priv_templ, CKA_IBM_OPAQUE,",
          "4770:                                          target_key_token, target_key_token_length))) {",
          "4771:             TRACE_DEVEL(\"build_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4772:             return rc;",
          "4773:         }",
          "4776:         OPENSSL_cleanse(privkey, privlen);",
          "4779:     TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "4780:     TRACE_DEBUG_DUMPTEMPL(priv_templ);",
          "4785: static CK_RV import_ec_pubkey(TEMPLATE *pub_templ)",
          "4788:     CK_ATTRIBUTE *opaque_attr = NULL;",
          "4790:     rc = template_attribute_find(pub_templ, CKA_IBM_OPAQUE, &opaque_attr);",
          "4791:     if (rc == TRUE) {",
          "4796:         enum cca_token_type token_type;",
          "4797:         unsigned int token_keybitsize;",
          "4798:         CK_BYTE *t, *q;",
          "4799:         uint16_t q_len;",
          "4800:         CK_BYTE *ecpoint = NULL;",
          "4801:         CK_ULONG ecpoint_len;",
          "4803:         if (analyse_cca_key_token(opaque_attr->pValue, opaque_attr->ulValueLen,",
          "4804:                                   &token_type, &token_keybitsize) != TRUE) {",
          "4805:             TRACE_ERROR(\"Invalid/unknown cca token in CKA_IBM_OPAQUE attribute\\n\");",
          "4806:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4807:         }",
          "4808:         if (token_type != sec_ecc_publ_key) {",
          "4809:             TRACE_ERROR(\"CCA token type in CKA_IBM_OPAQUE does not match to keytype CKK_EC\\n\");",
          "4810:             return CKR_TEMPLATE_INCONSISTENT;",
          "4811:         }",
          "4814:         t = opaque_attr->pValue;",
          "4815:         rc = check_cca_ec_type_and_add_params(t[8+8], token_keybitsize, pub_templ);",
          "4816:         if (rc != CKR_OK)",
          "4817:             return rc;",
          "4820:         q = (CK_BYTE *)(t + 8 + 14);",
          "4821:         q_len = ntohs(*((uint16_t *)(t + 8 + 12)));",
          "4822:         if (q_len > CCATOK_EC_MAX_Q_LEN) {",
          "4823:             TRACE_ERROR(\"Invalid Q len %hu\\n\", q_len);",
          "4824:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4825:         }",
          "4826:         rc = ber_encode_OCTET_STRING(FALSE, &ecpoint, &ecpoint_len, q, q_len);",
          "4827:         if (rc != CKR_OK) {",
          "4828:             TRACE_DEVEL(\"ber_encode_OCTET_STRING failed\\n\");",
          "4829:             return rc;",
          "4830:         }",
          "4831:         rc = build_update_attribute(pub_templ, CKA_EC_POINT, ecpoint, ecpoint_len);",
          "4832:         free(ecpoint);",
          "4833:         if (rc != CKR_OK) {",
          "4834:             TRACE_DEVEL(\"build_update_attribute(CKA_EC_POINT) failed\\n\");",
          "4835:             return rc;",
          "4836:         }",
          "4838:     } else {",
          "4844:         long return_code, reason_code, rule_array_count, exit_data_len = 0;",
          "4845:         long private_key_name_length, key_token_length;",
          "4846:         unsigned char *exit_data = NULL;",
          "4847:         unsigned char rule_array[CCA_RULE_ARRAY_SIZE] = { 0, };",
          "4848:         long key_value_structure_length;",
          "4849:         unsigned char key_value_structure[CCA_KEY_VALUE_STRUCT_SIZE] = { 0, };",
          "4850:         unsigned char private_key_name[CCA_PRIVATE_KEY_NAME_SIZE] = { 0, };",
          "4851:         unsigned char key_token[CCA_KEY_TOKEN_SIZE] = { 0, };",
          "4852:         long param1=0;",
          "4853:         unsigned char *param2=NULL;",
          "4854:         uint8_t curve_type;",
          "4855:         uint16_t curve_bitlen;",
          "4856:         CK_BYTE *pubkey = NULL;",
          "4857:         CK_ULONG publen = 0;",
          "4858:         CK_ATTRIBUTE *attr = NULL;",
          "4859:         CK_ULONG field_len;",
          "4862:         rc = curve_supported(pub_templ, &curve_type, &curve_bitlen);",
          "4863:         if (rc != CKR_OK) {",
          "4864:             TRACE_ERROR(\"Curve not supported by this token.\\n\");",
          "4865:             return rc;",
          "4866:         }",
          "4869:         rc = template_attribute_get_non_empty(pub_templ, CKA_EC_POINT, &attr);",
          "4870:         if (rc != CKR_OK) {",
          "4871:             TRACE_ERROR(\"Could not find CKA_EC_POINT for the key.\\n\");",
          "4872:             return rc;",
          "4873:         }",
          "4875:         rc = ber_decode_OCTET_STRING(attr->pValue, &pubkey, &publen,",
          "4876:                                      &field_len);",
          "4877:         if (rc != CKR_OK || attr->ulValueLen != field_len) {",
          "4878:             TRACE_DEVEL(\"ber decoding of public key failed\\n\");",
          "4879:             return CKR_ATTRIBUTE_VALUE_INVALID;",
          "4880:         }",
          "4883:         memset(key_value_structure, 0, CCA_KEY_VALUE_STRUCT_SIZE);",
          "4885:         rc = build_public_EC_key_value_structure(pubkey, publen,",
          "4886:                                                  curve_type, curve_bitlen,",
          "4887:                                                  (unsigned char *)&key_value_structure,",
          "4888:                                                  &key_value_structure_length);",
          "4889:         if (rc != CKR_OK)",
          "4890:             return rc;",
          "4893:         rule_array_count = 1;",
          "4894:         memcpy(rule_array, \"ECC-PUBL\", (size_t)(CCA_KEYWORD_SIZE));",
          "4895:         private_key_name_length = 0;",
          "4896:         key_token_length = CCA_KEY_TOKEN_SIZE;",
          "4897:         key_value_structure_length = CCA_KEY_VALUE_STRUCT_SIZE;",
          "4899:         dll_CSNDPKB(&return_code, &reason_code,",
          "4900:                     &exit_data_len, exit_data,",
          "4901:                     &rule_array_count, rule_array,",
          "4902:                     &key_value_structure_length, key_value_structure,",
          "4903:                     &private_key_name_length, private_key_name,",
          "4904:                     &param1, param2, &param1, param2, &param1, param2,",
          "4905:                     &param1, param2, &param1, param2,",
          "4906:                     &key_token_length,",
          "4907:                     key_token);",
          "4909:         if (return_code != CCA_SUCCESS) {",
          "4910:             TRACE_ERROR(\"CSNDPKB (EC KEY TOKEN BUILD) failed. return:%ld,\"",
          "4911:                         \" reason:%ld\\n\", return_code, reason_code);",
          "4912:             if (is_curve_error(return_code, reason_code))",
          "4913:                 return CKR_CURVE_NOT_SUPPORTED;",
          "4914:             return CKR_FUNCTION_FAILED;",
          "4915:         }",
          "4919:         if ((rc = build_update_attribute(pub_templ, CKA_IBM_OPAQUE,",
          "4920:                                          key_token, key_token_length))) {",
          "4921:             TRACE_DEVEL(\"build_update_attribute(CKA_IBM_OPAQUE) failed\\n\");",
          "4922:             return rc;",
          "4923:         }",
          "4926:     TRACE_DEBUG(\"%s: imported object template attributes:\\n\", __func__);",
          "4927:     TRACE_DEBUG_DUMPTEMPL(pub_templ);",
          "4934:     CK_RV rc;",
          "4935:     CK_ATTRIBUTE *attr = NULL;",
          "4936:     CK_KEY_TYPE keytype;",
          "4937:     CK_OBJECT_CLASS keyclass;",
          "4939:     UNUSED(tokdata);",
          "4940:     UNUSED(sess);",
          "4942:     if (!object) {",
          "4943:         TRACE_ERROR(\"Invalid argument\\n\");",
          "4944:         return CKR_FUNCTION_FAILED;",
          "4945:     }",
          "4951:         TRACE_DEVEL(\"object not a key, no need to import.\\n\");",
          "4952:         return CKR_OK;",
          "4953:     }",
          "4956:     rc = template_attribute_get_ulong(object->template, CKA_CLASS, &keyclass);",
          "4957:     if (rc != CKR_OK) {",
          "4958:         TRACE_ERROR(\"object has no CKA_CLASS value %s\\n\", ock_err(ERR_TEMPLATE_INCOMPLETE));",
          "4959:         return CKR_TEMPLATE_INCOMPLETE;",
          "4960:     }",
          "4963:     template_attribute_find(object->template, CKA_VALUE, &attr);",
          "4965:     switch (keytype) {",
          "4966:     case CKK_RSA:",
          "4967:         switch(keyclass) {",
          "4968:         case CKO_PUBLIC_KEY:",
          "4970:             rc = import_rsa_pubkey(object->template);",
          "4971:             if (rc != CKR_OK) {",
          "4972:                 TRACE_DEVEL(\"RSA public key import failed, rc=0x%lx\\n\", rc);",
          "4973:                 return rc;",
          "4974:             }",
          "4975:             TRACE_INFO(\"RSA public key imported\\n\");",
          "4976:             break;",
          "4977:         case CKO_PRIVATE_KEY:",
          "4979:             rc = import_rsa_privkey(object->template);",
          "4980:             if (rc != CKR_OK) {",
          "4981:                 TRACE_DEVEL(\"RSA private key import failed, rc=0x%lx\\n\", rc);",
          "4982:                 return rc;",
          "4983:             }",
          "4984:             TRACE_INFO(\"RSA private key imported\\n\");",
          "4985:             break;",
          "4986:         default:",
          "4987:             TRACE_ERROR(\"%s\\n\", ock_err(ERR_KEY_TYPE_INCONSISTENT));",
          "4988:             return CKR_KEY_TYPE_INCONSISTENT;",
          "4989:         }",
          "4990:         break;",
          "4991:     case CKK_AES:",
          "4992:     case CKK_DES:",
          "4993:     case CKK_DES3:",
          "4994:         rc = import_symmetric_key(object, keytype);",
          "4996:             TRACE_DEVEL(\"Symmetric key import failed, rc=0x%lx\\n\", rc);",
          "4999:         TRACE_INFO(\"symmetric key with len=%ld successful imported\\n\",",
          "5000:                    attr->ulValueLen);",
          "5001:         break;",
          "5002:     case CKK_GENERIC_SECRET:",
          "5003:         rc = import_generic_secret_key(object);",
          "5005:             TRACE_DEVEL(\"Generic Secret (HMAC) key import failed \"",
          "5006:                         \" with rc=0x%lx\\n\", rc);",
          "5009:         TRACE_INFO(\"Generic Secret (HMAC) key with len=%ld successfully\"",
          "5010:                    \" imported\\n\", attr->ulValueLen);",
          "5011:         break;",
          "5012:     case CKK_EC:",
          "5016:             rc = import_ec_pubkey(object->template);",
          "5017:             if (rc != CKR_OK) {",
          "5018:                 TRACE_DEVEL(\"ECpublic key import failed, rc=0x%lx\\n\", rc);",
          "5019:                 return rc;",
          "5020:             }",
          "5021:             TRACE_INFO(\"EC public key imported\\n\");",
          "5025:             rc = import_ec_privkey(object->template);",
          "5026:             if (rc != CKR_OK) {",
          "5027:                 TRACE_DEVEL(\"EC private key import failed, rc=0x%lx\\n\", rc);",
          "5028:                 return rc;",
          "5029:             }",
          "5030:             TRACE_INFO(\"EC private key imported\\n\");",
          "5037:     default:",
          "5039:         TRACE_ERROR(\"Unknown/unsupported key type 0x%lx\\n\", keytype);",
          "5040:         return CKR_KEY_FUNCTION_NOT_PERMITTED;",
          "5041:     }",
          "5043:     return CKR_OK;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4409:         return rc;",
          "4410:     }",
          "4412:     return CKR_OK;",
          "4413: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5140:     TRACE_DEBUG(\"%s: secret key template attributes:\\n\", __func__);",
          "5141:     TRACE_DEBUG_DUMPTEMPL(template);",
          "",
          "---------------"
        ],
        "usr/lib/cca_stdll/cca_stdll.h||usr/lib/cca_stdll/cca_stdll.h": [
          "File: usr/lib/cca_stdll/cca_stdll.h -> usr/lib/cca_stdll/cca_stdll.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #define CCA_RSA_INTTOK_PRIVKEY_LENGTH_OFFSET 2",
          "69: #define CCA_RSA_INTTOK_PUBKEY_LENGTH_OFFSET 2",
          "75: #define CCA_RSA_INTTOK_PUBKEY_E_LENGTH_OFFSET 6",
          "",
          "[Removed Lines]",
          "71: #define CCA_RSA_INTTOK_PRIVKEY_N_LENGTH_OFFSET 62",
          "73: #define CCA_RSA_INTTOK_PRIVKEY_N_OFFSET 134",
          "",
          "[Added Lines]",
          "71: #define CCA_RSA_INTTOK_PRIVKEY_ME_N_LENGTH_OFFSET 52",
          "73: #define CCA_RSA_INTTOK_PRIVKEY_ME_N_OFFSET 122",
          "75: #define CCA_RSA_INTTOK_PRIVKEY_CRT_N_LENGTH_OFFSET 62",
          "77: #define CCA_RSA_INTTOK_PRIVKEY_CRT_N_OFFSET 134",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83: #define CCA_STATCCAE_ASYM_CMK_OFFSET  56",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: #define CCA_RSA_EXTTOK_PUBKEY_OFFSET  8",
          "91: #define CCA_RSA_EXTTOK_PUBKEY_N_LENGTH_OFFSET 10",
          "94: #define CCA_HMAC_INTTOK_PAYLOAD_LENGTH_OFFSET 38",
          "",
          "---------------"
        ],
        "usr/lib/common/key.c||usr/lib/common/key.c": [
          "File: usr/lib/common/key.c -> usr/lib/common/key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1842:     CK_ULONG val;",
          "1843:     CK_RV rc;",
          "1845:     found = template_attribute_find(tmpl, CKA_MODULUS, &attr);",
          "1846:     if (!found) {",
          "1847:         if (mode == MODE_CREATE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1845:     if (mode == MODE_CREATE &&",
          "1846:         token_specific.secure_key_token == TRUE &&",
          "1847:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "1852:         return publ_key_check_required_attributes(tmpl, mode);",
          "1853:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2052:     CK_ATTRIBUTE *attr = NULL;",
          "2053:     CK_BBOOL found;",
          "2056:     found = template_attribute_find(tmpl, CKA_MODULUS, &attr);",
          "2057:     if (!found) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2065:     if (mode == MODE_CREATE &&",
          "2066:         token_specific.secure_key_token == TRUE &&",
          "2067:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "2072:         return priv_key_check_required_attributes(tmpl, mode);",
          "2073:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3453:     CK_ATTRIBUTE *attr = NULL;",
          "3454:     CK_RV rc;",
          "3456:     rc = template_attribute_get_non_empty(tmpl, CKA_ECDSA_PARAMS, &attr);",
          "3457:     if (rc != CKR_OK) {",
          "3458:         if (mode == MODE_CREATE || mode == MODE_KEYGEN) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3475:     if (mode == MODE_CREATE &&",
          "3476:         token_specific.secure_key_token == TRUE &&",
          "3477:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "3482:         return publ_key_check_required_attributes(tmpl, mode);",
          "3483:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3650:     CK_BBOOL found;",
          "3651:     CK_RV rc;",
          "3653:     rc = template_attribute_get_non_empty(tmpl, CKA_ECDSA_PARAMS, &attr);",
          "3654:     if (rc != CKR_OK) {",
          "3655:         if (mode == MODE_CREATE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3682:     if (mode == MODE_CREATE &&",
          "3683:         token_specific.secure_key_token == TRUE &&",
          "3684:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "3689:         return priv_key_check_required_attributes(tmpl, mode);",
          "3690:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6211:     CK_ATTRIBUTE *attr = NULL;",
          "6212:     CK_BBOOL found;",
          "6214:     found = template_attribute_find(tmpl, CKA_VALUE, &attr);",
          "6215:     if (!found) {",
          "6216:         if (mode == MODE_CREATE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6253:     if (mode == MODE_CREATE &&",
          "6254:         token_specific.secure_key_token == TRUE &&",
          "6255:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "6260:         return secret_key_check_required_attributes(tmpl, mode);",
          "6261:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6605:     CK_ATTRIBUTE *attr = NULL;",
          "6606:     CK_BBOOL found;",
          "6608:     found = template_attribute_find(tmpl, CKA_VALUE, &attr);",
          "6609:     if (!found) {",
          "6610:         if (mode == MODE_CREATE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6657:     if (mode == MODE_CREATE &&",
          "6658:         token_specific.secure_key_token == TRUE &&",
          "6659:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "6664:         return secret_key_check_required_attributes(tmpl, mode);",
          "6665:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7841:     CK_ATTRIBUTE *attr = NULL;",
          "7842:     CK_BBOOL found;",
          "7844:     found = template_attribute_find(tmpl, CKA_VALUE, &attr);",
          "7845:     if (!found) {",
          "7846:         if (mode == MODE_CREATE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7903:     if (mode == MODE_CREATE &&",
          "7904:         token_specific.secure_key_token == TRUE &&",
          "7905:         template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE, &attr) == CKR_OK) {",
          "7910:         return secret_key_check_required_attributes(tmpl, mode);",
          "7911:     }",
          "",
          "---------------"
        ],
        "usr/lib/common/new_host.c||usr/lib/common/new_host.c": [
          "File: usr/lib/common/new_host.c -> usr/lib/common/new_host.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3629:     }",
          "3631:     TRACE_DEBUG(\"Private Template:\\n\");",
          "3633:     for (i = 0; i < ulPrivateKeyAttributeCount; i++, attr++) {",
          "3634:         TRACE_DEBUG_DUMPATTR(attr);",
          "3635:     }",
          "",
          "[Removed Lines]",
          "3632:     attr = pPublicKeyTemplate;",
          "",
          "[Added Lines]",
          "3632:     attr = pPrivateKeyTemplate;",
          "",
          "---------------"
        ],
        "usr/lib/common/template.c||usr/lib/common/template.c": [
          "File: usr/lib/common/template.c -> usr/lib/common/template.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1863:             return CKR_OK;",
          "1864:         break;",
          "1865:     case CKA_MODIFIABLE:",
          "",
          "[Removed Lines]",
          "1862:         if ((mode & (MODE_COPY | MODE_MODIFY)) != 0)",
          "",
          "[Added Lines]",
          "1862:         if ((mode & (MODE_CREATE | MODE_COPY | MODE_MODIFY)) != 0)",
          "",
          "---------------"
        ],
        "usr/lib/ep11_stdll/new_host.c||usr/lib/ep11_stdll/new_host.c": [
          "File: usr/lib/ep11_stdll/new_host.c -> usr/lib/ep11_stdll/new_host.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3846:     }",
          "3848:     TRACE_DEBUG(\"Private Template:\\n\");",
          "3850:     for (i = 0; i < ulPrivateKeyAttributeCount; i++, attr++) {",
          "3851:         TRACE_DEBUG_DUMPATTR(attr);",
          "3852:     }",
          "",
          "[Removed Lines]",
          "3849:     attr = pPublicKeyTemplate;",
          "",
          "[Added Lines]",
          "3849:     attr = pPrivateKeyTemplate;",
          "",
          "---------------"
        ],
        "usr/lib/icsf_stdll/new_host.c||usr/lib/icsf_stdll/new_host.c": [
          "File: usr/lib/icsf_stdll/new_host.c -> usr/lib/icsf_stdll/new_host.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2916:     }",
          "2918:     TRACE_DEBUG(\"Private Template:\\n\");",
          "2920:     for (i = 0; i < ulPrivateKeyAttributeCount; i++, attr++) {",
          "2921:         TRACE_DEBUG_DUMPATTR(attr);",
          "2922:     }",
          "",
          "[Removed Lines]",
          "2919:     attr = pPublicKeyTemplate;",
          "",
          "[Added Lines]",
          "2919:     attr = pPrivateKeyTemplate;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "31392a297258d2cce6b85dd626ee5a5deaf773b0",
      "candidate_info": {
        "commit_hash": "31392a297258d2cce6b85dd626ee5a5deaf773b0",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/31392a297258d2cce6b85dd626ee5a5deaf773b0",
        "files": [
          "usr/lib/ep11_stdll/ep11_specific.c"
        ],
        "message": "EP11: Update EP11 specific attributes from key blob\n\nAfter a key generation, key import, derive, or unwrap operation,\nretrieve some EP11 specific attributes from the key blob, and\nupdate/set these attributes in the Opencryptoki object as well.\n\nThe EP11 specific attributes can be specified by an application\nin the template for object creation, import, derive, or unwrap,\nand they will then be contained in the EP11 key blob as well.\nWith this change, EP11 specific attributes that have not been\nspecified and got a default value by EP11, are now also available\nas PKCS#11 attributes.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/ep11_stdll/ep11_specific.c||usr/lib/ep11_stdll/ep11_specific.c": [
          "File: usr/lib/ep11_stdll/ep11_specific.c -> usr/lib/ep11_stdll/ep11_specific.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "531: static CK_RV get_ep11_target_for_apqn(uint_32 adapter, uint_32 domain,",
          "532:                                       target_t *target, uint64_t flags);",
          "533: static void free_ep11_target_for_apqn(target_t target);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534: static CK_RV update_ep11_attrs_from_blob(STDLL_TokData_t *tokdata,",
          "535:                                          TEMPLATE *tmpl);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3940:         return rc;",
          "3941:     }",
          "3943:     return CKR_OK;",
          "3944: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3945:     rc = update_ep11_attrs_from_blob(tokdata, obj->template);",
          "3946:     if (rc != CKR_OK) {",
          "3947:         TRACE_ERROR(\"%s update_ep11_attrs_from_blob failed with rc=0x%lx\\n\",",
          "3948:                     __func__, rc);",
          "3949:         return rc;",
          "3950:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4028:     }",
          "4029:     attr = NULL;",
          "4031:     if (class == CKO_SECRET_KEY && csum_len >= EP11_CSUMSIZE) {",
          "4033:         rc = build_attribute(CKA_CHECK_VALUE, csum, EP11_CSUMSIZE, &attr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4040:     rc = update_ep11_attrs_from_blob(tokdata, key_obj->template);",
          "4041:     if (rc != CKR_OK) {",
          "4042:         TRACE_ERROR(\"%s update_ep11_attrs_from_blob failed with rc=0x%lx\\n\",",
          "4043:                     __func__, rc);",
          "4044:         goto error;",
          "4045:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5255:     }",
          "5256:     opaque_attr = NULL;",
          "5258:     if (class == CKO_SECRET_KEY && cslen >= EP11_CSUMSIZE) {",
          "5260:         rc = build_attribute(CKA_CHECK_VALUE, csum, EP11_CSUMSIZE, &chk_attr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5274:     rc = update_ep11_attrs_from_blob(tokdata, key_obj->template);",
          "5275:     if (rc != CKR_OK) {",
          "5276:         TRACE_ERROR(\"%s update_ep11_attrs_from_blob failed with rc=0x%lx\\n\",",
          "5277:                     __func__, rc);",
          "5278:         goto error;",
          "5279:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6661:                    (void *)public_key_obj, (void *)private_key_obj);",
          "6662:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6687:     rc = update_ep11_attrs_from_blob(tokdata, private_key_obj->template);",
          "6688:     if (rc != CKR_OK) {",
          "6689:         TRACE_ERROR(\"%s update_ep11_attrs_from_blob failed with rc=0x%lx\\n\",",
          "6690:                     __func__, rc);",
          "6691:         goto error;",
          "6692:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "8495:         if (rc != CKR_OK) {",
          "8496:             TRACE_ERROR(\"ab_unwrap_update_template failed with rc=0x%08lx\\n\", rc);",
          "8498:         }",
          "8499:     }",
          "8501:     switch (*(CK_OBJECT_CLASS *) cla_attr->pValue) {",
          "8502:     case CKO_SECRET_KEY:",
          "",
          "[Removed Lines]",
          "8497:             return rc;",
          "",
          "[Added Lines]",
          "8525:             goto error;",
          "8529:     rc = update_ep11_attrs_from_blob(tokdata, key_obj->template);",
          "8530:     if (rc != CKR_OK) {",
          "8531:         TRACE_ERROR(\"%s update_ep11_attrs_from_blob failed with rc=0x%lx\\n\",",
          "8532:                     __func__, rc);",
          "8533:         goto error;",
          "8534:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "11984:     }",
          "11985: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12027: static CK_RV update_ep11_attrs_from_blob(STDLL_TokData_t *tokdata,",
          "12028:                                          TEMPLATE *tmpl)",
          "12029: {",
          "12030:     ep11_private_data_t *ep11_data = tokdata->private_data;",
          "12032:     CK_BBOOL attrb = CK_FALSE, useasdata = CK_FALSE;",
          "12033:     CK_BBOOL pkeyextr = CK_FALSE, pkeyneverextr = CK_FALSE;",
          "12034:     CK_ULONG stdcomp1 = 0;",
          "12035:     CK_ATTRIBUTE *attr, *blob_attr = NULL;",
          "12036:     ep11_target_info_t* target_info;",
          "12037:     CK_RV rc = CKR_OK;",
          "12038:     CK_ULONG i;",
          "12040:     CK_ATTRIBUTE ibm_attrs[] = {",
          "12041:         { CKA_IBM_RESTRICTABLE, &restr, sizeof(restr) },",
          "12044:         { CKA_IBM_USE_AS_DATA, &useasdata, sizeof(useasdata) },",
          "12045:         { CKA_IBM_ATTRBOUND, &attrb, sizeof(attrb) },",
          "12046:         { CKA_IBM_STD_COMPLIANCE1, &stdcomp1, sizeof(stdcomp1) },",
          "12048:         { CKA_IBM_PROTKEY_EXTRACTABLE, &pkeyextr, sizeof(pkeyextr) },",
          "12049:         { CKA_IBM_PROTKEY_NEVER_EXTRACTABLE, &pkeyneverextr,",
          "12050:           sizeof(pkeyneverextr) },",
          "12051:     };",
          "12052:     CK_ULONG num_ibm_attrs = sizeof(ibm_attrs) / sizeof(CK_ATTRIBUTE);",
          "12054:     if (!ep11_data->pkey_wrap_supported)",
          "12055:         num_ibm_attrs -= 2;",
          "12057:     if (template_attribute_get_non_empty(tmpl, CKA_IBM_OPAQUE,",
          "12058:                                          &blob_attr) != CKR_OK) {",
          "12059:         TRACE_ERROR(\"This key has no CKA_IBM_OPAQUE: should not occur!\\n\");",
          "12060:         return CKR_FUNCTION_FAILED;",
          "12061:     }",
          "12063:     target_info = get_target_info(tokdata);",
          "12064:     if (target_info == NULL)",
          "12065:         return CKR_FUNCTION_FAILED;",
          "12067:     rc = dll_m_GetAttributeValue(blob_attr->pValue,",
          "12068:                                  blob_attr->ulValueLen, ibm_attrs,",
          "12069:                                  num_ibm_attrs, target_info->target);",
          "12071:     put_target_info(tokdata, target_info);",
          "12073:     if (rc != CKR_OK) {",
          "12074:         rc = ep11_error_to_pkcs11_error(rc, NULL);",
          "12075:         TRACE_ERROR(\"%s m_GetAttributeValue failed rc=0x%lx\\n\",",
          "12076:                     __func__, rc);",
          "12077:         return rc;",
          "12078:     }",
          "12081:     for (i = 0; i < num_ibm_attrs; i++) {",
          "12082:         if (ibm_attrs[i].ulValueLen == CK_UNAVAILABLE_INFORMATION) {",
          "12083:             TRACE_DEVEL(\"%s Attribute 0x%lx not available\\n\", __func__,",
          "12084:                         ibm_attrs[i].type);",
          "12085:             continue;",
          "12086:         }",
          "12088:         rc = build_attribute(ibm_attrs[i].type, ibm_attrs[i].pValue,",
          "12089:                              ibm_attrs[i].ulValueLen, &attr);",
          "12090:         if (rc != CKR_OK) {",
          "12091:             TRACE_ERROR(\"%s build_attribute failed with rc=0x%lx\\n\", __func__, rc);",
          "12092:             return rc;",
          "12093:         }",
          "12095:         rc = template_update_attribute(tmpl, attr);",
          "12096:         if (rc != CKR_OK) {",
          "12097:             free(attr);",
          "12098:             TRACE_ERROR(\"%s template_update_attribute failed with rc=0x%lx\\n\",",
          "12099:                         __func__, rc);",
          "12100:             return rc;",
          "12101:         }",
          "12102:     }",
          "12104:     return CKR_OK;",
          "12105: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7fe01fb5b05a2c1e2aa71c3867e09989061a143b",
      "candidate_info": {
        "commit_hash": "7fe01fb5b05a2c1e2aa71c3867e09989061a143b",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/7fe01fb5b05a2c1e2aa71c3867e09989061a143b",
        "files": [
          "usr/lib/common/sign_mgr.c",
          "usr/lib/common/verify_mgr.c"
        ],
        "message": "Do not allow C_SignFinal directly following C_SignInit\n\nPKCS#11 states \"After calling C_SignInit, the application can either\ncall C_Sign to sign in a single part; or call C_SignUpdate one or more\ntimes, followed by C_SignFinal, to sign data in multiple parts.\"\n\nTo sign the empty message use C_Sign or a C_Sign_Update\nwith a zero length message.\n\nThe same is true for C_Verify and friends.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/common/sign_mgr.c||usr/lib/common/sign_mgr.c",
          "usr/lib/common/verify_mgr.c||usr/lib/common/verify_mgr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/common/sign_mgr.c||usr/lib/common/sign_mgr.c": [
          "File: usr/lib/common/sign_mgr.c -> usr/lib/common/sign_mgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1084:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_OPERATION_NOT_INITIALIZED));",
          "1085:         return CKR_OPERATION_NOT_INITIALIZED;",
          "1086:     }",
          "1092:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_OPERATION_ACTIVE));",
          "1093:         return CKR_OPERATION_ACTIVE;",
          "1094:     }",
          "",
          "[Removed Lines]",
          "1087:     if (ctx->multi_init == FALSE) {",
          "1088:         ctx->multi = TRUE;",
          "1089:         ctx->multi_init = TRUE;",
          "1090:     }",
          "1091:     if (ctx->multi == FALSE) {",
          "",
          "[Added Lines]",
          "1087:     if (ctx->multi_init == FALSE || ctx->multi == FALSE) {",
          "",
          "---------------"
        ],
        "usr/lib/common/verify_mgr.c||usr/lib/common/verify_mgr.c": [
          "File: usr/lib/common/verify_mgr.c -> usr/lib/common/verify_mgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1074:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_OPERATION_NOT_INITIALIZED));",
          "1075:         return CKR_OPERATION_NOT_INITIALIZED;",
          "1076:     }",
          "1082:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_OPERATION_ACTIVE));",
          "1083:         return CKR_OPERATION_ACTIVE;",
          "1084:     }",
          "",
          "[Removed Lines]",
          "1077:     if (ctx->multi_init == FALSE) {",
          "1078:         ctx->multi = TRUE;",
          "1079:         ctx->multi_init = TRUE;",
          "1080:     }",
          "1081:     if (ctx->multi == FALSE) {",
          "",
          "[Added Lines]",
          "1077:     if (ctx->multi_init == FALSE || ctx->multi == FALSE) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5cfa568f0d1a8d722a0385819ef7175451c79f3e",
      "candidate_info": {
        "commit_hash": "5cfa568f0d1a8d722a0385819ef7175451c79f3e",
        "repo": "opencryptoki/opencryptoki",
        "commit_url": "https://github.com/opencryptoki/opencryptoki/commit/5cfa568f0d1a8d722a0385819ef7175451c79f3e",
        "files": [
          "usr/lib/common/mech_dh.c"
        ],
        "message": "Fix dh_pkcs_derive mechanism parameter checking\n\nPKCS #11 does not impose any parameter length restrictions for\nmechanism CKM_DH_PKCS_DERIVE (peer public data). Thus, do not\ncheck the parameter length, other than that it should be > 0.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
        "before_after_code_files": [
          "usr/lib/common/mech_dh.c||usr/lib/common/mech_dh.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "usr/lib/common/mech_dh.c||usr/lib/common/mech_dh.c": [
          "File: usr/lib/common/mech_dh.c -> usr/lib/common/mech_dh.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:         TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_PARAM_INVALID));",
          "71:         return (CKR_MECHANISM_PARAM_INVALID);",
          "72:     }",
          "",
          "[Removed Lines]",
          "65:     if ((!mech->pParameter) ||",
          "66:         ((mech->ulParameterLen != 64) &&",
          "67:          (mech->ulParameterLen != 96) &&",
          "68:          (mech->ulParameterLen != 128) &&",
          "69:          (mech->ulParameterLen != 192) && (mech->ulParameterLen != 256))) {",
          "",
          "[Added Lines]",
          "65:     if (mech->pParameter == NULL || mech->ulParameterLen == 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-9717",
  "cve_desc": "fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",
  "repo": "torvalds/linux",
  "patch_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
  "patch_info": {
    "commit_hash": "ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
    "files": [
      "fs/namespace.c",
      "fs/pnode.h"
    ],
    "message": "mnt: Honor MNT_LOCKED when detaching mounts\n\nModify umount(MNT_DETACH) to keep mounts in the hash table that are\nlocked to their parent mounts, when the parent is lazily unmounted.\n\nIn mntput_no_expire detach the children from the hash table, depending\non mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.\n\nIn __detach_mounts if there are any mounts that have been unmounted\nbut still are on the list of mounts of a mountpoint, remove their\nchildren from the mount hash table and those children to the unmounted\nlist so they won't linger potentially indefinitely waiting for their\nfinal mntput, now that the mounts serve no purpose.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/namespace.c||fs/namespace.c",
      "fs/pnode.h||fs/pnode.h"
    ]
  },
  "patch_diff": {
    "fs/namespace.c||fs/namespace.c": [
      "File: fs/namespace.c -> fs/namespace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1099:  rcu_read_unlock();",
      "1101:  list_del(&mnt->mnt_instance);",
      "1102:  unlock_mount_hash();",
      "1104:  if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1103:  if (unlikely(!list_empty(&mnt->mnt_mounts))) {",
      "1104:   struct mount *p, *tmp;",
      "1105:   list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
      "1106:    umount_mnt(p);",
      "1107:   }",
      "1108:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1370:   propagate_umount(&tmp_list);",
      "1372:  while (!list_empty(&tmp_list)) {",
      "1373:   p = list_first_entry(&tmp_list, struct mount, mnt_list);",
      "1374:   list_del_init(&p->mnt_expire);",
      "1375:   list_del_init(&p->mnt_list);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1380:   bool disconnect;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1378:   if (how & UMOUNT_SYNC)",
      "1379:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
      "1382:   if (mnt_has_parent(p)) {",
      "1383:    mnt_add_count(p->mnt_parent, -1);",
      "1385:   }",
      "1386:   change_mnt_propagation(p, MS_PRIVATE);",
      "1387:  }",
      "",
      "[Removed Lines]",
      "1381:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
      "1384:    umount_mnt(p);",
      "",
      "[Added Lines]",
      "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
      "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
      "1392:      disconnect ? &unmounted : NULL);",
      "1395:    if (!disconnect) {",
      "1397:     list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);",
      "1398:    } else {",
      "1399:     umount_mnt(p);",
      "1400:    }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1506:  lock_mount_hash();",
      "1507:  while (!hlist_empty(&mp->m_list)) {",
      "1508:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
      "1510:  }",
      "1511:  unlock_mount_hash();",
      "1512:  put_mountpoint(mp);",
      "",
      "[Removed Lines]",
      "1509:   umount_tree(mnt, 0);",
      "",
      "[Added Lines]",
      "1525:   if (mnt->mnt.mnt_flags & MNT_UMOUNT) {",
      "1526:    struct mount *p, *tmp;",
      "1527:    list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
      "1528:     hlist_add_head(&p->mnt_umount.s_list, &unmounted);",
      "1529:     umount_mnt(p);",
      "1530:    }",
      "1531:   }",
      "1532:   else umount_tree(mnt, 0);",
      "",
      "---------------"
    ],
    "fs/pnode.h||fs/pnode.h": [
      "File: fs/pnode.h -> fs/pnode.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)",
      "21: #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)",
      "22: #define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)",
      "24: #define CL_EXPIRE      0x01",
      "25: #define CL_SLAVE       0x02",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "23: #define IS_MNT_LOCKED_AND_LAZY(m) \\",
      "24:  (((m)->mnt.mnt_flags & (MNT_LOCKED|MNT_SYNC_UMOUNT)) == MNT_LOCKED)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
      "candidate_info": {
        "commit_hash": "e0c9c0afd2fc958ffa34b697972721d81df8a56f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f",
        "files": [
          "fs/namespace.c"
        ],
        "message": "mnt: Update detach_mounts to leave mounts connected\n\nNow that it is possible to lazily unmount an entire mount tree and\nleave the individual mounts connected to each other add a new flag\nUMOUNT_CONNECTED to umount_tree to force this behavior and use\nthis flag in detach_mounts.\n\nThis closes a bug where the deletion of a file or directory could\ntrigger an unmount and reveal data under a mount point.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1348: enum umount_tree_flags {",
          "1349:  UMOUNT_SYNC = 1,",
          "1350:  UMOUNT_PROPAGATE = 2,",
          "1351: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1351:  UMOUNT_CONNECTED = 4,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1386:   if (how & UMOUNT_SYNC)",
          "1387:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1391:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
          "1392:      disconnect ? &unmounted : NULL);",
          "",
          "[Removed Lines]",
          "1389:   disconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
          "",
          "[Added Lines]",
          "1390:   disconnect = !(((how & UMOUNT_CONNECTED) &&",
          "1391:     mnt_has_parent(p) &&",
          "1392:     (p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||",
          "1393:           IS_MNT_LOCKED_AND_LAZY(p));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1529:     umount_mnt(p);",
          "1530:    }",
          "1531:   }",
          "1533:  }",
          "1534:  unlock_mount_hash();",
          "1535:  put_mountpoint(mp);",
          "",
          "[Removed Lines]",
          "1532:   else umount_tree(mnt, 0);",
          "",
          "[Added Lines]",
          "1536:   else umount_tree(mnt, UMOUNT_CONNECTED);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c003b26ff98ca04a180ff34c38c007a3998d62f9",
      "candidate_info": {
        "commit_hash": "c003b26ff98ca04a180ff34c38c007a3998d62f9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c003b26ff98ca04a180ff34c38c007a3998d62f9",
        "files": [
          "fs/namespace.c",
          "fs/pnode.c",
          "fs/pnode.h"
        ],
        "message": "mnt: In umount_tree reuse mnt_list instead of mnt_hash\n\numount_tree builds a list of mounts that need to be unmounted.\nUtilize mnt_list for this purpose instead of mnt_hash.  This begins to\nallow keeping a mount on the mnt_hash after it is unmounted, which is\nnecessary for a properly functioning MNT_LOCKED implementation.\n\nThe fact that mnt_list is an ordinary list makding available list_move\nis nice bonus.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c",
          "fs/pnode.c||fs/pnode.c",
          "fs/pnode.h||fs/pnode.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c",
            "fs/pnode.h||fs/pnode.h"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c",
            "fs/pnode.h||fs/pnode.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1328: static void umount_tree(struct mount *mnt, enum umount_tree_flags how)",
          "1329: {",
          "1331:  struct mount *p;",
          "1339:   list_del_init(&p->mnt_child);",
          "1341:  if (how & UMOUNT_PROPAGATE)",
          "1342:   propagate_umount(&tmp_list);",
          "1347:   list_del_init(&p->mnt_expire);",
          "1348:   list_del_init(&p->mnt_list);",
          "1349:   __touch_mnt_namespace(p->mnt_ns);",
          "",
          "[Removed Lines]",
          "1330:  HLIST_HEAD(tmp_list);",
          "1333:  for (p = mnt; p; p = next_mnt(p, mnt)) {",
          "1334:   hlist_del_init_rcu(&p->mnt_hash);",
          "1335:   hlist_add_head(&p->mnt_hash, &tmp_list);",
          "1336:  }",
          "1338:  hlist_for_each_entry(p, &tmp_list, mnt_hash)",
          "1344:  while (!hlist_empty(&tmp_list)) {",
          "1345:   p = hlist_entry(tmp_list.first, struct mount, mnt_hash);",
          "1346:   hlist_del_init_rcu(&p->mnt_hash);",
          "",
          "[Added Lines]",
          "1330:  LIST_HEAD(tmp_list);",
          "1334:  for (p = mnt; p; p = next_mnt(p, mnt))",
          "1335:   list_move(&p->mnt_list, &tmp_list);",
          "1338:  list_for_each_entry(p, &tmp_list, mnt_list) {",
          "1339:   hlist_del_init_rcu(&p->mnt_hash);",
          "1341:  }",
          "1347:  while (!list_empty(&tmp_list)) {",
          "1348:   p = list_first_entry(&tmp_list, struct mount, mnt_list);",
          "",
          "---------------"
        ],
        "fs/pnode.c||fs/pnode.c": [
          "File: fs/pnode.c -> fs/pnode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "384:   if (child && list_empty(&child->mnt_mounts)) {",
          "385:    list_del_init(&child->mnt_child);",
          "386:    hlist_del_init_rcu(&child->mnt_hash);",
          "388:   }",
          "389:  }",
          "390: }",
          "",
          "[Removed Lines]",
          "387:    hlist_add_before_rcu(&child->mnt_hash, &mnt->mnt_hash);",
          "",
          "[Added Lines]",
          "387:    list_move_tail(&child->mnt_list, &mnt->mnt_list);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "400: {",
          "401:  struct mount *mnt;",
          "404:   __propagate_umount(mnt);",
          "405:  return 0;",
          "406: }",
          "",
          "[Removed Lines]",
          "399: int propagate_umount(struct hlist_head *list)",
          "403:  hlist_for_each_entry(mnt, list, mnt_hash)",
          "",
          "[Added Lines]",
          "399: int propagate_umount(struct list_head *list)",
          "403:  list_for_each_entry(mnt, list, mnt_list)",
          "",
          "---------------"
        ],
        "fs/pnode.h||fs/pnode.h": [
          "File: fs/pnode.h -> fs/pnode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void change_mnt_propagation(struct mount *, int);",
          "41: int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,",
          "42:   struct hlist_head *);",
          "44: int propagate_mount_busy(struct mount *, int);",
          "45: void mnt_release_group_id(struct mount *);",
          "46: int get_dominating_id(struct mount *mnt, const struct path *root);",
          "",
          "[Removed Lines]",
          "43: int propagate_umount(struct hlist_head *);",
          "",
          "[Added Lines]",
          "43: int propagate_umount(struct list_head *);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "87b95ce0964c016ede92763be9c164e49f1019e9",
      "candidate_info": {
        "commit_hash": "87b95ce0964c016ede92763be9c164e49f1019e9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/87b95ce0964c016ede92763be9c164e49f1019e9",
        "files": [
          "fs/fs_pin.c",
          "fs/mount.h",
          "fs/namespace.c"
        ],
        "message": "switch the IO-triggering parts of umount to fs_pin\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/fs_pin.c||fs/fs_pin.c",
          "fs/mount.h||fs/mount.h",
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/fs_pin.c||fs/fs_pin.c": [
          "File: fs/fs_pin.c -> fs/fs_pin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include <linux/fs.h>",
          "2: #include <linux/sched.h>",
          "3: #include <linux/slab.h>",
          "5: #include \"internal.h\"",
          "6: #include \"mount.h\"",
          "",
          "[Removed Lines]",
          "4: #include <linux/fs_pin.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/mount.h||fs/mount.h": [
          "File: fs/mount.h -> fs/mount.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include <linux/seq_file.h>",
          "3: #include <linux/poll.h>",
          "4: #include <linux/ns_common.h>",
          "6: struct mnt_namespace {",
          "7:  atomic_t  count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include <linux/fs_pin.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:  struct hlist_head mnt_pins;",
          "66: };",
          "",
          "[Removed Lines]",
          "65:  struct path mnt_ex_mountpoint;",
          "",
          "[Added Lines]",
          "66:  struct fs_pin mnt_umount;",
          "67:  struct dentry *mnt_ex_mountpoint;",
          "",
          "---------------"
        ],
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: #endif",
          "191: }",
          "193: static struct mount *alloc_vfsmnt(const char *name)",
          "194: {",
          "195:  struct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193: static void drop_mountpoint(struct fs_pin *p)",
          "194: {",
          "195:  struct mount *m = container_of(p, struct mount, mnt_umount);",
          "196:  dput(m->mnt_ex_mountpoint);",
          "197:  pin_remove(p);",
          "198:  mntput(&m->mnt);",
          "199: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "229: #ifdef CONFIG_FSNOTIFY",
          "230:   INIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);",
          "231: #endif",
          "232:  }",
          "233:  return mnt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:   init_fs_pin(&mnt->mnt_umount, drop_mountpoint);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1290: static void namespace_unlock(void)",
          "1291: {",
          "1293:  struct hlist_head head = unmounted;",
          "1295:  if (likely(hlist_empty(&head))) {",
          "",
          "[Removed Lines]",
          "1292:  struct mount *mnt;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1300:  head.first->pprev = &head.first;",
          "1301:  INIT_HLIST_HEAD(&unmounted);",
          "1308:  up_write(&namespace_sem);",
          "1310:  synchronize_rcu();",
          "1319: }",
          "1321: static inline void namespace_lock(void)",
          "",
          "[Removed Lines]",
          "1304:  hlist_for_each_entry(mnt, &head, mnt_hash)",
          "1305:   if (mnt->mnt_ex_mountpoint.mnt)",
          "1306:    mntget(mnt->mnt_ex_mountpoint.mnt);",
          "1312:  while (!hlist_empty(&head)) {",
          "1313:   mnt = hlist_entry(head.first, struct mount, mnt_hash);",
          "1314:   hlist_del_init(&mnt->mnt_hash);",
          "1315:   if (mnt->mnt_ex_mountpoint.mnt)",
          "1316:    path_put(&mnt->mnt_ex_mountpoint);",
          "1317:   mntput(&mnt->mnt);",
          "1318:  }",
          "",
          "[Added Lines]",
          "1314:  group_pin_kill(&head);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1334: {",
          "1335:  HLIST_HEAD(tmp_list);",
          "1336:  struct mount *p;",
          "1339:  for (p = mnt; p; p = next_mnt(p, mnt)) {",
          "1340:   hlist_del_init_rcu(&p->mnt_hash);",
          "",
          "[Removed Lines]",
          "1337:  struct mount *last = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1347:  if (how)",
          "1348:   propagate_umount(&tmp_list);",
          "1351:   list_del_init(&p->mnt_expire);",
          "1352:   list_del_init(&p->mnt_list);",
          "1353:   __touch_mnt_namespace(p->mnt_ns);",
          "1354:   p->mnt_ns = NULL;",
          "1355:   if (how < 2)",
          "1356:    p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;",
          "1357:   if (mnt_has_parent(p)) {",
          "1358:    hlist_del_init(&p->mnt_mp_list);",
          "1359:    put_mountpoint(p->mnt_mp);",
          "1360:    mnt_add_count(p->mnt_parent, -1);",
          "1364:    p->mnt_mountpoint = p->mnt.mnt_root;",
          "1365:    p->mnt_parent = p;",
          "1366:    p->mnt_mp = NULL;",
          "1367:   }",
          "1368:   change_mnt_propagation(p, MS_PRIVATE);",
          "1377:  }",
          "1378: }",
          "",
          "[Removed Lines]",
          "1350:  hlist_for_each_entry(p, &tmp_list, mnt_hash) {",
          "1362:    p->mnt_ex_mountpoint.dentry = p->mnt_mountpoint;",
          "1363:    p->mnt_ex_mountpoint.mnt = &p->mnt_parent->mnt;",
          "1369:   last = p;",
          "1370:  }",
          "1371:  if (last) {",
          "1372:   last->mnt_hash.next = unmounted.first;",
          "1373:   if (unmounted.first)",
          "1374:    unmounted.first->pprev = &last->mnt_hash.next;",
          "1375:   unmounted.first = tmp_list.first;",
          "1376:   unmounted.first->pprev = &unmounted.first;",
          "",
          "[Added Lines]",
          "1345:  while (!hlist_empty(&tmp_list)) {",
          "1346:   p = hlist_entry(tmp_list.first, struct mount, mnt_hash);",
          "1347:   hlist_del_init_rcu(&p->mnt_hash);",
          "1355:   pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
          "1361:    p->mnt_ex_mountpoint = p->mnt_mountpoint;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
      "candidate_info": {
        "commit_hash": "80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/80b5dce8c59b0de1ed6e403b8298e02dcb4db64b",
        "files": [
          "fs/mount.h",
          "fs/namespace.c"
        ],
        "message": "vfs: Add a function to lazily unmount all mounts from any dentry.\n\nThe new function detach_mounts comes in two pieces.  The first piece\nis a static inline test of d_mounpoint that returns immediately\nwithout taking any locks if d_mounpoint is not set.  In the common\ncase when mountpoints are absent this allows the vfs to continue\nrunning with it's same cacheline foot print.\n\nThe second piece of detach_mounts __detach_mounts actually does the\nwork and it assumes that a mountpoint is present so it is slow and\ntakes namespace_sem for write, and then locks the mount hash (aka\nmount_lock) after a struct mountpoint has been found.\n\nWith those two locks held each entry on the list of mounts on a\nmountpoint is selected and lazily unmounted until all of the mount\nhave been lazily unmounted.\n\nv7: Wrote a proper change description and removed the changelog\n    documenting deleted wrong turns.\n\nSigned-off-by: Eric W. Biederman <ebiederman@twitter.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/mount.h||fs/mount.h",
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/mount.h||fs/mount.h": [
          "File: fs/mount.h -> fs/mount.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "88: extern bool legitimize_mnt(struct vfsmount *, unsigned);",
          "90: static inline void get_mnt_ns(struct mnt_namespace *ns)",
          "91: {",
          "92:  atomic_inc(&ns->count);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: extern void __detach_mounts(struct dentry *dentry);",
          "92: static inline void detach_mounts(struct dentry *dentry)",
          "93: {",
          "94:  if (!d_mountpoint(dentry))",
          "95:   return;",
          "96:  __detach_mounts(dentry);",
          "97: }",
          "",
          "---------------"
        ],
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1468:  return retval;",
          "1469: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1481: void __detach_mounts(struct dentry *dentry)",
          "1482: {",
          "1483:  struct mountpoint *mp;",
          "1484:  struct mount *mnt;",
          "1486:  namespace_lock();",
          "1487:  mp = lookup_mountpoint(dentry);",
          "1488:  if (!mp)",
          "1489:   goto out_unlock;",
          "1491:  lock_mount_hash();",
          "1492:  while (!hlist_empty(&mp->m_list)) {",
          "1493:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1494:   umount_tree(mnt, 2);",
          "1495:  }",
          "1496:  unlock_mount_hash();",
          "1497:  put_mountpoint(mp);",
          "1498: out_unlock:",
          "1499:  namespace_unlock();",
          "1500: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe78fcc85a2046c51f1535710996860557eeec20",
      "candidate_info": {
        "commit_hash": "fe78fcc85a2046c51f1535710996860557eeec20",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fe78fcc85a2046c51f1535710996860557eeec20",
        "files": [
          "fs/namespace.c"
        ],
        "message": "mnt: In detach_mounts detach the appropriate unmounted mount\n\nThe handling of in detach_mounts of unmounted but connected mounts is\nbuggy and can lead to an infinite loop.\n\nCorrect the handling of unmounted mounts in detach_mount.  When the\nmountpoint of an unmounted but connected mount is connected to a\ndentry, and that dentry is deleted we need to disconnect that mount\nfrom the parent mount and the deleted dentry.\n\nNothing changes for the unmounted and connected children.  They can be\nsafely ignored.\n\nCc: stable@vger.kernel.org\nFixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "fs/namespace.c||fs/namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/namespace.c||fs/namespace.c"
          ],
          "candidate": [
            "fs/namespace.c||fs/namespace.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1565:  while (!hlist_empty(&mp->m_list)) {",
          "1566:   mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);",
          "1567:   if (mnt->mnt.mnt_flags & MNT_UMOUNT) {",
          "1573:   }",
          "1574:   else umount_tree(mnt, UMOUNT_CONNECTED);",
          "1575:  }",
          "",
          "[Removed Lines]",
          "1568:    struct mount *p, *tmp;",
          "1569:    list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
          "1570:     hlist_add_head(&p->mnt_umount.s_list, &unmounted);",
          "1571:     umount_mnt(p);",
          "1572:    }",
          "",
          "[Added Lines]",
          "1568:    hlist_add_head(&mnt->mnt_umount.s_list, &unmounted);",
          "1569:    umount_mnt(mnt);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
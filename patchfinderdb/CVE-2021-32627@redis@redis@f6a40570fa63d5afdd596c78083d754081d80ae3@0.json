{
  "cve_id": "CVE-2021-32627",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. In affected versions an integer overflow bug in Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves changing the default proto-max-bulk-len and client-query-buffer-limit configuration parameters to very large values and constructing specially crafted very large stream elements. The problem is fixed in Redis 6.2.6, 6.0.16 and 5.0.14. For users unable to upgrade an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
  "repo": "redis/redis",
  "patch_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
  "patch_info": {
    "commit_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3",
    "files": [
      "src/geo.c",
      "src/listpack.c",
      "src/quicklist.c",
      "src/rdb.c",
      "src/server.h",
      "src/t_hash.c",
      "src/t_list.c",
      "src/t_stream.c",
      "src/t_zset.c",
      "src/ziplist.c",
      "src/ziplist.h",
      "tests/support/util.tcl",
      "tests/unit/violations.tcl"
    ],
    "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.",
    "before_after_code_files": [
      "src/geo.c||src/geo.c",
      "src/listpack.c||src/listpack.c",
      "src/quicklist.c||src/quicklist.c",
      "src/rdb.c||src/rdb.c",
      "src/server.h||src/server.h",
      "src/t_hash.c||src/t_hash.c",
      "src/t_list.c||src/t_list.c",
      "src/t_stream.c||src/t_stream.c",
      "src/t_zset.c||src/t_zset.c",
      "src/ziplist.c||src/ziplist.c",
      "src/ziplist.h||src/ziplist.h",
      "tests/support/util.tcl||tests/support/util.tcl",
      "tests/unit/violations.tcl||tests/unit/violations.tcl"
    ]
  },
  "patch_diff": {
    "src/geo.c||src/geo.c": [
      "File: src/geo.c -> src/geo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "635:         robj *zobj;",
      "636:         zset *zs;",
      "637:         int i;",
      "640:         if (returned_items) {",
      "641:             zobj = createZsetObject();",
      "",
      "[Removed Lines]",
      "638:         size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "638:         size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "650:             size_t elelen = sdslen(gp->member);",
      "652:             if (maxelelen < elelen) maxelelen = elelen;",
      "653:             znode = zslInsert(zs->zsl,score,gp->member);",
      "654:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
      "655:             gp->member = NULL;",
      "656:         }",
      "658:         if (returned_items) {",
      "660:             setKey(c,c->db,storekey,zobj);",
      "661:             decrRefCount(zobj);",
      "662:             notifyKeyspaceEvent(NOTIFY_ZSET,\"georadiusstore\",storekey,",
      "",
      "[Removed Lines]",
      "659:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
      "",
      "[Added Lines]",
      "653:             totelelen += elelen;",
      "660:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
      "",
      "---------------"
    ],
    "src/listpack.c||src/listpack.c": [
      "File: src/listpack.c -> src/listpack.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "283:     } else {",
      "284:         if (size < 64) *enclen = 1+size;",
      "285:         else if (size < 4096) *enclen = 2+size;",
      "287:         return LP_ENCODING_STRING;",
      "288:     }",
      "289: }",
      "",
      "[Removed Lines]",
      "286:         else *enclen = 5+size;",
      "",
      "[Added Lines]",
      "286:         else *enclen = 5+(uint64_t)size;",
      "",
      "---------------"
    ],
    "src/quicklist.c||src/quicklist.c": [
      "File: src/quicklist.c -> src/quicklist.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: #include \"quicklist.h\"",
      "33: #include \"zmalloc.h\"",
      "34: #include \"ziplist.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #include \"redisassert.h\"",
      "",
      "---------------"
    ],
    "src/rdb.c||src/rdb.c": [
      "File: src/rdb.c -> src/rdb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1561:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
      "1563:         uint64_t zsetlen;",
      "1565:         zset *zs;",
      "1567:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
      "",
      "[Removed Lines]",
      "1564:         size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "1564:         size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1600:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
      "1602:             znode = zslInsert(zs->zsl,score,sdsele);",
      "1603:             dictAdd(zs->dict,sdsele,&znode->score);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1601:             totelelen += sdslen(sdsele);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1607:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
      "1610:     } else if (rdbtype == RDB_TYPE_HASH) {",
      "1611:         uint64_t len;",
      "1612:         int ret;",
      "",
      "[Removed Lines]",
      "1608:             maxelelen <= server.zset_max_ziplist_value)",
      "1609:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
      "",
      "[Added Lines]",
      "1609:             maxelelen <= server.zset_max_ziplist_value &&",
      "1610:             ziplistSafeToAdd(NULL, totelelen))",
      "1611:         {",
      "1612:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
      "1613:         }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1635:                 return NULL;",
      "1636:             }",
      "1645:             if (sdslen(field) > server.hash_max_ziplist_value ||",
      "1647:             {",
      "1650:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
      "1651:                 break;",
      "1652:             }",
      "1653:             sdsfree(field);",
      "1654:             sdsfree(value);",
      "1655:         }",
      "",
      "[Removed Lines]",
      "1639:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
      "1640:                     sdslen(field), ZIPLIST_TAIL);",
      "1641:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
      "1642:                     sdslen(value), ZIPLIST_TAIL);",
      "1646:                 sdslen(value) > server.hash_max_ziplist_value)",
      "1648:                 sdsfree(field);",
      "1649:                 sdsfree(value);",
      "",
      "[Added Lines]",
      "1644:                 sdslen(value) > server.hash_max_ziplist_value ||",
      "1645:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
      "1648:                 ret = dictAdd((dict*)o->ptr, field, value);",
      "1649:                 if (ret == DICT_ERR) {",
      "1650:                     rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
      "1651:                 }",
      "1656:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
      "1657:                     sdslen(field), ZIPLIST_TAIL);",
      "1658:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
      "1659:                     sdslen(value), ZIPLIST_TAIL);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1726:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
      "1727:                         if (flen > maxlen) maxlen = flen;",
      "1728:                         if (vlen > maxlen) maxlen = vlen;",
      "1729:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
      "1730:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
      "1731:                     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1737:                         if (!ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
      "1738:                             rdbExitReportCorruptRDB(\"Hash zipmap too big (%u)\", flen);",
      "1739:                         }",
      "",
      "---------------"
    ],
    "src/server.h||src/server.h": [
      "File: src/server.h -> src/server.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1999: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
      "2000: unsigned long zsetLength(const robj *zobj);",
      "2001: void zsetConvert(robj *zobj, int encoding);",
      "2003: int zsetScore(robj *zobj, sds member, double *score);",
      "2004: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
      "2005: int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);",
      "",
      "[Removed Lines]",
      "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
      "",
      "[Added Lines]",
      "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
      "",
      "---------------"
    ],
    "src/t_hash.c||src/t_hash.c": [
      "File: src/t_hash.c -> src/t_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
      "41:     int i;",
      "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
      "45:     for (i = start; i <= end; i++) {",
      "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
      "51:         }",
      "52:     }",
      "53: }",
      "",
      "[Removed Lines]",
      "46:         if (sdsEncodedObject(argv[i]) &&",
      "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
      "48:         {",
      "50:             break;",
      "",
      "[Added Lines]",
      "42:     size_t sum = 0;",
      "47:         if (!sdsEncodedObject(argv[i]))",
      "48:             continue;",
      "49:         size_t len = sdslen(argv[i]->ptr);",
      "50:         if (len > server.hash_max_ziplist_value) {",
      "52:             return;",
      "54:         sum += len;",
      "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
      "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
      "",
      "---------------"
    ],
    "src/t_list.c||src/t_list.c": [
      "File: src/t_list.c -> src/t_list.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #include \"server.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "197: void pushGenericCommand(client *c, int where) {",
      "198:     int j, pushed = 0;",
      "199:     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);",
      "201:     if (lobj && lobj->type != OBJ_LIST) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "202:     for (j = 2; j < c->argc; j++) {",
      "203:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
      "204:             addReplyError(c, \"Element too large\");",
      "205:             return;",
      "206:         }",
      "207:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "277:         return;",
      "278:     }",
      "280:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
      "281:         checkType(c,subject,OBJ_LIST)) return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "290:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
      "291:         addReplyError(c, \"Element too large\");",
      "292:         return;",
      "293:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "344:     long index;",
      "345:     robj *value = c->argv[3];",
      "347:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
      "348:         return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "362:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
      "363:         addReplyError(c, \"Element too large\");",
      "364:         return;",
      "365:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "510:     int direction = LIST_TAIL;",
      "514:     for (int j = 3; j < c->argc; j++) {",
      "515:         char *opt = c->argv[j]->ptr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "533:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
      "534:         addReplyError(c, \"Element too large\");",
      "535:         return;",
      "536:     }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "610:     long toremove;",
      "611:     long removed = 0;",
      "613:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
      "614:         return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "638:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
      "639:         addReplyError(c, \"Element too large\");",
      "640:         return;",
      "641:     }",
      "",
      "---------------"
    ],
    "src/t_stream.c||src/t_stream.c": [
      "File: src/t_stream.c -> src/t_stream.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: void streamFreeCG(streamCG *cg);",
      "44: void streamFreeNACK(streamNACK *na);",
      "45: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "212:     raxIterator ri;",
      "",
      "[Removed Lines]",
      "209:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
      "",
      "[Added Lines]",
      "218:     if (streamCompareID(&id,&s->last_id) <= 0) {",
      "219:         errno = EDOM;",
      "220:         return C_ERR;",
      "221:     }",
      "226:     size_t totelelen = 0;",
      "227:     for (int64_t i = 0; i < numfields*2; i++) {",
      "228:         sds ele = argv[i]->ptr;",
      "229:         totelelen += sdslen(ele);",
      "230:     }",
      "231:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
      "232:         errno = ERANGE;",
      "233:         return C_ERR;",
      "234:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "267:     if (lp != NULL) {",
      "271:             lp = NULL;",
      "272:         } else if (server.stream_node_max_entries) {",
      "273:             int64_t count = lpGetInteger(lpFirst(lp));",
      "",
      "[Removed Lines]",
      "268:         if (server.stream_node_max_bytes &&",
      "269:             lp_bytes >= server.stream_node_max_bytes)",
      "270:         {",
      "",
      "[Added Lines]",
      "293:         size_t node_max_bytes = server.stream_node_max_bytes;",
      "294:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
      "295:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
      "296:         if (lp_bytes + totelelen >= node_max_bytes) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1269:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
      "1272:     {",
      "1275:         return;",
      "1276:     }",
      "1277:     addReplyStreamID(c,&id);",
      "",
      "[Removed Lines]",
      "1270:         &id, id_given ? &id : NULL)",
      "1271:         == C_ERR)",
      "1273:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
      "1274:                         \"target stream top item\");",
      "",
      "[Added Lines]",
      "1296:         &id, id_given ? &id : NULL) == C_ERR)",
      "1298:         if (errno == EDOM)",
      "1299:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
      "1300:                             \"the target stream top item\");",
      "1301:         else",
      "1302:             addReplyError(c,\"Elements are too large to be stored\");",
      "",
      "---------------"
    ],
    "src/t_zset.c||src/t_zset.c": [
      "File: src/t_zset.c -> src/t_zset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1238: }",
      "1244:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
      "1245:     zset *zset = zobj->ptr;",
      "1247:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
      "1250: }",
      "",
      "[Removed Lines]",
      "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
      "1248:         maxelelen <= server.zset_max_ziplist_value)",
      "1249:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
      "",
      "[Added Lines]",
      "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
      "1248:         maxelelen <= server.zset_max_ziplist_value &&",
      "1249:         ziplistSafeToAdd(NULL, totelelen))",
      "1250:     {",
      "1251:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
      "1252:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1355:             }",
      "1356:             return 1;",
      "1357:         } else if (!xx) {",
      "1363:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
      "1367:         } else {",
      "1369:             return 1;",
      "1370:         }",
      "1372:         zset *zs = zobj->ptr;",
      "1373:         zskiplistNode *znode;",
      "1374:         dictEntry *de;",
      "",
      "[Removed Lines]",
      "1360:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
      "1361:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
      "1362:                 sdslen(ele) > server.zset_max_ziplist_value)",
      "1364:             if (newscore) *newscore = score;",
      "1366:             return 1;",
      "1371:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
      "",
      "[Added Lines]",
      "1363:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
      "1364:                 sdslen(ele) > server.zset_max_ziplist_value ||",
      "1365:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
      "1366:             {",
      "1368:             } else {",
      "1369:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
      "1370:                 if (newscore) *newscore = score;",
      "1372:                 return 1;",
      "1373:             }",
      "1378:     }",
      "1382:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2180:     zsetopsrc *src;",
      "2181:     zsetopval zval;",
      "2182:     sds tmp;",
      "2184:     robj *dstobj;",
      "2185:     zset *dstzset;",
      "2186:     zskiplistNode *znode;",
      "",
      "[Removed Lines]",
      "2183:     size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "2194:     size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2304:                     tmp = zuiNewSdsFromValue(&zval);",
      "2305:                     znode = zslInsert(dstzset->zsl,score,tmp);",
      "2306:                     dictAdd(dstzset->dict,tmp,&znode->score);",
      "2307:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
      "2308:                 }",
      "2309:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2318:                     totelelen += sdslen(tmp);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2343:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
      "2345:                     dictSetKey(accumulator, de, tmp);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2355:                      totelelen += sdslen(tmp);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2380:     if (dbDelete(c->db,dstkey))",
      "2381:         touched = 1;",
      "2382:     if (dstzset->zsl->length) {",
      "2384:         dbAdd(c->db,dstkey,dstobj);",
      "2385:         addReplyLongLong(c,zsetLength(dstobj));",
      "2386:         signalModifiedKey(c,c->db,dstkey);",
      "",
      "[Removed Lines]",
      "2383:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);",
      "",
      "[Added Lines]",
      "2396:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen,totelelen);",
      "",
      "---------------"
    ],
    "src/ziplist.c||src/ziplist.c": [
      "File: src/ziplist.c -> src/ziplist.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "265:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
      "266: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "270: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
      "271: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
      "272:     size_t len = zl? ziplistBlobLen(zl): 0;",
      "273:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
      "274:         return 0;",
      "275:     return 1;",
      "276: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "586: }",
      "590:     zl = zrealloc(zl,len);",
      "591:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
      "592:     zl[len-1] = ZIP_END;",
      "",
      "[Removed Lines]",
      "589: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
      "",
      "[Added Lines]",
      "600: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
      "601:     assert(len < UINT32_MAX);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "899:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
      "902:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
      "903:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "914:     assert(zlbytes < UINT32_MAX);",
      "",
      "---------------"
    ],
    "src/ziplist.h||src/ziplist.h": [
      "File: src/ziplist.h -> src/ziplist.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "49: unsigned int ziplistLen(unsigned char *zl);",
      "50: size_t ziplistBlobLen(unsigned char *zl);",
      "51: void ziplistRepr(unsigned char *zl);",
      "53: #ifdef REDIS_TEST",
      "54: int ziplistTest(int argc, char *argv[]);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "52: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
      "",
      "---------------"
    ],
    "tests/support/util.tcl||tests/support/util.tcl": [
      "File: tests/support/util.tcl -> tests/support/util.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "110: # count current log lines in server's stdout",
      "111: proc count_log_lines {srv_idx} {",
      "113: }",
      "115: # verify pattern exists in server's sdtout after a certain line number",
      "",
      "[Removed Lines]",
      "112:     set _ [exec wc -l < [srv $srv_idx stdout]]",
      "",
      "[Added Lines]",
      "112:     set _ [string trim [exec wc -l < [srv $srv_idx stdout]]]",
      "113: }",
      "115: # returns the number of times a line with that pattern appears in a file",
      "116: proc count_message_lines {file pattern} {",
      "117:     set res 0",
      "118:     # exec fails when grep exists with status other than 0 (when the patter wasn't found)",
      "119:     catch {",
      "120:         set res [string trim [exec grep $pattern $file 2> /dev/null | wc -l]]",
      "121:     }",
      "122:     return $res",
      "123: }",
      "125: # returns the number of times a line with that pattern appears in the log",
      "126: proc count_log_message {srv_idx pattern} {",
      "127:     set stdout [srv $srv_idx stdout]",
      "128:     return [count_message_lines $stdout $pattern]",
      "",
      "---------------"
    ],
    "tests/unit/violations.tcl||tests/unit/violations.tcl": [
      "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: # These tests consume massive amounts of memory, and are not",
      "2: # suitable to be executed as part of the normal test suite",
      "3: set ::str500 [string repeat x 500000000] ;# 500mb",
      "5: # Utility function to write big argument into redis client connection",
      "6: proc write_big_bulk {size} {",
      "7:     r write \"\\$$size\\r\\n\"",
      "8:     while {$size >= 500000000} {",
      "9:         r write $::str500",
      "10:         incr size -500000000",
      "11:     }",
      "12:     if {$size > 0} {",
      "13:         r write [string repeat x $size]",
      "14:     }",
      "15:     r write \"\\r\\n\"",
      "16: }",
      "18: # One XADD with one huge 5GB field",
      "19: # Expected to fail resulting in an empty stream",
      "20: start_server [list overrides [list save \"\"] ] {",
      "21:     test {XADD one huge field} {",
      "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
      "25:         r write \"\\$1\\r\\nA\\r\\n\"",
      "26:         write_big_bulk 5000000000 ;#5gb",
      "27:         r flush",
      "28:         catch {r read} err",
      "29:         assert_match {*too large*} $err",
      "30:         r xlen S1",
      "31:     } {0}",
      "32: }",
      "34: # One XADD with one huge (exactly nearly) 4GB field",
      "35: # This uncovers the overflow in lpEncodeGetType",
      "36: # Expected to fail resulting in an empty stream",
      "37: start_server [list overrides [list save \"\"] ] {",
      "38:     test {XADD one huge field - 1} {",
      "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
      "42:         r write \"\\$1\\r\\nA\\r\\n\"",
      "43:         write_big_bulk 4294967295 ;#4gb-1",
      "44:         r flush",
      "45:         catch {r read} err",
      "46:         assert_match {*too large*} $err",
      "47:         r xlen S1",
      "48:     } {0}",
      "49: }",
      "51: # Gradually add big stream fields using repeated XADD calls",
      "52: start_server [list overrides [list save \"\"] ] {",
      "53:     test {several XADD big fields} {",
      "54:         r config set stream-node-max-bytes 0",
      "55:         for {set j 0} {$j<10} {incr j} {",
      "56:             r xadd stream * 1 $::str500 2 $::str500",
      "57:         }",
      "58:         r ping",
      "59:         r xlen stream",
      "60:     } {10}",
      "61: }",
      "63: # Add over 4GB to a single stream listpack (one XADD command)",
      "64: # Expected to fail resulting in an empty stream",
      "65: start_server [list overrides [list save \"\"] ] {",
      "66:     test {single XADD big fields} {",
      "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
      "68:         for {set j 0} {$j<10} {incr j} {",
      "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
      "70:             write_big_bulk 500000000 ;#500mb",
      "71:         }",
      "72:         r flush",
      "73:         catch {r read} err",
      "74:         assert_match {*too large*} $err",
      "75:         r xlen S",
      "76:     } {0}",
      "77: }",
      "79: # Gradually add big hash fields using repeated HSET calls",
      "80: # This reproduces the overflow in the call to ziplistResize",
      "81: # Object will be converted to hashtable encoding",
      "82: start_server [list overrides [list save \"\"] ] {",
      "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
      "84:     test {hash with many big fields} {",
      "85:         for {set j 0} {$j<10} {incr j} {",
      "86:             r hset h $j $::str500",
      "87:         }",
      "88:         r object encoding h",
      "89:     } {hashtable}",
      "90: }",
      "92: # Add over 4GB to a single hash field (one HSET command)",
      "93: # Object will be converted to hashtable encoding",
      "94: start_server [list overrides [list save \"\"] ] {",
      "95:     test {hash with one huge field} {",
      "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
      "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
      "100:         r write \"\\$1\\r\\nA\\r\\n\"",
      "101:         write_big_bulk 5000000000 ;#5gb",
      "102:         r flush",
      "103:         r read",
      "104:         r object encoding H1",
      "105:     } {hashtable}",
      "106: }",
      "108: # Add over 4GB to a single list member (one LPUSH command)",
      "109: # Currently unsupported, and expected to fail rather than being truncated",
      "110: # Expected to fail resulting in a non-existing list",
      "111: start_server [list overrides [list save \"\"] ] {",
      "112:     test {list with one huge field} {",
      "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
      "116:         write_big_bulk 5000000000 ;#5gb",
      "117:         r flush",
      "118:         catch {r read} err",
      "119:         assert_match {*too large*} $err",
      "120:         r exists L1",
      "121:     } {0}",
      "122: }",
      "124: # SORT which attempts to store an element larger than 4GB into a list.",
      "125: # Currently unsupported and results in an assertion instead of truncation",
      "126: start_server [list overrides [list save \"\"] ] {",
      "127:     test {SORT adds huge field to list} {",
      "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
      "131:         write_big_bulk 5000000000 ;#5gb",
      "132:         r flush",
      "133:         r read",
      "134:         assert_equal [r strlen S1] 5000000000",
      "135:         r set S2 asdf",
      "136:         r sadd myset 1 2",
      "137:         r mset D1 1 D2 2",
      "138:         catch {r sort myset by D* get S* store mylist}",
      "139:         # assert_equal [count_log_message 0 \"crashed by signal\"] 0   - not suitable for 6.0",
      "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
      "141:     }",
      "142: }",
      "144: # SORT which stores an integer encoded element into a list.",
      "145: # Just for coverage, no news here.",
      "146: start_server [list overrides [list save \"\"] ] {",
      "147:     test {SORT adds integer field to list} {",
      "148:         r set S1 asdf",
      "149:         r set S2 123 ;# integer encoded",
      "150:         assert_encoding \"int\" S2",
      "151:         r sadd myset 1 2",
      "152:         r mset D1 1 D2 2",
      "153:         r sort myset by D* get S* store mylist",
      "154:         r llen mylist",
      "155:     } {2}",
      "156: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
      "candidate_info": {
        "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "files": [
          "src/intset.c",
          "src/rdb.c",
          "src/t_set.c"
        ],
        "message": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
        "before_after_code_files": [
          "src/intset.c||src/intset.c",
          "src/rdb.c||src/rdb.c",
          "src/t_set.c||src/t_set.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [
            "src/rdb.c||src/rdb.c"
          ],
          "candidate": [
            "src/rdb.c||src/rdb.c"
          ]
        }
      },
      "candidate_diff": {
        "src/intset.c||src/intset.c": [
          "File: src/intset.c -> src/intset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"intset.h\"",
          "35: #include \"zmalloc.h\"",
          "36: #include \"endianconv.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #include \"redisassert.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105: static intset *intsetResize(intset *is, uint32_t len) {",
          "107:     is = zrealloc(is,sizeof(intset)+size);",
          "108:     return is;",
          "109: }",
          "",
          "[Removed Lines]",
          "106:     uint32_t size = len*intrev32ifbe(is->encoding);",
          "",
          "[Added Lines]",
          "107:     uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
          "108:     assert(size <= SIZE_MAX - sizeof(intset));",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1518:         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "1522:             o = createSetObject();",
          "",
          "[Removed Lines]",
          "1521:         if (len > server.set_max_intset_entries) {",
          "",
          "[Added Lines]",
          "1521:         size_t max_entries = server.set_max_intset_entries;",
          "1522:         if (max_entries >= 1<<30) max_entries = 1<<30;",
          "1523:         if (len > max_entries) {",
          "",
          "---------------"
        ],
        "src/t_set.c||src/t_set.c": [
          "File: src/t_set.c -> src/t_set.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:             if (success) {",
          "70:                     setTypeConvert(subject,OBJ_ENCODING_HT);",
          "71:                 return 1;",
          "72:             }",
          "",
          "[Removed Lines]",
          "69:                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)",
          "",
          "[Added Lines]",
          "69:                 size_t max_entries = server.set_max_intset_entries;",
          "71:                 if (max_entries >= 1<<30) max_entries = 1<<30;",
          "72:                 if (intsetLen(subject->ptr) > max_entries)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
      "candidate_info": {
        "commit_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/dde1c975b88f2e305ad4df720230474e30f6b100",
        "files": [
          "src/replication.c",
          "src/rio.c"
        ],
        "message": "Minor refactoring for rioConnRead and adding errno (#9280)\n\nminor refactoring for rioConnRead and adding errno\n\n(cherry picked from commit a40381640502439f751f42c4b23d4c6d396993e3)",
        "before_after_code_files": [
          "src/replication.c||src/replication.c",
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/replication.c||src/replication.c": [
          "File: src/replication.c -> src/replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1667:         if (rdbLoadRio(&rdb,RDBFLAGS_REPLICATION,&rsi) != C_OK) {",
          "1670:             serverLog(LL_WARNING,",
          "1673:             cancelReplicationHandshake();",
          "1674:             rioFreeConn(&rdb, NULL);",
          "",
          "[Removed Lines]",
          "1669:             stopLoading(0);",
          "1671:                 \"Failed trying to load the MASTER synchronization DB \"",
          "1672:                 \"from socket\");",
          "",
          "[Added Lines]",
          "1670:                       \"Failed trying to load the MASTER synchronization DB \"",
          "1671:                       \"from socket: %s\", strerror(errno));",
          "1672:             stopLoading(0);",
          "",
          "---------------"
        ],
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:         r->io.conn.pos = 0;",
          "188:     }",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {",
          "194:         errno = EOVERFLOW;",
          "195:         return 0;",
          "196:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "210:         }",
          "211:         int retval = connRead(r->io.conn.conn,",
          "212:                           (char*)r->io.conn.buf + sdslen(r->io.conn.buf),",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "208:                 return 0;",
          "209:             }",
          "",
          "[Added Lines]",
          "209:             toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
      "candidate_info": {
        "commit_hash": "bb7597f46ee7798531e236a20f41729d5a056050",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/bb7597f46ee7798531e236a20f41729d5a056050",
        "files": [
          "deps/hiredis/hiredis.c",
          "deps/hiredis/test.c"
        ],
        "message": "Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762)\n\nThe redis-cli command line tool and redis-sentinel service may be vulnerable\nto integer overflow when parsing specially crafted large multi-bulk network\nreplies. This is a result of a vulnerability in the underlying hiredis\nlibrary which does not perform an overflow check before calling the calloc()\nheap allocation function.\n\nThis issue only impacts systems with heap allocators that do not perform their\nown overflow checks. Most modern systems do and are therefore not likely to\nbe affected. Furthermore, by default redis-sentinel uses the jemalloc allocator\nwhich is also not vulnerable.",
        "before_after_code_files": [
          "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c",
          "deps/hiredis/test.c||deps/hiredis/test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/hiredis/hiredis.c||deps/hiredis/hiredis.c": [
          "File: deps/hiredis/hiredis.c -> deps/hiredis/hiredis.c"
        ],
        "deps/hiredis/test.c||deps/hiredis/test.c": [
          "File: deps/hiredis/test.c -> deps/hiredis/test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "400:     freeReplyObject(reply);",
          "401:     redisReaderFree(reader);",
          "403: #if LLONG_MAX > SIZE_MAX",
          "404:     test(\"Set error when array > SIZE_MAX: \");",
          "405:     reader = redisReaderCreate();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:     test(\"Multi-bulk never overflows regardless of maxelements: \");",
          "404:     size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;",
          "405:     char bad_mbulk_reply[100];",
          "406:     snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",",
          "407:         (unsigned long long) bad_mbulk_len);",
          "409:     reader = redisReaderCreate();",
          "411:     redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));",
          "412:     ret = redisReaderGetReply(reader,&reply);",
          "413:     test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);",
          "414:     freeReplyObject(reply);",
          "415:     redisReaderFree(reader);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
      "candidate_info": {
        "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
        "files": [
          "src/networking.c",
          "src/server.c",
          "src/server.h",
          "tests/unit/auth.tcl"
        ],
        "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "before_after_code_files": [
          "src/networking.c||src/networking.c",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "tests/unit/auth.tcl||tests/unit/auth.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [
            "src/server.h||src/server.h"
          ],
          "candidate": [
            "src/server.h||src/server.h"
          ]
        }
      },
      "candidate_diff": {
        "src/networking.c||src/networking.c": [
          "File: src/networking.c -> src/networking.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);",
          "98: }",
          "100: client *createClient(connection *conn) {",
          "101:     client *c = zmalloc(sizeof(client));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100: int authRequired(client *c) {",
          "103:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "104:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "105:                         !c->authenticated;",
          "106:     return auth_required;",
          "107: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1744:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
          "1745:             setProtocolError(\"invalid mbulk count\",c);",
          "1746:             return C_ERR;",
          "1747:         }",
          "1749:         c->qb_pos = (newline-c->querybuf)+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1756:         } else if (ll > 10 && authRequired(c)) {",
          "1757:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
          "1758:             setProtocolError(\"unauth mbulk count\", c);",
          "1759:             return C_ERR;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1791:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
          "1792:                 setProtocolError(\"invalid bulk length\",c);",
          "1793:                 return C_ERR;",
          "1794:             }",
          "1796:             c->qb_pos = newline-c->querybuf+2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1807:             } else if (ll > 16384 && authRequired(c)) {",
          "1808:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
          "1809:                 setProtocolError(\"unauth bulk length\", c);",
          "1810:                 return C_ERR;",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3590:     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||",
          "3591:                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));",
          "3601:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
          "3602:             rejectCommand(c,shared.noautherr);",
          "",
          "[Removed Lines]",
          "3595:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
          "3596:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
          "3597:                         !c->authenticated;",
          "3598:     if (auth_required) {",
          "",
          "[Added Lines]",
          "3593:     if (authRequired(c)) {",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1743: void unprotectClient(client *c);",
          "1744: void initThreadedIO(void);",
          "1745: client *lookupClientByID(uint64_t id);",
          "1747: #ifdef __GNUC__",
          "1748: void addReplyErrorFormat(client *c, const char *fmt, ...)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1746: int authRequired(client *c);",
          "",
          "---------------"
        ],
        "tests/unit/auth.tcl||tests/unit/auth.tcl": [
          "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:         r set foo 100",
          "25:         r incr foo",
          "26:     } {101}",
          "27: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
          "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "30:         $rr write \"*100\\r\\n\"",
          "31:         $rr flush",
          "32:         catch {[$rr read]} e",
          "33:         assert_match {*unauthenticated multibulk length*} $e",
          "34:         $rr close",
          "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
          "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
          "38:         $rr flush",
          "39:         catch {[$rr read]} e",
          "40:         assert_match {*unauthenticated bulk length*} $e",
          "41:         $rr close",
          "42:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
      "candidate_info": {
        "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2030:     sds *argv = NULL;",
          "2031:     int argc = 0;",
          "2032:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "2030:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2044:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "2049:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "2046:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2047:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2052:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "2053:     argc = 0;",
          "2054:     while(argc < *argcp) {",
          "2055:         if (*p != '$') goto protoerr;",
          "2060:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "2061:         argv[argc++] = sdsnewlen(p,slen);",
          "2063:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "2057:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2057:         if (*p == '\\0') goto keep_reading;",
          "2061:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "2065:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2067:     return argv;",
          "2069: protoerr:",
          "2070:     sdsfreesplitres(argv,argc);",
          "2071:     sdsfree(copy);",
          "2072:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2076: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2555: int ldbRepl(lua_State *lua) {",
          "2556:     sds *argv;",
          "2557:     int argc;",
          "2561:     while(1) {",
          "2563:             char buf[1024];",
          "2564:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
          "2565:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2562:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2565:     char* err = NULL;",
          "2570:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2572:             if (err) {",
          "2573:                 lua_pushstring(lua, err);",
          "2574:                 lua_error(lua);",
          "2575:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2570:                 return C_ERR;",
          "2571:             }",
          "2572:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2573:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2589:                 sdsfree(ldb.cbuf);",
          "2590:                 ldb.cbuf = sdsempty();",
          "2591:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2592:                 lua_error(lua);",
          "2593:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "820:     r eval {return 'hello'} 0",
          "821:     r eval {return 'hello'} 0",
          "822: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "824: start_server {tags {\"scripting needs:debug external:skip\"}} {",
          "825:     test {Test scripting debug protocol parsing} {",
          "826:         r script debug sync",
          "827:         r eval {return 'hello'} 0",
          "828:         catch {r 'hello\\0world'} e",
          "829:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "830:         catch {r 'hello\\0'} e",
          "831:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "832:         catch {r '\\0hello'} e",
          "833:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "834:         catch {r '\\0hello\\0'} e",
          "835:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "836:     }",
          "837: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
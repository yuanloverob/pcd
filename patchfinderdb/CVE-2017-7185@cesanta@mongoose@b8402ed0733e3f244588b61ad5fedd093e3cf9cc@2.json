{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7a633bfa3b0f6bd481d9c259e8e3179ca8079a5",
      "candidate_info": {
        "commit_hash": "d7a633bfa3b0f6bd481d9c259e8e3179ca8079a5",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/d7a633bfa3b0f6bd481d9c259e8e3179ca8079a5",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix timers when polling loop gets delayed\n\nPast due timers should be brought forward to restore interval.\n\nPUBLISHED_FROM=dbe1b8b98804cf8de81e1dbe814222422363278f",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14851: uint32_t mg_lwip_get_poll_delay_ms(struct mg_mgr *mgr) {",
          "14852:   struct mg_connection *nc;",
          "14854:   double min_timer = 0;",
          "14855:   int num_timers = 0;",
          "14856:   mg_ev_mgr_lwip_process_signals(mgr);",
          "",
          "[Removed Lines]",
          "14853:   double now = mg_time();",
          "",
          "[Added Lines]",
          "14853:   double now;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14876:     }",
          "14877:   }",
          "14878:   uint32_t timeout_ms = ~0;",
          "14879:   if (num_timers > 0) {",
          "14880:     double timer_timeout_ms = (min_timer - now) * 1000 + 1 /* rounding */;",
          "14881:     if (timer_timeout_ms < timeout_ms) {",
          "14882:       timeout_ms = timer_timeout_ms;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14879:   now = mg_time();",
          "14882:     if (min_timer < now) return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5a9000d466511c36cc3b4e6d49e322d6dbfdc52",
      "candidate_info": {
        "commit_hash": "d5a9000d466511c36cc3b4e6d49e322d6dbfdc52",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/d5a9000d466511c36cc3b4e6d49e322d6dbfdc52",
        "files": [
          "mongoose.c"
        ],
        "message": "Harden MQTT parser some more\n\nPUBLISHED_FROM=5e7fcc7bf145aa8e1045e8d627b1c0731bb4341b",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9956:   switch (cmd) {",
          "9957:     case MG_MQTT_CMD_CONNECT: {",
          "9958:       p = scanto(p, &mm->protocol_name);",
          "9959:       mm->protocol_version = *(uint8_t *) p++;",
          "9960:       mm->connect_flags = *(uint8_t *) p++;",
          "9961:       mm->keep_alive_timer = getu16(p);",
          "9962:       p += 2;",
          "9965:         p = scanto(p, &mm->will_topic);",
          "9967:         p = scanto(p, &mm->will_message);",
          "9969:         p = scanto(p, &mm->user_name);",
          "9971:         p = scanto(p, &mm->password);",
          "9973:       LOG(LL_DEBUG,",
          "9974:           (\"%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] \"",
          "",
          "[Removed Lines]",
          "9963:       if (p < end) p = scanto(p, &mm->client_id);",
          "9964:       if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))",
          "9966:       if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))",
          "9968:       if (p < end && (mm->connect_flags & MG_MQTT_HAS_USER_NAME))",
          "9970:       if (p < end && (mm->connect_flags & MG_MQTT_HAS_PASSWORD))",
          "",
          "[Added Lines]",
          "9959:       if (p > end - 4) return -2;",
          "9964:       if (p >= end) return -2;",
          "9965:       p = scanto(p, &mm->client_id);",
          "9966:       if (p > end) return -2;",
          "9967:       if (mm->connect_flags & MG_MQTT_HAS_WILL) {",
          "9968:         if (p >= end) return -2;",
          "9970:       }",
          "9971:       if (mm->connect_flags & MG_MQTT_HAS_WILL) {",
          "9972:         if (p >= end) return -2;",
          "9974:       }",
          "9975:       if (mm->connect_flags & MG_MQTT_HAS_USER_NAME) {",
          "9976:         if (p >= end) return -2;",
          "9978:       }",
          "9979:       if (mm->connect_flags & MG_MQTT_HAS_PASSWORD) {",
          "9980:         if (p >= end) return -2;",
          "9982:       }",
          "9983:       if (p != end) return -2;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9982:       break;",
          "9983:     }",
          "9984:     case MG_MQTT_CMD_CONNACK:",
          "9985:       mm->connack_ret_code = p[1];",
          "9986:       break;",
          "9987:     case MG_MQTT_CMD_PUBACK:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9997:       if (end - p < 2) return -2;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "9993:       break;",
          "9994:     case MG_MQTT_CMD_PUBLISH: {",
          "9995:       p = scanto(p, &mm->topic);",
          "9996:       if (mm->qos > 0) {",
          "9997:         mm->message_id = getu16(p);",
          "9998:         p += 2;",
          "9999:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10009:       if (p > end) return -2;",
          "10011:         if (end - p < 2) return -2;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "10002:       break;",
          "10003:     }",
          "10004:     case MG_MQTT_CMD_SUBSCRIBE:",
          "10005:       mm->message_id = getu16(p);",
          "10006:       p += 2;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10020:       if (end - p < 2) return -2;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "10037:       while (1) {",
          "10038:         int len = parse_mqtt(io, &mm);",
          "10040:         nc->handler(nc, MG_MQTT_EVENT_BASE + mm.cmd, &mm MG_UD_ARG(user_data));",
          "10041:         mbuf_remove(io, len);",
          "10042:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10055:         if (len < 0) {",
          "10058:           nc->flags |= MG_F_CLOSE_IMMEDIATELY;",
          "10059:           break;",
          "10060:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2fa18b47db9ef17f1d1b3742c06bb25c0384bb54",
      "candidate_info": {
        "commit_hash": "2fa18b47db9ef17f1d1b3742c06bb25c0384bb54",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/2fa18b47db9ef17f1d1b3742c06bb25c0384bb54",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix DNS name uncompression\n\nPUBLISHED_FROM=07e820f539fa5feca2ad1cf81faca8404b773a65",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10836: size_t mg_dns_uncompress_name(struct mg_dns_message *msg, struct mg_str *name,",
          "10837:                               char *dst, int dst_len) {",
          "10839:   char *old_dst = dst;",
          "10840:   const unsigned char *data = (unsigned char *) name->p;",
          "10841:   const unsigned char *end = (unsigned char *) msg->pkt.p + msg->pkt.len;",
          "",
          "[Removed Lines]",
          "10838:   int chunk_len;",
          "",
          "[Added Lines]",
          "10838:   int chunk_len, num_ptrs = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10850:       return 0;",
          "10851:     }",
          "10854:       uint16_t off = (data[-1] & (~0xc0)) << 8 | data[0];",
          "10855:       if (off >= msg->pkt.len) {",
          "10856:         return 0;",
          "10857:       }",
          "10858:       data = (unsigned char *) msg->pkt.p + off;",
          "10859:       continue;",
          "10860:     }",
          "10861:     if (chunk_len > leeway) {",
          "10862:       chunk_len = leeway;",
          "10863:     }",
          "",
          "[Removed Lines]",
          "10853:     if (chunk_len & 0xc0) {",
          "",
          "[Added Lines]",
          "10853:     if ((chunk_len & 0xc0) == 0xc0) {",
          "10859:       if (++num_ptrs > 15) {",
          "10860:         return 0;",
          "10861:       }",
          "10865:     if (chunk_len > 63) {",
          "10866:       return 0;",
          "10867:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb3a5a7d905978b5b1ce26ad3100294ee669dda1",
      "candidate_info": {
        "commit_hash": "fb3a5a7d905978b5b1ce26ad3100294ee669dda1",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/fb3a5a7d905978b5b1ce26ad3100294ee669dda1",
        "files": [
          "mongoose.c"
        ],
        "message": "Disable cert verification when ssl_ca_cert is '*'\n\nPUBLISHED_FROM=578706e48a2c1fbbf5e9aaab3eba743e7d13fa61",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4695: static enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,",
          "4696:                                             const char *ca_cert) {",
          "4697:   if (ca_cert == NULL || strcmp(ca_cert, \"*\") == 0) {",
          "4698:     return MG_SSL_OK;",
          "4699:   }",
          "4700:   ctx->ca_cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->ca_cert));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4698:     mbedtls_ssl_conf_authmode(ctx->conf, MBEDTLS_SSL_VERIFY_NONE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ac857d18db62cd267254e50476add79b84119fee",
      "candidate_info": {
        "commit_hash": "ac857d18db62cd267254e50476add79b84119fee",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/ac857d18db62cd267254e50476add79b84119fee",
        "files": [
          "examples/multithreaded/Makefile",
          "examples/multithreaded/multithreaded.c"
        ],
        "message": "Add mg multithreaded example\n\nPUBLISHED_FROM=8a3424ba6260b0351d7c06270dc141d804ae7f77",
        "before_after_code_files": [
          "examples/multithreaded/multithreaded.c||examples/multithreaded/multithreaded.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "examples/multithreaded/multithreaded.c||examples/multithreaded/multithreaded.c": [
          "File: examples/multithreaded/multithreaded.c -> examples/multithreaded/multithreaded.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #include \"mongoose.h\"",
          "8: static sig_atomic_t s_received_signal = 0;",
          "9: static const char *s_http_port = \"8000\";",
          "10: static const int s_num_worker_threads = 5;",
          "11: static unsigned long s_next_id = 0;",
          "13: static void signal_handler(int sig_num) {",
          "14:   signal(sig_num, signal_handler);",
          "15:   s_received_signal = sig_num;",
          "16: }",
          "17: static struct mg_serve_http_opts s_http_server_opts;",
          "18: static sock_t sock[2];",
          "21: struct work_request {",
          "22:   unsigned long conn_id;  // needed to identify the connection where to send the reply",
          "24: };",
          "27: struct work_result {",
          "28:   unsigned long conn_id;",
          "29:   int sleep_time;",
          "30: };",
          "32: static void on_work_complete(struct mg_connection *nc, int ev, void *ev_data) {",
          "33:   (void) ev;",
          "34:   char s[32];",
          "35:   struct mg_connection *c;",
          "36:   for (c = mg_next(nc->mgr, NULL); c != NULL; c = mg_next(nc->mgr, c)) {",
          "37:     if (c->user_data != NULL) {",
          "38:       struct work_result *res = (struct work_result *)ev_data;",
          "39:       if ((unsigned long)c->user_data == res->conn_id) {",
          "40:         sprintf(s, \"conn_id:%lu sleep:%d\", res->conn_id, res->sleep_time);",
          "41:         mg_send_head(c, 200, strlen(s), \"Content-Type: text/plain\");",
          "42:         mg_printf(c, \"%s\", s);",
          "43:       }",
          "44:     }",
          "45:   }",
          "46: }",
          "48: void *worker_thread_proc(void *param) {",
          "49:   struct mg_mgr *mgr = (struct mg_mgr *) param;",
          "50:   struct work_request req = {0};",
          "52:   while (s_received_signal == 0) {",
          "53:     if (read(sock[1], &req, sizeof(req)) < 0)",
          "54:       perror(\"Reading worker sock\");",
          "55:     int r = rand() % 10;",
          "56:     sleep(r);",
          "57:     struct work_result res = {req.conn_id, r};",
          "58:     mg_broadcast(mgr, on_work_complete, (void *)&res, sizeof(res));",
          "59:   }",
          "60:   return NULL;",
          "61: }",
          "63: static void ev_handler(struct mg_connection *nc, int ev, void *ev_data) {",
          "64:   (void) nc;",
          "65:   (void) ev_data;",
          "67:   switch (ev) {",
          "68:     case MG_EV_ACCEPT:",
          "69:       nc->user_data = (void *)++s_next_id;",
          "70:       break;",
          "71:     case MG_EV_HTTP_REQUEST: {",
          "72:       struct work_request req = {(unsigned long)nc->user_data};",
          "74:       if (write(sock[0], &req, sizeof(req)) < 0)",
          "75:         perror(\"Writing worker sock\");",
          "76:       break;",
          "77:     }",
          "78:     case MG_EV_CLOSE: {",
          "79:       if (nc->user_data) nc->user_data = NULL;",
          "80:     }",
          "81:   }",
          "82: }",
          "84: int main(void) {",
          "85:   struct mg_mgr mgr;",
          "86:   struct mg_connection *nc;",
          "87:   int i;",
          "89:   if (mg_socketpair(sock, SOCK_STREAM) == 0) {",
          "90:     perror(\"Opening socket pair\");",
          "91:     exit(1);",
          "92:   }",
          "94:   signal(SIGTERM, signal_handler);",
          "95:   signal(SIGINT, signal_handler);",
          "97:   mg_mgr_init(&mgr, NULL);",
          "99:   nc = mg_bind(&mgr, s_http_port, ev_handler);",
          "100:   if (nc == NULL) {",
          "101:     printf(\"Failed to create listener\\n\");",
          "102:     return 1;",
          "103:   }",
          "105:   mg_set_protocol_http_websocket(nc);",
          "106:   s_http_server_opts.document_root = \".\";  // Serve current directory",
          "107:   s_http_server_opts.enable_directory_listing = \"no\";",
          "109:   for (i = 0; i < s_num_worker_threads; i++) {",
          "110:     mg_start_thread(worker_thread_proc, &mgr);",
          "111:   }",
          "113:   printf(\"Started on port %s\\n\", s_http_port);",
          "114:   while (s_received_signal == 0) {",
          "115:     mg_mgr_poll(&mgr, 200);",
          "116:   }",
          "118:   mg_mgr_free(&mgr);",
          "120:   closesocket(sock[0]);",
          "121:   closesocket(sock[1]);",
          "123:   return 0;",
          "124: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
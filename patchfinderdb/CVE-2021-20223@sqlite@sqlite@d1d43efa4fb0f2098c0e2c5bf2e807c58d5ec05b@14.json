{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "98aa1d735eb80f90b4523f50c17fc965ce967c79",
      "candidate_info": {
        "commit_hash": "98aa1d735eb80f90b4523f50c17fc965ce967c79",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/98aa1d735eb80f90b4523f50c17fc965ce967c79",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "test/count.test"
        ],
        "message": "Fix the count-optimization so that it honors the NOT INDEXED clause.\n\nFossilOrigin-Name: 0d23a0b209900f4d7c6c13f75d4364f19afc23db72f9cfdb11e05b81502e8040",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "test/count.test||test/count.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3fce9711a47329811cd333ae2f1d1384a96d73b9a5d6f9d08454a57a3fd24fc8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6700:         if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);",
          "6708:           }",
          "6709:         }",
          "6710:         if( pBest ){",
          "",
          "[Removed Lines]",
          "6701:         for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){",
          "6702:           if( pIdx->bUnordered==0",
          "6703:            && pIdx->szIdxRow<pTab->szTabRow",
          "6704:            && pIdx->pPartIdxWhere==0",
          "6705:            && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)",
          "6706:           ){",
          "6707:             pBest = pIdx;",
          "",
          "[Added Lines]",
          "6701:         if( !p->pSrc->a[0].fg.notIndexed ){",
          "6702:           for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){",
          "6703:             if( pIdx->bUnordered==0",
          "6704:              && pIdx->szIdxRow<pTab->szTabRow",
          "6705:              && pIdx->pPartIdxWhere==0",
          "6706:              && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)",
          "6707:             ){",
          "6708:               pBest = pIdx;",
          "6709:             }",
          "",
          "---------------"
        ],
        "test/count.test||test/count.test": [
          "File: test/count.test -> test/count.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:   SELECT count(DISTINCT) FROM t6 GROUP BY x;",
          "197: } {1 {DISTINCT aggregates must have exactly one argument}}",
          "199: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "199: # 2020-05-08.",
          "200: # The count() optimization should honor the NOT INDEXED clause",
          "201: #",
          "202: reset_db",
          "203: do_execsql_test count-7.1 {",
          "204:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b INT, c VARCHAR(1000));",
          "205:   CREATE INDEX t1b ON t1(b);",
          "206:   INSERT INTO t1(a,b,c) values(1,2,'count.test cases for NOT INDEXED');",
          "207:   ANALYZE;",
          "208:   UPDATE sqlite_stat1 SET stat='1000000 10' WHERE idx='t1b';",
          "209:   ANALYZE sqlite_master;",
          "210: }",
          "211: do_eqp_test count-7.2 {",
          "212:   SELECT count(1) FROM t1;",
          "213: } {",
          "214:   QUERY PLAN",
          "215:   `--SCAN TABLE t1 USING COVERING INDEX t1b",
          "216: }",
          "217: do_eqp_test count-7.3 {",
          "218:   SELECT count(1) FROM t1 NOT INDEXED",
          "219: } {",
          "220:   QUERY PLAN",
          "221:   `--SCAN TABLE t1",
          "222: }",
          "223: do_eqp_test count-7.3 {",
          "224:   SELECT count(*) FROM t1;",
          "225: } {",
          "226:   QUERY PLAN",
          "227:   `--SCAN TABLE t1 USING COVERING INDEX t1b",
          "228: }",
          "229: do_eqp_test count-7.4 {",
          "230:   SELECT count(*) FROM t1 NOT INDEXED",
          "231: } {",
          "232:   QUERY PLAN",
          "233:   `--SCAN TABLE t1",
          "234: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "59c56796917a28041e8f315abe1a376508413961",
      "candidate_info": {
        "commit_hash": "59c56796917a28041e8f315abe1a376508413961",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/59c56796917a28041e8f315abe1a376508413961",
        "files": [
          "manifest",
          "manifest.uuid",
          "tool/lemon.c"
        ],
        "message": "Fix incorrect SQL generated by the Lemon change of the previous check-in.\n\nFossilOrigin-Name: fccfb8a9ed3c1df9f23762bb8df6fdf36a21118899e3fae41f451169a5f2c08e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "tool/lemon.c||tool/lemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 329cbb372d4d77f774f01a87d104c40ef42d713afbe76195b65f5ca205c5ea7b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tool/lemon.c||tool/lemon.c": [
          "File: tool/lemon.c -> tool/lemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4234:     for(i=0, rp=lemp->rule; rp; rp=rp->next, i++){",
          "4235:       assert( i==rp->iRule );",
          "4236:       fprintf(sql,",
          "4238:         rp->iRule, rp->lhs->index",
          "4239:       );",
          "4240:       writeRuleText(sql, rp);",
          "",
          "[Removed Lines]",
          "4237:         \"INSERT INTO rule(ruleid,lhs)VALUES(%d,%d,'\",",
          "",
          "[Added Lines]",
          "4237:         \"INSERT INTO rule(ruleid,lhs,txt)VALUES(%d,%d,'\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b55389412fbce88965cc897ff25630527fa8db30",
      "candidate_info": {
        "commit_hash": "b55389412fbce88965cc897ff25630527fa8db30",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b55389412fbce88965cc897ff25630527fa8db30",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/sqliteInt.h"
        ],
        "message": "Use __has_extension(c_atomic) instead of __has_feature(c_atomic) to detect support for atomic load and store operations with clang.\n\nFossilOrigin-Name: 362255791f8801e0d9869e36239b8b2cb29c38bf0b86894bd2d159ce46d8447e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1ab30c75f2fe14d1ee77d0eace4e29ba8f805d63e2da0897b111ea1311f409aa",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "195: #endif",
          "197: # define AtomicLoad(PTR)       __atomic_load_n((PTR),__ATOMIC_RELAXED)",
          "198: # define AtomicStore(PTR,VAL)  __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)",
          "199: #else",
          "",
          "[Removed Lines]",
          "193: #ifndef __has_feature",
          "196: #if GCC_VERSION>=4007000 || __has_feature(c_atomic)",
          "",
          "[Added Lines]",
          "193: #ifndef __has_extension",
          "196: #if GCC_VERSION>=4007000 || __has_extension(c_atomic)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "51f2b1719ce6cbc5fba38885b3ddf622f8647ce9",
      "candidate_info": {
        "commit_hash": "51f2b1719ce6cbc5fba38885b3ddf622f8647ce9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/51f2b1719ce6cbc5fba38885b3ddf622f8647ce9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/where.c",
          "test/join.test"
        ],
        "message": "Fix an instance where the planner might choose to use the OR-optimization when it adds no benefit. The same quirk causes an assert() to fail. This is not a bug in released versions - without the assert() the library still gets the right answer, it just does so less efficiently than it should.\n\nFossilOrigin-Name: f4bed1d7af8a94c6facd567dec5afae8865a5ad76b8834493099e5e30bed1132",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/where.c||src/where.c",
          "test/join.test||test/join.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c4d5b75c9381255ec8d9a284eedb6b27be46ca868cae5985cf8a5769b15290c3",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2135:   }",
          "2136:   pBuilder->iPlanLimit--;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2138:   whereLoopAdjustCost(pWInfo->pLoops, pTemplate);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2162:   ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);",
          "2164:   if( ppPrev==0 ){",
          "",
          "[Removed Lines]",
          "2161:   whereLoopAdjustCost(pWInfo->pLoops, pTemplate);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/join.test||test/join.test": [
          "File: test/join.test -> test/join.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "1001:    WHERE v0.c0 == 0;",
          "1002: } {123 0 c0}",
          "1005: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1004: #-------------------------------------------------------------------------",
          "1005: reset_db",
          "1006: do_execsql_test join-24.1 {",
          "1007:   CREATE TABLE t1(a PRIMARY KEY, x);",
          "1008:   CREATE TABLE t2(b INT);",
          "1009:   CREATE INDEX t1aa ON t1(a, a);",
          "1011:   INSERT INTO t1 VALUES('abc', 'def');",
          "1012:   INSERT INTO t2 VALUES(1);",
          "1013: }",
          "1015: do_execsql_test join-24.2 {",
          "1016:   SELECT * FROM t2 JOIN t1 WHERE a='abc' AND x='def';",
          "1017: } {1 abc def}",
          "1018: do_execsql_test join-24.3 {",
          "1019:   SELECT * FROM t2 JOIN t1 WHERE a='abc' AND x='abc';",
          "1020: } {}",
          "1022: do_execsql_test join-24.2 {",
          "1023:   SELECT * FROM t2 LEFT JOIN t1 ON a=0 WHERE (x='x' OR x IS NULL);",
          "1024: } {1 {} {}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "477a357278473b57853b6e5bb7a3184e4e7cd5e9",
      "candidate_info": {
        "commit_hash": "477a357278473b57853b6e5bb7a3184e4e7cd5e9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/477a357278473b57853b6e5bb7a3184e4e7cd5e9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/analyze.c",
          "src/btree.c",
          "src/btree.h",
          "src/ctime.c",
          "src/pragma.c",
          "src/pragma.h",
          "src/select.c",
          "src/sqliteInt.h",
          "src/vdbe.c",
          "tool/mkpragmatab.tcl"
        ],
        "message": "Add support for PRAGMA analyze_limit and approximate analysis.\n\nFossilOrigin-Name: 812547525d35df975f40cbbeb604cc9cd2dec809c1ca083cbb139fe59ffa1d73",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/analyze.c||src/analyze.c",
          "src/btree.c||src/btree.c",
          "src/btree.h||src/btree.h",
          "src/ctime.c||src/ctime.c",
          "src/pragma.c||src/pragma.c",
          "src/pragma.h||src/pragma.h",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/vdbe.c||src/vdbe.c",
          "tool/mkpragmatab.tcl||tool/mkpragmatab.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d09bcce37f1eaf084e3b07eb4a23653ea1f370cdd290ce3875408186adf87022",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/analyze.c||src/analyze.c": [
          "File: src/analyze.c -> src/analyze.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "189:   int aRoot[ArraySize(aTable)];",
          "190:   u8 aCreateTbl[ArraySize(aTable)];",
          "192:   if( v==0 ) return;",
          "193:   assert( sqlite3BtreeHoldsAllMutexes(db) );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: #ifdef SQLITE_ENABLE_STAT4",
          "192:   const int nToOpen = OptimizationEnabled(db,SQLITE_Stat4) ? 2 : 1;",
          "193: #else",
          "194:   const int nToOpen = 1;",
          "195: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "200:   for(i=0; i<ArraySize(aTable); i++){",
          "201:     const char *zTab = aTable[i].zName;",
          "202:     Table *pStat;",
          "203:     if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){",
          "",
          "[Removed Lines]",
          "204:       if( aTable[i].zCols ){",
          "",
          "[Added Lines]",
          "208:     aCreateTbl[i] = 0;",
          "210:       if( i<nToOpen ){",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "219:       aRoot[i] = pStat->tnum;",
          "221:       sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);",
          "222:       if( zWhere ){",
          "223:         sqlite3NestedParse(pParse,",
          "",
          "[Removed Lines]",
          "220:       aCreateTbl[i] = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "236:   }",
          "240:     assert( i<ArraySize(aTable) );",
          "241:     sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, aRoot[i], iDb, 3);",
          "242:     sqlite3VdbeChangeP5(v, aCreateTbl[i]);",
          "",
          "[Removed Lines]",
          "239:   for(i=0; aTable[i].zCols; i++){",
          "",
          "[Added Lines]",
          "244:   for(i=0; i<nToOpen; i++){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "357: static void statAccumDestructor(void *pOld){",
          "358:   StatAccum *p = (StatAccum*)pOld;",
          "359: #ifdef SQLITE_ENABLE_STAT4",
          "364: #endif",
          "365:   sqlite3DbFree(p->db, p);",
          "366: }",
          "",
          "[Removed Lines]",
          "360:   int i;",
          "361:   for(i=0; i<p->nCol; i++) sampleClear(p->db, p->aBest+i);",
          "362:   for(i=0; i<p->mxSample; i++) sampleClear(p->db, p->a+i);",
          "363:   sampleClear(p->db, &p->current);",
          "",
          "[Added Lines]",
          "368:   if( p->mxSample ){",
          "369:     int i;",
          "370:     for(i=0; i<p->nCol; i++) sampleClear(p->db, p->aBest+i);",
          "371:     for(i=0; i<p->mxSample; i++) sampleClear(p->db, p->a+i);",
          "372:     sampleClear(p->db, &p->current);",
          "373:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "402: #ifdef SQLITE_ENABLE_STAT4",
          "404: #endif",
          "",
          "[Removed Lines]",
          "403:   int mxSample = SQLITE_STAT4_SAMPLES;",
          "",
          "[Added Lines]",
          "413:   int mxSample = OptimizationEnabled(db,SQLITE_Stat4) ?SQLITE_STAT4_SAMPLES :0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "416:   n = sizeof(*p)",
          "419: #ifdef SQLITE_ENABLE_STAT4",
          "423: #endif",
          "425:   db = sqlite3_context_db_handle(context);",
          "426:   p = sqlite3DbMallocZero(db, n);",
          "427:   if( p==0 ){",
          "",
          "[Removed Lines]",
          "422:     + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample)",
          "424:   ;",
          "",
          "[Added Lines]",
          "430:   if( mxSample ){",
          "433:       + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample);",
          "434:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "430:   }",
          "432:   p->db = db;",
          "433:   p->nRow = 0;",
          "434:   p->nCol = nCol;",
          "435:   p->nKeyCol = nKeyCol;",
          "436:   p->current.anDLt = (tRowcnt*)&p[1];",
          "437:   p->current.anEq = &p->current.anDLt[nColUp];",
          "439: #ifdef SQLITE_ENABLE_STAT4",
          "444:     p->iGet = -1;",
          "447:     p->current.anLt = &p->current.anEq[nColUp];",
          "448:     p->iPrn = 0x689e962d*(u32)nCol ^ 0xd0944565*(u32)sqlite3_value_int(argv[2]);",
          "",
          "[Removed Lines]",
          "440:   {",
          "445:     p->mxSample = mxSample;",
          "446:     p->nPSample = (tRowcnt)(sqlite3_value_int64(argv[2])/(mxSample/3+1) + 1);",
          "",
          "[Added Lines]",
          "444:   p->nEst = sqlite3_value_int64(argv[2]);",
          "446:   p->nLimit = sqlite3_value_int64(argv[3]);",
          "449:   p->nSkipAhead = 0;",
          "454:   p->mxSample = p->nLimit==0 ? mxSample : 0;",
          "455:   if( mxSample ){",
          "460:     p->nPSample = (tRowcnt)(p->nEst/(mxSample/3+1) + 1);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "704:   }else{",
          "706: #ifdef SQLITE_ENABLE_STAT4",
          "708: #endif",
          "",
          "[Removed Lines]",
          "707:     samplePushPrevious(p, iChng);",
          "",
          "[Added Lines]",
          "724:     if( p->mxSample ) samplePushPrevious(p, iChng);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "715:     for(i=iChng; i<p->nCol; i++){",
          "716:       p->current.anDLt[i]++;",
          "717: #ifdef SQLITE_ENABLE_STAT4",
          "719: #endif",
          "720:       p->current.anEq[i] = 1;",
          "721:     }",
          "722:   }",
          "734: #ifdef SQLITE_ENABLE_STAT4",
          "739:     if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){",
          "740:       p->current.isPSample = 1;",
          "",
          "[Removed Lines]",
          "718:       p->current.anLt[i] += p->current.anEq[i];",
          "723:   p->nRow++;",
          "724: #ifdef SQLITE_ENABLE_STAT4",
          "725:   if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){",
          "726:     sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));",
          "727:   }else{",
          "728:     sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),",
          "729:                                        sqlite3_value_blob(argv[2]));",
          "730:   }",
          "731:   p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;",
          "732: #endif",
          "735:   {",
          "736:     tRowcnt nLt = p->current.anLt[p->nCol-1];",
          "",
          "[Added Lines]",
          "735:       if( p->mxSample ) p->current.anLt[i] += p->current.anEq[i];",
          "741:   p->nRow++;",
          "743:   if( p->mxSample ){",
          "744:     tRowcnt nLt;",
          "745:     if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){",
          "746:       sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));",
          "747:     }else{",
          "748:       sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),",
          "749:                                          sqlite3_value_blob(argv[2]));",
          "750:     }",
          "751:     p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;",
          "753:     nLt = p->current.anLt[p->nCol-1];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "750:         sampleCopy(p, &p->aBest[i], &p->current);",
          "751:       }",
          "752:     }",
          "754: #endif",
          "755: }",
          "756: static const FuncDef statPushFuncdef = {",
          "",
          "[Removed Lines]",
          "753:   }",
          "",
          "[Added Lines]",
          "769:   }else",
          "771:   if( p->nLimit && p->nRow>p->nLimit*(p->nSkipAhead+1) ){",
          "772:     p->nSkipAhead++;",
          "773:     sqlite3_result_int(context, p->current.anDLt[0]>0);",
          "774:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "804:        || eCall==STAT_GET_ROWID || eCall==STAT_GET_NLT",
          "805:        || eCall==STAT_GET_NDLT",
          "806:   );",
          "807:   if( eCall==STAT_GET_STAT1 )",
          "808: #else",
          "809:   assert( argc==1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "828:   assert( eCall==STAT_GET_STAT1 || p->mxSample );",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "839:       return;",
          "840:     }",
          "843:     z = zRet + sqlite3Strlen30(zRet);",
          "844:     for(i=0; i<p->nKeyCol; i++){",
          "845:       u64 nDistinct = p->current.anDLt[i] + 1;",
          "",
          "[Removed Lines]",
          "842:     sqlite3_snprintf(24, zRet, \"%llu\", (u64)p->nRow);",
          "",
          "[Added Lines]",
          "864:     sqlite3_snprintf(24, zRet, \"%llu\",",
          "865:         p->nSkipAhead ? (u64)p->nEst : (u64)p->nRow);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "915:   {0}",
          "916: };",
          "919: #ifdef SQLITE_ENABLE_STAT4",
          "921: #elif SQLITE_DEBUG",
          "922:   assert( iParam==STAT_GET_STAT1 );",
          "923: #else",
          "924:   UNUSED_PARAMETER( iParam );",
          "925: #endif",
          "928:                              &statGetFuncdef, 0);",
          "929: }",
          "",
          "[Removed Lines]",
          "918: static void callStatGet(Parse *pParse, int regStat4, int iParam, int regOut){",
          "920:   sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat4+1);",
          "926:   assert( regOut!=regStat4 && regOut!=regStat4+1 );",
          "927:   sqlite3VdbeAddFunctionCall(pParse, 0, regStat4, regOut, 1+IsStat4,",
          "",
          "[Added Lines]",
          "941: static void callStatGet(Parse *pParse, int regStat, int iParam, int regOut){",
          "943:   sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat+1);",
          "949:   assert( regOut!=regStat && regOut!=regStat+1 );",
          "950:   sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+IsStat4,",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "955: #ifdef SQLITE_ENABLE_STAT4",
          "957: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1091: #ifdef SQLITE_ENABLE_STAT4",
          "1093: #endif",
          "1097:                                &statInitFuncdef, 0);",
          "",
          "[Removed Lines]",
          "1092:     sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regStat4+3);",
          "1094:     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);",
          "1095:     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4+2);",
          "1096:     sqlite3VdbeAddFunctionCall(pParse, 0, regStat4+1, regStat4, 2+IsStat4,",
          "",
          "[Added Lines]",
          "1110:     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat+1);",
          "1111:     assert( regRowid==regStat+2 );",
          "1112:     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regRowid);",
          "1114:     if( OptimizationEnabled(db, SQLITE_Stat4) ){",
          "1115:       sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regTemp);",
          "1116:       addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);",
          "1117:       VdbeCoverage(v);",
          "1118:     }else",
          "1120:     {",
          "1121:       addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);",
          "1122:       VdbeCoverage(v);",
          "1123:       sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp, 1);",
          "1124:     }",
          "1125:     assert( regTemp2==regStat+4 );",
          "1126:     sqlite3VdbeAddOp2(v, OP_Integer, db->nAnalysisLimit, regTemp2);",
          "1127:     sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1109:     sqlite3VdbeAddOp2(v, OP_Integer, 0, regChng);",
          "1110:     addrNextRow = sqlite3VdbeCurrentAddr(v);",
          "",
          "[Removed Lines]",
          "1107:     addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);",
          "1108:     VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1138:         char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);",
          "1139:         sqlite3VdbeAddOp2(v, OP_Integer, i, regChng);",
          "1140:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regTemp);",
          "1141:         aGotoChng[i] =",
          "1142:         sqlite3VdbeAddOp4(v, OP_Ne, regTemp, 0, regPrev+i, pColl, P4_COLLSEQ);",
          "1143:         sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1170:         VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1158:       for(i=0; i<nColTest; i++){",
          "1159:         sqlite3VdbeJumpHere(v, aGotoChng[i]);",
          "1160:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regPrev+i);",
          "1161:       }",
          "1162:       sqlite3VdbeResolveLabel(v, endDistinctTest);",
          "1163:       sqlite3DbFree(db, aGotoChng);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1191:         VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1173: #ifdef SQLITE_ENABLE_STAT4",
          "1186:       }",
          "1189:     }",
          "1190: #endif",
          "1198:     assert( \"BBB\"[0]==SQLITE_AFF_TEXT );",
          "1199:     sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, \"BBB\", 0);",
          "1200:     sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);",
          "",
          "[Removed Lines]",
          "1174:     assert( regRowid==(regStat4+2) );",
          "1175:     if( HasRowid(pTab) ){",
          "1176:       sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);",
          "1177:     }else{",
          "1178:       Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);",
          "1179:       int j, k, regKey;",
          "1180:       regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1181:       for(j=0; j<pPk->nKeyCol; j++){",
          "1182:         k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "1183:         assert( k>=0 && k<pIdx->nColumn );",
          "1184:         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);",
          "1185:         VdbeComment((v, \"%s\", pTab->aCol[pPk->aiColumn[j]].zName));",
          "1187:       sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk->nKeyCol, regRowid);",
          "1188:       sqlite3ReleaseTempRange(pParse, regKey, pPk->nKeyCol);",
          "1191:     assert( regChng==(regStat4+1) );",
          "1192:     sqlite3VdbeAddFunctionCall(pParse, 1, regStat4, regTemp, 2+IsStat4,",
          "1193:                                &statPushFuncdef, 0);",
          "1194:     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1197:     callStatGet(pParse, regStat4, STAT_GET_STAT1, regStat1);",
          "",
          "[Added Lines]",
          "1205:     if( OptimizationEnabled(db, SQLITE_Stat4) ){",
          "1206:       assert( regRowid==(regStat+2) );",
          "1207:       if( HasRowid(pTab) ){",
          "1208:         sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);",
          "1209:       }else{",
          "1210:         Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);",
          "1211:         int j, k, regKey;",
          "1212:         regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);",
          "1213:         for(j=0; j<pPk->nKeyCol; j++){",
          "1214:           k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);",
          "1215:           assert( k>=0 && k<pIdx->nColumn );",
          "1216:           sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);",
          "1217:           VdbeComment((v, \"%s.column(%d)\", pIdx->zName, i));",
          "1218:         }",
          "1219:         sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk->nKeyCol, regRowid);",
          "1220:         sqlite3ReleaseTempRange(pParse, regKey, pPk->nKeyCol);",
          "1224:     assert( regChng==(regStat+1) );",
          "1225:     {",
          "1226:       sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+IsStat4,",
          "1227:                                  &statPushFuncdef, 0);",
          "1228:       if( db->nAnalysisLimit ){",
          "1229:         int j1, j2, j3;",
          "1230:         j1 = sqlite3VdbeAddOp1(v, OP_IsNull, regTemp); VdbeCoverage(v);",
          "1231:         j2 = sqlite3VdbeAddOp1(v, OP_If, regTemp); VdbeCoverage(v);",
          "1232:         j3 = sqlite3VdbeAddOp4Int(v, OP_SeekGT, iIdxCur, 0, regPrev, 1);",
          "1233:         VdbeCoverage(v);",
          "1234:         sqlite3VdbeJumpHere(v, j1);",
          "1235:         sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1236:         sqlite3VdbeJumpHere(v, j2);",
          "1237:         sqlite3VdbeJumpHere(v, j3);",
          "1238:       }else{",
          "1239:         sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);",
          "1240:       }",
          "1241:     }",
          "1244:     callStatGet(pParse, regStat, STAT_GET_STAT1, regStat1);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1208: #ifdef SQLITE_ENABLE_STAT4",
          "1210:       int regEq = regStat1;",
          "1211:       int regLt = regStat1+1;",
          "1212:       int regDLt = regStat1+2;",
          "",
          "[Removed Lines]",
          "1209:     {",
          "",
          "[Added Lines]",
          "1256:     if( OptimizationEnabled(db, SQLITE_Stat4) && db->nAnalysisLimit==0 ){",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1220:       pParse->nMem = MAX(pParse->nMem, regCol+nCol);",
          "1222:       addrNext = sqlite3VdbeCurrentAddr(v);",
          "1224:       addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);",
          "1225:       VdbeCoverage(v);",
          "1229:       sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);",
          "1230:       VdbeCoverage(v);",
          "1231:       for(i=0; i<nCol; i++){",
          "",
          "[Removed Lines]",
          "1223:       callStatGet(pParse, regStat4, STAT_GET_ROWID, regSampleRowid);",
          "1226:       callStatGet(pParse, regStat4, STAT_GET_NEQ, regEq);",
          "1227:       callStatGet(pParse, regStat4, STAT_GET_NLT, regLt);",
          "1228:       callStatGet(pParse, regStat4, STAT_GET_NDLT, regDLt);",
          "",
          "[Added Lines]",
          "1270:       callStatGet(pParse, regStat, STAT_GET_ROWID, regSampleRowid);",
          "1273:       callStatGet(pParse, regStat, STAT_GET_NEQ, regEq);",
          "1274:       callStatGet(pParse, regStat, STAT_GET_NLT, regLt);",
          "1275:       callStatGet(pParse, regStat, STAT_GET_NDLT, regDLt);",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9512:   return rc;",
          "9513: }",
          "",
          "[Removed Lines]",
          "9515: #ifndef SQLITE_OMIT_BTREECOUNT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9586:   return rc;",
          "9587: }",
          "",
          "[Removed Lines]",
          "9588: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.h||src/btree.h": [
          "File: src/btree.h -> src/btree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "336: #endif",
          "337: int sqlite3BtreeCursorIsValidNN(BtCursor*);",
          "340: int sqlite3BtreeCount(sqlite3*, BtCursor*, i64*);",
          "343: #ifdef SQLITE_TEST",
          "344: int sqlite3BtreeCursorInfo(BtCursor*, int*, int);",
          "",
          "[Removed Lines]",
          "339: #ifndef SQLITE_OMIT_BTREECOUNT",
          "341: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/ctime.c||src/ctime.c": [
          "File: src/ctime.c -> src/ctime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "514: #if SQLITE_OMIT_BLOB_LITERAL",
          "515:   \"OMIT_BLOB_LITERAL\",",
          "516: #endif",
          "520: #if SQLITE_OMIT_CAST",
          "521:   \"OMIT_CAST\",",
          "522: #endif",
          "",
          "[Removed Lines]",
          "517: #if SQLITE_OMIT_BTREECOUNT",
          "518:   \"OMIT_BTREECOUNT\",",
          "519: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/pragma.c||src/pragma.c": [
          "File: src/pragma.c -> src/pragma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1729:         }",
          "1730:         sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);",
          "1731:         sqlite3VdbeJumpHere(v, loopTop-1);",
          "1733:         if( !isQuick ){",
          "1734:           sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");",
          "1735:           for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){",
          "",
          "[Removed Lines]",
          "1732: #ifndef SQLITE_OMIT_BTREECOUNT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2178:     break;",
          "2179:   }",
          "2181: #if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2186:   case PragTyp_ANALYSIS_LIMIT: {",
          "2187:     sqlite3_int64 N;",
          "2188:     if( zRight",
          "2189:      && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK",
          "2190:      && N>=0",
          "2191:     ){",
          "2192:       db->nAnalysisLimit = (int)(N&0x7fffffff);",
          "2193:     }",
          "2194:     returnSingleInt(v, db->nAnalysisLimit);",
          "2195:     break;",
          "2196:   }",
          "",
          "---------------"
        ],
        "src/pragma.h||src/pragma.h": [
          "File: src/pragma.h -> src/pragma.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #define PragTyp_ACTIVATE_EXTENSIONS            0",
          "",
          "[Removed Lines]",
          "9: #define PragTyp_HEADER_VALUE                   1",
          "10: #define PragTyp_AUTO_VACUUM                    2",
          "11: #define PragTyp_FLAG                           3",
          "12: #define PragTyp_BUSY_TIMEOUT                   4",
          "13: #define PragTyp_CACHE_SIZE                     5",
          "14: #define PragTyp_CACHE_SPILL                    6",
          "15: #define PragTyp_CASE_SENSITIVE_LIKE            7",
          "16: #define PragTyp_COLLATION_LIST                 8",
          "17: #define PragTyp_COMPILE_OPTIONS                9",
          "18: #define PragTyp_DATA_STORE_DIRECTORY          10",
          "19: #define PragTyp_DATABASE_LIST                 11",
          "20: #define PragTyp_DEFAULT_CACHE_SIZE            12",
          "21: #define PragTyp_ENCODING                      13",
          "22: #define PragTyp_FOREIGN_KEY_CHECK             14",
          "23: #define PragTyp_FOREIGN_KEY_LIST              15",
          "24: #define PragTyp_FUNCTION_LIST                 16",
          "25: #define PragTyp_HARD_HEAP_LIMIT               17",
          "26: #define PragTyp_INCREMENTAL_VACUUM            18",
          "27: #define PragTyp_INDEX_INFO                    19",
          "28: #define PragTyp_INDEX_LIST                    20",
          "29: #define PragTyp_INTEGRITY_CHECK               21",
          "30: #define PragTyp_JOURNAL_MODE                  22",
          "31: #define PragTyp_JOURNAL_SIZE_LIMIT            23",
          "32: #define PragTyp_LOCK_PROXY_FILE               24",
          "33: #define PragTyp_LOCKING_MODE                  25",
          "34: #define PragTyp_PAGE_COUNT                    26",
          "35: #define PragTyp_MMAP_SIZE                     27",
          "36: #define PragTyp_MODULE_LIST                   28",
          "37: #define PragTyp_OPTIMIZE                      29",
          "38: #define PragTyp_PAGE_SIZE                     30",
          "39: #define PragTyp_PRAGMA_LIST                   31",
          "40: #define PragTyp_SECURE_DELETE                 32",
          "41: #define PragTyp_SHRINK_MEMORY                 33",
          "42: #define PragTyp_SOFT_HEAP_LIMIT               34",
          "43: #define PragTyp_SYNCHRONOUS                   35",
          "44: #define PragTyp_TABLE_INFO                    36",
          "45: #define PragTyp_TEMP_STORE                    37",
          "46: #define PragTyp_TEMP_STORE_DIRECTORY          38",
          "47: #define PragTyp_THREADS                       39",
          "48: #define PragTyp_WAL_AUTOCHECKPOINT            40",
          "49: #define PragTyp_WAL_CHECKPOINT                41",
          "50: #define PragTyp_LOCK_STATUS                   42",
          "51: #define PragTyp_STATS                         43",
          "",
          "[Added Lines]",
          "9: #define PragTyp_ANALYSIS_LIMIT                 1",
          "10: #define PragTyp_HEADER_VALUE                   2",
          "11: #define PragTyp_AUTO_VACUUM                    3",
          "12: #define PragTyp_FLAG                           4",
          "13: #define PragTyp_BUSY_TIMEOUT                   5",
          "14: #define PragTyp_CACHE_SIZE                     6",
          "15: #define PragTyp_CACHE_SPILL                    7",
          "16: #define PragTyp_CASE_SENSITIVE_LIKE            8",
          "17: #define PragTyp_COLLATION_LIST                 9",
          "18: #define PragTyp_COMPILE_OPTIONS               10",
          "19: #define PragTyp_DATA_STORE_DIRECTORY          11",
          "20: #define PragTyp_DATABASE_LIST                 12",
          "21: #define PragTyp_DEFAULT_CACHE_SIZE            13",
          "22: #define PragTyp_ENCODING                      14",
          "23: #define PragTyp_FOREIGN_KEY_CHECK             15",
          "24: #define PragTyp_FOREIGN_KEY_LIST              16",
          "25: #define PragTyp_FUNCTION_LIST                 17",
          "26: #define PragTyp_HARD_HEAP_LIMIT               18",
          "27: #define PragTyp_INCREMENTAL_VACUUM            19",
          "28: #define PragTyp_INDEX_INFO                    20",
          "29: #define PragTyp_INDEX_LIST                    21",
          "30: #define PragTyp_INTEGRITY_CHECK               22",
          "31: #define PragTyp_JOURNAL_MODE                  23",
          "32: #define PragTyp_JOURNAL_SIZE_LIMIT            24",
          "33: #define PragTyp_LOCK_PROXY_FILE               25",
          "34: #define PragTyp_LOCKING_MODE                  26",
          "35: #define PragTyp_PAGE_COUNT                    27",
          "36: #define PragTyp_MMAP_SIZE                     28",
          "37: #define PragTyp_MODULE_LIST                   29",
          "38: #define PragTyp_OPTIMIZE                      30",
          "39: #define PragTyp_PAGE_SIZE                     31",
          "40: #define PragTyp_PRAGMA_LIST                   32",
          "41: #define PragTyp_SECURE_DELETE                 33",
          "42: #define PragTyp_SHRINK_MEMORY                 34",
          "43: #define PragTyp_SOFT_HEAP_LIMIT               35",
          "44: #define PragTyp_SYNCHRONOUS                   36",
          "45: #define PragTyp_TABLE_INFO                    37",
          "46: #define PragTyp_TEMP_STORE                    38",
          "47: #define PragTyp_TEMP_STORE_DIRECTORY          39",
          "48: #define PragTyp_THREADS                       40",
          "49: #define PragTyp_WAL_AUTOCHECKPOINT            41",
          "50: #define PragTyp_WAL_CHECKPOINT                42",
          "51: #define PragTyp_LOCK_STATUS                   43",
          "52: #define PragTyp_STATS                         44",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141: #endif",
          "142: #if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)",
          "143:  {/* zName:     */ \"application_id\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143:  {/* zName:     */ \"analysis_limit\",",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6665:     else {",
          "6667:       Table *pTab;",
          "6668:       if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){",
          "",
          "[Removed Lines]",
          "6666: #ifndef SQLITE_OMIT_BTREECOUNT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6721:         sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);",
          "6722:         sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "6723:         explainSimpleCount(pParse, pTab, pBest);",
          "",
          "[Removed Lines]",
          "6724:       }else",
          "6726:       {",
          "",
          "[Added Lines]",
          "6723:       }else{",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3187:   break;",
          "3188: }",
          "3198:   i64 nEntry;",
          "3199:   BtCursor *pCrsr;",
          "",
          "[Removed Lines]",
          "3196: #ifndef SQLITE_OMIT_BTREECOUNT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3201:   assert( p->apCsr[pOp->p1]->eCurType==CURTYPE_BTREE );",
          "3202:   pCrsr = p->apCsr[pOp->p1]->uc.pCursor;",
          "3203:   assert( pCrsr );",
          "3207:   pOut = out2Prerelease(p, pOp);",
          "3208:   pOut->u.i = nEntry;",
          "3209:   goto check_for_interrupt;",
          "3210: }",
          "",
          "[Removed Lines]",
          "3205:   rc = sqlite3BtreeCount(db, pCrsr, &nEntry);",
          "3206:   if( rc ) goto abort_due_to_error;",
          "3211: #endif",
          "",
          "[Added Lines]",
          "3207:   if( pOp->p3 ){",
          "3208:     nEntry = sqlite3BtreeRowCountEst(pCrsr);",
          "3209:   }else{",
          "3211:     rc = sqlite3BtreeCount(db, pCrsr, &nEntry);",
          "3212:     if( rc ) goto abort_due_to_error;",
          "3213:   }",
          "",
          "---------------"
        ],
        "tool/mkpragmatab.tcl||tool/mkpragmatab.tcl": [
          "File: tool/mkpragmatab.tcl -> tool/mkpragmatab.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "382:   NAME: threads",
          "383:   FLAG: Result0",
          "385:   NAME: optimize",
          "386:   FLAG: Result1 NeedSchema",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "385:   NAME: analysis_limit",
          "386:   FLAG: Result0",
          "",
          "---------------"
        ]
      }
    }
  ]
}
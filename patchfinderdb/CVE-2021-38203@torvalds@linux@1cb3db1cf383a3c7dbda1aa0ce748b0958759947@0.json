{
  "cve_id": "CVE-2021-38203",
  "cve_desc": "btrfs in the Linux kernel before 5.13.4 allows attackers to cause a denial of service (deadlock) via processes that trigger allocation of new system chunks during times when there is a shortage of free space in the system space_info.",
  "repo": "torvalds/linux",
  "patch_hash": "1cb3db1cf383a3c7dbda1aa0ce748b0958759947",
  "patch_info": {
    "commit_hash": "1cb3db1cf383a3c7dbda1aa0ce748b0958759947",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1cb3db1cf383a3c7dbda1aa0ce748b0958759947",
    "files": [
      "fs/btrfs/block-group.c",
      "fs/btrfs/transaction.c",
      "fs/btrfs/transaction.h"
    ],
    "message": "btrfs: fix deadlock with concurrent chunk allocations involving system chunks\n\nWhen a task attempting to allocate a new chunk verifies that there is not\ncurrently enough free space in the system space_info and there is another\ntask that allocated a new system chunk but it did not finish yet the\ncreation of the respective block group, it waits for that other task to\nfinish creating the block group. This is to avoid exhaustion of the system\nchunk array in the superblock, which is limited, when we have a thundering\nherd of tasks allocating new chunks. This problem was described and fixed\nby commit eafa4fd0ad0607 (\"btrfs: fix exhaustion of the system chunk array\ndue to concurrent allocations\").\n\nHowever there are two very similar scenarios where this can lead to a\ndeadlock:\n\n1) Task B allocated a new system chunk and task A is waiting on task B\n   to finish creation of the respective system block group. However before\n   task B ends its transaction handle and finishes the creation of the\n   system block group, it attempts to allocate another chunk (like a data\n   chunk for an fallocate operation for a very large range). Task B will\n   be unable to progress and allocate the new chunk, because task A set\n   space_info->chunk_alloc to 1 and therefore it loops at\n   btrfs_chunk_alloc() waiting for task A to finish its chunk allocation\n   and set space_info->chunk_alloc to 0, but task A is waiting on task B\n   to finish creation of the new system block group, therefore resulting\n   in a deadlock;\n\n2) Task B allocated a new system chunk and task A is waiting on task B to\n   finish creation of the respective system block group. By the time that\n   task B enter the final phase of block group allocation, which happens\n   at btrfs_create_pending_block_groups(), when it modifies the extent\n   tree, the device tree or the chunk tree to insert the items for some\n   new block group, it needs to allocate a new chunk, so it ends up at\n   btrfs_chunk_alloc() and keeps looping there because task A has set\n   space_info->chunk_alloc to 1, but task A is waiting for task B to\n   finish creation of the new system block group and release the reserved\n   system space, therefore resulting in a deadlock.\n\nIn short, the problem is if a task B needs to allocate a new chunk after\nit previously allocated a new system chunk and if another task A is\ncurrently waiting for task B to complete the allocation of the new system\nchunk.\n\nUnfortunately this deadlock scenario introduced by the previous fix for\nthe system chunk array exhaustion problem does not have a simple and short\nfix, and requires a big change to rework the chunk allocation code so that\nchunk btree updates are all made in the first phase of chunk allocation.\nAnd since this deadlock regression is being frequently hit on zoned\nfilesystems and the system chunk array exhaustion problem is triggered\nin more extreme cases (originally observed on PowerPC with a node size\nof 64K when running the fallocate tests from stress-ng), revert the\nchanges from that commit. The next patch in the series, with a subject\nof \"btrfs: rework chunk allocation to avoid exhaustion of the system\nchunk array\" does the necessary changes to fix the system chunk array\nexhaustion problem.\n\nReported-by: Naohiro Aota <naohiro.aota@wdc.com>\nLink: https://lore.kernel.org/linux-btrfs/20210621015922.ewgbffxuawia7liz@naota-xeon/\nFixes: eafa4fd0ad0607 (\"btrfs: fix exhaustion of the system chunk array due to concurrent allocations\")\nCC: stable@vger.kernel.org # 5.12+\nTested-by: Shin'ichiro Kawasaki <shinichiro.kawasaki@wdc.com>\nTested-by: Naohiro Aota <naohiro.aota@wdc.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nTested-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/block-group.c||fs/btrfs/block-group.c",
      "fs/btrfs/transaction.c||fs/btrfs/transaction.c",
      "fs/btrfs/transaction.h||fs/btrfs/transaction.h"
    ]
  },
  "patch_diff": {
    "fs/btrfs/block-group.c||fs/btrfs/block-group.c": [
      "File: fs/btrfs/block-group.c -> fs/btrfs/block-group.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3378: void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)",
      "3379: {",
      "3381:  struct btrfs_fs_info *fs_info = trans->fs_info;",
      "3382:  struct btrfs_space_info *info;",
      "3383:  u64 left;",
      "",
      "[Removed Lines]",
      "3380:  struct btrfs_transaction *cur_trans = trans->transaction;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3392:  lockdep_assert_held(&fs_info->chunk_mutex);",
      "3394:  info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);",
      "3396:  spin_lock(&info->lock);",
      "3397:  left = info->total_bytes - btrfs_space_info_used(info, true);",
      "3398:  spin_unlock(&info->lock);",
      "",
      "[Removed Lines]",
      "3395: again:",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3412:  if (left < thresh) {",
      "3413:   u64 flags = btrfs_system_alloc_profile(fs_info);",
      "",
      "[Removed Lines]",
      "3414:   u64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);",
      "3456:   if (reserved > trans->chunk_bytes_reserved) {",
      "3457:    const u64 min_needed = reserved - thresh;",
      "3459:    mutex_unlock(&fs_info->chunk_mutex);",
      "3460:    wait_event(cur_trans->chunk_reserve_wait,",
      "3461:       atomic64_read(&cur_trans->chunk_bytes_reserved) <=",
      "3462:       min_needed);",
      "3463:    mutex_lock(&fs_info->chunk_mutex);",
      "3464:    goto again;",
      "3465:   }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3477:   ret = btrfs_block_rsv_add(fs_info->chunk_root,",
      "3478:        &fs_info->chunk_block_rsv,",
      "3479:        thresh, BTRFS_RESERVE_NO_FLUSH);",
      "3482:    trans->chunk_bytes_reserved += thresh;",
      "3484:  }",
      "3485: }",
      "",
      "[Removed Lines]",
      "3480:   if (!ret) {",
      "3481:    atomic64_add(thresh, &cur_trans->chunk_bytes_reserved);",
      "3483:   }",
      "",
      "[Added Lines]",
      "3426:   if (!ret)",
      "",
      "---------------"
    ],
    "fs/btrfs/transaction.c||fs/btrfs/transaction.c": [
      "File: fs/btrfs/transaction.c -> fs/btrfs/transaction.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "260: void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)",
      "261: {",
      "262:  struct btrfs_fs_info *fs_info = trans->fs_info;",
      "265:  if (!trans->chunk_bytes_reserved)",
      "266:   return;",
      "",
      "[Removed Lines]",
      "263:  struct btrfs_transaction *cur_trans = trans->transaction;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:  btrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,",
      "271:     trans->chunk_bytes_reserved, NULL);",
      "274:  trans->chunk_bytes_reserved = 0;",
      "275: }",
      "",
      "[Removed Lines]",
      "272:  atomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);",
      "273:  cond_wake_up(&cur_trans->chunk_reserve_wait);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "386:  spin_lock_init(&cur_trans->dropped_roots_lock);",
      "387:  INIT_LIST_HEAD(&cur_trans->releasing_ebs);",
      "388:  spin_lock_init(&cur_trans->releasing_ebs_lock);",
      "391:  list_add_tail(&cur_trans->list, &fs_info->trans_list);",
      "392:  extent_io_tree_init(fs_info, &cur_trans->dirty_pages,",
      "393:    IO_TREE_TRANS_DIRTY_PAGES, fs_info->btree_inode);",
      "",
      "[Removed Lines]",
      "389:  atomic64_set(&cur_trans->chunk_bytes_reserved, 0);",
      "390:  init_waitqueue_head(&cur_trans->chunk_reserve_wait);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/btrfs/transaction.h||fs/btrfs/transaction.h": [
      "File: fs/btrfs/transaction.h -> fs/btrfs/transaction.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "97:  spinlock_t releasing_ebs_lock;",
      "98:  struct list_head releasing_ebs;",
      "106: };",
      "108: #define __TRANS_FREEZABLE (1U << 0)",
      "",
      "[Removed Lines]",
      "104:  atomic64_t chunk_bytes_reserved;",
      "105:  wait_queue_head_t chunk_reserve_wait;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "eafa4fd0ad06074da8be4e28ff93b4dca9ffa407",
      "candidate_info": {
        "commit_hash": "eafa4fd0ad06074da8be4e28ff93b4dca9ffa407",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eafa4fd0ad06074da8be4e28ff93b4dca9ffa407",
        "files": [
          "fs/btrfs/block-group.c",
          "fs/btrfs/transaction.c",
          "fs/btrfs/transaction.h"
        ],
        "message": "btrfs: fix exhaustion of the system chunk array due to concurrent allocations\n\nWhen we are running out of space for updating the chunk tree, that is,\nwhen we are low on available space in the system space info, if we have\nmany task concurrently allocating block groups, via fallocate for example,\nmany of them can end up all allocating new system chunks when only one is\nneeded. In extreme cases this can lead to exhaustion of the system chunk\narray, which has a size limit of 2048 bytes, and results in a transaction\nabort with errno EFBIG, producing a trace in dmesg like the following,\nwhich was triggered on a PowerPC machine with a node/leaf size of 64K:\n\n  [1359.518899] ------------[ cut here ]------------\n  [1359.518980] BTRFS: Transaction aborted (error -27)\n  [1359.519135] WARNING: CPU: 3 PID: 16463 at ../fs/btrfs/block-group.c:1968 btrfs_create_pending_block_groups+0x340/0x3c0 [btrfs]\n  [1359.519152] Modules linked in: (...)\n  [1359.519239] Supported: Yes, External\n  [1359.519252] CPU: 3 PID: 16463 Comm: stress-ng Tainted: G               X    5.3.18-47-default #1 SLE15-SP3\n  [1359.519274] NIP:  c008000000e36fe8 LR: c008000000e36fe4 CTR: 00000000006de8e8\n  [1359.519293] REGS: c00000056890b700 TRAP: 0700   Tainted: G               X     (5.3.18-47-default)\n  [1359.519317] MSR:  800000000282b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 48008222  XER: 00000007\n  [1359.519356] CFAR: c00000000013e170 IRQMASK: 0\n  [1359.519356] GPR00: c008000000e36fe4 c00000056890b990 c008000000e83200 0000000000000026\n  [1359.519356] GPR04: 0000000000000000 0000000000000000 0000d52a3b027651 0000000000000007\n  [1359.519356] GPR08: 0000000000000003 0000000000000001 0000000000000007 0000000000000000\n  [1359.519356] GPR12: 0000000000008000 c00000063fe44600 000000001015e028 000000001015dfd0\n  [1359.519356] GPR16: 000000000000404f 0000000000000001 0000000000010000 0000dd1e287affff\n  [1359.519356] GPR20: 0000000000000001 c000000637c9a000 ffffffffffffffe5 0000000000000000\n  [1359.519356] GPR24: 0000000000000004 0000000000000000 0000000000000100 ffffffffffffffc0\n  [1359.519356] GPR28: c000000637c9a000 c000000630e09230 c000000630e091d8 c000000562188b08\n  [1359.519561] NIP [c008000000e36fe8] btrfs_create_pending_block_groups+0x340/0x3c0 [btrfs]\n  [1359.519613] LR [c008000000e36fe4] btrfs_create_pending_block_groups+0x33c/0x3c0 [btrfs]\n  [1359.519626] Call Trace:\n  [1359.519671] [c00000056890b990] [c008000000e36fe4] btrfs_create_pending_block_groups+0x33c/0x3c0 [btrfs] (unreliable)\n  [1359.519729] [c00000056890ba90] [c008000000d68d44] __btrfs_end_transaction+0xbc/0x2f0 [btrfs]\n  [1359.519782] [c00000056890bae0] [c008000000e309ac] btrfs_alloc_data_chunk_ondemand+0x154/0x610 [btrfs]\n  [1359.519844] [c00000056890bba0] [c008000000d8a0fc] btrfs_fallocate+0xe4/0x10e0 [btrfs]\n  [1359.519891] [c00000056890bd00] [c0000000004a23b4] vfs_fallocate+0x174/0x350\n  [1359.519929] [c00000056890bd50] [c0000000004a3cf8] ksys_fallocate+0x68/0xf0\n  [1359.519957] [c00000056890bda0] [c0000000004a3da8] sys_fallocate+0x28/0x40\n  [1359.519988] [c00000056890bdc0] [c000000000038968] system_call_exception+0xe8/0x170\n  [1359.520021] [c00000056890be20] [c00000000000cb70] system_call_common+0xf0/0x278\n  [1359.520037] Instruction dump:\n  [1359.520049] 7d0049ad 40c2fff4 7c0004ac 71490004 40820024 2f83fffb 419e0048 3c620000\n  [1359.520082] e863bcb8 7ec4b378 48010d91 e8410018 <0fe00000> 3c820000 e884bcc8 7ec6b378\n  [1359.520122] ---[ end trace d6c186e151022e20 ]---\n\nThe following steps explain how we can end up in this situation:\n\n1) Task A is at check_system_chunk(), either because it is allocating a\n   new data or metadata block group, at btrfs_chunk_alloc(), or because\n   it is removing a block group or turning a block group RO. It does not\n   matter why;\n\n2) Task A sees that there is not enough free space in the system\n   space_info object, that is 'left' is < 'thresh'. And at this point\n   the system space_info has a value of 0 for its 'bytes_may_use'\n   counter;\n\n3) As a consequence task A calls btrfs_alloc_chunk() in order to allocate\n   a new system block group (chunk) and then reserves 'thresh' bytes in\n   the chunk block reserve with the call to btrfs_block_rsv_add(). This\n   changes the chunk block reserve's 'reserved' and 'size' counters by an\n   amount of 'thresh', and changes the 'bytes_may_use' counter of the\n   system space_info object from 0 to 'thresh'.\n\n   Also during its call to btrfs_alloc_chunk(), we end up increasing the\n   value of the 'total_bytes' counter of the system space_info object by\n   8MiB (the size of a system chunk stripe). This happens through the\n   call chain:\n\n   btrfs_alloc_chunk()\n       create_chunk()\n           btrfs_make_block_group()\n               btrfs_update_space_info()\n\n4) After it finishes the first phase of the block group allocation, at\n   btrfs_chunk_alloc(), task A unlocks the chunk mutex;\n\n5) At this point the new system block group was added to the transaction\n   handle's list of new block groups, but its block group item, device\n   items and chunk item were not yet inserted in the extent, device and\n   chunk trees, respectively. That only happens later when we call\n   btrfs_finish_chunk_alloc() through a call to\n   btrfs_create_pending_block_groups();\n\n   Note that only when we update the chunk tree, through the call to\n   btrfs_finish_chunk_alloc(), we decrement the 'reserved' counter\n   of the chunk block reserve as we COW/allocate extent buffers,\n   through:\n\n   btrfs_alloc_tree_block()\n      btrfs_use_block_rsv()\n         btrfs_block_rsv_use_bytes()\n\n   And the system space_info's 'bytes_may_use' is decremented everytime\n   we allocate an extent buffer for COW operations on the chunk tree,\n   through:\n\n   btrfs_alloc_tree_block()\n      btrfs_reserve_extent()\n         find_free_extent()\n            btrfs_add_reserved_bytes()\n\n   If we end up COWing less chunk btree nodes/leaves than expected, which\n   is the typical case since the amount of space we reserve is always\n   pessimistic to account for the worst possible case, we release the\n   unused space through:\n\n   btrfs_create_pending_block_groups()\n      btrfs_trans_release_chunk_metadata()\n         btrfs_block_rsv_release()\n            block_rsv_release_bytes()\n                btrfs_space_info_free_bytes_may_use()\n\n   But before task A gets into btrfs_create_pending_block_groups()...\n\n6) Many other tasks start allocating new block groups through fallocate,\n   each one does the first phase of block group allocation in a\n   serialized way, since btrfs_chunk_alloc() takes the chunk mutex\n   before calling check_system_chunk() and btrfs_alloc_chunk().\n\n   However before everyone enters the final phase of the block group\n   allocation, that is, before calling btrfs_create_pending_block_groups(),\n   new tasks keep coming to allocate new block groups and while at\n   check_system_chunk(), the system space_info's 'bytes_may_use' keeps\n   increasing each time a task reserves space in the chunk block reserve.\n   This means that eventually some other task can end up not seeing enough\n   free space in the system space_info and decide to allocate yet another\n   system chunk.\n\n   This may repeat several times if yet more new tasks keep allocating\n   new block groups before task A, and all the other tasks, finish the\n   creation of the pending block groups, which is when reserved space\n   in excess is released. Eventually this can result in exhaustion of\n   system chunk array in the superblock, with btrfs_add_system_chunk()\n   returning EFBIG, resulting later in a transaction abort.\n\n   Even when we don't reach the extreme case of exhausting the system\n   array, most, if not all, unnecessarily created system block groups\n   end up being unused since when finishing creation of the first\n   pending system block group, the creation of the following ones end\n   up not needing to COW nodes/leaves of the chunk tree, so we never\n   allocate and deallocate from them, resulting in them never being\n   added to the list of unused block groups - as a consequence they\n   don't get deleted by the cleaner kthread - the only exceptions are\n   if we unmount and mount the filesystem again, which adds any unused\n   block groups to the list of unused block groups, if a scrub is\n   run, which also adds unused block groups to the unused list, and\n   under some circumstances when using a zoned filesystem or async\n   discard, which may also add unused block groups to the unused list.\n\nSo fix this by:\n\n*) Tracking the number of reserved bytes for the chunk tree per\n   transaction, which is the sum of reserved chunk bytes by each\n   transaction handle currently being used;\n\n*) When there is not enough free space in the system space_info,\n   if there are other transaction handles which reserved chunk space,\n   wait for some of them to complete in order to have enough excess\n   reserved space released, and then try again. Otherwise proceed with\n   the creation of a new system chunk.\n\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/block-group.c||fs/btrfs/block-group.c",
          "fs/btrfs/transaction.c||fs/btrfs/transaction.c",
          "fs/btrfs/transaction.h||fs/btrfs/transaction.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/block-group.c||fs/btrfs/block-group.c",
            "fs/btrfs/transaction.c||fs/btrfs/transaction.c",
            "fs/btrfs/transaction.h||fs/btrfs/transaction.h"
          ],
          "candidate": [
            "fs/btrfs/block-group.c||fs/btrfs/block-group.c",
            "fs/btrfs/transaction.c||fs/btrfs/transaction.c",
            "fs/btrfs/transaction.h||fs/btrfs/transaction.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/block-group.c||fs/btrfs/block-group.c": [
          "File: fs/btrfs/block-group.c -> fs/btrfs/block-group.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3274: void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)",
          "3275: {",
          "3276:  struct btrfs_fs_info *fs_info = trans->fs_info;",
          "3277:  struct btrfs_space_info *info;",
          "3278:  u64 left;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3276:  struct btrfs_transaction *cur_trans = trans->transaction;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3287:  lockdep_assert_held(&fs_info->chunk_mutex);",
          "3289:  info = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);",
          "3290:  spin_lock(&info->lock);",
          "3291:  left = info->total_bytes - btrfs_space_info_used(info, true);",
          "3292:  spin_unlock(&info->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3291: again:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3306:  if (left < thresh) {",
          "3307:   u64 flags = btrfs_system_alloc_profile(fs_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3310:   u64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);",
          "3352:   if (reserved > trans->chunk_bytes_reserved) {",
          "3353:    const u64 min_needed = reserved - thresh;",
          "3355:    mutex_unlock(&fs_info->chunk_mutex);",
          "3356:    wait_event(cur_trans->chunk_reserve_wait,",
          "3357:       atomic64_read(&cur_trans->chunk_bytes_reserved) <=",
          "3358:       min_needed);",
          "3359:    mutex_lock(&fs_info->chunk_mutex);",
          "3360:    goto again;",
          "3361:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3319:   ret = btrfs_block_rsv_add(fs_info->chunk_root,",
          "3320:        &fs_info->chunk_block_rsv,",
          "3321:        thresh, BTRFS_RESERVE_NO_FLUSH);",
          "3323:    trans->chunk_bytes_reserved += thresh;",
          "3324:  }",
          "3325: }",
          "",
          "[Removed Lines]",
          "3322:   if (!ret)",
          "",
          "[Added Lines]",
          "3376:   if (!ret) {",
          "3377:    atomic64_add(thresh, &cur_trans->chunk_bytes_reserved);",
          "3379:   }",
          "",
          "---------------"
        ],
        "fs/btrfs/transaction.c||fs/btrfs/transaction.c": [
          "File: fs/btrfs/transaction.c -> fs/btrfs/transaction.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "260: void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)",
          "261: {",
          "262:  struct btrfs_fs_info *fs_info = trans->fs_info;",
          "264:  if (!trans->chunk_bytes_reserved)",
          "265:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "263:  struct btrfs_transaction *cur_trans = trans->transaction;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "269:  btrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,",
          "270:     trans->chunk_bytes_reserved, NULL);",
          "271:  trans->chunk_bytes_reserved = 0;",
          "272: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:  atomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);",
          "273:  cond_wake_up(&cur_trans->chunk_reserve_wait);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "383:  spin_lock_init(&cur_trans->dropped_roots_lock);",
          "384:  INIT_LIST_HEAD(&cur_trans->releasing_ebs);",
          "385:  spin_lock_init(&cur_trans->releasing_ebs_lock);",
          "386:  list_add_tail(&cur_trans->list, &fs_info->trans_list);",
          "387:  extent_io_tree_init(fs_info, &cur_trans->dirty_pages,",
          "388:    IO_TREE_TRANS_DIRTY_PAGES, fs_info->btree_inode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:  atomic64_set(&cur_trans->chunk_bytes_reserved, 0);",
          "390:  init_waitqueue_head(&cur_trans->chunk_reserve_wait);",
          "",
          "---------------"
        ],
        "fs/btrfs/transaction.h||fs/btrfs/transaction.h": [
          "File: fs/btrfs/transaction.h -> fs/btrfs/transaction.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:  spinlock_t releasing_ebs_lock;",
          "98:  struct list_head releasing_ebs;",
          "99: };",
          "101: #define __TRANS_FREEZABLE (1U << 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104:  atomic64_t chunk_bytes_reserved;",
          "105:  wait_queue_head_t chunk_reserve_wait;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
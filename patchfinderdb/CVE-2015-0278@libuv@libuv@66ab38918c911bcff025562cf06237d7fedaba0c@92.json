{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0e5004ba77bc6db8a668b8826db5a9647e355623",
      "candidate_info": {
        "commit_hash": "0e5004ba77bc6db8a668b8826db5a9647e355623",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0e5004ba77bc6db8a668b8826db5a9647e355623",
        "files": [
          "src/win/core.c"
        ],
        "message": "windows: properly close the default loop\n\nAlso close the IOCP handle for any loop.\n\nCloses #393",
        "before_after_code_files": [
          "src/win/core.c||src/win/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/core.c||src/win/core.c": [
          "File: src/win/core.c -> src/win/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include \"req-inl.h\"",
          "43: static uv_once_t uv_init_guard_ = UV_ONCE_INIT;",
          "47: #if defined(_DEBUG) && (defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR))",
          "",
          "[Removed Lines]",
          "40: static uv_loop_t uv_default_loop_;",
          "44: static uv_once_t uv_default_loop_init_guard_ = UV_ONCE_INIT;",
          "",
          "[Added Lines]",
          "39: static uv_loop_t default_loop_struct;",
          "40: static uv_loop_t* default_loop_ptr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "181: }",
          "193: void uv__once_init(void) {",
          "194:   uv_once(&uv_init_guard_, uv_init);",
          "195: }",
          "198: uv_loop_t* uv_default_loop(void) {",
          "201: }",
          "204: static void uv__loop_close(uv_loop_t* loop) {",
          "206:   assert(!loop->wq_async.async_sent);",
          "207:   loop->wq_async.close_cb = NULL;",
          "208:   uv__handle_closing(&loop->wq_async);",
          "209:   uv__handle_close(&loop->wq_async);",
          "218:   }",
          "221:   uv_mutex_lock(&loop->wq_mutex);",
          "222:   assert(QUEUE_EMPTY(&loop->wq) && \"thread pool work queue not empty!\");",
          "223:   assert(!uv__has_active_reqs(loop));",
          "224:   uv_mutex_unlock(&loop->wq_mutex);",
          "225:   uv_mutex_destroy(&loop->wq_mutex);",
          "226: }",
          "",
          "[Removed Lines]",
          "184: static void uv_default_loop_init(void) {",
          "186:   uv__once_init();",
          "189:   uv_loop_init(&uv_default_loop_);",
          "190: }",
          "199:   uv_once(&uv_default_loop_init_guard_, uv_default_loop_init);",
          "200:   return &uv_default_loop_;",
          "211:   if (loop != &uv_default_loop_) {",
          "212:     size_t i;",
          "213:     for (i = 0; i < ARRAY_SIZE(loop->poll_peer_sockets); i++) {",
          "214:       SOCKET sock = loop->poll_peer_sockets[i];",
          "215:       if (sock != 0 && sock != INVALID_SOCKET)",
          "216:         closesocket(sock);",
          "217:     }",
          "",
          "[Added Lines]",
          "189:   if (default_loop_ptr != NULL)",
          "190:     return default_loop_ptr;",
          "192:   if (uv_loop_init(&default_loop_struct))",
          "193:     return NULL;",
          "195:   default_loop_ptr = &default_loop_struct;",
          "196:   return default_loop_ptr;",
          "201:   size_t i;",
          "209:   for (i = 0; i < ARRAY_SIZE(loop->poll_peer_sockets); i++) {",
          "210:     SOCKET sock = loop->poll_peer_sockets[i];",
          "211:     if (sock != 0 && sock != INVALID_SOCKET)",
          "212:       closesocket(sock);",
          "221:   CloseHandle(loop->iocp);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242: #ifndef NDEBUG",
          "243:   memset(loop, -1, sizeof(*loop));",
          "244: #endif",
          "246:   return 0;",
          "247: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "241:   if (loop == default_loop_ptr)",
          "242:     default_loop_ptr = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "267: void uv_loop_delete(uv_loop_t* loop) {",
          "269:   assert(err == 0);",
          "271:     free(loop);",
          "272: }",
          "",
          "[Removed Lines]",
          "268:   int err = uv_loop_close(loop);",
          "270:   if (loop != &uv_default_loop_)",
          "",
          "[Added Lines]",
          "266:   uv_loop_t* default_loop;",
          "267:   int err;",
          "268:   default_loop = default_loop_ptr;",
          "269:   err = uv_loop_close(loop);",
          "271:   if (loop != default_loop)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ad8f74302f88e85142d6af50c4178d13a2fd3be",
      "candidate_info": {
        "commit_hash": "7ad8f74302f88e85142d6af50c4178d13a2fd3be",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/7ad8f74302f88e85142d6af50c4178d13a2fd3be",
        "files": [
          "include/uv.h",
          "src/fs-poll.c",
          "src/unix/pipe.c",
          "src/uv-common.c",
          "src/win/pipe.c"
        ],
        "message": "unix, windows: set required size on UV_ENOBUFS\n\nWhen the supplied buffer is not big enough and UV_ENOBUFS is\nreturned, hint the user about the required size by setting\nthe len paramemeter to the required value.\n\nApplies to:\n- uv_pipe_getsockname\n- uv_fs_event_getpath\n- uv_fs_poll_getpath",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/fs-poll.c||src/fs-poll.c",
          "src/unix/pipe.c||src/unix/pipe.c",
          "src/uv-common.c||src/uv-common.c",
          "src/win/pipe.c||src/win/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1208: UV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle, char* buf, size_t* len);",
          "",
          "[Added Lines]",
          "1209: UV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,",
          "1210:                                   char* buf,",
          "1211:                                   size_t* len);",
          "",
          "---------------"
        ],
        "src/fs-poll.c||src/fs-poll.c": [
          "File: src/fs-poll.c -> src/fs-poll.c"
        ],
        "src/unix/pipe.c||src/unix/pipe.c": [
          "File: src/unix/pipe.c -> src/unix/pipe.c"
        ],
        "src/uv-common.c||src/uv-common.c": [
          "File: src/uv-common.c -> src/uv-common.c"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1779:   if (nt_status == STATUS_BUFFER_OVERFLOW) {",
          "1780:     name_size = sizeof(*name_info) + tmp_name_info.FileNameLength;",
          "1781:     name_info = malloc(name_size);",
          "1785:     nt_status = pNtQueryInformationFile(handle->handle,",
          "1786:                                         &io_status,",
          "",
          "[Removed Lines]",
          "1782:     if (!name_info)",
          "1783:       uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "",
          "[Added Lines]",
          "1782:     if (!name_info) {",
          "1784:       return UV_ENOMEM;",
          "1785:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1510ce81fde8f07a4f692274de467dfdad33c604",
      "candidate_info": {
        "commit_hash": "1510ce81fde8f07a4f692274de467dfdad33c604",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/1510ce81fde8f07a4f692274de467dfdad33c604",
        "files": [
          "Makefile.am",
          "include/uv.h",
          "src/unix/async.c",
          "src/win/async.c",
          "test/test-async-null-cb.c",
          "test/test-list.h",
          "uv.gyp"
        ],
        "message": "unix, windows: allow NULL async callback\n\nAllow a NULL callback so the user doesn't have to provide a dummy when\nthe actual event is processed by e.g. a check handle callback.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "include/uv.h||include/uv.h",
          "src/unix/async.c||src/unix/async.c",
          "src/win/async.c||src/win/async.c",
          "test/test-async-null-cb.c||test/test-async-null-cb.c",
          "test/test-list.h||test/test-list.h",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:                          test/task.h \\",
          "64:                          test/test-active.c \\",
          "65:                          test/test-async.c \\",
          "66:                          test/test-barrier.c \\",
          "67:                          test/test-callback-order.c \\",
          "68:                          test/test-callback-stack.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:                          test/test-async-null-cb.c \\",
          "",
          "---------------"
        ],
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ],
        "src/unix/async.c||src/unix/async.c": [
          "File: src/unix/async.c -> src/unix/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:   QUEUE_FOREACH(q, &loop->async_handles) {",
          "80:     h = QUEUE_DATA(q, uv_async_t, queue);",
          "82:     h->pending = 0;",
          "83:     h->async_cb(h, 0);",
          "84:   }",
          "85: }",
          "",
          "[Removed Lines]",
          "81:     if (!h->pending) continue;",
          "",
          "[Added Lines]",
          "82:     if (h->pending == 0)",
          "83:       continue;",
          "86:     if (h->async_cb == NULL)",
          "87:       continue;",
          "",
          "---------------"
        ],
        "src/win/async.c||src/win/async.c": [
          "File: src/win/async.c -> src/win/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "92:   handle->async_sent = 0;",
          "97:     uv_want_endgame(loop, (uv_handle_t*)handle);",
          "98:   }",
          "99: }",
          "",
          "[Removed Lines]",
          "94:   if (!(handle->flags & UV__HANDLE_CLOSING)) {",
          "95:     handle->async_cb((uv_async_t*) handle, 0);",
          "96:   } else {",
          "",
          "[Added Lines]",
          "94:   if (handle->flags & UV__HANDLE_CLOSING) {",
          "96:   } else if (handle->async_cb != NULL) {",
          "97:     handle->async_cb(handle, 0);",
          "",
          "---------------"
        ],
        "test/test-async-null-cb.c||test/test-async-null-cb.c": [
          "File: test/test-async-null-cb.c -> test/test-async-null-cb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "25: static uv_async_t async_handle;",
          "26: static uv_check_t check_handle;",
          "27: static int check_cb_called;",
          "28: static uv_thread_t thread;",
          "31: static void thread_cb(void* dummy) {",
          "32:   (void) &dummy;",
          "33:   uv_async_send(&async_handle);",
          "34: }",
          "37: static void check_cb(uv_check_t* handle, int status) {",
          "38:   ASSERT(check_cb_called == 0);",
          "39:   uv_close((uv_handle_t*) &async_handle, NULL);",
          "40:   uv_close((uv_handle_t*) &check_handle, NULL);",
          "41:   check_cb_called++;",
          "42: }",
          "45: TEST_IMPL(async_null_cb) {",
          "46:   ASSERT(0 == uv_async_init(uv_default_loop(), &async_handle, NULL));",
          "47:   ASSERT(0 == uv_check_init(uv_default_loop(), &check_handle));",
          "48:   ASSERT(0 == uv_check_start(&check_handle, check_cb));",
          "49:   ASSERT(0 == uv_thread_create(&thread, thread_cb, NULL));",
          "50:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "51:   ASSERT(0 == uv_thread_join(&thread));",
          "52:   ASSERT(1 == check_cb_called);",
          "53:   MAKE_VALGRIND_HAPPY();",
          "54:   return 0;",
          "55: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: TEST_DECLARE   (active)",
          "135: TEST_DECLARE   (embed)",
          "136: TEST_DECLARE   (async)",
          "137: TEST_DECLARE   (get_currentexe)",
          "138: TEST_DECLARE   (process_title)",
          "139: TEST_DECLARE   (cwd_and_chdir)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: TEST_DECLARE   (async_null_cb)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "396:   TEST_ENTRY  (embed)",
          "398:   TEST_ENTRY  (async)",
          "400:   TEST_ENTRY  (get_currentexe)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400:   TEST_ENTRY  (async_null_cb)",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "302:         'test/test-util.c',",
          "303:         'test/test-active.c',",
          "304:         'test/test-async.c',",
          "305:         'test/test-callback-stack.c',",
          "306:         'test/test-callback-order.c',",
          "307:         'test/test-connection-fail.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305:         'test/test-async-null-cb.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d2f67b92c6ed46fb6dc9f9a65580b6ae63f72472",
      "candidate_info": {
        "commit_hash": "d2f67b92c6ed46fb6dc9f9a65580b6ae63f72472",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d2f67b92c6ed46fb6dc9f9a65580b6ae63f72472",
        "files": [
          "configure.ac"
        ],
        "message": "build: use AM_PROG_AR conditionally\n\nAM_PROG_AR does not exist in automake v0.11 but without it, you can't\nbuild libuv with automake v0.12+ on Darwin.",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: AC_ENABLE_SHARED",
          "22: AC_ENABLE_STATIC",
          "23: AC_PROG_CC",
          "25: LT_INIT",
          "26: # TODO(bnoordhuis) Check for -pthread vs. -pthreads",
          "27: AC_CHECK_LIB([dl], [dlopen])",
          "",
          "[Removed Lines]",
          "24: AM_PROG_AR",
          "",
          "[Added Lines]",
          "24: # AM_PROG_AR is not available in automake v0.11 but it's essential in v0.12.",
          "25: m4_ifdef([AM_PROG_AR], [AM_PROG_AR])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8c9d5dce57056805d1842741ecd9d32cc8b97e0e",
      "candidate_info": {
        "commit_hash": "8c9d5dce57056805d1842741ecd9d32cc8b97e0e",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/8c9d5dce57056805d1842741ecd9d32cc8b97e0e",
        "files": [
          "include/uv.h",
          "src/fs-poll.c",
          "test/test-fs-poll.c",
          "test/test-list.h"
        ],
        "message": "unix, windows: add uv_fs_poll_getpath",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/fs-poll.c||src/fs-poll.c",
          "test/test-fs-poll.c||test/test-fs-poll.c",
          "test/test-list.h||test/test-list.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1933: UV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1940: UV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buf, size_t* len);",
          "",
          "---------------"
        ],
        "src/fs-poll.c||src/fs-poll.c": [
          "File: src/fs-poll.c -> src/fs-poll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118: }",
          "121: void uv__fs_poll_close(uv_fs_poll_t* handle) {",
          "122:   uv_fs_poll_stop(handle);",
          "123: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121: int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buf, size_t* len) {",
          "122:   struct poll_ctx* ctx;",
          "123:   size_t required_len;",
          "125:   if (!uv__is_active(handle)) {",
          "127:     return UV_EINVAL;",
          "128:   }",
          "130:   ctx = handle->poll_ctx;",
          "131:   assert(ctx != NULL);",
          "133:   required_len = strlen(ctx->path) + 1;",
          "134:   if (required_len > *len) {",
          "136:     return UV_ENOBUFS;",
          "137:   }",
          "139:   memcpy(buf, ctx->path, required_len);",
          "142:   return 0;",
          "143: }",
          "",
          "---------------"
        ],
        "test/test-fs-poll.c||test/test-fs-poll.c": [
          "File: test/test-fs-poll.c -> test/test-fs-poll.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:                     const uv_stat_t* prev,",
          "34:                     const uv_stat_t* curr);",
          "36: static uv_fs_poll_t poll_handle;",
          "37: static uv_timer_t timer_handle;",
          "38: static uv_loop_t* loop;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: static void poll_cb_fail(uv_fs_poll_t* handle,",
          "37:                          int status,",
          "38:                          const uv_stat_t* prev,",
          "39:                          const uv_stat_t* curr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72: }",
          "75: static void poll_cb(uv_fs_poll_t* handle,",
          "76:                     int status,",
          "77:                     const uv_stat_t* prev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80: static void poll_cb_fail(uv_fs_poll_t* handle,",
          "81:                          int status,",
          "82:                          const uv_stat_t* prev,",
          "83:                          const uv_stat_t* curr) {",
          "84:   ASSERT(0 && \"fail_cb called\");",
          "85: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "144:   MAKE_VALGRIND_HAPPY();",
          "145:   return 0;",
          "146: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162: TEST_IMPL(fs_poll_getpath) {",
          "163:   char buf[1024];",
          "164:   size_t len;",
          "165:   loop = uv_default_loop();",
          "167:   remove(FIXTURE);",
          "169:   ASSERT(0 == uv_fs_poll_init(loop, &poll_handle));",
          "170:   len = sizeof buf;",
          "171:   ASSERT(UV_EINVAL == uv_fs_poll_getpath(&poll_handle, buf, &len));",
          "172:   ASSERT(0 == uv_fs_poll_start(&poll_handle, poll_cb_fail, FIXTURE, 100));",
          "173:   len = sizeof buf;",
          "174:   ASSERT(0 == uv_fs_poll_getpath(&poll_handle, buf, &len));",
          "175:   ASSERT(0 == memcmp(buf, FIXTURE, len));",
          "177:   uv_close((uv_handle_t*) &poll_handle, close_cb);",
          "179:   ASSERT(0 == uv_run(loop, UV_RUN_DEFAULT));",
          "181:   ASSERT(close_cb_called == 1);",
          "183:   MAKE_VALGRIND_HAPPY();",
          "184:   return 0;",
          "185: }",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "176: TEST_DECLARE   (spawn_stdout_and_stderr_to_file)",
          "177: TEST_DECLARE   (spawn_auto_unref)",
          "178: TEST_DECLARE   (fs_poll)",
          "179: TEST_DECLARE   (kill)",
          "180: TEST_DECLARE   (fs_file_noent)",
          "181: TEST_DECLARE   (fs_file_nametoolong)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "179: TEST_DECLARE   (fs_poll_getpath)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "475:   TEST_ENTRY  (spawn_stdout_and_stderr_to_file)",
          "476:   TEST_ENTRY  (spawn_auto_unref)",
          "477:   TEST_ENTRY  (fs_poll)",
          "478:   TEST_ENTRY  (kill)",
          "480: #ifdef _WIN32",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "479:   TEST_ENTRY  (fs_poll_getpath)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
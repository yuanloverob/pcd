{
  "cve_id": "CVE-2015-2141",
  "cve_desc": "The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack.",
  "repo": "weidai11/cryptopp",
  "patch_hash": "9425e16437439e68c7d96abef922167d68fafaff",
  "patch_info": {
    "commit_hash": "9425e16437439e68c7d96abef922167d68fafaff",
    "repo": "weidai11/cryptopp",
    "commit_url": "https://github.com/weidai11/cryptopp/commit/9425e16437439e68c7d96abef922167d68fafaff",
    "files": [
      "rw.cpp"
    ],
    "message": "Fix for CVE-2015-2141. Thanks to Evgeny Sidorov for reporting. Squaring to satisfy Jacobi requirements suggested by JPM.",
    "before_after_code_files": [
      "rw.cpp||rw.cpp"
    ]
  },
  "patch_diff": {
    "rw.cpp||rw.cpp": [
      "File: rw.cpp -> rw.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "126:  DoQuickSanityCheck();",
      "127:  ModularArithmetic modn(m_n);",
      "128:  Integer r, rInv;",
      "130:   r.Randomize(rng, Integer::One(), m_n - Integer::One());",
      "131:   rInv = modn.MultiplicativeInverse(r);",
      "132:  } while (rInv.IsZero());",
      "133:  Integer re = modn.Square(r);",
      "134:  re = modn.Multiply(re, x);   // blind",
      "",
      "[Removed Lines]",
      "129:  do { // do this in a loop for people using small numbers for testing",
      "",
      "[Added Lines]",
      "131:  do {",
      "135:   r = modn.Square(r);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1f0c35e6693db8350ebd99998dbbd23cf303e40d",
      "candidate_info": {
        "commit_hash": "1f0c35e6693db8350ebd99998dbbd23cf303e40d",
        "repo": "weidai11/cryptopp",
        "commit_url": "https://github.com/weidai11/cryptopp/commit/1f0c35e6693db8350ebd99998dbbd23cf303e40d",
        "files": [
          "rw.cpp",
          "shark.cpp",
          "sharkbox.cpp",
          "square.cpp",
          "tftables.cpp"
        ],
        "message": "Cleared initialization warning related to use of brackets",
        "before_after_code_files": [
          "rw.cpp||rw.cpp",
          "shark.cpp||shark.cpp",
          "sharkbox.cpp||sharkbox.cpp",
          "square.cpp||square.cpp",
          "tftables.cpp||tftables.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "rw.cpp||rw.cpp"
          ],
          "candidate": [
            "rw.cpp||rw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "rw.cpp||rw.cpp": [
          "File: rw.cpp -> rw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "202:  Integer re = modn.Square(r);",
          "203:  re = modn.Multiply(re, x);    // blind",
          "206:  Integer e, f;",
          "208:  const Integer U = modq.Exponentiate(h, (q+1)/8);",
          "",
          "[Removed Lines]",
          "205:  const Integer &h = re, &p = m_p, &q = m_q, &n = m_n;",
          "",
          "[Added Lines]",
          "205:  const Integer &h = re, &p = m_p, &q = m_q;",
          "",
          "---------------"
        ],
        "shark.cpp||shark.cpp": [
          "File: shark.cpp -> shark.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"modes.h\"",
          "7: #include \"gf256.h\"",
          "9: NAMESPACE_BEGIN(CryptoPP)",
          "11: static word64 SHARKTransform(word64 a)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #if GCC_DIAGNOSTIC_AWARE",
          "10: # pragma GCC diagnostic ignored \"-Wmissing-braces\"",
          "11: #endif",
          "",
          "---------------"
        ],
        "sharkbox.cpp||sharkbox.cpp": [
          "File: sharkbox.cpp -> sharkbox.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"pch.h\"",
          "2: #include \"shark.h\"",
          "4: NAMESPACE_BEGIN(CryptoPP)",
          "6: const byte SHARK::Enc::sbox[256] = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #if GCC_DIAGNOSTIC_AWARE",
          "5: # pragma GCC diagnostic ignored \"-Wmissing-braces\"",
          "6: #endif",
          "",
          "---------------"
        ],
        "square.cpp||square.cpp": [
          "File: square.cpp -> square.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"misc.h\"",
          "7: #include \"gf256.h\"",
          "9: NAMESPACE_BEGIN(CryptoPP)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #if GCC_DIAGNOSTIC_AWARE",
          "10: # pragma GCC diagnostic ignored \"-Wmissing-braces\"",
          "11: #endif",
          "",
          "---------------"
        ],
        "tftables.cpp||tftables.cpp": [
          "File: tftables.cpp -> tftables.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"pch.h\"",
          "4: #include \"twofish.h\"",
          "6: NAMESPACE_BEGIN(CryptoPP)",
          "8: const byte Twofish::Base::q[2][256] = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #if GCC_DIAGNOSTIC_AWARE",
          "7: # pragma GCC diagnostic ignored \"-Wmissing-braces\"",
          "8: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "79c934859977729cd33227024f7d25ad8d1fdd6a",
      "candidate_info": {
        "commit_hash": "79c934859977729cd33227024f7d25ad8d1fdd6a",
        "repo": "weidai11/cryptopp",
        "commit_url": "https://github.com/weidai11/cryptopp/commit/79c934859977729cd33227024f7d25ad8d1fdd6a",
        "files": [
          "rw.cpp"
        ],
        "message": "Fixed spelling error in attribution",
        "before_after_code_files": [
          "rw.cpp||rw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "rw.cpp||rw.cpp"
          ],
          "candidate": [
            "rw.cpp||rw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "rw.cpp||rw.cpp": [
          "File: rw.cpp -> rw.cpp"
        ]
      }
    },
    {
      "candidate_hash": "77206baf56e6feb111f54678038307ac216128d5",
      "candidate_info": {
        "commit_hash": "77206baf56e6feb111f54678038307ac216128d5",
        "repo": "weidai11/cryptopp",
        "commit_url": "https://github.com/weidai11/cryptopp/commit/77206baf56e6feb111f54678038307ac216128d5",
        "files": [
          "algparam.h",
          "cryptlib.h",
          "gzip.cpp",
          "hkdf.h",
          "ida.cpp",
          "iterhash.cpp",
          "misc.h",
          "modes.cpp",
          "oaep.cpp",
          "osrng.cpp",
          "pssr.cpp",
          "queue.cpp",
          "rw.cpp",
          "smartptr.h",
          "trap.h",
          "validat0.cpp",
          "zdeflate.cpp"
        ],
        "message": "Whitespace checkin",
        "before_after_code_files": [
          "algparam.h||algparam.h",
          "cryptlib.h||cryptlib.h",
          "gzip.cpp||gzip.cpp",
          "hkdf.h||hkdf.h",
          "ida.cpp||ida.cpp",
          "iterhash.cpp||iterhash.cpp",
          "misc.h||misc.h",
          "modes.cpp||modes.cpp",
          "oaep.cpp||oaep.cpp",
          "osrng.cpp||osrng.cpp",
          "pssr.cpp||pssr.cpp",
          "queue.cpp||queue.cpp",
          "rw.cpp||rw.cpp",
          "smartptr.h||smartptr.h",
          "trap.h||trap.h",
          "validat0.cpp||validat0.cpp",
          "zdeflate.cpp||zdeflate.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "rw.cpp||rw.cpp"
          ],
          "candidate": [
            "rw.cpp||rw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "algparam.h||algparam.h": [
          "File: algparam.h -> algparam.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:   if (!m_done)",
          "192:   {",
          "193:    R value;",
          "195:     throw InvalidArgument(std::string(typeid(T).name()) + \": Missing required parameter '\" + name + \"'\");",
          "196:    (m_pObject->*pm)(value);",
          "197:   }",
          "",
          "[Removed Lines]",
          "194:    if(!m_source.GetValue(name, value))",
          "",
          "[Added Lines]",
          "194:    if (!m_source.GetValue(name, value))",
          "",
          "---------------"
        ],
        "cryptlib.h||cryptlib.h": [
          "File: cryptlib.h -> cryptlib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:  CRYPTOPP_DLL bool GetAsUIntValue(const char *name, unsigned int &value) const",
          "300:  {",
          "301:   int v;",
          "303:   value = static_cast<unsigned int>(v);",
          "304:   return true;",
          "305:  }",
          "",
          "[Removed Lines]",
          "302:   if(!GetValue(name, v) || v < 0) return false;",
          "",
          "[Added Lines]",
          "302:   if (!GetValue(name, v) || v < 0) return false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "314:  CRYPTOPP_DLL unsigned int GetAsUIntValueWithDefault(const char *name, unsigned int defaultValue) const",
          "315:  {",
          "316:   int v;",
          "318:   return static_cast<unsigned int>(v);",
          "319:  }",
          "",
          "[Removed Lines]",
          "317:   if(!GetValue(name, v) || v < 0) return defaultValue;",
          "",
          "[Added Lines]",
          "317:   if (!GetValue(name, v) || v < 0) return defaultValue;",
          "",
          "---------------"
        ],
        "gzip.cpp||gzip.cpp": [
          "File: gzip.cpp -> gzip.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:  if (flags & FILENAME) // skip filename",
          "67:   do",
          "69:   while (b);",
          "71:  if (flags & COMMENTS) // skip comments",
          "72:   do",
          "74:   while (b);",
          "75: }",
          "",
          "[Removed Lines]",
          "68:    if(!m_inQueue.Get(b)) throw HeaderErr();",
          "73:    if(!m_inQueue.Get(b)) throw HeaderErr();",
          "",
          "[Added Lines]",
          "68:    if (!m_inQueue.Get(b)) throw HeaderErr();",
          "73:    if (!m_inQueue.Get(b)) throw HeaderErr();",
          "",
          "---------------"
        ],
        "hkdf.h||hkdf.h": [
          "File: hkdf.h -> hkdf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  CRYPTOPP_ASSERT(derived && derivedLen);",
          "56:  CRYPTOPP_ASSERT(derivedLen <= MaxDerivedKeyLength());",
          "59:   throw InvalidArgument(\"HKDF: derivedLen must be less than or equal to MaxDerivedKeyLength\");",
          "61:  HMAC<T> hmac;",
          "",
          "[Removed Lines]",
          "58:  if(derivedLen > MaxDerivedKeyLength())",
          "",
          "[Added Lines]",
          "58:  if (derivedLen > MaxDerivedKeyLength())",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:  while (derivedLen > 0)",
          "76:  {",
          "79:   hmac.CalculateDigest(buffer, &block, 1);",
          "81:   size_t segmentLen = STDMIN(derivedLen, DIGEST_SIZE);",
          "",
          "[Removed Lines]",
          "77:   if(block++) {hmac.Update(buffer, buffer.size());}",
          "78:   if(context && contextLen) {hmac.Update(context, contextLen);}",
          "",
          "[Added Lines]",
          "77:   if (block++) {hmac.Update(buffer, buffer.size());}",
          "78:   if (context && contextLen) {hmac.Update(context, contextLen);}",
          "",
          "---------------"
        ],
        "ida.cpp||ida.cpp": [
          "File: ida.cpp -> ida.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "381:  if (m_possiblePadding)",
          "382:  {",
          "384:   m_zeroCount += len;",
          "385:   begin += len;",
          "386:   if (begin == end)",
          "",
          "[Removed Lines]",
          "383:   size_t len = find_if(begin, end, bind2nd(not_equal_to<byte>(), byte(0))) - begin;",
          "",
          "[Added Lines]",
          "383:   size_t len = find_if (begin, end, bind2nd(not_equal_to<byte>(), byte(0))) - begin;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "401: #else",
          "402:  typedef reverse_iterator<const byte *> RevIt;",
          "403: #endif",
          "405:  if (x != begin && *(x-1) == 1)",
          "406:  {",
          "407:   AttachedTransformation()->Put(begin, x-begin-1);",
          "",
          "[Removed Lines]",
          "404:  const byte *x = find_if(RevIt(end), RevIt(begin), bind2nd(not_equal_to<byte>(), byte(0))).base();",
          "",
          "[Added Lines]",
          "404:  const byte *x = find_if (RevIt(end), RevIt(begin), bind2nd(not_equal_to<byte>(), byte(0))).base();",
          "",
          "---------------"
        ],
        "iterhash.cpp||iterhash.cpp": [
          "File: iterhash.cpp -> iterhash.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:  {",
          "29:   if (num+len >= blockSize)",
          "30:   {",
          "32:     memcpy(data+num, input, blockSize-num);",
          "34:    HashBlock(dataBuf);",
          "",
          "[Removed Lines]",
          "31:    if(data && input)",
          "",
          "[Added Lines]",
          "31:    if (data && input)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39:   }",
          "40:   else",
          "41:   {",
          "43:     memcpy(data+num, input, len);",
          "45:    return;",
          "",
          "[Removed Lines]",
          "42:    if(data && input)",
          "",
          "[Added Lines]",
          "42:    if (data && input)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:   else",
          "65:    do",
          "66:    {   // copy input first if it's not aligned correctly",
          "68:      memcpy(data, input, blockSize);",
          "70:     HashBlock(dataBuf);",
          "",
          "[Removed Lines]",
          "67:     if(data && input)",
          "",
          "[Added Lines]",
          "67:     if (data && input)",
          "",
          "---------------"
        ],
        "misc.h||misc.h": [
          "File: misc.h -> misc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "209:   memcpy(dest, src, count);",
          "210: }",
          "",
          "[Removed Lines]",
          "208:  if(dest && src && count)",
          "",
          "[Added Lines]",
          "208:  if (dest && src && count)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:   memmove(dest, src, count);",
          "224: }",
          "",
          "[Removed Lines]",
          "222:  if(dest && src && count)",
          "",
          "[Added Lines]",
          "222:  if (dest && src && count)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "237:  if (__builtin_constant_p(num) && num==0)",
          "238:   return ptr;",
          "239: #endif",
          "242:  return memset(ptr, value, num);",
          "243: }",
          "",
          "[Removed Lines]",
          "240:  if(!ptr) return NULL;",
          "241:  if(!num) return ptr;",
          "",
          "[Added Lines]",
          "240:  if (!ptr) return NULL;",
          "241:  if (!num) return ptr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1532:  T t1, t2 = 0;",
          "1533:  t1 = ConditionalByteReverse(order, value);",
          "1535:  memmove(block, &(t1 ^= t2), sizeof(T));",
          "1536: }",
          "",
          "[Removed Lines]",
          "1534:  if(xorBlock) memmove(&t2, xorBlock, sizeof(T));",
          "",
          "[Added Lines]",
          "1534:  if (xorBlock) memmove(&t2, xorBlock, sizeof(T));",
          "",
          "---------------"
        ],
        "modes.cpp||modes.cpp": [
          "File: modes.cpp -> modes.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:  m_cipher->ProcessBlock(m_register, m_temp);",
          "53:  const unsigned int updateSize = BlockSize()-m_feedbackSize;",
          "56:   memmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);",
          "57:  memcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);",
          "58: }",
          "",
          "[Removed Lines]",
          "55:  if(updateSize)",
          "",
          "[Added Lines]",
          "55:  if (updateSize)",
          "",
          "---------------"
        ],
        "oaep.cpp||oaep.cpp": [
          "File: oaep.cpp -> oaep.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  byte *M = std::find(maskedDB+hLen, maskedDB+dbLen, 0x01);",
          "89:  invalid = (M == maskedDB+dbLen) || invalid;",
          "91:  invalid = !pHash->VerifyDigest(maskedDB, encodingParameters.begin(), encodingParameters.size()) || invalid;",
          "93:  if (invalid)",
          "",
          "[Removed Lines]",
          "90:  invalid = (std::find_if(maskedDB+hLen, M, std::bind2nd(std::not_equal_to<byte>(), byte(0))) != M) || invalid;",
          "",
          "[Added Lines]",
          "90:  invalid = (std::find_if (maskedDB+hLen, M, std::bind2nd(std::not_equal_to<byte>(), byte(0))) != M) || invalid;",
          "",
          "---------------"
        ],
        "osrng.cpp||osrng.cpp": [
          "File: osrng.cpp -> osrng.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: MicrosoftCryptoProvider::MicrosoftCryptoProvider()",
          "49: {",
          "51:   throw OS_RNG_Err(\"CryptAcquireContext\");",
          "52: }",
          "",
          "[Removed Lines]",
          "50:  if(!CryptAcquireContext(&m_hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))",
          "",
          "[Added Lines]",
          "50:  if (!CryptAcquireContext(&m_hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))",
          "",
          "---------------"
        ],
        "pssr.cpp||pssr.cpp": [
          "File: pssr.cpp -> pssr.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:  xorbuf(xorStart + 1, recoverableMessage, recoverableMessageLength);",
          "79:  xorbuf(xorStart + 1 + recoverableMessageLength, salt, salt.size());",
          "82:   memcpy(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second);",
          "83:     representative[representativeByteLength - 1] = hashIdentifier.second ? 0xcc : 0xbc;",
          "",
          "[Removed Lines]",
          "81:  if(representative && hashIdentifier.first)",
          "",
          "[Added Lines]",
          "81:  if (representative && hashIdentifier.first)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "117:  byte *salt = representative + representativeByteLength - u - digestSize - saltSize;",
          "119:  recoverableMessageLength = salt-M-1;",
          "120:  if (*M == 0x01",
          "121:   && (size_t)(M - representative - (representativeBitLength % 8 != 0)) >= MinPadLen(digestSize)",
          "122:   && recoverableMessageLength <= MaxRecoverableLength(representativeBitLength, hashIdentifier.second, digestSize))",
          "123:  {",
          "125:    memcpy(recoverableMessage, M+1, recoverableMessageLength);",
          "126:  }",
          "127:  else",
          "",
          "[Removed Lines]",
          "118:  byte *M = std::find_if(representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), byte(0)));",
          "124:   if(recoverableMessage && M && recoverableMessageLength)",
          "",
          "[Added Lines]",
          "118:  byte *M = std::find_if (representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), byte(0)));",
          "124:   if (recoverableMessage && M && recoverableMessageLength)",
          "",
          "---------------"
        ],
        "queue.cpp||queue.cpp": [
          "File: queue.cpp -> queue.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:  inline size_t Put(const byte *begin, size_t length)",
          "44:  {",
          "46:   size_t l = STDMIN(length, MaxSize()-m_tail);",
          "47:   if (buf+m_tail != begin)",
          "48:    memcpy(buf+m_tail, begin, l);",
          "",
          "[Removed Lines]",
          "45:   if(!begin || !length) return length;",
          "",
          "[Added Lines]",
          "45:   if (!begin || !length) return length;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:  inline size_t Peek(byte *target, size_t copyMax) const",
          "63:  {",
          "65:   size_t len = STDMIN(copyMax, m_tail-m_head);",
          "66:   memcpy(target, buf+m_head, len);",
          "67:   return len;",
          "",
          "[Removed Lines]",
          "64:   if(!target || !copyMax) return 0;",
          "",
          "[Added Lines]",
          "64:   if (!target || !copyMax) return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "429: ByteQueue & ByteQueue::operator=(const ByteQueue &rhs)",
          "430: {",
          "433:  Destroy();",
          "434:  CopyFrom(rhs);",
          "",
          "[Removed Lines]",
          "431:  if(this == &rhs) return *this;",
          "",
          "[Added Lines]",
          "431:  if (this == &rhs) return *this;",
          "",
          "---------------"
        ],
        "rw.cpp||rw.cpp": [
          "File: rw.cpp -> rw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "124: {",
          "125:  ModularArithmetic modp(m_p), modq(m_q);",
          "128:  {",
          "129:   #pragma omp section",
          "130:    m_pre_2_9p = modp.Exponentiate(2, (9 * m_p - 11)/8);",
          "",
          "[Removed Lines]",
          "127:  #pragma omp parallel sections if(CRYPTOPP_RW_USE_OMP)",
          "",
          "[Added Lines]",
          "127:  #pragma omp parallel sections if (CRYPTOPP_RW_USE_OMP)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151: void InvertibleRWFunction::SavePrecomputation(BufferedTransformation &bt) const",
          "152: {",
          "154:   Precompute();",
          "156:  DERSequenceEncoder seq(bt);",
          "",
          "[Removed Lines]",
          "153:  if(!m_precompute)",
          "",
          "[Added Lines]",
          "153:  if (!m_precompute)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "187: {",
          "188:  DoQuickSanityCheck();",
          "191:   Precompute();",
          "193:  ModularArithmetic modn(m_n), modp(m_p), modq(m_q);",
          "",
          "[Removed Lines]",
          "190:  if(!m_precompute)",
          "",
          "[Added Lines]",
          "190:  if (!m_precompute)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "210:  Integer e, f;",
          "212:  const Integer U = modq.Exponentiate(h, (q+1)/8);",
          "214:   e = Integer::One();",
          "215:  else",
          "216:   e = -1;",
          "218:  const Integer eh = e*h, V = modp.Exponentiate(eh, (p-3)/8);",
          "220:   f = Integer::One();",
          "221:  else",
          "222:   f = 2;",
          "224:  Integer W, X;",
          "226:  {",
          "227:   #pragma omp section",
          "228:   {",
          "",
          "[Removed Lines]",
          "213:  if(((modq.Exponentiate(U, 4) - h) % q).IsZero())",
          "219:  if(((modp.Multiply(modp.Exponentiate(V, 4), modp.Exponentiate(eh, 2)) - eh) % p).IsZero())",
          "225:  #pragma omp parallel sections if(CRYPTOPP_RW_USE_OMP)",
          "",
          "[Added Lines]",
          "213:  if (((modq.Exponentiate(U, 4) - h) % q).IsZero())",
          "219:  if (((modp.Multiply(modp.Exponentiate(V, 4), modp.Exponentiate(eh, 2)) - eh) % p).IsZero())",
          "225:  #pragma omp parallel sections if (CRYPTOPP_RW_USE_OMP)",
          "",
          "---------------"
        ],
        "smartptr.h||smartptr.h": [
          "File: smartptr.h -> smartptr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "115: template <class T> value_ptr<T>& value_ptr<T>::operator=(const value_ptr<T>& rhs)",
          "116: {",
          "118:  {",
          "119:   T *old_p = this->m_p;",
          "120:   this->m_p = rhs.m_p ? new T(*rhs.m_p) : NULL;",
          "",
          "[Removed Lines]",
          "117:  if(this != &rhs)",
          "",
          "[Added Lines]",
          "117:  if (this != &rhs)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139: template <class T> clonable_ptr<T>& clonable_ptr<T>::operator=(const clonable_ptr<T>& rhs)",
          "140: {",
          "142:  {",
          "143:   T *old_p = this->m_p;",
          "144:   this->m_p = rhs.m_p ? rhs.m_p->Clone() : NULL;",
          "",
          "[Removed Lines]",
          "141:  if(this !=  &rhs)",
          "",
          "[Added Lines]",
          "141:  if (this !=  &rhs)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226: template <class T> counted_ptr<T> & counted_ptr<T>::operator=(const counted_ptr<T>& rhs)",
          "227: {",
          "230:  if (m_p != rhs.m_p)",
          "231:  {",
          "",
          "[Removed Lines]",
          "228:  if(this == &rhs) { return *this; }",
          "",
          "[Added Lines]",
          "228:  if (this == &rhs) { return *this; }",
          "",
          "---------------"
        ],
        "trap.h||trap.h": [
          "File: trap.h -> trap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #if !defined(NDEBUG) && defined(CRYPTOPP_UNIX_AVAILABLE)",
          "25: #  define CRYPTOPP_ASSERT(exp) {                                  \\",
          "27:       std::ostringstream oss;                                     \\",
          "28:       oss << \"Assertion failed: \" << (char*)(__FILE__) << \"(\"     \\",
          "29:           << (int)(__LINE__) << \"): \" << (char*)(__func__)        \\",
          "",
          "[Removed Lines]",
          "26:     if(!(exp)) {                                                  \\",
          "",
          "[Added Lines]",
          "26:     if (!(exp)) {                                                  \\",
          "",
          "---------------"
        ],
        "validat0.cpp||validat0.cpp": [
          "File: validat0.cpp -> validat0.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "337:   signed int v; bool p = true;",
          "338:   {",
          "341:    {",
          "342:     signed long v1 = std::numeric_limits<signed long>::min(); p = !SafeConvert(v1, v) && p;",
          "343:     signed long v2 = std::numeric_limits<signed long>::max(); p = !SafeConvert(v2, v) && p;",
          "344:     unsigned long v3 = std::numeric_limits<unsigned long>::max(); p = !SafeConvert(v3, v) && p;",
          "345:    }",
          "348:    {",
          "349:     signed long long v1 = std::numeric_limits<signed long long>::min(); p = !SafeConvert(v1, v) && p;",
          "350:     signed long long v2 = std::numeric_limits<signed long long>::max(); p = !SafeConvert(v2, v) && p;",
          "",
          "[Removed Lines]",
          "340:    if(sizeof(signed int) != sizeof(signed long))",
          "347:    if(sizeof(signed int) != sizeof(signed long long))",
          "",
          "[Added Lines]",
          "340:    if (sizeof(signed int) != sizeof(signed long))",
          "347:    if (sizeof(signed int) != sizeof(signed long long))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "373:   unsigned int v; bool p = true;",
          "374:   {",
          "377:    {",
          "378:     unsigned long v1 = std::numeric_limits<unsigned long>::max(); p = !SafeConvert(v1, v) && p;",
          "379:    }",
          "382:    {",
          "383:     unsigned long long v1 = std::numeric_limits<unsigned long long>::max(); p = !SafeConvert(v1, v) && p;",
          "384:    }",
          "",
          "[Removed Lines]",
          "376:    if(sizeof(unsigned int) != sizeof(unsigned long))",
          "381:    if(sizeof(unsigned int) != sizeof(unsigned long long))",
          "",
          "[Added Lines]",
          "376:    if (sizeof(unsigned int) != sizeof(unsigned long))",
          "381:    if (sizeof(unsigned int) != sizeof(unsigned long long))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "407:  {",
          "410:   {",
          "411:    signed long v; bool p = true;",
          "412:    {",
          "",
          "[Removed Lines]",
          "409:   if(sizeof(signed long) != sizeof(signed long long))",
          "",
          "[Added Lines]",
          "409:   if (sizeof(signed long) != sizeof(signed long long))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "440:  {",
          "443:   {",
          "444:    unsigned long v; bool p = true;",
          "445:    {",
          "",
          "[Removed Lines]",
          "442:   if(sizeof(unsigned long) != sizeof(unsigned long long))",
          "",
          "[Added Lines]",
          "442:   if (sizeof(unsigned long) != sizeof(unsigned long long))",
          "",
          "---------------"
        ],
        "zdeflate.cpp||zdeflate.cpp": [
          "File: zdeflate.cpp -> zdeflate.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "668:    m_literalCounts[256] = 1;",
          "669:    HuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);",
          "670:    m_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);",
          "673:    HuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);",
          "674:    m_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);",
          "677:    SecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);",
          "678:    memcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));",
          "",
          "[Removed Lines]",
          "671:    unsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));",
          "675:    unsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));",
          "",
          "[Added Lines]",
          "671:    unsigned int hlit = (unsigned int)(find_if (RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));",
          "675:    unsigned int hdist = (unsigned int)(find_if (RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b2820c28d3bda5fcffb799598a45466772c4b559",
      "candidate_info": {
        "commit_hash": "b2820c28d3bda5fcffb799598a45466772c4b559",
        "repo": "weidai11/cryptopp",
        "commit_url": "https://github.com/weidai11/cryptopp/commit/b2820c28d3bda5fcffb799598a45466772c4b559",
        "files": [
          "rw.cpp"
        ],
        "message": "Fixed spelling error in attribution",
        "before_after_code_files": [
          "rw.cpp||rw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "rw.cpp||rw.cpp"
          ],
          "candidate": [
            "rw.cpp||rw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "rw.cpp||rw.cpp": [
          "File: rw.cpp -> rw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:   r.Randomize(rng, Integer::One(), m_n - Integer::One());",
          "198:   r = modn.Square(r);",
          "199:   rInv = modn.MultiplicativeInverse(r);",
          "202:  Integer re = modn.Square(r);",
          "203:  re = modn.Multiply(re, x);    // blind",
          "",
          "[Removed Lines]",
          "200:  } while(rInv.IsZero());",
          "",
          "[Added Lines]",
          "200:  } while (rInv.IsZero());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "260810ce63aa01bc02240aa7602dd90e258f7b51",
      "candidate_info": {
        "commit_hash": "260810ce63aa01bc02240aa7602dd90e258f7b51",
        "repo": "weidai11/cryptopp",
        "commit_url": "https://github.com/weidai11/cryptopp/commit/260810ce63aa01bc02240aa7602dd90e258f7b51",
        "files": [
          "rw.cpp",
          "rw.h"
        ],
        "message": "Implmented Bernstein\\'s Tweaked Roots for Rabin-Williams signatures. Thanks to Evgeny Sidorov for suggesting it",
        "before_after_code_files": [
          "rw.cpp||rw.cpp",
          "rw.h||rw.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "rw.cpp||rw.cpp"
          ],
          "candidate": [
            "rw.cpp||rw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "rw.cpp||rw.cpp": [
          "File: rw.cpp -> rw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include \"nbtheory.h\"",
          "6: #include \"asn.h\"",
          "8: #ifndef CRYPTOPP_IMPORTS",
          "10: NAMESPACE_BEGIN(CryptoPP)",
          "12: void RWFunction::BERDecode(BufferedTransformation &bt)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #ifndef NDEBUG",
          "9: # include <cassert>",
          "10: #endif",
          "14: static const bool CRYPTOPP_RW_USE_OMP = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:  m_n = m_p * m_q;",
          "101:  m_u = m_q.InverseMod(m_p);",
          "102: }",
          "104: void InvertibleRWFunction::BERDecode(BufferedTransformation &bt)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109:  Precompute();",
          "110: }",
          "112: void InvertibleRWFunction::Initialize(const Integer &n, const Integer &p, const Integer &q, const Integer &u)",
          "113: {",
          "114:  m_n = n; m_p = p; m_q = q; m_u = u;",
          "116:  Precompute();",
          "117: }",
          "119: void InvertibleRWFunction::PrecomputeTweakedRoots() const",
          "120: {",
          "121:  ModularArithmetic modp(m_p), modq(m_q);",
          "123:  #pragma omp parallel sections if(CRYPTOPP_RW_USE_OMP)",
          "124:  {",
          "125:   #pragma omp section",
          "126:    m_pre_2_9p = modp.Exponentiate(2, (9 * m_p - 11)/8);",
          "127:   #pragma omp section",
          "128:    m_pre_2_3q = modq.Exponentiate(2, (3 * m_q - 5)/8);",
          "129:   #pragma omp section",
          "130:    m_pre_q_p = modp.Exponentiate(m_q, m_p - 2);",
          "131:  }",
          "133:  m_precompute = true;",
          "134: }",
          "136: void InvertibleRWFunction::LoadPrecomputation(BufferedTransformation &bt)",
          "137: {",
          "138:  BERSequenceDecoder seq(bt);",
          "139:  m_pre_2_9p.BERDecode(seq);",
          "140:  m_pre_2_3q.BERDecode(seq);",
          "141:  m_pre_q_p.BERDecode(seq);",
          "142:  seq.MessageEnd();",
          "144:  m_precompute = true;",
          "145: }",
          "147: void InvertibleRWFunction::SavePrecomputation(BufferedTransformation &bt) const",
          "148: {",
          "149:  if(!m_precompute)",
          "150:   Precompute();",
          "152:  DERSequenceEncoder seq(bt);",
          "153:  m_pre_2_9p.DEREncode(seq);",
          "154:  m_pre_2_3q.DEREncode(seq);",
          "155:  m_pre_q_p.DEREncode(seq);",
          "156:  seq.MessageEnd();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:  m_q.BERDecode(seq);",
          "110:  m_u.BERDecode(seq);",
          "111:  seq.MessageEnd();",
          "112: }",
          "114: void InvertibleRWFunction::DEREncode(BufferedTransformation &bt) const",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:  m_precompute = false;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "121:  seq.MessageEnd();",
          "122: }",
          "124: Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const",
          "125: {",
          "126:  DoQuickSanityCheck();",
          "128:  Integer r, rInv;",
          "132:   r.Randomize(rng, Integer::One(), m_n - Integer::One());",
          "135:   r = modn.Square(r);",
          "136:   rInv = modn.MultiplicativeInverse(r);",
          "139:  Integer re = modn.Square(r);",
          "151:   {",
          "156:   }",
          "162:   throw Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");",
          "164: }",
          "166: bool InvertibleRWFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const",
          "",
          "[Removed Lines]",
          "127:  ModularArithmetic modn(m_n);",
          "131:  do {",
          "137:  } while (rInv.IsZero());",
          "140:  re = modn.Multiply(re, x);   // blind",
          "142:  Integer cp=re%m_p, cq=re%m_q;",
          "143:  if (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)",
          "144:  {",
          "145:   cp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;",
          "146:   cq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;",
          "147:  }",
          "149:  #pragma omp parallel",
          "150:   #pragma omp sections",
          "152:    #pragma omp section",
          "153:     cp = ModularSquareRoot(cp, m_p);",
          "154:    #pragma omp section",
          "155:     cq = ModularSquareRoot(cq, m_q);",
          "158:  Integer y = CRT(cq, m_q, cp, m_p, m_u);",
          "159:  y = modn.Multiply(y, rInv);    // unblind",
          "160:  y = STDMIN(y, m_n-y);",
          "161:  if (ApplyFunction(y) != x)    // check",
          "163:  return y;",
          "",
          "[Added Lines]",
          "186:  if(!m_precompute)",
          "187:   Precompute();",
          "189:  ModularArithmetic modn(m_n), modp(m_p), modq(m_q);",
          "192:  do",
          "193:  {",
          "200:  } while(rInv.IsZero());",
          "203:  re = modn.Multiply(re, x);    // blind",
          "205:  const Integer &h = re, &p = m_p, &q = m_q, &n = m_n;",
          "206:  Integer e, f;",
          "208:  const Integer U = modq.Exponentiate(h, (q+1)/8);",
          "209:  if(((modq.Exponentiate(U, 4) - h) % q).IsZero())",
          "210:   e = Integer::One();",
          "211:  else",
          "212:   e = -1;",
          "214:  const Integer eh = e*h, V = modp.Exponentiate(eh, (p-3)/8);",
          "215:  if(((modp.Multiply(modp.Exponentiate(V, 4), modp.Exponentiate(eh, 2)) - eh) % p).IsZero())",
          "216:   f = Integer::One();",
          "217:  else",
          "218:   f = 2;",
          "220:  Integer W, X;",
          "221:  #pragma omp parallel sections if(CRYPTOPP_RW_USE_OMP)",
          "222:  {",
          "223:   #pragma omp section",
          "224:   {",
          "225:    W = (f.IsUnit() ? U : modq.Multiply(m_pre_2_3q, U));",
          "226:   }",
          "227:   #pragma omp section",
          "229:    const Integer t = modp.Multiply(modp.Exponentiate(V, 3), eh);",
          "230:    X = (f.IsUnit() ? t : modp.Multiply(m_pre_2_9p, t));",
          "232:  }",
          "233:  const Integer Y = W + q * modp.Multiply(m_pre_q_p, (X - W));",
          "236:  Integer s = modn.Multiply(modn.Square(Y), rInv);",
          "237:  assert((e * f * s.Squared()) % m_n == x);",
          "240:  s = STDMIN(s, m_n - s);",
          "241:  if (ApplyFunction(s) != x)                      // check",
          "244:  return s;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "195:   CRYPTOPP_SET_FUNCTION_ENTRY(Prime2)",
          "196:   CRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)",
          "197:   ;",
          "198: }",
          "200: NAMESPACE_END",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "280:  m_precompute = false;",
          "",
          "---------------"
        ],
        "rw.h||rw.h": [
          "File: rw.h -> rw.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  typedef InvertibleRWFunction ThisClass;",
          "50: public:",
          "54:  void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)",
          "55:   {GenerateRandomWithKeySize(rng, modulusBits);}",
          "",
          "[Removed Lines]",
          "51:  void Initialize(const Integer &n, const Integer &p, const Integer &q, const Integer &u)",
          "52:   {m_n = n; m_p = p; m_q = q; m_u = u;}",
          "",
          "[Added Lines]",
          "51:  InvertibleRWFunction() : m_precompute(false) {}",
          "53:  void Initialize(const Integer &n, const Integer &p, const Integer &q, const Integer &u);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:  void SetPrime2(const Integer &q) {m_q = q;}",
          "80:  void SetMultiplicativeInverseOfPrime2ModPrime1(const Integer &u) {m_u = u;}",
          "82: protected:",
          "83:  Integer m_p, m_q, m_u;",
          "84: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:  virtual bool SupportsPrecomputation() const {return true;}",
          "84:  virtual void Precompute(unsigned int unused = 0) {PrecomputeTweakedRoots();}",
          "85:  virtual void Precompute(unsigned int unused = 0) const {PrecomputeTweakedRoots();}",
          "87:  virtual void LoadPrecomputation(BufferedTransformation &storedPrecomputation);",
          "88:  virtual void SavePrecomputation(BufferedTransformation &storedPrecomputation) const;",
          "90: protected:",
          "91:  void PrecomputeTweakedRoots() const;",
          "96:  mutable Integer m_pre_2_9p, m_pre_2_3q, m_pre_q_p;",
          "97:  mutable bool m_precompute;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ec206a7d34c7fc36c71087d0eb3ac9cb8cb4a59b",
      "candidate_info": {
        "commit_hash": "ec206a7d34c7fc36c71087d0eb3ac9cb8cb4a59b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ec206a7d34c7fc36c71087d0eb3ac9cb8cb4a59b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/wal.c"
        ],
        "message": "Use AtomicStore() to set values in the wal-index hash table.\n\nFossilOrigin-Name: 1ab30c75f2fe14d1ee77d0eace4e29ba8f805d63e2da0897b111ea1311f409aa",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/wal.c||src/wal.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 3c2bf8042ec46195c67dfd91df084f5bc19162fd26389920e716b310c80deea6",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/wal.c||src/wal.c": [
          "File: src/wal.c -> src/wal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1096:       if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;",
          "1097:     }",
          "1098:     sLoc.aPgno[idx] = iPage;",
          "1101: #ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT",
          "",
          "[Removed Lines]",
          "1099:     sLoc.aHash[iKey] = (ht_slot)idx;",
          "",
          "[Added Lines]",
          "1099:     AtomicStore(&sLoc.aHash[iKey], (ht_slot)idx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f2972b6083aef8bd57c2e1ff60d357c5b1ff7f88",
      "candidate_info": {
        "commit_hash": "f2972b6083aef8bd57c2e1ff60d357c5b1ff7f88",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f2972b6083aef8bd57c2e1ff60d357c5b1ff7f88",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/resolve.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/update.c",
          "test/upfrom2.test"
        ],
        "message": "Fix problems with using LIMIT and FROM clauses as part of single UPDATE statement.\n\nFossilOrigin-Name: b717dc3c5fafb9b86a141e7ecffc030fd9b36aa57a0b3e5200d64ad23a0aa13d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/resolve.c||src/resolve.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c",
          "test/upfrom2.test||test/upfrom2.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 823ba94e29dece1687e28711e503a1f56d392c306b0cbc0a20548180834530d1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "756:     case TK_ROW: {",
          "757:       SrcList *pSrcList = pNC->pSrcList;",
          "758:       struct SrcList_item *pItem;",
          "760:       pItem = pSrcList->a;",
          "761:       assert( HasRowid(pItem->pTab) && pItem->pTab->pSelect==0 );",
          "762:       pExpr->op = TK_COLUMN;",
          "",
          "[Removed Lines]",
          "759:       assert( pSrcList && pSrcList->nSrc==1 );",
          "",
          "[Added Lines]",
          "759:       assert( pSrcList && pSrcList->nSrc>=1 );",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1006:       testcase( eDest==SRT_Coroutine );",
          "1007:       testcase( eDest==SRT_Output );",
          "1008:       assert( eDest==SRT_Set || eDest==SRT_Mem",
          "1010:     }",
          "1011:     sRowLoadInfo.regResult = regResult;",
          "1012:     sRowLoadInfo.ecelFlags = ecelFlags;",
          "",
          "[Removed Lines]",
          "1009:            || eDest==SRT_Coroutine || eDest==SRT_Output );",
          "",
          "[Added Lines]",
          "1009:            || eDest==SRT_Coroutine || eDest==SRT_Output",
          "1010:            || eDest==SRT_Upfrom );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1156:     }",
          "1158:     case SRT_Upfrom: {",
          "1165:       }else{",
          "1167:       }",
          "1168:       break;",
          "1169:     }",
          "",
          "[Removed Lines]",
          "1159:       assert( pSort==0 );",
          "1160:       int i2 = pDest->iSDParm2;",
          "1161:       int r1 = sqlite3GetTempReg(pParse);",
          "1162:       sqlite3VdbeAddOp3(v, OP_MakeRecord,regResult+(i2<0),nResultCol-(i2<0),r1);",
          "1163:       if( i2<0 ){",
          "1164:         sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);",
          "1166:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);",
          "",
          "[Added Lines]",
          "1160:       if( pSort ){",
          "1161:         pushOntoSorter(",
          "1162:             pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);",
          "1164:         int i2 = pDest->iSDParm2;",
          "1165:         int r1 = sqlite3GetTempReg(pParse);",
          "1166:         sqlite3VdbeAddOp3(v, OP_MakeRecord,regResult+(i2<0),nResultCol-(i2<0),r1);",
          "1167:         if( i2<0 ){",
          "1168:           sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);",
          "1169:         }else{",
          "1170:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);",
          "1171:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1600:       break;",
          "1601:     }",
          "1602: #endif",
          "1603:     default: {",
          "1604:       assert( eDest==SRT_Output || eDest==SRT_Coroutine );",
          "1605:       testcase( eDest==SRT_Output );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1608:     case SRT_Upfrom: {",
          "1609:       int i2 = pDest->iSDParm2;",
          "1610:       int r1 = sqlite3GetTempReg(pParse);",
          "1611:       sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);",
          "1612:       if( i2<0 ){",
          "1613:         sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);",
          "1614:       }else{",
          "1615:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);",
          "1616:       }",
          "1617:       break;",
          "1618:     }",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168: ){",
          "169:   int i;",
          "170:   sqlite3 *db = pParse->db;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:   ExprList *pOrderBy,",
          "169:   Expr *pLimit",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "174:   Table *pTab = pTabList->a[0].pTab;",
          "175:   SrcList *pSrc = sqlite3SrcListDup(db, pTabList, 0);",
          "176:   Expr *pWhere2 = sqlite3ExprDup(db, pWhere, 0);",
          "177:   int eDest;",
          "179:   assert( pTabList->nSrc>1 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "179:   Expr *pLimit2 = sqlite3ExprDup(db, pLimit, 0);",
          "180:   ExprList *pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);",
          "181:   ExprList *pGroupBy = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:   }",
          "185:   if( pPk ){",
          "186:     for(i=0; i<pPk->nKeyCol; i++){",
          "192:     }",
          "193:     eDest = SRT_Upfrom;",
          "194:   }else if( pTab->pSelect ){",
          "",
          "[Removed Lines]",
          "187:       pList = sqlite3ExprListAppend(pParse, pList,",
          "188:           sqlite3PExpr(pParse, TK_DOT,",
          "189:             sqlite3Expr(db, TK_ID, pTab->zName),",
          "190:             sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zName)",
          "191:       ));",
          "",
          "[Added Lines]",
          "192:       Expr *pNew = sqlite3PExpr(pParse, TK_DOT,",
          "193:           sqlite3Expr(db, TK_ID, pTab->zName),",
          "194:           sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zName)",
          "195:       );",
          "196:       if( pLimit ){",
          "197:         pGroupBy = sqlite3ExprListAppend(pParse, pGroupBy,",
          "198:             sqlite3ExprDup(db, pNew, 0)",
          "199:         );",
          "200:       }",
          "201:       pList = sqlite3ExprListAppend(pParse, pList, pNew);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:     ));",
          "200:     eDest = SRT_Table;",
          "201:   }else{",
          "207:     eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;",
          "208:   }",
          "209:   for(i=0; i<pChanges->nExpr; i++){",
          "210:     pList = sqlite3ExprListAppend(pParse, pList,",
          "211:         sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)",
          "212:     );",
          "213:   }",
          "215:   sqlite3SelectDestInit(&dest, eDest, iEph);",
          "216:   dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);",
          "217:   sqlite3Select(pParse, pSelect, &dest);",
          "",
          "[Removed Lines]",
          "202:     pList = sqlite3ExprListAppend(pParse, pList,",
          "203:         sqlite3PExpr(pParse, TK_DOT,",
          "204:           sqlite3Expr(db, TK_ID, pTab->zName),",
          "205:           sqlite3Expr(db, TK_ID, \"_rowid_\")",
          "206:     ));",
          "214:   pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, 0, 0, 0, 0, 0);",
          "",
          "[Added Lines]",
          "213:     pList = sqlite3ExprListAppend(pParse, pList,",
          "214:         sqlite3PExpr(pParse, TK_ROW, 0, 0)",
          "215:     );",
          "216:     if( pLimit ){",
          "217:       pGroupBy = sqlite3ExprListAppend(pParse, pGroupBy,",
          "218:           sqlite3PExpr(pParse, TK_ROW, 0, 0)",
          "219:       );",
          "220:     }",
          "227:   pSelect = sqlite3SelectNew(",
          "228:       pParse, pList, pSrc, pWhere2, pGroupBy, 0, pOrderBy2, 0, pLimit2",
          "229:   );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "323:   assert( nChangeFrom==0 || pUpsert==0 );",
          "325: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "327:     pWhere = sqlite3LimitWhere(",
          "328:         pParse, pTabList, pWhere, pOrderBy, pLimit, \"UPDATE\"",
          "329:     );",
          "",
          "[Removed Lines]",
          "326:   if( !isView ){",
          "",
          "[Added Lines]",
          "341:   if( !isView && nChangeFrom==0 ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "608:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);",
          "609:       if( pPk ) sqlite3VdbeSetP4KeyInfo(pParse, pPk);",
          "610:       if( nChangeFrom ){",
          "612: #ifndef SQLITE_OMIT_SUBQUERY",
          "613:         if( isView ) iDataCur = iEph;",
          "614: #endif",
          "",
          "[Removed Lines]",
          "611:         updatePopulateEphTable(pParse, iEph, pPk, pChanges, pTabList, pWhere);",
          "",
          "[Added Lines]",
          "626:         updatePopulateEphTable(",
          "627:             pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit",
          "628:         );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1148:       }",
          "1149:     }",
          "1152:     sqlite3ExprListDelete(db, pList);",
          "1153:     eOnePass = ONEPASS_OFF;",
          "1154:   }else{",
          "",
          "[Removed Lines]",
          "1151:     updatePopulateEphTable(pParse, ephemTab, 0, pList, pSrc, pWhere);",
          "",
          "[Added Lines]",
          "1168:     updatePopulateEphTable(pParse, ephemTab, 0, pList, pSrc, pWhere, 0, 0);",
          "",
          "---------------"
        ],
        "test/upfrom2.test||test/upfrom2.test": [
          "File: test/upfrom2.test -> test/upfrom2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfrom2",
          "33: # Test cases:",
          "34: #",
          "35: #   1.*: Test that triggers are fired correctly for UPDATE FROM statements,",
          "37: #",
          "39: foreach {tn wo} {",
          "",
          "[Removed Lines]",
          "17: if 0 {",
          "18: do_execsql_test 0.0 {",
          "19:   CREATE TABLE t1 (a PRIMARY KEY, b, c) WITHOUT ROWID;",
          "20: }",
          "21: explain_i { REPLACE INTO t1 VALUES('one', 'two', 'three'); }",
          "22: breakpoint",
          "23: execsql {",
          "24:   REPLACE INTO t1 VALUES('one', 'two', 'three');",
          "25:   REPLACE INTO t1 VALUES('one', 'two', 'four');",
          "26: }",
          "27: do_execsql_test x {",
          "28:   SELECT * FROM t1",
          "29: } {one two four}",
          "30: exit",
          "31: }",
          "36: #        and only once for each row.",
          "",
          "[Added Lines]",
          "20: #        and only once for each row. Except for INSTEAD OF triggers on",
          "21: #        views - these are fired once for each row returned by the join,",
          "22: #        including duplicates.",
          "23: #",
          "24: #   2.*: Test adding ORDER BY and LIMIT clauses with UPDATE FROM statements.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110:     ten->eight        i->i",
          "111:     two->twelve       xii->xii",
          "112:   }",
          "113: }]",
          "114: }",
          "118: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:   do_test 1.%TN%.4 { db changes } {2}",
          "104:   do_execsql_test 1.%TN%.5 {",
          "105:     CREATE VIEW v1 AS SELECT * FROM t1;",
          "106:     CREATE TRIGGER v1tr INSTEAD OF UPDATE ON v1 BEGIN",
          "107:       UPDATE t1 SET y=new.y, z=new.z WHERE x=new.x;",
          "108:     END;",
          "110:     DELETE FROM log;",
          "111:     WITH data(k, v) AS (",
          "112:       VALUES(3, 'thirteen'), (3, 'fourteen'), (4, 'fifteen'), (4, 'sixteen')",
          "113:     )",
          "114:     UPDATE v1 SET z=v FROM data WHERE x=k;",
          "115:   }",
          "117:   do_execsql_test 1.%TN%.6 {",
          "118:     SELECT * FROM v1;",
          "119:     SELECT * FROM log;",
          "120:   } {",
          "121:     1 i eight   2 xii twelve   3 v fourteen   4 iv sixteen",
          "122:     thirty->thirteen  v->v",
          "123:     thirteen->fourteen  v->v",
          "124:     four->fifteen  iv->iv",
          "125:     fifteen->sixteen  iv->iv",
          "126:   }",
          "131: ifcapable update_delete_limit {",
          "132: foreach {tn wo} {",
          "133:   1 \"\"",
          "134:   2 \"WITHOUT ROWID\"",
          "135: } {",
          "136:   reset_db",
          "138: eval [string map [list %WO% $wo %TN% $tn] {",
          "139:   do_execsql_test 2.%TN%.1 {",
          "140:     CREATE TABLE x1(a INTEGER PRIMARY KEY, b) %WO%;",
          "141:     INSERT INTO x1 VALUES",
          "142:         (1, 'one'), (2, 'two'), (3, 'three'), (4, 'four'),",
          "143:         (5, 'five'), (6, 'six'), (7, 'seven'), (8, 'eight');",
          "144:   }",
          "146:   do_execsql_test 2.%TN%.2 {",
          "147:     CREATE TABLE data1(x, y);",
          "148:     INSERT INTO data1 VALUES",
          "149:     (1, 'eleven'), (1, 'twenty-one'), (2, 'twelve'), (2, 'twenty-two'),",
          "150:     (3, 'thirteen'), (3, 'twenty-three'), (4, 'fourteen'), (4, 'twenty-four');",
          "151:   }",
          "153:   do_execsql_test 2.%TN%.3 {",
          "154:     UPDATE x1 SET b=y FROM data1 WHERE a=x ORDER BY a LIMIT 3;",
          "155:     SELECT * FROM x1;",
          "156:   } {",
          "157:     1 eleven 2 twelve 3 thirteen 4 four 5 five 6 six 7 seven 8 eight",
          "158:   }",
          "160:   do_execsql_test 2.%TN%.4 {",
          "161:     UPDATE x1 SET b=b||y FROM data1 WHERE a=x ORDER BY b LIMIT 3;",
          "162:     SELECT * FROM x1;",
          "163:   } {",
          "164:     1 eleveneleven 2 twelve 3 thirteenthirteen 4 fourfourteen",
          "165:     5 five 6 six 7 seven 8 eight",
          "166:   }",
          "168: }]",
          "169: }}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d2a1be84b8e47c078a3b2e3804b9d6771ea4328",
      "candidate_info": {
        "commit_hash": "7d2a1be84b8e47c078a3b2e3804b9d6771ea4328",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/7d2a1be84b8e47c078a3b2e3804b9d6771ea4328",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fts3auto.test"
        ],
        "message": "Fix a case in fts3auto.test that fails for SQLITE_DISABLE_FTS4_DEFERRED builds.\n\nFossilOrigin-Name: d241055ead935f0e461a67f483788bcd59f7e8d65ade54b9c7c7c4fec9414102",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/fts3auto.test||test/fts3auto.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c7e29458a73bbe73a1429477d0c01d5a7b870ab75d3cb08a703be21714e439b7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fts3auto.test||test/fts3auto.test": [
          "File: test/fts3auto.test -> test/fts3auto.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "571:   do_fts3query_test 4.$tn.4.4 -deferred fi* t1 {on* NEAR/2 fi*}",
          "572:   do_fts3query_test 4.$tn.4.5 -deferred fi* t1 {on* NEAR/3 fi*}",
          "578: }",
          "580: #--------------------------------------------------------------------------",
          "",
          "[Removed Lines]",
          "574:   db eval {UPDATE t1_stat SET value=x'' WHERE id=0}",
          "575:   do_catchsql_test 4.$tn.4.6 {",
          "576:     SELECT docid FROM t1 WHERE t1 MATCH 'on* NEAR/3 fi*'",
          "577:   } {1 {database disk image is malformed}}",
          "",
          "[Added Lines]",
          "574:   ifcapable fts4_deferred {",
          "575:     db eval {UPDATE t1_stat SET value=x'' WHERE id=0}",
          "576:     do_catchsql_test 4.$tn.4.6 {",
          "577:       SELECT docid FROM t1 WHERE t1 MATCH 'on* NEAR/3 fi*'",
          "578:     } {1 {database disk image is malformed}}",
          "579:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "576d0a9fd9d43d602d9d9a57ade48a5187f4d96c",
      "candidate_info": {
        "commit_hash": "576d0a9fd9d43d602d9d9a57ade48a5187f4d96c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/576d0a9fd9d43d602d9d9a57ade48a5187f4d96c",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c",
          "src/where.c"
        ],
        "message": "Fix comments and strengthen assert() statements associated with the OPFLAG_SEEKEQ and BTREE_SEEK_EQ flags.\n\nFossilOrigin-Name: 231749213854756b599b33413b17b35186f17889b0c73f109fa9db726b415558",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c",
          "src/where.c||src/where.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c5f96a085db9688a09793f52ce1ecf033c2e6e2e5873a19fe0fb374b242b317f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3830:   assert( OPFLAG_BULKCSR==BTREE_BULKLOAD );",
          "3831:   assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ );",
          "3832:   testcase( pOp->p5 & OPFLAG_BULKCSR );",
          "3834:   testcase( pOp->p2 & OPFLAG_SEEKEQ );",
          "3836:   sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,",
          "3837:                                (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));",
          "3838:   if( rc ) goto abort_due_to_error;",
          "",
          "[Removed Lines]",
          "3833: #ifdef SQLITE_ENABLE_CURSOR_HINTS",
          "3835: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4253:       goto abort_due_to_error;",
          "4254:     }",
          "4255:   }else{",
          "4260:     if( sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ) ){",
          "4261:       eqOnly = 1;",
          "4262:       assert( pOp->opcode==OP_SeekGE || pOp->opcode==OP_SeekLE );",
          "4263:       assert( pOp[1].opcode==OP_IdxLT || pOp[1].opcode==OP_IdxGT );",
          "4264:       assert( pOp[1].p1==pOp[0].p1 );",
          "4265:       assert( pOp[1].p2==pOp[0].p2 );",
          "4266:       assert( pOp[1].p3==pOp[0].p3 );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4267:       assert( pOp->opcode==OP_SeekGE || pOp[1].opcode==OP_IdxLT );",
          "4268:       assert( pOp->opcode==OP_SeekLE || pOp[1].opcode==OP_IdxGT );",
          "",
          "---------------"
        ],
        "src/where.c||src/where.c": [
          "File: src/where.c -> src/where.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5122:         sqlite3VdbeChangeP4(v, -1, SQLITE_INT_TO_PTR(n), P4_INT32);",
          "5123:         assert( n<=pTab->nCol );",
          "5124:       }",
          "5126:       if( pLoop->u.btree.pIndex!=0 ){",
          "5127:         sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ|bFordelete);",
          "5128:       }else",
          "",
          "[Removed Lines]",
          "5125: #ifdef SQLITE_ENABLE_CURSOR_HINTS",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5178:          && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0",
          "5179:          && pWInfo->eDistinct!=WHERE_DISTINCT_ORDERED",
          "5180:         ){",
          "5182:         }",
          "5183:         VdbeComment((v, \"%s\", pIx->zName));",
          "5184: #ifdef SQLITE_ENABLE_COLUMN_USED_MASK",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5181:           sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69887c99d4cd271fe6bf9b40e958c90e409120b1",
      "candidate_info": {
        "commit_hash": "69887c99d4cd271fe6bf9b40e958c90e409120b1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/69887c99d4cd271fe6bf9b40e958c90e409120b1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/delete.c",
          "src/parse.y",
          "src/select.c",
          "src/sqliteInt.h",
          "src/update.c",
          "test/fts4upfrom.test",
          "test/pg_common.tcl",
          "test/upfrom1.tcl",
          "test/upfrom1.test"
        ],
        "message": "Allow a FROM clause in UPDATE statements.\n\nFossilOrigin-Name: f353a1a613bb7ad8cedcda377a7fe6fd05ee03b1f50665b00b84a868a71c5bec",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/delete.c||src/delete.c",
          "src/parse.y||src/parse.y",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/update.c||src/update.c",
          "test/fts4upfrom.test||test/fts4upfrom.test",
          "test/pg_common.tcl||test/pg_common.tcl",
          "test/upfrom1.tcl||test/upfrom1.tcl",
          "test/upfrom1.test||test/upfrom1.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b73d9a7d6f7fec0ffc9640902a849289c305f8651e891388c01255c4da7a6c4b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4495:   }",
          "4496: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4503: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){",
          "4504:   if( p2 && p1 ){",
          "4505:     assert( p1->nSrc==1 );",
          "4506:     p1 = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, p1->nSrc);",
          "4507:     if( p1 ){",
          "4508:       assert( p1->nSrc==1+p2->nSrc );",
          "4509:       memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(struct SrcList_item));",
          "4510:       sqlite3_free(p2);",
          "4511:     }else{",
          "4512:       sqlite3SrcListDelete(pParse->db, p2);",
          "4513:     }",
          "4514:   }",
          "4515:   return p1;",
          "4516: }",
          "",
          "---------------"
        ],
        "src/delete.c||src/delete.c": [
          "File: src/delete.c -> src/delete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){",
          "32:   struct SrcList_item *pItem = pSrc->a;",
          "33:   Table *pTab;",
          "35:   pTab = sqlite3LocateTableItem(pParse, 0, pItem);",
          "36:   sqlite3DeleteTable(pParse->db, pItem->pTab);",
          "37:   pItem->pTab = pTab;",
          "",
          "[Removed Lines]",
          "34:   assert( pItem && pSrc->nSrc==1 );",
          "",
          "[Added Lines]",
          "34:   assert( pItem && pSrc->nSrc>=1 );",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "641: from(A) ::= FROM seltablist(X). {",
          "642:   A = X;",
          "643:   sqlite3SrcListShiftJoinType(A);",
          "",
          "[Removed Lines]",
          "640: from(A) ::= .                {A = sqlite3DbMallocZero(pParse->db, sizeof(*A));}",
          "",
          "[Added Lines]",
          "640: from(A) ::= .                {A = 0;}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "869: %ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "871:         where_opt(W) orderby_opt(O) limit_opt(L).  {",
          "872:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "873:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "874:   sqlite3Update(pParse,X,Y,W,R,O,L,0);",
          "875: }",
          "876: %endif",
          "877: %ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "879:         where_opt(W).  {",
          "880:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "881:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "882:   sqlite3Update(pParse,X,Y,W,R,0,0,0);",
          "883: }",
          "884: %endif",
          "",
          "[Removed Lines]",
          "870: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "878: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "",
          "[Added Lines]",
          "870: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "873:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "879: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "883:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1154:       break;",
          "1155:     }",
          "1162:     case SRT_Set: {",
          "1163:       if( pSort ){",
          "",
          "[Removed Lines]",
          "1157: #ifndef SQLITE_OMIT_SUBQUERY",
          "",
          "[Added Lines]",
          "1161:     case SRT_ISet:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1168:         pushOntoSorter(",
          "1169:             pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);",
          "1170:       }else{",
          "1171:         int r1 = sqlite3GetTempReg(pParse);",
          "1176:         sqlite3ReleaseTempReg(pParse, r1);",
          "1177:       }",
          "1178:       break;",
          "1179:     }",
          "1183:     case SRT_Exists: {",
          "",
          "[Removed Lines]",
          "1172:         assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );",
          "1173:         sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol,",
          "1174:             r1, pDest->zAffSdst, nResultCol);",
          "1175:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);",
          "",
          "[Added Lines]",
          "1171:         int bITab = (eDest==SRT_ISet);",
          "1173:         sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult+bITab, nResultCol-bITab,",
          "1174:             r1, pDest->zAffSdst, 0",
          "1175:         );",
          "1176:         if( bITab ){",
          "1177:           sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);",
          "1178:         }else{",
          "1179:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1,regResult,nResultCol);",
          "1180:         }",
          "1186: #ifndef SQLITE_OMIT_SUBQUERY",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4981:   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){",
          "4982:     Table *pTab;",
          "4983:     assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );",
          "4986: #ifndef SQLITE_OMIT_CTE",
          "4987:     if( withExpand(pWalker, pFrom) ) return WRC_Abort;",
          "4988:     if( pFrom->pTab ) {} else",
          "",
          "[Removed Lines]",
          "4984:     if( pFrom->fg.isRecursive ) continue;",
          "4985:     assert( pFrom->pTab==0 );",
          "",
          "[Added Lines]",
          "4990:     if( pFrom->pTab ) continue;",
          "4991:     assert( pFrom->fg.isRecursive==0 );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4204: IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);",
          "4205: int sqlite3IdListIndex(IdList*,const char*);",
          "4206: SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);",
          "4207: SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);",
          "4208: SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,",
          "4209:                                       Token*, Select*, Expr*, IdList*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4208: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2);",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:                                             aXRef, chngRowid);",
          "131: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161: static void updatePopulateEphTable(",
          "168: ){",
          "169:   int i;",
          "170:   sqlite3 *db = pParse->db;",
          "171:   SelectDest dest;",
          "172:   Select *pSelect = 0;",
          "173:   ExprList *pList = 0;",
          "174:   Table *pTab = pTabList->a[0].pTab;",
          "175:   SrcList *pSrc = sqlite3SrcListDup(db, pTabList, 0);",
          "176:   Expr *pWhere2 = sqlite3ExprDup(db, pWhere, 0);",
          "177:   int eDest;",
          "179:   assert( pTabList->nSrc>1 );",
          "180:   if( pSrc ){",
          "181:     pSrc->a[0].iCursor = -1;",
          "182:     pSrc->a[0].pTab->nTabRef--;",
          "183:     pSrc->a[0].pTab = 0;",
          "184:   }",
          "185:   if( pPk ){",
          "186:     for(i=0; i<pPk->nKeyCol; i++){",
          "187:       pList = sqlite3ExprListAppend(pParse, pList,",
          "188:           sqlite3PExpr(pParse, TK_DOT,",
          "189:             sqlite3Expr(db, TK_ID, pTab->zName),",
          "190:             sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zName)",
          "191:       ));",
          "192:     }",
          "193:     eDest = SRT_Set;",
          "194:   }else if( pTab->pSelect ){",
          "195:     pList = sqlite3ExprListAppend(pParse, pList,",
          "196:         sqlite3PExpr(pParse, TK_DOT,",
          "197:           sqlite3Expr(db, TK_ID, pTab->zName),",
          "198:           sqlite3PExpr(pParse, TK_ASTERISK, 0, 0)",
          "199:     ));",
          "200:     eDest = SRT_Table;",
          "201:   }else{",
          "202:     pList = sqlite3ExprListAppend(pParse, pList,",
          "203:         sqlite3PExpr(pParse, TK_DOT,",
          "204:           sqlite3Expr(db, TK_ID, pTab->zName),",
          "205:           sqlite3Expr(db, TK_ID, \"_rowid_\")",
          "206:     ));",
          "207:     eDest = IsVirtual(pTab) ? SRT_Table : SRT_ISet;",
          "208:   }",
          "209:   for(i=0; i<pChanges->nExpr; i++){",
          "210:     pList = sqlite3ExprListAppend(pParse, pList,",
          "211:         sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)",
          "212:     );",
          "213:   }",
          "214:   pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, 0, 0, 0, 0, 0);",
          "215:   sqlite3SelectDestInit(&dest, eDest, iEph);",
          "216:   sqlite3Select(pParse, pSelect, &dest);",
          "217:   sqlite3SelectDelete(db, pSelect);",
          "218: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:   int nChangeFrom = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207:   if( pParse->nErr || db->mallocFailed ){",
          "208:     goto update_cleanup;",
          "209:   }",
          "",
          "[Removed Lines]",
          "210:   assert( pTabList->nSrc==1 );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "231: # undef isView",
          "232: # define isView 0",
          "233: #endif",
          "235: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "236:   if( !isView ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "321:   nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;",
          "322:   assert( nChangeFrom==0 || pUpsert==0 );",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "303:   chngRowid = chngPk = 0;",
          "304:   for(i=0; i<pChanges->nExpr; i++){",
          "306:       goto update_cleanup;",
          "307:     }",
          "308:     for(j=0; j<pTab->nCol; j++){",
          "",
          "[Removed Lines]",
          "305:     if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "[Added Lines]",
          "396:     if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "463: #if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)",
          "465:     sqlite3MaterializeView(pParse, pTab,",
          "466:         pWhere, pOrderBy, pLimit, iDataCur",
          "467:     );",
          "",
          "[Removed Lines]",
          "464:   if( isView ){",
          "",
          "[Added Lines]",
          "555:   if( nChangeFrom==0 && isView ){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "477:     goto update_cleanup;",
          "478:   }",
          "",
          "[Removed Lines]",
          "476:   if( sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "[Added Lines]",
          "567:   if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "500:     sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);",
          "501:   }",
          "504:     sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);",
          "505:   }else{",
          "508:     iPk = pParse->nMem+1;",
          "509:     pParse->nMem += nPk;",
          "510:     regKey = ++pParse->nMem;",
          "511:     if( pUpsert==0 ){",
          "512:       iEph = pParse->nTab++;",
          "516:     }",
          "517:   }",
          "529:   }else{",
          "562:         }",
          "564:       }",
          "565:     }",
          "593:     }else{",
          "597:     }",
          "598:   }",
          "600:   if( pUpsert==0 ){",
          "602:       sqlite3WhereEnd(pWInfo);",
          "603:     }",
          "",
          "[Removed Lines]",
          "503:   if( HasRowid(pTab) ){",
          "506:     assert( pPk!=0 );",
          "507:     nPk = pPk->nKeyCol;",
          "513:         sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "514:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nPk);",
          "515:       sqlite3VdbeSetP4KeyInfo(pParse, pPk);",
          "519:   if( pUpsert ){",
          "525:     pWInfo = 0;",
          "526:     eOnePass = ONEPASS_SINGLE;",
          "527:     sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "528:     bFinishSeek = 0;",
          "537:     flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "538:     if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "539:       flags |= WHERE_ONEPASS_MULTIROW;",
          "540:     }",
          "541:     pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags, iIdxCur);",
          "542:     if( pWInfo==0 ) goto update_cleanup;",
          "554:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "555:     bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "556:     if( eOnePass!=ONEPASS_SINGLE ){",
          "557:       sqlite3MultiWrite(pParse);",
          "558:       if( eOnePass==ONEPASS_MULTI ){",
          "559:         int iCur = aiCurOnePass[1];",
          "560:         if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "561:           eOnePass = ONEPASS_OFF;",
          "563:         assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "566:   }",
          "568:   if( HasRowid(pTab) ){",
          "572:     sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "573:     if( eOnePass==ONEPASS_OFF ){",
          "575:       aRegIdx[nAllIdx] = ++pParse->nMem;",
          "576:       sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "577:     }",
          "578:   }else{",
          "584:     for(i=0; i<nPk; i++){",
          "585:       assert( pPk->aiColumn[i]>=0 );",
          "586:       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "587:                                       pPk->aiColumn[i], iPk+i);",
          "588:     }",
          "589:     if( eOnePass ){",
          "590:       if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "591:       nKey = nPk;",
          "592:       regKey = iPk;",
          "594:       sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "595:                         sqlite3IndexAffinityStr(db, pPk), nPk);",
          "596:       sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "601:     if( eOnePass!=ONEPASS_MULTI ){",
          "",
          "[Added Lines]",
          "594:   if( nChangeFrom==0 && HasRowid(pTab) ){",
          "597:     assert( pPk!=0 || HasRowid(pTab) );",
          "598:     nPk = pPk ? pPk->nKeyCol : 0;",
          "601:     pParse->nMem += nChangeFrom;",
          "604:       int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);",
          "606:       if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "607:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);",
          "608:       if( pPk ) sqlite3VdbeSetP4KeyInfo(pParse, pPk);",
          "609:       if( nChangeFrom ){",
          "610:         updatePopulateEphTable(pParse, iEph, pPk, pChanges, pTabList, pWhere);",
          "611: #ifndef SQLITE_OMIT_SUBQUERY",
          "612:         if( isView ) iDataCur = iEph;",
          "613: #endif",
          "614:       }",
          "618:   if( nChangeFrom ){",
          "619:     sqlite3MultiWrite(pParse);",
          "620:     eOnePass = ONEPASS_OFF;",
          "622:     if( pUpsert ){",
          "628:       pWInfo = 0;",
          "629:       eOnePass = ONEPASS_SINGLE;",
          "630:       sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "631:       bFinishSeek = 0;",
          "632:     }else{",
          "640:       flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "641:       if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "642:         flags |= WHERE_ONEPASS_MULTIROW;",
          "643:       }",
          "644:       pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);",
          "645:       if( pWInfo==0 ) goto update_cleanup;",
          "657:       eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "658:       bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "659:       if( eOnePass!=ONEPASS_SINGLE ){",
          "660:         sqlite3MultiWrite(pParse);",
          "661:         if( eOnePass==ONEPASS_MULTI ){",
          "662:           int iCur = aiCurOnePass[1];",
          "663:           if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "664:             eOnePass = ONEPASS_OFF;",
          "665:           }",
          "666:           assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "671:     if( HasRowid(pTab) ){",
          "675:       sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "676:       if( eOnePass==ONEPASS_OFF ){",
          "678:         aRegIdx[nAllIdx] = ++pParse->nMem;",
          "679:         sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "680:       }",
          "687:       for(i=0; i<nPk; i++){",
          "688:         assert( pPk->aiColumn[i]>=0 );",
          "689:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "690:                                         pPk->aiColumn[i], iPk+i);",
          "691:       }",
          "692:       if( eOnePass ){",
          "693:         if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "694:         nKey = nPk;",
          "695:         regKey = iPk;",
          "696:       }else{",
          "697:         sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "698:                           sqlite3IndexAffinityStr(db, pPk), nPk);",
          "699:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "700:       }",
          "705:     if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "634:       sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);",
          "635:       VdbeCoverageIf(v, pPk==0);",
          "636:       VdbeCoverageIf(v, pPk!=0);",
          "638:       labelContinue = sqlite3VdbeMakeLabel(pParse);",
          "639:       sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);",
          "643:     }else{",
          "644:       labelContinue = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet,labelBreak,",
          "645:                                regOldRowid);",
          "",
          "[Removed Lines]",
          "637:     }else if( pPk ){",
          "640:       addrTop = sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "641:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, 0);",
          "642:       VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "741:     }else if( pPk || nChangeFrom ){",
          "744:       addrTop = sqlite3VdbeCurrentAddr(v);",
          "745:       if( nChangeFrom ){",
          "746:         if( !isView ){",
          "747:           if( pPk ){",
          "748:             for(i=0; i<nPk; i++){",
          "749:               sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);",
          "750:             }",
          "751:             sqlite3VdbeAddOp4Int(",
          "752:                 v, OP_NotFound, iDataCur, labelContinue, iPk, nPk",
          "753:             );",
          "754:           }else{",
          "755:             sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);",
          "756:             sqlite3VdbeAddOp3(",
          "757:                 v, OP_NotExists, iDataCur, labelContinue, regOldRowid",
          "758:             );",
          "759:           }",
          "760:         }",
          "761:         VdbeCoverage(v);",
          "762:       }else{",
          "763:         sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "764:         sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);",
          "765:         VdbeCoverage(v);",
          "766:       }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "708:     }else{",
          "709:       j = aXRef[i];",
          "710:       if( j>=0 ){",
          "712:       }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){",
          "",
          "[Removed Lines]",
          "711:         sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "",
          "[Added Lines]",
          "835:         if( nChangeFrom ){",
          "836:           assert( eOnePass==ONEPASS_OFF );",
          "837:           int nOff = (isView ? pTab->nCol : nPk);",
          "838:           sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);",
          "839:         }else{",
          "840:           sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "841:         }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "740:     sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,",
          "741:         TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);",
          "771:       }",
          "773: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "779: #endif",
          "780:   }",
          "782:   if( !isView ){",
          "",
          "[Removed Lines]",
          "749:     if( pPk ){",
          "750:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue,regKey,nKey);",
          "751:       VdbeCoverage(v);",
          "752:     }else{",
          "753:       sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);",
          "754:       VdbeCoverage(v);",
          "755:     }",
          "766:     for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "767:       if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "768:         if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "769:       }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "770:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "772:     }",
          "774:     if( pTab->tabFlags & TF_HasGenerated ){",
          "775:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "776:       testcase( pTab->tabFlags & TF_HasStored );",
          "777:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "778:     }",
          "",
          "[Added Lines]",
          "873:     if( !isView ){",
          "880:       if( pPk ){",
          "881:         sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);",
          "882:         VdbeCoverage(v);",
          "883:       }else{",
          "884:         sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);",
          "885:         VdbeCoverage(v);",
          "886:       }",
          "897:       for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "898:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "899:           if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "900:         }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "901:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "902:         }",
          "905:       if( pTab->tabFlags & TF_HasGenerated ){",
          "906:         testcase( pTab->tabFlags & TF_HasVirtual );",
          "907:         testcase( pTab->tabFlags & TF_HasStored );",
          "908:         sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "909:       }",
          "911:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "879:   }else if( eOnePass==ONEPASS_MULTI ){",
          "880:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "881:     sqlite3WhereEnd(pWInfo);",
          "883:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "884:     sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);",
          "885:   }else{",
          "",
          "[Removed Lines]",
          "882:   }else if( pPk ){",
          "",
          "[Added Lines]",
          "1014:   }else if( pPk || nChangeFrom ){",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "982:   addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);",
          "983:   regArg = pParse->nMem + 1;",
          "984:   pParse->nMem += nArg;",
          "1004:     if( pRowid ){",
          "1006:     }else{",
          "1008:     }",
          "1009:   }else{",
          "1035: #ifdef SQLITE_DEBUG",
          "1039: #endif",
          "1042:   }",
          "1045:   if( eOnePass==ONEPASS_OFF ){",
          "1050:     addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "985:   regRec = ++pParse->nMem;",
          "986:   regRowid = ++pParse->nMem;",
          "989:   pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,WHERE_ONEPASS_DESIRED,0);",
          "990:   if( pWInfo==0 ) return;",
          "993:   for(i=0; i<pTab->nCol; i++){",
          "994:     assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "995:     if( aXRef[i]>=0 ){",
          "996:       sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "997:     }else{",
          "998:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1000:     }",
          "1001:   }",
          "1002:   if( HasRowid(pTab) ){",
          "1003:     sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1005:       sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1007:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1012:     pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1013:     assert( pPk!=0 );",
          "1014:     assert( pPk->nKeyCol==1 );",
          "1015:     iPk = pPk->aiColumn[0];",
          "1016:     sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1017:     sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1018:   }",
          "1020:   eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1023:   assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1025:   if( eOnePass ){",
          "1028:     sqlite3VdbeChangeToNoop(v, addr);",
          "1029:     sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1030:   }else{",
          "1033:     sqlite3MultiWrite(pParse);",
          "1034:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1038:     sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1040:     sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1041:     sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1047:     sqlite3WhereEnd(pWInfo);",
          "",
          "[Added Lines]",
          "1117:   if( pSrc->nSrc>1 ){",
          "1118:     ExprList *pList = 0;",
          "1120:       pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db,pRowid,0));",
          "1122:       pList = sqlite3ExprListAppend(pParse, pList,",
          "1123:           sqlite3PExpr(pParse, TK_DOT,",
          "1124:             sqlite3Expr(db, TK_ID, pTab->zName),",
          "1125:             sqlite3Expr(db, TK_ID, \"_rowid_\")",
          "1126:       ));",
          "1128:     for(i=0; i<pTab->nCol; i++){",
          "1129:       if( aXRef[i]>=0 ){",
          "1130:         pList = sqlite3ExprListAppend(pParse, pList,",
          "1131:           sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)",
          "1132:         );",
          "1133:       }else{",
          "1134:         pList = sqlite3ExprListAppend(pParse, pList,",
          "1135:             sqlite3PExpr(pParse, TK_DOT,",
          "1136:               sqlite3Expr(db, TK_ID, pTab->zName),",
          "1137:               sqlite3Expr(db, TK_ID, pTab->aCol[i].zName)",
          "1138:         ));",
          "1139:       }",
          "1140:     }",
          "1142:     updatePopulateEphTable(pParse, ephemTab, 0, pList, pSrc, pWhere);",
          "1143:     sqlite3ExprListDelete(db, pList);",
          "1144:     eOnePass = ONEPASS_OFF;",
          "1146:     regRec = ++pParse->nMem;",
          "1147:     regRowid = ++pParse->nMem;",
          "1150:     pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);",
          "1151:     if( pWInfo==0 ) return;",
          "1154:     for(i=0; i<pTab->nCol; i++){",
          "1155:       assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "1156:       if( aXRef[i]>=0 ){",
          "1157:         sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "1158:       }else{",
          "1159:         sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1161:       }",
          "1162:     }",
          "1163:     if( HasRowid(pTab) ){",
          "1164:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1165:       if( pRowid ){",
          "1166:         sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1167:       }else{",
          "1168:         sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1169:       }",
          "1170:     }else{",
          "1173:       pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1174:       assert( pPk!=0 );",
          "1175:       assert( pPk->nKeyCol==1 );",
          "1176:       iPk = pPk->aiColumn[0];",
          "1177:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1178:       sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1179:     }",
          "1181:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1184:     assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1186:     if( eOnePass ){",
          "1189:       sqlite3VdbeChangeToNoop(v, addr);",
          "1190:       sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1191:     }else{",
          "1194:       sqlite3MultiWrite(pParse);",
          "1195:       sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1199:       sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1201:       sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1202:       sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1203:     }",
          "1209:     if( pSrc->nSrc==1 ){",
          "1210:       sqlite3WhereEnd(pWInfo);",
          "1211:     }",
          "",
          "---------------"
        ],
        "test/fts4upfrom.test||test/fts4upfrom.test": [
          "File: test/fts4upfrom.test -> test/fts4upfrom.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 February 24",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this script is testing UPDATE statements with FROM clauses",
          "13: # against FTS4 tables.",
          "14: #",
          "15: #",
          "17: set testdir [file dirname $argv0]",
          "18: source $testdir/tester.tcl",
          "19: set testprefix fts4upfrom",
          "21: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "22: ifcapable !fts3 {",
          "23:   finish_test",
          "24:   return",
          "25: }",
          "27: foreach {tn create_table} {",
          "28:   1 { CREATE VIRTUAL TABLE ft USING fts3(a, b, c) }",
          "29:   2 { CREATE TABLE ft(a, b, c) }",
          "30:   3 {",
          "31:     CREATE TABLE real(a, b, c);",
          "32:     CREATE INDEX i1 ON real(a);",
          "33:     CREATE VIEW ft AS SELECT rowid, a, b, c FROM real;",
          "34:     CREATE TRIGGER tr1 INSTEAD OF INSERT ON ft BEGIN",
          "35:       INSERT INTO real(rowid, a, b, c) VALUES(new.rowid, new.a, new.b, new.c);",
          "36:     END;",
          "37:     CREATE TRIGGER tr2 INSTEAD OF UPDATE ON ft BEGIN",
          "38:       UPDATE real SET rowid=new.rowid, a=new.a, b=new.b, c=new.c",
          "39:       WHERE rowid=old.rowid;",
          "40:     END;",
          "41:   }",
          "42: } {",
          "43:   catchsql { DROP VIEW IF EXISTS changes }",
          "44:   catchsql { DROP TABLE IF EXISTS ft }",
          "45:   catchsql { DROP VIEW IF EXISTS ft }",
          "46:   execsql $create_table",
          "48:   do_execsql_test 1.$tn.0 {",
          "49:     INSERT INTO ft(a, b, c) VALUES('a', NULL, 'apple');",
          "50:     INSERT INTO ft(a, b, c) VALUES('b', NULL, 'banana');",
          "51:     INSERT INTO ft(a, b, c) VALUES('c', NULL, 'cherry');",
          "52:     INSERT INTO ft(a, b, c) VALUES('d', NULL, 'damson plum');",
          "53:   }",
          "55:   do_execsql_test 1.$tn.1 {",
          "56:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "57:   } {",
          "58:     a {} apple",
          "59:     b {} banana",
          "60:     c {} cherry",
          "61:     d {} {damson plum}",
          "62:   }",
          "64:   do_execsql_test 1.$tn.2 {",
          "65:     UPDATE ft SET b=o.c FROM ft AS o WHERE (ft.a == char(unicode(o.a)+1))",
          "66:   }",
          "68:   do_execsql_test 1.$tn.3 {",
          "69:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "70:   } {",
          "71:     a {} apple",
          "72:     b apple banana",
          "73:     c banana cherry",
          "74:     d cherry {damson plum}",
          "75:   }",
          "77:   do_catchsql_test 1.$tn.4 {",
          "78:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "79:   } {1 {no such table: changes}}",
          "81:   do_execsql_test 1.$tn.5 {",
          "82:     create view changes(k, v) AS",
          "83:       VALUES( 'd', 'dewberry' ) UNION ALL",
          "84:       VALUES( 'c', 'clementine' ) UNION ALL",
          "85:       VALUES( 'b', 'blueberry' ) UNION ALL",
          "86:       VALUES( 'a', 'apricot' )",
          "87:     ;",
          "88:   }",
          "90:   do_execsql_test 1.$tn.6 {",
          "91:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "92:   }",
          "94:   do_execsql_test 1.$tn.7 {",
          "95:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "96:   } {",
          "97:     a {} apricot",
          "98:     b apple blueberry",
          "99:     c banana clementine",
          "100:     d cherry dewberry",
          "101:   }",
          "102: }",
          "104: finish_test",
          "",
          "---------------"
        ],
        "test/pg_common.tcl||test/pg_common.tcl": [
          "File: test/pg_common.tcl -> test/pg_common.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: proc execsql {sql} {",
          "21:   set lSql [list]",
          "22:   set frag \"\"",
          "23:   while {[string length $sql]>0} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:   set sql [string map {{WITHOUT ROWID} {}} $sql]",
          "",
          "---------------"
        ],
        "test/upfrom1.tcl||test/upfrom1.tcl": [
          "File: test/upfrom1.tcl -> test/upfrom1.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: source [file join [file dirname $argv0] pg_common.tcl]",
          "15: #=========================================================================",
          "17: start_test upfrom1 \"2020 April 22\"",
          "19: foreach {tn wo} {",
          "20:   1 \"WITHOUT ROWID\"",
          "21:   2 \"\"",
          "22: } {",
          "23: eval [string map [list %TN% $tn %WITHOUT_ROWID% $wo] {",
          "24: execsql_test 1.%TN%.0 {",
          "25:   DROP TABLE IF EXISTS t2;",
          "26:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) %WITHOUT_ROWID%;",
          "27:   INSERT INTO t2 VALUES(1, 2, 3);",
          "28:   INSERT INTO t2 VALUES(4, 5, 6);",
          "29:   INSERT INTO t2 VALUES(7, 8, 9);",
          "31:   DROP TABLE IF EXISTS chng;",
          "32:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "33:   INSERT INTO chng VALUES(1, 100, 1000);",
          "34:   INSERT INTO chng VALUES(7, 700, 7000);",
          "35: }",
          "37: execsql_test 1.%TN%.1 {",
          "38:   SELECT * FROM t2;",
          "39: }",
          "41: execsql_test 1.%TN%.2 {",
          "42:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "43:   SELECT * FROM t2 ORDER BY a;",
          "44: }",
          "46: execsql_test 1.%TN%.3 {",
          "47:   DELETE FROM t2;",
          "48:   INSERT INTO t2 VALUES(1, 2, 3);",
          "49:   INSERT INTO t2 VALUES(4, 5, 6);",
          "50:   INSERT INTO t2 VALUES(7, 8, 9);",
          "51: }",
          "53: execsql_test 1.%TN%.4 {",
          "54:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "55:     WHERE a IN (SELECT a FROM chng);",
          "56:   SELECT * FROM t2 ORDER BY a;",
          "57: }",
          "59: execsql_test 1.%TN%.5 {",
          "60:   DROP TABLE IF EXISTS t3;",
          "61:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) %WITHOUT_ROWID%;",
          "62:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "63:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "64:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "66:   DROP TABLE IF EXISTS t4;",
          "67:   CREATE TABLE t4(x TEXT);",
          "68:   INSERT INTO t4 VALUES('five');",
          "70:   SELECT * FROM t3 ORDER BY a;",
          "71: }",
          "73: execsql_test 1.%TN%.6 {",
          "74:   UPDATE t3 SET c=x FROM t4;",
          "75:   SELECT * FROM t3 ORDER BY a;",
          "76: }",
          "77: }]}",
          "79: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom1.test||test/upfrom1.test": [
          "File: test/upfrom1.test -> test/upfrom1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.",
          "12: #",
          "14: ####################################################",
          "15: # DO NOT EDIT! THIS FILE IS AUTOMATICALLY GENERATED!",
          "16: ####################################################",
          "18: set testdir [file dirname $argv0]",
          "19: source $testdir/tester.tcl",
          "20: set testprefix upfrom1",
          "22: do_execsql_test 1.1.0 {",
          "23:   DROP TABLE IF EXISTS t2;",
          "24:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) WITHOUT ROWID;",
          "25:   INSERT INTO t2 VALUES(1, 2, 3);",
          "26:   INSERT INTO t2 VALUES(4, 5, 6);",
          "27:   INSERT INTO t2 VALUES(7, 8, 9);",
          "29:   DROP TABLE IF EXISTS chng;",
          "30:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "31:   INSERT INTO chng VALUES(1, 100, 1000);",
          "32:   INSERT INTO chng VALUES(7, 700, 7000);",
          "33: } {}",
          "35: do_execsql_test 1.1.1 {",
          "36:   SELECT * FROM t2;",
          "37: } {1 2 3   4 5 6   7 8 9}",
          "39: do_execsql_test 1.1.2 {",
          "40:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "41:   SELECT * FROM t2 ORDER BY a;",
          "42: } {1 100 1000   4 5 6   7 700 7000}",
          "44: do_execsql_test 1.1.3 {",
          "45:   DELETE FROM t2;",
          "46:   INSERT INTO t2 VALUES(1, 2, 3);",
          "47:   INSERT INTO t2 VALUES(4, 5, 6);",
          "48:   INSERT INTO t2 VALUES(7, 8, 9);",
          "49: } {}",
          "51: do_execsql_test 1.1.4 {",
          "52:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "53:     WHERE a IN (SELECT a FROM chng);",
          "54:   SELECT * FROM t2 ORDER BY a;",
          "55: } {1 100 1000   4 5 6   7 700 7000}",
          "57: do_execsql_test 1.1.5 {",
          "58:   DROP TABLE IF EXISTS t3;",
          "59:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) WITHOUT ROWID;",
          "60:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "61:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "62:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "64:   DROP TABLE IF EXISTS t4;",
          "65:   CREATE TABLE t4(x TEXT);",
          "66:   INSERT INTO t4 VALUES('five');",
          "68:   SELECT * FROM t3 ORDER BY a;",
          "69: } {1 1 one   2 2 two   3 3 three}",
          "71: do_execsql_test 1.1.6 {",
          "72:   UPDATE t3 SET c=x FROM t4;",
          "73:   SELECT * FROM t3 ORDER BY a;",
          "74: } {1 1 five   2 2 five   3 3 five}",
          "76: do_execsql_test 1.2.0 {",
          "77:   DROP TABLE IF EXISTS t2;",
          "78:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) ;",
          "79:   INSERT INTO t2 VALUES(1, 2, 3);",
          "80:   INSERT INTO t2 VALUES(4, 5, 6);",
          "81:   INSERT INTO t2 VALUES(7, 8, 9);",
          "83:   DROP TABLE IF EXISTS chng;",
          "84:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "85:   INSERT INTO chng VALUES(1, 100, 1000);",
          "86:   INSERT INTO chng VALUES(7, 700, 7000);",
          "87: } {}",
          "89: do_execsql_test 1.2.1 {",
          "90:   SELECT * FROM t2;",
          "91: } {1 2 3   4 5 6   7 8 9}",
          "93: do_execsql_test 1.2.2 {",
          "94:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "95:   SELECT * FROM t2 ORDER BY a;",
          "96: } {1 100 1000   4 5 6   7 700 7000}",
          "98: do_execsql_test 1.2.3 {",
          "99:   DELETE FROM t2;",
          "100:   INSERT INTO t2 VALUES(1, 2, 3);",
          "101:   INSERT INTO t2 VALUES(4, 5, 6);",
          "102:   INSERT INTO t2 VALUES(7, 8, 9);",
          "103: } {}",
          "105: do_execsql_test 1.2.4 {",
          "106:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "107:     WHERE a IN (SELECT a FROM chng);",
          "108:   SELECT * FROM t2 ORDER BY a;",
          "109: } {1 100 1000   4 5 6   7 700 7000}",
          "111: do_execsql_test 1.2.5 {",
          "112:   DROP TABLE IF EXISTS t3;",
          "113:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) ;",
          "114:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "115:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "116:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "118:   DROP TABLE IF EXISTS t4;",
          "119:   CREATE TABLE t4(x TEXT);",
          "120:   INSERT INTO t4 VALUES('five');",
          "122:   SELECT * FROM t3 ORDER BY a;",
          "123: } {1 1 one   2 2 two   3 3 three}",
          "125: do_execsql_test 1.2.6 {",
          "126:   UPDATE t3 SET c=x FROM t4;",
          "127:   SELECT * FROM t3 ORDER BY a;",
          "128: } {1 1 five   2 2 five   3 3 five}",
          "130: finish_test",
          "",
          "---------------"
        ]
      }
    }
  ]
}
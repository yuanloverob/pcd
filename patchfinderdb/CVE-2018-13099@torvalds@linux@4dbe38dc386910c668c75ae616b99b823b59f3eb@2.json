{
  "cve_id": "CVE-2018-13099",
  "cve_desc": "An issue was discovered in fs/f2fs/inline.c in the Linux kernel through 4.4. A denial of service (out-of-bounds memory access and BUG) can occur for a modified f2fs filesystem image in which an inline inode contains an invalid reserved blkaddr.",
  "repo": "torvalds/linux",
  "patch_hash": "4dbe38dc386910c668c75ae616b99b823b59f3eb",
  "patch_info": {
    "commit_hash": "4dbe38dc386910c668c75ae616b99b823b59f3eb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4dbe38dc386910c668c75ae616b99b823b59f3eb",
    "files": [
      "fs/f2fs/inline.c"
    ],
    "message": "f2fs: fix to do sanity check with reserved blkaddr of inline inode\n\nAs Wen Xu reported in bugzilla, after image was injected with random data\nby fuzzing, inline inode would contain invalid reserved blkaddr, then\nduring inline conversion, we will encounter illegal memory accessing\nreported by KASAN, the root cause of this is when writing out converted\ninline page, we will use invalid reserved blkaddr to update sit bitmap,\nresult in accessing memory beyond sit bitmap boundary.\n\nIn order to fix this issue, let's do sanity check with reserved block\naddress of inline inode to avoid above condition.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200179\n\n[ 1428.846352] BUG: KASAN: use-after-free in update_sit_entry+0x80/0x7f0\n[ 1428.846618] Read of size 4 at addr ffff880194483540 by task a.out/2741\n\n[ 1428.846855] CPU: 0 PID: 2741 Comm: a.out Tainted: G        W         4.17.0+ #1\n[ 1428.846858] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[ 1428.846860] Call Trace:\n[ 1428.846868]  dump_stack+0x71/0xab\n[ 1428.846875]  print_address_description+0x6b/0x290\n[ 1428.846881]  kasan_report+0x28e/0x390\n[ 1428.846888]  ? update_sit_entry+0x80/0x7f0\n[ 1428.846898]  update_sit_entry+0x80/0x7f0\n[ 1428.846906]  f2fs_allocate_data_block+0x6db/0xc70\n[ 1428.846914]  ? f2fs_get_node_info+0x14f/0x590\n[ 1428.846920]  do_write_page+0xc8/0x150\n[ 1428.846928]  f2fs_outplace_write_data+0xfe/0x210\n[ 1428.846935]  ? f2fs_do_write_node_page+0x170/0x170\n[ 1428.846941]  ? radix_tree_tag_clear+0xff/0x130\n[ 1428.846946]  ? __mod_node_page_state+0x22/0xa0\n[ 1428.846951]  ? inc_zone_page_state+0x54/0x100\n[ 1428.846956]  ? __test_set_page_writeback+0x336/0x5d0\n[ 1428.846964]  f2fs_convert_inline_page+0x407/0x6d0\n[ 1428.846971]  ? f2fs_read_inline_data+0x3b0/0x3b0\n[ 1428.846978]  ? __get_node_page+0x335/0x6b0\n[ 1428.846987]  f2fs_convert_inline_inode+0x41b/0x500\n[ 1428.846994]  ? f2fs_convert_inline_page+0x6d0/0x6d0\n[ 1428.847000]  ? kasan_unpoison_shadow+0x31/0x40\n[ 1428.847005]  ? kasan_kmalloc+0xa6/0xd0\n[ 1428.847024]  f2fs_file_mmap+0x79/0xc0\n[ 1428.847029]  mmap_region+0x58b/0x880\n[ 1428.847037]  ? arch_get_unmapped_area+0x370/0x370\n[ 1428.847042]  do_mmap+0x55b/0x7a0\n[ 1428.847048]  vm_mmap_pgoff+0x16f/0x1c0\n[ 1428.847055]  ? vma_is_stack_for_current+0x50/0x50\n[ 1428.847062]  ? __fsnotify_update_child_dentry_flags.part.1+0x160/0x160\n[ 1428.847068]  ? do_sys_open+0x206/0x2a0\n[ 1428.847073]  ? __fget+0xb4/0x100\n[ 1428.847079]  ksys_mmap_pgoff+0x278/0x360\n[ 1428.847085]  ? find_mergeable_anon_vma+0x50/0x50\n[ 1428.847091]  do_syscall_64+0x73/0x160\n[ 1428.847098]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[ 1428.847102] RIP: 0033:0x7fb1430766ba\n[ 1428.847103] Code: 89 f5 41 54 49 89 fc 55 53 74 35 49 63 e8 48 63 da 4d 89 f9 49 89 e8 4d 63 d6 48 89 da 4c 89 ee 4c 89 e7 b8 09 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 56 5b 5d 41 5c 41 5d 41 5e 41 5f c3 0f 1f 00\n[ 1428.847162] RSP: 002b:00007ffc651d9388 EFLAGS: 00000246 ORIG_RAX: 0000000000000009\n[ 1428.847167] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 00007fb1430766ba\n[ 1428.847170] RDX: 0000000000000001 RSI: 0000000000001000 RDI: 0000000000000000\n[ 1428.847173] RBP: 0000000000000003 R08: 0000000000000003 R09: 0000000000000000\n[ 1428.847176] R10: 0000000000008002 R11: 0000000000000246 R12: 0000000000000000\n[ 1428.847179] R13: 0000000000001000 R14: 0000000000008002 R15: 0000000000000000\n\n[ 1428.847252] Allocated by task 2683:\n[ 1428.847372]  kasan_kmalloc+0xa6/0xd0\n[ 1428.847380]  kmem_cache_alloc+0xc8/0x1e0\n[ 1428.847385]  getname_flags+0x73/0x2b0\n[ 1428.847390]  user_path_at_empty+0x1d/0x40\n[ 1428.847395]  vfs_statx+0xc1/0x150\n[ 1428.847401]  __do_sys_newlstat+0x7e/0xd0\n[ 1428.847405]  do_syscall_64+0x73/0x160\n[ 1428.847411]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1428.847466] Freed by task 2683:\n[ 1428.847566]  __kasan_slab_free+0x137/0x190\n[ 1428.847571]  kmem_cache_free+0x85/0x1e0\n[ 1428.847575]  filename_lookup+0x191/0x280\n[ 1428.847580]  vfs_statx+0xc1/0x150\n[ 1428.847585]  __do_sys_newlstat+0x7e/0xd0\n[ 1428.847590]  do_syscall_64+0x73/0x160\n[ 1428.847596]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1428.847648] The buggy address belongs to the object at ffff880194483300\n                which belongs to the cache names_cache of size 4096\n[ 1428.847946] The buggy address is located 576 bytes inside of\n                4096-byte region [ffff880194483300, ffff880194484300)\n[ 1428.848234] The buggy address belongs to the page:\n[ 1428.848366] page:ffffea0006512000 count:1 mapcount:0 mapping:ffff8801f3586380 index:0x0 compound_mapcount: 0\n[ 1428.848606] flags: 0x17fff8000008100(slab|head)\n[ 1428.848737] raw: 017fff8000008100 dead000000000100 dead000000000200 ffff8801f3586380\n[ 1428.848931] raw: 0000000000000000 0000000000070007 00000001ffffffff 0000000000000000\n[ 1428.849122] page dumped because: kasan: bad access detected\n\n[ 1428.849305] Memory state around the buggy address:\n[ 1428.849436]  ffff880194483400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849620]  ffff880194483480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849804] >ffff880194483500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.849985]                                            ^\n[ 1428.850120]  ffff880194483580: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.850303]  ffff880194483600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1428.850498] ==================================================================\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/inline.c||fs/f2fs/inline.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/inline.c||fs/f2fs/inline.c": [
      "File: fs/f2fs/inline.c -> fs/f2fs/inline.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  if (err)",
      "131:   return err;",
      "133:  f2fs_bug_on(F2FS_P_SB(page), PageWriteback(page));",
      "135:  f2fs_do_read_inline_data(page, dn->inode_page);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  if (unlikely(dn->data_blkaddr != NEW_ADDR)) {",
      "134:   f2fs_put_dnode(dn);",
      "135:   set_sbi_flag(fio.sbi, SBI_NEED_FSCK);",
      "136:   f2fs_msg(fio.sbi->sb, KERN_WARNING,",
      "137:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
      "138:    \"run fsck to fix.\",",
      "139:    __func__, dn->inode->i_ino, dn->data_blkaddr);",
      "140:   return -EINVAL;",
      "141:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "363:  if (err)",
      "364:   goto out;",
      "366:  f2fs_wait_on_page_writeback(page, DATA, true);",
      "368:  dentry_blk = page_address(page);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "376:  if (unlikely(dn.data_blkaddr != NEW_ADDR)) {",
      "377:   f2fs_put_dnode(&dn);",
      "378:   set_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);",
      "379:   f2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,",
      "380:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
      "381:    \"run fsck to fix.\",",
      "382:    __func__, dir->i_ino, dn.data_blkaddr);",
      "383:   err = -EINVAL;",
      "384:   goto out;",
      "385:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a1933c09ef84c2fd187e05b560ddc6e1267d6508",
      "candidate_info": {
        "commit_hash": "a1933c09ef84c2fd187e05b560ddc6e1267d6508",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a1933c09ef84c2fd187e05b560ddc6e1267d6508",
        "files": [
          "fs/f2fs/sysfs.c"
        ],
        "message": "f2fs: avoid potential deadlock in f2fs_sbi_store\n\n[  155.018460] ======================================================\n[  155.021431] WARNING: possible circular locking dependency detected\n[  155.024339] 4.18.0-rc3+ #5 Tainted: G           OE\n[  155.026879] ------------------------------------------------------\n[  155.029783] umount/2901 is trying to acquire lock:\n[  155.032187] 00000000c4282f1f (kn->count#130){++++}, at: kernfs_remove+0x1f/0x30\n[  155.035439]\n[  155.035439] but task is already holding lock:\n[  155.038892] 0000000056e4307b (&type->s_umount_key#41){++++}, at: deactivate_super+0x33/0x50\n[  155.042602]\n[  155.042602] which lock already depends on the new lock.\n[  155.042602]\n[  155.047465]\n[  155.047465] the existing dependency chain (in reverse order) is:\n[  155.051354]\n[  155.051354] -> #1 (&type->s_umount_key#41){++++}:\n[  155.054768]        f2fs_sbi_store+0x61/0x460 [f2fs]\n[  155.057083]        kernfs_fop_write+0x113/0x1a0\n[  155.059277]        __vfs_write+0x36/0x180\n[  155.061250]        vfs_write+0xbe/0x1b0\n[  155.063179]        ksys_write+0x55/0xc0\n[  155.065068]        do_syscall_64+0x60/0x1b0\n[  155.067071]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  155.069529]\n[  155.069529] -> #0 (kn->count#130){++++}:\n[  155.072421]        __kernfs_remove+0x26f/0x2e0\n[  155.074452]        kernfs_remove+0x1f/0x30\n[  155.076342]        kobject_del.part.5+0xe/0x40\n[  155.078354]        f2fs_put_super+0x12d/0x290 [f2fs]\n[  155.080500]        generic_shutdown_super+0x6c/0x110\n[  155.082655]        kill_block_super+0x21/0x50\n[  155.084634]        kill_f2fs_super+0x9c/0xc0 [f2fs]\n[  155.086726]        deactivate_locked_super+0x3f/0x70\n[  155.088826]        cleanup_mnt+0x3b/0x70\n[  155.090584]        task_work_run+0x93/0xc0\n[  155.092367]        exit_to_usermode_loop+0xf0/0x100\n[  155.094466]        do_syscall_64+0x162/0x1b0\n[  155.096312]        entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  155.098603]\n[  155.098603] other info that might help us debug this:\n[  155.098603]\n[  155.102418]  Possible unsafe locking scenario:\n[  155.102418]\n[  155.105134]        CPU0                    CPU1\n[  155.107037]        ----                    ----\n[  155.108910]   lock(&type->s_umount_key#41);\n[  155.110674]                                lock(kn->count#130);\n[  155.113010]                                lock(&type->s_umount_key#41);\n[  155.115608]   lock(kn->count#130);\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c": [
          "File: fs/f2fs/sysfs.c -> fs/f2fs/sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "286:  bool gc_entry = (!strcmp(a->attr.name, \"gc_urgent\") ||",
          "287:      a->struct_type == GC_THREAD);",
          "291:  ret = __sbi_store(a, sbi, buf, count);",
          "292:  if (gc_entry)",
          "293:   up_read(&sbi->sb->s_umount);",
          "",
          "[Removed Lines]",
          "289:  if (gc_entry)",
          "290:   down_read(&sbi->sb->s_umount);",
          "",
          "[Added Lines]",
          "289:  if (gc_entry) {",
          "290:   if (!down_read_trylock(&sbi->sb->s_umount))",
          "291:    return -EAGAIN;",
          "292:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bfd40eaff5abb9f62c8ef94ca13ed0d94a560f10",
      "candidate_info": {
        "commit_hash": "bfd40eaff5abb9f62c8ef94ca13ed0d94a560f10",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bfd40eaff5abb9f62c8ef94ca13ed0d94a560f10",
        "files": [
          "drivers/char/mem.c",
          "fs/exec.c",
          "include/linux/mm.h",
          "mm/mmap.c",
          "mm/nommu.c"
        ],
        "message": "mm: fix vma_is_anonymous() false-positives\n\nvma_is_anonymous() relies on ->vm_ops being NULL to detect anonymous\nVMA.  This is unreliable as ->mmap may not set ->vm_ops.\n\nFalse-positive vma_is_anonymous() may lead to crashes:\n\n\tnext ffff8801ce5e7040 prev ffff8801d20eca50 mm ffff88019c1e13c0\n\tprot 27 anon_vma ffff88019680cdd8 vm_ops 0000000000000000\n\tpgoff 0 file ffff8801b2ec2d00 private_data 0000000000000000\n\tflags: 0xff(read|write|exec|shared|mayread|maywrite|mayexec|mayshare)\n\t------------[ cut here ]------------\n\tkernel BUG at mm/memory.c:1422!\n\tinvalid opcode: 0000 [#1] SMP KASAN\n\tCPU: 0 PID: 18486 Comm: syz-executor3 Not tainted 4.18.0-rc3+ #136\n\tHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google\n\t01/01/2011\n\tRIP: 0010:zap_pmd_range mm/memory.c:1421 [inline]\n\tRIP: 0010:zap_pud_range mm/memory.c:1466 [inline]\n\tRIP: 0010:zap_p4d_range mm/memory.c:1487 [inline]\n\tRIP: 0010:unmap_page_range+0x1c18/0x2220 mm/memory.c:1508\n\tCall Trace:\n\t unmap_single_vma+0x1a0/0x310 mm/memory.c:1553\n\t zap_page_range_single+0x3cc/0x580 mm/memory.c:1644\n\t unmap_mapping_range_vma mm/memory.c:2792 [inline]\n\t unmap_mapping_range_tree mm/memory.c:2813 [inline]\n\t unmap_mapping_pages+0x3a7/0x5b0 mm/memory.c:2845\n\t unmap_mapping_range+0x48/0x60 mm/memory.c:2880\n\t truncate_pagecache+0x54/0x90 mm/truncate.c:800\n\t truncate_setsize+0x70/0xb0 mm/truncate.c:826\n\t simple_setattr+0xe9/0x110 fs/libfs.c:409\n\t notify_change+0xf13/0x10f0 fs/attr.c:335\n\t do_truncate+0x1ac/0x2b0 fs/open.c:63\n\t do_sys_ftruncate+0x492/0x560 fs/open.c:205\n\t __do_sys_ftruncate fs/open.c:215 [inline]\n\t __se_sys_ftruncate fs/open.c:213 [inline]\n\t __x64_sys_ftruncate+0x59/0x80 fs/open.c:213\n\t do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290\n\t entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nReproducer:\n\n\t#include <stdio.h>\n\t#include <stddef.h>\n\t#include <stdint.h>\n\t#include <stdlib.h>\n\t#include <string.h>\n\t#include <sys/types.h>\n\t#include <sys/stat.h>\n\t#include <sys/ioctl.h>\n\t#include <sys/mman.h>\n\t#include <unistd.h>\n\t#include <fcntl.h>\n\n\t#define KCOV_INIT_TRACE\t\t\t_IOR('c', 1, unsigned long)\n\t#define KCOV_ENABLE\t\t\t_IO('c', 100)\n\t#define KCOV_DISABLE\t\t\t_IO('c', 101)\n\t#define COVER_SIZE\t\t\t(1024<<10)\n\n\t#define KCOV_TRACE_PC  0\n\t#define KCOV_TRACE_CMP 1\n\n\tint main(int argc, char **argv)\n\t{\n\t\tint fd;\n\t\tunsigned long *cover;\n\n\t\tsystem(\"mount -t debugfs none /sys/kernel/debug\");\n\t\tfd = open(\"/sys/kernel/debug/kcov\", O_RDWR);\n\t\tioctl(fd, KCOV_INIT_TRACE, COVER_SIZE);\n\t\tcover = mmap(NULL, COVER_SIZE * sizeof(unsigned long),\n\t\t\t\tPROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tmunmap(cover, COVER_SIZE * sizeof(unsigned long));\n\t\tcover = mmap(NULL, COVER_SIZE * sizeof(unsigned long),\n\t\t\t\tPROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\t\tmemset(cover, 0, COVER_SIZE * sizeof(unsigned long));\n\t\tftruncate(fd, 3UL << 20);\n\t\treturn 0;\n\t}\n\nThis can be fixed by assigning anonymous VMAs own vm_ops and not relying\non it being NULL.\n\nIf ->mmap() failed to set ->vm_ops, mmap_region() will set it to\ndummy_vm_ops.  This way we will have non-NULL ->vm_ops for all VMAs.\n\nLink: http://lkml.kernel.org/r/20180724121139.62570-4-kirill.shutemov@linux.intel.com\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nReported-by: syzbot+3f84280d52be9b7083cc@syzkaller.appspotmail.com\nAcked-by: Linus Torvalds <torvalds@linux-foundation.org>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "drivers/char/mem.c||drivers/char/mem.c",
          "fs/exec.c||fs/exec.c",
          "include/linux/mm.h||include/linux/mm.h",
          "mm/mmap.c||mm/mmap.c",
          "mm/nommu.c||mm/nommu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/char/mem.c||drivers/char/mem.c": [
          "File: drivers/char/mem.c -> drivers/char/mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "708: #endif",
          "709:  if (vma->vm_flags & VM_SHARED)",
          "710:   return shmem_zero_setup(vma);",
          "711:  return 0;",
          "712: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "711:  vma_set_anonymous(vma);",
          "",
          "---------------"
        ],
        "fs/exec.c||fs/exec.c": [
          "File: fs/exec.c -> fs/exec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "293:  bprm->vma = vma = vm_area_alloc(mm);",
          "294:  if (!vma)",
          "295:   return -ENOMEM;",
          "297:  if (down_write_killable(&mm->mmap_sem)) {",
          "298:   err = -EINTR;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "296:  vma_set_anonymous(vma);",
          "",
          "---------------"
        ],
        "include/linux/mm.h||include/linux/mm.h": [
          "File: include/linux/mm.h -> include/linux/mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "455: static inline void vma_init(struct vm_area_struct *vma, struct mm_struct *mm)",
          "456: {",
          "457:  vma->vm_mm = mm;",
          "458:  INIT_LIST_HEAD(&vma->anon_vma_chain);",
          "459: }",
          "461: struct mmu_gather;",
          "462: struct inode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:  static const struct vm_operations_struct dummy_vm_ops = {};",
          "460:  vma->vm_ops = &dummy_vm_ops;",
          "464: static inline void vma_set_anonymous(struct vm_area_struct *vma)",
          "465: {",
          "466:  vma->vm_ops = NULL;",
          "467: }",
          "",
          "---------------"
        ],
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1778:   error = shmem_zero_setup(vma);",
          "1779:   if (error)",
          "1780:    goto free_vma;",
          "1781:  }",
          "1783:  vma_link(mm, vma, prev, rb_link, rb_parent);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1781:  } else {",
          "1782:   vma_set_anonymous(vma);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2983:   return -ENOMEM;",
          "2984:  }",
          "2986:  vma->vm_start = addr;",
          "2987:  vma->vm_end = addr + len;",
          "2988:  vma->vm_pgoff = pgoff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2988:  vma_set_anonymous(vma);",
          "",
          "---------------"
        ],
        "mm/nommu.c||mm/nommu.c": [
          "File: mm/nommu.c -> mm/nommu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1145:   if (ret < len)",
          "1146:    memset(base + ret, 0, len - ret);",
          "1148:  }",
          "1150:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1148:  } else {",
          "1149:   vma_set_anonymous(vma);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71eb5255f55bdb484d35ff7c9a1803f453dfbf82",
      "candidate_info": {
        "commit_hash": "71eb5255f55bdb484d35ff7c9a1803f453dfbf82",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/71eb5255f55bdb484d35ff7c9a1803f453dfbf82",
        "files": [
          "net/core/lwt_bpf.c"
        ],
        "message": "bpf: use GFP_ATOMIC instead of GFP_KERNEL in bpf_parse_prog()\n\nbpf_parse_prog() is protected by rcu_read_lock().\nso that GFP_KERNEL is not allowed in the bpf_parse_prog().\n\n[51015.579396] =============================\n[51015.579418] WARNING: suspicious RCU usage\n[51015.579444] 4.18.0-rc6+ #208 Not tainted\n[51015.579464] -----------------------------\n[51015.579488] ./include/linux/rcupdate.h:303 Illegal context switch in RCU read-side critical section!\n[51015.579510] other info that might help us debug this:\n[51015.579532] rcu_scheduler_active = 2, debug_locks = 1\n[51015.579556] 2 locks held by ip/1861:\n[51015.579577]  #0: 00000000a8c12fd1 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x2e0/0x910\n[51015.579711]  #1: 00000000bf815f8e (rcu_read_lock){....}, at: lwtunnel_build_state+0x96/0x390\n[51015.579842] stack backtrace:\n[51015.579869] CPU: 0 PID: 1861 Comm: ip Not tainted 4.18.0-rc6+ #208\n[51015.579891] Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 07/08/2015\n[51015.579911] Call Trace:\n[51015.579950]  dump_stack+0x74/0xbb\n[51015.580000]  ___might_sleep+0x16b/0x3a0\n[51015.580047]  __kmalloc_track_caller+0x220/0x380\n[51015.580077]  kmemdup+0x1c/0x40\n[51015.580077]  bpf_parse_prog+0x10e/0x230\n[51015.580164]  ? kasan_kmalloc+0xa0/0xd0\n[51015.580164]  ? bpf_destroy_state+0x30/0x30\n[51015.580164]  ? bpf_build_state+0xe2/0x3e0\n[51015.580164]  bpf_build_state+0x1bb/0x3e0\n[51015.580164]  ? bpf_parse_prog+0x230/0x230\n[51015.580164]  ? lock_is_held_type+0x123/0x1a0\n[51015.580164]  lwtunnel_build_state+0x1aa/0x390\n[51015.580164]  fib_create_info+0x1579/0x33d0\n[51015.580164]  ? sched_clock_local+0xe2/0x150\n[51015.580164]  ? fib_info_update_nh_saddr+0x1f0/0x1f0\n[51015.580164]  ? sched_clock_local+0xe2/0x150\n[51015.580164]  fib_table_insert+0x201/0x1990\n[51015.580164]  ? lock_downgrade+0x610/0x610\n[51015.580164]  ? fib_table_lookup+0x1920/0x1920\n[51015.580164]  ? lwtunnel_valid_encap_type.part.6+0xcb/0x3a0\n[51015.580164]  ? rtm_to_fib_config+0x637/0xbd0\n[51015.580164]  inet_rtm_newroute+0xed/0x1b0\n[51015.580164]  ? rtm_to_fib_config+0xbd0/0xbd0\n[51015.580164]  rtnetlink_rcv_msg+0x331/0x910\n[ ... ]\n\nFixes: 3a0af8fd61f9 (\"bpf: BPF for lightweight tunnel infrastructure\")\nSigned-off-by: Taehee Yoo <ap420073@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "net/core/lwt_bpf.c||net/core/lwt_bpf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/core/lwt_bpf.c||net/core/lwt_bpf.c": [
          "File: net/core/lwt_bpf.c -> net/core/lwt_bpf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:  if (!tb[LWT_BPF_PROG_FD] || !tb[LWT_BPF_PROG_NAME])",
          "218:   return -EINVAL;",
          "221:  if (!prog->name)",
          "222:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "220:  prog->name = nla_memdup(tb[LWT_BPF_PROG_NAME], GFP_KERNEL);",
          "",
          "[Added Lines]",
          "220:  prog->name = nla_memdup(tb[LWT_BPF_PROG_NAME], GFP_ATOMIC);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9e630bcb7701f94dbd729fe57d37c089c763ad9f",
      "candidate_info": {
        "commit_hash": "9e630bcb7701f94dbd729fe57d37c089c763ad9f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9e630bcb7701f94dbd729fe57d37c089c763ad9f",
        "files": [
          "net/rds/ib_frmr.c",
          "net/rds/ib_mr.h",
          "net/rds/ib_rdma.c",
          "net/rds/rdma.c",
          "net/rds/rds.h",
          "net/rds/send.c"
        ],
        "message": "RDS: RDMA: Fix the NULL-ptr deref in rds_ib_get_mr\n\nRegistration of a memory region(MR) through FRMR/fastreg(unlike FMR)\nneeds a connection/qp. With a proxy qp, this dependency on connection\nwill be removed, but that needs more infrastructure patches, which is a\nwork in progress.\n\nAs an intermediate fix, the get_mr returns EOPNOTSUPP when connection\ndetails are not populated. The MR registration through sendmsg() will\ncontinue to work even with fast registration, since connection in this\ncase is formed upfront.\n\nThis patch fixes the following crash:\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 1 PID: 4244 Comm: syzkaller468044 Not tainted 4.16.0-rc6+ #361\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS\nGoogle 01/01/2011\nRIP: 0010:rds_ib_get_mr+0x5c/0x230 net/rds/ib_rdma.c:544\nRSP: 0018:ffff8801b059f890 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: ffff8801b07e1300 RCX: ffffffff8562d96e\nRDX: 000000000000000d RSI: 0000000000000001 RDI: 0000000000000068\nRBP: ffff8801b059f8b8 R08: ffffed0036274244 R09: ffff8801b13a1200\nR10: 0000000000000004 R11: ffffed0036274243 R12: ffff8801b13a1200\nR13: 0000000000000001 R14: ffff8801ca09fa9c R15: 0000000000000000\nFS:  00007f4d050af700(0000) GS:ffff8801db300000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f4d050aee78 CR3: 00000001b0d9b006 CR4: 00000000001606e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __rds_rdma_map+0x710/0x1050 net/rds/rdma.c:271\n rds_get_mr_for_dest+0x1d4/0x2c0 net/rds/rdma.c:357\n rds_setsockopt+0x6cc/0x980 net/rds/af_rds.c:347\n SYSC_setsockopt net/socket.c:1849 [inline]\n SyS_setsockopt+0x189/0x360 net/socket.c:1828\n do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287\n entry_SYSCALL_64_after_hwframe+0x42/0xb7\nRIP: 0033:0x4456d9\nRSP: 002b:00007f4d050aedb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00000000006dac3c RCX: 00000000004456d9\nRDX: 0000000000000007 RSI: 0000000000000114 RDI: 0000000000000004\nRBP: 00000000006dac38 R08: 00000000000000a0 R09: 0000000000000000\nR10: 0000000020000380 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fffbfb36d6f R14: 00007f4d050af9c0 R15: 0000000000000005\nCode: fa 48 c1 ea 03 80 3c 02 00 0f 85 cc 01 00 00 4c 8b bb 80 04 00 00\n48\nb8 00 00 00 00 00 fc ff df 49 8d 7f 68 48 89 fa 48 c1 ea 03 <80> 3c 02\n00 0f\n85 9c 01 00 00 4d 8b 7f 68 48 b8 00 00 00 00 00\nRIP: rds_ib_get_mr+0x5c/0x230 net/rds/ib_rdma.c:544 RSP:\nffff8801b059f890\n---[ end trace 7e1cea13b85473b0 ]---\n\nReported-by: syzbot+b51c77ef956678a65834@syzkaller.appspotmail.com\nSigned-off-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\nSigned-off-by: Avinash Repaka <avinash.repaka@oracle.com>\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/rds/ib_frmr.c||net/rds/ib_frmr.c",
          "net/rds/ib_mr.h||net/rds/ib_mr.h",
          "net/rds/ib_rdma.c||net/rds/ib_rdma.c",
          "net/rds/rdma.c||net/rds/rdma.c",
          "net/rds/rds.h||net/rds/rds.h",
          "net/rds/send.c||net/rds/send.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/rds/ib_frmr.c||net/rds/ib_frmr.c": [
          "File: net/rds/ib_frmr.c -> net/rds/ib_frmr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "344:  struct rds_ib_frmr *frmr;",
          "345:  int ret;",
          "347:  do {",
          "348:   if (ibmr)",
          "349:    rds_ib_free_frmr(ibmr, true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "347:  if (!ic) {",
          "349:   return ERR_PTR(-EOPNOTSUPP);",
          "350:  }",
          "",
          "---------------"
        ],
        "net/rds/ib_mr.h||net/rds/ib_mr.h": [
          "File: net/rds/ib_mr.h -> net/rds/ib_mr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:    struct rds_info_rdma_connection *iinfo);",
          "116: void rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *);",
          "117: void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,",
          "119: void rds_ib_sync_mr(void *trans_private, int dir);",
          "120: void rds_ib_free_mr(void *trans_private, int invalidate);",
          "121: void rds_ib_flush_mrs(void);",
          "",
          "[Removed Lines]",
          "118:       struct rds_sock *rs, u32 *key_ret);",
          "",
          "[Added Lines]",
          "118:       struct rds_sock *rs, u32 *key_ret,",
          "119:       struct rds_connection *conn);",
          "",
          "---------------"
        ],
        "net/rds/ib_rdma.c||net/rds/ib_rdma.c": [
          "File: net/rds/ib_rdma.c -> net/rds/ib_rdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "537: }",
          "539: void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,",
          "541: {",
          "542:  struct rds_ib_device *rds_ibdev;",
          "543:  struct rds_ib_mr *ibmr = NULL;",
          "545:  int ret;",
          "547:  rds_ibdev = rds_ib_get_device(rs->rs_bound_addr);",
          "",
          "[Removed Lines]",
          "540:       struct rds_sock *rs, u32 *key_ret)",
          "544:  struct rds_ib_connection *ic = rs->rs_conn->c_transport_data;",
          "",
          "[Added Lines]",
          "540:       struct rds_sock *rs, u32 *key_ret,",
          "541:       struct rds_connection *conn)",
          "545:  struct rds_ib_connection *ic = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "550:   goto out;",
          "551:  }",
          "553:  if (!rds_ibdev->mr_8k_pool || !rds_ibdev->mr_1m_pool) {",
          "554:   ret = -ENODEV;",
          "555:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "554:  if (conn)",
          "555:   ic = conn->c_transport_data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "559:   ibmr = rds_ib_reg_frmr(rds_ibdev, ic, sg, nents, key_ret);",
          "560:  else",
          "561:   ibmr = rds_ib_reg_fmr(rds_ibdev, sg, nents, key_ret);",
          "567:   pr_warn(\"RDS/IB: rds_ib_get_mr failed (errno=%d)\\n\", ret);",
          "569:  if (rds_ibdev)",
          "570:   rds_ib_dev_put(rds_ibdev);",
          "573: }",
          "575: void rds_ib_destroy_mr_pool(struct rds_ib_mr_pool *pool)",
          "",
          "[Removed Lines]",
          "562:  if (ibmr)",
          "563:   rds_ibdev = NULL;",
          "565:  out:",
          "566:  if (!ibmr)",
          "572:  return ibmr;",
          "",
          "[Added Lines]",
          "566:  if (IS_ERR(ibmr)) {",
          "567:   ret = PTR_ERR(ibmr);",
          "569:  } else {",
          "570:   return ibmr;",
          "571:  }",
          "573:  out:",
          "577:  return ERR_PTR(ret);",
          "",
          "---------------"
        ],
        "net/rds/rdma.c||net/rds/rdma.c": [
          "File: net/rds/rdma.c -> net/rds/rdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: }",
          "172: static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,",
          "174: {",
          "175:  struct rds_mr *mr = NULL, *found;",
          "176:  unsigned int nr_pages;",
          "",
          "[Removed Lines]",
          "173:     u64 *cookie_ret, struct rds_mr **mr_ret)",
          "",
          "[Added Lines]",
          "173:      u64 *cookie_ret, struct rds_mr **mr_ret,",
          "174:      struct rds_conn_path *cp)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:  trans_private = rs->rs_transport->get_mr(sg, nents, rs,",
          "274:  if (IS_ERR(trans_private)) {",
          "275:   for (i = 0 ; i < nents; i++)",
          "",
          "[Removed Lines]",
          "272:        &mr->r_key);",
          "",
          "[Added Lines]",
          "273:        &mr->r_key,",
          "274:        cp ? cp->cp_conn : NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330:       sizeof(struct rds_get_mr_args)))",
          "331:   return -EFAULT;",
          "334: }",
          "336: int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)",
          "",
          "[Removed Lines]",
          "333:  return __rds_rdma_map(rs, &args, NULL, NULL);",
          "",
          "[Added Lines]",
          "335:  return __rds_rdma_map(rs, &args, NULL, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "354:  new_args.cookie_addr = args.cookie_addr;",
          "355:  new_args.flags = args.flags;",
          "358: }",
          "",
          "[Removed Lines]",
          "357:  return __rds_rdma_map(rs, &new_args, NULL, NULL);",
          "",
          "[Added Lines]",
          "359:  return __rds_rdma_map(rs, &new_args, NULL, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "782:      rm->m_rdma_cookie != 0)",
          "783:   return -EINVAL;",
          "786: }",
          "",
          "[Removed Lines]",
          "785:  return __rds_rdma_map(rs, CMSG_DATA(cmsg), &rm->m_rdma_cookie, &rm->rdma.op_rdma_mr);",
          "",
          "[Added Lines]",
          "787:  return __rds_rdma_map(rs, CMSG_DATA(cmsg), &rm->m_rdma_cookie,",
          "788:          &rm->rdma.op_rdma_mr, rm->m_conn_path);",
          "",
          "---------------"
        ],
        "net/rds/rds.h||net/rds/rds.h": [
          "File: net/rds/rds.h -> net/rds/rds.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "464:    struct scatterlist *op_sg;",
          "465:   } data;",
          "466:  };",
          "467: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468:  struct rds_conn_path *m_conn_path;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "544:      unsigned int avail);",
          "545:  void (*exit)(void);",
          "546:  void *(*get_mr)(struct scatterlist *sg, unsigned long nr_sg,",
          "548:  void (*sync_mr)(void *trans_private, int direction);",
          "549:  void (*free_mr)(void *trans_private, int invalidate);",
          "550:  void (*flush_mrs)(void);",
          "",
          "[Removed Lines]",
          "547:    struct rds_sock *rs, u32 *key_ret);",
          "",
          "[Added Lines]",
          "549:    struct rds_sock *rs, u32 *key_ret,",
          "550:    struct rds_connection *conn);",
          "",
          "---------------"
        ],
        "net/rds/send.c||net/rds/send.c": [
          "File: net/rds/send.c -> net/rds/send.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1169:   rs->rs_conn = conn;",
          "1170:  }",
          "1173:  ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);",
          "1174:  if (ret) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1172:  if (conn->c_trans->t_mp_capable)",
          "1173:   cpath = &conn->c_path[rds_send_mprds_hash(rs, conn)];",
          "1174:  else",
          "1175:   cpath = &conn->c_path[0];",
          "1177:  rm->m_conn_path = cpath;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1192:   goto out;",
          "1193:  }",
          "1200:  if (rds_destroy_pending(conn)) {",
          "1201:   ret = -EAGAIN;",
          "1202:   goto out;",
          "",
          "[Removed Lines]",
          "1195:  if (conn->c_trans->t_mp_capable)",
          "1196:   cpath = &conn->c_path[rds_send_mprds_hash(rs, conn)];",
          "1197:  else",
          "1198:   cpath = &conn->c_path[0];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
      "candidate_info": {
        "commit_hash": "76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2",
        "files": [
          "fs/f2fs/inode.c"
        ],
        "message": "f2fs: fix to do sanity check with extra_attr feature\n\nIf FI_EXTRA_ATTR is set in inode by fuzzing, inode.i_addr[0] will be\nparsed as inode.i_extra_isize, then in __recover_inline_status, inline\ndata address will beyond boundary of page, result in accessing invalid\nmemory.\n\nSo in this condition, during reading inode page, let's do sanity check\nwith EXTRA_ATTR feature of fs and extra_attr bit of inode, if they're\ninconsistent, deny to load this inode.\n\n- Overview\nOut-of-bound access in f2fs_iget() when mounting a corrupted f2fs image\n\n- Reproduce\n\nThe following message will be got in KASAN build of 4.18 upstream kernel.\n[  819.392227] ==================================================================\n[  819.393901] BUG: KASAN: slab-out-of-bounds in f2fs_iget+0x736/0x1530\n[  819.395329] Read of size 4 at addr ffff8801f099c968 by task mount/1292\n\n[  819.397079] CPU: 1 PID: 1292 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  819.397082] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  819.397088] Call Trace:\n[  819.397124]  dump_stack+0x7b/0xb5\n[  819.397154]  print_address_description+0x70/0x290\n[  819.397159]  kasan_report+0x291/0x390\n[  819.397163]  ? f2fs_iget+0x736/0x1530\n[  819.397176]  check_memory_region+0x139/0x190\n[  819.397182]  __asan_loadN+0xf/0x20\n[  819.397185]  f2fs_iget+0x736/0x1530\n[  819.397197]  f2fs_fill_super+0x1b4f/0x2b40\n[  819.397202]  ? f2fs_fill_super+0x1b4f/0x2b40\n[  819.397208]  ? f2fs_commit_super+0x1b0/0x1b0\n[  819.397227]  ? set_blocksize+0x90/0x140\n[  819.397241]  mount_bdev+0x1c5/0x210\n[  819.397245]  ? f2fs_commit_super+0x1b0/0x1b0\n[  819.397252]  f2fs_mount+0x15/0x20\n[  819.397256]  mount_fs+0x60/0x1a0\n[  819.397267]  ? alloc_vfsmnt+0x309/0x360\n[  819.397272]  vfs_kern_mount+0x6b/0x1a0\n[  819.397282]  do_mount+0x34a/0x18c0\n[  819.397300]  ? lockref_put_or_lock+0xcf/0x160\n[  819.397306]  ? copy_mount_string+0x20/0x20\n[  819.397318]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  819.397324]  ? kasan_check_write+0x14/0x20\n[  819.397334]  ? _copy_from_user+0x6a/0x90\n[  819.397353]  ? memdup_user+0x42/0x60\n[  819.397359]  ksys_mount+0x83/0xd0\n[  819.397365]  __x64_sys_mount+0x67/0x80\n[  819.397388]  do_syscall_64+0x78/0x170\n[  819.397403]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  819.397422] RIP: 0033:0x7f54c667cb9a\n[  819.397424] Code: 48 8b 0d 01 c3 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d ce c2 2b 00 f7 d8 64 89 01 48\n[  819.397483] RSP: 002b:00007ffd8f46cd08 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5\n[  819.397496] RAX: ffffffffffffffda RBX: 0000000000dfa030 RCX: 00007f54c667cb9a\n[  819.397498] RDX: 0000000000dfa210 RSI: 0000000000dfbf30 RDI: 0000000000e02ec0\n[  819.397501] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  819.397503] R10: 00000000c0ed0000 R11: 0000000000000202 R12: 0000000000e02ec0\n[  819.397505] R13: 0000000000dfa210 R14: 0000000000000000 R15: 0000000000000003\n\n[  819.397866] Allocated by task 139:\n[  819.398702]  save_stack+0x46/0xd0\n[  819.398705]  kasan_kmalloc+0xad/0xe0\n[  819.398709]  kasan_slab_alloc+0x11/0x20\n[  819.398713]  kmem_cache_alloc+0xd1/0x1e0\n[  819.398717]  dup_fd+0x50/0x4c0\n[  819.398740]  copy_process.part.37+0xbed/0x32e0\n[  819.398744]  _do_fork+0x16e/0x590\n[  819.398748]  __x64_sys_clone+0x69/0x80\n[  819.398752]  do_syscall_64+0x78/0x170\n[  819.398756]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[  819.399097] Freed by task 159:\n[  819.399743]  save_stack+0x46/0xd0\n[  819.399747]  __kasan_slab_free+0x13c/0x1a0\n[  819.399750]  kasan_slab_free+0xe/0x10\n[  819.399754]  kmem_cache_free+0x89/0x1e0\n[  819.399757]  put_files_struct+0x132/0x150\n[  819.399761]  exit_files+0x62/0x70\n[  819.399766]  do_exit+0x47b/0x1390\n[  819.399770]  do_group_exit+0x86/0x130\n[  819.399774]  __x64_sys_exit_group+0x2c/0x30\n[  819.399778]  do_syscall_64+0x78/0x170\n[  819.399782]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[  819.400115] The buggy address belongs to the object at ffff8801f099c680\n                which belongs to the cache files_cache of size 704\n[  819.403234] The buggy address is located 40 bytes to the right of\n                704-byte region [ffff8801f099c680, ffff8801f099c940)\n[  819.405689] The buggy address belongs to the page:\n[  819.406709] page:ffffea0007c26700 count:1 mapcount:0 mapping:ffff8801f69a3340 index:0xffff8801f099d380 compound_mapcount: 0\n[  819.408984] flags: 0x2ffff0000008100(slab|head)\n[  819.409932] raw: 02ffff0000008100 ffffea00077fb600 0000000200000002 ffff8801f69a3340\n[  819.411514] raw: ffff8801f099d380 0000000080130000 00000001ffffffff 0000000000000000\n[  819.413073] page dumped because: kasan: bad access detected\n\n[  819.414539] Memory state around the buggy address:\n[  819.415521]  ffff8801f099c800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.416981]  ffff8801f099c880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.418454] >ffff8801f099c900: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc\n[  819.419921]                                                           ^\n[  819.421265]  ffff8801f099c980: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n[  819.422745]  ffff8801f099ca00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[  819.424206] ==================================================================\n[  819.425668] Disabling lock debugging due to kernel taint\n[  819.457463] F2FS-fs (loop0): Mounted with checkpoint version = 3\n\nThe kernel still mounts the image. If you run the following program on the mounted folder mnt,\n\n(poc.c)\n\nstatic void activity(char *mpoint) {\n\n  char *foo_bar_baz;\n  int err;\n\n  static int buf[8192];\n  memset(buf, 0, sizeof(buf));\n\n  err = asprintf(&foo_bar_baz, \"%s/foo/bar/baz\", mpoint);\n    int fd = open(foo_bar_baz, O_RDONLY, 0);\n  if (fd >= 0) {\n      read(fd, (char *)buf, 11);\n      close(fd);\n  }\n}\n\nint main(int argc, char *argv[]) {\n  activity(argv[1]);\n  return 0;\n}\n\nYou can get kernel crash:\n[  819.457463] F2FS-fs (loop0): Mounted with checkpoint version = 3\n[  918.028501] BUG: unable to handle kernel paging request at ffffed0048000d82\n[  918.044020] PGD 23ffee067 P4D 23ffee067 PUD 23fbef067 PMD 0\n[  918.045207] Oops: 0000 [#1] SMP KASAN PTI\n[  918.046048] CPU: 0 PID: 1309 Comm: poc Tainted: G    B             4.18.0-rc1+ #4\n[  918.047573] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  918.049552] RIP: 0010:check_memory_region+0x5e/0x190\n[  918.050565] Code: f8 49 c1 e8 03 49 89 db 49 c1 eb 03 4d 01 cb 4d 01 c1 4d 8d 63 01 4c 89 c8 4d 89 e2 4d 29 ca 49 83 fa 10 7f 3d 4d 85 d2 74 32 <41> 80 39 00 75 23 48 b8 01 00 00 00 00 fc ff df 4d 01 d1 49 01 c0\n[  918.054322] RSP: 0018:ffff8801e3a1f258 EFLAGS: 00010202\n[  918.055400] RAX: ffffed0048000d82 RBX: ffff880240006c11 RCX: ffffffffb8867d14\n[  918.056832] RDX: 0000000000000000 RSI: 0000000000000002 RDI: ffff880240006c10\n[  918.058253] RBP: ffff8801e3a1f268 R08: 1ffff10048000d82 R09: ffffed0048000d82\n[  918.059717] R10: 0000000000000001 R11: ffffed0048000d82 R12: ffffed0048000d83\n[  918.061159] R13: ffff8801e3a1f390 R14: 0000000000000000 R15: ffff880240006c08\n[  918.062614] FS:  00007fac9732c700(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  918.064246] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  918.065412] CR2: ffffed0048000d82 CR3: 00000001df77a000 CR4: 00000000000006f0\n[  918.066882] Call Trace:\n[  918.067410]  __asan_loadN+0xf/0x20\n[  918.068149]  f2fs_find_target_dentry+0xf4/0x270\n[  918.069083]  ? __get_node_page+0x331/0x5b0\n[  918.069925]  f2fs_find_in_inline_dir+0x24b/0x310\n[  918.070881]  ? f2fs_recover_inline_data+0x4c0/0x4c0\n[  918.071905]  ? unwind_next_frame.part.5+0x34f/0x490\n[  918.072901]  ? unwind_dump+0x290/0x290\n[  918.073695]  ? is_bpf_text_address+0xe/0x20\n[  918.074566]  __f2fs_find_entry+0x599/0x670\n[  918.075408]  ? kasan_unpoison_shadow+0x36/0x50\n[  918.076315]  ? kasan_kmalloc+0xad/0xe0\n[  918.077100]  ? memcg_kmem_put_cache+0x55/0xa0\n[  918.077998]  ? f2fs_find_target_dentry+0x270/0x270\n[  918.079006]  ? d_set_d_op+0x30/0x100\n[  918.079749]  ? __d_lookup_rcu+0x69/0x2e0\n[  918.080556]  ? __d_alloc+0x275/0x450\n[  918.081297]  ? kasan_check_write+0x14/0x20\n[  918.082135]  ? memset+0x31/0x40\n[  918.082820]  ? fscrypt_setup_filename+0x1ec/0x4c0\n[  918.083782]  ? d_alloc_parallel+0x5bb/0x8c0\n[  918.084640]  f2fs_find_entry+0xe9/0x110\n[  918.085432]  ? __f2fs_find_entry+0x670/0x670\n[  918.086308]  ? kasan_check_write+0x14/0x20\n[  918.087163]  f2fs_lookup+0x297/0x590\n[  918.087902]  ? f2fs_link+0x2b0/0x2b0\n[  918.088646]  ? legitimize_path.isra.29+0x61/0xa0\n[  918.089589]  __lookup_slow+0x12e/0x240\n[  918.090371]  ? may_delete+0x2b0/0x2b0\n[  918.091123]  ? __nd_alloc_stack+0xa0/0xa0\n[  918.091944]  lookup_slow+0x44/0x60\n[  918.092642]  walk_component+0x3ee/0xa40\n[  918.093428]  ? is_bpf_text_address+0xe/0x20\n[  918.094283]  ? pick_link+0x3e0/0x3e0\n[  918.095047]  ? in_group_p+0xa5/0xe0\n[  918.095771]  ? generic_permission+0x53/0x1e0\n[  918.096666]  ? security_inode_permission+0x1d/0x70\n[  918.097646]  ? inode_permission+0x7a/0x1f0\n[  918.098497]  link_path_walk+0x2a2/0x7b0\n[  918.099298]  ? apparmor_capget+0x3d0/0x3d0\n[  918.100140]  ? walk_component+0xa40/0xa40\n[  918.100958]  ? path_init+0x2e6/0x580\n[  918.101695]  path_openat+0x1bb/0x2160\n[  918.102471]  ? __save_stack_trace+0x92/0x100\n[  918.103352]  ? save_stack+0xb5/0xd0\n[  918.104070]  ? vfs_unlink+0x250/0x250\n[  918.104822]  ? save_stack+0x46/0xd0\n[  918.105538]  ? kasan_slab_alloc+0x11/0x20\n[  918.106370]  ? kmem_cache_alloc+0xd1/0x1e0\n[  918.107213]  ? getname_flags+0x76/0x2c0\n[  918.107997]  ? getname+0x12/0x20\n[  918.108677]  ? do_sys_open+0x14b/0x2c0\n[  918.109450]  ? __x64_sys_open+0x4c/0x60\n[  918.110255]  ? do_syscall_64+0x78/0x170\n[  918.111083]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.112148]  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.113204]  ? f2fs_empty_inline_dir+0x1e0/0x1e0\n[  918.114150]  ? timespec64_trunc+0x5c/0x90\n[  918.114993]  ? wb_io_lists_depopulated+0x1a/0xc0\n[  918.115937]  ? inode_io_list_move_locked+0x102/0x110\n[  918.116949]  do_filp_open+0x12b/0x1d0\n[  918.117709]  ? may_open_dev+0x50/0x50\n[  918.118475]  ? kasan_kmalloc+0xad/0xe0\n[  918.119246]  do_sys_open+0x17c/0x2c0\n[  918.119983]  ? do_sys_open+0x17c/0x2c0\n[  918.120751]  ? filp_open+0x60/0x60\n[  918.121463]  ? task_work_run+0x4d/0xf0\n[  918.122237]  __x64_sys_open+0x4c/0x60\n[  918.123001]  do_syscall_64+0x78/0x170\n[  918.123759]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  918.124802] RIP: 0033:0x7fac96e3e040\n[  918.125537] Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 83 3d 09 27 2d 00 00 75 10 b8 02 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 7e e0 01 00 48 89 04 24\n[  918.129341] RSP: 002b:00007fff1b37f848 EFLAGS: 00000246 ORIG_RAX: 0000000000000002\n[  918.130870] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fac96e3e040\n[  918.132295] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 000000000122d080\n[  918.133748] RBP: 00007fff1b37f9b0 R08: 00007fac9710bbd8 R09: 0000000000000001\n[  918.135209] R10: 000000000000069d R11: 0000000000000246 R12: 0000000000400c20\n[  918.136650] R13: 00007fff1b37fab0 R14: 0000000000000000 R15: 0000000000000000\n[  918.138093] Modules linked in: snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd mac_hid i2c_piix4 soundcore ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid1 raid0 multipath linear 8139too crct10dif_pclmul crc32_pclmul qxl drm_kms_helper syscopyarea aesni_intel sysfillrect sysimgblt fb_sys_fops ttm drm aes_x86_64 crypto_simd cryptd 8139cp glue_helper mii pata_acpi floppy\n[  918.147924] CR2: ffffed0048000d82\n[  918.148619] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  918.149563] RIP: 0010:check_memory_region+0x5e/0x190\n[  918.150576] Code: f8 49 c1 e8 03 49 89 db 49 c1 eb 03 4d 01 cb 4d 01 c1 4d 8d 63 01 4c 89 c8 4d 89 e2 4d 29 ca 49 83 fa 10 7f 3d 4d 85 d2 74 32 <41> 80 39 00 75 23 48 b8 01 00 00 00 00 fc ff df 4d 01 d1 49 01 c0\n[  918.154360] RSP: 0018:ffff8801e3a1f258 EFLAGS: 00010202\n[  918.155411] RAX: ffffed0048000d82 RBX: ffff880240006c11 RCX: ffffffffb8867d14\n[  918.156833] RDX: 0000000000000000 RSI: 0000000000000002 RDI: ffff880240006c10\n[  918.158257] RBP: ffff8801e3a1f268 R08: 1ffff10048000d82 R09: ffffed0048000d82\n[  918.159722] R10: 0000000000000001 R11: ffffed0048000d82 R12: ffffed0048000d83\n[  918.161149] R13: ffff8801e3a1f390 R14: 0000000000000000 R15: ffff880240006c08\n[  918.162587] FS:  00007fac9732c700(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  918.164203] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  918.165356] CR2: ffffed0048000d82 CR3: 00000001df77a000 CR4: 00000000000006f0\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/inode.c||fs/f2fs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/inode.c||fs/f2fs/inode.c": [
          "File: fs/f2fs/inode.c -> fs/f2fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:    __func__, inode->i_ino);",
          "206:   return false;",
          "207:  }",
          "208:  return true;",
          "209: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:  if (f2fs_has_extra_attr(inode) &&",
          "210:    !f2fs_sb_has_extra_attr(sbi->sb)) {",
          "211:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "212:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "213:    \"%s: inode (ino=%lx) is with extra_attr, \"",
          "214:    \"but extra_attr feature is off\",",
          "215:    __func__, inode->i_ino);",
          "216:   return false;",
          "217:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "258:  get_inline_info(inode, ri);",
          "260:  fi->i_extra_isize = f2fs_has_extra_attr(inode) ?",
          "261:      le16_to_cpu(ri->i_extra_isize) : 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:  if (!sanity_check_inode(inode)) {",
          "271:   f2fs_put_page(node_page, 1);",
          "272:   return -EINVAL;",
          "273:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "338:  ret = do_read_inode(inode);",
          "339:  if (ret)",
          "340:   goto bad_inode;",
          "345: make_now:",
          "346:  if (ino == F2FS_NODE_INO(sbi)) {",
          "347:   inode->i_mapping->a_ops = &f2fs_node_aops;",
          "",
          "[Removed Lines]",
          "341:  if (!sanity_check_inode(inode)) {",
          "342:   ret = -EINVAL;",
          "343:   goto bad_inode;",
          "344:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
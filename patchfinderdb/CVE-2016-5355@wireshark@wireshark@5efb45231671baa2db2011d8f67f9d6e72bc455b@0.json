{
  "cve_id": "CVE-2016-5355",
  "cve_desc": "wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",
  "repo": "wireshark/wireshark",
  "patch_hash": "5efb45231671baa2db2011d8f67f9d6e72bc455b",
  "patch_info": {
    "commit_hash": "5efb45231671baa2db2011d8f67f9d6e72bc455b",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/5efb45231671baa2db2011d8f67f9d6e72bc455b",
    "files": [
      "wiretap/toshiba.c"
    ],
    "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90\nReviewed-on: https://code.wireshark.org/review/15169\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "wiretap/toshiba.c||wiretap/toshiba.c"
    ]
  },
  "patch_diff": {
    "wiretap/toshiba.c||wiretap/toshiba.c": [
      "File: wiretap/toshiba.c -> wiretap/toshiba.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "98: static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };",
      "99: #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])",
      "106: static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,",
      "107:  gint64 *data_offset);",
      "108: static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,",
      "",
      "[Removed Lines]",
      "104: #define TOSHIBA_MAX_PACKET_LEN 16384",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "253:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "254:  char line[TOSHIBA_LINE_LENGTH];",
      "255:  int num_items_scanned;",
      "257:  char channel[10], direction[10];",
      "258:  int i, hex_lines;",
      "259:  guint8 *pd;",
      "",
      "[Removed Lines]",
      "256:  int pkt_len, pktnum, hr, min, sec, csec;",
      "",
      "[Added Lines]",
      "251:  guint pkt_len;",
      "252:  int pktnum, hr, min, sec, csec;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "306:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
      "309:  if (num_items_scanned != 1) {",
      "312:   return FALSE;",
      "313:  }",
      "315:  phdr->rec_type = REC_TYPE_PACKET;",
      "316:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
      "",
      "[Removed Lines]",
      "308:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
      "",
      "[Added Lines]",
      "304:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
      "310:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
      "317:       pkt_len, WTAP_MAX_PACKET_SIZE);",
      "318:   return FALSE;",
      "319:  }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "341:  }",
      "345:  pd = ws_buffer_start_ptr(buf);",
      "",
      "[Removed Lines]",
      "344:  ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);",
      "",
      "[Added Lines]",
      "350:  ws_buffer_assure_space(buf, pkt_len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f94b8feb63b77276d27d0e350014548b6287039f",
      "candidate_info": {
        "commit_hash": "f94b8feb63b77276d27d0e350014548b6287039f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/f94b8feb63b77276d27d0e350014548b6287039f",
        "files": [
          "wiretap/toshiba.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90\nReviewed-on: https://code.wireshark.org/review/15169\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 5efb45231671baa2db2011d8f67f9d6e72bc455b)\nReviewed-on: https://code.wireshark.org/review/15170",
        "before_after_code_files": [
          "wiretap/toshiba.c||wiretap/toshiba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ],
          "candidate": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98: static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };",
          "99: #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])",
          "106: static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,",
          "107:  gint64 *data_offset);",
          "108: static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,",
          "",
          "[Removed Lines]",
          "104: #define TOSHIBA_MAX_PACKET_LEN 16384",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "253:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "254:  char line[TOSHIBA_LINE_LENGTH];",
          "255:  int num_items_scanned;",
          "257:  char channel[10], direction[10];",
          "258:  int i, hex_lines;",
          "259:  guint8 *pd;",
          "",
          "[Removed Lines]",
          "256:  int pkt_len, pktnum, hr, min, sec, csec;",
          "",
          "[Added Lines]",
          "251:  guint pkt_len;",
          "252:  int pktnum, hr, min, sec, csec;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "306:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
          "309:  if (num_items_scanned != 1) {",
          "312:   return FALSE;",
          "313:  }",
          "315:  phdr->rec_type = REC_TYPE_PACKET;",
          "316:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "308:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
          "",
          "[Added Lines]",
          "304:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
          "310:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "317:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "318:   return FALSE;",
          "319:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:  }",
          "345:  pd = ws_buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "344:  ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "350:  ws_buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3270dfac43da861c714df76513456b46765ff47f",
      "candidate_info": {
        "commit_hash": "3270dfac43da861c714df76513456b46765ff47f",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f",
        "files": [
          "wiretap/toshiba.c"
        ],
        "message": "Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https://code.wireshark.org/review/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/toshiba.c||wiretap/toshiba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ],
          "candidate": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "248:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "249:  char line[TOSHIBA_LINE_LENGTH];",
          "250:  int num_items_scanned;",
          "253:  char channel[10], direction[10];",
          "254:  int i, hex_lines;",
          "255:  guint8 *pd;",
          "",
          "[Removed Lines]",
          "251:  guint pkt_len;",
          "252:  int pktnum, hr, min, sec, csec;",
          "",
          "[Added Lines]",
          "251:  int pkt_len, pktnum, hr, min, sec, csec;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "302:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
          "305:  if (num_items_scanned != 1) {",
          "308:   return FALSE;",
          "309:  }",
          "310:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "",
          "[Removed Lines]",
          "304:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
          "",
          "[Added Lines]",
          "303:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
          "309:  if (pkt_len < 0) {",
          "312:   return FALSE;",
          "313:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "303680c3eae0263854c80845a660a1784d731533",
      "candidate_info": {
        "commit_hash": "303680c3eae0263854c80845a660a1784d731533",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/303680c3eae0263854c80845a660a1784d731533",
        "files": [
          "wiretap/toshiba.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: If0b79376fc6fe2f49c7b7d7796dee7b7683485cb\nReviewed-on: https://code.wireshark.org/review/15171\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/toshiba.c||wiretap/toshiba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ],
          "candidate": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };",
          "101: #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])",
          "108: static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,",
          "109:  gint64 *data_offset);",
          "110: static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,",
          "",
          "[Removed Lines]",
          "106: #define TOSHIBA_MAX_PACKET_LEN 16384",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "256:  char line[TOSHIBA_LINE_LENGTH];",
          "257:  int num_items_scanned;",
          "259:  char channel[10], direction[10];",
          "260:  int i, hex_lines;",
          "261:  guint8 *pd;",
          "",
          "[Removed Lines]",
          "258:  int pkt_len, pktnum, hr, min, sec, csec;",
          "",
          "[Added Lines]",
          "253:  guint pkt_len;",
          "254:  int pktnum, hr, min, sec, csec;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
          "311:  if (num_items_scanned != 1) {",
          "314:   return FALSE;",
          "315:  }",
          "317:  phdr->rec_type = REC_TYPE_PACKET;",
          "318:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "310:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
          "",
          "[Added Lines]",
          "306:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
          "312:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "319:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "320:   return FALSE;",
          "321:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "343:  }",
          "347:  pd = buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "346:  buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "352:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a8ed46c02e2aad04b30ccaf916b4ad553e28467",
      "candidate_info": {
        "commit_hash": "1a8ed46c02e2aad04b30ccaf916b4ad553e28467",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1a8ed46c02e2aad04b30ccaf916b4ad553e28467",
        "files": [
          "wiretap/toshiba.c"
        ],
        "message": "Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: If0b79376fc6fe2f49c7b7d7796dee7b7683485cb\nReviewed-on: https://code.wireshark.org/review/15171\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n(cherry picked from commit 303680c3eae0263854c80845a660a1784d731533)\nReviewed-on: https://code.wireshark.org/review/16111\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "wiretap/toshiba.c||wiretap/toshiba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ],
          "candidate": [
            "wiretap/toshiba.c||wiretap/toshiba.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };",
          "101: #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])",
          "108: static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,",
          "109:  gint64 *data_offset);",
          "110: static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,",
          "",
          "[Removed Lines]",
          "106: #define TOSHIBA_MAX_PACKET_LEN 16384",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255:  union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "256:  char line[TOSHIBA_LINE_LENGTH];",
          "257:  int num_items_scanned;",
          "259:  char channel[10], direction[10];",
          "260:  int i, hex_lines;",
          "261:  guint8 *pd;",
          "",
          "[Removed Lines]",
          "258:  int pkt_len, pktnum, hr, min, sec, csec;",
          "",
          "[Added Lines]",
          "253:  guint pkt_len;",
          "254:  int pktnum, hr, min, sec, csec;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:  } while (strcmp(line, \"OFFSET 0001-0203\") != 0);",
          "311:  if (num_items_scanned != 1) {",
          "314:   return FALSE;",
          "315:  }",
          "317:  phdr->rec_type = REC_TYPE_PACKET;",
          "318:  phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "",
          "[Removed Lines]",
          "310:  num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);",
          "",
          "[Added Lines]",
          "306:  num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);",
          "312:  if (pkt_len > WTAP_MAX_PACKET_SIZE) {",
          "319:       pkt_len, WTAP_MAX_PACKET_SIZE);",
          "320:   return FALSE;",
          "321:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "343:  }",
          "347:  pd = buffer_start_ptr(buf);",
          "",
          "[Removed Lines]",
          "346:  buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);",
          "",
          "[Added Lines]",
          "352:  buffer_assure_space(buf, pkt_len);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
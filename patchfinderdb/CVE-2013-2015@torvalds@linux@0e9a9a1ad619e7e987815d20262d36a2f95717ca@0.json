{
  "cve_id": "CVE-2013-2015",
  "cve_desc": "The ext4_orphan_del function in fs/ext4/namei.c in the Linux kernel before 3.7.3 does not properly handle orphan-list entries for non-journal filesystems, which allows physically proximate attackers to cause a denial of service (system hang) via a crafted filesystem on removable media, as demonstrated by the e2fsprogs tests/f_orphan_extents_inode/image.gz test.",
  "repo": "torvalds/linux",
  "patch_hash": "0e9a9a1ad619e7e987815d20262d36a2f95717ca",
  "patch_info": {
    "commit_hash": "0e9a9a1ad619e7e987815d20262d36a2f95717ca",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca",
    "files": [
      "fs/ext4/namei.c"
    ],
    "message": "ext4: avoid hang when mounting non-journal filesystems with orphan list\n\nWhen trying to mount a file system which does not contain a journal,\nbut which does have a orphan list containing an inode which needs to\nbe truncated, the mount call with hang forever in\next4_orphan_cleanup() because ext4_orphan_del() will return\nimmediately without removing the inode from the orphan list, leading\nto an uninterruptible loop in kernel code which will busy out one of\nthe CPU's on the system.\n\nThis can be trivially reproduced by trying to mount the file system\nfound in tests/f_orphan_extents_inode/image.gz from the e2fsprogs\nsource tree.  If a malicious user were to put this on a USB stick, and\nmount it on a Linux desktop which has automatic mounts enabled, this\ncould be considered a potential denial of service attack.  (Not a big\ndeal in practice, but professional paranoids worry about such things,\nand have even been known to allocate CVE numbers for such problems.)\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nReviewed-by: Zheng Liu <wenqing.lz@taobao.com>\nCc: stable@vger.kernel.org",
    "before_after_code_files": [
      "fs/ext4/namei.c||fs/ext4/namei.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/namei.c||fs/ext4/namei.c": [
      "File: fs/ext4/namei.c -> fs/ext4/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2648:  struct ext4_iloc iloc;",
      "2649:  int err = 0;",
      "2652:   return 0;",
      "2654:  mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);",
      "",
      "[Removed Lines]",
      "2651:  if (!EXT4_SB(inode->i_sb)->s_journal)",
      "",
      "[Added Lines]",
      "2651:  if ((!EXT4_SB(inode->i_sb)->s_journal) &&",
      "2652:      !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c9b92530a723ac5ef8e352885a1862b18f31b2f5",
      "candidate_info": {
        "commit_hash": "c9b92530a723ac5ef8e352885a1862b18f31b2f5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5",
        "files": [
          "fs/ext4/namei.c"
        ],
        "message": "ext4: make orphan functions be no-op in no-journal mode\n\nInstead of checking whether the handle is valid, we check if journal\nis enabled. This avoids taking the s_orphan_lock mutex in all cases\nwhen there is no journal in use, including the error paths where\next4_orphan_del() is called with a handle set to NULL.\n\nSigned-off-by: Anatol Pomozov <anatol.pomozov@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/namei.c||fs/ext4/namei.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/namei.c||fs/ext4/namei.c"
          ],
          "candidate": [
            "fs/ext4/namei.c||fs/ext4/namei.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/namei.c||fs/ext4/namei.c": [
          "File: fs/ext4/namei.c -> fs/ext4/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2369:  struct ext4_iloc iloc;",
          "2370:  int err = 0, rc;",
          "2373:   return 0;",
          "2375:  mutex_lock(&EXT4_SB(sb)->s_orphan_lock);",
          "",
          "[Removed Lines]",
          "2372:  if (!ext4_handle_valid(handle))",
          "",
          "[Added Lines]",
          "2372:  if (!EXT4_SB(sb)->s_journal)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2443:  struct ext4_iloc iloc;",
          "2444:  int err = 0;",
          "2448:   return 0;",
          "2450:  mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);",
          "",
          "[Removed Lines]",
          "2447:  if (handle && !ext4_handle_valid(handle))",
          "",
          "[Added Lines]",
          "2446:  if (!EXT4_SB(inode->i_sb)->s_journal)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2467:   goto out;",
          "2469:  err = ext4_reserve_inode_write(handle, inode, &iloc);",
          "",
          "[Removed Lines]",
          "2466:  if (sbi->s_journal && !handle)",
          "",
          "[Added Lines]",
          "2465:  if (!handle)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
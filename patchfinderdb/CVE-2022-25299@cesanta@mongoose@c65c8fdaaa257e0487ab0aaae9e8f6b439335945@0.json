{
  "cve_id": "CVE-2022-25299",
  "cve_desc": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
  "repo": "cesanta/mongoose",
  "patch_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
  "patch_info": {
    "commit_hash": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
    "files": [
      "Makefile",
      "mongoose.c",
      "src/http.c",
      "test/unit_test.c"
    ],
    "message": "Protect against the directory traversal in mg_upload()",
    "before_after_code_files": [
      "mongoose.c||mongoose.c",
      "src/http.c||src/http.c",
      "test/unit_test.c||test/unit_test.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1142:   return buf;",
      "1143: }",
      "1173: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "1174:                       void *fn_data) {",
      "1175:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "1145: #if MG_ENABLE_FILE",
      "1146: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1147:                    const char *dir) {",
      "1148:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1149:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1150:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1151:   if (name[0] == '\\0') {",
      "1152:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1153:     return -1;",
      "1154:   } else {",
      "1155:     FILE *fp;",
      "1156:     size_t oft = strtoul(offset, NULL, 0);",
      "1157:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1158:     LOG(LL_DEBUG,",
      "1159:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "1160:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1161:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "1162:       return -2;",
      "1163:     } else {",
      "1164:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1165:       fclose(fp);",
      "1166:       mg_http_reply(c, 200, \"\", \"\");",
      "1167:       return (int) hm->body.len;",
      "1168:     }",
      "1169:   }",
      "1170: }",
      "1171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1680:   c->recv.len -= ch.len;",
      "1681: }",
      "1683: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "1684:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "1685:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1655: #if MG_ENABLE_FILE",
      "1656: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "1657:                    const char *dir) {",
      "1658:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "1659:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "1660:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "1661:   if (name[0] == '\\0') {",
      "1662:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "1663:     return -1;",
      "1664:   } else {",
      "1665:     FILE *fp;",
      "1666:     long oft = strtol(offset, NULL, 0);",
      "1667:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "1668:     remove_double_dots(path);",
      "1669:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "1670:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "1671:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "1672:       return -2;",
      "1673:     } else {",
      "1674:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "1675:       fclose(fp);",
      "1676:       mg_http_reply(c, 200, \"\", \"\");",
      "1677:       return (int) hm->body.len;",
      "1678:     }",
      "1679:   }",
      "1680: }",
      "1681: #endif",
      "",
      "---------------"
    ],
    "src/http.c||src/http.c": [
      "File: src/http.c -> src/http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "378:   return buf;",
      "379: }",
      "409: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
      "410:                       void *fn_data) {",
      "411:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
      "",
      "[Removed Lines]",
      "381: #if MG_ENABLE_FILE",
      "382: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "383:                    const char *dir) {",
      "384:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "385:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "386:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "387:   if (name[0] == '\\0') {",
      "388:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "389:     return -1;",
      "390:   } else {",
      "391:     FILE *fp;",
      "392:     size_t oft = strtoul(offset, NULL, 0);",
      "393:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "394:     LOG(LL_DEBUG,",
      "395:         (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
      "396:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "397:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);",
      "398:       return -2;",
      "399:     } else {",
      "400:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "401:       fclose(fp);",
      "402:       mg_http_reply(c, 200, \"\", \"\");",
      "403:       return (int) hm->body.len;",
      "404:     }",
      "405:   }",
      "406: }",
      "407: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "916:   c->recv.len -= ch.len;",
      "917: }",
      "919: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
      "920:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
      "921:     struct mg_http_message hm;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "891: #if MG_ENABLE_FILE",
      "892: int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
      "893:                    const char *dir) {",
      "894:   char offset[40] = \"\", name[200] = \"\", path[256];",
      "895:   mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));",
      "896:   mg_http_get_var(&hm->query, \"name\", name, sizeof(name));",
      "897:   if (name[0] == '\\0') {",
      "898:     mg_http_reply(c, 400, \"\", \"%s\", \"name required\");",
      "899:     return -1;",
      "900:   } else {",
      "901:     FILE *fp;",
      "902:     long oft = strtol(offset, NULL, 0);",
      "903:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
      "904:     remove_double_dots(path);",
      "905:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
      "906:     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {",
      "907:       mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);",
      "908:       return -2;",
      "909:     } else {",
      "910:       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
      "911:       fclose(fp);",
      "912:       mg_http_reply(c, 200, \"\", \"\");",
      "913:       return (int) hm->body.len;",
      "914:     }",
      "915:   }",
      "916: }",
      "917: #endif",
      "",
      "---------------"
    ],
    "test/unit_test.c||test/unit_test.c": [
      "File: test/unit_test.c -> test/unit_test.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "698:     remove(\"uploaded.txt\");",
      "699:   }",
      "702:   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);",
      "703:   ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "700:   {",
      "702:     char *p;",
      "703:     remove(\"uploaded.txt\");",
      "704:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);",
      "705:     ASSERT(fetch(&mgr, buf, url,",
      "706:                  \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"",
      "707:                  \"Content-Length: 5\\r\\n\"",
      "708:                  \"\\r\\nhello\") == 200);",
      "709:     ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) != NULL);",
      "710:     ASSERT(strcmp(p, \"hello\") == 0);",
      "711:     free(p);",
      "712:     remove(\"uploaded.txt\");",
      "713:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f64c86d23f08ac7e425f62bf47d58d88cca25c33",
      "candidate_info": {
        "commit_hash": "f64c86d23f08ac7e425f62bf47d58d88cca25c33",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/f64c86d23f08ac7e425f62bf47d58d88cca25c33",
        "files": [
          "examples/file-upload/main.c",
          "mongoose.c",
          "mongoose.h",
          "src/arch_azurertos.h",
          "src/arch_freertos_lwip.h",
          "src/arch_freertos_tcp.h",
          "src/arch_unix.h",
          "src/arch_win32.h",
          "src/dns.c",
          "src/fs.c",
          "src/fs_fat.c",
          "src/fs_packed.c",
          "src/http.c",
          "src/log.c",
          "src/mqtt.c",
          "src/net.c",
          "src/ssi.c",
          "src/str.c",
          "src/str.h",
          "src/util.c",
          "src/util.h",
          "test/unit_test.c"
        ],
        "message": "Use mg_snprintf()",
        "before_after_code_files": [
          "examples/file-upload/main.c||examples/file-upload/main.c",
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/arch_azurertos.h||src/arch_azurertos.h",
          "src/arch_freertos_lwip.h||src/arch_freertos_lwip.h",
          "src/arch_freertos_tcp.h||src/arch_freertos_tcp.h",
          "src/arch_unix.h||src/arch_unix.h",
          "src/arch_win32.h||src/arch_win32.h",
          "src/dns.c||src/dns.c",
          "src/fs.c||src/fs.c",
          "src/fs_fat.c||src/fs_fat.c",
          "src/fs_packed.c||src/fs_packed.c",
          "src/http.c||src/http.c",
          "src/log.c||src/log.c",
          "src/mqtt.c||src/mqtt.c",
          "src/net.c||src/net.c",
          "src/ssi.c||src/ssi.c",
          "src/str.c||src/str.c",
          "src/str.h||src/str.h",
          "src/util.c||src/util.c",
          "src/util.h||src/util.h",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/file-upload/main.c||examples/file-upload/main.c": [
          "File: examples/file-upload/main.c -> examples/file-upload/main.c"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "456:   bool result = false;",
          "457:   struct mg_fd *fd;",
          "458:   char tmp[MG_PATH_MAX];",
          "460:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "461:     result = fs->wr(fd->fd, buf, len) == len;",
          "462:     mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "459:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "",
          "[Added Lines]",
          "458:   mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "491: #if MG_ENABLE_FATFS",
          "492: #include <ff.h>",
          "494: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "495:   FILINFO fi;",
          "496:   if (path[0] == '\\0' || strcmp(path, MG_FATFS_ROOT) == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "493: static int mg_days_from_epoch(int y, int m, int d) {",
          "494:   y -= m <= 2;",
          "495:   int era = y / 400;",
          "496:   int yoe = y - era * 400;",
          "497:   int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;",
          "498:   int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;",
          "499:   return era * 146097 + doe - 719468;",
          "500: }",
          "502: static time_t mg_timegm(struct tm const *t) {",
          "503:   int year = t->tm_year + 1900;",
          "504:   int month = t->tm_mon;  // 0-11",
          "505:   if (month > 11) {",
          "506:     year += month / 12;",
          "507:     month %= 12;",
          "508:   } else if (month < 0) {",
          "509:     int years_diff = (11 - month) / 12;",
          "510:     year -= years_diff;",
          "511:     month += 12 * years_diff;",
          "512:   }",
          "513:   int x = mg_days_from_epoch(year, month + 1, t->tm_mday);",
          "514:   return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;",
          "515: }",
          "517: static time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {",
          "518:   struct tm tm;",
          "519:   memset(&tm, 0, sizeof(struct tm));",
          "520:   tm.tm_sec = (ftime << 1) & 0x3e;",
          "521:   tm.tm_min = ((ftime >> 5) & 0x3f);",
          "522:   tm.tm_hour = ((ftime >> 11) & 0x1f);",
          "523:   tm.tm_mday = (fdate & 0x1f);",
          "524:   tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;",
          "525:   tm.tm_year = ((fdate >> 9) & 0x7f) + 80;",
          "526:   return mg_timegm(&tm);",
          "527: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "499:     return MG_FS_DIR;",
          "500:   } else if (f_stat(path, &fi) == 0) {",
          "501:     if (size) *size = (size_t) fi.fsize;",
          "503:     return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);",
          "504:   } else {",
          "505:     return 0;",
          "",
          "[Removed Lines]",
          "502:     if (mtime) *mtime = (fi.fdate << 16) | fi.ftime;",
          "",
          "[Added Lines]",
          "537:     if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "629:     begin = &path[n + 1];",
          "630:     end = strchr(begin, '/');",
          "631:     if (end == NULL) end = begin + strlen(begin);",
          "633:     buf[sizeof(buf) - 1] = '\\0';",
          "",
          "[Removed Lines]",
          "632:     snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "",
          "[Added Lines]",
          "668:     mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1325: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);",
          "1326: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "1329:   return buf;",
          "1330: }",
          "",
          "[Removed Lines]",
          "1327:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,",
          "1328:            (int64_t) size);",
          "",
          "[Added Lines]",
          "1363:   mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1446:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "1447:   } else {",
          "1448:     int n, status = 200;",
          "1450:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "1451:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "[Removed Lines]",
          "1449:     char range[100] = \"\";",
          "",
          "[Added Lines]",
          "1484:     char range[100] = \"\", tmp[50];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1458:       if (r1 > r2 || r2 >= cl) {",
          "1459:         status = 416;",
          "1460:         cl = 0;",
          "1463:       } else {",
          "1464:         status = 206;",
          "1465:         cl = r2 - r1 + 1;",
          "1470:         fs->sk(fd->fd, (size_t) r1);",
          "1471:       }",
          "1472:     }",
          "1474:     mg_printf(c,",
          "1475:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"",
          "1477:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "1479:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "1480:       c->is_draining = 1;",
          "1481:       mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "1461:         snprintf(range, sizeof(range),",
          "1462:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);",
          "1466:         snprintf(range, sizeof(range),",
          "1467:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "1468:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "1469:                  r1, r1 + cl - 1, (int64_t) size);",
          "1476:               \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",",
          "1478:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "[Added Lines]",
          "1496:         mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",",
          "1497:                     (int64_t) size);",
          "1501:         mg_snprintf(range, sizeof(range),",
          "1502:                     \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,",
          "1503:                     (int64_t) size);",
          "1507:     mg_snprintf(tmp, sizeof(tmp), \"Content-Length: %lld\\r\\n\", cl);",
          "1508:     LOG(LL_INFO, (\"TMP: [%s]\", tmp));",
          "1511:               \"Etag: %s\\r\\n%s%s%s\\r\\n\",",
          "1513:               etag, tmp, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1498:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "1499:   size_t size = 0;",
          "1500:   time_t t = 0;",
          "1502:   int flags, n = 0;",
          "1506:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "1507:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "1508:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "1509:   } else {",
          "1510:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "1512:     if (flags & MG_FS_DIR) {",
          "1520:     } else {",
          "1522:     }",
          "1524:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "1525:     mg_printf(d->c,",
          "1526:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "",
          "[Removed Lines]",
          "1501:   char path[MG_PATH_MAX], sz[64], mod[64];",
          "1505:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {",
          "1511:     struct tm tm;",
          "1513:       snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "1514:     } else if (size < 1024) {",
          "1515:       snprintf(sz, sizeof(sz), \"%d\", (int) size);",
          "1516:     } else if (size < 0x100000) {",
          "1517:       snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);",
          "1518:     } else if (size < 0x40000000) {",
          "1519:       snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);",
          "1521:       snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);",
          "1523:     strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));",
          "",
          "[Added Lines]",
          "1536:   char path[MG_PATH_MAX], sz[40], mod[40];",
          "1540:   if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >",
          "1541:       sizeof(path)) {",
          "1548:       mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "1550:       mg_snprintf(sz, sizeof(sz), \"%llx\", (uint64_t) size);",
          "1552:     mg_snprintf(mod, sizeof(mod), \"%lx\", (unsigned long) t);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1588:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "1589:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "1590:             MG_VERSION);",
          "1593:   if (n > sizeof(tmp)) n = 0;",
          "1594:   memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "1595: }",
          "",
          "[Removed Lines]",
          "1591:   n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "1592:                         (unsigned long) (c->send.len - off));",
          "",
          "[Added Lines]",
          "1620:   n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1620:                         char *path, size_t path_size) {",
          "1621:   int flags = 0, tmp;",
          "1624:   if (n > path_size) n = path_size;",
          "1625:   path[path_size - 1] = '\\0';",
          "1626:   if ((fs->st(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "[Removed Lines]",
          "1623:   size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "",
          "[Added Lines]",
          "1651:   size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1649:                 (int) hm->uri.len, hm->uri.ptr);",
          "1650:       flags = 0;",
          "1651:     } else if (flags & MG_FS_DIR) {",
          "1653:             (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "1655:             (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "1656:         flags = tmp;",
          "1657:       } else {",
          "",
          "[Removed Lines]",
          "1652:       if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "1654:            (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "",
          "[Added Lines]",
          "1680:       if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "1682:            (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1723:     int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);",
          "1724:     const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);",
          "1725:     if (p != NULL) {",
          "1728:     }",
          "1729:   } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {",
          "1731:   } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {",
          "1732:     struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));",
          "1734:   } else {",
          "1735:     mg_http_get_var(&hm->query, \"access_token\", pass, passlen);",
          "1736:   }",
          "",
          "[Removed Lines]",
          "1726:       snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);",
          "1727:       snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);",
          "1730:     snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "1733:     if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "",
          "[Added Lines]",
          "1754:       mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);",
          "1755:       mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);",
          "1758:     mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "1761:     if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1845:   } else {",
          "1846:     struct mg_fd *fd;",
          "1847:     long oft = strtol(offset, NULL, 0);",
          "1849:     remove_double_dots(path);",
          "1850:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "1851:     if (oft == 0) fs->rm(path);",
          "",
          "[Removed Lines]",
          "1848:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Added Lines]",
          "1876:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2034:   }",
          "2036:   if (level <= max) {",
          "2047:     s_fn(buf, sizeof(buf) - 1, s_fn_param);",
          "2048:     return true;",
          "2049:   } else {",
          "",
          "[Removed Lines]",
          "2037:     char timebuf[21], buf[50] = \"\";",
          "2038:     time_t t = time(NULL);",
          "2039:     struct tm tmp, *tm = gmtime_r(&t, &tmp);",
          "2040:     int n;",
          "2041:     (void) tmp;",
          "2042:     strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);",
          "2043:     n = snprintf(buf, sizeof(buf), \"%s %d %s:%d:%s\", timebuf, level, p, line,",
          "2044:                  fname);",
          "2045:     if (n < 0 || n > (int) sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "2046:     while (n < (int) sizeof(buf) - 1) buf[n++] = ' ';",
          "",
          "[Added Lines]",
          "2065:     char buf[40];",
          "2066:     size_t n = mg_snprintf(buf, sizeof(buf), \"%llx %d %s:%d:%s\", mg_millis(),",
          "2067:                            level, p, line, fname);",
          "2068:     if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "2069:     while (n < sizeof(buf) - 1) buf[n++] = ' ';",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2410:     if (len_len >= 4) return MQTT_MALFORMED;",
          "2411:   }",
          "2412:   end = p + n;",
          "2414:   m->dgram.len = (size_t) (end - buf);",
          "2416:   switch (m->cmd) {",
          "",
          "[Removed Lines]",
          "2413:   if (lc & 0x80 || end > buf + len) return MQTT_INCOMPLETE;",
          "",
          "[Added Lines]",
          "2436:   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2582:   char tmp[30];",
          "2583:   const char *fmt = a->is_ip6 ? \"[%s]:%d\" : \"%s:%d\";",
          "2584:   mg_ntoa(a, tmp, sizeof(tmp));",
          "2586:   return buf;",
          "2587: }",
          "2589: char *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len) {",
          "2590:   if (addr->is_ip6) {",
          "2591:     uint16_t *p = (uint16_t *) addr->ip6;",
          "2595:   } else {",
          "2596:     uint8_t p[4];",
          "2597:     memcpy(p, &addr->ip, sizeof(p));",
          "2600:   }",
          "2601:   return buf;",
          "2602: }",
          "",
          "[Removed Lines]",
          "2585:   snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));",
          "2592:     snprintf(buf, len, \"%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx\", mg_htons(p[0]),",
          "2593:              mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),",
          "2594:              mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));",
          "2598:     snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],",
          "2599:              (int) p[3]);",
          "",
          "[Added Lines]",
          "2608:   mg_snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));",
          "2615:     mg_snprintf(buf, len, \"%x:%x:%x:%x:%x:%x:%x:%x\", mg_htons(p[0]),",
          "2616:                 mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),",
          "2617:                 mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));",
          "2621:     mg_snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],",
          "2622:                 (int) p[3]);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3713:           char tmp[MG_PATH_MAX + BUFSIZ + 10],",
          "3715:           while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;",
          "3717:           if (depth < MG_MAX_SSI_DEPTH &&",
          "3718:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "3719:             mg_iobuf_add(&b, b.len, data, strlen(data), align);",
          "",
          "[Removed Lines]",
          "3716:           snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "",
          "[Added Lines]",
          "3739:           mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3723:           }",
          "3724:         } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {",
          "3725:           char tmp[MG_PATH_MAX + BUFSIZ + 10], *data;",
          "3727:           if (depth < MG_MAX_SSI_DEPTH &&",
          "3728:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "3729:             mg_iobuf_add(&b, b.len, data, strlen(data), align);",
          "",
          "[Removed Lines]",
          "3726:           snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "",
          "[Added Lines]",
          "3749:           mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3934:   return off > 0;",
          "3935: }",
          "3937: #ifdef MG_ENABLE_LINES",
          "3938: #line 1 \"src/timer.c\"",
          "3939: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3960: size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {",
          "3961:   const char *letters = \"0123456789abcdef\";",
          "3962:   uint64_t v = (uint64_t) val;",
          "3963:   size_t s = 0, n, i;",
          "3964:   if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);",
          "3968:   if (is_hex) {",
          "3969:     for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];",
          "3970:   } else {",
          "3971:     for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];",
          "3972:   }",
          "3974:   for (i = 0; i < n / 2; i++) {",
          "3975:     char t = buf[s + i];",
          "3976:     buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;",
          "3977:   }",
          "3978:   if (val == 0) buf[n++] = '0';  // Handle special case",
          "3979:   return n + s;",
          "3980: }",
          "3982: static size_t mg_copys(char *buf, size_t len, size_t n, char *p, size_t k) {",
          "3983:   size_t j = 0;",
          "3984:   for (j = 0; j < k && j + n < len && p[j]; j++) buf[n + j] = p[j];",
          "3985:   return j;",
          "3986: }",
          "3988: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap) {",
          "3989:   size_t i = 0, n = 0;",
          "3990:   while (fmt[i] != '\\0') {",
          "3991:     if (fmt[i] == '%') {",
          "3992:       size_t j, k, is_long = 0, w = 0 /* width */, pr = 0 /* precision */;",
          "3993:       char pad = ' ', c = fmt[++i];",
          "3994:       if (c == '0') pad = '0', c = fmt[++i];",
          "3995:       while (isdigit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];",
          "3996:       if (c == '.') {",
          "3997:         c = fmt[++i];",
          "3998:         if (c == '*') {",
          "3999:           pr = (size_t) va_arg(ap, int);",
          "4000:           c = fmt[++i];",
          "4001:         } else {",
          "4002:           while (isdigit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];",
          "4003:         }",
          "4004:       }",
          "4005:       if (c == 'l') {",
          "4006:         is_long++, c = fmt[++i];",
          "4007:         if (c == 'l') is_long++, c = fmt[++i];",
          "4008:       }",
          "4009:       if (c == 'd' || c == 'u' || c == 'x') {",
          "4010:         bool s = (c == 'd'), h = (c == 'x');",
          "4011:         char tmp[30];",
          "4012:         if (is_long == 2) {",
          "4013:           int64_t v = va_arg(ap, int64_t);",
          "4014:           k = mg_lld(tmp, v, s, h);",
          "4015:         } else if (is_long == 1) {",
          "4016:           long v = va_arg(ap, long);",
          "4017:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);",
          "4018:         } else {",
          "4019:           int v = va_arg(ap, int);",
          "4020:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);",
          "4021:         }",
          "4022:         for (j = 0; n < len && k < w && j + k < w; j++) buf[n++] = pad;",
          "4023:         mg_copys(buf, len, n, tmp, k);",
          "4024:         n += k;",
          "4025:       } else if (c == 'c') {",
          "4026:         int p = va_arg(ap, int);",
          "4027:         if (n < len) buf[n] = (char) p;",
          "4028:         n++;",
          "4029:       } else if (c == 's') {",
          "4030:         char *p = va_arg(ap, char *);",
          "4031:         if (pr == 0) pr = p == NULL ? 0 : strlen(p);",
          "4032:         for (j = 0; n < len && pr < w && j + pr < w; j++) buf[n++] = pad;",
          "4033:         n += mg_copys(buf, len, n, p, pr);",
          "4034:       }",
          "4035:       i++;",
          "4036:     } else {",
          "4037:       if (n < len) buf[n] = fmt[i];",
          "4038:       n++, i++;",
          "4039:     }",
          "4040:   }",
          "4041:   if (n < len) buf[n] = '\\0';",
          "4042:   return n;",
          "4043: }",
          "4045: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {",
          "4046:   va_list ap;",
          "4047:   size_t n;",
          "4048:   va_start(ap, fmt);",
          "4049:   n = mg_vsnprintf(buf, len, fmt, ap);",
          "4050:   va_end(ap);",
          "4051:   return n;",
          "4052: }",
          "4054: char *mg_hexdump(const void *buf, size_t len) {",
          "4055:   const unsigned char *p = (const unsigned char *) buf;",
          "4056:   size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;",
          "4057:   char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);",
          "4058:   if (dst == NULL) return dst;",
          "4059:   for (i = 0; i < len; i++) {",
          "4060:     idx = i % 16;",
          "4061:     if (idx == 0) {",
          "4062:       if (i > 0 && dlen > n)",
          "4063:         n += mg_snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "4064:       if (dlen > n)",
          "4065:         n += mg_snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));",
          "4066:     }",
          "4067:     if (dlen < n) break;",
          "4068:     n += mg_snprintf(dst + n, dlen - n, \" %02x\", p[i]);",
          "4069:     ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);",
          "4070:     ascii[idx + 1] = '\\0';",
          "4071:   }",
          "4072:   while (i++ % 16) {",
          "4073:     if (n < dlen) n += mg_snprintf(dst + n, dlen - n, \"%s\", \"   \");",
          "4074:   }",
          "4075:   if (n < dlen) n += mg_snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "4076:   if (n > dlen - 1) n = dlen - 1;",
          "4077:   dst[n] = '\\0';",
          "4078:   return dst;",
          "4079: }",
          "4081: char *mg_hex(const void *buf, size_t len, char *to) {",
          "4082:   const unsigned char *p = (const unsigned char *) buf;",
          "4083:   static const char *hex = \"0123456789abcdef\";",
          "4084:   size_t i = 0;",
          "4085:   for (; len--; p++) {",
          "4086:     to[i++] = hex[p[0] >> 4];",
          "4087:     to[i++] = hex[p[0] & 0x0f];",
          "4088:   }",
          "4089:   to[i] = '\\0';",
          "4090:   return to;",
          "4091: }",
          "4093: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "4094:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "4095:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "4096:                                   : (unsigned char) (c - 'W');",
          "4097: }",
          "4099: unsigned long mg_unhexn(const char *s, size_t len) {",
          "4100:   unsigned long i = 0, v = 0;",
          "4101:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "4102:   return v;",
          "4103: }",
          "4105: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "4106:   size_t i;",
          "4107:   for (i = 0; i < len; i += 2) {",
          "4108:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "4109:   }",
          "4110: }",
          "4112: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {",
          "4113:   va_list ap_copy;",
          "4114:   int len;",
          "4116:   va_copy(ap_copy, ap);",
          "4117:   len = vsnprintf(*buf, size, fmt, ap_copy);",
          "4118:   va_end(ap_copy);",
          "4120:   if (len < 0) {",
          "4126:     while (len < 0) {",
          "4127:       free(*buf);",
          "4128:       if (size == 0) size = 5;",
          "4129:       size *= 2;",
          "4130:       if ((*buf = (char *) calloc(1, size)) == NULL) {",
          "4131:         len = -1;",
          "4132:         break;",
          "4133:       }",
          "4134:       va_copy(ap_copy, ap);",
          "4135:       len = vsnprintf(*buf, size - 1, fmt, ap_copy);",
          "4136:       va_end(ap_copy);",
          "4137:     }",
          "4140:     if (*buf != NULL) (*buf)[len] = 0;",
          "4142:   } else if (len >= (int) size) {",
          "4144:     if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {",
          "4145:       len = -1;  // LCOV_EXCL_LINE",
          "4146:     } else {     // LCOV_EXCL_LINE",
          "4147:       va_copy(ap_copy, ap);",
          "4148:       len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);",
          "4149:       va_end(ap_copy);",
          "4150:     }",
          "4151:   }",
          "4153:   return len;",
          "4154: }",
          "4156: int mg_asprintf(char **buf, size_t size, const char *fmt, ...) {",
          "4157:   int ret;",
          "4158:   va_list ap;",
          "4159:   va_start(ap, fmt);",
          "4160:   ret = mg_vasprintf(buf, size, fmt, ap);",
          "4161:   va_end(ap);",
          "4162:   return ret;",
          "4163: }",
          "4165: int64_t mg_to64(struct mg_str str) {",
          "4166:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "4167:   size_t i = 0;",
          "4168:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "4169:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "4170:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "4171:     if (result > max) return 0;",
          "4172:     result *= 10;",
          "4173:     result += (str.ptr[i] - '0');",
          "4174:     i++;",
          "4175:   }",
          "4176:   return result * neg;",
          "4177: }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4498:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));",
          "4499: }",
          "4626: uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {",
          "4627:   int i;",
          "4628:   crc = ~crc;",
          "",
          "[Removed Lines]",
          "4501: char *mg_hexdump(const void *buf, size_t len) {",
          "4502:   const unsigned char *p = (const unsigned char *) buf;",
          "4503:   size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;",
          "4504:   char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);",
          "4505:   if (dst == NULL) return dst;",
          "4506:   for (i = 0; i < len; i++) {",
          "4507:     idx = i % 16;",
          "4508:     if (idx == 0) {",
          "4509:       if (i > 0 && dlen > n)",
          "4510:         n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "4511:       if (dlen > n)",
          "4512:         n += (size_t) snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));",
          "4513:     }",
          "4514:     if (dlen < n) break;",
          "4515:     n += (size_t) snprintf(dst + n, dlen - n, \" %02x\", p[i]);",
          "4516:     ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);",
          "4517:     ascii[idx + 1] = '\\0';",
          "4518:   }",
          "4519:   while (i++ % 16) {",
          "4520:     if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"%s\", \"   \");",
          "4521:   }",
          "4522:   if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "4523:   if (n > dlen - 1) n = dlen - 1;",
          "4524:   dst[n] = '\\0';",
          "4525:   return dst;",
          "4526: }",
          "4528: char *mg_hex(const void *buf, size_t len, char *to) {",
          "4529:   const unsigned char *p = (const unsigned char *) buf;",
          "4530:   static const char *hex = \"0123456789abcdef\";",
          "4531:   size_t i = 0;",
          "4532:   for (; len--; p++) {",
          "4533:     to[i++] = hex[p[0] >> 4];",
          "4534:     to[i++] = hex[p[0] & 0x0f];",
          "4535:   }",
          "4536:   to[i] = '\\0';",
          "4537:   return to;",
          "4538: }",
          "4540: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "4541:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "4542:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "4543:                                   : (unsigned char) (c - 'W');",
          "4544: }",
          "4546: unsigned long mg_unhexn(const char *s, size_t len) {",
          "4547:   unsigned long i = 0, v = 0;",
          "4548:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "4549:   return v;",
          "4550: }",
          "4552: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "4553:   size_t i;",
          "4554:   for (i = 0; i < len; i += 2) {",
          "4555:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "4556:   }",
          "4557: }",
          "4559: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {",
          "4560:   va_list ap_copy;",
          "4561:   int len;",
          "4563:   va_copy(ap_copy, ap);",
          "4564:   len = vsnprintf(*buf, size, fmt, ap_copy);",
          "4565:   va_end(ap_copy);",
          "4567:   if (len < 0) {",
          "4573:     while (len < 0) {",
          "4574:       free(*buf);",
          "4575:       if (size == 0) size = 5;",
          "4576:       size *= 2;",
          "4577:       if ((*buf = (char *) calloc(1, size)) == NULL) {",
          "4578:         len = -1;",
          "4579:         break;",
          "4580:       }",
          "4581:       va_copy(ap_copy, ap);",
          "4582:       len = vsnprintf(*buf, size - 1, fmt, ap_copy);",
          "4583:       va_end(ap_copy);",
          "4584:     }",
          "4587:     if (*buf != NULL) (*buf)[len] = 0;",
          "4589:   } else if (len >= (int) size) {",
          "4591:     if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {",
          "4592:       len = -1;  // LCOV_EXCL_LINE",
          "4593:     } else {     // LCOV_EXCL_LINE",
          "4594:       va_copy(ap_copy, ap);",
          "4595:       len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);",
          "4596:       va_end(ap_copy);",
          "4597:     }",
          "4598:   }",
          "4600:   return len;",
          "4601: }",
          "4603: int mg_asprintf(char **buf, size_t size, const char *fmt, ...) {",
          "4604:   int ret;",
          "4605:   va_list ap;",
          "4606:   va_start(ap, fmt);",
          "4607:   ret = mg_vasprintf(buf, size, fmt, ap);",
          "4608:   va_end(ap);",
          "4609:   return ret;",
          "4610: }",
          "4612: int64_t mg_to64(struct mg_str str) {",
          "4613:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "4614:   size_t i = 0;",
          "4615:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "4616:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "4617:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "4618:     if (result > max) return 0;",
          "4619:     result *= 10;",
          "4620:     result += (str.ptr[i] - '0');",
          "4621:     i++;",
          "4622:   }",
          "4623:   return result * neg;",
          "4624: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: #define socklen_t int",
          "101: #define closesocket(x) soc_close(x)",
          "111: #undef FOPEN_MAX",
          "",
          "[Removed Lines]",
          "102: #define gmtime_r(a, b) gmtime(a)",
          "103: #define MG_INT64_FMT \"%lld\"",
          "105: static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {",
          "106:   struct tm *x = localtime(t);",
          "108:   return tm;",
          "109: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192: #error Set LWIP_SOCKET variable to 1 (in lwipopts.h)",
          "193: #endif",
          "206: static inline void *mg_calloc(int cnt, size_t size) {",
          "207:   void *p = pvPortMalloc(cnt * size);",
          "",
          "[Removed Lines]",
          "195: #if LWIP_POSIX_SOCKETS_IO_NAMES != 0",
          "199: #error LWIP_POSIX_SOCKETS_IO_NAMES must be set to 0 (in lwipopts.h) for FreeRTOS",
          "200: #endif",
          "202: #define MG_INT64_FMT \"%lld\"",
          "203: #define MG_DIRSEP '/'",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "211: #define calloc(a, b) mg_calloc((a), (b))",
          "212: #define free(a) vPortFree(a)",
          "213: #define malloc(a) pvPortMalloc(a)",
          "215: #define mkdir(a, b) (-1)",
          "217: #endif  // MG_ARCH == MG_ARCH_FREERTOS_LWIP",
          "",
          "[Removed Lines]",
          "214: #define gmtime_r(a, b) gmtime(a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "275: #define malloc(a) pvPortMalloc(a)",
          "276: #define mkdir(a, b) (-1)",
          "280: #if !defined(__GNUC__)",
          "282: struct timeval {",
          "",
          "[Removed Lines]",
          "278: #define gmtime_r(a, b) gmtime(a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "331: #include <time.h>",
          "332: #include <unistd.h>",
          "336: #ifndef MG_ENABLE_DIRLIST",
          "337: #define MG_ENABLE_DIRLIST 1",
          "338: #endif",
          "",
          "[Removed Lines]",
          "334: #define MG_INT64_FMT \"%\" PRId64",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "430: #define MG_ENABLE_DIRLIST 1",
          "431: #endif",
          "446: #endif",
          "",
          "[Removed Lines]",
          "434: static __inline struct tm *gmtime_r(const time_t *t, struct tm *tm) {",
          "435:   struct tm *x = gmtime(t);",
          "437:   return tm;",
          "438: }",
          "440: static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {",
          "441:   struct tm *x = localtime(t);",
          "443:   return tm;",
          "444: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "584: bool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);",
          "585: bool mg_globmatch(const char *pattern, size_t plen, const char *s, size_t n);",
          "586: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "551: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "552: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap);",
          "553: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...);",
          "554: char *mg_hexdump(const void *buf, size_t len);",
          "555: char *mg_hex(const void *buf, size_t len, char *dst);",
          "556: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "557: unsigned long mg_unhexn(const char *s, size_t len);",
          "558: int mg_asprintf(char **buf, size_t size, const char *fmt, ...);",
          "559: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap);",
          "560: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "561: int64_t mg_to64(struct mg_str str);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "687: uint16_t mg_ntohs(uint16_t net);",
          "688: uint32_t mg_ntohl(uint32_t net);",
          "689: uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len);",
          "698: int64_t mg_millis(void);",
          "700: #define mg_htons(x) mg_ntohs(x)",
          "",
          "[Removed Lines]",
          "690: char *mg_hexdump(const void *buf, size_t len);",
          "691: char *mg_hex(const void *buf, size_t len, char *dst);",
          "692: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "693: unsigned long mg_unhexn(const char *s, size_t len);",
          "694: int mg_asprintf(char **buf, size_t size, const char *fmt, ...);",
          "695: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap);",
          "696: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "697: int64_t mg_to64(struct mg_str str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_azurertos.h||src/arch_azurertos.h": [
          "File: src/arch_azurertos.h -> src/arch_azurertos.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define socklen_t int",
          "27: #define closesocket(x) soc_close(x)",
          "37: #undef FOPEN_MAX",
          "",
          "[Removed Lines]",
          "28: #define gmtime_r(a, b) gmtime(a)",
          "29: #define MG_INT64_FMT \"%lld\"",
          "31: static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {",
          "32:   struct tm *x = localtime(t);",
          "34:   return tm;",
          "35: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_freertos_lwip.h||src/arch_freertos_lwip.h": [
          "File: src/arch_freertos_lwip.h -> src/arch_freertos_lwip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #error Set LWIP_SOCKET variable to 1 (in lwipopts.h)",
          "30: #endif",
          "43: static inline void *mg_calloc(int cnt, size_t size) {",
          "44:   void *p = pvPortMalloc(cnt * size);",
          "",
          "[Removed Lines]",
          "32: #if LWIP_POSIX_SOCKETS_IO_NAMES != 0",
          "36: #error LWIP_POSIX_SOCKETS_IO_NAMES must be set to 0 (in lwipopts.h) for FreeRTOS",
          "37: #endif",
          "39: #define MG_INT64_FMT \"%lld\"",
          "40: #define MG_DIRSEP '/'",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: #define calloc(a, b) mg_calloc((a), (b))",
          "49: #define free(a) vPortFree(a)",
          "50: #define malloc(a) pvPortMalloc(a)",
          "52: #define mkdir(a, b) (-1)",
          "54: #endif  // MG_ARCH == MG_ARCH_FREERTOS_LWIP",
          "",
          "[Removed Lines]",
          "51: #define gmtime_r(a, b) gmtime(a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_freertos_tcp.h||src/arch_freertos_tcp.h": [
          "File: src/arch_freertos_tcp.h -> src/arch_freertos_tcp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: #define malloc(a) pvPortMalloc(a)",
          "59: #define mkdir(a, b) (-1)",
          "63: #if !defined(__GNUC__)",
          "65: struct timeval {",
          "",
          "[Removed Lines]",
          "61: #define gmtime_r(a, b) gmtime(a)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_unix.h||src/arch_unix.h": [
          "File: src/arch_unix.h -> src/arch_unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include <time.h>",
          "31: #include <unistd.h>",
          "35: #ifndef MG_ENABLE_DIRLIST",
          "36: #define MG_ENABLE_DIRLIST 1",
          "37: #endif",
          "",
          "[Removed Lines]",
          "33: #define MG_INT64_FMT \"%\" PRId64",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_win32.h||src/arch_win32.h": [
          "File: src/arch_win32.h -> src/arch_win32.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: #define MG_ENABLE_DIRLIST 1",
          "91: #endif",
          "106: #endif",
          "",
          "[Removed Lines]",
          "94: static __inline struct tm *gmtime_r(const time_t *t, struct tm *tm) {",
          "95:   struct tm *x = gmtime(t);",
          "97:   return tm;",
          "98: }",
          "100: static __inline struct tm *localtime_r(const time_t *t, struct tm *tm) {",
          "101:   struct tm *x = localtime(t);",
          "103:   return tm;",
          "104: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dns.c||src/dns.c": [
          "File: src/dns.c -> src/dns.c"
        ],
        "src/fs.c||src/fs.c": [
          "File: src/fs.c -> src/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:   bool result = false;",
          "48:   struct mg_fd *fd;",
          "49:   char tmp[MG_PATH_MAX];",
          "51:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "52:     result = fs->wr(fd->fd, buf, len) == len;",
          "53:     mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "50:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "",
          "[Added Lines]",
          "50:   mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "",
          "---------------"
        ],
        "src/fs_fat.c||src/fs_fat.c": [
          "File: src/fs_fat.c -> src/fs_fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #if MG_ENABLE_FATFS",
          "4: #include <ff.h>",
          "6: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "7:   FILINFO fi;",
          "8:   if (path[0] == '\\0' || strcmp(path, MG_FATFS_ROOT) == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: static int mg_days_from_epoch(int y, int m, int d) {",
          "7:   y -= m <= 2;",
          "8:   int era = y / 400;",
          "9:   int yoe = y - era * 400;",
          "10:   int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;",
          "11:   int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;",
          "12:   return era * 146097 + doe - 719468;",
          "13: }",
          "15: static time_t mg_timegm(struct tm const *t) {",
          "16:   int year = t->tm_year + 1900;",
          "17:   int month = t->tm_mon;  // 0-11",
          "18:   if (month > 11) {",
          "19:     year += month / 12;",
          "20:     month %= 12;",
          "21:   } else if (month < 0) {",
          "22:     int years_diff = (11 - month) / 12;",
          "23:     year -= years_diff;",
          "24:     month += 12 * years_diff;",
          "25:   }",
          "26:   int x = mg_days_from_epoch(year, month + 1, t->tm_mday);",
          "27:   return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;",
          "28: }",
          "30: static time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {",
          "31:   struct tm tm;",
          "32:   memset(&tm, 0, sizeof(struct tm));",
          "33:   tm.tm_sec = (ftime << 1) & 0x3e;",
          "34:   tm.tm_min = ((ftime >> 5) & 0x3f);",
          "35:   tm.tm_hour = ((ftime >> 11) & 0x1f);",
          "36:   tm.tm_mday = (fdate & 0x1f);",
          "37:   tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;",
          "38:   tm.tm_year = ((fdate >> 9) & 0x7f) + 80;",
          "39:   return mg_timegm(&tm);",
          "40: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:     return MG_FS_DIR;",
          "12:   } else if (f_stat(path, &fi) == 0) {",
          "13:     if (size) *size = (size_t) fi.fsize;",
          "15:     return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);",
          "16:   } else {",
          "17:     return 0;",
          "",
          "[Removed Lines]",
          "14:     if (mtime) *mtime = (fi.fdate << 16) | fi.ftime;",
          "",
          "[Added Lines]",
          "50:     if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);",
          "",
          "---------------"
        ],
        "src/fs_packed.c||src/fs_packed.c": [
          "File: src/fs_packed.c -> src/fs_packed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"fs.h\"",
          "3: struct packed_file {",
          "4:   const char *data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include \"str.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     begin = &path[n + 1];",
          "48:     end = strchr(begin, '/');",
          "49:     if (end == NULL) end = begin + strlen(begin);",
          "51:     buf[sizeof(buf) - 1] = '\\0';",
          "",
          "[Removed Lines]",
          "50:     snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "",
          "[Added Lines]",
          "51:     mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "373: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);",
          "374: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "377:   return buf;",
          "378: }",
          "",
          "[Removed Lines]",
          "375:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,",
          "376:            (int64_t) size);",
          "",
          "[Added Lines]",
          "375:   mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "494:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "495:   } else {",
          "496:     int n, status = 200;",
          "498:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "499:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "[Removed Lines]",
          "497:     char range[100] = \"\";",
          "",
          "[Added Lines]",
          "496:     char range[100] = \"\", tmp[50];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "506:       if (r1 > r2 || r2 >= cl) {",
          "507:         status = 416;",
          "508:         cl = 0;",
          "511:       } else {",
          "512:         status = 206;",
          "513:         cl = r2 - r1 + 1;",
          "518:         fs->sk(fd->fd, (size_t) r1);",
          "519:       }",
          "520:     }",
          "522:     mg_printf(c,",
          "523:               \"HTTP/1.1 %d %s\\r\\nContent-Type: %.*s\\r\\n\"",
          "525:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "527:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "528:       c->is_draining = 1;",
          "529:       mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "509:         snprintf(range, sizeof(range),",
          "510:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);",
          "514:         snprintf(range, sizeof(range),",
          "515:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "516:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "517:                  r1, r1 + cl - 1, (int64_t) size);",
          "524:               \"Etag: %s\\r\\nContent-Length: \" MG_INT64_FMT \"\\r\\n%s%s\\r\\n\",",
          "526:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "[Added Lines]",
          "508:         mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",",
          "509:                     (int64_t) size);",
          "513:         mg_snprintf(range, sizeof(range),",
          "514:                     \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,",
          "515:                     (int64_t) size);",
          "519:     mg_snprintf(tmp, sizeof(tmp), \"Content-Length: %lld\\r\\n\", cl);",
          "520:     LOG(LL_INFO, (\"TMP: [%s]\", tmp));",
          "523:               \"Etag: %s\\r\\n%s%s%s\\r\\n\",",
          "525:               etag, tmp, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "546:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "547:   size_t size = 0;",
          "548:   time_t t = 0;",
          "550:   int flags, n = 0;",
          "554:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "555:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "556:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "557:   } else {",
          "558:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "560:     if (flags & MG_FS_DIR) {",
          "568:     } else {",
          "570:     }",
          "572:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "573:     mg_printf(d->c,",
          "574:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "",
          "[Removed Lines]",
          "549:   char path[MG_PATH_MAX], sz[64], mod[64];",
          "553:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {",
          "559:     struct tm tm;",
          "561:       snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "562:     } else if (size < 1024) {",
          "563:       snprintf(sz, sizeof(sz), \"%d\", (int) size);",
          "564:     } else if (size < 0x100000) {",
          "565:       snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);",
          "566:     } else if (size < 0x40000000) {",
          "567:       snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);",
          "569:       snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);",
          "571:     strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&t, &tm));",
          "",
          "[Added Lines]",
          "548:   char path[MG_PATH_MAX], sz[40], mod[40];",
          "552:   if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >",
          "553:       sizeof(path)) {",
          "560:       mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "562:       mg_snprintf(sz, sizeof(sz), \"%llx\", (uint64_t) size);",
          "564:     mg_snprintf(mod, sizeof(mod), \"%lx\", (unsigned long) t);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "636:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "637:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "638:             MG_VERSION);",
          "641:   if (n > sizeof(tmp)) n = 0;",
          "642:   memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "643: }",
          "",
          "[Removed Lines]",
          "639:   n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "640:                         (unsigned long) (c->send.len - off));",
          "",
          "[Added Lines]",
          "632:   n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "668:                         char *path, size_t path_size) {",
          "669:   int flags = 0, tmp;",
          "672:   if (n > path_size) n = path_size;",
          "673:   path[path_size - 1] = '\\0';",
          "674:   if ((fs->st(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "[Removed Lines]",
          "671:   size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "",
          "[Added Lines]",
          "663:   size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "697:                 (int) hm->uri.len, hm->uri.ptr);",
          "698:       flags = 0;",
          "699:     } else if (flags & MG_FS_DIR) {",
          "701:             (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "703:             (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "704:         flags = tmp;",
          "705:       } else {",
          "",
          "[Removed Lines]",
          "700:       if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "702:            (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "",
          "[Added Lines]",
          "692:       if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "694:            (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "771:     int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);",
          "772:     const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);",
          "773:     if (p != NULL) {",
          "776:     }",
          "777:   } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {",
          "779:   } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {",
          "780:     struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));",
          "782:   } else {",
          "783:     mg_http_get_var(&hm->query, \"access_token\", pass, passlen);",
          "784:   }",
          "",
          "[Removed Lines]",
          "774:       snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);",
          "775:       snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);",
          "778:     snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "781:     if (t.len > 0) snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "",
          "[Added Lines]",
          "766:       mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);",
          "767:       mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);",
          "770:     mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "773:     if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "893:   } else {",
          "894:     struct mg_fd *fd;",
          "895:     long oft = strtol(offset, NULL, 0);",
          "897:     remove_double_dots(path);",
          "898:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "899:     if (oft == 0) fs->rm(path);",
          "",
          "[Removed Lines]",
          "896:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "[Added Lines]",
          "888:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "",
          "---------------"
        ],
        "src/log.c||src/log.c": [
          "File: src/log.c -> src/log.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:   }",
          "37:   if (level <= max) {",
          "48:     s_fn(buf, sizeof(buf) - 1, s_fn_param);",
          "49:     return true;",
          "50:   } else {",
          "",
          "[Removed Lines]",
          "38:     char timebuf[21], buf[50] = \"\";",
          "39:     time_t t = time(NULL);",
          "40:     struct tm tmp, *tm = gmtime_r(&t, &tmp);",
          "41:     int n;",
          "42:     (void) tmp;",
          "43:     strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S\", tm);",
          "44:     n = snprintf(buf, sizeof(buf), \"%s %d %s:%d:%s\", timebuf, level, p, line,",
          "45:                  fname);",
          "46:     if (n < 0 || n > (int) sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "47:     while (n < (int) sizeof(buf) - 1) buf[n++] = ' ';",
          "",
          "[Added Lines]",
          "38:     char buf[40];",
          "39:     size_t n = mg_snprintf(buf, sizeof(buf), \"%llx %d %s:%d:%s\", mg_millis(),",
          "40:                            level, p, line, fname);",
          "41:     if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "42:     while (n < sizeof(buf) - 1) buf[n++] = ' ';",
          "",
          "---------------"
        ],
        "src/mqtt.c||src/mqtt.c": [
          "File: src/mqtt.c -> src/mqtt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:     if (len_len >= 4) return MQTT_MALFORMED;",
          "135:   }",
          "136:   end = p + n;",
          "138:   m->dgram.len = (size_t) (end - buf);",
          "140:   switch (m->cmd) {",
          "",
          "[Removed Lines]",
          "137:   if (lc & 0x80 || end > buf + len) return MQTT_INCOMPLETE;",
          "",
          "[Added Lines]",
          "137:   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;",
          "",
          "---------------"
        ],
        "src/net.c||src/net.c": [
          "File: src/net.c -> src/net.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:   char tmp[30];",
          "24:   const char *fmt = a->is_ip6 ? \"[%s]:%d\" : \"%s:%d\";",
          "25:   mg_ntoa(a, tmp, sizeof(tmp));",
          "27:   return buf;",
          "28: }",
          "30: char *mg_ntoa(const struct mg_addr *addr, char *buf, size_t len) {",
          "31:   if (addr->is_ip6) {",
          "32:     uint16_t *p = (uint16_t *) addr->ip6;",
          "36:   } else {",
          "37:     uint8_t p[4];",
          "38:     memcpy(p, &addr->ip, sizeof(p));",
          "41:   }",
          "42:   return buf;",
          "43: }",
          "",
          "[Removed Lines]",
          "26:   snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));",
          "33:     snprintf(buf, len, \"%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx\", mg_htons(p[0]),",
          "34:              mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),",
          "35:              mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));",
          "39:     snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],",
          "40:              (int) p[3]);",
          "",
          "[Added Lines]",
          "26:   mg_snprintf(buf, len, fmt, tmp, (int) mg_ntohs(a->port));",
          "33:     mg_snprintf(buf, len, \"%x:%x:%x:%x:%x:%x:%x:%x\", mg_htons(p[0]),",
          "34:                 mg_htons(p[1]), mg_htons(p[2]), mg_htons(p[3]), mg_htons(p[4]),",
          "35:                 mg_htons(p[5]), mg_htons(p[6]), mg_htons(p[7]));",
          "39:     mg_snprintf(buf, len, \"%d.%d.%d.%d\", (int) p[0], (int) p[1], (int) p[2],",
          "40:                 (int) p[3]);",
          "",
          "---------------"
        ],
        "src/ssi.c||src/ssi.c": [
          "File: src/ssi.c -> src/ssi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:           char tmp[MG_PATH_MAX + BUFSIZ + 10],",
          "23:           while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;",
          "25:           if (depth < MG_MAX_SSI_DEPTH &&",
          "26:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "27:             mg_iobuf_add(&b, b.len, data, strlen(data), align);",
          "",
          "[Removed Lines]",
          "24:           snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "",
          "[Added Lines]",
          "24:           mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31:           }",
          "32:         } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {",
          "33:           char tmp[MG_PATH_MAX + BUFSIZ + 10], *data;",
          "35:           if (depth < MG_MAX_SSI_DEPTH &&",
          "36:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "37:             mg_iobuf_add(&b, b.len, data, strlen(data), align);",
          "",
          "[Removed Lines]",
          "34:           snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "",
          "[Added Lines]",
          "34:           mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "",
          "---------------"
        ],
        "src/str.c||src/str.c": [
          "File: src/str.c -> src/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:   return off > 0;",
          "147: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149: size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {",
          "150:   const char *letters = \"0123456789abcdef\";",
          "151:   uint64_t v = (uint64_t) val;",
          "152:   size_t s = 0, n, i;",
          "153:   if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);",
          "157:   if (is_hex) {",
          "158:     for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];",
          "159:   } else {",
          "160:     for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];",
          "161:   }",
          "163:   for (i = 0; i < n / 2; i++) {",
          "164:     char t = buf[s + i];",
          "165:     buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;",
          "166:   }",
          "167:   if (val == 0) buf[n++] = '0';  // Handle special case",
          "168:   return n + s;",
          "169: }",
          "171: static size_t mg_copys(char *buf, size_t len, size_t n, char *p, size_t k) {",
          "172:   size_t j = 0;",
          "173:   for (j = 0; j < k && j + n < len && p[j]; j++) buf[n + j] = p[j];",
          "174:   return j;",
          "175: }",
          "177: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap) {",
          "178:   size_t i = 0, n = 0;",
          "179:   while (fmt[i] != '\\0') {",
          "180:     if (fmt[i] == '%') {",
          "181:       size_t j, k, is_long = 0, w = 0 /* width */, pr = 0 /* precision */;",
          "182:       char pad = ' ', c = fmt[++i];",
          "183:       if (c == '0') pad = '0', c = fmt[++i];",
          "184:       while (isdigit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];",
          "185:       if (c == '.') {",
          "186:         c = fmt[++i];",
          "187:         if (c == '*') {",
          "188:           pr = (size_t) va_arg(ap, int);",
          "189:           c = fmt[++i];",
          "190:         } else {",
          "191:           while (isdigit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];",
          "192:         }",
          "193:       }",
          "194:       if (c == 'l') {",
          "195:         is_long++, c = fmt[++i];",
          "196:         if (c == 'l') is_long++, c = fmt[++i];",
          "197:       }",
          "198:       if (c == 'd' || c == 'u' || c == 'x') {",
          "199:         bool s = (c == 'd'), h = (c == 'x');",
          "200:         char tmp[30];",
          "201:         if (is_long == 2) {",
          "202:           int64_t v = va_arg(ap, int64_t);",
          "203:           k = mg_lld(tmp, v, s, h);",
          "204:         } else if (is_long == 1) {",
          "205:           long v = va_arg(ap, long);",
          "206:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);",
          "207:         } else {",
          "208:           int v = va_arg(ap, int);",
          "209:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);",
          "210:         }",
          "211:         for (j = 0; n < len && k < w && j + k < w; j++) buf[n++] = pad;",
          "212:         mg_copys(buf, len, n, tmp, k);",
          "213:         n += k;",
          "214:       } else if (c == 'c') {",
          "215:         int p = va_arg(ap, int);",
          "216:         if (n < len) buf[n] = (char) p;",
          "217:         n++;",
          "218:       } else if (c == 's') {",
          "219:         char *p = va_arg(ap, char *);",
          "220:         if (pr == 0) pr = p == NULL ? 0 : strlen(p);",
          "221:         for (j = 0; n < len && pr < w && j + pr < w; j++) buf[n++] = pad;",
          "222:         n += mg_copys(buf, len, n, p, pr);",
          "223:       }",
          "224:       i++;",
          "225:     } else {",
          "226:       if (n < len) buf[n] = fmt[i];",
          "227:       n++, i++;",
          "228:     }",
          "229:   }",
          "230:   if (n < len) buf[n] = '\\0';",
          "231:   return n;",
          "232: }",
          "234: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {",
          "235:   va_list ap;",
          "236:   size_t n;",
          "237:   va_start(ap, fmt);",
          "238:   n = mg_vsnprintf(buf, len, fmt, ap);",
          "239:   va_end(ap);",
          "240:   return n;",
          "241: }",
          "243: char *mg_hexdump(const void *buf, size_t len) {",
          "244:   const unsigned char *p = (const unsigned char *) buf;",
          "245:   size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;",
          "246:   char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);",
          "247:   if (dst == NULL) return dst;",
          "248:   for (i = 0; i < len; i++) {",
          "249:     idx = i % 16;",
          "250:     if (idx == 0) {",
          "251:       if (i > 0 && dlen > n)",
          "252:         n += mg_snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "253:       if (dlen > n)",
          "254:         n += mg_snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));",
          "255:     }",
          "256:     if (dlen < n) break;",
          "257:     n += mg_snprintf(dst + n, dlen - n, \" %02x\", p[i]);",
          "258:     ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);",
          "259:     ascii[idx + 1] = '\\0';",
          "260:   }",
          "261:   while (i++ % 16) {",
          "262:     if (n < dlen) n += mg_snprintf(dst + n, dlen - n, \"%s\", \"   \");",
          "263:   }",
          "264:   if (n < dlen) n += mg_snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "265:   if (n > dlen - 1) n = dlen - 1;",
          "266:   dst[n] = '\\0';",
          "267:   return dst;",
          "268: }",
          "270: char *mg_hex(const void *buf, size_t len, char *to) {",
          "271:   const unsigned char *p = (const unsigned char *) buf;",
          "272:   static const char *hex = \"0123456789abcdef\";",
          "273:   size_t i = 0;",
          "274:   for (; len--; p++) {",
          "275:     to[i++] = hex[p[0] >> 4];",
          "276:     to[i++] = hex[p[0] & 0x0f];",
          "277:   }",
          "278:   to[i] = '\\0';",
          "279:   return to;",
          "280: }",
          "282: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "283:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "284:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "285:                                   : (unsigned char) (c - 'W');",
          "286: }",
          "288: unsigned long mg_unhexn(const char *s, size_t len) {",
          "289:   unsigned long i = 0, v = 0;",
          "290:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "291:   return v;",
          "292: }",
          "294: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "295:   size_t i;",
          "296:   for (i = 0; i < len; i += 2) {",
          "297:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "298:   }",
          "299: }",
          "301: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {",
          "302:   va_list ap_copy;",
          "303:   int len;",
          "305:   va_copy(ap_copy, ap);",
          "306:   len = vsnprintf(*buf, size, fmt, ap_copy);",
          "307:   va_end(ap_copy);",
          "309:   if (len < 0) {",
          "315:     while (len < 0) {",
          "316:       free(*buf);",
          "317:       if (size == 0) size = 5;",
          "318:       size *= 2;",
          "319:       if ((*buf = (char *) calloc(1, size)) == NULL) {",
          "320:         len = -1;",
          "321:         break;",
          "322:       }",
          "323:       va_copy(ap_copy, ap);",
          "324:       len = vsnprintf(*buf, size - 1, fmt, ap_copy);",
          "325:       va_end(ap_copy);",
          "326:     }",
          "329:     if (*buf != NULL) (*buf)[len] = 0;",
          "331:   } else if (len >= (int) size) {",
          "333:     if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {",
          "334:       len = -1;  // LCOV_EXCL_LINE",
          "335:     } else {     // LCOV_EXCL_LINE",
          "336:       va_copy(ap_copy, ap);",
          "337:       len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);",
          "338:       va_end(ap_copy);",
          "339:     }",
          "340:   }",
          "342:   return len;",
          "343: }",
          "345: int mg_asprintf(char **buf, size_t size, const char *fmt, ...) {",
          "346:   int ret;",
          "347:   va_list ap;",
          "348:   va_start(ap, fmt);",
          "349:   ret = mg_vasprintf(buf, size, fmt, ap);",
          "350:   va_end(ap);",
          "351:   return ret;",
          "352: }",
          "354: int64_t mg_to64(struct mg_str str) {",
          "355:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "356:   size_t i = 0;",
          "357:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "358:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "359:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "360:     if (result > max) return 0;",
          "361:     result *= 10;",
          "362:     result += (str.ptr[i] - '0');",
          "363:     i++;",
          "364:   }",
          "365:   return result * neg;",
          "366: }",
          "",
          "---------------"
        ],
        "src/str.h||src/str.h": [
          "File: src/str.h -> src/str.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: bool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);",
          "31: bool mg_globmatch(const char *pattern, size_t plen, const char *s, size_t n);",
          "32: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v);",
          "34: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap);",
          "35: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...);",
          "36: char *mg_hexdump(const void *buf, size_t len);",
          "37: char *mg_hex(const void *buf, size_t len, char *dst);",
          "38: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "39: unsigned long mg_unhexn(const char *s, size_t len);",
          "40: int mg_asprintf(char **buf, size_t size, const char *fmt, ...);",
          "41: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap);",
          "42: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "43: int64_t mg_to64(struct mg_str str);",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:   return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));",
          "39: }",
          "166: uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {",
          "167:   int i;",
          "168:   crc = ~crc;",
          "",
          "[Removed Lines]",
          "41: char *mg_hexdump(const void *buf, size_t len) {",
          "42:   const unsigned char *p = (const unsigned char *) buf;",
          "43:   size_t i, idx, n = 0, ofs = 0, dlen = len * 5 + 100;",
          "44:   char ascii[17] = \"\", *dst = (char *) calloc(1, dlen);",
          "45:   if (dst == NULL) return dst;",
          "46:   for (i = 0; i < len; i++) {",
          "47:     idx = i % 16;",
          "48:     if (idx == 0) {",
          "49:       if (i > 0 && dlen > n)",
          "50:         n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "51:       if (dlen > n)",
          "52:         n += (size_t) snprintf(dst + n, dlen - n, \"%04x \", (int) (i + ofs));",
          "53:     }",
          "54:     if (dlen < n) break;",
          "55:     n += (size_t) snprintf(dst + n, dlen - n, \" %02x\", p[i]);",
          "56:     ascii[idx] = (char) (p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i]);",
          "57:     ascii[idx + 1] = '\\0';",
          "58:   }",
          "59:   while (i++ % 16) {",
          "60:     if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"%s\", \"   \");",
          "61:   }",
          "62:   if (n < dlen) n += (size_t) snprintf(dst + n, dlen - n, \"  %s\\n\", ascii);",
          "63:   if (n > dlen - 1) n = dlen - 1;",
          "64:   dst[n] = '\\0';",
          "65:   return dst;",
          "66: }",
          "68: char *mg_hex(const void *buf, size_t len, char *to) {",
          "69:   const unsigned char *p = (const unsigned char *) buf;",
          "70:   static const char *hex = \"0123456789abcdef\";",
          "71:   size_t i = 0;",
          "72:   for (; len--; p++) {",
          "73:     to[i++] = hex[p[0] >> 4];",
          "74:     to[i++] = hex[p[0] & 0x0f];",
          "75:   }",
          "76:   to[i] = '\\0';",
          "77:   return to;",
          "78: }",
          "80: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "81:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "82:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "83:                                   : (unsigned char) (c - 'W');",
          "84: }",
          "86: unsigned long mg_unhexn(const char *s, size_t len) {",
          "87:   unsigned long i = 0, v = 0;",
          "88:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "89:   return v;",
          "90: }",
          "92: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "93:   size_t i;",
          "94:   for (i = 0; i < len; i += 2) {",
          "95:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "96:   }",
          "97: }",
          "99: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap) {",
          "100:   va_list ap_copy;",
          "101:   int len;",
          "103:   va_copy(ap_copy, ap);",
          "104:   len = vsnprintf(*buf, size, fmt, ap_copy);",
          "105:   va_end(ap_copy);",
          "107:   if (len < 0) {",
          "113:     while (len < 0) {",
          "114:       free(*buf);",
          "115:       if (size == 0) size = 5;",
          "116:       size *= 2;",
          "117:       if ((*buf = (char *) calloc(1, size)) == NULL) {",
          "118:         len = -1;",
          "119:         break;",
          "120:       }",
          "121:       va_copy(ap_copy, ap);",
          "122:       len = vsnprintf(*buf, size - 1, fmt, ap_copy);",
          "123:       va_end(ap_copy);",
          "124:     }",
          "127:     if (*buf != NULL) (*buf)[len] = 0;",
          "129:   } else if (len >= (int) size) {",
          "131:     if ((*buf = (char *) calloc(1, (size_t) len + 1)) == NULL) {",
          "132:       len = -1;  // LCOV_EXCL_LINE",
          "133:     } else {     // LCOV_EXCL_LINE",
          "134:       va_copy(ap_copy, ap);",
          "135:       len = vsnprintf(*buf, (size_t) len + 1, fmt, ap_copy);",
          "136:       va_end(ap_copy);",
          "137:     }",
          "138:   }",
          "140:   return len;",
          "141: }",
          "143: int mg_asprintf(char **buf, size_t size, const char *fmt, ...) {",
          "144:   int ret;",
          "145:   va_list ap;",
          "146:   va_start(ap, fmt);",
          "147:   ret = mg_vasprintf(buf, size, fmt, ap);",
          "148:   va_end(ap);",
          "149:   return ret;",
          "150: }",
          "152: int64_t mg_to64(struct mg_str str) {",
          "153:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "154:   size_t i = 0;",
          "155:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "156:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "157:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "158:     if (result > max) return 0;",
          "159:     result *= 10;",
          "160:     result += (str.ptr[i] - '0');",
          "161:     i++;",
          "162:   }",
          "163:   return result * neg;",
          "164: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/util.h||src/util.h": [
          "File: src/util.h -> src/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: uint16_t mg_ntohs(uint16_t net);",
          "9: uint32_t mg_ntohl(uint32_t net);",
          "10: uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len);",
          "19: int64_t mg_millis(void);",
          "21: #define mg_htons(x) mg_ntohs(x)",
          "",
          "[Removed Lines]",
          "11: char *mg_hexdump(const void *buf, size_t len);",
          "12: char *mg_hex(const void *buf, size_t len, char *dst);",
          "13: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "14: unsigned long mg_unhexn(const char *s, size_t len);",
          "15: int mg_asprintf(char **buf, size_t size, const char *fmt, ...);",
          "16: int mg_vasprintf(char **buf, size_t size, const char *fmt, va_list ap);",
          "17: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "18: int64_t mg_to64(struct mg_str str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "315:         \"\\xc9\\xd6\\xa2\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\"",
          "316:         \"\\xed\\x98\\x00\\x00\\x00\\xde\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\"",
          "317:         \"\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";",
          "320:     ASSERT((ms = mg_sntp_parse(sntp_good, sizeof(sntp_good))) > 0);",
          "322:     gmtime_r(&t, &tm);",
          "323:     ASSERT(tm.tm_year == 116);",
          "324:     ASSERT(tm.tm_mon == 10);",
          "",
          "[Removed Lines]",
          "318:     struct tm tm;",
          "319:     time_t t;",
          "321:     t = (time_t) (ms / 1000);",
          "",
          "[Added Lines]",
          "319: #if MG_ARCH == MG_ARCH_UNIX",
          "320:     time_t t = (time_t) (ms / 1000);",
          "321:     struct tm tm;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "326:     ASSERT(tm.tm_hour == 16);",
          "327:     ASSERT(tm.tm_min == 15);",
          "328:     ASSERT(tm.tm_sec == 21);",
          "329:     ASSERT(mg_sntp_parse(bad_good, sizeof(bad_good)) < 0);",
          "330:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1192: }",
          "1194: static void test_str(void) {",
          "1195:   struct mg_str s = mg_strdup(mg_str(\"a\"));",
          "1196:   ASSERT(mg_strcmp(s, mg_str(\"a\")) == 0);",
          "1197:   free((void *) s.ptr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1196:   char buf[100];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1201:   ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"d\")) == NULL);",
          "1202:   ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"b\")) != NULL);",
          "1203:   ASSERT(mg_strcmp(mg_str(\"hi\"), mg_strstrip(mg_str(\" \\thi\\r\\n\"))) == 0);",
          "1204: }",
          "1206: static void fn1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1207:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%d\", 0) == 1 && !strcmp(buf, \"0\"));",
          "1208:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%d\", 1) == 1 && !strcmp(buf, \"1\"));",
          "1209:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%d\", -1) == 2 && !strcmp(buf, \"-1\"));",
          "1210:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%.*s\", 1, \"ab\") == 1 &&",
          "1211:          !strcmp(buf, \"a\"));",
          "1212:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%.1s\", \"ab\") == 1 && !strcmp(buf, \"a\"));",
          "1213:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%.99s\", \"a\") == 1 && !strcmp(buf, \"a\"));",
          "1214:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%11s\", \"a\") == 11 &&",
          "1215:          !strcmp(buf, \"          a\"));",
          "1216:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%s\", \"a\\0b\") == 1 && !strcmp(buf, \"a\"));",
          "1217:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%2s\", \"a\") == 2 && !strcmp(buf, \" a\"));",
          "1218:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%.*s\", 3, \"a\\0b\") == 1 &&",
          "1219:          !strcmp(buf, \"a\"));",
          "1220:   memset(buf, 'x', sizeof(buf));",
          "1221:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%d\", 7) == 1 && !strcmp(buf, \"7\"));",
          "1222:   memset(buf, 0, sizeof(buf));",
          "1223:   ASSERT(mg_snprintf(buf, 0, \"%d\", 123) == 3 && buf[0] == '\\0');",
          "1224:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%lld\", (uint64_t) 0xffffffffff) == 13 &&",
          "1225:          !strcmp(buf, \"1099511627775\"));",
          "1226:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%llx\", (uint64_t) 0xffffffffff) == 10 &&",
          "1227:          !strcmp(buf, \"ffffffffff\"));",
          "1228:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%lx\", (unsigned long) 0x6204d754) ==",
          "1229:              8 &&",
          "1230:          !strcmp(buf, \"6204d754\"));",
          "1231:   ASSERT(mg_snprintf(buf, sizeof(buf), \"ab\") == 2 && !strcmp(buf, \"ab\"));",
          "1232:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%dx\", 1) == 2 && !strcmp(buf, \"1x\"));",
          "1233:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%sx\", \"a\") == 2 && !strcmp(buf, \"ax\"));",
          "1234:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%cx\", 32) == 2 && !strcmp(buf, \" x\"));",
          "1235:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%x\", 15) == 1 && !strcmp(buf, \"f\"));",
          "1236:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%2x\", 15) == 2 && !strcmp(buf, \" f\"));",
          "1237:   ASSERT(mg_snprintf(buf, sizeof(buf), \"%02x\", 15) == 2 && !strcmp(buf, \"0f\"));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1697: int main(void) {",
          "1698:   mg_log_set(\"3\");",
          "1699:   test_globmatch();",
          "1700:   test_get_header_var();",
          "1701:   test_rewrites();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1733:   test_str();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1710:   test_util();",
          "1711:   test_sntp();",
          "1712:   test_dns();",
          "1714:   test_timer();",
          "1715:   test_url();",
          "1716:   test_iobuf();",
          "",
          "[Removed Lines]",
          "1713:   test_str();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f1da8542ce7276ae8e57ae0042ee7a375350b802",
      "candidate_info": {
        "commit_hash": "f1da8542ce7276ae8e57ae0042ee7a375350b802",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/f1da8542ce7276ae8e57ae0042ee7a375350b802",
        "files": [
          "docs/README.md",
          "mongoose.c",
          "mongoose.h",
          "src/arch_unix.h",
          "src/base64.c",
          "src/fs.h",
          "src/fs_dummy.c",
          "src/fs_fat.c",
          "src/fs_posix.c",
          "src/http.c",
          "src/iobuf.c",
          "src/iobuf.h",
          "src/log.c",
          "src/md5.c",
          "src/sha1.c",
          "src/sock.c",
          "src/ssi.c",
          "src/str.c",
          "src/url.c",
          "src/util.c"
        ],
        "message": "Nits",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/arch_unix.h||src/arch_unix.h",
          "src/base64.c||src/base64.c",
          "src/fs.h||src/fs.h",
          "src/fs_dummy.c||src/fs_dummy.c",
          "src/fs_fat.c||src/fs_fat.c",
          "src/fs_posix.c||src/fs_posix.c",
          "src/http.c||src/http.c",
          "src/iobuf.c||src/iobuf.c",
          "src/iobuf.h||src/iobuf.h",
          "src/log.c||src/log.c",
          "src/md5.c||src/md5.c",
          "src/sha1.c||src/sha1.c",
          "src/sock.c||src/sock.c",
          "src/ssi.c||src/ssi.c",
          "src/str.c||src/str.c",
          "src/url.c||src/url.c",
          "src/util.c||src/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #line 1 \"src/base64.c\"",
          "24: #endif",
          "28: static int mg_b64idx(int c) {",
          "29:   if (c < 26) {",
          "",
          "[Removed Lines]",
          "26: #include <string.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "907:   return result;",
          "908: }",
          "910: #ifdef MG_ENABLE_LINES",
          "911: #line 1 \"src/fs_fat.c\"",
          "912: #endif",
          "915: #if MG_ENABLE_FATFS",
          "916: #include <ff.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "910: #ifdef MG_ENABLE_LINES",
          "911: #line 1 \"src/fs_dummy.c\"",
          "912: #endif",
          "915: static int d_stat(const char *path, size_t *size, time_t *mtime) {",
          "916:   (void) path, (void) size, (void) mtime;",
          "917:   return 0;",
          "918: }",
          "919: static void d_list(const char *path, void (*fn)(const char *, void *),",
          "920:                    void *userdata) {",
          "921:   (void) path, (void) fn, (void) userdata;",
          "922: }",
          "923: static void *d_open(const char *path, int flags) {",
          "924:   (void) path, (void) flags;",
          "925:   return NULL;",
          "926: }",
          "927: static void d_close(void *fp) {",
          "928:   (void) fp;",
          "929: }",
          "930: static size_t d_read(void *fd, void *buf, size_t len) {",
          "931:   (void) fd, (void) buf, (void) len;",
          "932:   return 0;",
          "933: }",
          "934: static size_t d_write(void *fd, const void *buf, size_t len) {",
          "935:   (void) fd, (void) buf, (void) len;",
          "936:   return 0;",
          "937: }",
          "938: static size_t d_seek(void *fd, size_t offset) {",
          "939:   (void) fd, (void) offset;",
          "940:   return (size_t) ~0;",
          "941: }",
          "942: static bool d_rename(const char *from, const char *to) {",
          "943:   (void) from, (void) to;",
          "944:   return false;",
          "945: }",
          "946: static bool d_remove(const char *path) {",
          "947:   (void) path;",
          "948:   return false;",
          "949: }",
          "950: static bool d_mkdir(const char *path) {",
          "951:   (void) path;",
          "952:   return false;",
          "953: }",
          "955: struct mg_fs mg_fs_dummy = {d_stat,  d_list, d_open,   d_close,  d_read,",
          "956:                             d_write, d_seek, d_rename, d_remove, d_mkdir};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1364:   return mkdir(path, 0775) == 0;",
          "1365: }",
          "1408: #endif",
          "1410: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,",
          "",
          "[Removed Lines]",
          "1367: #else",
          "1369: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "1370:   (void) path, (void) size, (void) mtime;",
          "1371:   return 0;",
          "1372: }",
          "1373: static void p_list(const char *path, void (*fn)(const char *, void *),",
          "1374:                    void *userdata) {",
          "1375:   (void) path, (void) fn, (void) userdata;",
          "1376: }",
          "1377: static void *p_open(const char *path, int flags) {",
          "1378:   (void) path, (void) flags;",
          "1379:   return NULL;",
          "1380: }",
          "1381: static void p_close(void *fp) {",
          "1382:   (void) fp;",
          "1383: }",
          "1384: static size_t p_read(void *fd, void *buf, size_t len) {",
          "1385:   (void) fd, (void) buf, (void) len;",
          "1386:   return 0;",
          "1387: }",
          "1388: static size_t p_write(void *fd, const void *buf, size_t len) {",
          "1389:   (void) fd, (void) buf, (void) len;",
          "1390:   return 0;",
          "1391: }",
          "1392: static size_t p_seek(void *fd, size_t offset) {",
          "1393:   (void) fd, (void) offset;",
          "1394:   return (size_t) ~0;",
          "1395: }",
          "1396: static bool p_rename(const char *from, const char *to) {",
          "1397:   (void) from, (void) to;",
          "1398:   return false;",
          "1399: }",
          "1400: static bool p_remove(const char *path) {",
          "1401:   (void) path;",
          "1402:   return false;",
          "1403: }",
          "1404: static bool p_mkdir(const char *path) {",
          "1405:   (void) path;",
          "1406:   return false;",
          "1407: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1890:               opts->extra_headers ? opts->extra_headers : \"\");",
          "1891:   } else {",
          "1892:     int n, status = 200;",
          "1894:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "1897:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "1898:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {",
          "1900:       if (n == 1) r2 = cl - 1;",
          "",
          "[Removed Lines]",
          "1893:     char range[100] = \"\";",
          "",
          "[Added Lines]",
          "1901:     char range[100];",
          "1906:     range[0] = '\\0';",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2096: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "2097:                        const struct mg_http_serve_opts *opts) {",
          "2099:   const char *sp = opts->ssi_pattern;",
          "2100:   int flags = uri_to_path(c, hm, opts, path, sizeof(path));",
          "2101:   if (flags < 0) {",
          "",
          "[Removed Lines]",
          "2098:   char path[MG_PATH_MAX] = \"\";",
          "",
          "[Added Lines]",
          "2107:   char path[MG_PATH_MAX];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2256: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "2257:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "2259:   long res = 0, offset;",
          "2260:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "2261:   offset = strtol(buf, NULL, 0);",
          "",
          "[Removed Lines]",
          "2258:   char buf[20] = \"\";",
          "",
          "[Added Lines]",
          "2267:   char buf[20] = \"0\";",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "2362: #include <string.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2697: static void default_logger(unsigned char c) {",
          "2698:   putchar(c);",
          "2699: }",
          "2701: static const char *s_spec = \"2\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2707:   (void) c;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2786: #ifdef MG_ENABLE_LINES",
          "2787: #line 1 \"src/md5.c\"",
          "2788: #endif",
          "2792: #if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5",
          "",
          "[Removed Lines]",
          "2789: #include <string.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2805: #if BYTE_ORDER == BIG_ENDIAN",
          "2806:   do {",
          "2808:                  ((unsigned) buf[1] << 8 | buf[0]);",
          "2810:     buf += 4;",
          "",
          "[Removed Lines]",
          "2807:     uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "",
          "[Added Lines]",
          "2816:     uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "3555: #include <string.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3964:   } else if (n > 0) {",
          "3965:     if (c->is_hexdumping) {",
          "3966:       union usa usa;",
          "3968:       socklen_t slen = sizeof(usa.sin);",
          "3969:       struct mg_addr a;",
          "3970:       memset(&usa, 0, sizeof(usa));",
          "",
          "[Removed Lines]",
          "3967:       char t1[50] = \"\", t2[50] = \"\";",
          "",
          "[Added Lines]",
          "3976:       char t1[50], t2[50];",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4493:   struct mg_iobuf b = {NULL, 0, 0};",
          "4494:   FILE *fp = fopen(path, \"rb\");",
          "4495:   if (fp != NULL) {",
          "4497:     int ch, intag = 0;",
          "4498:     size_t len = 0, align = MG_IO_SIZE;",
          "4499:     while ((ch = fgetc(fp)) != EOF) {",
          "4500:       if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {",
          "4501:         buf[len++] = (char) (ch & 0xff);",
          "4502:         if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {",
          "4503:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],",
          "",
          "[Removed Lines]",
          "4496:     char buf[MG_SSI_BUFSIZ] = \"\", arg[sizeof(buf)] = \"\";",
          "",
          "[Added Lines]",
          "4505:     char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];",
          "4508:     buf[0] = arg[0] = '\\0';",
          "4512:         buf[len] = '\\0';",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4577: #line 1 \"src/str.c\"",
          "4578: #endif",
          "4582: struct mg_str mg_str_s(const char *s) {",
          "4583:   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};",
          "",
          "[Removed Lines]",
          "4580: #include <stdlib.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5278: #line 1 \"src/url.c\"",
          "5279: #endif",
          "5283: struct url {",
          "5284:   size_t key, user, pass, host, port, uri, end;",
          "",
          "[Removed Lines]",
          "5281: #include <stdlib.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "5369: #endif",
          "5376: #if MG_ENABLE_CUSTOM_RANDOM",
          "5377: #else",
          "5378: void mg_random(void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "5372: #if MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)",
          "5373: #include <mach/mach_time.h>",
          "5374: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "414: #define _DARWIN_UNLIMITED_SELECT 1  // No limit on file descriptors",
          "416: #if !defined(MG_ENABLE_POLL) && (defined(__linux__) || defined(__APPLE__))",
          "417: #define MG_ENABLE_POLL 1",
          "418: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "416: #if defined(__APPLE__)",
          "417: #include <mach/mach_time.h>",
          "418: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "817:   bool (*mkd)(const char *path);                        // Create directory",
          "818: };",
          "820: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "821: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/device-dashboard",
          "822: extern struct mg_fs mg_fs_fat;     // FAT FS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "824: extern struct mg_fs mg_fs_dummy;   // Dummy FS, does nothing",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "878: const char *mg_url_uri(const char *url);",
          "883: struct mg_iobuf {",
          "884:   unsigned char *buf;  // Pointer to stored data",
          "",
          "[Removed Lines]",
          "881: #include <stddef.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/arch_unix.h||src/arch_unix.h": [
          "File: src/arch_unix.h -> src/arch_unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define _DARWIN_UNLIMITED_SELECT 1  // No limit on file descriptors",
          "7: #if !defined(MG_ENABLE_POLL) && (defined(__linux__) || defined(__APPLE__))",
          "8: #define MG_ENABLE_POLL 1",
          "9: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #if defined(__APPLE__)",
          "8: #include <mach/mach_time.h>",
          "9: #endif",
          "",
          "---------------"
        ],
        "src/base64.c||src/base64.c": [
          "File: src/base64.c -> src/base64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"base64.h\"",
          "4: static int mg_b64idx(int c) {",
          "5:   if (c < 26) {",
          "",
          "[Removed Lines]",
          "2: #include <string.h>",
          "",
          "[Added Lines]",
          "2: #include \"arch.h\"",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:   bool (*mkd)(const char *path);                        // Create directory",
          "26: };",
          "28: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "29: extern struct mg_fs mg_fs_packed;  // Packed FS, see examples/device-dashboard",
          "30: extern struct mg_fs mg_fs_fat;     // FAT FS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: extern struct mg_fs mg_fs_dummy;   // Dummy FS, does nothing",
          "",
          "---------------"
        ],
        "src/fs_dummy.c||src/fs_dummy.c": [
          "File: src/fs_dummy.c -> src/fs_dummy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"fs.h\"",
          "3: static int d_stat(const char *path, size_t *size, time_t *mtime) {",
          "4:   (void) path, (void) size, (void) mtime;",
          "5:   return 0;",
          "6: }",
          "7: static void d_list(const char *path, void (*fn)(const char *, void *),",
          "8:                    void *userdata) {",
          "9:   (void) path, (void) fn, (void) userdata;",
          "10: }",
          "11: static void *d_open(const char *path, int flags) {",
          "12:   (void) path, (void) flags;",
          "13:   return NULL;",
          "14: }",
          "15: static void d_close(void *fp) {",
          "16:   (void) fp;",
          "17: }",
          "18: static size_t d_read(void *fd, void *buf, size_t len) {",
          "19:   (void) fd, (void) buf, (void) len;",
          "20:   return 0;",
          "21: }",
          "22: static size_t d_write(void *fd, const void *buf, size_t len) {",
          "23:   (void) fd, (void) buf, (void) len;",
          "24:   return 0;",
          "25: }",
          "26: static size_t d_seek(void *fd, size_t offset) {",
          "27:   (void) fd, (void) offset;",
          "28:   return (size_t) ~0;",
          "29: }",
          "30: static bool d_rename(const char *from, const char *to) {",
          "31:   (void) from, (void) to;",
          "32:   return false;",
          "33: }",
          "34: static bool d_remove(const char *path) {",
          "35:   (void) path;",
          "36:   return false;",
          "37: }",
          "38: static bool d_mkdir(const char *path) {",
          "39:   (void) path;",
          "40:   return false;",
          "41: }",
          "43: struct mg_fs mg_fs_dummy = {d_stat,  d_list, d_open,   d_close,  d_read,",
          "44:                             d_write, d_seek, d_rename, d_remove, d_mkdir};",
          "",
          "---------------"
        ],
        "src/fs_fat.c||src/fs_fat.c": [
          "File: src/fs_fat.c -> src/fs_fat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"fs.h\"",
          "3: #if MG_ENABLE_FATFS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"arch.h\"",
          "",
          "---------------"
        ],
        "src/fs_posix.c||src/fs_posix.c": [
          "File: src/fs_posix.c -> src/fs_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202:   return mkdir(path, 0775) == 0;",
          "203: }",
          "246: #endif",
          "248: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,",
          "",
          "[Removed Lines]",
          "205: #else",
          "207: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "208:   (void) path, (void) size, (void) mtime;",
          "209:   return 0;",
          "210: }",
          "211: static void p_list(const char *path, void (*fn)(const char *, void *),",
          "212:                    void *userdata) {",
          "213:   (void) path, (void) fn, (void) userdata;",
          "214: }",
          "215: static void *p_open(const char *path, int flags) {",
          "216:   (void) path, (void) flags;",
          "217:   return NULL;",
          "218: }",
          "219: static void p_close(void *fp) {",
          "220:   (void) fp;",
          "221: }",
          "222: static size_t p_read(void *fd, void *buf, size_t len) {",
          "223:   (void) fd, (void) buf, (void) len;",
          "224:   return 0;",
          "225: }",
          "226: static size_t p_write(void *fd, const void *buf, size_t len) {",
          "227:   (void) fd, (void) buf, (void) len;",
          "228:   return 0;",
          "229: }",
          "230: static size_t p_seek(void *fd, size_t offset) {",
          "231:   (void) fd, (void) offset;",
          "232:   return (size_t) ~0;",
          "233: }",
          "234: static bool p_rename(const char *from, const char *to) {",
          "235:   (void) from, (void) to;",
          "236:   return false;",
          "237: }",
          "238: static bool p_remove(const char *path) {",
          "239:   (void) path;",
          "240:   return false;",
          "241: }",
          "242: static bool p_mkdir(const char *path) {",
          "243:   (void) path;",
          "244:   return false;",
          "245: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "475:               opts->extra_headers ? opts->extra_headers : \"\");",
          "476:   } else {",
          "477:     int n, status = 200;",
          "479:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "482:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "483:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {",
          "485:       if (n == 1) r2 = cl - 1;",
          "",
          "[Removed Lines]",
          "478:     char range[100] = \"\";",
          "",
          "[Added Lines]",
          "478:     char range[100];",
          "483:     range[0] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "681: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "682:                        const struct mg_http_serve_opts *opts) {",
          "684:   const char *sp = opts->ssi_pattern;",
          "685:   int flags = uri_to_path(c, hm, opts, path, sizeof(path));",
          "686:   if (flags < 0) {",
          "",
          "[Removed Lines]",
          "683:   char path[MG_PATH_MAX] = \"\";",
          "",
          "[Added Lines]",
          "684:   char path[MG_PATH_MAX];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "841: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "842:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "844:   long res = 0, offset;",
          "845:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "846:   offset = strtol(buf, NULL, 0);",
          "",
          "[Removed Lines]",
          "843:   char buf[20] = \"\";",
          "",
          "[Added Lines]",
          "844:   char buf[20] = \"0\";",
          "",
          "---------------"
        ],
        "src/iobuf.c||src/iobuf.c": [
          "File: src/iobuf.c -> src/iobuf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"iobuf.h\"",
          "2: #include \"log.h\"",
          "8: static void zeromem(volatile unsigned char *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "4: #include <string.h>",
          "",
          "[Added Lines]",
          "2: #include \"arch.h\"",
          "",
          "---------------"
        ],
        "src/iobuf.h||src/iobuf.h": [
          "File: src/iobuf.h -> src/iobuf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #pragma once",
          "5: struct mg_iobuf {",
          "6:   unsigned char *buf;  // Pointer to stored data",
          "",
          "[Removed Lines]",
          "3: #include <stddef.h>",
          "",
          "[Added Lines]",
          "3: #include \"arch.h\"",
          "",
          "---------------"
        ],
        "src/log.c||src/log.c": [
          "File: src/log.c -> src/log.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: static void default_logger(unsigned char c) {",
          "5:   putchar(c);",
          "6: }",
          "8: static const char *s_spec = \"2\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6:   (void) c;",
          "",
          "---------------"
        ],
        "src/md5.c||src/md5.c": [
          "File: src/md5.c -> src/md5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include \"md5.h\"",
          "4: #if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5",
          "5: #if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)",
          "",
          "[Removed Lines]",
          "1: #include <string.h>",
          "",
          "[Added Lines]",
          "2: #include \"arch.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17: #if BYTE_ORDER == BIG_ENDIAN",
          "18:   do {",
          "20:                  ((unsigned) buf[1] << 8 | buf[0]);",
          "22:     buf += 4;",
          "",
          "[Removed Lines]",
          "19:     uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "",
          "[Added Lines]",
          "19:     uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "",
          "---------------"
        ],
        "src/sha1.c||src/sha1.c": [
          "File: src/sha1.c -> src/sha1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"sha1.h\"",
          "",
          "[Removed Lines]",
          "4: #include <string.h>",
          "",
          "[Added Lines]",
          "4: #include \"arch.h\"",
          "",
          "---------------"
        ],
        "src/sock.c||src/sock.c": [
          "File: src/sock.c -> src/sock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:   } else if (n > 0) {",
          "119:     if (c->is_hexdumping) {",
          "120:       union usa usa;",
          "122:       socklen_t slen = sizeof(usa.sin);",
          "123:       struct mg_addr a;",
          "124:       memset(&usa, 0, sizeof(usa));",
          "",
          "[Removed Lines]",
          "121:       char t1[50] = \"\", t2[50] = \"\";",
          "",
          "[Added Lines]",
          "121:       char t1[50], t2[50];",
          "",
          "---------------"
        ],
        "src/ssi.c||src/ssi.c": [
          "File: src/ssi.c -> src/ssi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:   struct mg_iobuf b = {NULL, 0, 0};",
          "16:   FILE *fp = fopen(path, \"rb\");",
          "17:   if (fp != NULL) {",
          "19:     int ch, intag = 0;",
          "20:     size_t len = 0, align = MG_IO_SIZE;",
          "21:     while ((ch = fgetc(fp)) != EOF) {",
          "22:       if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {",
          "23:         buf[len++] = (char) (ch & 0xff);",
          "24:         if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {",
          "25:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],",
          "",
          "[Removed Lines]",
          "18:     char buf[MG_SSI_BUFSIZ] = \"\", arg[sizeof(buf)] = \"\";",
          "",
          "[Added Lines]",
          "18:     char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];",
          "21:     buf[0] = arg[0] = '\\0';",
          "25:         buf[len] = '\\0';",
          "",
          "---------------"
        ],
        "src/str.c||src/str.c": [
          "File: src/str.c -> src/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"str.h\"",
          "4: struct mg_str mg_str_s(const char *s) {",
          "5:   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};",
          "",
          "[Removed Lines]",
          "2: #include <stdlib.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/url.c||src/url.c": [
          "File: src/url.c -> src/url.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"url.h\"",
          "4: struct url {",
          "5:   size_t key, user, pass, host, port, uri, end;",
          "",
          "[Removed Lines]",
          "2: #include <stdlib.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"util.h\"",
          "7: #if MG_ENABLE_CUSTOM_RANDOM",
          "8: #else",
          "9: void mg_random(void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "3: #if MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)",
          "4: #include <mach/mach_time.h>",
          "5: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56412193e710666258a5fe4fa7d1a542b142ce5d",
      "candidate_info": {
        "commit_hash": "56412193e710666258a5fe4fa7d1a542b142ce5d",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/56412193e710666258a5fe4fa7d1a542b142ce5d",
        "files": [
          "docs/README.md",
          "mongoose.c",
          "mongoose.h",
          "src/http.c",
          "src/str.c",
          "src/str.h"
        ],
        "message": "Add mg_remove_double_dots(), hide mg_http_upload()",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/http.c||src/http.c",
          "src/str.c||src/str.c",
          "src/str.h||src/str.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2036:   memcpy(c->send.buf + off - 12, tmp, n);  // Set content length",
          "2037: }",
          "2060: static int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,",
          "2061:                         struct mg_fs *fs, struct mg_str url, struct mg_str dir,",
          "",
          "[Removed Lines]",
          "2039: static void remove_double_dots(char *s) {",
          "2040:   char *p = s;",
          "2041:   while (*s != '\\0') {",
          "2043:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "2044:       while (s[0] != '\\0') {",
          "2045:         if (s[0] == '/' || s[0] == '\\\\') {",
          "2046:           s++;",
          "2047:         } else if (s[0] == '.' && s[1] == '.' &&",
          "2048:                    (s[2] == '/' || s[2] == '\\\\')) {",
          "2049:           s += 2;",
          "2050:         } else {",
          "2051:           break;",
          "2052:         }",
          "2053:       }",
          "2054:     }",
          "2055:   }",
          "2057: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2069:   mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,",
          "2070:                 path_size - n, 0);",
          "2071:   path[path_size - 1] = '\\0';  // Double-check",
          "2073:   n = strlen(path);",
          "2074:   while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "2075:   flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);",
          "",
          "[Removed Lines]",
          "2072:   remove_double_dots(path);",
          "",
          "[Added Lines]",
          "2052:   mg_remove_double_dots(path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2288:     struct mg_fd *fd;",
          "2289:     long oft = strtol(offset, NULL, 0);",
          "2290:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "2292:     MG_DEBUG((\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "2293:     if (oft == 0) fs->rm(path);",
          "2294:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "",
          "[Removed Lines]",
          "2291:     remove_double_dots(path);",
          "",
          "[Added Lines]",
          "2271:     mg_remove_double_dots(path);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4815:   return result * neg;",
          "4816: }",
          "4818: #ifdef MG_ENABLE_LINES",
          "4819: #line 1 \"src/timer.c\"",
          "4820: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4797: char *mg_remove_double_dots(char *s) {",
          "4798:   char *p = s;",
          "4799:   while (*s != '\\0') {",
          "4801:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "4802:       while (s[0] != '\\0') {",
          "4803:         if (s[0] == '/' || s[0] == '\\\\') {",
          "4804:           s++;",
          "4805:         } else if (s[0] == '.' && s[1] == '.' &&",
          "4806:                    (s[2] == '/' || s[2] == '\\\\')) {",
          "4807:           s += 2;",
          "4808:         } else {",
          "4809:           break;",
          "4810:         }",
          "4811:       }",
          "4812:     }",
          "4813:   }",
          "4815:   return s;",
          "4816: }",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "725: size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex);",
          "726: double mg_atod(const char *buf, int len, int *numlen);",
          "727: size_t mg_dtoa(char *buf, size_t len, double d, int width);",
          "729: typedef void (*mg_pc_t)(char, void *);                  // Custom putchar",
          "730: typedef size_t (*mg_pm_t)(mg_pc_t, void *, va_list *);  // %M printer",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "728: char *mg_remove_double_dots(char *s);",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "621:   memcpy(c->send.buf + off - 12, tmp, n);  // Set content length",
          "622: }",
          "645: static int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,",
          "646:                         struct mg_fs *fs, struct mg_str url, struct mg_str dir,",
          "",
          "[Removed Lines]",
          "624: static void remove_double_dots(char *s) {",
          "625:   char *p = s;",
          "626:   while (*s != '\\0') {",
          "628:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "629:       while (s[0] != '\\0') {",
          "630:         if (s[0] == '/' || s[0] == '\\\\') {",
          "631:           s++;",
          "632:         } else if (s[0] == '.' && s[1] == '.' &&",
          "633:                    (s[2] == '/' || s[2] == '\\\\')) {",
          "634:           s += 2;",
          "635:         } else {",
          "636:           break;",
          "637:         }",
          "638:       }",
          "639:     }",
          "640:   }",
          "642: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "654:   mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,",
          "655:                 path_size - n, 0);",
          "656:   path[path_size - 1] = '\\0';  // Double-check",
          "658:   n = strlen(path);",
          "659:   while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "660:   flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);",
          "",
          "[Removed Lines]",
          "657:   remove_double_dots(path);",
          "",
          "[Added Lines]",
          "637:   mg_remove_double_dots(path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "873:     struct mg_fd *fd;",
          "874:     long oft = strtol(offset, NULL, 0);",
          "875:     mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "877:     MG_DEBUG((\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "878:     if (oft == 0) fs->rm(path);",
          "879:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "",
          "[Removed Lines]",
          "876:     remove_double_dots(path);",
          "",
          "[Added Lines]",
          "856:     mg_remove_double_dots(path);",
          "",
          "---------------"
        ],
        "src/str.c||src/str.c": [
          "File: src/str.c -> src/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:   }",
          "223:   return result * neg;",
          "224: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225: char *mg_remove_double_dots(char *s) {",
          "226:   char *p = s;",
          "227:   while (*s != '\\0') {",
          "229:     if (s[-1] == '/' || s[-1] == '\\\\') {",
          "230:       while (s[0] != '\\0') {",
          "231:         if (s[0] == '/' || s[0] == '\\\\') {",
          "232:           s++;",
          "233:         } else if (s[0] == '.' && s[1] == '.' &&",
          "234:                    (s[2] == '/' || s[2] == '\\\\')) {",
          "235:           s += 2;",
          "236:         } else {",
          "237:           break;",
          "238:         }",
          "239:       }",
          "240:     }",
          "241:   }",
          "243:   return s;",
          "244: }",
          "",
          "---------------"
        ],
        "src/str.h||src/str.h": [
          "File: src/str.h -> src/str.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex);",
          "41: double mg_atod(const char *buf, int len, int *numlen);",
          "42: size_t mg_dtoa(char *buf, size_t len, double d, int width);",
          "44: typedef void (*mg_pc_t)(char, void *);                  // Custom putchar",
          "45: typedef size_t (*mg_pm_t)(mg_pc_t, void *, va_list *);  // %M printer",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: char *mg_remove_double_dots(char *s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8cd4699dbcdb08834e2cbfc117ece013cc7ab519",
      "candidate_info": {
        "commit_hash": "8cd4699dbcdb08834e2cbfc117ece013cc7ab519",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/8cd4699dbcdb08834e2cbfc117ece013cc7ab519",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/arch_freertos_lwip.h",
          "src/fs.c",
          "src/fs.h",
          "src/http.c",
          "test/unit_test.c"
        ],
        "message": "Rename FS API functions to avoid conflicts",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/arch_freertos_lwip.h||src/arch_freertos_lwip.h",
          "src/fs.c||src/fs.c",
          "src/fs.h||src/fs.h",
          "src/http.c||src/http.c",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "413: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {",
          "414:   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "415:   if (fd != NULL) {",
          "417:     fd->fs = fs;",
          "418:     if (fd->fd == NULL) {",
          "419:       free(fd);",
          "",
          "[Removed Lines]",
          "416:     fd->fd = fs->open(path, flags);",
          "",
          "[Added Lines]",
          "416:     fd->fd = fs->op(path, flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "426: void mg_fs_close(struct mg_fd *fd) {",
          "427:   if (fd != NULL) {",
          "429:     free(fd);",
          "430:   }",
          "431: }",
          "",
          "[Removed Lines]",
          "428:     fd->fs->close(fd->fd);",
          "",
          "[Added Lines]",
          "428:     fd->fs->cl(fd->fd);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "434:   struct mg_fd *fd;",
          "435:   char *data = NULL;",
          "436:   size_t size = 0;",
          "438:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "439:     data = (char *) calloc(1, size + 1);",
          "440:     if (data != NULL) {",
          "442:         free(data);",
          "443:         data = NULL;",
          "444:       } else {",
          "",
          "[Removed Lines]",
          "437:   fs->stat(path, &size, NULL);",
          "441:       if (fs->read(fd->fd, data, size) != size) {",
          "",
          "[Added Lines]",
          "437:   fs->st(path, &size, NULL);",
          "441:       if (fs->rd(fd->fd, data, size) != size) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "458:   char tmp[MG_PATH_MAX];",
          "459:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "460:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "462:     mg_fs_close(fd);",
          "463:     if (result) {",
          "466:     } else {",
          "468:     }",
          "469:   }",
          "470:   return result;",
          "",
          "[Removed Lines]",
          "461:     result = fs->write(fd->fd, buf, len) == len;",
          "464:       fs->remove(path);",
          "465:       fs->rename(tmp, path);",
          "467:       fs->remove(tmp);",
          "",
          "[Added Lines]",
          "461:     result = fs->wr(fd->fd, buf, len) == len;",
          "464:       fs->rm(path);",
          "465:       fs->mv(tmp, path);",
          "467:       fs->rm(tmp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1337:     size_t n, max = 2 * MG_IO_SIZE;",
          "1338:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "1339:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "1342:     if (n > 0) c->send.len += n;",
          "1343:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "1344:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "1340:     n = fd->fs->read(fd->fd, c->send.buf + c->send.len,",
          "1341:                      c->send.size - c->send.len);",
          "",
          "[Added Lines]",
          "1340:     n = fd->fs->rd(fd->fd, c->send.buf + c->send.len,",
          "1341:                    c->send.size - c->send.len);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1434:   time_t mtime = 0;",
          "1435:   struct mg_str *inm = NULL;",
          "1438:     LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));",
          "1439:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "1440:     mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "1437:   if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {",
          "",
          "[Added Lines]",
          "1437:   if (fd == NULL || fs->st(path, &size, &mtime) == 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1467:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "1468:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "1469:                  r1, r1 + cl - 1, (int64_t) size);",
          "1471:       }",
          "1472:     }",
          "",
          "[Removed Lines]",
          "1470:         fs->seek(fd->fd, (size_t) r1);",
          "",
          "[Added Lines]",
          "1470:         fs->sk(fd->fd, (size_t) r1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1505:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {",
          "1506:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "1508:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "1509:   } else {",
          "1510:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "",
          "[Removed Lines]",
          "1507:   } else if ((flags = fs->stat(path, &size, &t)) == 0) {",
          "",
          "[Added Lines]",
          "1507:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1583:             (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,",
          "1584:             uri.ptr);",
          "1587:   mg_printf(c,",
          "1588:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "1589:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "",
          "[Removed Lines]",
          "1586:   fs->list(dir, printdirentry, &d);",
          "",
          "[Added Lines]",
          "1586:   fs->ls(dir, printdirentry, &d);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1623:   size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "1624:   if (n > path_size) n = path_size;",
          "1625:   path[path_size - 1] = '\\0';",
          "1627:     mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,",
          "1628:                   dir.ptr);",
          "1629:   } else {",
          "",
          "[Removed Lines]",
          "1626:   if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "[Added Lines]",
          "1626:   if ((fs->st(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1636:     LOG(LL_VERBOSE_DEBUG,",
          "1637:         (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));",
          "1638:     while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "1640:     if (flags == 0) {",
          "1641:       mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh",
          "1642:     } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&",
          "",
          "[Removed Lines]",
          "1639:     flags = fs->stat(path, NULL, NULL);                 // Does it exist?",
          "",
          "[Added Lines]",
          "1639:     flags = fs->st(path, NULL, NULL);                   // Does it exist?",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1650:       flags = 0;",
          "1651:     } else if (flags & MG_FS_DIR) {",
          "1652:       if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "1654:            (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "1656:         flags = tmp;",
          "1657:       } else {",
          "1658:         path[n] = '\\0';  // Remove appended index file name",
          "",
          "[Removed Lines]",
          "1653:             (tmp = fs->stat(path, NULL, NULL)) != 0) ||",
          "1655:             (tmp = fs->stat(path, NULL, NULL)) != 0))) {",
          "",
          "[Added Lines]",
          "1653:             (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "1655:             (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1852:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "1853:     remove_double_dots(path);",
          "1854:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "1856:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "1857:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "1858:       return -2;",
          "1859:     } else {",
          "1861:       mg_fs_close(fd);",
          "1862:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "1863:       return (int) hm->body.len;",
          "",
          "[Removed Lines]",
          "1855:     if (oft == 0) fs->remove(path);",
          "1860:       int written = (int) fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "",
          "[Added Lines]",
          "1855:     if (oft == 0) fs->rm(path);",
          "1860:       int written = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: #if MG_ARCH == MG_ARCH_FREERTOS_LWIP",
          "168: #include <stdarg.h>",
          "169: #include <stdbool.h>",
          "170: #include <stdint.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168: #include <ctype.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "642: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "647: struct mg_fs {",
          "658: };",
          "660: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "",
          "[Removed Lines]",
          "648:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "649:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "650:   void *(*open)(const char *path, int flags);              // Open file",
          "651:   void (*close)(void *fd);                                 // Close file",
          "652:   size_t (*read)(void *fd, void *buf, size_t len);         // Read file",
          "653:   size_t (*write)(void *fd, const void *buf, size_t len);  // Write file",
          "654:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "655:   bool (*rename)(const char *from, const char *to);        // Rename",
          "656:   bool (*remove)(const char *path);                        // Delete file",
          "657:   bool (*mkd)(const char *path);                           // Create directory",
          "",
          "[Added Lines]",
          "653:   int (*st)(const char *path, size_t *size, time_t *mtime);  // stat file",
          "654:   void (*ls)(const char *path, void (*fn)(const char *, void *), void *);",
          "655:   void *(*op)(const char *path, int flags);             // Open file",
          "656:   void (*cl)(void *fd);                                 // Close file",
          "657:   size_t (*rd)(void *fd, void *buf, size_t len);        // Read file",
          "658:   size_t (*wr)(void *fd, const void *buf, size_t len);  // Write file",
          "659:   size_t (*sk)(void *fd, size_t offset);                // Set file position",
          "660:   bool (*mv)(const char *from, const char *to);         // Rename file",
          "661:   bool (*rm)(const char *path);                         // Delete file",
          "662:   bool (*mkd)(const char *path);                        // Create directory",
          "",
          "---------------"
        ],
        "src/arch_freertos_lwip.h||src/arch_freertos_lwip.h": [
          "File: src/arch_freertos_lwip.h -> src/arch_freertos_lwip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #if MG_ARCH == MG_ARCH_FREERTOS_LWIP",
          "5: #include <stdarg.h>",
          "6: #include <stdbool.h>",
          "7: #include <stdint.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include <ctype.h>",
          "",
          "---------------"
        ],
        "src/fs.c||src/fs.c": [
          "File: src/fs.c -> src/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {",
          "5:   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "6:   if (fd != NULL) {",
          "8:     fd->fs = fs;",
          "9:     if (fd->fd == NULL) {",
          "10:       free(fd);",
          "",
          "[Removed Lines]",
          "7:     fd->fd = fs->open(path, flags);",
          "",
          "[Added Lines]",
          "7:     fd->fd = fs->op(path, flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17: void mg_fs_close(struct mg_fd *fd) {",
          "18:   if (fd != NULL) {",
          "20:     free(fd);",
          "21:   }",
          "22: }",
          "",
          "[Removed Lines]",
          "19:     fd->fs->close(fd->fd);",
          "",
          "[Added Lines]",
          "19:     fd->fs->cl(fd->fd);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "25:   struct mg_fd *fd;",
          "26:   char *data = NULL;",
          "27:   size_t size = 0;",
          "29:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "30:     data = (char *) calloc(1, size + 1);",
          "31:     if (data != NULL) {",
          "33:         free(data);",
          "34:         data = NULL;",
          "35:       } else {",
          "",
          "[Removed Lines]",
          "28:   fs->stat(path, &size, NULL);",
          "32:       if (fs->read(fd->fd, data, size) != size) {",
          "",
          "[Added Lines]",
          "28:   fs->st(path, &size, NULL);",
          "32:       if (fs->rd(fd->fd, data, size) != size) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "49:   char tmp[MG_PATH_MAX];",
          "50:   snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "51:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "53:     mg_fs_close(fd);",
          "54:     if (result) {",
          "57:     } else {",
          "59:     }",
          "60:   }",
          "61:   return result;",
          "",
          "[Removed Lines]",
          "52:     result = fs->write(fd->fd, buf, len) == len;",
          "55:       fs->remove(path);",
          "56:       fs->rename(tmp, path);",
          "58:       fs->remove(tmp);",
          "",
          "[Added Lines]",
          "52:     result = fs->wr(fd->fd, buf, len) == len;",
          "55:       fs->rm(path);",
          "56:       fs->mv(tmp, path);",
          "58:       fs->rm(tmp);",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };",
          "11: struct mg_fs {",
          "22: };",
          "24: extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek",
          "",
          "[Removed Lines]",
          "12:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "13:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "14:   void *(*open)(const char *path, int flags);              // Open file",
          "15:   void (*close)(void *fd);                                 // Close file",
          "16:   size_t (*read)(void *fd, void *buf, size_t len);         // Read file",
          "17:   size_t (*write)(void *fd, const void *buf, size_t len);  // Write file",
          "18:   size_t (*seek)(void *fd, size_t offset);                 // Set file position",
          "19:   bool (*rename)(const char *from, const char *to);        // Rename",
          "20:   bool (*remove)(const char *path);                        // Delete file",
          "21:   bool (*mkd)(const char *path);                           // Create directory",
          "",
          "[Added Lines]",
          "16:   int (*st)(const char *path, size_t *size, time_t *mtime);  // stat file",
          "17:   void (*ls)(const char *path, void (*fn)(const char *, void *), void *);",
          "18:   void *(*op)(const char *path, int flags);             // Open file",
          "19:   void (*cl)(void *fd);                                 // Close file",
          "20:   size_t (*rd)(void *fd, void *buf, size_t len);        // Read file",
          "21:   size_t (*wr)(void *fd, const void *buf, size_t len);  // Write file",
          "22:   size_t (*sk)(void *fd, size_t offset);                // Set file position",
          "23:   bool (*mv)(const char *from, const char *to);         // Rename file",
          "24:   bool (*rm)(const char *path);                         // Delete file",
          "25:   bool (*mkd)(const char *path);                        // Create directory",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:     size_t n, max = 2 * MG_IO_SIZE;",
          "386:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "387:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "390:     if (n > 0) c->send.len += n;",
          "391:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "392:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "388:     n = fd->fs->read(fd->fd, c->send.buf + c->send.len,",
          "389:                      c->send.size - c->send.len);",
          "",
          "[Added Lines]",
          "388:     n = fd->fs->rd(fd->fd, c->send.buf + c->send.len,",
          "389:                    c->send.size - c->send.len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "482:   time_t mtime = 0;",
          "483:   struct mg_str *inm = NULL;",
          "486:     LOG(LL_DEBUG, (\"404 [%s] %p\", path, (void *) fd));",
          "487:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "488:     mg_fs_close(fd);",
          "",
          "[Removed Lines]",
          "485:   if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {",
          "",
          "[Added Lines]",
          "485:   if (fd == NULL || fs->st(path, &size, &mtime) == 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "515:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "516:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "517:                  r1, r1 + cl - 1, (int64_t) size);",
          "519:       }",
          "520:     }",
          "",
          "[Removed Lines]",
          "518:         fs->seek(fd->fd, (size_t) r1);",
          "",
          "[Added Lines]",
          "518:         fs->sk(fd->fd, (size_t) r1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) < 0) {",
          "554:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "556:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "557:   } else {",
          "558:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "",
          "[Removed Lines]",
          "555:   } else if ((flags = fs->stat(path, &size, &t)) == 0) {",
          "",
          "[Added Lines]",
          "555:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "631:             (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,",
          "632:             uri.ptr);",
          "635:   mg_printf(c,",
          "636:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "637:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "",
          "[Removed Lines]",
          "634:   fs->list(dir, printdirentry, &d);",
          "",
          "[Added Lines]",
          "634:   fs->ls(dir, printdirentry, &d);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "671:   size_t n = (size_t) snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "672:   if (n > path_size) n = path_size;",
          "673:   path[path_size - 1] = '\\0';",
          "675:     mg_http_reply(c, 400, \"\", \"Invalid web root [%.*s]\\n\", (int) dir.len,",
          "676:                   dir.ptr);",
          "677:   } else {",
          "",
          "[Removed Lines]",
          "674:   if ((fs->stat(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "[Added Lines]",
          "674:   if ((fs->st(path, NULL, NULL) & MG_FS_DIR) == 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "684:     LOG(LL_VERBOSE_DEBUG,",
          "685:         (\"%lu %.*s -> %s\", c->id, (int) hm->uri.len, hm->uri.ptr, path));",
          "686:     while (n > 0 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "688:     if (flags == 0) {",
          "689:       mg_http_reply(c, 404, \"\", \"Not found\\n\");  // Does not exist, doh",
          "690:     } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&",
          "",
          "[Removed Lines]",
          "687:     flags = fs->stat(path, NULL, NULL);                 // Does it exist?",
          "",
          "[Added Lines]",
          "687:     flags = fs->st(path, NULL, NULL);                   // Does it exist?",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "698:       flags = 0;",
          "699:     } else if (flags & MG_FS_DIR) {",
          "700:       if (((snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "702:            (snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "704:         flags = tmp;",
          "705:       } else {",
          "706:         path[n] = '\\0';  // Remove appended index file name",
          "",
          "[Removed Lines]",
          "701:             (tmp = fs->stat(path, NULL, NULL)) != 0) ||",
          "703:             (tmp = fs->stat(path, NULL, NULL)) != 0))) {",
          "",
          "[Added Lines]",
          "701:             (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "703:             (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "900:     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);",
          "901:     remove_double_dots(path);",
          "902:     LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
          "904:     if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "905:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "906:       return -2;",
          "907:     } else {",
          "909:       mg_fs_close(fd);",
          "910:       mg_http_reply(c, 200, \"\", \"%d\", written);",
          "911:       return (int) hm->body.len;",
          "",
          "[Removed Lines]",
          "903:     if (oft == 0) fs->remove(path);",
          "908:       int written = (int) fs->write(fd->fd, hm->body.ptr, hm->body.len);",
          "",
          "[Added Lines]",
          "903:     if (oft == 0) fs->rm(path);",
          "908:       int written = (int) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "609:     char etag[100];",
          "610:     size_t size = 0;",
          "611:     time_t mtime = 0;",
          "613:     ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);",
          "614:     ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",",
          "615:                  etag) == 304);",
          "",
          "[Removed Lines]",
          "612:     ASSERT(mg_fs_posix.stat(\"./test/data/a.txt\", &size, &mtime) != 0);",
          "",
          "[Added Lines]",
          "612:     ASSERT(mg_fs_posix.st(\"./test/data/a.txt\", &size, &mtime) != 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c2176f969bfe4b50cf995d0e24c1979ef9a53f00",
      "candidate_info": {
        "commit_hash": "c2176f969bfe4b50cf995d0e24c1979ef9a53f00",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/c2176f969bfe4b50cf995d0e24c1979ef9a53f00",
        "files": [
          ".github/workflows/test.yml",
          "Makefile",
          "docs/README.md",
          "examples/complete/Makefile",
          "examples/complete/main.c",
          "examples/esp32/Makefile",
          "examples/esp32/main/CMakeLists.txt",
          "examples/esp8266/Makefile",
          "examples/http-restful-server/Makefile",
          "examples/http-server/Makefile",
          "examples/live-log/main.c",
          "examples/stm32-freertos-tcp/Makefile",
          "examples/timers/Makefile",
          "examples/websocket-server/Makefile",
          "mongoose.c",
          "mongoose.h",
          "src/arch_esp32.h",
          "src/arch_unix.h",
          "src/arch_win32.h",
          "src/config.h",
          "src/fs.h",
          "src/fs_packed.c",
          "src/fs_posix.c",
          "src/http.c",
          "src/ssi.c",
          "test/mongoose_custom.c",
          "test/mongoose_custom.h",
          "test/unit_test.c"
        ],
        "message": "Implement FS virtualization",
        "before_after_code_files": [
          "examples/complete/main.c||examples/complete/main.c",
          "examples/live-log/main.c||examples/live-log/main.c",
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/arch_esp32.h||src/arch_esp32.h",
          "src/arch_unix.h||src/arch_unix.h",
          "src/arch_win32.h||src/arch_win32.h",
          "src/config.h||src/config.h",
          "src/fs.h||src/fs.h",
          "src/fs_packed.c||src/fs_packed.c",
          "src/fs_posix.c||src/fs_posix.c",
          "src/http.c||src/http.c",
          "src/ssi.c||src/ssi.c",
          "test/mongoose_custom.c||test/mongoose_custom.c",
          "test/mongoose_custom.h||test/mongoose_custom.h",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/complete/main.c||examples/complete/main.c": [
          "File: examples/complete/main.c -> examples/complete/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:           \"Pragma: no-cache\\r\\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\\r\\n\"",
          "120:           \"Content-Type: multipart/x-mixed-replace; boundary=--foo\\r\\n\\r\\n\");",
          "121:     } else if (mg_http_match_uri(hm, \"/api/log/static\")) {",
          "123:     } else if (mg_http_match_uri(hm, \"/api/log/live\")) {",
          "124:       c->label[0] = 'L';  // Mark that connection as live log listener",
          "125:       mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");",
          "",
          "[Removed Lines]",
          "122:       mg_http_serve_file(c, hm, \"log.txt\", \"text/plain\", \"\");",
          "",
          "[Added Lines]",
          "122:       struct mg_http_serve_opts opts = {.root_dir = NULL};",
          "123:       mg_http_serve_file(c, hm, \"log.txt\", &opts);",
          "",
          "---------------"
        ],
        "examples/live-log/main.c||examples/live-log/main.c": [
          "File: examples/live-log/main.c -> examples/live-log/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:   if (ev == MG_EV_HTTP_MSG) {",
          "12:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "13:     if (mg_http_match_uri(hm, \"/api/log/static\")) {",
          "15:     } else if (mg_http_match_uri(hm, \"/api/log/live\")) {",
          "16:       c->label[0] = 'L';  // Mark that connection as live log listener",
          "17:       mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");",
          "",
          "[Removed Lines]",
          "14:       mg_http_serve_file(c, hm, \"log.txt\", \"text/plain\", \"\");",
          "",
          "[Added Lines]",
          "14:       struct mg_http_serve_opts opts = {.root_dir = NULL};",
          "15:       mg_http_serve_file(c, hm, \"log.txt\", &opts);",
          "",
          "---------------"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "424: }",
          "426: static char *packed_realpath(const char *path, char *resolved_path) {",
          "428:   strcpy(resolved_path, path);",
          "429:   return resolved_path;",
          "430: }",
          "433:   const char *data = mg_unpack(path, size);",
          "434:   if (mtime) *mtime = 0;",
          "436: }",
          "438: static void packed_list(const char *path, void (*fn)(const char *, void *),",
          "",
          "[Removed Lines]",
          "427:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "432: static int packed_stat(const char *path, size_t *size, unsigned *mtime) {",
          "435:   return data == NULL ? 0 : MG_FS_READ;",
          "",
          "[Added Lines]",
          "427:   if (resolved_path == NULL) resolved_path = (char *) malloc(strlen(path) + 1);",
          "432: static int packed_stat(const char *path, size_t *size, time_t *mtime) {",
          "435:   return data == NULL ? MG_FS_DIR : MG_FS_READ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "447:   struct mg_fd *fd = NULL;",
          "448:   if (data == NULL) return NULL;",
          "449:   if (flags & MG_FS_WRITE) return NULL;",
          "452:   fp->size = size;",
          "453:   fp->data = data;",
          "454:   fd->fd = fp;",
          "",
          "[Removed Lines]",
          "450:   fp = calloc(1, sizeof(*fp));",
          "451:   fd = calloc(1, sizeof(*fd));",
          "",
          "[Added Lines]",
          "450:   fp = (struct packed_file *) calloc(1, sizeof(*fp));",
          "451:   fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "489: #endif",
          "493: static char *posix_realpath(const char *path, char *resolved_path) {",
          "494: #ifdef _WIN32",
          "496: #else",
          "497:   return realpath(path, resolved_path);",
          "498: #endif",
          "499: }",
          "502: #ifdef _WIN32",
          "503:   struct _stati64 st;",
          "504:   wchar_t tmp[PATH_MAX];",
          "",
          "[Removed Lines]",
          "492: #if defined(O_READ)",
          "495:   return _fullpath(path, resolved_path, PATH_MAX);",
          "501: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "",
          "[Added Lines]",
          "492: #if defined(FOPEN_MAX)",
          "495:   return _fullpath(resolved_path, path, _MAX_PATH);",
          "496: #elif MG_ARCH == MG_ARCH_ESP32 || MG_ARCH == MG_ARCH_ESP8266 || \\",
          "497:     MG_ARCH == MG_ARCH_FREERTOS_TCP",
          "498:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "499:   strcpy(resolved_path, path);",
          "500:   return resolved_path;",
          "506: static int posix_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "509:   if (stat(path, &st) != 0) return 0;",
          "510: #endif",
          "511:   if (size) *size = (size_t) st.st_size;",
          "513:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "514: }",
          "516: static void posix_list(const char *dir, void (*fn)(const char *, void *),",
          "517:                        void *userdata) {",
          "519:   struct dirent *dp;",
          "520:   DIR *dirp;",
          "531:   }",
          "532: }",
          "534: static struct mg_fd *posix_open(const char *path, int flags) {",
          "",
          "[Removed Lines]",
          "512:   if (mtime) *mtime = (unsigned) st.st_mtime;",
          "523:   if ((dirp = (opendir(dir))) != NULL) {",
          "524:     size_t off, n;",
          "525:     while ((dp = readdir(dirp)) != NULL) {",
          "527:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "528:       fn(dp->d_name, &st);",
          "529:     }",
          "530:     closedir(dirp);",
          "",
          "[Added Lines]",
          "517:   if (mtime) *mtime = st.st_mtime;",
          "521: #ifdef _WIN32",
          "522: struct dirent {",
          "523:   char d_name[MAX_PATH];",
          "524: };",
          "526: typedef struct win32_dir {",
          "527:   HANDLE handle;",
          "528:   WIN32_FIND_DATAW info;",
          "529:   struct dirent result;",
          "530: } DIR;",
          "532: int gettimeofday(struct timeval *tv, void *tz) {",
          "533:   FILETIME ft;",
          "534:   unsigned __int64 tmpres = 0;",
          "536:   if (tv != NULL) {",
          "537:     GetSystemTimeAsFileTime(&ft);",
          "538:     tmpres |= ft.dwHighDateTime;",
          "539:     tmpres <<= 32;",
          "540:     tmpres |= ft.dwLowDateTime;",
          "541:     tmpres /= 10;  // convert into microseconds",
          "542:     tmpres -= (int64_t) 11644473600000000;",
          "543:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "544:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "545:   }",
          "546:   (void) tz;",
          "547:   return 0;",
          "548: }",
          "550: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "551:   int ret;",
          "552:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "553:   strncpy(buf, path, sizeof(buf));",
          "554:   buf[sizeof(buf) - 1] = '\\0';",
          "556:   p = buf + strlen(buf) - 1;",
          "557:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "558:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "559:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "562:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "563:                       NULL, NULL);",
          "564:   if (strcmp(buf, buf2) != 0) {",
          "565:     wbuf[0] = L'\\0';",
          "566:     ret = 0;",
          "567:   }",
          "568:   return ret;",
          "569: }",
          "571: DIR *opendir(const char *name) {",
          "572:   DIR *d = NULL;",
          "573:   wchar_t wpath[MAX_PATH];",
          "574:   DWORD attrs;",
          "576:   if (name == NULL) {",
          "577:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "578:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "579:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "580:   } else {",
          "581:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "582:     attrs = GetFileAttributesW(wpath);",
          "583:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "584:       (void) wcscat(wpath, L\"\\\\*\");",
          "585:       d->handle = FindFirstFileW(wpath, &d->info);",
          "586:       d->result.d_name[0] = '\\0';",
          "587:     } else {",
          "588:       free(d);",
          "589:       d = NULL;",
          "590:     }",
          "591:   }",
          "592:   return d;",
          "593: }",
          "595: int closedir(DIR *d) {",
          "596:   int result = 0;",
          "597:   if (d != NULL) {",
          "598:     if (d->handle != INVALID_HANDLE_VALUE)",
          "599:       result = FindClose(d->handle) ? 0 : -1;",
          "600:     free(d);",
          "601:   } else {",
          "602:     result = -1;",
          "603:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "604:   }",
          "605:   return result;",
          "606: }",
          "608: struct dirent *readdir(DIR *d) {",
          "609:   struct dirent *result = NULL;",
          "610:   if (d != NULL) {",
          "611:     memset(&d->result, 0, sizeof(d->result));",
          "612:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "613:       result = &d->result;",
          "614:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "615:                           sizeof(result->d_name), NULL, NULL);",
          "616:       if (!FindNextFileW(d->handle, &d->info)) {",
          "617:         FindClose(d->handle);",
          "618:         d->handle = INVALID_HANDLE_VALUE;",
          "619:       }",
          "620:     } else {",
          "621:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "622:     }",
          "623:   } else {",
          "624:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "625:   }",
          "626:   return result;",
          "627: }",
          "628: #endif",
          "632: #if MG_ENABLE_DIRLIST",
          "635:   if ((dirp = (opendir(dir))) == NULL) return;",
          "636:   while ((dp = readdir(dirp)) != NULL) {",
          "637:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "638:     fn(dp->d_name, userdata);",
          "640:   closedir(dirp);",
          "641: #else",
          "642:   (void) dir, (void) fn, (void) userdata;",
          "643: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "547:   fp = (void *) fopen(path, mode);",
          "548: #endif",
          "549:   if (fp == NULL) return NULL;",
          "551:   fd->fd = fp;",
          "552:   fd->fs = &mg_fs_posix;",
          "553:   return fd;",
          "554: }",
          "556: static void posix_close(struct mg_fd *fd) {",
          "558: }",
          "560: static size_t posix_read(void *fp, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "550:   fd = calloc(1, sizeof(*fd));",
          "557:   if (fd) fclose((FILE *) fd->fd), free(fd);",
          "",
          "[Added Lines]",
          "662:   fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "669:   if (fd != NULL) fclose((FILE *) fd->fd), free(fd);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "580:   return NULL;",
          "581: }",
          "584:   (void) path, (void) size, (void) mtime;",
          "585:   return 0;",
          "586: }",
          "",
          "[Removed Lines]",
          "583: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "",
          "[Added Lines]",
          "695: static int posix_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "991: static void http_cb(struct mg_connection *, int, void *, void *);",
          "992: static void restore_http_cb(struct mg_connection *c) {",
          "994:   c->pfn_data = NULL;",
          "995:   c->pfn = http_cb;",
          "996: }",
          "1001:   return buf;",
          "1002: }",
          "",
          "[Removed Lines]",
          "993:   if (c->pfn_data != NULL) fclose((FILE *) c->pfn_data);",
          "998: char *mg_http_etag(char *buf, size_t len, struct stat *st) {",
          "999:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) st->st_mtime,",
          "1000:            (int64_t) st->st_size);",
          "",
          "[Added Lines]",
          "1105:   struct mg_fd *fd = (struct mg_fd *) c->pfn_data;",
          "1106:   if (fd != NULL) fd->fs->close(fd);",
          "1111: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "1112:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,",
          "1113:            (int64_t) size);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1030: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "1031:                       void *fn_data) {",
          "1032:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "1035:     size_t n, max = 2 * MG_IO_SIZE;",
          "1036:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "1037:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "1039:     if (n > 0) c->send.len += n;",
          "1040:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "1041:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "1033:     FILE *fp = (FILE *) fn_data;",
          "1038:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, fp);",
          "",
          "[Added Lines]",
          "1146:     struct mg_fd *fd = (struct mg_fd *) fn_data;",
          "1151:     n = fd->fs->read(fd->fd, c->send.buf + c->send.len,",
          "1152:                      c->send.size - c->send.len);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1146: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "1147:                         const char *path, struct mg_http_serve_opts *opts) {",
          "1150:   char etag[64];",
          "1156:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "1160:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "1161:   } else {",
          "1162:     int n, status = 200;",
          "1163:     char range[100] = \"\";",
          "1165:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "[Removed Lines]",
          "1148:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "1149:   struct stat st;",
          "1151:   FILE *fp = fopen(path, \"rb\");",
          "1152:   if (fp == NULL || stat(path, &st) != 0 ||",
          "1153:       mg_http_etag(etag, sizeof(etag), &st) != etag) {",
          "1154:     LOG(LL_DEBUG, (\"404 [%.*s] [%s] %p\", (int) hm->uri.len, hm->uri.ptr, path,",
          "1155:                    (void *) fp));",
          "1157:     if (fp != NULL) fclose(fp);",
          "1158:   } else if (inm != NULL && mg_vcasecmp(inm, etag) == 0) {",
          "1159:     fclose(fp);",
          "1164:     int64_t r1 = 0, r2 = 0, cl = st.st_size;",
          "",
          "[Added Lines]",
          "1263:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "1264:   struct mg_fd *fd = fs->open(path, MG_FS_READ);",
          "1265:   size_t size = 0;",
          "1266:   time_t mtime = 0;",
          "1267:   struct mg_str *inm = NULL;",
          "1269:   if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {",
          "1270:     LOG(LL_DEBUG, (\"404 [%.*s] %p\", (int) hm->uri.len, hm->uri.ptr, fd));",
          "1272:     fs->close(fd);",
          "1274:   } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&",
          "1275:              (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&",
          "1276:              mg_vcasecmp(inm, etag) == 0) {",
          "1277:     fs->close(fd);",
          "1282:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1173:         status = 416;",
          "1174:         cl = 0;",
          "1175:         snprintf(range, sizeof(range),",
          "1178:       } else {",
          "1179:         status = 206;",
          "1180:         cl = r2 - r1 + 1;",
          "1181:         snprintf(range, sizeof(range),",
          "1182:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "1183:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "1192:       }",
          "1193:     }",
          "",
          "[Removed Lines]",
          "1176:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\",",
          "1177:                  (int64_t) st.st_size);",
          "1184:                  r1, r1 + cl - 1, (int64_t) st.st_size);",
          "1185: #if defined(_FILE_OFFSET_BITS) &&                             \\",
          "1186:     (_FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\",
          "1187:      _XOPEN_SOURCE >= 600)",
          "1188:         fseeko(fp, (off_t) r1, SEEK_SET);",
          "1189: #else",
          "1190:         fseek(fp, (long) r1, SEEK_SET);",
          "1191: #endif",
          "",
          "[Added Lines]",
          "1294:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);",
          "1301:                  r1, r1 + cl - 1, (int64_t) size);",
          "1302:         fs->seek(fd->fd, (size_t) r1);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1198:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "1199:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "1200:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "1202:     } else {",
          "1203:       c->pfn = static_cb;",
          "1205:     }",
          "1206:   }",
          "1207: }",
          "1238: };",
          "1353:   } else {",
          "1360:     } else {",
          "1362:     }",
          "1363:   }",
          "1370: }",
          "1372: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "1373:                     struct mg_http_serve_opts *opts, char *dir) {",
          "1377:   static const char *sort_js_code =",
          "1378:       \"<script>function srt(tb, sc, so, d) {\"",
          "1379:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "",
          "[Removed Lines]",
          "1201:       fclose(fp);",
          "1204:       c->pfn_data = fp;",
          "1209: #if MG_ARCH == MG_ARCH_ESP32 || MG_ARCH == MG_ARCH_ESP8266 || \\",
          "1210:     MG_ARCH == MG_ARCH_FREERTOS_TCP",
          "1211: char *realpath(const char *src, char *dst) {",
          "1212:   int len = strlen(src);",
          "1213:   if (len > MG_PATH_MAX - 1) len = MG_PATH_MAX - 1;",
          "1214:   strncpy(dst, src, len);",
          "1215:   dst[len] = '\\0';",
          "1216:   LOG(LL_DEBUG, (\"[%s] -> [%s]\", src, dst));",
          "1217:   return dst;",
          "1218: }",
          "1219: #endif",
          "1222: bool mg_is_dir(const char *path) WEAK;",
          "1223: bool mg_is_dir(const char *path) {",
          "1224: #if MG_ARCH == MG_ARCH_FREERTOS_TCP && defined(MG_ENABLE_FF)",
          "1225:   struct FF_STAT st;",
          "1226:   return (ff_stat(path, &st) == 0) && (st.st_mode & FF_IFDIR);",
          "1227: #else",
          "1228:   struct stat st;",
          "1229:   return stat(path, &st) == 0 && S_ISDIR(st.st_mode);",
          "1230: #endif",
          "1231: }",
          "1233: #if MG_ENABLE_DIRECTORY_LISTING",
          "1235: #ifdef _WIN32",
          "1236: struct dirent {",
          "1237:   char d_name[MAX_PATH];",
          "1240: typedef struct win32_dir {",
          "1241:   HANDLE handle;",
          "1242:   WIN32_FIND_DATAW info;",
          "1243:   struct dirent result;",
          "1244: } DIR;",
          "1246: int gettimeofday(struct timeval *tv, void *tz) {",
          "1247:   FILETIME ft;",
          "1248:   unsigned __int64 tmpres = 0;",
          "1250:   if (tv != NULL) {",
          "1251:     GetSystemTimeAsFileTime(&ft);",
          "1252:     tmpres |= ft.dwHighDateTime;",
          "1253:     tmpres <<= 32;",
          "1254:     tmpres |= ft.dwLowDateTime;",
          "1255:     tmpres /= 10;  // convert into microseconds",
          "1256:     tmpres -= (int64_t) 11644473600000000;",
          "1257:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "1258:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "1259:   }",
          "1260:   (void) tz;",
          "1261:   return 0;",
          "1262: }",
          "1264: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "1265:   int ret;",
          "1266:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "1267:   strncpy(buf, path, sizeof(buf));",
          "1268:   buf[sizeof(buf) - 1] = '\\0';",
          "1270:   p = buf + strlen(buf) - 1;",
          "1271:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "1272:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "1273:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "1276:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "1277:                       NULL, NULL);",
          "1278:   if (strcmp(buf, buf2) != 0) {",
          "1279:     wbuf[0] = L'\\0';",
          "1280:     ret = 0;",
          "1281:   }",
          "1282:   return ret;",
          "1283: }",
          "1285: DIR *opendir(const char *name) {",
          "1286:   DIR *d = NULL;",
          "1287:   wchar_t wpath[MAX_PATH];",
          "1288:   DWORD attrs;",
          "1290:   if (name == NULL) {",
          "1291:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1292:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "1293:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "1294:   } else {",
          "1295:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "1296:     attrs = GetFileAttributesW(wpath);",
          "1297:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "1298:       (void) wcscat(wpath, L\"\\\\*\");",
          "1299:       d->handle = FindFirstFileW(wpath, &d->info);",
          "1300:       d->result.d_name[0] = '\\0';",
          "1301:     } else {",
          "1302:       free(d);",
          "1303:       d = NULL;",
          "1304:     }",
          "1305:   }",
          "1306:   return d;",
          "1307: }",
          "1309: int closedir(DIR *d) {",
          "1310:   int result = 0;",
          "1311:   if (d != NULL) {",
          "1312:     if (d->handle != INVALID_HANDLE_VALUE)",
          "1313:       result = FindClose(d->handle) ? 0 : -1;",
          "1314:     free(d);",
          "1315:   } else {",
          "1316:     result = -1;",
          "1317:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1318:   }",
          "1319:   return result;",
          "1320: }",
          "1322: struct dirent *readdir(DIR *d) {",
          "1323:   struct dirent *result = NULL;",
          "1324:   if (d != NULL) {",
          "1325:     memset(&d->result, 0, sizeof(d->result));",
          "1326:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "1327:       result = &d->result;",
          "1328:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "1329:                           sizeof(result->d_name), NULL, NULL);",
          "1330:       if (!FindNextFileW(d->handle, &d->info)) {",
          "1331:         FindClose(d->handle);",
          "1332:         d->handle = INVALID_HANDLE_VALUE;",
          "1333:       }",
          "1334:     } else {",
          "1335:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "1336:     }",
          "1337:   } else {",
          "1338:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1339:   }",
          "1340:   return result;",
          "1341: }",
          "1342: #endif",
          "1344: static void printdirentry(struct mg_connection *c, const char *name,",
          "1345:                           struct stat *stp) {",
          "1346:   char size[64], mod[64], path[MG_PATH_MAX];",
          "1347:   int is_dir = S_ISDIR(stp->st_mode), n = 0;",
          "1348:   const char *slash = is_dir ? \"/\" : \"\";",
          "1349:   struct tm t;",
          "1351:   if (is_dir) {",
          "1352:     snprintf(size, sizeof(size), \"%s\", \"[DIR]\");",
          "1354:     if (stp->st_size < 1024) {",
          "1355:       snprintf(size, sizeof(size), \"%d\", (int) stp->st_size);",
          "1356:     } else if (stp->st_size < 0x100000) {",
          "1357:       snprintf(size, sizeof(size), \"%.1fk\", (double) stp->st_size / 1024.0);",
          "1358:     } else if (stp->st_size < 0x40000000) {",
          "1359:       snprintf(size, sizeof(size), \"%.1fM\", (double) stp->st_size / 1048576);",
          "1361:       snprintf(size, sizeof(size), \"%.1fG\", (double) stp->st_size / 1073741824);",
          "1364:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&stp->st_mtime, &t));",
          "1365:   n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "1366:   mg_printf(c,",
          "1367:             \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "1368:             \"<td>%s</td><td>%s</td></tr>\\n\",",
          "1369:             n, path, slash, name, slash, mod, size);",
          "1374:   char path[MG_PATH_MAX], *p = &dir[strlen(dir) - 1], tmp[10];",
          "1375:   struct dirent *dp;",
          "1376:   DIR *dirp;",
          "",
          "[Added Lines]",
          "1312:       fs->close(fd);",
          "1315:       c->pfn_data = fd;",
          "1320: struct printdirentrydata {",
          "1321:   struct mg_connection *c;",
          "1322:   struct mg_http_message *hm;",
          "1323:   struct mg_http_serve_opts *opts;",
          "1324:   const char *dir;",
          "1327: static void printdirentry(const char *name, void *userdata) {",
          "1328:   struct printdirentrydata *d = (struct printdirentrydata *) userdata;",
          "1329:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "1330:   size_t size = 0;",
          "1331:   time_t mtime = 0;",
          "1332:   char path[MG_PATH_MAX], sz[64], mod[64];",
          "1333:   int flags, n = 0;",
          "1335:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, MG_DIRSEP, name) < 0) {",
          "1336:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "1337:   } else if ((flags = fs->stat(path, &size, &mtime)) == 0) {",
          "1338:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "1340:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "1341:     struct tm t;",
          "1342:     if (flags & MG_FS_DIR) {",
          "1343:       snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "1344:     } else if (size < 1024) {",
          "1345:       snprintf(sz, sizeof(sz), \"%d\", (int) size);",
          "1346:     } else if (size < 0x100000) {",
          "1347:       snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);",
          "1348:     } else if (size < 0x40000000) {",
          "1349:       snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);",
          "1351:       snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);",
          "1353:     strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&mtime, &t));",
          "1354:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "1355:     mg_printf(d->c,",
          "1356:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "1357:               \"<td>%s</td><td>%s</td></tr>\\n\",",
          "1358:               n, path, slash, name, slash, mod, sz);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1397:       \"srt(tb, sc, so, true);\"",
          "1398:       \"}\"",
          "1399:       \"</script>\";",
          "1462:     LOG(LL_ERROR, (\"realpath(%s): %d\", opts->root_dir, errno));",
          "1463:     mg_http_reply(c, 400, \"\", \"Bad web root [%s]\\n\", opts->root_dir);",
          "1465:     mg_http_reply(c, 400, \"\", \"Invalid web root [%s]\\n\", root_dir);",
          "1466:   } else {",
          "1469:     size_t n1 = strlen(root_dir), n2;",
          "1472:     mg_url_decode(hm->uri.ptr, hm->uri.len, root_dir + n1, rlen - n1, 0);",
          "1473:     root_dir[rlen - 1] = '\\0';",
          "1474:     n2 = strlen(root_dir);",
          "1475:     while (n2 > 0 && root_dir[n2 - 1] == '/') root_dir[--n2] = 0;",
          "1481:     } else {",
          "1492:       } else {",
          "1495:       }",
          "1496:     }",
          "1497:   }",
          "1499: }",
          "1501: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "1502:                        struct mg_http_serve_opts *opts) {",
          "1524:     listdir(c, hm, opts, path);",
          "1529:   } else if (opts->ssi_pattern != NULL &&",
          "1530:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern), path,",
          "1531:                           strlen(path))) {",
          "1534:   } else {",
          "1535:     mg_http_serve_file(c, hm, path, opts);",
          "1536:   }",
          "",
          "[Removed Lines]",
          "1401:   while (p > dir && *p != '/') *p-- = '\\0';",
          "1402:   if ((dirp = (opendir(dir))) != NULL) {",
          "1403:     size_t off, n;",
          "1404:     mg_printf(c,",
          "1405:               \"HTTP/1.1 200 OK\\r\\n\"",
          "1406:               \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "1407:               \"%s\"",
          "1408:               \"Content-Length:         \\r\\n\\r\\n\",",
          "1409:               opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "1410:     off = c->send.len;  // Start of body",
          "1411:     mg_printf(c,",
          "1412:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "1413:               \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "1414:               \"font-family: monospace; }</style></head>\"",
          "1415:               \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "1416:               \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "1417:               \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "1418:               \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "1419:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "1420:               \"</thead>\"",
          "1421:               \"<tbody id=\\\"tb\\\">\\n\",",
          "1422:               (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "1423:               (int) hm->uri.len, hm->uri.ptr);",
          "1425:     while ((dp = readdir(dirp)) != NULL) {",
          "1426:       struct stat st;",
          "1427:       const char *sep = dp->d_name[0] == MG_DIRSEP ? \"/\" : \"\";",
          "1429:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "1431:       if (snprintf(path, sizeof(path), \"%s%s%s\", dir, sep, dp->d_name) < 0) {",
          "1432:         LOG(LL_ERROR, (\"%s truncated\", dp->d_name));",
          "1433:       } else if (stat(path, &st) != 0) {",
          "1434:         LOG(LL_ERROR, (\"%lu stat(%s): %d\", c->id, path, errno));",
          "1435:       } else {",
          "1436:         printdirentry(c, dp->d_name, &st);",
          "1437:       }",
          "1438:     }",
          "1439:     closedir(dirp);",
          "1440:     mg_printf(c,",
          "1441:               \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "1442:               \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "1443:               MG_VERSION);",
          "1444:     n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "1445:                           (unsigned long) (c->send.len - off));",
          "1446:     if (n > sizeof(tmp)) n = 0;",
          "1447:     memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "1448:   } else {",
          "1449:     mg_http_reply(c, 400, \"\", \"Cannot open dir\");",
          "1450:     LOG(LL_ERROR, (\"%lu opendir(%s) -> %d\", c->id, dir, errno));",
          "1451:   }",
          "1452: }",
          "1453: #endif",
          "1455: static bool uri_to_local_path(struct mg_connection *c,",
          "1456:                               struct mg_http_message *hm,",
          "1457:                               struct mg_http_serve_opts *opts, char *root_dir,",
          "1458:                               size_t rlen, char *path, size_t path_len,",
          "1459:                               bool *is_index) {",
          "1460:   bool success = false;",
          "1461:   if (realpath(opts->root_dir, root_dir) == NULL) {",
          "1464:   } else if (!mg_is_dir(root_dir)) {",
          "1477:     if (realpath(root_dir, path) == NULL) {",
          "1478:       LOG(LL_ERROR, (\"realpath(%s): %d\", root_dir, errno));",
          "1479:       mg_http_reply(c, 404, \"\", \"Not found [%.*s]\\n\", (int) hm->uri.len,",
          "1480:                     hm->uri.ptr);",
          "1482:       if (mg_is_dir(path)) {",
          "1483:         strncat(path, \"/index.html\", path_len - strlen(path) - 1);",
          "1484:         path[path_len - 1] = '\\0';",
          "1486:       }",
          "1488:       if (strlen(path) < n1 || memcmp(root_dir, path, n1) != 0) {",
          "1490:         mg_http_reply(c, 404, \"\", \"Invalid URI [%.*s]\\n\", (int) hm->uri.len,",
          "1491:                       hm->uri.ptr);",
          "1493:         root_dir[n1] = '\\0';",
          "1494:         success = true;",
          "1498:   return success;",
          "1503:   char root_dir[MG_PATH_MAX], path[sizeof(root_dir)];",
          "1504:   bool is_index = false, exists;",
          "1505:   struct stat st;",
          "1506:   root_dir[0] = path[0] = '\\0';",
          "1508:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), path,",
          "1509:                          sizeof(path), &is_index))",
          "1510:     return;",
          "1512:   exists = stat(path, &st) == 0;",
          "1513: #if MG_ENABLE_SSI",
          "1514:   if (is_index && !exists) {",
          "1515:     char *p = path + strlen(path);",
          "1516:     while (p > path && p[-1] != '/') p--;",
          "1517:     strncpy(p, \"index.shtml\", (size_t)(&path[sizeof(path)] - p - 2));",
          "1518:     path[sizeof(path) - 1] = '\\0';",
          "1519:     exists = stat(path, &st) == 0;",
          "1520:   }",
          "1521: #endif",
          "1522:   if (is_index && !exists) {",
          "1523: #if MG_ENABLE_DIRECTORY_LISTING",
          "1525: #else",
          "1526:     mg_http_reply(c, 403, \"\", \"%s\", \"Directory listing not supported\");",
          "1527: #endif",
          "1528: #if MG_ENABLE_SSI",
          "1532:     mg_http_serve_ssi(c, root_dir, path);",
          "1533: #endif",
          "",
          "[Added Lines]",
          "1387:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "1388:   struct printdirentrydata d = {c, hm, opts, dir};",
          "1389:   char tmp[10];",
          "1390:   size_t off, n;",
          "1392:   mg_printf(c,",
          "1393:             \"HTTP/1.1 200 OK\\r\\n\"",
          "1394:             \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "1395:             \"%s\"",
          "1396:             \"Content-Length:         \\r\\n\\r\\n\",",
          "1397:             opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "1398:   off = c->send.len;  // Start of body",
          "1399:   mg_printf(c,",
          "1400:             \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "1401:             \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "1402:             \"font-family: monospace; }</style></head>\"",
          "1403:             \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "1404:             \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "1405:             \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "1406:             \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "1407:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "1408:             \"</thead>\"",
          "1409:             \"<tbody id=\\\"tb\\\">\\n\",",
          "1410:             (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "1411:             (int) hm->uri.len, hm->uri.ptr);",
          "1413:   fs->list(dir, printdirentry, &d);",
          "1414:   mg_printf(c,",
          "1415:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "1416:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "1417:             MG_VERSION);",
          "1418:   n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "1419:                         (unsigned long) (c->send.len - off));",
          "1420:   if (n > sizeof(tmp)) n = 0;",
          "1421:   memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "1422: }",
          "1424: static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,",
          "1425:                        struct mg_http_serve_opts *opts, char *root_dir,",
          "1426:                        size_t rlen, char *path, size_t plen) {",
          "1427:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "1428:   int flags = 0, tmp;",
          "1429:   if (fs->realpath(opts->root_dir, root_dir) == NULL) {",
          "1432:   } else if (!(fs->stat(root_dir, NULL, NULL) & MG_FS_DIR)) {",
          "1444:     if (fs->realpath(root_dir, path) == NULL ||",
          "1445:         (flags = fs->stat(path, NULL, NULL)) == 0) {",
          "1446:       mg_http_reply(c, 404, \"\", \"Not found\\n\");",
          "1450:       root_dir[n1] = '\\0';  // Restore root_dir - remove appended URI",
          "1451:       n2 = strlen(path);    // Memorise path length",
          "1452:       if ((flags & MG_FS_DIR) &&",
          "1453:           ((snprintf(path + n2, plen - n2, \"/index.html\") > 0 &&",
          "1454:             (tmp = fs->stat(path, NULL, NULL)) != 0) ||",
          "1455:            (snprintf(path + n2, plen - n2, \"/index.shtml\") > 0 &&",
          "1456:             (tmp = fs->stat(path, NULL, NULL)) != 0))) {",
          "1457:         flags = tmp;",
          "1459:         path[n2] = '\\0';  // Remove appended index file name",
          "1463:     if (strlen(path) < n1 || memcmp(root_dir, path, n1) != 0) {",
          "1464:       mg_http_reply(c, 404, \"\", \"Invalid URI [%.*s]\\n\", (int) hm->uri.len,",
          "1465:                     hm->uri.ptr);",
          "1466:       flags = 0;",
          "1467:     }",
          "1469:   return flags;",
          "1474:   char root[MG_PATH_MAX] = \"\", path[sizeof(root)] = \"\";",
          "1475:   int flags = uri_to_path(c, hm, opts, root, sizeof(root), path, sizeof(path));",
          "1477:   if (flags == 0) return;",
          "1478:   LOG(LL_DEBUG, (\"root [%s], path [%s] %d\", root, path, flags));",
          "1479:   if (flags & MG_FS_DIR) {",
          "1484:     mg_http_serve_ssi(c, root, path);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3516:   mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);",
          "3517:   free(data);",
          "3518: }",
          "3519: #endif",
          "3521: #ifdef MG_ENABLE_LINES",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3470: #else",
          "3471: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "3472:                        const char *fullpath) {",
          "3473:   mg_http_reply(c, 501, NULL, \"SSI not enabled\");",
          "3474:   (void) root, (void) fullpath;",
          "3475: }",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: #endif",
          "40: #ifndef MG_ENABLE_SSI",
          "42: #endif",
          "44: #ifndef MG_ENABLE_IPV6",
          "",
          "[Removed Lines]",
          "41: #define MG_ENABLE_SSI 0",
          "",
          "[Added Lines]",
          "41: #define MG_ENABLE_SSI 1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58: #define MG_ENABLE_WINSOCK 1",
          "59: #endif",
          "63: #endif",
          "65: #ifndef MG_ENABLE_SOCKETPAIR",
          "",
          "[Removed Lines]",
          "61: #ifndef MG_ENABLE_DIRECTORY_LISTING",
          "62: #define MG_ENABLE_DIRECTORY_LISTING 0",
          "",
          "[Added Lines]",
          "61: #ifndef MG_ENABLE_DIRLIST",
          "62: #define MG_ENABLE_DIRLIST 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70: #ifndef MG_IO_SIZE",
          "72: #endif",
          "",
          "[Removed Lines]",
          "71: #define MG_IO_SIZE 512",
          "",
          "[Added Lines]",
          "71: #define MG_IO_SIZE 2048",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "153: #ifndef MG_PATH_MAX",
          "154: #define MG_PATH_MAX 128",
          "155: #endif",
          "157: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "156: #undef MG_ENABLE_DIRLIST",
          "157: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "345: #define MG_DIRSEP '/'",
          "346: #define MG_INT64_FMT \"%\" PRId64",
          "348: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "349: #undef MG_ENABLE_DIRLIST",
          "350: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "414: #ifndef EWOULDBLOCK",
          "415: #define EWOULDBLOCK WSAEWOULDBLOCK",
          "416: #endif",
          "429: #ifndef va_copy",
          "430: #ifdef __va_copy",
          "",
          "[Removed Lines]",
          "417: #define realpath(a, b) _fullpath((b), (a), MG_PATH_MAX)",
          "418: #define fopen(a, b) mg_fopen((a), (b))",
          "421: #ifdef _stati64",
          "422: #define stat _stat64",
          "423: #define _stat64(a, b) mg_stat((a), (b))",
          "424: #else",
          "425: #define stat _stati64",
          "426: #define _stati64(a, b) mg_stat((a), (b))",
          "427: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "440: #define MG_INT64_FMT \"%I64d\"",
          "456: static __inline struct tm *gmtime_r(time_t *t, struct tm *tm) {",
          "",
          "[Removed Lines]",
          "442: static __inline FILE *mg_fopen(const char *path, const char *mode) {",
          "443:   wchar_t b1[MAX_PATH], b2[10];",
          "444:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "445:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "446:   return _wfopen(b1, b2);",
          "447: }",
          "449: static __inline int mg_stat(const char *path, struct stat *st) {",
          "450:   wchar_t tmp[MAX_PATH];",
          "451:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "452:   return _wstati64(tmp, st);",
          "453: }",
          "",
          "[Added Lines]",
          "435: #undef MG_ENABLE_DIRLIST",
          "436: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "612: struct mg_fs {",
          "613:   char *(*realpath)(const char *path, char *resolved_path);",
          "615:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "616:   struct mg_fd *(*open)(const char *path, int flags);",
          "617:   void (*close)(struct mg_fd *fd);",
          "",
          "[Removed Lines]",
          "614:   int (*stat)(const char *path, size_t *size, unsigned *mtime);",
          "",
          "[Added Lines]",
          "597:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "",
          "---------------"
        ],
        "src/arch_esp32.h||src/arch_esp32.h": [
          "File: src/arch_esp32.h -> src/arch_esp32.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifndef MG_PATH_MAX",
          "23: #define MG_PATH_MAX 128",
          "24: #endif",
          "26: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #undef MG_ENABLE_DIRLIST",
          "26: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------"
        ],
        "src/arch_unix.h||src/arch_unix.h": [
          "File: src/arch_unix.h -> src/arch_unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #define MG_DIRSEP '/'",
          "34: #define MG_INT64_FMT \"%\" PRId64",
          "36: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #undef MG_ENABLE_DIRLIST",
          "36: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------"
        ],
        "src/arch_win32.h||src/arch_win32.h": [
          "File: src/arch_win32.h -> src/arch_win32.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: #ifndef EWOULDBLOCK",
          "67: #define EWOULDBLOCK WSAEWOULDBLOCK",
          "68: #endif",
          "81: #ifndef va_copy",
          "82: #ifdef __va_copy",
          "",
          "[Removed Lines]",
          "69: #define realpath(a, b) _fullpath((b), (a), MG_PATH_MAX)",
          "70: #define fopen(a, b) mg_fopen((a), (b))",
          "73: #ifdef _stati64",
          "74: #define stat _stat64",
          "75: #define _stat64(a, b) mg_stat((a), (b))",
          "76: #else",
          "77: #define stat _stati64",
          "78: #define _stati64(a, b) mg_stat((a), (b))",
          "79: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92: #define MG_INT64_FMT \"%I64d\"",
          "108: static __inline struct tm *gmtime_r(time_t *t, struct tm *tm) {",
          "",
          "[Removed Lines]",
          "94: static __inline FILE *mg_fopen(const char *path, const char *mode) {",
          "95:   wchar_t b1[MAX_PATH], b2[10];",
          "96:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "97:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "98:   return _wfopen(b1, b2);",
          "99: }",
          "101: static __inline int mg_stat(const char *path, struct stat *st) {",
          "102:   wchar_t tmp[MAX_PATH];",
          "103:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "104:   return _wstati64(tmp, st);",
          "105: }",
          "",
          "[Added Lines]",
          "83: #undef MG_ENABLE_DIRLIST",
          "84: #define MG_ENABLE_DIRLIST 1",
          "",
          "---------------"
        ],
        "src/config.h||src/config.h": [
          "File: src/config.h -> src/config.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #endif",
          "15: #ifndef MG_ENABLE_SSI",
          "17: #endif",
          "19: #ifndef MG_ENABLE_IPV6",
          "",
          "[Removed Lines]",
          "16: #define MG_ENABLE_SSI 0",
          "",
          "[Added Lines]",
          "16: #define MG_ENABLE_SSI 1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: #define MG_ENABLE_WINSOCK 1",
          "34: #endif",
          "38: #endif",
          "40: #ifndef MG_ENABLE_SOCKETPAIR",
          "",
          "[Removed Lines]",
          "36: #ifndef MG_ENABLE_DIRECTORY_LISTING",
          "37: #define MG_ENABLE_DIRECTORY_LISTING 0",
          "",
          "[Added Lines]",
          "36: #ifndef MG_ENABLE_DIRLIST",
          "37: #define MG_ENABLE_DIRLIST 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45: #ifndef MG_IO_SIZE",
          "47: #endif",
          "",
          "[Removed Lines]",
          "46: #define MG_IO_SIZE 512",
          "",
          "[Added Lines]",
          "46: #define MG_IO_SIZE 2048",
          "",
          "---------------"
        ],
        "src/fs.h||src/fs.h": [
          "File: src/fs.h -> src/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: struct mg_fs {",
          "9:   char *(*realpath)(const char *path, char *resolved_path);",
          "11:   void (*list)(const char *path, void (*fn)(const char *, void *), void *);",
          "12:   struct mg_fd *(*open)(const char *path, int flags);",
          "13:   void (*close)(struct mg_fd *fd);",
          "",
          "[Removed Lines]",
          "10:   int (*stat)(const char *path, size_t *size, unsigned *mtime);",
          "",
          "[Added Lines]",
          "10:   int (*stat)(const char *path, size_t *size, time_t *mtime);",
          "",
          "---------------"
        ],
        "src/fs_packed.c||src/fs_packed.c": [
          "File: src/fs_packed.c -> src/fs_packed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: }",
          "15: static char *packed_realpath(const char *path, char *resolved_path) {",
          "17:   strcpy(resolved_path, path);",
          "18:   return resolved_path;",
          "19: }",
          "22:   const char *data = mg_unpack(path, size);",
          "23:   if (mtime) *mtime = 0;",
          "25: }",
          "27: static void packed_list(const char *path, void (*fn)(const char *, void *),",
          "",
          "[Removed Lines]",
          "16:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "21: static int packed_stat(const char *path, size_t *size, unsigned *mtime) {",
          "24:   return data == NULL ? 0 : MG_FS_READ;",
          "",
          "[Added Lines]",
          "16:   if (resolved_path == NULL) resolved_path = (char *) malloc(strlen(path) + 1);",
          "21: static int packed_stat(const char *path, size_t *size, time_t *mtime) {",
          "24:   return data == NULL ? MG_FS_DIR : MG_FS_READ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:   struct mg_fd *fd = NULL;",
          "37:   if (data == NULL) return NULL;",
          "38:   if (flags & MG_FS_WRITE) return NULL;",
          "41:   fp->size = size;",
          "42:   fp->data = data;",
          "43:   fd->fd = fp;",
          "",
          "[Removed Lines]",
          "39:   fp = calloc(1, sizeof(*fp));",
          "40:   fd = calloc(1, sizeof(*fd));",
          "",
          "[Added Lines]",
          "39:   fp = (struct packed_file *) calloc(1, sizeof(*fp));",
          "40:   fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "",
          "---------------"
        ],
        "src/fs_posix.c||src/fs_posix.c": [
          "File: src/fs_posix.c -> src/fs_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"fs.h\"",
          "4: static char *posix_realpath(const char *path, char *resolved_path) {",
          "5: #ifdef _WIN32",
          "7: #else",
          "8:   return realpath(path, resolved_path);",
          "9: #endif",
          "10: }",
          "13: #ifdef _WIN32",
          "14:   struct _stati64 st;",
          "15:   wchar_t tmp[PATH_MAX];",
          "",
          "[Removed Lines]",
          "3: #if defined(O_READ)",
          "6:   return _fullpath(path, resolved_path, PATH_MAX);",
          "12: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "",
          "[Added Lines]",
          "3: #if defined(FOPEN_MAX)",
          "6:   return _fullpath(resolved_path, path, _MAX_PATH);",
          "7: #elif MG_ARCH == MG_ARCH_ESP32 || MG_ARCH == MG_ARCH_ESP8266 || \\",
          "8:     MG_ARCH == MG_ARCH_FREERTOS_TCP",
          "9:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "10:   strcpy(resolved_path, path);",
          "11:   return resolved_path;",
          "17: static int posix_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:   if (stat(path, &st) != 0) return 0;",
          "21: #endif",
          "22:   if (size) *size = (size_t) st.st_size;",
          "24:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "25: }",
          "27: static void posix_list(const char *dir, void (*fn)(const char *, void *),",
          "28:                        void *userdata) {",
          "30:   struct dirent *dp;",
          "31:   DIR *dirp;",
          "42:   }",
          "43: }",
          "45: static struct mg_fd *posix_open(const char *path, int flags) {",
          "",
          "[Removed Lines]",
          "23:   if (mtime) *mtime = (unsigned) st.st_mtime;",
          "34:   if ((dirp = (opendir(dir))) != NULL) {",
          "35:     size_t off, n;",
          "36:     while ((dp = readdir(dirp)) != NULL) {",
          "38:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "39:       fn(dp->d_name, &st);",
          "40:     }",
          "41:     closedir(dirp);",
          "",
          "[Added Lines]",
          "28:   if (mtime) *mtime = st.st_mtime;",
          "32: #ifdef _WIN32",
          "33: struct dirent {",
          "34:   char d_name[MAX_PATH];",
          "35: };",
          "37: typedef struct win32_dir {",
          "38:   HANDLE handle;",
          "39:   WIN32_FIND_DATAW info;",
          "40:   struct dirent result;",
          "41: } DIR;",
          "43: int gettimeofday(struct timeval *tv, void *tz) {",
          "44:   FILETIME ft;",
          "45:   unsigned __int64 tmpres = 0;",
          "47:   if (tv != NULL) {",
          "48:     GetSystemTimeAsFileTime(&ft);",
          "49:     tmpres |= ft.dwHighDateTime;",
          "50:     tmpres <<= 32;",
          "51:     tmpres |= ft.dwLowDateTime;",
          "52:     tmpres /= 10;  // convert into microseconds",
          "53:     tmpres -= (int64_t) 11644473600000000;",
          "54:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "55:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "56:   }",
          "57:   (void) tz;",
          "58:   return 0;",
          "59: }",
          "61: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "62:   int ret;",
          "63:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "64:   strncpy(buf, path, sizeof(buf));",
          "65:   buf[sizeof(buf) - 1] = '\\0';",
          "67:   p = buf + strlen(buf) - 1;",
          "68:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "69:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "70:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "73:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "74:                       NULL, NULL);",
          "75:   if (strcmp(buf, buf2) != 0) {",
          "76:     wbuf[0] = L'\\0';",
          "77:     ret = 0;",
          "78:   }",
          "79:   return ret;",
          "80: }",
          "82: DIR *opendir(const char *name) {",
          "83:   DIR *d = NULL;",
          "84:   wchar_t wpath[MAX_PATH];",
          "85:   DWORD attrs;",
          "87:   if (name == NULL) {",
          "88:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "89:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "90:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "91:   } else {",
          "92:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "93:     attrs = GetFileAttributesW(wpath);",
          "94:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "95:       (void) wcscat(wpath, L\"\\\\*\");",
          "96:       d->handle = FindFirstFileW(wpath, &d->info);",
          "97:       d->result.d_name[0] = '\\0';",
          "98:     } else {",
          "99:       free(d);",
          "100:       d = NULL;",
          "101:     }",
          "102:   }",
          "103:   return d;",
          "104: }",
          "106: int closedir(DIR *d) {",
          "107:   int result = 0;",
          "108:   if (d != NULL) {",
          "109:     if (d->handle != INVALID_HANDLE_VALUE)",
          "110:       result = FindClose(d->handle) ? 0 : -1;",
          "111:     free(d);",
          "112:   } else {",
          "113:     result = -1;",
          "114:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "115:   }",
          "116:   return result;",
          "117: }",
          "119: struct dirent *readdir(DIR *d) {",
          "120:   struct dirent *result = NULL;",
          "121:   if (d != NULL) {",
          "122:     memset(&d->result, 0, sizeof(d->result));",
          "123:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "124:       result = &d->result;",
          "125:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "126:                           sizeof(result->d_name), NULL, NULL);",
          "127:       if (!FindNextFileW(d->handle, &d->info)) {",
          "128:         FindClose(d->handle);",
          "129:         d->handle = INVALID_HANDLE_VALUE;",
          "130:       }",
          "131:     } else {",
          "132:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "133:     }",
          "134:   } else {",
          "135:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "136:   }",
          "137:   return result;",
          "138: }",
          "139: #endif",
          "143: #if MG_ENABLE_DIRLIST",
          "146:   if ((dirp = (opendir(dir))) == NULL) return;",
          "147:   while ((dp = readdir(dirp)) != NULL) {",
          "148:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "149:     fn(dp->d_name, userdata);",
          "151:   closedir(dirp);",
          "152: #else",
          "153:   (void) dir, (void) fn, (void) userdata;",
          "154: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58:   fp = (void *) fopen(path, mode);",
          "59: #endif",
          "60:   if (fp == NULL) return NULL;",
          "62:   fd->fd = fp;",
          "63:   fd->fs = &mg_fs_posix;",
          "64:   return fd;",
          "65: }",
          "67: static void posix_close(struct mg_fd *fd) {",
          "69: }",
          "71: static size_t posix_read(void *fp, void *buf, size_t len) {",
          "",
          "[Removed Lines]",
          "61:   fd = calloc(1, sizeof(*fd));",
          "68:   if (fd) fclose((FILE *) fd->fd), free(fd);",
          "",
          "[Added Lines]",
          "173:   fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "180:   if (fd != NULL) fclose((FILE *) fd->fd), free(fd);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91:   return NULL;",
          "92: }",
          "95:   (void) path, (void) size, (void) mtime;",
          "96:   return 0;",
          "97: }",
          "",
          "[Removed Lines]",
          "94: static int posix_stat(const char *path, size_t *size, unsigned *mtime) {",
          "",
          "[Added Lines]",
          "206: static int posix_stat(const char *path, size_t *size, time_t *mtime) {",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "367: static void http_cb(struct mg_connection *, int, void *, void *);",
          "368: static void restore_http_cb(struct mg_connection *c) {",
          "370:   c->pfn_data = NULL;",
          "371:   c->pfn = http_cb;",
          "372: }",
          "377:   return buf;",
          "378: }",
          "",
          "[Removed Lines]",
          "369:   if (c->pfn_data != NULL) fclose((FILE *) c->pfn_data);",
          "374: char *mg_http_etag(char *buf, size_t len, struct stat *st) {",
          "375:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) st->st_mtime,",
          "376:            (int64_t) st->st_size);",
          "",
          "[Added Lines]",
          "369:   struct mg_fd *fd = (struct mg_fd *) c->pfn_data;",
          "370:   if (fd != NULL) fd->fs->close(fd);",
          "375: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "376:   snprintf(buf, len, \"\\\"%lx.\" MG_INT64_FMT \"\\\"\", (unsigned long) mtime,",
          "377:            (int64_t) size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "406: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "407:                       void *fn_data) {",
          "408:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "411:     size_t n, max = 2 * MG_IO_SIZE;",
          "412:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "413:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "415:     if (n > 0) c->send.len += n;",
          "416:     if (c->send.len < c->send.size) restore_http_cb(c);",
          "417:   } else if (ev == MG_EV_CLOSE) {",
          "",
          "[Removed Lines]",
          "409:     FILE *fp = (FILE *) fn_data;",
          "414:     n = fread(c->send.buf + c->send.len, 1, c->send.size - c->send.len, fp);",
          "",
          "[Added Lines]",
          "410:     struct mg_fd *fd = (struct mg_fd *) fn_data;",
          "415:     n = fd->fs->read(fd->fd, c->send.buf + c->send.len,",
          "416:                      c->send.size - c->send.len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "522: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "523:                         const char *path, struct mg_http_serve_opts *opts) {",
          "526:   char etag[64];",
          "532:     mg_http_reply(c, 404, \"\", \"%s\", \"Not found\\n\");",
          "536:     mg_printf(c, \"HTTP/1.1 304 Not Modified\\r\\nContent-Length: 0\\r\\n\\r\\n\");",
          "537:   } else {",
          "538:     int n, status = 200;",
          "539:     char range[100] = \"\";",
          "541:     struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "",
          "[Removed Lines]",
          "524:   struct mg_str *inm = mg_http_get_header(hm, \"If-None-Match\");",
          "525:   struct stat st;",
          "527:   FILE *fp = fopen(path, \"rb\");",
          "528:   if (fp == NULL || stat(path, &st) != 0 ||",
          "529:       mg_http_etag(etag, sizeof(etag), &st) != etag) {",
          "530:     LOG(LL_DEBUG, (\"404 [%.*s] [%s] %p\", (int) hm->uri.len, hm->uri.ptr, path,",
          "531:                    (void *) fp));",
          "533:     if (fp != NULL) fclose(fp);",
          "534:   } else if (inm != NULL && mg_vcasecmp(inm, etag) == 0) {",
          "535:     fclose(fp);",
          "540:     int64_t r1 = 0, r2 = 0, cl = st.st_size;",
          "",
          "[Added Lines]",
          "527:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "528:   struct mg_fd *fd = fs->open(path, MG_FS_READ);",
          "529:   size_t size = 0;",
          "530:   time_t mtime = 0;",
          "531:   struct mg_str *inm = NULL;",
          "533:   if (fd == NULL || fs->stat(path, &size, &mtime) == 0) {",
          "534:     LOG(LL_DEBUG, (\"404 [%.*s] %p\", (int) hm->uri.len, hm->uri.ptr, fd));",
          "536:     fs->close(fd);",
          "538:   } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&",
          "539:              (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&",
          "540:              mg_vcasecmp(inm, etag) == 0) {",
          "541:     fs->close(fd);",
          "546:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "549:         status = 416;",
          "550:         cl = 0;",
          "551:         snprintf(range, sizeof(range),",
          "554:       } else {",
          "555:         status = 206;",
          "556:         cl = r2 - r1 + 1;",
          "557:         snprintf(range, sizeof(range),",
          "558:                  \"Content-Range: bytes \" MG_INT64_FMT \"-\" MG_INT64_FMT",
          "559:                  \"/\" MG_INT64_FMT \"\\r\\n\",",
          "568:       }",
          "569:     }",
          "",
          "[Removed Lines]",
          "552:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\",",
          "553:                  (int64_t) st.st_size);",
          "560:                  r1, r1 + cl - 1, (int64_t) st.st_size);",
          "561: #if defined(_FILE_OFFSET_BITS) &&                             \\",
          "562:     (_FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\",
          "563:      _XOPEN_SOURCE >= 600)",
          "564:         fseeko(fp, (off_t) r1, SEEK_SET);",
          "565: #else",
          "566:         fseek(fp, (long) r1, SEEK_SET);",
          "567: #endif",
          "",
          "[Added Lines]",
          "558:                  \"Content-Range: bytes */\" MG_INT64_FMT \"\\r\\n\", (int64_t) size);",
          "565:                  r1, r1 + cl - 1, (int64_t) size);",
          "566:         fs->seek(fd->fd, (size_t) r1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "574:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "575:               etag, cl, range, opts->extra_headers ? opts->extra_headers : \"\");",
          "576:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "578:     } else {",
          "579:       c->pfn = static_cb;",
          "581:     }",
          "582:   }",
          "583: }",
          "614: };",
          "670:   } else {",
          "677:     } else {",
          "680:     }",
          "681:   }",
          "746: }",
          "748: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "749:                     struct mg_http_serve_opts *opts, char *dir) {",
          "753:   static const char *sort_js_code =",
          "754:       \"<script>function srt(tb, sc, so, d) {\"",
          "755:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "",
          "[Removed Lines]",
          "577:       fclose(fp);",
          "580:       c->pfn_data = fp;",
          "585: #if MG_ARCH == MG_ARCH_ESP32 || MG_ARCH == MG_ARCH_ESP8266 || \\",
          "586:     MG_ARCH == MG_ARCH_FREERTOS_TCP",
          "587: char *realpath(const char *src, char *dst) {",
          "588:   int len = strlen(src);",
          "589:   if (len > MG_PATH_MAX - 1) len = MG_PATH_MAX - 1;",
          "590:   strncpy(dst, src, len);",
          "591:   dst[len] = '\\0';",
          "592:   LOG(LL_DEBUG, (\"[%s] -> [%s]\", src, dst));",
          "593:   return dst;",
          "594: }",
          "595: #endif",
          "598: bool mg_is_dir(const char *path) WEAK;",
          "599: bool mg_is_dir(const char *path) {",
          "600: #if MG_ARCH == MG_ARCH_FREERTOS_TCP && defined(MG_ENABLE_FF)",
          "601:   struct FF_STAT st;",
          "602:   return (ff_stat(path, &st) == 0) && (st.st_mode & FF_IFDIR);",
          "603: #else",
          "604:   struct stat st;",
          "605:   return stat(path, &st) == 0 && S_ISDIR(st.st_mode);",
          "606: #endif",
          "607: }",
          "609: #if MG_ENABLE_DIRECTORY_LISTING",
          "611: #ifdef _WIN32",
          "612: struct dirent {",
          "613:   char d_name[MAX_PATH];",
          "616: typedef struct win32_dir {",
          "617:   HANDLE handle;",
          "618:   WIN32_FIND_DATAW info;",
          "619:   struct dirent result;",
          "620: } DIR;",
          "622: int gettimeofday(struct timeval *tv, void *tz) {",
          "623:   FILETIME ft;",
          "624:   unsigned __int64 tmpres = 0;",
          "626:   if (tv != NULL) {",
          "627:     GetSystemTimeAsFileTime(&ft);",
          "628:     tmpres |= ft.dwHighDateTime;",
          "629:     tmpres <<= 32;",
          "630:     tmpres |= ft.dwLowDateTime;",
          "631:     tmpres /= 10;  // convert into microseconds",
          "632:     tmpres -= (int64_t) 11644473600000000;",
          "633:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "634:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "635:   }",
          "636:   (void) tz;",
          "637:   return 0;",
          "638: }",
          "640: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "641:   int ret;",
          "642:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "643:   strncpy(buf, path, sizeof(buf));",
          "644:   buf[sizeof(buf) - 1] = '\\0';",
          "646:   p = buf + strlen(buf) - 1;",
          "647:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "648:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "649:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "652:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "653:                       NULL, NULL);",
          "654:   if (strcmp(buf, buf2) != 0) {",
          "655:     wbuf[0] = L'\\0';",
          "656:     ret = 0;",
          "657:   }",
          "658:   return ret;",
          "659: }",
          "661: DIR *opendir(const char *name) {",
          "662:   DIR *d = NULL;",
          "663:   wchar_t wpath[MAX_PATH];",
          "664:   DWORD attrs;",
          "666:   if (name == NULL) {",
          "667:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "668:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "669:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "671:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "672:     attrs = GetFileAttributesW(wpath);",
          "673:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "674:       (void) wcscat(wpath, L\"\\\\*\");",
          "675:       d->handle = FindFirstFileW(wpath, &d->info);",
          "676:       d->result.d_name[0] = '\\0';",
          "678:       free(d);",
          "679:       d = NULL;",
          "682:   return d;",
          "683: }",
          "685: int closedir(DIR *d) {",
          "686:   int result = 0;",
          "687:   if (d != NULL) {",
          "688:     if (d->handle != INVALID_HANDLE_VALUE)",
          "689:       result = FindClose(d->handle) ? 0 : -1;",
          "690:     free(d);",
          "691:   } else {",
          "692:     result = -1;",
          "693:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "694:   }",
          "695:   return result;",
          "696: }",
          "698: struct dirent *readdir(DIR *d) {",
          "699:   struct dirent *result = NULL;",
          "700:   if (d != NULL) {",
          "701:     memset(&d->result, 0, sizeof(d->result));",
          "702:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "703:       result = &d->result;",
          "704:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "705:                           sizeof(result->d_name), NULL, NULL);",
          "706:       if (!FindNextFileW(d->handle, &d->info)) {",
          "707:         FindClose(d->handle);",
          "708:         d->handle = INVALID_HANDLE_VALUE;",
          "709:       }",
          "710:     } else {",
          "711:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "712:     }",
          "713:   } else {",
          "714:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "715:   }",
          "716:   return result;",
          "717: }",
          "718: #endif",
          "720: static void printdirentry(struct mg_connection *c, const char *name,",
          "721:                           struct stat *stp) {",
          "722:   char size[64], mod[64], path[MG_PATH_MAX];",
          "723:   int is_dir = S_ISDIR(stp->st_mode), n = 0;",
          "724:   const char *slash = is_dir ? \"/\" : \"\";",
          "725:   struct tm t;",
          "727:   if (is_dir) {",
          "728:     snprintf(size, sizeof(size), \"%s\", \"[DIR]\");",
          "729:   } else {",
          "730:     if (stp->st_size < 1024) {",
          "731:       snprintf(size, sizeof(size), \"%d\", (int) stp->st_size);",
          "732:     } else if (stp->st_size < 0x100000) {",
          "733:       snprintf(size, sizeof(size), \"%.1fk\", (double) stp->st_size / 1024.0);",
          "734:     } else if (stp->st_size < 0x40000000) {",
          "735:       snprintf(size, sizeof(size), \"%.1fM\", (double) stp->st_size / 1048576);",
          "736:     } else {",
          "737:       snprintf(size, sizeof(size), \"%.1fG\", (double) stp->st_size / 1073741824);",
          "738:     }",
          "739:   }",
          "740:   strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&stp->st_mtime, &t));",
          "741:   n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "742:   mg_printf(c,",
          "743:             \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "744:             \"<td>%s</td><td>%s</td></tr>\\n\",",
          "745:             n, path, slash, name, slash, mod, size);",
          "750:   char path[MG_PATH_MAX], *p = &dir[strlen(dir) - 1], tmp[10];",
          "751:   struct dirent *dp;",
          "752:   DIR *dirp;",
          "",
          "[Added Lines]",
          "576:       fs->close(fd);",
          "579:       c->pfn_data = fd;",
          "584: struct printdirentrydata {",
          "585:   struct mg_connection *c;",
          "586:   struct mg_http_message *hm;",
          "587:   struct mg_http_serve_opts *opts;",
          "588:   const char *dir;",
          "591: static void printdirentry(const char *name, void *userdata) {",
          "592:   struct printdirentrydata *d = (struct printdirentrydata *) userdata;",
          "593:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "594:   size_t size = 0;",
          "595:   time_t mtime = 0;",
          "596:   char path[MG_PATH_MAX], sz[64], mod[64];",
          "597:   int flags, n = 0;",
          "599:   if (snprintf(path, sizeof(path), \"%s%c%s\", d->dir, MG_DIRSEP, name) < 0) {",
          "600:     LOG(LL_ERROR, (\"%s truncated\", name));",
          "601:   } else if ((flags = fs->stat(path, &size, &mtime)) == 0) {",
          "602:     LOG(LL_ERROR, (\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "604:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "605:     struct tm t;",
          "606:     if (flags & MG_FS_DIR) {",
          "607:       snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "608:     } else if (size < 1024) {",
          "609:       snprintf(sz, sizeof(sz), \"%d\", (int) size);",
          "610:     } else if (size < 0x100000) {",
          "611:       snprintf(sz, sizeof(sz), \"%.1fk\", (double) size / 1024.0);",
          "612:     } else if (size < 0x40000000) {",
          "613:       snprintf(sz, sizeof(sz), \"%.1fM\", (double) size / 1048576);",
          "615:       snprintf(sz, sizeof(sz), \"%.1fG\", (double) size / 1073741824);",
          "617:     strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime_r(&mtime, &t));",
          "618:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "619:     mg_printf(d->c,",
          "620:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "621:               \"<td>%s</td><td>%s</td></tr>\\n\",",
          "622:               n, path, slash, name, slash, mod, sz);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "773:       \"srt(tb, sc, so, true);\"",
          "774:       \"}\"",
          "775:       \"</script>\";",
          "838:     LOG(LL_ERROR, (\"realpath(%s): %d\", opts->root_dir, errno));",
          "839:     mg_http_reply(c, 400, \"\", \"Bad web root [%s]\\n\", opts->root_dir);",
          "841:     mg_http_reply(c, 400, \"\", \"Invalid web root [%s]\\n\", root_dir);",
          "842:   } else {",
          "845:     size_t n1 = strlen(root_dir), n2;",
          "848:     mg_url_decode(hm->uri.ptr, hm->uri.len, root_dir + n1, rlen - n1, 0);",
          "849:     root_dir[rlen - 1] = '\\0';",
          "850:     n2 = strlen(root_dir);",
          "851:     while (n2 > 0 && root_dir[n2 - 1] == '/') root_dir[--n2] = 0;",
          "857:     } else {",
          "868:       } else {",
          "871:       }",
          "872:     }",
          "873:   }",
          "875: }",
          "877: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "878:                        struct mg_http_serve_opts *opts) {",
          "900:     listdir(c, hm, opts, path);",
          "905:   } else if (opts->ssi_pattern != NULL &&",
          "906:              mg_globmatch(opts->ssi_pattern, strlen(opts->ssi_pattern), path,",
          "907:                           strlen(path))) {",
          "910:   } else {",
          "911:     mg_http_serve_file(c, hm, path, opts);",
          "912:   }",
          "",
          "[Removed Lines]",
          "777:   while (p > dir && *p != '/') *p-- = '\\0';",
          "778:   if ((dirp = (opendir(dir))) != NULL) {",
          "779:     size_t off, n;",
          "780:     mg_printf(c,",
          "781:               \"HTTP/1.1 200 OK\\r\\n\"",
          "782:               \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "783:               \"%s\"",
          "784:               \"Content-Length:         \\r\\n\\r\\n\",",
          "785:               opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "786:     off = c->send.len;  // Start of body",
          "787:     mg_printf(c,",
          "788:               \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "789:               \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "790:               \"font-family: monospace; }</style></head>\"",
          "791:               \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "792:               \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "793:               \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "794:               \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "795:               \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "796:               \"</thead>\"",
          "797:               \"<tbody id=\\\"tb\\\">\\n\",",
          "798:               (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "799:               (int) hm->uri.len, hm->uri.ptr);",
          "801:     while ((dp = readdir(dirp)) != NULL) {",
          "802:       struct stat st;",
          "803:       const char *sep = dp->d_name[0] == MG_DIRSEP ? \"/\" : \"\";",
          "805:       if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "807:       if (snprintf(path, sizeof(path), \"%s%s%s\", dir, sep, dp->d_name) < 0) {",
          "808:         LOG(LL_ERROR, (\"%s truncated\", dp->d_name));",
          "809:       } else if (stat(path, &st) != 0) {",
          "810:         LOG(LL_ERROR, (\"%lu stat(%s): %d\", c->id, path, errno));",
          "811:       } else {",
          "812:         printdirentry(c, dp->d_name, &st);",
          "813:       }",
          "814:     }",
          "815:     closedir(dirp);",
          "816:     mg_printf(c,",
          "817:               \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "818:               \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "819:               MG_VERSION);",
          "820:     n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "821:                           (unsigned long) (c->send.len - off));",
          "822:     if (n > sizeof(tmp)) n = 0;",
          "823:     memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "824:   } else {",
          "825:     mg_http_reply(c, 400, \"\", \"Cannot open dir\");",
          "826:     LOG(LL_ERROR, (\"%lu opendir(%s) -> %d\", c->id, dir, errno));",
          "827:   }",
          "828: }",
          "829: #endif",
          "831: static bool uri_to_local_path(struct mg_connection *c,",
          "832:                               struct mg_http_message *hm,",
          "833:                               struct mg_http_serve_opts *opts, char *root_dir,",
          "834:                               size_t rlen, char *path, size_t path_len,",
          "835:                               bool *is_index) {",
          "836:   bool success = false;",
          "837:   if (realpath(opts->root_dir, root_dir) == NULL) {",
          "840:   } else if (!mg_is_dir(root_dir)) {",
          "853:     if (realpath(root_dir, path) == NULL) {",
          "854:       LOG(LL_ERROR, (\"realpath(%s): %d\", root_dir, errno));",
          "855:       mg_http_reply(c, 404, \"\", \"Not found [%.*s]\\n\", (int) hm->uri.len,",
          "856:                     hm->uri.ptr);",
          "858:       if (mg_is_dir(path)) {",
          "859:         strncat(path, \"/index.html\", path_len - strlen(path) - 1);",
          "860:         path[path_len - 1] = '\\0';",
          "862:       }",
          "864:       if (strlen(path) < n1 || memcmp(root_dir, path, n1) != 0) {",
          "866:         mg_http_reply(c, 404, \"\", \"Invalid URI [%.*s]\\n\", (int) hm->uri.len,",
          "867:                       hm->uri.ptr);",
          "869:         root_dir[n1] = '\\0';",
          "870:         success = true;",
          "874:   return success;",
          "879:   char root_dir[MG_PATH_MAX], path[sizeof(root_dir)];",
          "880:   bool is_index = false, exists;",
          "881:   struct stat st;",
          "882:   root_dir[0] = path[0] = '\\0';",
          "884:   if (!uri_to_local_path(c, hm, opts, root_dir, sizeof(root_dir), path,",
          "885:                          sizeof(path), &is_index))",
          "886:     return;",
          "888:   exists = stat(path, &st) == 0;",
          "889: #if MG_ENABLE_SSI",
          "890:   if (is_index && !exists) {",
          "891:     char *p = path + strlen(path);",
          "892:     while (p > path && p[-1] != '/') p--;",
          "893:     strncpy(p, \"index.shtml\", (size_t)(&path[sizeof(path)] - p - 2));",
          "894:     path[sizeof(path) - 1] = '\\0';",
          "895:     exists = stat(path, &st) == 0;",
          "896:   }",
          "897: #endif",
          "898:   if (is_index && !exists) {",
          "899: #if MG_ENABLE_DIRECTORY_LISTING",
          "901: #else",
          "902:     mg_http_reply(c, 403, \"\", \"%s\", \"Directory listing not supported\");",
          "903: #endif",
          "904: #if MG_ENABLE_SSI",
          "908:     mg_http_serve_ssi(c, root_dir, path);",
          "909: #endif",
          "",
          "[Added Lines]",
          "651:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "652:   struct printdirentrydata d = {c, hm, opts, dir};",
          "653:   char tmp[10];",
          "654:   size_t off, n;",
          "656:   mg_printf(c,",
          "657:             \"HTTP/1.1 200 OK\\r\\n\"",
          "658:             \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "659:             \"%s\"",
          "660:             \"Content-Length:         \\r\\n\\r\\n\",",
          "661:             opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "662:   off = c->send.len;  // Start of body",
          "663:   mg_printf(c,",
          "664:             \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "665:             \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "666:             \"font-family: monospace; }</style></head>\"",
          "667:             \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "668:             \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "669:             \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "670:             \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "671:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "672:             \"</thead>\"",
          "673:             \"<tbody id=\\\"tb\\\">\\n\",",
          "674:             (int) hm->uri.len, hm->uri.ptr, sort_js_code, sort_js_code2,",
          "675:             (int) hm->uri.len, hm->uri.ptr);",
          "677:   fs->list(dir, printdirentry, &d);",
          "678:   mg_printf(c,",
          "679:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "680:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "681:             MG_VERSION);",
          "682:   n = (size_t) snprintf(tmp, sizeof(tmp), \"%lu\",",
          "683:                         (unsigned long) (c->send.len - off));",
          "684:   if (n > sizeof(tmp)) n = 0;",
          "685:   memcpy(c->send.buf + off - 10, tmp, n);  // Set content length",
          "686: }",
          "688: static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,",
          "689:                        struct mg_http_serve_opts *opts, char *root_dir,",
          "690:                        size_t rlen, char *path, size_t plen) {",
          "691:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "692:   int flags = 0, tmp;",
          "693:   if (fs->realpath(opts->root_dir, root_dir) == NULL) {",
          "696:   } else if (!(fs->stat(root_dir, NULL, NULL) & MG_FS_DIR)) {",
          "708:     if (fs->realpath(root_dir, path) == NULL ||",
          "709:         (flags = fs->stat(path, NULL, NULL)) == 0) {",
          "710:       mg_http_reply(c, 404, \"\", \"Not found\\n\");",
          "714:       root_dir[n1] = '\\0';  // Restore root_dir - remove appended URI",
          "715:       n2 = strlen(path);    // Memorise path length",
          "716:       if ((flags & MG_FS_DIR) &&",
          "717:           ((snprintf(path + n2, plen - n2, \"/index.html\") > 0 &&",
          "718:             (tmp = fs->stat(path, NULL, NULL)) != 0) ||",
          "719:            (snprintf(path + n2, plen - n2, \"/index.shtml\") > 0 &&",
          "720:             (tmp = fs->stat(path, NULL, NULL)) != 0))) {",
          "721:         flags = tmp;",
          "723:         path[n2] = '\\0';  // Remove appended index file name",
          "727:     if (strlen(path) < n1 || memcmp(root_dir, path, n1) != 0) {",
          "728:       mg_http_reply(c, 404, \"\", \"Invalid URI [%.*s]\\n\", (int) hm->uri.len,",
          "729:                     hm->uri.ptr);",
          "730:       flags = 0;",
          "731:     }",
          "733:   return flags;",
          "738:   char root[MG_PATH_MAX] = \"\", path[sizeof(root)] = \"\";",
          "739:   int flags = uri_to_path(c, hm, opts, root, sizeof(root), path, sizeof(path));",
          "741:   if (flags == 0) return;",
          "742:   LOG(LL_DEBUG, (\"root [%s], path [%s] %d\", root, path, flags));",
          "743:   if (flags & MG_FS_DIR) {",
          "748:     mg_http_serve_ssi(c, root, path);",
          "",
          "---------------"
        ],
        "src/ssi.c||src/ssi.c": [
          "File: src/ssi.c -> src/ssi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:   mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);",
          "84:   free(data);",
          "85: }",
          "86: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86: #else",
          "87: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "88:                        const char *fullpath) {",
          "89:   mg_http_reply(c, 501, NULL, \"SSI not enabled\");",
          "90:   (void) root, (void) fullpath;",
          "91: }",
          "",
          "---------------"
        ],
        "test/mongoose_custom.c||test/mongoose_custom.c": [
          "File: test/mongoose_custom.c -> test/mongoose_custom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:   return 0;",
          "12: }",
          "14: struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,",
          "15:                                  mg_event_handler_t fn, void *fn_data) {",
          "16:   (void) mgr, (void) url, (void) fn, (void) fn_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: char *realpath(const char *path, char *resolved_path) {",
          "15:   if (resolved_path == NULL) resolved_path = malloc(strlen(path) + 1);",
          "16:   strcpy(resolved_path, path);",
          "17:   return resolved_path;",
          "18: }",
          "",
          "---------------"
        ],
        "test/mongoose_custom.h||test/mongoose_custom.h": [
          "File: test/mongoose_custom.h -> test/mongoose_custom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #pragma once",
          "6: #include <errno.h>",
          "7: #include <stdarg.h>",
          "",
          "[Removed Lines]",
          "4: #define _GNU_SOURCE  // For fopencookie()",
          "",
          "[Added Lines]",
          "4: #define _POSIX_TIMERS",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21: #define MG_PATH_MAX 100",
          "22: #undef MG_ENABLE_SOCKET",
          "23: #define MG_ENABLE_SOCKET 0",
          "",
          "[Removed Lines]",
          "25: int clock_gettime(clockid_t clock_id, struct timespec *tp);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "363:       sopts.root_dir = \".\";",
          "364:       sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";",
          "365:       mg_http_serve_dir(c, hm, &sopts);",
          "371:     } else if (mg_http_match_uri(hm, \"/servefile\")) {",
          "372:       struct mg_http_serve_opts sopts;",
          "373:       memset(&sopts, 0, sizeof(sopts));",
          "",
          "[Removed Lines]",
          "366:     } else if (mg_http_match_uri(hm, \"/packed/#\")) {",
          "367:       struct mg_http_serve_opts sopts;",
          "368:       memset(&sopts, 0, sizeof(sopts));",
          "369:       sopts.root_dir = \".\";",
          "370:       mg_http_serve_dir(c, hm, &sopts);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "502:   ASSERT(cmpbody(buf, \"\u0454\\n\") == 0);",
          "504:   {",
          "507:     char etag[100];",
          "510:     ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",",
          "511:                  etag) == 304);",
          "512:   }",
          "",
          "[Removed Lines]",
          "505:     extern char *mg_http_etag(char *, size_t, struct stat *);",
          "506:     struct stat st;",
          "508:     ASSERT(stat(\"./test/data/a.txt\", &st) == 0);",
          "509:     ASSERT(mg_http_etag(etag, sizeof(etag), &st) == etag);",
          "",
          "[Added Lines]",
          "500:     extern char *mg_http_etag(char *, size_t, size_t, time_t);",
          "502:     size_t size = 0;",
          "503:     time_t mtime = 0;",
          "504:     ASSERT(mg_fs_posix.stat(\"./test/data/a.txt\", &size, &mtime) != 0);",
          "505:     ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "587:   fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\");",
          "588:   ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);",
          "589:   ASSERT(mg_strstr(mg_str(buf), mg_str(\">Index of /test/<\")) != NULL);",
          "590:   ASSERT(mg_strstr(mg_str(buf), mg_str(\">fuzz.c<\")) != NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "585:   printf(\"-------\\n%s\\n\", buf);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1356:   ASSERT(mg_http_next_multipart(mg_str(s), ofs, &part) == 0);",
          "1357: }",
          "1359: static void test_packed(void) {",
          "1360:   struct mg_mgr mgr;",
          "1361:   const char *url = \"http://127.0.0.1:12351\";",
          "1363:   mg_mgr_init(&mgr);",
          "1366:   mg_mgr_free(&mgr);",
          "1367:   ASSERT(mgr.conns == NULL);",
          "1368: }",
          "1370: int main(void) {",
          "1371:   mg_log_set(\"3\");",
          "1373:   test_crc32();",
          "1374:   test_multipart();",
          "1375:   test_http_chunked();",
          "",
          "[Removed Lines]",
          "1362:   char buf[FETCH_BUF_SIZE];",
          "1364:   mg_http_listen(&mgr, url, eh1, NULL);",
          "1365:   ASSERT(fetch(&mgr, buf, url, \"GET /packed/ HTTP/1.0\\n\\n\") == 404);",
          "1372:   test_packed();",
          "",
          "[Added Lines]",
          "1356: static void eh7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {",
          "1357:   if (ev == MG_EV_HTTP_MSG) {",
          "1358:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "1359:     struct mg_http_serve_opts sopts;",
          "1360:     memset(&sopts, 0, sizeof(sopts));",
          "1361:     sopts.root_dir = \".\";",
          "1362:     sopts.fs = &mg_fs_packed;",
          "1363:     mg_http_serve_dir(c, hm, &sopts);",
          "1364:   }",
          "1365:   (void) ev_data, (void) fn_data;",
          "1366: }",
          "1371:   char buf[FETCH_BUF_SIZE] = \"\";",
          "1373:   mg_http_listen(&mgr, url, eh7, NULL);",
          "1376:   fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\");",
          "1377:   printf(\"--------\\n%s\\n\", buf);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1379:   test_dns();",
          "1380:   test_str();",
          "1381:   test_timer();",
          "1383:   test_url();",
          "1384:   test_iobuf();",
          "1385:   test_commalist();",
          "",
          "[Removed Lines]",
          "1382:   test_http_range();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1392:   test_http_client();",
          "1393:   test_http_no_content_length();",
          "1394:   test_http_pipeline();",
          "1395:   test_mqtt();",
          "1396:   printf(\"SUCCESS. Total tests: %d\\n\", s_num_tests);",
          "1397:   return EXIT_SUCCESS;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1405:   test_http_range();",
          "1406:   test_packed();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
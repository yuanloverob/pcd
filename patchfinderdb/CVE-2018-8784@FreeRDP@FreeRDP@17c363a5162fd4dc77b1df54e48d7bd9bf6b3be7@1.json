{
  "cve_id": "CVE-2018-8784",
  "cve_desc": "FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress_segment() that results in a memory corruption and probably even a remote code execution.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7",
  "patch_info": {
    "commit_hash": "17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/17c363a5162fd4dc77b1df54e48d7bd9bf6b3be7",
    "files": [
      "libfreerdp/codec/zgfx.c"
    ],
    "message": "Fixed CVE-2018-8784\n\nThanks to Eyal Itkin from Check Point Software Technologies.",
    "before_after_code_files": [
      "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
    ]
  },
  "patch_diff": {
    "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
      "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "137:  _zgfx->cBitsCurrent -= _nbits;",
      "138:  _zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;",
      "139:  _zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);",
      "140: }",
      "142: static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "140:  return TRUE;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "229:  UINT32 count;",
      "230:  UINT32 distance;",
      "231:  BYTE* pbSegment;",
      "235:   return FALSE;",
      "",
      "[Removed Lines]",
      "232:  size_t cbSegment = segmentSize - 1;",
      "234:  if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))",
      "",
      "[Added Lines]",
      "233:  size_t cbSegment;",
      "235:  if (!zgfx || !stream)",
      "236:   return FALSE;",
      "238:  cbSegment = segmentSize - 1;",
      "240:  if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||",
      "241:      (segmentSize > UINT32_MAX))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "242:  if (!(flags & PACKET_COMPRESSED))",
      "243:  {",
      "244:   zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);",
      "245:   CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);",
      "246:   zgfx->OutputCount = cbSegment;",
      "247:   return TRUE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "253:   if (cbSegment > sizeof(zgfx->OutputBuffer))",
      "254:    return FALSE;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "280:      if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)",
      "281:       zgfx->HistoryIndex = 0;",
      "283:      zgfx->OutputBuffer[zgfx->OutputCount++] = c;",
      "284:     }",
      "285:     else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "294:      if (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))",
      "295:       return FALSE;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "313:        count += zgfx->bits;",
      "314:       }",
      "316:       zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);",
      "317:       zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);",
      "318:       zgfx->OutputCount += count;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "330:       if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)",
      "331:        return FALSE;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "325:       zgfx->cBitsRemaining -= zgfx->cBitsCurrent;",
      "326:       zgfx->cBitsCurrent = 0;",
      "327:       zgfx->BitsCurrent = 0;",
      "328:       CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);",
      "329:       zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);",
      "330:       zgfx->pbInputCurrent += count;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "346:       if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)",
      "347:        return FALSE;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09b9d4f1994a674c4ec85b4947aa656eda1aed8a",
      "candidate_info": {
        "commit_hash": "09b9d4f1994a674c4ec85b4947aa656eda1aed8a",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a",
        "files": [
          "libfreerdp/gdi/graphics.c"
        ],
        "message": "Fixed CVE-2018-8787\n\nThanks to Eyal Itkin from Check Point Software Technologies.",
        "before_after_code_files": [
          "libfreerdp/gdi/graphics.c||libfreerdp/gdi/graphics.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/5031"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/gdi/graphics.c||libfreerdp/gdi/graphics.c": [
          "File: libfreerdp/gdi/graphics.c -> libfreerdp/gdi/graphics.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: {",
          "142:  UINT32 SrcSize = length;",
          "143:  rdpGdi* gdi = context->gdi;",
          "144:  bitmap->compressed = FALSE;",
          "145:  bitmap->format = gdi->dstFormat;",
          "147:  bitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);",
          "149:  if (!bitmap->data)",
          "",
          "[Removed Lines]",
          "146:  bitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);",
          "",
          "[Added Lines]",
          "144:  UINT32 size = DstWidth * DstHeight;",
          "148:  if ((GetBytesPerPixel(bitmap->format) == 0) ||",
          "149:      (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||",
          "150:      (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))",
          "151:   return FALSE;",
          "153:  size *= GetBytesPerPixel(bitmap->format);",
          "154:  bitmap->length = size;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbdc4f4933ca4d603831ef46c4aa17261298e03e",
      "candidate_info": {
        "commit_hash": "dbdc4f4933ca4d603831ef46c4aa17261298e03e",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/dbdc4f4933ca4d603831ef46c4aa17261298e03e",
        "files": [
          "libfreerdp/codec/zgfx.c"
        ],
        "message": "Fixed endianess issues of zgfx decoder.",
        "before_after_code_files": [
          "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ],
          "candidate": [
            "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c"
          ]
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/zgfx.c||libfreerdp/codec/zgfx.c": [
          "File: libfreerdp/codec/zgfx.c -> libfreerdp/codec/zgfx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110:  _zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent; \\",
          "111:  _zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);",
          "114: {",
          "115:  UINT32 front;",
          "118:  if (count <= 0)",
          "119:   return;",
          "121:  if (count > zgfx->HistoryBufferSize)",
          "122:  {",
          "124:   count = zgfx->HistoryBufferSize;",
          "125:   src += residue;",
          "126:   zgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;",
          "",
          "[Removed Lines]",
          "113: static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, UINT32 count)",
          "116:  UINT32 residue;",
          "123:   residue = count - zgfx->HistoryBufferSize;",
          "",
          "[Added Lines]",
          "113: static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)",
          "122:   const size_t residue = count - zgfx->HistoryBufferSize;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "190:  while ((bytesLeft -= bytes) > 0);",
          "191: }",
          "194: {",
          "195:  BYTE c;",
          "196:  BYTE flags;",
          "",
          "[Removed Lines]",
          "193: static int zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, const BYTE* pbSegment, UINT32 cbSegment)",
          "",
          "[Added Lines]",
          "192: static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "200:  int inPrefix;",
          "201:  UINT32 count;",
          "202:  UINT32 distance;",
          "210:  zgfx->OutputCount = 0;",
          "212:  if (!(flags & PACKET_COMPRESSED))",
          "213:  {",
          "214:   zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);",
          "215:   CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);",
          "216:   zgfx->OutputCount = cbSegment;",
          "218:  }",
          "220:  zgfx->pbInputCurrent = pbSegment;",
          "",
          "[Removed Lines]",
          "204:  if (cbSegment < 1)",
          "205:   return -1;",
          "208:  pbSegment++;",
          "209:  cbSegment--;",
          "217:   return 1;",
          "",
          "[Added Lines]",
          "202:  BYTE* pbSegment;",
          "203:  size_t cbSegment = segmentSize - 1;",
          "205:  if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))",
          "206:   return FALSE;",
          "210:  pbSegment = Stream_Pointer(stream);",
          "211:  Stream_Seek(stream, cbSegment);",
          "218:   return TRUE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "308:   }",
          "309:  }",
          "312: }",
          "314: int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,",
          "315:                     UINT32* pDstSize, UINT32 flags)",
          "316: {",
          "318:  BYTE descriptor;",
          "325:  if (descriptor == ZGFX_SEGMENTED_SINGLE)",
          "326:  {",
          "334:   if (!*ppDstData)",
          "338:   CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);",
          "",
          "[Removed Lines]",
          "311:  return 1;",
          "317:  int status;",
          "320:  if (SrcSize < 1)",
          "321:   return -1;",
          "327:   status = zgfx_decompress_segment(zgfx, &pSrcData[1], SrcSize - 1);",
          "329:   if (status < 0)",
          "330:    return status;",
          "335:    return -1;",
          "",
          "[Added Lines]",
          "312:  return TRUE;",
          "318:  int status = -1;",
          "320:  wStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);",
          "322:  if (Stream_GetRemainingLength(stream) < 1)",
          "323:   goto fail;",
          "329:   if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))",
          "330:    goto fail;",
          "335:    goto fail;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "346:   UINT32 uncompressedSize;",
          "347:   BYTE* pConcatenated;",
          "348:   segmentOffset = 7;",
          "351:   pConcatenated = (BYTE*) malloc(uncompressedSize);",
          "353:   if (!pConcatenated)",
          "359:   for (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)",
          "360:   {",
          "369:    CopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);",
          "370:    pConcatenated += zgfx->OutputCount;",
          "371:   }",
          "372:  }",
          "373:  else",
          "374:  {",
          "376:  }",
          "379: }",
          "383: {",
          "385:  if (!Stream_EnsureRemainingCapacity(s, SrcSize + 1))",
          "386:  {",
          "387:   WLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");",
          "389:  }",
          "393:  Stream_Write(s, pSrcData, SrcSize);",
          "395: }",
          "397: int zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,",
          "",
          "[Removed Lines]",
          "354:    return -1;",
          "362:    segmentOffset += 4;",
          "363:    status = zgfx_decompress_segment(zgfx, &pSrcData[segmentOffset], segmentSize);",
          "365:    if (status < 0)",
          "366:     return status;",
          "368:    segmentOffset += segmentSize;",
          "375:   return -1;",
          "378:  return 1;",
          "381: static int zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,",
          "382:                                  UINT32 SrcSize, UINT32* pFlags)",
          "388:   return -1;",
          "394:  return 1;",
          "",
          "[Added Lines]",
          "350:   if (Stream_GetRemainingLength(stream) < 6)",
          "351:    goto fail;",
          "356:   if (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))",
          "357:    goto fail;",
          "362:    goto fail;",
          "369:    if (Stream_GetRemainingLength(stream) < sizeof(UINT32))",
          "370:     goto fail;",
          "374:    if (!zgfx_decompress_segment(zgfx, stream, segmentSize))",
          "375:     goto fail;",
          "383:   goto fail;",
          "386:  status = 1;",
          "387: fail:",
          "388:  Stream_Free(stream, FALSE);",
          "389:  return status;",
          "392: static BOOL zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,",
          "393:                                   UINT32 SrcSize, UINT32* pFlags)",
          "399:   return FALSE;",
          "405:  return TRUE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "449:   posDataStart = Stream_GetPosition(sDst);",
          "456:   if (posDstSize)",
          "457:   {",
          "",
          "[Removed Lines]",
          "451:   if ((status = zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags)) < 0)",
          "452:   {",
          "453:    return status;",
          "454:   }",
          "",
          "[Added Lines]",
          "462:   if (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))",
          "463:    return -1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
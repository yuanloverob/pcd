{
  "cve_id": "CVE-2017-6831",
  "cve_desc": "Heap-based buffer overflow in the decodeBlockWAVE function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6, 0.3.5, 0.3.4, 0.3.3, 0.3.2, 0.3.1, 0.3.0 and 0.2.7 allows remote attackers to cause a denial of service (crash) via a crafted file.",
  "repo": "antlarr/audiofile",
  "patch_hash": "a2e9eab8ea87c4ffc494d839ebb4ea145eb9f2e6",
  "patch_info": {
    "commit_hash": "a2e9eab8ea87c4ffc494d839ebb4ea145eb9f2e6",
    "repo": "antlarr/audiofile",
    "commit_url": "https://github.com/antlarr/audiofile/commit/a2e9eab8ea87c4ffc494d839ebb4ea145eb9f2e6",
    "files": [
      "libaudiofile/WAVE.cpp"
    ],
    "message": "Actually fail when error occurs in parseFormat\n\nWhen there's an unsupported number of bits per sample or an invalid\nnumber of samples per block, don't only print an error message using\nthe error handler, but actually stop parsing the file.\n\nThis fixes #35 (also reported at\nhttps://bugzilla.opensuse.org/show_bug.cgi?id=1026983 and\nhttps://blogs.gentoo.org/ago/2017/02/20/audiofile-heap-based-buffer-overflow-in-imadecodeblockwave-ima-cpp/\n)",
    "before_after_code_files": [
      "libaudiofile/WAVE.cpp||libaudiofile/WAVE.cpp"
    ]
  },
  "patch_diff": {
    "libaudiofile/WAVE.cpp||libaudiofile/WAVE.cpp": [
      "File: libaudiofile/WAVE.cpp -> libaudiofile/WAVE.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "326:    {",
      "327:     _af_error(AF_BAD_NOT_IMPLEMENTED,",
      "328:      \"IMA ADPCM compression supports only 4 bits per sample\");",
      "329:    }",
      "331:    int bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "329:     return AF_FAIL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "333:    {",
      "334:     _af_error(AF_BAD_CODEC_CONFIG,",
      "335:      \"Invalid samples per block for IMA ADPCM compression\");",
      "336:    }",
      "338:    track->f.sampleWidth = 16;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "337:     return AF_FAIL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e018528ab5d767c512e3b35df1c91e53b5e21fea",
      "candidate_info": {
        "commit_hash": "e018528ab5d767c512e3b35df1c91e53b5e21fea",
        "repo": "antlarr/audiofile",
        "commit_url": "https://github.com/antlarr/audiofile/commit/e018528ab5d767c512e3b35df1c91e53b5e21fea",
        "files": [
          "libaudiofile/modules/BlockCodec.cpp"
        ],
        "message": "Check for division by zero in BlockCodec::runPull",
        "before_after_code_files": [
          "libaudiofile/modules/BlockCodec.cpp||libaudiofile/modules/BlockCodec.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/mpruett/audiofile/pull/44"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libaudiofile/modules/BlockCodec.cpp||libaudiofile/modules/BlockCodec.cpp": [
          "File: libaudiofile/modules/BlockCodec.cpp -> libaudiofile/modules/BlockCodec.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:  ssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);",
          "53:  for (int i=0; i<blocksRead; i++)",
          "",
          "[Removed Lines]",
          "50:  int blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;",
          "",
          "[Added Lines]",
          "50:  int blocksRead = (bytesRead >= 0 && m_bytesPerPacket > 0) ? bytesRead / m_bytesPerPacket : 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
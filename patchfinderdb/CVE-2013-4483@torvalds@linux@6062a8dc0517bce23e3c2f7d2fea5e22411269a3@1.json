{
  "cve_id": "CVE-2013-4483",
  "cve_desc": "The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
  "patch_info": {
    "commit_hash": "6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
    "files": [
      "ipc/msg.c",
      "ipc/sem.c",
      "ipc/util.c",
      "ipc/util.h"
    ],
    "message": "ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "ipc/msg.c||ipc/msg.c",
      "ipc/sem.c||ipc/sem.c",
      "ipc/util.c||ipc/util.c",
      "ipc/util.h||ipc/util.h"
    ]
  },
  "patch_diff": {
    "ipc/msg.c||ipc/msg.c": [
      "File: ipc/msg.c -> ipc/msg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "687:    goto out_unlock_free;",
      "688:   }",
      "689:   ss_add(msq, &s);",
      "691:   msg_unlock(msq);",
      "692:   schedule();",
      "",
      "[Removed Lines]",
      "690:   ipc_rcu_getref(msq);",
      "",
      "[Added Lines]",
      "691:   if (!ipc_rcu_getref(msq)) {",
      "692:    err = -EIDRM;",
      "693:    goto out_unlock_free;",
      "694:   }",
      "",
      "---------------"
    ],
    "ipc/sem.c||ipc/sem.c": [
      "File: ipc/sem.c -> ipc/sem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "138: #define sem_ids(ns) ((ns)->ids[IPC_SEM_IDS])",
      "141: #define sem_checkid(sma, semid) ipc_checkid(&sma->sem_perm, semid)",
      "143: static int newary(struct ipc_namespace *, struct ipc_params *);",
      "",
      "[Removed Lines]",
      "140: #define sem_unlock(sma)  ipc_unlock(&(sma)->sem_perm)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "189:     IPC_SEM_IDS, sysvipc_sem_proc_show);",
      "190: }",
      "197: {",
      "198:  struct kern_ipc_perm *ipcp;",
      "199:  struct sem_array *sma;",
      "",
      "[Removed Lines]",
      "196: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)",
      "",
      "[Added Lines]",
      "208: static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,",
      "209:          int nsops)",
      "210: {",
      "211:  int locknum;",
      "212:  again:",
      "213:  if (nsops == 1 && !sma->complex_count) {",
      "214:   struct sem *sem = sma->sem_base + sops->sem_num;",
      "217:   spin_lock(&sem->lock);",
      "223:   if (unlikely(sma->complex_count)) {",
      "224:    spin_unlock(&sem->lock);",
      "225:    goto lock_array;",
      "226:   }",
      "233:   if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {",
      "234:    spin_unlock(&sem->lock);",
      "235:    spin_unlock_wait(&sma->sem_perm.lock);",
      "236:    goto again;",
      "237:   }",
      "239:   locknum = sops->sem_num;",
      "240:  } else {",
      "241:   int i;",
      "248:  lock_array:",
      "249:   spin_lock(&sma->sem_perm.lock);",
      "250:   for (i = 0; i < sma->sem_nsems; i++) {",
      "251:    struct sem *sem = sma->sem_base + i;",
      "252:    spin_unlock_wait(&sem->lock);",
      "253:   }",
      "254:   locknum = -1;",
      "255:  }",
      "256:  return locknum;",
      "257: }",
      "259: static inline void sem_unlock(struct sem_array *sma, int locknum)",
      "260: {",
      "261:  if (locknum == -1) {",
      "262:   spin_unlock(&sma->sem_perm.lock);",
      "263:  } else {",
      "264:   struct sem *sem = sma->sem_base + locknum;",
      "265:   spin_unlock(&sem->lock);",
      "266:  }",
      "267:  rcu_read_unlock();",
      "268: }",
      "274: static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,",
      "275:    int id, struct sembuf *sops, int nsops, int *locknum)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "205:   goto err;",
      "206:  }",
      "",
      "[Removed Lines]",
      "208:  spin_lock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "287:  sma = container_of(ipcp, struct sem_array, sem_perm);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "213:  if (!ipcp->deleted)",
      "214:   return container_of(ipcp, struct sem_array, sem_perm);",
      "217:  sma = ERR_PTR(-EINVAL);",
      "218: err:",
      "219:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "216:  spin_unlock(&ipcp->lock);",
      "",
      "[Added Lines]",
      "296:  sem_unlock(sma, *locknum);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "230:  return container_of(ipcp, struct sem_array, sem_perm);",
      "231: }",
      "244: static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,",
      "245:        int id)",
      "246: {",
      "",
      "[Removed Lines]",
      "233: static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,",
      "234:       int id)",
      "235: {",
      "236:  struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);",
      "238:  if (IS_ERR(ipcp))",
      "239:   return ERR_CAST(ipcp);",
      "241:  return container_of(ipcp, struct sem_array, sem_perm);",
      "242: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "255: static inline void sem_lock_and_putref(struct sem_array *sma)",
      "256: {",
      "258:  ipc_rcu_putref(sma);",
      "259: }",
      "261: static inline void sem_getref_and_unlock(struct sem_array *sma)",
      "262: {",
      "265: }",
      "267: static inline void sem_putref(struct sem_array *sma)",
      "268: {",
      "272: }",
      "",
      "[Removed Lines]",
      "257:  ipc_lock_by_ptr(&sma->sem_perm);",
      "263:  ipc_rcu_getref(sma);",
      "264:  ipc_unlock(&(sma)->sem_perm);",
      "269:  ipc_lock_by_ptr(&sma->sem_perm);",
      "270:  ipc_rcu_putref(sma);",
      "271:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "326:  rcu_read_lock();",
      "327:  sem_lock(sma, NULL, -1);",
      "333:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "334:  sem_unlock(sma, -1);",
      "339:  sem_lock_and_putref(sma);",
      "340:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "277: static inline void sem_getref(struct sem_array *sma)",
      "278: {",
      "282: }",
      "284: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
      "",
      "[Removed Lines]",
      "279:  spin_lock(&(sma)->sem_perm.lock);",
      "280:  ipc_rcu_getref(sma);",
      "281:  ipc_unlock(&(sma)->sem_perm);",
      "",
      "[Added Lines]",
      "348:  sem_lock(sma, NULL, -1);",
      "349:  WARN_ON_ONCE(!ipc_rcu_getref(sma));",
      "350:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "372:  sma->sem_base = (struct sem *) &sma[1];",
      "375:   INIT_LIST_HEAD(&sma->sem_base[i].sem_pending);",
      "377:  sma->complex_count = 0;",
      "378:  INIT_LIST_HEAD(&sma->sem_pending);",
      "379:  INIT_LIST_HEAD(&sma->list_id);",
      "380:  sma->sem_nsems = nsems;",
      "381:  sma->sem_ctime = get_seconds();",
      "384:  return sma->sem_perm.id;",
      "385: }",
      "",
      "[Removed Lines]",
      "374:  for (i = 0; i < nsems; i++)",
      "382:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "443:  for (i = 0; i < nsems; i++) {",
      "445:   spin_lock_init(&sma->sem_base[i].lock);",
      "446:  }",
      "453:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "820:  sem_rmid(ns, sma);",
      "823:  wake_up_sem_queue_do(&tasks);",
      "824:  ns->used_sems -= sma->sem_nsems;",
      "",
      "[Removed Lines]",
      "821:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "892:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "947:  struct sem_array *sma;",
      "948:  struct sem* curr;",
      "949:  int err;",
      "951:  struct list_head tasks;",
      "952:  int val;",
      "953: #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)",
      "",
      "[Removed Lines]",
      "950:  int nsems;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "958:  val = arg;",
      "959: #endif",
      "965:  INIT_LIST_HEAD(&tasks);",
      "972:  err = security_sem_semctl(sma, SETVAL);",
      "980:  curr = &sma->sem_base[semnum];",
      "986:  assert_spin_locked(&sma->sem_perm.lock);",
      "987:  list_for_each_entry(un, &sma->list_id, list_id)",
      "988:   un->semadj[semnum] = 0;",
      "",
      "[Removed Lines]",
      "961:  sma = sem_lock_check(ns, semid);",
      "962:  if (IS_ERR(sma))",
      "963:   return PTR_ERR(sma);",
      "966:  nsems = sma->sem_nsems;",
      "968:  err = -EACCES;",
      "969:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO))",
      "970:   goto out_unlock;",
      "973:  if (err)",
      "974:   goto out_unlock;",
      "976:  err = -EINVAL;",
      "977:  if(semnum < 0 || semnum >= nsems)",
      "978:   goto out_unlock;",
      "982:  err = -ERANGE;",
      "983:  if (val > SEMVMX || val < 0)",
      "984:   goto out_unlock;",
      "",
      "[Added Lines]",
      "1031:  if (val > SEMVMX || val < 0)",
      "1032:   return -ERANGE;",
      "1036:  rcu_read_lock();",
      "1037:  sma = sem_obtain_object_check(ns, semid);",
      "1038:  if (IS_ERR(sma)) {",
      "1039:   rcu_read_unlock();",
      "1040:   return PTR_ERR(sma);",
      "1041:  }",
      "1043:  if (semnum < 0 || semnum >= sma->sem_nsems) {",
      "1044:   rcu_read_unlock();",
      "1045:   return -EINVAL;",
      "1046:  }",
      "1049:  if (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {",
      "1050:   rcu_read_unlock();",
      "1051:   return -EACCES;",
      "1052:  }",
      "1055:  if (err) {",
      "1056:   rcu_read_unlock();",
      "1057:   return -EACCES;",
      "1058:  }",
      "1060:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "992:  sma->sem_ctime = get_seconds();",
      "994:  do_smart_update(sma, NULL, 0, 0, &tasks);",
      "998:  wake_up_sem_queue_do(&tasks);",
      "1000: }",
      "1002: static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,",
      "",
      "[Removed Lines]",
      "995:  err = 0;",
      "996: out_unlock:",
      "997:  sem_unlock(sma);",
      "999:  return err;",
      "",
      "[Added Lines]",
      "1073:  sem_unlock(sma, -1);",
      "1075:  return 0;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1052:    sem_lock_and_putref(sma);",
      "1053:    if (sma->sem_perm.deleted) {",
      "1055:     err = -EIDRM;",
      "1056:     goto out_free;",
      "1057:    }",
      "1061:   for (i = 0; i < sma->sem_nsems; i++)",
      "1062:    sem_io[i] = sma->sem_base[i].semval;",
      "1064:   err = 0;",
      "1065:   if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))",
      "1066:    err = -EFAULT;",
      "",
      "[Removed Lines]",
      "1054:     sem_unlock(sma);",
      "1058:   }",
      "1060:   spin_lock(&sma->sem_perm.lock);",
      "1063:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1130:     sem_unlock(sma, -1);",
      "1134:   } else",
      "1135:    sem_lock(sma, NULL, -1);",
      "1139:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1071:   int i;",
      "1072:   struct sem_undo *un;",
      "1075:   rcu_read_unlock();",
      "1077:   if(nsems > SEMMSL_FAST) {",
      "",
      "[Removed Lines]",
      "1074:   ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1150:   if (!ipc_rcu_getref(sma)) {",
      "1151:    rcu_read_unlock();",
      "1152:    return -EIDRM;",
      "1153:   }",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1097:   }",
      "1098:   sem_lock_and_putref(sma);",
      "1099:   if (sma->sem_perm.deleted) {",
      "1101:    err = -EIDRM;",
      "1102:    goto out_free;",
      "1103:   }",
      "",
      "[Removed Lines]",
      "1100:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1179:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "1124:   goto out_wakeup;",
      "1125:  }",
      "1128:  curr = &sma->sem_base[semnum];",
      "1130:  switch (cmd) {",
      "",
      "[Removed Lines]",
      "1127:  spin_lock(&sma->sem_perm.lock);",
      "",
      "[Added Lines]",
      "1206:  sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "1143:  }",
      "1145: out_unlock:",
      "1147: out_wakeup:",
      "1148:  wake_up_sem_queue_do(&tasks);",
      "1149: out_free:",
      "",
      "[Removed Lines]",
      "1146:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1225:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "1212:  switch(cmd){",
      "1213:  case IPC_RMID:",
      "1215:   freeary(ns, ipcp);",
      "1216:   goto out_up;",
      "1217:  case IPC_SET:",
      "1219:   err = ipc_update_perm(&semid64.sem_perm, ipcp);",
      "1220:   if (err)",
      "1221:    goto out_unlock;",
      "",
      "[Removed Lines]",
      "1214:   ipc_lock_object(&sma->sem_perm);",
      "1218:   ipc_lock_object(&sma->sem_perm);",
      "",
      "[Added Lines]",
      "1293:   sem_lock(sma, NULL, -1);",
      "1297:   sem_lock(sma, NULL, -1);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "1228:  }",
      "1230: out_unlock:",
      "1232: out_up:",
      "1233:  up_write(&sem_ids(ns).rw_mutex);",
      "1234:  return err;",
      "",
      "[Removed Lines]",
      "1231:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1310:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "1340:  struct sem_array *sma;",
      "1341:  struct sem_undo_list *ulp;",
      "1342:  struct sem_undo *un, *new;",
      "1346:  error = get_undo_list(&ulp);",
      "1347:  if (error)",
      "",
      "[Removed Lines]",
      "1343:  int nsems;",
      "1344:  int error;",
      "",
      "[Added Lines]",
      "1422:  int nsems, error;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "1363:  }",
      "1365:  nsems = sma->sem_nsems;",
      "1367:  rcu_read_unlock();",
      "",
      "[Removed Lines]",
      "1366:  ipc_rcu_getref(sma);",
      "",
      "[Added Lines]",
      "1444:  if (!ipc_rcu_getref(sma)) {",
      "1445:   rcu_read_unlock();",
      "1446:   un = ERR_PTR(-EIDRM);",
      "1447:   goto out;",
      "1448:  }",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "1377:  sem_lock_and_putref(sma);",
      "1378:  if (sma->sem_perm.deleted) {",
      "1380:   kfree(new);",
      "1381:   un = ERR_PTR(-EIDRM);",
      "1382:   goto out;",
      "",
      "[Removed Lines]",
      "1379:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1461:   sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "1404: success:",
      "1405:  spin_unlock(&ulp->lock);",
      "1406:  rcu_read_lock();",
      "1408: out:",
      "1409:  return un;",
      "1410: }",
      "",
      "[Removed Lines]",
      "1407:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1489:  sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "1444:  struct sembuf fast_sops[SEMOPM_FAST];",
      "1445:  struct sembuf* sops = fast_sops, *sop;",
      "1446:  struct sem_undo *un;",
      "1448:  struct sem_queue queue;",
      "1449:  unsigned long jiffies_left = 0;",
      "1450:  struct ipc_namespace *ns;",
      "",
      "[Removed Lines]",
      "1447:  int undos = 0, alter = 0, max;",
      "",
      "[Added Lines]",
      "1529:  int undos = 0, alter = 0, max, locknum;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "1488:    alter = 1;",
      "1489:  }",
      "1491:  if (undos) {",
      "1492:   un = find_alloc_undo(ns, semid);",
      "1493:   if (IS_ERR(un)) {",
      "1494:    error = PTR_ERR(un);",
      "1495:    goto out_free;",
      "1496:   }",
      "1498:   un = NULL;",
      "1503:  sma = sem_obtain_object_check(ns, semid);",
      "1504:  if (IS_ERR(sma)) {",
      "1507:   error = PTR_ERR(sma);",
      "1508:   goto out_free;",
      "1509:  }",
      "",
      "[Removed Lines]",
      "1497:  } else",
      "1500:  INIT_LIST_HEAD(&tasks);",
      "1502:  rcu_read_lock();",
      "1505:   if (un)",
      "1506:    rcu_read_unlock();",
      "",
      "[Added Lines]",
      "1573:  INIT_LIST_HEAD(&tasks);",
      "1582:  } else {",
      "1584:   rcu_read_lock();",
      "1585:  }",
      "1589:   rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "1536:  error = -EIDRM;",
      "1555:  error = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));",
      "1556:  if (error <= 0) {",
      "",
      "[Removed Lines]",
      "1537:  ipc_lock_object(&sma->sem_perm);",
      "1538:  if (un) {",
      "1539:   if (un->semid == -1) {",
      "1540:    rcu_read_unlock();",
      "1541:    goto out_unlock_free;",
      "1542:   } else {",
      "1551:    rcu_read_unlock();",
      "1552:   }",
      "1553:  }",
      "",
      "[Added Lines]",
      "1620:  locknum = sem_lock(sma, sops, nsops);",
      "1621:  if (un && un->semid == -1)",
      "1622:   goto out_unlock_free;",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "1592: sleep_again:",
      "1593:  current->state = TASK_INTERRUPTIBLE;",
      "1596:  if (timeout)",
      "1597:   jiffies_left = schedule_timeout(jiffies_left);",
      "",
      "[Removed Lines]",
      "1594:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1663:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "1613:   goto out_free;",
      "1614:  }",
      "",
      "[Removed Lines]",
      "1616:  sma = sem_obtain_lock(ns, semid);",
      "",
      "[Added Lines]",
      "1685:  sma = sem_obtain_lock(ns, semid, sops, nsops, &locknum);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "1652:  unlink_queue(sma, &queue);",
      "1654: out_unlock_free:",
      "1656: out_wakeup:",
      "1657:  wake_up_sem_queue_do(&tasks);",
      "1658: out_free:",
      "",
      "[Removed Lines]",
      "1655:  sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1724:  sem_unlock(sma, locknum);",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "1716:   struct sem_array *sma;",
      "1717:   struct sem_undo *un;",
      "1718:   struct list_head tasks;",
      "1722:   rcu_read_lock();",
      "1723:   un = list_entry_rcu(ulp->list_proc.next,",
      "",
      "[Removed Lines]",
      "1719:   int semid;",
      "1720:   int i;",
      "",
      "[Added Lines]",
      "1788:   int semid, i;",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "1726:    semid = -1;",
      "1727:    else",
      "1728:    semid = un->semid;",
      "1732:    break;",
      "1738:    continue;",
      "1740:   un = __lookup_undo(ulp, semid);",
      "1741:   if (un == NULL) {",
      "1746:    continue;",
      "1747:   }",
      "",
      "[Removed Lines]",
      "1729:   rcu_read_unlock();",
      "1731:   if (semid == -1)",
      "1734:   sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1737:   if (IS_ERR(sma))",
      "1745:    sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1798:   if (semid == -1) {",
      "1799:    rcu_read_unlock();",
      "1801:   }",
      "1803:   sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);",
      "1805:   if (IS_ERR(sma)) {",
      "1806:    rcu_read_unlock();",
      "1808:   }",
      "1810:   sem_lock(sma, NULL, -1);",
      "1816:    sem_unlock(sma, -1);",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "1783:   INIT_LIST_HEAD(&tasks);",
      "1784:   do_smart_update(sma, NULL, 0, 1, &tasks);",
      "1786:   wake_up_sem_queue_do(&tasks);",
      "1788:   kfree_rcu(un, rcu);",
      "",
      "[Removed Lines]",
      "1785:   sem_unlock(sma);",
      "",
      "[Added Lines]",
      "1856:   sem_unlock(sma, -1);",
      "",
      "---------------"
    ],
    "ipc/util.c||ipc/util.c": [
      "File: ipc/util.c -> ipc/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "443: {",
      "445:  if(size > PAGE_SIZE)",
      "446:   out = vmalloc(size);",
      "447:  else",
      "",
      "[Removed Lines]",
      "442: void* ipc_alloc(int size)",
      "444:  void* out;",
      "",
      "[Added Lines]",
      "442: void *ipc_alloc(int size)",
      "444:  void *out;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "479: struct ipc_rcu_hdr",
      "480: {",
      "482:  int is_vmalloc;",
      "483:  void *data[0];",
      "484: };",
      "",
      "[Removed Lines]",
      "481:  int refcount;",
      "",
      "[Added Lines]",
      "481:  atomic_t refcount;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "524: {",
      "530:  if (rcu_use_vmalloc(size)) {",
      "531:   out = vmalloc(HDRLEN_VMALLOC + size);",
      "537:  } else {",
      "538:   out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);",
      "544:  }",
      "546:  return out;",
      "547: }",
      "550: {",
      "552: }",
      "554: static void ipc_do_vfree(struct work_struct *work)",
      "",
      "[Removed Lines]",
      "523: void* ipc_rcu_alloc(int size)",
      "525:  void* out;",
      "532:   if (out) {",
      "533:    out += HDRLEN_VMALLOC;",
      "534:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "535:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "536:   }",
      "539:   if (out) {",
      "540:    out += HDRLEN_KMALLOC;",
      "541:    container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "542:    container_of(out, struct ipc_rcu_hdr, data)->refcount = 1;",
      "543:   }",
      "549: void ipc_rcu_getref(void *ptr)",
      "551:  container_of(ptr, struct ipc_rcu_hdr, data)->refcount++;",
      "",
      "[Added Lines]",
      "521: void *ipc_rcu_alloc(int size)",
      "523:  void *out;",
      "531:   if (!out)",
      "532:    goto done;",
      "534:   out += HDRLEN_VMALLOC;",
      "535:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
      "538:   if (!out)",
      "539:    goto done;",
      "541:   out += HDRLEN_KMALLOC;",
      "542:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
      "546:  atomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);",
      "547: done:",
      "551: int ipc_rcu_getref(void *ptr)",
      "553:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "579: void ipc_rcu_putref(void *ptr)",
      "580: {",
      "582:   return;",
      "584:  if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {",
      "",
      "[Removed Lines]",
      "581:  if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)",
      "",
      "[Added Lines]",
      "583:  if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))",
      "",
      "---------------"
    ],
    "ipc/util.h||ipc/util.h": [
      "File: ipc/util.h -> ipc/util.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "121: void* ipc_rcu_alloc(int size);",
      "123: void ipc_rcu_putref(void *ptr);",
      "125: struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);",
      "",
      "[Removed Lines]",
      "122: void ipc_rcu_getref(void *ptr);",
      "",
      "[Added Lines]",
      "122: int ipc_rcu_getref(void *ptr);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "600fe9751aeb6f6b72de84076a05c5b8c04152c0",
      "candidate_info": {
        "commit_hash": "600fe9751aeb6f6b72de84076a05c5b8c04152c0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/600fe9751aeb6f6b72de84076a05c5b8c04152c0",
        "files": [
          "ipc/util.c"
        ],
        "message": "ipc_schedule_free() can do vfree() directly now\n\nCommit 32fcfd40715e (\"make vfree() safe to call from interrupt\ncontexts\") made it safe to do vfree directly from the RCU callback,\nwhich allows us to simplify ipc/util.c a lot by getting rid of the\ndifferences between vmalloc/kmalloc memory.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/util.c||ipc/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/util.c||ipc/util.c"
          ],
          "candidate": [
            "ipc/util.c||ipc/util.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/util.c||ipc/util.c": [
          "File: ipc/util.c -> ipc/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:   kfree(ptr);",
          "467: }",
          "489:  struct rcu_head rcu;",
          "491:  void *data[0];",
          "492: };",
          "",
          "[Removed Lines]",
          "479: struct ipc_rcu_hdr",
          "480: {",
          "481:  atomic_t refcount;",
          "482:  int is_vmalloc;",
          "483:  void *data[0];",
          "484: };",
          "487: struct ipc_rcu_grace",
          "488: {",
          "494: struct ipc_rcu_sched",
          "495: {",
          "496:  struct work_struct work;",
          "498:  void *data[0];",
          "499: };",
          "501: #define HDRLEN_KMALLOC  (sizeof(struct ipc_rcu_grace) > sizeof(struct ipc_rcu_hdr) ? \\",
          "502:      sizeof(struct ipc_rcu_grace) : sizeof(struct ipc_rcu_hdr))",
          "503: #define HDRLEN_VMALLOC  (sizeof(struct ipc_rcu_sched) > HDRLEN_KMALLOC ? \\",
          "504:      sizeof(struct ipc_rcu_sched) : HDRLEN_KMALLOC)",
          "506: static inline int rcu_use_vmalloc(int size)",
          "507: {",
          "509:  if (HDRLEN_KMALLOC + size > PAGE_SIZE)",
          "510:   return 1;",
          "511:  return 0;",
          "512: }",
          "",
          "[Added Lines]",
          "469: struct ipc_rcu {",
          "471:  atomic_t refcount;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "521: void *ipc_rcu_alloc(int size)",
          "522: {",
          "549: }",
          "551: int ipc_rcu_getref(void *ptr)",
          "552: {",
          "559: }",
          "568: static void ipc_schedule_free(struct rcu_head *head)",
          "569: {",
          "579: }",
          "581: void ipc_rcu_putref(void *ptr)",
          "582: {",
          "584:   return;",
          "589:  } else {",
          "591:  }",
          "592: }",
          "",
          "[Removed Lines]",
          "523:  void *out;",
          "529:  if (rcu_use_vmalloc(size)) {",
          "530:   out = vmalloc(HDRLEN_VMALLOC + size);",
          "531:   if (!out)",
          "532:    goto done;",
          "534:   out += HDRLEN_VMALLOC;",
          "535:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;",
          "536:  } else {",
          "537:   out = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);",
          "538:   if (!out)",
          "539:    goto done;",
          "541:   out += HDRLEN_KMALLOC;",
          "542:   container_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;",
          "543:  }",
          "546:  atomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);",
          "547: done:",
          "548:  return out;",
          "553:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);",
          "554: }",
          "556: static void ipc_do_vfree(struct work_struct *work)",
          "557: {",
          "558:  vfree(container_of(work, struct ipc_rcu_sched, work));",
          "570:  struct ipc_rcu_grace *grace;",
          "571:  struct ipc_rcu_sched *sched;",
          "573:  grace = container_of(head, struct ipc_rcu_grace, rcu);",
          "574:  sched = container_of(&(grace->data[0]), struct ipc_rcu_sched,",
          "575:     data[0]);",
          "577:  INIT_WORK(&sched->work, ipc_do_vfree);",
          "578:  schedule_work(&sched->work);",
          "583:  if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))",
          "586:  if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {",
          "587:   call_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,",
          "588:     ipc_schedule_free);",
          "590:   kfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);",
          "",
          "[Added Lines]",
          "488:  struct ipc_rcu *out = ipc_alloc(sizeof(struct ipc_rcu) + size);",
          "489:  if (unlikely(!out))",
          "490:   return NULL;",
          "491:  atomic_set(&out->refcount, 1);",
          "492:  return out->data;",
          "497:  return atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu, data)->refcount);",
          "506:  vfree(container_of(head, struct ipc_rcu, rcu));",
          "511:  struct ipc_rcu *p = container_of(ptr, struct ipc_rcu, data);",
          "513:  if (!atomic_dec_and_test(&p->refcount))",
          "516:  if (is_vmalloc_addr(ptr)) {",
          "517:   call_rcu(&p->rcu, ipc_schedule_free);",
          "519:   kfree_rcu(p, rcu);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5e9d527591421ccdb16acb8c23662231135d8686",
      "candidate_info": {
        "commit_hash": "5e9d527591421ccdb16acb8c23662231135d8686",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5e9d527591421ccdb16acb8c23662231135d8686",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc/sem.c: fix race in sem_lock()\n\nThe exclusion of complex operations in sem_lock() is insufficient: after\nacquiring the per-semaphore lock, a simple op must first check that\nsem_perm.lock is not locked and only after that test check\ncomplex_count.  The current code does it the other way around - and that\ncreates a race.  Details are below.\n\nThe patch is a complete rewrite of sem_lock(), based in part on the code\nfrom Mike Galbraith.  It removes all gotos and all loops and thus the\nrisk of livelocks.\n\nI have tested the patch (together with the next one) on my i3 laptop and\nit didn't cause any problems.\n\nThe bug is probably also present in 3.10 and 3.11, but for these kernels\nit might be simpler just to move the test of sma->complex_count after\nthe spin_is_locked() test.\n\nDetails of the bug:\n\nAssume:\n - sma->complex_count = 0.\n - Thread 1: semtimedop(complex op that must sleep)\n - Thread 2: semtimedop(simple op).\n\nPseudo-Trace:\n\nThread 1: sem_lock(): acquire sem_perm.lock\nThread 1: sem_lock(): check for ongoing simple ops\n\t\t\tNothing ongoing, thread 2 is still before sem_lock().\nThread 1: try_atomic_semop()\n\t<<< preempted.\n\nThread 2: sem_lock():\n        static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n                                      int nsops)\n        {\n                int locknum;\n         again:\n                if (nsops == 1 && !sma->complex_count) {\n                        struct sem *sem = sma->sem_base + sops->sem_num;\n\n                        /* Lock just the semaphore we are interested in. */\n                        spin_lock(&sem->lock);\n\n                        /*\n                         * If sma->complex_count was set while we were spinning,\n                         * we may need to look at things we did not lock here.\n                         */\n                        if (unlikely(sma->complex_count)) {\n                                spin_unlock(&sem->lock);\n                                goto lock_array;\n                        }\n        <<<<<<<<<\n\t<<< complex_count is still 0.\n\t<<<\n        <<< Here it is preempted\n        <<<<<<<<<\n\nThread 1: try_atomic_semop() returns, notices that it must sleep.\nThread 1: increases sma->complex_count.\nThread 1: drops sem_perm.lock\nThread 2:\n                /*\n                 * Another process is holding the global lock on the\n                 * sem_array; we cannot enter our critical section,\n                 * but have to wait for the global lock to be released.\n                 */\n                if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n                        spin_unlock(&sem->lock);\n                        spin_unlock_wait(&sma->sem_perm.lock);\n                        goto again;\n                }\n\t<<< sem_perm.lock already dropped, thus no \"goto again;\"\n\n                locknum = sops->sem_num;\n\nSigned-off-by: Manfred Spraul <manfred@colorfullife.com>\nCc: Mike Galbraith <bitbucket@online.de>\nCc: Rik van Riel <riel@redhat.com>\nCc: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: <stable@vger.kernel.org>\t[3.10+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "252:  ipc_rcu_free(head);",
          "253: }",
          "271: static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,",
          "272:          int nsops)",
          "273: {",
          "300:   }",
          "303:  } else {",
          "318:  }",
          "320: }",
          "322: static inline void sem_unlock(struct sem_array *sma, int locknum)",
          "",
          "[Removed Lines]",
          "274:  int locknum;",
          "275:  again:",
          "276:  if (nsops == 1 && !sma->complex_count) {",
          "277:   struct sem *sem = sma->sem_base + sops->sem_num;",
          "280:   spin_lock(&sem->lock);",
          "286:   if (unlikely(sma->complex_count)) {",
          "287:    spin_unlock(&sem->lock);",
          "288:    goto lock_array;",
          "289:   }",
          "296:   if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {",
          "297:    spin_unlock(&sem->lock);",
          "298:    spin_unlock_wait(&sma->sem_perm.lock);",
          "299:    goto again;",
          "302:   locknum = sops->sem_num;",
          "304:   int i;",
          "311:  lock_array:",
          "312:   ipc_lock_object(&sma->sem_perm);",
          "313:   for (i = 0; i < sma->sem_nsems; i++) {",
          "314:    struct sem *sem = sma->sem_base + i;",
          "315:    spin_unlock_wait(&sem->lock);",
          "316:   }",
          "317:   locknum = -1;",
          "319:  return locknum;",
          "",
          "[Added Lines]",
          "261: static void sem_wait_array(struct sem_array *sma)",
          "262: {",
          "263:  int i;",
          "264:  struct sem *sem;",
          "266:  for (i = 0; i < sma->sem_nsems; i++) {",
          "267:   sem = sma->sem_base + i;",
          "268:   spin_unlock_wait(&sem->lock);",
          "269:  }",
          "270: }",
          "282:  struct sem *sem;",
          "284:  if (nsops != 1) {",
          "286:   ipc_lock_object(&sma->sem_perm);",
          "291:   sem_wait_array(sma);",
          "292:   return -1;",
          "293:  }",
          "310:  sem = sma->sem_base + sops->sem_num;",
          "312:  if (sma->complex_count == 0) {",
          "317:   spin_lock(&sem->lock);",
          "320:   if (!spin_is_locked(&sma->sem_perm.lock)) {",
          "322:    smp_mb();",
          "328:    if (sma->complex_count == 0) {",
          "330:     return sops->sem_num;",
          "331:    }",
          "333:   spin_unlock(&sem->lock);",
          "334:  }",
          "337:  ipc_lock_object(&sma->sem_perm);",
          "339:  if (sma->complex_count == 0) {",
          "344:   spin_lock(&sem->lock);",
          "345:   ipc_unlock_object(&sma->sem_perm);",
          "346:   return sops->sem_num;",
          "351:   sem_wait_array(sma);",
          "352:   return -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6d49dab8ae06c6d35a4d0967364a9ecbe8fdea2c",
      "candidate_info": {
        "commit_hash": "6d49dab8ae06c6d35a4d0967364a9ecbe8fdea2c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6d49dab8ae06c6d35a4d0967364a9ecbe8fdea2c",
        "files": [
          "ipc/sem.c"
        ],
        "message": "ipc: move rcu_read_unlock() out of sem_unlock() and into callers\n\nThe IPC locking is a mess, and sem_unlock() unlocks not only the\nsemaphore spinlock, it also drops the rcu read lock.  Unlike sem_lock(),\nwhich just gets the spin-lock, and expects the caller to get the rcu\nread lock.\n\nThis all makes things very hard to follow, and it's very confusing when\nyou take the rcu read lock in one function, and then release it in\nanother.  And it has caused actual bugs: the sem_obtain_lock() function\nended up dropping the RCU read lock twice in one error path, because it\nfirst did the sem_unlock(), and then did a rcu_read_unlock() to match\nthe rcu_read_lock() it had done.\n\nThis is just a totally mindless \"remove rcu_read_unlock() from\nsem_unlock() and add it immediately after each caller\" (except for the\naforementioned bug where we did too many rcu_read_unlock(), and in\nfind_alloc_undo() where we just got the rcu_read_lock() to correct for\nthe fact that sem_unlock would immediately drop it again).\n\nWe can (and should) clean things up further, but this fixes the bug with\nthe minimal amount of subtlety.\n\nReviewed-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "264:   struct sem *sem = sma->sem_base + locknum;",
          "265:   spin_unlock(&sem->lock);",
          "266:  }",
          "268: }",
          "",
          "[Removed Lines]",
          "267:  rcu_read_unlock();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "332: {",
          "333:  sem_lock_and_putref(sma);",
          "334:  sem_unlock(sma, -1);",
          "335: }",
          "337: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "435:  sma->sem_nsems = nsems;",
          "436:  sma->sem_ctime = get_seconds();",
          "437:  sem_unlock(sma, -1);",
          "439:  return sma->sem_perm.id;",
          "440: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "438:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "875:  sem_rmid(ns, sma);",
          "876:  sem_unlock(sma, -1);",
          "878:  wake_up_sem_queue_do(&tasks);",
          "879:  ns->used_sems -= sma->sem_nsems;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1056:  do_smart_update(sma, NULL, 0, 0, &tasks);",
          "1057:  sem_unlock(sma, -1);",
          "1058:  wake_up_sem_queue_do(&tasks);",
          "1059:  return 0;",
          "1060: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1060:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1104:   if(nsems > SEMMSL_FAST) {",
          "1105:    if (!ipc_rcu_getref(sma)) {",
          "1106:     sem_unlock(sma, -1);",
          "1107:     err = -EIDRM;",
          "1108:     goto out_free;",
          "1109:    }",
          "1110:    sem_unlock(sma, -1);",
          "1111:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "1112:    if(sem_io == NULL) {",
          "1113:     sem_putref(sma);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1110:     rcu_read_unlock();",
          "1115:    rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1117:    sem_lock_and_putref(sma);",
          "1118:    if (sma->sem_perm.deleted) {",
          "1119:     sem_unlock(sma, -1);",
          "1120:     err = -EIDRM;",
          "1121:     goto out_free;",
          "1122:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1125:     rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1124:   for (i = 0; i < sma->sem_nsems; i++)",
          "1125:    sem_io[i] = sma->sem_base[i].semval;",
          "1126:   sem_unlock(sma, -1);",
          "1127:   err = 0;",
          "1128:   if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))",
          "1129:    err = -EFAULT;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1133:   rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1164:   sem_lock_and_putref(sma);",
          "1165:   if (sma->sem_perm.deleted) {",
          "1166:    sem_unlock(sma, -1);",
          "1167:    err = -EIDRM;",
          "1168:    goto out_free;",
          "1169:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1174:    rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1211: out_unlock:",
          "1212:  sem_unlock(sma, -1);",
          "1213: out_wakeup:",
          "1214:  wake_up_sem_queue_do(&tasks);",
          "1215: out_free:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1221:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1296: out_unlock:",
          "1297:  sem_unlock(sma, -1);",
          "1298: out_up:",
          "1299:  up_write(&sem_ids(ns).rw_mutex);",
          "1300:  return err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1307:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1443:  }",
          "1446:  sem_lock_and_putref(sma);",
          "1447:  if (sma->sem_perm.deleted) {",
          "1448:   sem_unlock(sma, -1);",
          "1449:   kfree(new);",
          "1450:   un = ERR_PTR(-EIDRM);",
          "1451:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1460:   rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1473: success:",
          "1474:  spin_unlock(&ulp->lock);",
          "1476:  sem_unlock(sma, -1);",
          "1477: out:",
          "1478:  return un;",
          "",
          "[Removed Lines]",
          "1475:  rcu_read_lock();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1648: sleep_again:",
          "1649:  current->state = TASK_INTERRUPTIBLE;",
          "1650:  sem_unlock(sma, locknum);",
          "1652:  if (timeout)",
          "1653:   jiffies_left = schedule_timeout(jiffies_left);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1662:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1710: out_unlock_free:",
          "1711:  sem_unlock(sma, locknum);",
          "1712: out_wakeup:",
          "1713:  wake_up_sem_queue_do(&tasks);",
          "1714: out_free:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1724:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1803:    sem_unlock(sma, -1);",
          "1804:    continue;",
          "1805:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1817:    rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1841:   INIT_LIST_HEAD(&tasks);",
          "1842:   do_smart_update(sma, NULL, 0, 1, &tasks);",
          "1843:   sem_unlock(sma, -1);",
          "1844:   wake_up_sem_queue_do(&tasks);",
          "1846:   kfree_rcu(un, rcu);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1858:   rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "16df3674efe39f3ab63e7052f1244dd3d50e7f84",
      "candidate_info": {
        "commit_hash": "16df3674efe39f3ab63e7052f1244dd3d50e7f84",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/16df3674efe39f3ab63e7052f1244dd3d50e7f84",
        "files": [
          "ipc/sem.c",
          "ipc/util.h"
        ],
        "message": "ipc,sem: do not hold ipc lock more than necessary\n\nInstead of holding the ipc lock for permissions and security checks, among\nothers, only acquire it when necessary.\n\nSome numbers....\n\n1) With Rik's semop-multi.c microbenchmark we can see the following\n   results:\n\nBaseline (3.9-rc1):\ncpus 4, threads: 256, semaphores: 128, test duration: 30 secs\ntotal operations: 151452270, ops/sec 5048409\n\n+  59.40%            a.out  [kernel.kallsyms]  [k] _raw_spin_lock\n+   6.14%            a.out  [kernel.kallsyms]  [k] sys_semtimedop\n+   3.84%            a.out  [kernel.kallsyms]  [k] avc_has_perm_flags\n+   3.64%            a.out  [kernel.kallsyms]  [k] __audit_syscall_exit\n+   2.06%            a.out  [kernel.kallsyms]  [k] copy_user_enhanced_fast_string\n+   1.86%            a.out  [kernel.kallsyms]  [k] ipc_lock\n\nWith this patchset:\ncpus 4, threads: 256, semaphores: 128, test duration: 30 secs\ntotal operations: 273156400, ops/sec 9105213\n\n+  18.54%            a.out  [kernel.kallsyms]  [k] _raw_spin_lock\n+  11.72%            a.out  [kernel.kallsyms]  [k] sys_semtimedop\n+   7.70%            a.out  [kernel.kallsyms]  [k] ipc_has_perm.isra.21\n+   6.58%            a.out  [kernel.kallsyms]  [k] avc_has_perm_flags\n+   6.54%            a.out  [kernel.kallsyms]  [k] __audit_syscall_exit\n+   4.71%            a.out  [kernel.kallsyms]  [k] ipc_obtain_object_check\n\n2) While on an Oracle swingbench DSS (data mining) workload the\n   improvements are not as exciting as with Rik's benchmark, we can see\n   some positive numbers.  For an 8 socket machine the following are the\n   percentages of %sys time incurred in the ipc lock:\n\nBaseline (3.9-rc1):\n100 swingbench users: 8,74%\n400 swingbench users: 21,86%\n800 swingbench users: 84,35%\n\nWith this patchset:\n100 swingbench users: 8,11%\n400 swingbench users: 19,93%\n800 swingbench users: 77,69%\n\n[riel@redhat.com: fix two locking bugs]\n[sasha.levin@oracle.com: prevent releasing RCU read lock twice in semctl_main]\n[akpm@linux-foundation.org: coding-style fixes]\nSigned-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nSigned-off-by: Rik van Riel <riel@redhat.com>\nReviewed-by: Chegu Vinod <chegu_vinod@hp.com>\nAcked-by: Michel Lespinasse <walken@google.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Jason Low <jason.low2@hp.com>\nCc: Emmanuel Benisty <benisty.e@gmail.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/sem.c||ipc/sem.c",
          "ipc/util.h||ipc/util.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.h||ipc/util.h"
          ],
          "candidate": [
            "ipc/sem.c||ipc/sem.c",
            "ipc/util.h||ipc/util.h"
          ]
        }
      },
      "candidate_diff": {
        "ipc/sem.c||ipc/sem.c": [
          "File: ipc/sem.c -> ipc/sem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:  return container_of(ipcp, struct sem_array, sem_perm);",
          "205: }",
          "207: static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,",
          "208:       int id)",
          "209: {",
          "210:  struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);",
          "212:  if (IS_ERR(ipcp))",
          "215:  return container_of(ipcp, struct sem_array, sem_perm);",
          "216: }",
          "",
          "[Removed Lines]",
          "213:   return (struct sem_array *)ipcp;",
          "",
          "[Added Lines]",
          "207: static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int id)",
          "208: {",
          "209:  struct kern_ipc_perm *ipcp = ipc_obtain_object(&sem_ids(ns), id);",
          "211:  if (IS_ERR(ipcp))",
          "212:   return ERR_CAST(ipcp);",
          "214:  return container_of(ipcp, struct sem_array, sem_perm);",
          "215: }",
          "223:   return ERR_CAST(ipcp);",
          "225:  return container_of(ipcp, struct sem_array, sem_perm);",
          "226: }",
          "228: static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,",
          "229:        int id)",
          "230: {",
          "231:  struct kern_ipc_perm *ipcp = ipc_obtain_object_check(&sem_ids(ns), id);",
          "233:  if (IS_ERR(ipcp))",
          "234:   return ERR_CAST(ipcp);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234:  ipc_unlock(&(sma)->sem_perm);",
          "235: }",
          "237: static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)",
          "238: {",
          "239:  ipc_rmid(&sem_ids(ns), &s->sem_perm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261: static inline void sem_getref(struct sem_array *sma)",
          "262: {",
          "263:  spin_lock(&(sma)->sem_perm.lock);",
          "264:  ipc_rcu_getref(sma);",
          "265:  ipc_unlock(&(sma)->sem_perm);",
          "266: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "842:  case SEM_STAT:",
          "843:  {",
          "844:   struct semid64_ds tbuf;",
          "847:   if (cmd == SEM_STAT) {",
          "851:    id = sma->sem_perm.id;",
          "852:   } else {",
          "857:   }",
          "859:   err = -EACCES;",
          "",
          "[Removed Lines]",
          "845:   int id;",
          "848:    sma = sem_lock(ns, semid);",
          "849:    if (IS_ERR(sma))",
          "850:     return PTR_ERR(sma);",
          "853:    sma = sem_lock_check(ns, semid);",
          "854:    if (IS_ERR(sma))",
          "855:     return PTR_ERR(sma);",
          "856:    id = 0;",
          "",
          "[Added Lines]",
          "876:   int id = 0;",
          "878:   memset(&tbuf, 0, sizeof(tbuf));",
          "881:    rcu_read_lock();",
          "882:    sma = sem_obtain_object(ns, semid);",
          "883:    if (IS_ERR(sma)) {",
          "884:     err = PTR_ERR(sma);",
          "885:     goto out_unlock;",
          "886:    }",
          "889:    rcu_read_lock();",
          "890:    sma = sem_obtain_object_check(ns, semid);",
          "891:    if (IS_ERR(sma)) {",
          "892:     err = PTR_ERR(sma);",
          "893:     goto out_unlock;",
          "894:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "864:   if (err)",
          "865:    goto out_unlock;",
          "869:   kernel_to_ipc64_perm(&sma->sem_perm, &tbuf.sem_perm);",
          "870:   tbuf.sem_otime  = sma->sem_otime;",
          "871:   tbuf.sem_ctime  = sma->sem_ctime;",
          "872:   tbuf.sem_nsems  = sma->sem_nsems;",
          "874:   if (copy_semid_to_user(p, &tbuf, version))",
          "875:    return -EFAULT;",
          "876:   return id;",
          "",
          "[Removed Lines]",
          "867:   memset(&tbuf, 0, sizeof(tbuf));",
          "873:   sem_unlock(sma);",
          "",
          "[Added Lines]",
          "909:   rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "879:   return -EINVAL;",
          "880:  }",
          "881: out_unlock:",
          "883:  return err;",
          "884: }",
          "",
          "[Removed Lines]",
          "882:  sem_unlock(sma);",
          "",
          "[Added Lines]",
          "918:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "947: {",
          "948:  struct sem_array *sma;",
          "949:  struct sem* curr;",
          "951:  ushort fast_sem_io[SEMMSL_FAST];",
          "952:  ushort* sem_io = fast_sem_io;",
          "954:  struct list_head tasks;",
          "958:   return PTR_ERR(sma);",
          "961:  nsems = sma->sem_nsems;",
          "963:  err = -EACCES;",
          "964:  if (ipcperms(ns, &sma->sem_perm,",
          "968:  err = security_sem_semctl(sma, cmd);",
          "972:  err = -EACCES;",
          "973:  switch (cmd) {",
          "",
          "[Removed Lines]",
          "950:  int err;",
          "953:  int nsems;",
          "956:  sma = sem_lock_check(ns, semid);",
          "957:  if (IS_ERR(sma))",
          "960:  INIT_LIST_HEAD(&tasks);",
          "965:    cmd == SETALL ? S_IWUGO : S_IRUGO))",
          "966:   goto out_unlock;",
          "969:  if (err)",
          "970:   goto out_unlock;",
          "",
          "[Added Lines]",
          "986:  int err, nsems;",
          "991:  INIT_LIST_HEAD(&tasks);",
          "993:  rcu_read_lock();",
          "994:  sma = sem_obtain_object_check(ns, semid);",
          "995:  if (IS_ERR(sma)) {",
          "996:   rcu_read_unlock();",
          "998:  }",
          "1004:    cmd == SETALL ? S_IWUGO : S_IRUGO)) {",
          "1005:   rcu_read_unlock();",
          "1006:   goto out_wakeup;",
          "1007:  }",
          "1010:  if (err) {",
          "1011:   rcu_read_unlock();",
          "1012:   goto out_wakeup;",
          "1013:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "977:   int i;",
          "979:   if(nsems > SEMMSL_FAST) {",
          "982:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "983:    if(sem_io == NULL) {",
          "",
          "[Removed Lines]",
          "980:    sem_getref_and_unlock(sma);",
          "",
          "[Added Lines]",
          "1023:    sem_getref(sma);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "993:    }",
          "994:   }",
          "996:   for (i = 0; i < sma->sem_nsems; i++)",
          "997:    sem_io[i] = sma->sem_base[i].semval;",
          "998:   sem_unlock(sma);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1039:   spin_lock(&sma->sem_perm.lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1006:   int i;",
          "1007:   struct sem_undo *un;",
          "1011:   if(nsems > SEMMSL_FAST) {",
          "1012:    sem_io = ipc_alloc(sizeof(ushort)*nsems);",
          "",
          "[Removed Lines]",
          "1009:   sem_getref_and_unlock(sma);",
          "",
          "[Added Lines]",
          "1053:   ipc_rcu_getref(sma);",
          "1054:   rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1054:  }",
          "1055:  err = -EINVAL;",
          "1059:  curr = &sma->sem_base[semnum];",
          "1061:  switch (cmd) {",
          "",
          "[Removed Lines]",
          "1056:  if(semnum < 0 || semnum >= nsems)",
          "1057:   goto out_unlock;",
          "",
          "[Added Lines]",
          "1101:  if (semnum < 0 || semnum >= nsems) {",
          "1102:   rcu_read_unlock();",
          "1103:   goto out_wakeup;",
          "1104:  }",
          "1106:  spin_lock(&sma->sem_perm.lock);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1072:   err = count_semzcnt(sma,semnum);",
          "1073:   goto out_unlock;",
          "1074:  }",
          "1075: out_unlock:",
          "1076:  sem_unlock(sma);",
          "1077:  wake_up_sem_queue_do(&tasks);",
          "1079: out_free:",
          "1080:  if(sem_io != fast_sem_io)",
          "1081:   ipc_free(sem_io, sizeof(ushort)*nsems);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1126: out_wakeup:",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1126:    return -EFAULT;",
          "1127:  }",
          "1131:  if (IS_ERR(ipcp))",
          "1132:   return PTR_ERR(ipcp);",
          "1134:  sma = container_of(ipcp, struct sem_array, sem_perm);",
          "1136:  err = security_sem_semctl(sma, cmd);",
          "1138:   goto out_unlock;",
          "1140:  switch(cmd){",
          "1141:  case IPC_RMID:",
          "1142:   freeary(ns, ipcp);",
          "1143:   goto out_up;",
          "1144:  case IPC_SET:",
          "1145:   err = ipc_update_perm(&semid64.sem_perm, ipcp);",
          "1146:   if (err)",
          "1147:    goto out_unlock;",
          "1148:   sma->sem_ctime = get_seconds();",
          "1149:   break;",
          "1150:  default:",
          "1151:   err = -EINVAL;",
          "1152:  }",
          "1154: out_unlock:",
          "",
          "[Removed Lines]",
          "1129:  ipcp = ipcctl_pre_down(ns, &sem_ids(ns), semid, cmd,",
          "1130:           &semid64.sem_perm, 0);",
          "1137:  if (err)",
          "",
          "[Added Lines]",
          "1178:  ipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,",
          "1179:           &semid64.sem_perm, 0);",
          "1186:  if (err) {",
          "1187:   rcu_read_unlock();",
          "1189:  }",
          "1193:   ipc_lock_object(&sma->sem_perm);",
          "1197:   ipc_lock_object(&sma->sem_perm);",
          "1204:   rcu_read_unlock();",
          "1206:   goto out_up;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1277:  spin_unlock(&ulp->lock);",
          "1278:  if (likely(un!=NULL))",
          "1279:   goto out;",
          "1286:   return ERR_CAST(sma);",
          "1288:  nsems = sma->sem_nsems;",
          "1292:  new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "1280:  rcu_read_unlock();",
          "1284:  sma = sem_lock_check(ns, semid);",
          "1285:  if (IS_ERR(sma))",
          "1289:  sem_getref_and_unlock(sma);",
          "",
          "[Added Lines]",
          "1338:  sma = sem_obtain_object_check(ns, semid);",
          "1339:  if (IS_ERR(sma)) {",
          "1340:   rcu_read_unlock();",
          "1342:  }",
          "1345:  ipc_rcu_getref(sma);",
          "1346:  rcu_read_unlock();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1422:  INIT_LIST_HEAD(&tasks);",
          "1425:  if (IS_ERR(sma)) {",
          "1426:   if (un)",
          "1427:    rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "1424:  sma = sem_lock_check(ns, semid);",
          "",
          "[Added Lines]",
          "1481:  rcu_read_lock();",
          "1482:  sma = sem_obtain_object_check(ns, semid);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1429:   goto out_free;",
          "1430:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1490:  error = -EFBIG;",
          "1491:  if (max >= sma->sem_nsems) {",
          "1492:   rcu_read_unlock();",
          "1493:   goto out_wakeup;",
          "1494:  }",
          "1496:  error = -EACCES;",
          "1497:  if (ipcperms(ns, &sma->sem_perm, alter ? S_IWUGO : S_IRUGO)) {",
          "1498:   rcu_read_unlock();",
          "1499:   goto out_wakeup;",
          "1500:  }",
          "1502:  error = security_sem_semop(sma, sops, nsops, alter);",
          "1503:  if (error) {",
          "1504:   rcu_read_unlock();",
          "1505:   goto out_wakeup;",
          "1506:  }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1439:  error = -EIDRM;",
          "1440:  if (un) {",
          "1441:   if (un->semid == -1) {",
          "1442:    rcu_read_unlock();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1516:  ipc_lock_object(&sma->sem_perm);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1454:   }",
          "1455:  }",
          "1469:  error = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));",
          "1470:  if (error <= 0) {",
          "1471:   if (alter && error == 0)",
          "",
          "[Removed Lines]",
          "1457:  error = -EFBIG;",
          "1458:  if (max >= sma->sem_nsems)",
          "1459:   goto out_unlock_free;",
          "1461:  error = -EACCES;",
          "1462:  if (ipcperms(ns, &sma->sem_perm, alter ? S_IWUGO : S_IRUGO))",
          "1463:   goto out_unlock_free;",
          "1465:  error = security_sem_semop(sma, sops, nsops, alter);",
          "1466:  if (error)",
          "1467:   goto out_unlock_free;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1569: out_unlock_free:",
          "1570:  sem_unlock(sma);",
          "1572:  wake_up_sem_queue_do(&tasks);",
          "1573: out_free:",
          "1574:  if(sops != fast_sops)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1636: out_wakeup:",
          "",
          "---------------"
        ],
        "ipc/util.h||ipc/util.h": [
          "File: ipc/util.h -> ipc/util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:  rcu_read_unlock();",
          "172: }",
          "174: struct kern_ipc_perm *ipc_lock_check(struct ipc_ids *ids, int id);",
          "175: struct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);",
          "176: int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174: static inline void ipc_lock_object(struct kern_ipc_perm *perm)",
          "175: {",
          "176:  spin_lock(&perm->lock);",
          "177: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3dd1f784ed6603d7ab1043e51e6371235edf2313",
      "candidate_info": {
        "commit_hash": "3dd1f784ed6603d7ab1043e51e6371235edf2313",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3dd1f784ed6603d7ab1043e51e6371235edf2313",
        "files": [
          "ipc/msg.c"
        ],
        "message": "ipc,msg: shorten critical region in msgsnd\n\ndo_msgsnd() is another function that does too many things with the ipc\nobject lock acquired.  Take it only when needed when actually updating\nmsq.\n\nSigned-off-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Andi Kleen <andi@firstfloor.org>\nCc: Rik van Riel <riel@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "ipc/msg.c||ipc/msg.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ipc/msg.c||ipc/msg.c"
          ],
          "candidate": [
            "ipc/msg.c||ipc/msg.c"
          ]
        }
      },
      "candidate_diff": {
        "ipc/msg.c||ipc/msg.c": [
          "File: ipc/msg.c -> ipc/msg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:  msg->m_type = mtype;",
          "699:  msg->m_ts = msgsz;",
          "702:  if (IS_ERR(msq)) {",
          "703:   err = PTR_ERR(msq);",
          "705:  }",
          "707:  for (;;) {",
          "",
          "[Removed Lines]",
          "701:  msq = msg_lock_check(ns, msqid);",
          "704:   goto out_free;",
          "",
          "[Added Lines]",
          "701:  rcu_read_lock();",
          "702:  msq = msq_obtain_object_check(ns, msqid);",
          "705:   goto out_unlock1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "710:   err = -EACCES;",
          "711:   if (ipcperms(ns, &msq->q_perm, S_IWUGO))",
          "714:   err = security_msg_queue_msgsnd(msq, msg, msgflg);",
          "715:   if (err)",
          "718:   if (msgsz + msq->q_cbytes <= msq->q_qbytes &&",
          "719:     1 + msq->q_qnum <= msq->q_qbytes) {",
          "",
          "[Removed Lines]",
          "712:    goto out_unlock_free;",
          "716:    goto out_unlock_free;",
          "",
          "[Added Lines]",
          "713:    goto out_unlock1;",
          "717:    goto out_unlock1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "724:   if (msgflg & IPC_NOWAIT) {",
          "725:    err = -EAGAIN;",
          "727:   }",
          "728:   ss_add(msq, &s);",
          "730:   if (!ipc_rcu_getref(msq)) {",
          "731:    err = -EIDRM;",
          "733:   }",
          "736:   schedule();",
          "739:   ipc_rcu_putref(msq);",
          "740:   if (msq->q_perm.deleted) {",
          "741:    err = -EIDRM;",
          "743:   }",
          "744:   ss_del(&s);",
          "746:   if (signal_pending(current)) {",
          "747:    err = -ERESTARTNOHAND;",
          "749:   }",
          "750:  }",
          "752:  msq->q_lspid = task_tgid_vnr(current);",
          "753:  msq->q_stime = get_seconds();",
          "",
          "[Removed Lines]",
          "726:    goto out_unlock_free;",
          "732:    goto out_unlock_free;",
          "735:   msg_unlock(msq);",
          "738:   ipc_lock_by_ptr(&msq->q_perm);",
          "742:    goto out_unlock_free;",
          "748:    goto out_unlock_free;",
          "",
          "[Added Lines]",
          "727:    goto out_unlock1;",
          "730:   ipc_lock_object(&msq->q_perm);",
          "735:    goto out_unlock0;",
          "738:   ipc_unlock_object(&msq->q_perm);",
          "739:   rcu_read_unlock();",
          "742:   rcu_read_lock();",
          "743:   ipc_lock_object(&msq->q_perm);",
          "748:    goto out_unlock0;",
          "755:    goto out_unlock0;",
          "758:   ipc_unlock_object(&msq->q_perm);",
          "761:  ipc_lock_object(&msq->q_perm);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "764:  err = 0;",
          "765:  msg = NULL;",
          "770:  if (msg != NULL)",
          "771:   free_msg(msg);",
          "772:  return err;",
          "",
          "[Removed Lines]",
          "767: out_unlock_free:",
          "768:  msg_unlock(msq);",
          "769: out_free:",
          "",
          "[Added Lines]",
          "777: out_unlock0:",
          "778:  ipc_unlock_object(&msq->q_perm);",
          "779: out_unlock1:",
          "780:  rcu_read_unlock();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
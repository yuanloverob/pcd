{
  "cve_id": "CVE-2016-7425",
  "cve_desc": "The arcmsr_iop_message_xfer function in drivers/scsi/arcmsr/arcmsr_hba.c in the Linux kernel through 4.8.2 does not restrict a certain length field, which allows local users to gain privileges or cause a denial of service (heap-based buffer overflow) via an ARCMSR_MESSAGE_WRITE_WQBUFFER control code.",
  "repo": "torvalds/linux",
  "patch_hash": "7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
  "patch_info": {
    "commit_hash": "7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
    "files": [
      "drivers/scsi/arcmsr/arcmsr_hba.c"
    ],
    "message": "scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()\n\nWe need to put an upper bound on \"user_len\" so the memcpy() doesn't\noverflow.\n\nCc: <stable@vger.kernel.org>\nReported-by: Marco Grassi <marco.gra@gmail.com>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Tomas Henzl <thenzl@redhat.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "before_after_code_files": [
      "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c"
    ]
  },
  "patch_diff": {
    "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c": [
      "File: drivers/scsi/arcmsr/arcmsr_hba.c -> drivers/scsi/arcmsr/arcmsr_hba.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2388:  }",
      "2389:  case ARCMSR_MESSAGE_WRITE_WQBUFFER: {",
      "2390:   unsigned char *ver_addr;",
      "2392:   uint8_t *pQbuffer, *ptmpuserbuffer;",
      "2393:   ver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);",
      "2394:   if (!ver_addr) {",
      "",
      "[Removed Lines]",
      "2391:   int32_t user_len, cnt2end;",
      "",
      "[Added Lines]",
      "2391:   uint32_t user_len;",
      "2392:   int32_t cnt2end;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2397:   }",
      "2398:   ptmpuserbuffer = ver_addr;",
      "2399:   user_len = pcmdmessagefld->cmdmessage.Length;",
      "2400:   memcpy(ptmpuserbuffer,",
      "2401:    pcmdmessagefld->messagedatabuffer, user_len);",
      "2402:   spin_lock_irqsave(&acb->wqbuffer_lock, flags);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2401:   if (user_len > ARCMSR_API_DATA_BUFLEN) {",
      "2402:    retvalue = ARCMSR_MESSAGE_FAIL;",
      "2403:    kfree(ver_addr);",
      "2404:    goto message_out;",
      "2405:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4bd173c30792791a6daca8c64793ec0a4ae8324f",
      "candidate_info": {
        "commit_hash": "4bd173c30792791a6daca8c64793ec0a4ae8324f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4bd173c30792791a6daca8c64793ec0a4ae8324f",
        "files": [
          "drivers/scsi/arcmsr/arcmsr_hba.c"
        ],
        "message": "scsi: arcmsr: Simplify user_len checking\n\nDo the user_len check first and then the ver_addr allocation so that we\ncan save us the kfree() on the error path when user_len is >\nARCMSR_API_DATA_BUFLEN.\n\nSigned-off-by: Borislav Petkov <bp@suse.de>\nCc: Marco Grassi <marco.gra@gmail.com>\nCc: Dan Carpenter <dan.carpenter@oracle.com>\nCc: Tomas Henzl <thenzl@redhat.com>\nCc: Martin K. Petersen <martin.petersen@oracle.com>\nCc: <stable@vger.kernel.org>\nReviewed-by: Johannes Thumshirn <jthumshirn@suse.de>\nReviewed-by: Tomas Henzl <thenzl@redhat.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c"
          ],
          "candidate": [
            "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/scsi/arcmsr/arcmsr_hba.c||drivers/scsi/arcmsr/arcmsr_hba.c": [
          "File: drivers/scsi/arcmsr/arcmsr_hba.c -> drivers/scsi/arcmsr/arcmsr_hba.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2391:   uint32_t user_len;",
          "2392:   int32_t cnt2end;",
          "2393:   uint8_t *pQbuffer, *ptmpuserbuffer;",
          "2396:    retvalue = ARCMSR_MESSAGE_FAIL;",
          "2397:    goto message_out;",
          "2398:   }",
          "2402:    retvalue = ARCMSR_MESSAGE_FAIL;",
          "2404:    goto message_out;",
          "2405:   }",
          "2406:   memcpy(ptmpuserbuffer,",
          "2407:    pcmdmessagefld->messagedatabuffer, user_len);",
          "2408:   spin_lock_irqsave(&acb->wqbuffer_lock, flags);",
          "",
          "[Removed Lines]",
          "2394:   ver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);",
          "2395:   if (!ver_addr) {",
          "2399:   ptmpuserbuffer = ver_addr;",
          "2400:   user_len = pcmdmessagefld->cmdmessage.Length;",
          "2401:   if (user_len > ARCMSR_API_DATA_BUFLEN) {",
          "2403:    kfree(ver_addr);",
          "",
          "[Added Lines]",
          "2395:   user_len = pcmdmessagefld->cmdmessage.Length;",
          "2396:   if (user_len > ARCMSR_API_DATA_BUFLEN) {",
          "2401:   ver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);",
          "2402:   if (!ver_addr) {",
          "2406:   ptmpuserbuffer = ver_addr;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
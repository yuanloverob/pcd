{
  "cve_id": "CVE-2016-4581",
  "cve_desc": "fs/pnode.c in the Linux kernel before 4.5.4 does not properly traverse a mount propagation tree in a certain case involving a slave mount, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted series of mount system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
  "patch_info": {
    "commit_hash": "5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5ec0811d30378ae104f250bfc9b3640242d81e3f",
    "files": [
      "fs/pnode.c"
    ],
    "message": "propogate_mnt: Handle the first propogated copy being a slave\n\nWhen the first propgated copy was a slave the following oops would result:\n> BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n> IP: [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> PGD bacd4067 PUD bac66067 PMD 0\n> Oops: 0000 [#1] SMP\n> Modules linked in:\n> CPU: 1 PID: 824 Comm: mount Not tainted 4.6.0-rc5userns+ #1523\n> Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007\n> task: ffff8800bb0a8000 ti: ffff8800bac3c000 task.ti: ffff8800bac3c000\n> RIP: 0010:[<ffffffff811fba4e>]  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> RSP: 0018:ffff8800bac3fd38  EFLAGS: 00010283\n> RAX: 0000000000000000 RBX: ffff8800bb77ec00 RCX: 0000000000000010\n> RDX: 0000000000000000 RSI: ffff8800bb58c000 RDI: ffff8800bb58c480\n> RBP: ffff8800bac3fd48 R08: 0000000000000001 R09: 0000000000000000\n> R10: 0000000000001ca1 R11: 0000000000001c9d R12: 0000000000000000\n> R13: ffff8800ba713800 R14: ffff8800bac3fda0 R15: ffff8800bb77ec00\n> FS:  00007f3c0cd9b7e0(0000) GS:ffff8800bfb00000(0000) knlGS:0000000000000000\n> CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n> CR2: 0000000000000010 CR3: 00000000bb79d000 CR4: 00000000000006e0\n> Stack:\n>  ffff8800bb77ec00 0000000000000000 ffff8800bac3fd88 ffffffff811fbf85\n>  ffff8800bac3fd98 ffff8800bb77f080 ffff8800ba713800 ffff8800bb262b40\n>  0000000000000000 0000000000000000 ffff8800bac3fdd8 ffffffff811f1da0\n> Call Trace:\n>  [<ffffffff811fbf85>] propagate_mnt+0x105/0x140\n>  [<ffffffff811f1da0>] attach_recursive_mnt+0x120/0x1e0\n>  [<ffffffff811f1ec3>] graft_tree+0x63/0x70\n>  [<ffffffff811f1f6b>] do_add_mount+0x9b/0x100\n>  [<ffffffff811f2c1a>] do_mount+0x2aa/0xdf0\n>  [<ffffffff8117efbe>] ? strndup_user+0x4e/0x70\n>  [<ffffffff811f3a45>] SyS_mount+0x75/0xc0\n>  [<ffffffff8100242b>] do_syscall_64+0x4b/0xa0\n>  [<ffffffff81988f3c>] entry_SYSCALL64_slow_path+0x25/0x25\n> Code: 00 00 75 ec 48 89 0d 02 22 22 01 8b 89 10 01 00 00 48 89 05 fd 21 22 01 39 8e 10 01 00 00 0f 84 e0 00 00 00 48 8b 80 d8 00 00 00 <48> 8b 50 10 48 89 05 df 21 22 01 48 89 15 d0 21 22 01 8b 53 30\n> RIP  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n>  RSP <ffff8800bac3fd38>\n> CR2: 0000000000000010\n> ---[ end trace 2725ecd95164f217 ]---\n\nThis oops happens with the namespace_sem held and can be triggered by\nnon-root users.  An all around not pleasant experience.\n\nTo avoid this scenario when finding the appropriate source mount to\ncopy stop the walk up the mnt_master chain when the first source mount\nis encountered.\n\nFurther rewrite the walk up the last_source mnt_master chain so that\nit is clear what is going on.\n\nThe reason why the first source mount is special is that it it's\nmnt_parent is not a mount in the dest_mnt propagation tree, and as\nsuch termination conditions based up on the dest_mnt mount propgation\ntree do not make sense.\n\nTo avoid other kinds of confusion last_dest is not changed when\ncomputing last_source.  last_dest is only used once in propagate_one\nand that is above the point of the code being modified, so changing\nthe global variable is meaningless and confusing.\n\nCc: stable@vger.kernel.org\nfixes: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68 (\"smarter propagate_mnt()\")\nReported-by: Tycho Andersen <tycho.andersen@canonical.com>\nReviewed-by: Seth Forshee <seth.forshee@canonical.com>\nTested-by: Seth Forshee <seth.forshee@canonical.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "fs/pnode.c||fs/pnode.c"
    ]
  },
  "patch_diff": {
    "fs/pnode.c||fs/pnode.c": [
      "File: fs/pnode.c -> fs/pnode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "200: static struct user_namespace *user_ns;",
      "202: static struct mountpoint *mp;",
      "203: static struct hlist_head *list;",
      "",
      "[Removed Lines]",
      "201: static struct mount *last_dest, *last_source, *dest_master;",
      "",
      "[Added Lines]",
      "201: static struct mount *last_dest, *first_source, *last_source, *dest_master;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "221:   type = CL_MAKE_SHARED;",
      "222:  } else {",
      "223:   struct mount *n, *p;",
      "224:   for (n = m; ; n = p) {",
      "225:    p = n->mnt_master;",
      "235:     break;",
      "237:   }",
      "238:   type = CL_SLAVE;",
      "240:   if (IS_MNT_SHARED(m))",
      "",
      "[Removed Lines]",
      "226:    if (p == dest_master || IS_MNT_MARKED(p)) {",
      "227:     while (last_dest->mnt_master != p) {",
      "228:      last_source = last_source->mnt_master;",
      "229:      last_dest = last_source->mnt_parent;",
      "230:     }",
      "231:     if (!peers(n, last_dest)) {",
      "232:      last_source = last_source->mnt_master;",
      "233:      last_dest = last_source->mnt_parent;",
      "234:     }",
      "236:    }",
      "",
      "[Added Lines]",
      "224:   bool done;",
      "227:    if (p == dest_master || IS_MNT_MARKED(p))",
      "230:   do {",
      "231:    struct mount *parent = last_source->mnt_parent;",
      "232:    if (last_source == first_source)",
      "233:     break;",
      "234:    done = parent->mnt_master == p;",
      "235:    if (done && peers(n, parent))",
      "236:     break;",
      "237:    last_source = last_source->mnt_master;",
      "238:   } while (!done);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "287:  user_ns = current->nsproxy->mnt_ns->user_ns;",
      "288:  last_dest = dest_mnt;",
      "289:  last_source = source_mnt;",
      "290:  mp = dest_mp;",
      "291:  list = tree_list;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  first_source = source_mnt;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6ae645d5fa385f3787bf1723639cd907fe5865e7",
      "candidate_info": {
        "commit_hash": "6ae645d5fa385f3787bf1723639cd907fe5865e7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6ae645d5fa385f3787bf1723639cd907fe5865e7",
        "files": [
          "drivers/input/misc/max8997_haptic.c"
        ],
        "message": "Input: max8997-haptic - fix NULL pointer dereference\n\nNULL pointer derefence happens when booting with DTB because the\nplatform data for haptic device is not set in supplied data from parent\nMFD device.\n\nThe MFD device creates only platform data (from Device Tree) for itself,\nnot for haptic child.\n\nUnable to handle kernel NULL pointer dereference at virtual address 0000009c\npgd = c0004000\n\t[0000009c] *pgd=00000000\n\tInternal error: Oops: 5 [#1] PREEMPT SMP ARM\n\t(max8997_haptic_probe) from [<c03f9cec>] (platform_drv_probe+0x4c/0xb0)\n\t(platform_drv_probe) from [<c03f8440>] (driver_probe_device+0x214/0x2c0)\n\t(driver_probe_device) from [<c03f8598>] (__driver_attach+0xac/0xb0)\n\t(__driver_attach) from [<c03f67ac>] (bus_for_each_dev+0x68/0x9c)\n\t(bus_for_each_dev) from [<c03f7a38>] (bus_add_driver+0x1a0/0x218)\n\t(bus_add_driver) from [<c03f8db0>] (driver_register+0x78/0xf8)\n\t(driver_register) from [<c0101774>] (do_one_initcall+0x90/0x1d8)\n\t(do_one_initcall) from [<c0a00dbc>] (kernel_init_freeable+0x15c/0x1fc)\n\t(kernel_init_freeable) from [<c06bb5b4>] (kernel_init+0x8/0x114)\n\t(kernel_init) from [<c0107938>] (ret_from_fork+0x14/0x3c)\n\nSigned-off-by: Marek Szyprowski <m.szyprowski@samsung.com>\nCc: <stable@vger.kernel.org>\nFixes: 104594b01ce7 (\"Input: add driver support for MAX8997-haptic\")\n[k.kozlowski: Write commit message, add CC-stable]\nSigned-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
        "before_after_code_files": [
          "drivers/input/misc/max8997_haptic.c||drivers/input/misc/max8997_haptic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/input/misc/max8997_haptic.c||drivers/input/misc/max8997_haptic.c": [
          "File: drivers/input/misc/max8997_haptic.c -> drivers/input/misc/max8997_haptic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "255:  struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);",
          "256:  const struct max8997_platform_data *pdata =",
          "257:      dev_get_platdata(iodev->dev);",
          "260:  struct max8997_haptic *chip;",
          "261:  struct input_dev *input_dev;",
          "262:  int error;",
          "264:  if (!haptic_pdata) {",
          "265:   dev_err(&pdev->dev, \"no haptic platform data\\n\");",
          "266:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "258:  const struct max8997_haptic_platform_data *haptic_pdata =",
          "259:      pdata->haptic_pdata;",
          "",
          "[Added Lines]",
          "258:  const struct max8997_haptic_platform_data *haptic_pdata = NULL;",
          "263:  if (pdata)",
          "264:   haptic_pdata = pdata->haptic_pdata;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "635f6b0893cff193a1774881ebb1e4a4b9a7fead",
      "candidate_info": {
        "commit_hash": "635f6b0893cff193a1774881ebb1e4a4b9a7fead",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/635f6b0893cff193a1774881ebb1e4a4b9a7fead",
        "files": [
          "drivers/scsi/cxlflash/superpipe.c"
        ],
        "message": "cxlflash: Fix to resolve dead-lock during EEH recovery\n\nWhen a cxlflash adapter goes into EEH recovery and multiple processes\n(each having established its own context) are active, the EEH recovery\ncan hang if the processes attempt to recover in parallel. The symptom\nlogged after a couple of minutes is:\n\nINFO: task eehd:48 blocked for more than 120 seconds.\nNot tainted 4.5.0-491-26f710d+ #1\n\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\neehd            0    48      2\nCall Trace:\n__switch_to+0x2f0/0x410\n__schedule+0x300/0x980\nschedule+0x48/0xc0\nrwsem_down_write_failed+0x294/0x410\ndown_write+0x88/0xb0\ncxlflash_pci_error_detected+0x100/0x1c0 [cxlflash]\ncxl_vphb_error_detected+0x88/0x110 [cxl]\ncxl_pci_error_detected+0xb0/0x1d0 [cxl]\neeh_report_error+0xbc/0x130\neeh_pe_dev_traverse+0x94/0x160\neeh_handle_normal_event+0x17c/0x450\neeh_handle_event+0x184/0x370\neeh_event_handler+0x1c8/0x1d0\nkthread+0x110/0x130\nret_from_kernel_thread+0x5c/0xa4\nINFO: task blockio:33215 blocked for more than 120 seconds.\n\nNot tainted 4.5.0-491-26f710d+ #1\n\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\nblockio         0 33215  33213\nCall Trace:\n0x1 (unreliable)\n__switch_to+0x2f0/0x410\n__schedule+0x300/0x980\nschedule+0x48/0xc0\nrwsem_down_read_failed+0x124/0x1d0\ndown_read+0x68/0x80\ncxlflash_ioctl+0x70/0x6f0 [cxlflash]\nscsi_ioctl+0x3b0/0x4c0\nsg_ioctl+0x960/0x1010\ndo_vfs_ioctl+0xd8/0x8c0\nSyS_ioctl+0xd4/0xf0\nsystem_call+0x38/0xb4\nINFO: task eehd:48 blocked for more than 120 seconds.\n\nThe hang is because of a 3 way dead-lock:\n\nProcess A holds the recovery mutex, and waits for eehd to complete.\nProcess B holds the semaphore and waits for the recovery mutex.\neehd waits for semaphore.\n\nThe fix is to have Process B above release the semaphore before\nattempting to acquire the recovery mutex. This will allow\neehd to proceed to completion.\n\nSigned-off-by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>\nReviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/cxlflash/superpipe.c||drivers/scsi/cxlflash/superpipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/cxlflash/superpipe.c||drivers/scsi/cxlflash/superpipe.c": [
          "File: drivers/scsi/cxlflash/superpipe.c -> drivers/scsi/cxlflash/superpipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1642:  int rc = 0;",
          "1644:  atomic_inc(&cfg->recovery_threads);",
          "1645:  rc = mutex_lock_interruptible(mutex);",
          "1646:  if (rc)",
          "1647:   goto out;",
          "1649:  dev_dbg(dev, \"%s: reason 0x%016llX rctxid=%016llX\\n\",",
          "1650:   __func__, recover->reason, rctxid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1652:  up_read(&cfg->ioctl_rwsem);",
          "1654:  down_read(&cfg->ioctl_rwsem);",
          "1657:  rc = check_state(cfg);",
          "1658:  if (rc) {",
          "1659:   dev_err(dev, \"%s: Failed state! rc=%d\\n\", __func__, rc);",
          "1660:   rc = -ENODEV;",
          "1661:   goto out;",
          "1662:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7ae8fd0351f912b075149a1e03a017be8b903b9a",
      "candidate_info": {
        "commit_hash": "7ae8fd0351f912b075149a1e03a017be8b903b9a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7ae8fd0351f912b075149a1e03a017be8b903b9a",
        "files": [
          "fs/pnode.c"
        ],
        "message": "fs/pnode.c: treat zero mnt_group_id-s as unequal\n\npropagate_one(m) calculates \"type\" argument for copy_tree() like this:\n\n>    if (m->mnt_group_id == last_dest->mnt_group_id) {\n>        type = CL_MAKE_SHARED;\n>    } else {\n>        type = CL_SLAVE;\n>        if (IS_MNT_SHARED(m))\n>           type |= CL_MAKE_SHARED;\n>   }\n\nThe \"type\" argument then governs clone_mnt() behavior with respect to flags\nand mnt_master of new mount. When we iterate through a slave group, it is\npossible that both current \"m\" and \"last_dest\" are not shared (although,\nboth are slaves, i.e. have non-NULL mnt_master-s). Then the comparison\nabove erroneously makes new mount shared and sets its mnt_master to\nlast_source->mnt_master. The patch fixes the problem by handling zero\nmnt_group_id-s as though they are unequal.\n\nThe similar problem exists in the implementation of \"else\" clause above\nwhen we have to ascend upward in the master/slave tree by calling:\n\n>    last_source = last_source->mnt_master;\n>    last_dest = last_source->mnt_parent;\n\nproper number of times. The last step is governed by\n\"n->mnt_group_id != last_dest->mnt_group_id\" condition that may lie if\nboth are zero. The patch fixes this case in the same way as the former one.\n\n[AV: don't open-code an obvious helper...]\n\nSigned-off-by: Maxim Patlasov <mpatlasov@virtuozzo.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/pnode.c||fs/pnode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pnode.c||fs/pnode.c"
          ],
          "candidate": [
            "fs/pnode.c||fs/pnode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pnode.c||fs/pnode.c": [
          "File: fs/pnode.c -> fs/pnode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: static struct mountpoint *mp;",
          "203: static struct hlist_head *list;",
          "205: static int propagate_one(struct mount *m)",
          "206: {",
          "207:  struct mount *child;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "205: static inline bool peers(struct mount *m1, struct mount *m2)",
          "206: {",
          "207:  return m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;",
          "208: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  if (!is_subdir(mp->m_dentry, m->mnt.mnt_root))",
          "214:   return 0;",
          "216:   type = CL_MAKE_SHARED;",
          "217:  } else {",
          "218:   struct mount *n, *p;",
          "",
          "[Removed Lines]",
          "215:  if (m->mnt_group_id == last_dest->mnt_group_id) {",
          "",
          "[Added Lines]",
          "220:  if (peers(m, last_dest)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "223:      last_source = last_source->mnt_master;",
          "224:      last_dest = last_source->mnt_parent;",
          "225:     }",
          "227:      last_source = last_source->mnt_master;",
          "228:      last_dest = last_source->mnt_parent;",
          "229:     }",
          "",
          "[Removed Lines]",
          "226:     if (n->mnt_group_id != last_dest->mnt_group_id) {",
          "",
          "[Added Lines]",
          "231:     if (!peers(n, last_dest)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
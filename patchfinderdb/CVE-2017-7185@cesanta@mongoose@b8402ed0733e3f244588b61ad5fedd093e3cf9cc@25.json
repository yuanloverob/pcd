{
  "cve_id": "CVE-2017-7185",
  "cve_desc": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.",
  "repo": "cesanta/mongoose",
  "patch_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
  "patch_info": {
    "commit_hash": "b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc",
    "files": [
      "mongoose.c"
    ],
    "message": "Fix crash in multipart handling\n\nClose cesanta/dev#6974\n\nPUBLISHED_FROM=4d4e4a46eceba10aec8dacb7f8f58bd078c92307",
    "before_after_code_files": [
      "mongoose.c||mongoose.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5961:   struct mbuf *io = &c->recv_mbuf;",
      "5962:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
      "5964:   if ((int) io->len < pd->mp_stream.boundary_len + 2) {",
      "5965:     return 0;",
      "5966:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5964:   if (pd->mp_stream.boundary == NULL) {",
      "5965:     pd->mp_stream.state = MPS_FINALIZE;",
      "5966:     DBG((\"Invalid request: boundary not initilaized\"));",
      "5967:     return 0;",
      "5968:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "14094aaef70ce535984702ff6507e23486e0d47b",
      "candidate_info": {
        "commit_hash": "14094aaef70ce535984702ff6507e23486e0d47b",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/14094aaef70ce535984702ff6507e23486e0d47b",
        "files": [
          "docs/c-api/http_server.h/mg_send_http_chunk.md",
          "mongoose.h"
        ],
        "message": "Fix typo\n\nPUBLISHED_FROM=56fdeaf4965ef26c398267c8656735bb52e45085",
        "before_after_code_files": [
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h"
        ]
      }
    },
    {
      "candidate_hash": "df5fff5e72f012b20da55151940fd1cf7ea32edb",
      "candidate_info": {
        "commit_hash": "df5fff5e72f012b20da55151940fd1cf7ea32edb",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/df5fff5e72f012b20da55151940fd1cf7ea32edb",
        "files": [
          "mongoose.c"
        ],
        "message": "Consistent MG_MALLOC, MG_REALLOC and MG_FREE calls\n\nPUBLISHED_FROM=e7f306b5d1a1366d3ec71fa238c5e18c03aadf8d",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #ifndef CS_MONGOOSE_SRC_INTERNAL_H_",
          "11: #define CS_MONGOOSE_SRC_INTERNAL_H_",
          "29: #ifndef MBUF_REALLOC",
          "30: #define MBUF_REALLOC MG_REALLOC",
          "",
          "[Removed Lines]",
          "13: #ifndef MG_MALLOC",
          "14: #define MG_MALLOC malloc",
          "15: #endif",
          "17: #ifndef MG_CALLOC",
          "18: #define MG_CALLOC calloc",
          "19: #endif",
          "21: #ifndef MG_REALLOC",
          "22: #define MG_REALLOC realloc",
          "23: #endif",
          "25: #ifndef MG_FREE",
          "26: #define MG_FREE free",
          "27: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "181: #ifdef MG_MODULE_LINES",
          "182: #line 1 \"common/cs_dbg.h\"",
          "183: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168: #line 1 \"common/mg_mem.h\"",
          "169: #endif",
          "175: #ifndef CS_COMMON_MG_MEM_H_",
          "176: #define CS_COMMON_MG_MEM_H_",
          "178: #ifndef MG_MALLOC",
          "179: #define MG_MALLOC malloc",
          "180: #endif",
          "182: #ifndef MG_CALLOC",
          "183: #define MG_CALLOC calloc",
          "184: #endif",
          "186: #ifndef MG_REALLOC",
          "187: #define MG_REALLOC realloc",
          "188: #endif",
          "190: #ifndef MG_FREE",
          "191: #define MG_FREE free",
          "192: #endif",
          "195: #ifdef MG_MODULE_LINES",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613: #ifdef _WIN32",
          "614: struct win32_dir {",
          "615:   DIR d;",
          "",
          "[Removed Lines]",
          "605: #ifndef MG_FREE",
          "606: #define MG_FREE free",
          "607: #endif",
          "609: #ifndef MG_MALLOC",
          "610: #define MG_MALLOC malloc",
          "611: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1160: struct mg_str mg_strdup(const struct mg_str s) {",
          "1161:   struct mg_str r = {NULL, 0};",
          "1162:   if (s.len > 0 && s.p != NULL) {",
          "1164:     if (r.p != NULL) {",
          "1165:       memcpy((char *) r.p, s.p, s.len);",
          "1166:       r.len = s.len;",
          "",
          "[Removed Lines]",
          "1163:     r.p = (char *) malloc(s.len);",
          "",
          "[Added Lines]",
          "1171:     r.p = (char *) MG_MALLOC(s.len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1468: #define C_DISABLE_BUILTIN_SNPRINTF 0",
          "1469: #endif",
          "1479: size_t c_strnlen(const char *s, size_t maxlen) WEAK;",
          "1480: size_t c_strnlen(const char *s, size_t maxlen) {",
          "",
          "[Removed Lines]",
          "1471: #ifndef MG_MALLOC",
          "1472: #define MG_MALLOC malloc",
          "1473: #endif",
          "1475: #ifndef MG_FREE",
          "1476: #define MG_FREE free",
          "1477: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1740: char *strdup(const char *src) WEAK;",
          "1741: char *strdup(const char *src) {",
          "1742:   size_t len = strlen(src) + 1;",
          "1744:   if (ret != NULL) {",
          "1745:     strcpy(ret, src);",
          "1746:   }",
          "",
          "[Removed Lines]",
          "1743:   char *ret = malloc(len);",
          "",
          "[Added Lines]",
          "1745:   char *ret = MG_MALLOC(len);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5114: #if MG_ENABLE_HTTP_STREAMING_MULTIPART",
          "5115: static void mg_http_free_proto_data_mp_stream(",
          "5116:     struct mg_http_multipart_stream *mp) {",
          "5120:   memset(mp, 0, sizeof(*mp));",
          "5121: }",
          "5122: #endif",
          "",
          "[Removed Lines]",
          "5117:   free((void *) mp->boundary);",
          "5118:   free((void *) mp->var_name);",
          "5119:   free((void *) mp->file_name);",
          "",
          "[Added Lines]",
          "5119:   MG_FREE((void *) mp->boundary);",
          "5120:   MG_FREE((void *) mp->var_name);",
          "5121:   MG_FREE((void *) mp->file_name);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5138:   while (current != NULL) {",
          "5139:     struct mg_http_endpoint *tmp = current->next;",
          "5142:     current = tmp;",
          "5143:   }",
          "",
          "[Removed Lines]",
          "5140:     free((void *) current->name);",
          "5141:     free(current);",
          "",
          "[Added Lines]",
          "5142:     MG_FREE((void *) current->name);",
          "5143:     MG_FREE(current);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5174: #endif",
          "5175:   mg_http_free_proto_data_endpoints(&pd->endpoints);",
          "5176:   mg_http_free_reverse_proxy_data(&pd->reverse_proxy_data);",
          "5178: }",
          "5180: #if MG_ENABLE_FILESYSTEM",
          "",
          "[Removed Lines]",
          "5177:   free(proto_data);",
          "",
          "[Added Lines]",
          "5179:   MG_FREE(proto_data);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5942:   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);",
          "5944:   mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);",
          "5946:   pd->mp_stream.file_name = NULL;",
          "5948:   pd->mp_stream.var_name = NULL;",
          "5949:   mg_http_multipart_call_handler(c, MG_EV_HTTP_MULTIPART_REQUEST_END, NULL, 0);",
          "5950:   mg_http_free_proto_data_mp_stream(&pd->mp_stream);",
          "",
          "[Removed Lines]",
          "5945:   free((void *) pd->mp_stream.file_name);",
          "5947:   free((void *) pd->mp_stream.var_name);",
          "",
          "[Added Lines]",
          "5947:   MG_FREE((void *) pd->mp_stream.file_name);",
          "5949:   MG_FREE((void *) pd->mp_stream.var_name);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6016:         mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);",
          "6017:       }",
          "6020:       pd->mp_stream.file_name = strdup(file_name);",
          "6022:       pd->mp_stream.var_name = strdup(var_name);",
          "6024:       mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_BEGIN, NULL, 0);",
          "",
          "[Removed Lines]",
          "6019:       free((void *) pd->mp_stream.file_name);",
          "6021:       free((void *) pd->mp_stream.var_name);",
          "",
          "[Added Lines]",
          "6021:       MG_FREE((void *) pd->mp_stream.file_name);",
          "6023:       MG_FREE((void *) pd->mp_stream.var_name);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "7558:       struct mg_http_multipart_part *mp =",
          "7559:           (struct mg_http_multipart_part *) ev_data;",
          "7560:       struct file_upload_state *fus =",
          "7562:       struct mg_str lfn = local_name_fn(nc, mg_mk_str(mp->file_name));",
          "7563:       mp->user_data = NULL;",
          "7564:       if (lfn.p == NULL || lfn.len == 0) {",
          "",
          "[Removed Lines]",
          "7561:           (struct file_upload_state *) calloc(1, sizeof(*fus));",
          "",
          "[Added Lines]",
          "7563:           (struct file_upload_state *) MG_CALLOC(1, sizeof(*fus));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "7572:         nc->flags |= MG_F_SEND_AND_CLOSE;",
          "7573:         return;",
          "7574:       }",
          "7576:       memcpy(fus->lfn, lfn.p, lfn.len);",
          "7577:       fus->lfn[lfn.len] = '\\0';",
          "7579:       LOG(LL_DEBUG,",
          "7580:           (\"%p Receiving file %s -> %s\", nc, mp->file_name, fus->lfn));",
          "7581:       fus->fp = mg_fopen(fus->lfn, \"w\");",
          "",
          "[Removed Lines]",
          "7575:       fus->lfn = (char *) malloc(lfn.len + 1);",
          "7578:       if (lfn.p != mp->file_name) free((char *) lfn.p);",
          "",
          "[Added Lines]",
          "7577:       fus->lfn = (char *) MG_MALLOC(lfn.len + 1);",
          "7580:       if (lfn.p != mp->file_name) MG_FREE((char *) lfn.p);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "7658:       }",
          "7659:       if (fus->fp != NULL) fclose(fus->fp);",
          "7662:       mp->user_data = NULL;",
          "7663:       nc->flags |= MG_F_SEND_AND_CLOSE;",
          "7664:       break;",
          "",
          "[Removed Lines]",
          "7660:       free(fus->lfn);",
          "7661:       free(fus);",
          "",
          "[Added Lines]",
          "7662:       MG_FREE(fus->lfn);",
          "7663:       MG_FREE(fus);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "7889:   struct mg_http_endpoint *new_ep = NULL;",
          "7891:   if (nc == NULL) return;",
          "7893:   if (new_ep == NULL) return;",
          "7895:   pd = mg_http_get_proto_data(nc);",
          "",
          "[Removed Lines]",
          "7892:   new_ep = (struct mg_http_endpoint *) calloc(1, sizeof(*new_ep));",
          "",
          "[Added Lines]",
          "7894:   new_ep = (struct mg_http_endpoint *) MG_CALLOC(1, sizeof(*new_ep));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "10125: static void mg_mqtt_broker_handle_connect(struct mg_mqtt_broker *brk,",
          "10126:                                           struct mg_connection *nc) {",
          "10128:   if (s == NULL) {",
          "10130:     mg_mqtt_connack(nc, MG_EV_MQTT_CONNACK_SERVER_UNAVAILABLE);",
          "",
          "[Removed Lines]",
          "10127:   struct mg_mqtt_session *s = (struct mg_mqtt_session *) calloc(1, sizeof *s);",
          "",
          "[Added Lines]",
          "10129:   struct mg_mqtt_session *s =",
          "10130:       (struct mg_mqtt_session *) MG_CALLOC(1, sizeof *s);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "10157:     qoss[qoss_len++] = qos;",
          "10158:   }",
          "10161:       ss->subscriptions, sizeof(*ss->subscriptions) * qoss_len);",
          "10162:   for (pos = 0;",
          "10163:        (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;",
          "10164:        ss->num_subscriptions++) {",
          "10165:     te = &ss->subscriptions[ss->num_subscriptions];",
          "10167:     te->qos = qos;",
          "10168:     strncpy((char *) te->topic, topic.p, topic.len + 1);",
          "10169:   }",
          "",
          "[Removed Lines]",
          "10160:   ss->subscriptions = (struct mg_mqtt_topic_expression *) realloc(",
          "10166:     te->topic = (char *) malloc(topic.len + 1);",
          "",
          "[Added Lines]",
          "10163:   ss->subscriptions = (struct mg_mqtt_topic_expression *) MG_REALLOC(",
          "10169:     te->topic = (char *) MG_MALLOC(topic.len + 1);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "10951:   dns_nc = mg_connect(mgr, nameserver_url, MG_CB(mg_resolve_async_eh, NULL));",
          "10952:   if (dns_nc == NULL) {",
          "10954:     return -1;",
          "10955:   }",
          "10956:   dns_nc->user_data = req;",
          "",
          "[Removed Lines]",
          "10953:     free(req);",
          "",
          "[Added Lines]",
          "10956:     MG_FREE(req);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "10962: }",
          "10964: void mg_set_nameserver(struct mg_mgr *mgr, const char *nameserver) {",
          "10966:   if (nameserver != NULL) {",
          "10967:     mgr->nameserver = strdup(nameserver);",
          "10968:   }",
          "",
          "[Removed Lines]",
          "10965:   free((char *) mgr->nameserver);",
          "",
          "[Added Lines]",
          "10968:   MG_FREE((char *) mgr->nameserver);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "12481:         if (s_sl_file_size_hints[i].name != NULL &&",
          "12482:             strcmp(s_sl_file_size_hints[i].name, pathname) == 0) {",
          "12483:           size = s_sl_file_size_hints[i].size;",
          "12485:           s_sl_file_size_hints[i].name = NULL;",
          "12486:           break;",
          "12487:         }",
          "",
          "[Removed Lines]",
          "12484:           free(s_sl_file_size_hints[i].name);",
          "",
          "[Added Lines]",
          "12489:           MG_FREE(s_sl_file_size_hints[i].name);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "13754:     memmove(der_file, der_file + 3, l - 2 /* including \\0 */);",
          "13755:   } else {",
          "13757:     der_file = NULL;",
          "13758:   }",
          "13759:   return der_file;",
          "",
          "[Removed Lines]",
          "13756:     free(der_file);",
          "",
          "[Added Lines]",
          "13763:     MG_FREE(der_file);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "13789:       } else {",
          "13790:         err = -1;",
          "13791:       }",
          "13794:       if (err != 0) return err;",
          "13795:     }",
          "13796:     if (ctx->ssl_ca_cert != NULL) {",
          "",
          "[Removed Lines]",
          "13792:       free(ssl_cert);",
          "13793:       free(ssl_key);",
          "",
          "[Added Lines]",
          "13799:       MG_FREE(ssl_cert);",
          "13800:       MG_FREE(ssl_key);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "13804:         } else {",
          "13805:           err = -1;",
          "13806:         }",
          "13808:         if (err != 0) return err;",
          "13809:       }",
          "13810:     }",
          "",
          "[Removed Lines]",
          "13807:         free(ssl_ca_cert);",
          "",
          "[Added Lines]",
          "13814:         MG_FREE(ssl_ca_cert);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "14057:   while (cs->rx_chain != NULL) {",
          "14058:     struct pbuf *seg = cs->rx_chain;",
          "14059:     size_t len = (seg->len - cs->rx_offset);",
          "14061:     if (data == NULL) {",
          "14062:       mgos_unlock();",
          "14063:       DBG((\"OOM\"));",
          "",
          "[Removed Lines]",
          "14060:     char *data = (char *) malloc(len);",
          "",
          "[Added Lines]",
          "14069:     char *data = (char *) MG_MALLOC(len);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "14179:     struct pbuf *p = sap->next;",
          "14180:     cs->rx_chain = pbuf_dechain(p);",
          "14181:     size_t data_len = p->len;",
          "14183:     if (data != NULL) {",
          "14184:       pbuf_copy_partial(p, data, data_len, 0);",
          "14185:       pbuf_free(p);",
          "",
          "[Removed Lines]",
          "14182:     char *data = (char *) malloc(data_len);",
          "",
          "[Added Lines]",
          "14191:     char *data = (char *) MG_MALLOC(data_len);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "14403: int mg_lwip_if_create_conn(struct mg_connection *nc) {",
          "14404:   struct mg_lwip_conn_state *cs =",
          "14406:   if (cs == NULL) return 0;",
          "14407:   cs->nc = nc;",
          "14408:   nc->sock = (intptr_t) cs;",
          "",
          "[Removed Lines]",
          "14405:       (struct mg_lwip_conn_state *) calloc(1, sizeof(*cs));",
          "",
          "[Added Lines]",
          "14414:       (struct mg_lwip_conn_state *) MG_CALLOC(1, sizeof(*cs));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "14426:       pbuf_free(seg);",
          "14427:     }",
          "14428:     memset(cs, 0, sizeof(*cs));",
          "14430:   } else if (nc->listener == NULL) {",
          "14432:     struct udp_pcb *upcb = cs->pcb.udp;",
          "",
          "[Removed Lines]",
          "14429:     free(cs);",
          "",
          "[Added Lines]",
          "14438:     MG_FREE(cs);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "14435:       udp_remove(upcb);",
          "14436:     }",
          "14437:     memset(cs, 0, sizeof(*cs));",
          "14439:   }",
          "14440:   nc->sock = INVALID_SOCKET;",
          "14441: }",
          "",
          "[Removed Lines]",
          "14438:     free(cs);",
          "",
          "[Added Lines]",
          "14447:     MG_FREE(cs);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "14844:   if (nc->flags & MG_F_CONNECTING) return;",
          "14845:   while (nc->recv_mbuf.len < MG_LWIP_SSL_RECV_MBUF_LIMIT) {",
          "14847:     if (buf == NULL) return;",
          "14848:     int ret = mg_ssl_if_read(nc, buf, MG_LWIP_SSL_IO_SIZE);",
          "14849:     DBG((\"%p %p SSL_read %u = %d\", nc, cs->rx_chain, MG_LWIP_SSL_IO_SIZE, ret));",
          "14850:     if (ret <= 0) {",
          "14852:       if (ret == MG_SSL_WANT_WRITE) {",
          "14853:         nc->flags |= MG_F_WANT_WRITE;",
          "14854:         return;",
          "",
          "[Removed Lines]",
          "14846:     char *buf = (char *) malloc(MG_LWIP_SSL_IO_SIZE);",
          "14851:       free(buf);",
          "",
          "[Added Lines]",
          "14856:     char *buf = (char *) MG_MALLOC(MG_LWIP_SSL_IO_SIZE);",
          "14861:       MG_FREE(buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4172c190e5efc21cec85f28d597bcc3292d5d5ce",
      "candidate_info": {
        "commit_hash": "4172c190e5efc21cec85f28d597bcc3292d5d5ce",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/4172c190e5efc21cec85f28d597bcc3292d5d5ce",
        "files": [
          "mongoose.c"
        ],
        "message": "Fix MQTT handshake; change to version 3.1.1\n\nDifferences between 3.1 and 3.1.1:\nhttps://github.com/mqtt/mqtt.github.io/wiki/Differences-between-3.1.0-and-3.1.1\n\nNone of them are breaking.\n\nPUBLISHED_FROM=cf2abd28deb1dabf787e07bcfdb335ff72462865",
        "before_after_code_files": [
          "mongoose.c||mongoose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9856:   nc->proto_data_destructor = mg_mqtt_proto_data_destructor;",
          "9857: }",
          "9859: void mg_send_mqtt_handshake(struct mg_connection *nc, const char *client_id) {",
          "9860:   static struct mg_send_mqtt_handshake_opts opts;",
          "9861:   mg_send_mqtt_handshake_opt(nc, client_id, opts);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9859: static void mg_mqtt_prepend_header(struct mg_connection *nc, uint8_t cmd,",
          "9860:                                    uint8_t flags, size_t len) {",
          "9861:   size_t off = nc->send_mbuf.len - len;",
          "9862:   uint8_t header = cmd << 4 | (uint8_t) flags;",
          "9864:   uint8_t buf[1 + sizeof(size_t)];",
          "9865:   uint8_t *vlen = &buf[1];",
          "9867:   assert(nc->send_mbuf.len >= len);",
          "9869:   buf[0] = header;",
          "9872:   do {",
          "9874:     len /= 0x80;",
          "9875:     if (len > 0) *vlen |= 0x80;",
          "9876:     vlen++;",
          "9877:   } while (len > 0);",
          "9879:   mbuf_insert(&nc->send_mbuf, off, buf, vlen - buf);",
          "9880: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9864: void mg_send_mqtt_handshake_opt(struct mg_connection *nc, const char *client_id,",
          "9865:                                 struct mg_send_mqtt_handshake_opts opts) {",
          "9870:   struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *) nc->proto_data;",
          "9879:   if (opts.user_name != NULL) {",
          "9880:     opts.flags |= MG_MQTT_HAS_USER_NAME;",
          "9882:   }",
          "9883:   if (opts.password != NULL) {",
          "9884:     opts.flags |= MG_MQTT_HAS_PASSWORD;",
          "9886:   }",
          "9887:   if (opts.will_topic != NULL && opts.will_message != NULL) {",
          "9888:     opts.flags |= MG_MQTT_HAS_WILL;",
          "9891:   }",
          "9898:   if (opts.keep_alive == 0) {",
          "9899:     opts.keep_alive = 60;",
          "9900:   }",
          "9909:   if (opts.flags & MG_MQTT_HAS_WILL) {",
          "9917:   }",
          "9919:   if (opts.flags & MG_MQTT_HAS_USER_NAME) {",
          "9923:   }",
          "9924:   if (opts.flags & MG_MQTT_HAS_PASSWORD) {",
          "9928:   }",
          "9930:   if (pd != NULL) {",
          "9931:     pd->keep_alive = opts.keep_alive;",
          "9932:   }",
          "9933: }",
          "9958: void mg_mqtt_publish(struct mg_connection *nc, const char *topic,",
          "9959:                      uint16_t message_id, int flags, const void *data,",
          "9960:                      size_t len) {",
          "",
          "[Removed Lines]",
          "9866:   uint8_t header = MG_MQTT_CMD_CONNECT << 4;",
          "9867:   uint8_t rem_len;",
          "9868:   uint16_t keep_alive;",
          "9869:   uint16_t len;",
          "9877:   rem_len = 9 + 1 + 2 + 2 + (uint8_t) strlen(client_id);",
          "9881:     rem_len += (uint8_t) strlen(opts.user_name) + 2;",
          "9885:     rem_len += (uint8_t) strlen(opts.password) + 2;",
          "9889:     rem_len += (uint8_t) strlen(opts.will_topic) + 2;",
          "9890:     rem_len += (uint8_t) strlen(opts.will_message) + 2;",
          "9893:   mg_send(nc, &header, 1);",
          "9894:   mg_send(nc, &rem_len, 1);",
          "9895:   mg_send(nc, \"\\00\\06MQIsdp\\03\", 9);",
          "9896:   mg_send(nc, &opts.flags, 1);",
          "9902:   keep_alive = htons(opts.keep_alive);",
          "9903:   mg_send(nc, &keep_alive, 2);",
          "9905:   len = htons((uint16_t) strlen(client_id));",
          "9906:   mg_send(nc, &len, 2);",
          "9907:   mg_send(nc, client_id, strlen(client_id));",
          "9910:     len = htons((uint16_t) strlen(opts.will_topic));",
          "9911:     mg_send(nc, &len, 2);",
          "9912:     mg_send(nc, opts.will_topic, strlen(opts.will_topic));",
          "9914:     len = htons((uint16_t) strlen(opts.will_message));",
          "9915:     mg_send(nc, &len, 2);",
          "9916:     mg_send(nc, opts.will_message, strlen(opts.will_message));",
          "9920:     len = htons((uint16_t) strlen(opts.user_name));",
          "9921:     mg_send(nc, &len, 2);",
          "9922:     mg_send(nc, opts.user_name, strlen(opts.user_name));",
          "9925:     len = htons((uint16_t) strlen(opts.password));",
          "9926:     mg_send(nc, &len, 2);",
          "9927:     mg_send(nc, opts.password, strlen(opts.password));",
          "9935: static void mg_mqtt_prepend_header(struct mg_connection *nc, uint8_t cmd,",
          "9936:                                    uint8_t flags, size_t len) {",
          "9937:   size_t off = nc->send_mbuf.len - len;",
          "9938:   uint8_t header = cmd << 4 | (uint8_t) flags;",
          "9940:   uint8_t buf[1 + sizeof(size_t)];",
          "9941:   uint8_t *vlen = &buf[1];",
          "9943:   assert(nc->send_mbuf.len >= len);",
          "9945:   buf[0] = header;",
          "9948:   do {",
          "9950:     len /= 0x80;",
          "9951:     if (len > 0) *vlen |= 0x80;",
          "9952:     vlen++;",
          "9953:   } while (len > 0);",
          "9955:   mbuf_insert(&nc->send_mbuf, off, buf, vlen - buf);",
          "9956: }",
          "",
          "[Added Lines]",
          "9889:   uint16_t hlen, nlen, rem_len = 0;",
          "9892:   mg_send(nc, \"\\00\\04MQTT\\04\", 7);",
          "9893:   rem_len += 7;",
          "9908:   mg_send(nc, &opts.flags, 1);",
          "9909:   rem_len += 1;",
          "9911:   nlen = htons(opts.keep_alive);",
          "9912:   mg_send(nc, &nlen, 2);",
          "9913:   rem_len += 2;",
          "9915:   hlen = strlen(client_id);",
          "9916:   nlen = htons((uint16_t) hlen);",
          "9917:   mg_send(nc, &nlen, 2);",
          "9918:   mg_send(nc, client_id, hlen);",
          "9919:   rem_len += 2 + hlen;",
          "9922:     hlen = strlen(opts.will_topic);",
          "9923:     nlen = htons((uint16_t) hlen);",
          "9924:     mg_send(nc, &nlen, 2);",
          "9925:     mg_send(nc, opts.will_topic, hlen);",
          "9926:     rem_len += 2 + hlen;",
          "9928:     hlen = strlen(opts.will_message);",
          "9929:     nlen = htons((uint16_t) nlen);",
          "9930:     mg_send(nc, &nlen, 2);",
          "9931:     mg_send(nc, opts.will_message, hlen);",
          "9932:     rem_len += 2 + hlen;",
          "9936:     hlen = strlen(opts.user_name);",
          "9937:     nlen = htons((uint16_t) hlen);",
          "9938:     mg_send(nc, &nlen, 2);",
          "9939:     mg_send(nc, opts.user_name, hlen);",
          "9940:     rem_len += 2 + hlen;",
          "9943:     hlen = strlen(opts.password);",
          "9944:     nlen = htons((uint16_t) hlen);",
          "9945:     mg_send(nc, &nlen, 2);",
          "9946:     mg_send(nc, opts.password, hlen);",
          "9947:     rem_len += 2 + hlen;",
          "9950:   mg_mqtt_prepend_header(nc, MG_MQTT_CMD_CONNECT, 0, rem_len);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ff078882d5066472c8df0d52629e4714c2416023",
      "candidate_info": {
        "commit_hash": "ff078882d5066472c8df0d52629e4714c2416023",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/ff078882d5066472c8df0d52629e4714c2416023",
        "files": [
          "mongoose.h"
        ],
        "message": "Don't define fileno stub in C++\n\nPUBLISHED_FROM=98fb6c78d20a98dfba07ba6671bd51a394bbc4ca",
        "before_after_code_files": [
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "548: #define __cdecl",
          "549: #define _FILE_OFFSET_BITS 32",
          "552: #define fileno(x) -1",
          "553: #endif",
          "",
          "[Removed Lines]",
          "551: #ifndef RTOS_SDK",
          "",
          "[Added Lines]",
          "551: #if !defined(RTOS_SDK) && !defined(__cplusplus)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4b55c4ceb3eb24f96218a45852ec7d0e1c38aee",
      "candidate_info": {
        "commit_hash": "d4b55c4ceb3eb24f96218a45852ec7d0e1c38aee",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/d4b55c4ceb3eb24f96218a45852ec7d0e1c38aee",
        "files": [
          "docs/c-api/http_server.h/intro.md",
          "docs/c-api/http_server.h/mg_check_digest_auth.md",
          "mongoose.c",
          "mongoose.h"
        ],
        "message": "Separate digest auth from HTTP headers parsing\n\nPUBLISHED_FROM=f97569ae2f31ab94ce4875eae4d0a198f719c388",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/cesanta/mongoose/pull/855"
        ],
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6973: int mg_http_check_digest_auth(struct http_message *hm, const char *auth_domain,",
          "6974:                               FILE *fp) {",
          "6975:   struct mg_str *hdr;",
          "6981:   if (hm == NULL || fp == NULL ||",
          "6982:       (hdr = mg_get_http_header(hm, \"Authorization\")) == NULL ||",
          "6984:       mg_http_parse_header(hdr, \"cnonce\", cnonce, sizeof(cnonce)) == 0 ||",
          "6985:       mg_http_parse_header(hdr, \"response\", response, sizeof(response)) == 0 ||",
          "6986:       mg_http_parse_header(hdr, \"uri\", uri, sizeof(uri)) == 0 ||",
          "",
          "[Removed Lines]",
          "6976:   char buf[128], f_user[sizeof(buf)], f_ha1[sizeof(buf)], f_domain[sizeof(buf)];",
          "6977:   char user[50], cnonce[64], response[40], uri[200], qop[20], nc[20], nonce[30];",
          "6978:   char expected_response[33];",
          "6983:       mg_http_parse_header(hdr, \"username\", user, sizeof(user)) == 0 ||",
          "",
          "[Added Lines]",
          "6976:   char username[50], cnonce[64], response[40], uri[200], qop[20], nc[20],",
          "6977:       nonce[30];",
          "6982:       mg_http_parse_header(hdr, \"username\", username, sizeof(username)) == 0 ||",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6991:     return 0;",
          "6992:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6995:   return mg_check_digest_auth(",
          "6996:       hm->method,",
          "6997:       mg_mk_str_n(",
          "6998:           hm->uri.p,",
          "6999:           hm->uri.len + (hm->query_string.len ? hm->query_string.len + 1 : 0)),",
          "7000:       mg_mk_str(username), mg_mk_str(cnonce), mg_mk_str(response),",
          "7001:       mg_mk_str(qop), mg_mk_str(nc), mg_mk_str(nonce), mg_mk_str(auth_domain),",
          "7002:       fp);",
          "7003: }",
          "7005: int mg_check_digest_auth(struct mg_str method, struct mg_str uri,",
          "7006:                          struct mg_str username, struct mg_str cnonce,",
          "7007:                          struct mg_str response, struct mg_str qop,",
          "7008:                          struct mg_str nc, struct mg_str nonce,",
          "7009:                          struct mg_str auth_domain, FILE *fp) {",
          "7010:   char buf[128], f_user[sizeof(buf)], f_ha1[sizeof(buf)], f_domain[sizeof(buf)];",
          "7011:   char expected_response[33];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6999:   while (fgets(buf, sizeof(buf), fp) != NULL) {",
          "7000:     if (sscanf(buf, \"%[^:]:%[^:]:%s\", f_user, f_domain, f_ha1) == 3 &&",
          "7010:       LOG(LL_DEBUG,",
          "7013:     }",
          "7014:   }",
          "",
          "[Removed Lines]",
          "7001:         strcmp(user, f_user) == 0 &&",
          "7003:         strcmp(auth_domain, f_domain) == 0) {",
          "7005:       mg_mkmd5resp(",
          "7006:           hm->method.p, hm->method.len, hm->uri.p,",
          "7007:           hm->uri.len + (hm->query_string.len ? hm->query_string.len + 1 : 0),",
          "7008:           f_ha1, strlen(f_ha1), nonce, strlen(nonce), nc, strlen(nc), cnonce,",
          "7009:           strlen(cnonce), qop, strlen(qop), expected_response);",
          "7011:           (\"%s %s %s %s\", user, f_domain, response, expected_response));",
          "7012:       return mg_casecmp(response, expected_response) == 0;",
          "",
          "[Added Lines]",
          "7020:         mg_vcmp(&username, f_user) == 0 &&",
          "7021:         mg_vcmp(&auth_domain, f_domain) == 0) {",
          "7023:       mg_mkmd5resp(method.p, method.len, uri.p, uri.len, f_ha1, strlen(f_ha1),",
          "7024:                    nonce.p, nonce.len, nc.p, nc.len, cnonce.p, cnonce.len,",
          "7025:                    qop.p, qop.len, expected_response);",
          "7027:           (\"%.*s %s %.*s %s\", (int) username.len, username.p, f_domain,",
          "7028:            (int) response.len, response.p, expected_response));",
          "7029:       return mg_ncasecmp(response.p, expected_response, response.len) == 0;",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4870: int mg_http_check_digest_auth(struct http_message *hm, const char *auth_domain,",
          "4871:                               FILE *fp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4879: int mg_check_digest_auth(struct mg_str method, struct mg_str uri,",
          "4880:                          struct mg_str username, struct mg_str cnonce,",
          "4881:                          struct mg_str response, struct mg_str qop,",
          "4882:                          struct mg_str nc, struct mg_str nonce,",
          "4883:                          struct mg_str auth_domain, FILE *fp);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
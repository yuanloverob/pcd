{
  "cve_id": "CVE-2013-4538",
  "cve_desc": "Multiple buffer overflows in the ssd0323_load function in hw/display/ssd0323.c in QEMU before 1.7.2 allow remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via crafted (1) cmd_len, (2) row, or (3) col values; (4) row_start and row_end values; or (5) col_star and col_end values in a savevm image.",
  "repo": "qemu/qemu",
  "patch_hash": "ead7a57df37d2187813a121308213f41591bd811",
  "patch_info": {
    "commit_hash": "ead7a57df37d2187813a121308213f41591bd811",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/ead7a57df37d2187813a121308213f41591bd811",
    "files": [
      "hw/display/ssd0323.c"
    ],
    "message": "ssd0323: fix buffer overun on invalid state load\n\nCVE-2013-4538\n\ns->cmd_len used as index in ssd0323_transfer() to store 32-bit field.\nPossible this field might then be supplied by guest to overwrite a\nreturn addr somewhere. Same for row/col fields, which are indicies into\nframebuffer array.\n\nTo fix validate after load.\n\nAdditionally, validate that the row/col_start/end are within bounds;\notherwise the guest can provoke an overrun by either setting the _end\nfield so large that the row++ increments just walk off the end of the\narray, or by setting the _start value to something bogus and then\nletting the \"we hit end of row\" logic reset row to row_start.\n\nFor completeness, validate mode as well.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nSigned-off-by: Juan Quintela <quintela@redhat.com>",
    "before_after_code_files": [
      "hw/display/ssd0323.c||hw/display/ssd0323.c"
    ]
  },
  "patch_diff": {
    "hw/display/ssd0323.c||hw/display/ssd0323.c": [
      "File: hw/display/ssd0323.c -> hw/display/ssd0323.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "312:         return -EINVAL;",
      "314:     s->cmd_len = qemu_get_be32(f);",
      "315:     s->cmd = qemu_get_be32(f);",
      "316:     for (i = 0; i < 8; i++)",
      "317:         s->cmd_data[i] = qemu_get_be32(f);",
      "318:     s->row = qemu_get_be32(f);",
      "319:     s->row_start = qemu_get_be32(f);",
      "320:     s->row_end = qemu_get_be32(f);",
      "321:     s->col = qemu_get_be32(f);",
      "322:     s->col_start = qemu_get_be32(f);",
      "323:     s->col_end = qemu_get_be32(f);",
      "324:     s->redraw = qemu_get_be32(f);",
      "325:     s->remap = qemu_get_be32(f);",
      "326:     s->mode = qemu_get_be32(f);",
      "327:     qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));",
      "329:     ss->cs = qemu_get_be32(f);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "315:     if (s->cmd_len < 0 || s->cmd_len > ARRAY_SIZE(s->cmd_data)) {",
      "316:         return -EINVAL;",
      "317:     }",
      "322:     if (s->row < 0 || s->row >= 80) {",
      "323:         return -EINVAL;",
      "324:     }",
      "326:     if (s->row_start < 0 || s->row_start >= 80) {",
      "327:         return -EINVAL;",
      "328:     }",
      "330:     if (s->row_end < 0 || s->row_end >= 80) {",
      "331:         return -EINVAL;",
      "332:     }",
      "334:     if (s->col < 0 || s->col >= 64) {",
      "335:         return -EINVAL;",
      "336:     }",
      "338:     if (s->col_start < 0 || s->col_start >= 64) {",
      "339:         return -EINVAL;",
      "340:     }",
      "342:     if (s->col_end < 0 || s->col_end >= 64) {",
      "343:         return -EINVAL;",
      "344:     }",
      "348:     if (s->mode != SSD0323_CMD && s->mode != SSD0323_DATA) {",
      "349:         return -EINVAL;",
      "350:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2265c71b3548913becbd1f6427e715dbbe3b0d2e",
      "candidate_info": {
        "commit_hash": "2265c71b3548913becbd1f6427e715dbbe3b0d2e",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/2265c71b3548913becbd1f6427e715dbbe3b0d2e",
        "files": [
          "hw/display/ssd0323.c"
        ],
        "message": "ssd0323: fix buffer overun on invalid state load\n\nCVE-2013-4538\n\ns->cmd_len used as index in ssd0323_transfer() to store 32-bit field.\nPossible this field might then be supplied by guest to overwrite a\nreturn addr somewhere. Same for row/col fields, which are indicies into\nframebuffer array.\n\nTo fix validate after load.\n\nAdditionally, validate that the row/col_start/end are within bounds;\notherwise the guest can provoke an overrun by either setting the _end\nfield so large that the row++ increments just walk off the end of the\narray, or by setting the _start value to something bogus and then\nletting the \"we hit end of row\" logic reset row to row_start.\n\nFor completeness, validate mode as well.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit ead7a57df37d2187813a121308213f41591bd811)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/display/ssd0323.c||hw/display/ssd0323.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/display/ssd0323.c||hw/display/ssd0323.c"
          ],
          "candidate": [
            "hw/display/ssd0323.c||hw/display/ssd0323.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/display/ssd0323.c||hw/display/ssd0323.c": [
          "File: hw/display/ssd0323.c -> hw/display/ssd0323.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:         return -EINVAL;",
          "314:     s->cmd_len = qemu_get_be32(f);",
          "315:     s->cmd = qemu_get_be32(f);",
          "316:     for (i = 0; i < 8; i++)",
          "317:         s->cmd_data[i] = qemu_get_be32(f);",
          "318:     s->row = qemu_get_be32(f);",
          "319:     s->row_start = qemu_get_be32(f);",
          "320:     s->row_end = qemu_get_be32(f);",
          "321:     s->col = qemu_get_be32(f);",
          "322:     s->col_start = qemu_get_be32(f);",
          "323:     s->col_end = qemu_get_be32(f);",
          "324:     s->redraw = qemu_get_be32(f);",
          "325:     s->remap = qemu_get_be32(f);",
          "326:     s->mode = qemu_get_be32(f);",
          "327:     qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));",
          "329:     ss->cs = qemu_get_be32(f);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:     if (s->cmd_len < 0 || s->cmd_len > ARRAY_SIZE(s->cmd_data)) {",
          "316:         return -EINVAL;",
          "317:     }",
          "322:     if (s->row < 0 || s->row >= 80) {",
          "323:         return -EINVAL;",
          "324:     }",
          "326:     if (s->row_start < 0 || s->row_start >= 80) {",
          "327:         return -EINVAL;",
          "328:     }",
          "330:     if (s->row_end < 0 || s->row_end >= 80) {",
          "331:         return -EINVAL;",
          "332:     }",
          "334:     if (s->col < 0 || s->col >= 64) {",
          "335:         return -EINVAL;",
          "336:     }",
          "338:     if (s->col_start < 0 || s->col_start >= 64) {",
          "339:         return -EINVAL;",
          "340:     }",
          "342:     if (s->col_end < 0 || s->col_end >= 64) {",
          "343:         return -EINVAL;",
          "344:     }",
          "348:     if (s->mode != SSD0323_CMD && s->mode != SSD0323_DATA) {",
          "349:         return -EINVAL;",
          "350:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af443645c3383f26a309d200413649ecac9ac58f",
      "candidate_info": {
        "commit_hash": "af443645c3383f26a309d200413649ecac9ac58f",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/af443645c3383f26a309d200413649ecac9ac58f",
        "files": [
          "hw/display/ssd0323.c"
        ],
        "message": "ssd0323: fix buffer overun on invalid state load\n\nCVE-2013-4538\n\ns->cmd_len used as index in ssd0323_transfer() to store 32-bit field.\nPossible this field might then be supplied by guest to overwrite a\nreturn addr somewhere. Same for row/col fields, which are indicies into\nframebuffer array.\n\nTo fix validate after load.\n\nAdditionally, validate that the row/col_start/end are within bounds;\notherwise the guest can provoke an overrun by either setting the _end\nfield so large that the row++ increments just walk off the end of the\narray, or by setting the _start value to something bogus and then\nletting the \"we hit end of row\" logic reset row to row_start.\n\nFor completeness, validate mode as well.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n(cherry picked from commit ead7a57df37d2187813a121308213f41591bd811)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "hw/display/ssd0323.c||hw/display/ssd0323.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "hw/display/ssd0323.c||hw/display/ssd0323.c"
          ],
          "candidate": [
            "hw/display/ssd0323.c||hw/display/ssd0323.c"
          ]
        }
      },
      "candidate_diff": {
        "hw/display/ssd0323.c||hw/display/ssd0323.c": [
          "File: hw/display/ssd0323.c -> hw/display/ssd0323.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:         return -EINVAL;",
          "314:     s->cmd_len = qemu_get_be32(f);",
          "315:     s->cmd = qemu_get_be32(f);",
          "316:     for (i = 0; i < 8; i++)",
          "317:         s->cmd_data[i] = qemu_get_be32(f);",
          "318:     s->row = qemu_get_be32(f);",
          "319:     s->row_start = qemu_get_be32(f);",
          "320:     s->row_end = qemu_get_be32(f);",
          "321:     s->col = qemu_get_be32(f);",
          "322:     s->col_start = qemu_get_be32(f);",
          "323:     s->col_end = qemu_get_be32(f);",
          "324:     s->redraw = qemu_get_be32(f);",
          "325:     s->remap = qemu_get_be32(f);",
          "326:     s->mode = qemu_get_be32(f);",
          "327:     qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));",
          "329:     ss->cs = qemu_get_be32(f);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:     if (s->cmd_len < 0 || s->cmd_len > ARRAY_SIZE(s->cmd_data)) {",
          "316:         return -EINVAL;",
          "317:     }",
          "322:     if (s->row < 0 || s->row >= 80) {",
          "323:         return -EINVAL;",
          "324:     }",
          "326:     if (s->row_start < 0 || s->row_start >= 80) {",
          "327:         return -EINVAL;",
          "328:     }",
          "330:     if (s->row_end < 0 || s->row_end >= 80) {",
          "331:         return -EINVAL;",
          "332:     }",
          "334:     if (s->col < 0 || s->col >= 64) {",
          "335:         return -EINVAL;",
          "336:     }",
          "338:     if (s->col_start < 0 || s->col_start >= 64) {",
          "339:         return -EINVAL;",
          "340:     }",
          "342:     if (s->col_end < 0 || s->col_end >= 64) {",
          "343:         return -EINVAL;",
          "344:     }",
          "348:     if (s->mode != SSD0323_CMD && s->mode != SSD0323_DATA) {",
          "349:         return -EINVAL;",
          "350:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-25211",
  "cve_desc": "In the Linux kernel through 5.8.7, local attackers able to inject conntrack netlink configuration could overflow a local buffer, causing crashes or triggering use of incorrect protocol numbers in ctnetlink_parse_tuple_filter in net/netfilter/nf_conntrack_netlink.c, aka CID-1cc5ef91d2ff.",
  "repo": "torvalds/linux",
  "patch_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
  "patch_info": {
    "commit_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "files": [
      "net/netfilter/nf_conntrack_netlink.c"
    ],
    "message": "netfilter: ctnetlink: add a range check for l3/l4 protonum\n\nThe indexes to the nf_nat_l[34]protos arrays come from userspace. So\ncheck the tuple's family, e.g. l3num, when creating the conntrack in\norder to prevent an OOB memory access during setup.  Here is an example\nkernel panic on 4.14.180 when userspace passes in an index greater than\nNFPROTO_NUMPROTO.\n\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nModules linked in:...\nProcess poc (pid: 5614, stack limit = 0x00000000a3933121)\nCPU: 4 PID: 5614 Comm: poc Tainted: G S      W  O    4.14.180-g051355490483\nHardware name: Qualcomm Technologies, Inc. SM8150 V2 PM8150 Google Inc. MSM\ntask: 000000002a3dfffe task.stack: 00000000a3933121\npc : __cfi_check_fail+0x1c/0x24\nlr : __cfi_check_fail+0x1c/0x24\n...\nCall trace:\n__cfi_check_fail+0x1c/0x24\nname_to_dev_t+0x0/0x468\nnfnetlink_parse_nat_setup+0x234/0x258\nctnetlink_parse_nat_setup+0x4c/0x228\nctnetlink_new_conntrack+0x590/0xc40\nnfnetlink_rcv_msg+0x31c/0x4d4\nnetlink_rcv_skb+0x100/0x184\nnfnetlink_rcv+0xf4/0x180\nnetlink_unicast+0x360/0x770\nnetlink_sendmsg+0x5a0/0x6a4\n___sys_sendmsg+0x314/0x46c\nSyS_sendmsg+0xb4/0x108\nel0_svc_naked+0x34/0x38\n\nThis crash is not happening since 5.4+, however, ctnetlink still\nallows for creating entries with unsupported layer 3 protocol number.\n\nFixes: c1d10adb4a521 (\"[NETFILTER]: Add ctnetlink port for nf_conntrack\")\nSigned-off-by: Will McVicker <willmcvicker@google.com>\n[pablo@netfilter.org: rebased original patch on top of nf.git]\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c": [
      "File: net/netfilter/nf_conntrack_netlink.c -> net/netfilter/nf_conntrack_netlink.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  if (err < 0)",
      "1405:   return err;",
      "1408:  tuple->src.l3num = l3num;",
      "1410:  if (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1407:  if (l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6)",
      "1408:   return -EOPNOTSUPP;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e80d3909be42f7e38cc350c1ba109cf0aa51956a",
      "candidate_info": {
        "commit_hash": "e80d3909be42f7e38cc350c1ba109cf0aa51956a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e80d3909be42f7e38cc350c1ba109cf0aa51956a",
        "files": [
          "mm/memory.c"
        ],
        "message": "mm: track page table modifications in __apply_to_page_range()\n\n__apply_to_page_range() is also used to change and/or allocate\npage-table pages in the vmalloc area of the address space.  Make sure\nthese changes get synchronized to other page-tables in the system by\ncalling arch_sync_kernel_mappings() when necessary.\n\nThe impact appears limited to x86-32, where apply_to_page_range may miss\nupdating the PMD.  That leads to explosions in drivers like\n\n  BUG: unable to handle page fault for address: fe036000\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0002) - not-present page\n  *pde = 00000000\n  Oops: 0002 [#1] SMP\n  CPU: 3 PID: 1300 Comm: gem_concurrent_ Not tainted 5.9.0-rc1+ #16\n  Hardware name:  /NUC6i3SYB, BIOS SYSKLi35.86A.0024.2015.1027.2142 10/27/2015\n  EIP: __execlists_context_alloc+0x132/0x2d0 [i915]\n  Code: 31 d2 89 f0 e8 2f 55 02 00 89 45 e8 3d 00 f0 ff ff 0f 87 11 01 00 00 8b 4d e8 03 4b 30 b8 5a 5a 5a 5a ba 01 00 00 00 8d 79 04 <c7> 01 5a 5a 5a 5a c7 81 fc 0f 00 00 5a 5a 5a 5a 83 e7 fc 29 f9 81\n  EAX: 5a5a5a5a EBX: f60ca000 ECX: fe036000 EDX: 00000001\n  ESI: f43b7340 EDI: fe036004 EBP: f6389cb8 ESP: f6389c9c\n  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00010286\n  CR0: 80050033 CR2: fe036000 CR3: 2d361000 CR4: 001506d0\n  DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000\n  DR6: fffe0ff0 DR7: 00000400\n  Call Trace:\n    execlists_context_alloc+0x10/0x20 [i915]\n    intel_context_alloc_state+0x3f/0x70 [i915]\n    __intel_context_do_pin+0x117/0x170 [i915]\n    i915_gem_do_execbuffer+0xcc7/0x2500 [i915]\n    i915_gem_execbuffer2_ioctl+0xcd/0x1f0 [i915]\n    drm_ioctl_kernel+0x8f/0xd0\n    drm_ioctl+0x223/0x3d0\n    __ia32_sys_ioctl+0x1ab/0x760\n    __do_fast_syscall_32+0x3f/0x70\n    do_fast_syscall_32+0x29/0x60\n    do_SYSENTER_32+0x15/0x20\n    entry_SYSENTER_32+0x9f/0xf2\n  EIP: 0xb7f28559\n  Code: 03 74 c0 01 10 05 03 74 b8 01 10 06 03 74 b4 01 10 07 03 74 b0 01 10 08 03 74 d8 01 00 00 00 00 00 51 52 55 89 e5 0f 34 cd 80 <5d> 5a 59 c3 90 90 90 90 8d 76 00 58 b8 77 00 00 00 cd 80 90 8d 76\n  EAX: ffffffda EBX: 00000005 ECX: c0406469 EDX: bf95556c\n  ESI: b7e68000 EDI: c0406469 EBP: 00000005 ESP: bf9554d8\n  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 007b EFLAGS: 00000296\n  Modules linked in: i915 x86_pkg_temp_thermal intel_powerclamp crc32_pclmul crc32c_intel intel_cstate intel_uncore intel_gtt drm_kms_helper intel_pch_thermal video button autofs4 i2c_i801 i2c_smbus fan\n  CR2: 00000000fe036000\n\nIt looks like kasan, xen and i915 are vulnerable.\n\nActual impact is \"on thinkpad X60 in 5.9-rc1, screen starts blinking\nafter 30-or-so minutes, and machine is unusable\"\n\n[sfr@canb.auug.org.au: ARCH_PAGE_TABLE_SYNC_MASK needs vmalloc.h]\n  Link: https://lkml.kernel.org/r/20200825172508.16800a4f@canb.auug.org.au\n[chris@chris-wilson.co.uk: changelog addition]\n[pavel@ucw.cz: changelog addition]\n\nFixes: 2ba3e6947aed (\"mm/vmalloc: track which page-table levels were modified\")\nFixes: 86cf69f1d893 (\"x86/mm/32: implement arch_sync_kernel_mappings()\")\nSigned-off-by: Joerg Roedel <jroedel@suse.de>\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nTested-by: Chris Wilson <chris@chris-wilson.co.uk>\t[x86-32]\nTested-by: Pavel Machek <pavel@ucw.cz>\nAcked-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: <stable@vger.kernel.org>\t[5.8+]\nLink: https://lkml.kernel.org/r/20200821123746.16904-1-joro@8bytes.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memory.c||mm/memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/memory.c||mm/memory.c": [
          "File: mm/memory.c -> mm/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: #include <linux/numa.h>",
          "74: #include <linux/perf_event.h>",
          "75: #include <linux/ptrace.h>",
          "77: #include <trace/events/kmem.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76: #include <linux/vmalloc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83: #include <asm/tlb.h>",
          "84: #include <asm/tlbflush.h>",
          "86: #include \"internal.h\"",
          "88: #if defined(LAST_CPUPID_NOT_IN_PAGE_FLAGS) && !defined(CONFIG_COMPILE_TEST)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87: #include \"pgalloc-track.h\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2207: static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,",
          "2208:          unsigned long addr, unsigned long end,",
          "2210: {",
          "2211:  pte_t *pte;",
          "2212:  int err = 0;",
          "",
          "[Removed Lines]",
          "2209:          pte_fn_t fn, void *data, bool create)",
          "",
          "[Added Lines]",
          "2211:          pte_fn_t fn, void *data, bool create,",
          "2212:          pgtbl_mod_mask *mask)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2215:  if (create) {",
          "2216:   pte = (mm == &init_mm) ?",
          "2218:    pte_alloc_map_lock(mm, pmd, addr, &ptl);",
          "2219:   if (!pte)",
          "2220:    return -ENOMEM;",
          "",
          "[Removed Lines]",
          "2217:    pte_alloc_kernel(pmd, addr) :",
          "",
          "[Added Lines]",
          "2220:    pte_alloc_kernel_track(pmd, addr, mask) :",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2246: static int apply_to_pmd_range(struct mm_struct *mm, pud_t *pud,",
          "2247:          unsigned long addr, unsigned long end,",
          "2249: {",
          "2250:  pmd_t *pmd;",
          "2251:  unsigned long next;",
          "",
          "[Removed Lines]",
          "2248:          pte_fn_t fn, void *data, bool create)",
          "",
          "[Added Lines]",
          "2252:          pte_fn_t fn, void *data, bool create,",
          "2253:          pgtbl_mod_mask *mask)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2254:  BUG_ON(pud_huge(*pud));",
          "2256:  if (create) {",
          "2258:   if (!pmd)",
          "2259:    return -ENOMEM;",
          "2260:  } else {",
          "",
          "[Removed Lines]",
          "2257:   pmd = pmd_alloc(mm, pud, addr);",
          "",
          "[Added Lines]",
          "2262:   pmd = pmd_alloc_track(mm, pud, addr, mask);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2264:   next = pmd_addr_end(addr, end);",
          "2265:   if (create || !pmd_none_or_clear_bad(pmd)) {",
          "2266:    err = apply_to_pte_range(mm, pmd, addr, next, fn, data,",
          "2268:    if (err)",
          "2269:     break;",
          "2270:   }",
          "",
          "[Removed Lines]",
          "2267:        create);",
          "",
          "[Added Lines]",
          "2272:        create, mask);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2275: static int apply_to_pud_range(struct mm_struct *mm, p4d_t *p4d,",
          "2276:          unsigned long addr, unsigned long end,",
          "2278: {",
          "2279:  pud_t *pud;",
          "2280:  unsigned long next;",
          "2281:  int err = 0;",
          "2283:  if (create) {",
          "2285:   if (!pud)",
          "2286:    return -ENOMEM;",
          "2287:  } else {",
          "",
          "[Removed Lines]",
          "2277:          pte_fn_t fn, void *data, bool create)",
          "2284:   pud = pud_alloc(mm, p4d, addr);",
          "",
          "[Added Lines]",
          "2282:          pte_fn_t fn, void *data, bool create,",
          "2283:          pgtbl_mod_mask *mask)",
          "2290:   pud = pud_alloc_track(mm, p4d, addr, mask);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2291:   next = pud_addr_end(addr, end);",
          "2292:   if (create || !pud_none_or_clear_bad(pud)) {",
          "2293:    err = apply_to_pmd_range(mm, pud, addr, next, fn, data,",
          "2295:    if (err)",
          "2296:     break;",
          "2297:   }",
          "",
          "[Removed Lines]",
          "2294:        create);",
          "",
          "[Added Lines]",
          "2300:        create, mask);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2302: static int apply_to_p4d_range(struct mm_struct *mm, pgd_t *pgd,",
          "2303:          unsigned long addr, unsigned long end,",
          "2305: {",
          "2306:  p4d_t *p4d;",
          "2307:  unsigned long next;",
          "2308:  int err = 0;",
          "2310:  if (create) {",
          "2312:   if (!p4d)",
          "2313:    return -ENOMEM;",
          "2314:  } else {",
          "",
          "[Removed Lines]",
          "2304:          pte_fn_t fn, void *data, bool create)",
          "2311:   p4d = p4d_alloc(mm, pgd, addr);",
          "",
          "[Added Lines]",
          "2310:          pte_fn_t fn, void *data, bool create,",
          "2311:          pgtbl_mod_mask *mask)",
          "2318:   p4d = p4d_alloc_track(mm, pgd, addr, mask);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2318:   next = p4d_addr_end(addr, end);",
          "2319:   if (create || !p4d_none_or_clear_bad(p4d)) {",
          "2320:    err = apply_to_pud_range(mm, p4d, addr, next, fn, data,",
          "2322:    if (err)",
          "2323:     break;",
          "2324:   }",
          "",
          "[Removed Lines]",
          "2321:        create);",
          "",
          "[Added Lines]",
          "2328:        create, mask);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2331:      void *data, bool create)",
          "2332: {",
          "2333:  pgd_t *pgd;",
          "2335:  unsigned long end = addr + size;",
          "2336:  int err = 0;",
          "2338:  if (WARN_ON(addr >= end))",
          "",
          "[Removed Lines]",
          "2334:  unsigned long next;",
          "",
          "[Added Lines]",
          "2341:  unsigned long start = addr, next;",
          "2343:  pgtbl_mod_mask mask = 0;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2343:   next = pgd_addr_end(addr, end);",
          "2344:   if (!create && pgd_none_or_clear_bad(pgd))",
          "2345:    continue;",
          "2347:   if (err)",
          "2348:    break;",
          "2349:  } while (pgd++, addr = next, addr != end);",
          "2351:  return err;",
          "2352: }",
          "",
          "[Removed Lines]",
          "2346:   err = apply_to_p4d_range(mm, pgd, addr, next, fn, data, create);",
          "",
          "[Added Lines]",
          "2354:   err = apply_to_p4d_range(mm, pgd, addr, next, fn, data, create, &mask);",
          "2359:  if (mask & ARCH_PAGE_TABLE_SYNC_MASK)",
          "2360:   arch_sync_kernel_mappings(start, start + size);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f1e8ea726e9020e01e9e2ae29c2d5eb11133032",
      "candidate_info": {
        "commit_hash": "2f1e8ea726e9020e01e9e2ae29c2d5eb11133032",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2f1e8ea726e9020e01e9e2ae29c2d5eb11133032",
        "files": [
          "net/dsa/slave.c"
        ],
        "message": "net: dsa: link interfaces with the DSA master to get rid of lockdep warnings\n\nSince commit 845e0ebb4408 (\"net: change addr_list_lock back to static\nkey\"), cascaded DSA setups (DSA switch port as DSA master for another\nDSA switch port) are emitting this lockdep warning:\n\n============================================\nWARNING: possible recursive locking detected\n5.8.0-rc1-00133-g923e4b5032dd-dirty #208 Not tainted\n--------------------------------------------\ndhcpcd/323 is trying to acquire lock:\nffff000066dd4268 (&dsa_master_addr_list_lock_key/1){+...}-{2:2}, at: dev_mc_sync+0x44/0x90\n\nbut task is already holding lock:\nffff00006608c268 (&dsa_master_addr_list_lock_key/1){+...}-{2:2}, at: dev_mc_sync+0x44/0x90\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(&dsa_master_addr_list_lock_key/1);\n  lock(&dsa_master_addr_list_lock_key/1);\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n3 locks held by dhcpcd/323:\n #0: ffffdbd1381dda18 (rtnl_mutex){+.+.}-{3:3}, at: rtnl_lock+0x24/0x30\n #1: ffff00006614b268 (_xmit_ETHER){+...}-{2:2}, at: dev_set_rx_mode+0x28/0x48\n #2: ffff00006608c268 (&dsa_master_addr_list_lock_key/1){+...}-{2:2}, at: dev_mc_sync+0x44/0x90\n\nstack backtrace:\nCall trace:\n dump_backtrace+0x0/0x1e0\n show_stack+0x20/0x30\n dump_stack+0xec/0x158\n __lock_acquire+0xca0/0x2398\n lock_acquire+0xe8/0x440\n _raw_spin_lock_nested+0x64/0x90\n dev_mc_sync+0x44/0x90\n dsa_slave_set_rx_mode+0x34/0x50\n __dev_set_rx_mode+0x60/0xa0\n dev_mc_sync+0x84/0x90\n dsa_slave_set_rx_mode+0x34/0x50\n __dev_set_rx_mode+0x60/0xa0\n dev_set_rx_mode+0x30/0x48\n __dev_open+0x10c/0x180\n __dev_change_flags+0x170/0x1c8\n dev_change_flags+0x2c/0x70\n devinet_ioctl+0x774/0x878\n inet_ioctl+0x348/0x3b0\n sock_do_ioctl+0x50/0x310\n sock_ioctl+0x1f8/0x580\n ksys_ioctl+0xb0/0xf0\n __arm64_sys_ioctl+0x28/0x38\n el0_svc_common.constprop.0+0x7c/0x180\n do_el0_svc+0x2c/0x98\n el0_sync_handler+0x9c/0x1b8\n el0_sync+0x158/0x180\n\nSince DSA never made use of the netdev API for describing links between\nupper devices and lower devices, the dev->lower_level value of a DSA\nswitch interface would be 1, which would warn when it is a DSA master.\n\nWe can use netdev_upper_dev_link() to describe the relationship between\na DSA slave and a DSA master. To be precise, a DSA \"slave\" (switch port)\nis an \"upper\" to a DSA \"master\" (host port). The relationship is \"many\nuppers to one lower\", like in the case of VLAN. So, for that reason, we\nuse the same function as VLAN uses.\n\nThere might be a chance that somebody will try to take hold of this\ninterface and use it immediately after register_netdev() and before\nnetdev_upper_dev_link(). To avoid that, we do the registration and\nlinkage while holding the RTNL, and we use the RTNL-locked cousin of\nregister_netdev(), which is register_netdevice().\n\nSince this warning was not there when lockdep was using dynamic keys for\naddr_list_lock, we are blaming the lockdep patch itself. The network\nstack _has_ been using static lockdep keys before, and it _is_ likely\nthat stacked DSA setups have been triggering these lockdep warnings\nsince forever, however I can't test very old kernels on this particular\nstacked DSA setup, to ensure I'm not in fact introducing regressions.\n\nFixes: 845e0ebb4408 (\"net: change addr_list_lock back to static key\")\nSuggested-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: Vladimir Oltean <olteanv@gmail.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/dsslave.c||net/dsa/slave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/dsslave.c||net/dsa/slave.c": [
          "File: net/dsslave.c -> net/dsa/slave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1802:  rtnl_lock();",
          "1804:  ret = register_netdevice(slave_dev);",
          "1808:   rtnl_unlock();",
          "1812:  ret = netdev_upper_dev_link(master, slave_dev, NULL);",
          "1814:  rtnl_unlock();",
          "1816:  if (ret)",
          "1817:   goto out_unregister;",
          "1821: out_unregister:",
          "1822:  unregister_netdev(slave_dev);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1839:  struct net_device *master = dsa_slave_to_master(slave_dev);",
          "1845:  netdev_upper_dev_unlink(master, slave_dev);",
          "1846:  unregister_netdevice(slave_dev);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
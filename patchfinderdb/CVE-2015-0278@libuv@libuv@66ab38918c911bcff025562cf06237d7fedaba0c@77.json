{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c8e4db6e00186c7feb100027f518efb070431d80",
      "candidate_info": {
        "commit_hash": "c8e4db6e00186c7feb100027f518efb070431d80",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/c8e4db6e00186c7feb100027f518efb070431d80",
        "files": [
          "include/uv.h"
        ],
        "message": "include: mark close_cb field as private",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "500: #define UV_HANDLE_FIELDS                                                      \\",
          "503:   void* data;                                                                 \\",
          "505:   uv_loop_t* loop;                                                            \\",
          "506:   uv_handle_type type;                                                        \\",
          "508:   void* handle_queue[2];                                                      \\",
          "509:   UV_HANDLE_PRIVATE_FIELDS                                                    \\",
          "",
          "[Removed Lines]",
          "502:   uv_close_cb close_cb;                                                       \\",
          "",
          "[Added Lines]",
          "507:   uv_close_cb close_cb;                                                       \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "02e8c8ef65271d6252c6eaf1ba1271de29cf4a9e",
      "candidate_info": {
        "commit_hash": "02e8c8ef65271d6252c6eaf1ba1271de29cf4a9e",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/02e8c8ef65271d6252c6eaf1ba1271de29cf4a9e",
        "files": [
          "include/uv.h"
        ],
        "message": "include: clarify uv_tcp_bind() behavior\n\nOn BSD-like platforms, EADDRINUSE is returned by the bind() system call.\nOn other platforms, it's returned by the listen() system call.\n\nIn other words, some platforms are 'first to bind wins', others are\n'first to listen wins' - but only with TCP sockets: UNIX domain sockets\nalways return EADDRINUSE from the bind() system call, UDP sockets don't\ncall listen() in the first place.\n\nFixes #769.",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ]
      }
    },
    {
      "candidate_hash": "2d5eaea1cd6a6d1f83f7771d55288ad1dc2b3547",
      "candidate_info": {
        "commit_hash": "2d5eaea1cd6a6d1f83f7771d55288ad1dc2b3547",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/2d5eaea1cd6a6d1f83f7771d55288ad1dc2b3547",
        "files": [
          "include/uv-unix.h",
          "src/unix/loop.c",
          "src/unix/process.c"
        ],
        "message": "unix: simplify how process handle queue is managed",
        "before_after_code_files": [
          "include/uv-unix.h||include/uv-unix.h",
          "src/unix/loop.c||src/unix/loop.c",
          "src/unix/process.c||src/unix/process.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [
            "src/unix/process.c||src/unix/process.c"
          ],
          "candidate": [
            "src/unix/process.c||src/unix/process.c"
          ]
        }
      },
      "candidate_diff": {
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:   uv_async_t wq_async;                                                        \\",
          "220:   uv_rwlock_t cloexec_lock;                                                   \\",
          "221:   uv_handle_t* closing_handles;                                               \\",
          "223:   void* prepare_handles[2];                                                   \\",
          "224:   void* check_handles[2];                                                     \\",
          "225:   void* idle_handles[2];                                                      \\",
          "",
          "[Removed Lines]",
          "222:   void* process_handles[1][2];                                                \\",
          "",
          "[Added Lines]",
          "222:   void* process_handles[2];                                                   \\",
          "",
          "---------------"
        ],
        "src/unix/loop.c||src/unix/loop.c": [
          "File: src/unix/loop.c -> src/unix/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: static int uv__loop_init(uv_loop_t* loop, int default_loop) {",
          "103:   int err;",
          "105:   uv__signal_global_once_init();",
          "",
          "[Removed Lines]",
          "102:   unsigned int i;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:   uv_signal_init(loop, &loop->child_watcher);",
          "139:   uv__handle_unref(&loop->child_watcher);",
          "140:   loop->child_watcher.flags |= UV__HANDLE_INTERNAL;",
          "145:   if (uv_rwlock_init(&loop->cloexec_lock))",
          "146:     abort();",
          "",
          "[Removed Lines]",
          "142:   for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++)",
          "143:     QUEUE_INIT(loop->process_handles + i);",
          "",
          "[Added Lines]",
          "140:   QUEUE_INIT(&loop->process_handles);",
          "",
          "---------------"
        ],
        "src/unix/process.c||src/unix/process.c": [
          "File: src/unix/process.c -> src/unix/process.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: #endif",
          "54: static void uv__chld(uv_signal_t* handle, int signum) {",
          "55:   uv_process_t* process;",
          "56:   uv_loop_t* loop;",
          "57:   int exit_status;",
          "58:   int term_signal;",
          "60:   int status;",
          "61:   pid_t pid;",
          "62:   QUEUE pending;",
          "64:   QUEUE* q;",
          "66:   assert(signum == SIGCHLD);",
          "68:   QUEUE_INIT(&pending);",
          "69:   loop = handle->loop;",
          "95:     }",
          "118:   }",
          "119: }",
          "",
          "[Removed Lines]",
          "48: static QUEUE* uv__process_queue(uv_loop_t* loop, int pid) {",
          "49:   assert(pid > 0);",
          "50:   return loop->process_handles + pid % ARRAY_SIZE(loop->process_handles);",
          "51: }",
          "59:   unsigned int i;",
          "63:   QUEUE* h;",
          "71:   for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++) {",
          "72:     h = loop->process_handles + i;",
          "73:     q = QUEUE_HEAD(h);",
          "75:     while (q != h) {",
          "76:       process = QUEUE_DATA(q, uv_process_t, queue);",
          "77:       q = QUEUE_NEXT(q);",
          "79:       do",
          "80:         pid = waitpid(process->pid, &status, WNOHANG);",
          "81:       while (pid == -1 && errno == EINTR);",
          "83:       if (pid == 0)",
          "84:         continue;",
          "86:       if (pid == -1) {",
          "87:         if (errno != ECHILD)",
          "88:           abort();",
          "89:         continue;",
          "90:       }",
          "92:       process->status = status;",
          "93:       QUEUE_REMOVE(&process->queue);",
          "94:       QUEUE_INSERT_TAIL(&pending, &process->queue);",
          "97:     while (!QUEUE_EMPTY(&pending)) {",
          "98:       q = QUEUE_HEAD(&pending);",
          "99:       QUEUE_REMOVE(q);",
          "100:       QUEUE_INIT(q);",
          "102:       process = QUEUE_DATA(q, uv_process_t, queue);",
          "103:       uv__handle_stop(process);",
          "105:       if (process->exit_cb == NULL)",
          "106:         continue;",
          "108:       exit_status = 0;",
          "109:       if (WIFEXITED(process->status))",
          "110:         exit_status = WEXITSTATUS(process->status);",
          "112:       term_signal = 0;",
          "113:       if (WIFSIGNALED(process->status))",
          "114:         term_signal = WTERMSIG(process->status);",
          "116:       process->exit_cb(process, exit_status, term_signal);",
          "117:     }",
          "",
          "[Added Lines]",
          "57:   QUEUE* h;",
          "64:   h = &loop->process_handles;",
          "65:   q = QUEUE_HEAD(h);",
          "66:   while (q != h) {",
          "67:     process = QUEUE_DATA(q, uv_process_t, queue);",
          "68:     q = QUEUE_NEXT(q);",
          "70:     do",
          "71:       pid = waitpid(process->pid, &status, WNOHANG);",
          "72:     while (pid == -1 && errno == EINTR);",
          "74:     if (pid == 0)",
          "75:       continue;",
          "77:     if (pid == -1) {",
          "78:       if (errno != ECHILD)",
          "79:         abort();",
          "80:       continue;",
          "83:     process->status = status;",
          "84:     QUEUE_REMOVE(&process->queue);",
          "85:     QUEUE_INSERT_TAIL(&pending, &process->queue);",
          "86:   }",
          "88:   QUEUE_FOREACH(q, &pending) {",
          "89:     process = QUEUE_DATA(q, uv_process_t, queue);",
          "90:     QUEUE_REMOVE(q);",
          "91:     uv__handle_stop(process);",
          "93:     if (process->exit_cb == NULL)",
          "94:       continue;",
          "96:     exit_status = 0;",
          "97:     if (WIFEXITED(process->status))",
          "98:       exit_status = WEXITSTATUS(process->status);",
          "100:     term_signal = 0;",
          "101:     if (WIFSIGNALED(process->status))",
          "102:       term_signal = WTERMSIG(process->status);",
          "104:     process->exit_cb(process, exit_status, term_signal);",
          "106:   assert(QUEUE_EMPTY(&pending));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:   int signal_pipe[2] = { -1, -1 };",
          "370:   int (*pipes)[2];",
          "371:   int stdio_count;",
          "373:   ssize_t r;",
          "374:   pid_t pid;",
          "375:   int err;",
          "",
          "[Removed Lines]",
          "372:   QUEUE* q;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "485:   if (exec_errorno == 0) {",
          "488:     uv__handle_start(process);",
          "489:   }",
          "",
          "[Removed Lines]",
          "486:     q = uv__process_queue(loop, pid);",
          "487:     QUEUE_INSERT_TAIL(q, &process->queue);",
          "",
          "[Added Lines]",
          "473:     QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e74e2ceca0cf5825f046b52e559f8291ee8bd18",
      "candidate_info": {
        "commit_hash": "2e74e2ceca0cf5825f046b52e559f8291ee8bd18",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/2e74e2ceca0cf5825f046b52e559f8291ee8bd18",
        "files": [
          "src/win/pipe.c",
          "src/win/process-stdio.c"
        ],
        "message": "windows: make uv_shutdown() for write-only pipes work\n\nA couple of issues prevented uv_shutdown() from working correctly with\nwrite-only pipes.\n\n  * The pipe handle wasn't opened with the right permissions, so an\n    attempt to probe the state of the write buffer would fail with\n    ERROR_ACCESS_DENIED.\n\n  * The pipe flags for child process stdio pipes were always set to\n    UV_HANDLE_READABLE and UV_HANDLE_WRITABLE, even in cases where it\n    was actually half-duplex.\n\n  * There was no code path that lead to closing the pipe handle if the\n    pipe was write-only.",
        "before_after_code_files": [
          "src/win/pipe.c||src/win/pipe.c",
          "src/win/process-stdio.c||src/win/process-stdio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1604:     if (handle->flags & UV_HANDLE_READ_PENDING) {",
          "1605:       eof_timer_start(handle);",
          "1606:     }",
          "1607:   }",
          "1609:   if (req->cb) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1608:   } else {",
          "1611:     CloseHandle(handle->handle);",
          "1612:     handle->handle = INVALID_HANDLE_VALUE;",
          "",
          "---------------"
        ],
        "src/win/process-stdio.c||src/win/process-stdio.c": [
          "File: src/win/process-stdio.c -> src/win/process-stdio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "104:   int err;",
          "106:   if (flags & UV_READABLE_PIPE) {",
          "108:     client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;",
          "109:   }",
          "110:   if (flags & UV_WRITABLE_PIPE) {",
          "111:     server_access |= PIPE_ACCESS_INBOUND;",
          "113:   }",
          "",
          "[Removed Lines]",
          "107:     server_access |= PIPE_ACCESS_OUTBOUND;",
          "112:     client_access |= GENERIC_WRITE;",
          "",
          "[Added Lines]",
          "111:     server_access |= PIPE_ACCESS_OUTBOUND | PIPE_ACCESS_INBOUND;",
          "116:     client_access |= GENERIC_WRITE | FILE_READ_ATTRIBUTES;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:     }",
          "164:   }",
          "170:   return 0;",
          "",
          "[Removed Lines]",
          "167:   server_pipe->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;",
          "",
          "[Added Lines]",
          "171:   if (flags & UV_READABLE_PIPE)",
          "172:     server_pipe->flags |= UV_HANDLE_WRITABLE;",
          "173:   if (flags & UV_WRITABLE_PIPE)",
          "174:     server_pipe->flags |= UV_HANDLE_READABLE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6c6c9221679c6cc66ac30fbad5ce086658113ea3",
      "candidate_info": {
        "commit_hash": "6c6c9221679c6cc66ac30fbad5ce086658113ea3",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6c6c9221679c6cc66ac30fbad5ce086658113ea3",
        "files": [
          "test/test-barrier.c"
        ],
        "message": "test: make barrier test more rigorous\n\nA correct barriers implementation blocks in uv_barrier_destroy() until\nthe last thread returns from uv_barrier_wait() so make the test more\nrigorous by destroying the barrier straight away instead of first\njoining the worker thread.\n\nSigned-off-by: Fedor Indutny <fedor@indutny.com>",
        "before_after_code_files": [
          "test/test-barrier.c||test/test-barrier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-barrier.c||test/test-barrier.c": [
          "File: test/test-barrier.c -> test/test-barrier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     uv_sleep(c->delay);",
          "43:   c->worker_barrier_wait_rval = uv_barrier_wait(&c->barrier);",
          "44: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:   if (c->worker_barrier_wait_rval == 1) {",
          "45:     uv_barrier_destroy(&c->barrier);",
          "46:     ASSERT(c->main_barrier_wait_rval == 0);",
          "47:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:   worker_config wc;",
          "51:   memset(&wc, 0, sizeof(wc));",
          "53:   ASSERT(0 == uv_barrier_init(&wc.barrier, 2));",
          "54:   ASSERT(0 == uv_thread_create(&thread, worker, &wc));",
          "56:   uv_sleep(100);",
          "57:   wc.main_barrier_wait_rval = uv_barrier_wait(&wc.barrier);",
          "59:   ASSERT(0 == uv_thread_join(&thread));",
          "62:   ASSERT(1 == (wc.main_barrier_wait_rval ^ wc.worker_barrier_wait_rval));",
          "64:   return 0;",
          "",
          "[Removed Lines]",
          "60:   uv_barrier_destroy(&wc.barrier);",
          "",
          "[Added Lines]",
          "56:   wc.main_barrier_wait_rval = -1;",
          "57:   wc.worker_barrier_wait_rval = -1;",
          "65:   if (wc.main_barrier_wait_rval == 1) {",
          "66:     uv_barrier_destroy(&wc.barrier);",
          "67:     ASSERT(wc.worker_barrier_wait_rval == 0);",
          "68:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72:   memset(&wc, 0, sizeof(wc));",
          "73:   wc.delay = 100;",
          "75:   ASSERT(0 == uv_barrier_init(&wc.barrier, 2));",
          "76:   ASSERT(0 == uv_thread_create(&thread, worker, &wc));",
          "78:   wc.main_barrier_wait_rval = uv_barrier_wait(&wc.barrier);",
          "80:   ASSERT(0 == uv_thread_join(&thread));",
          "83:   ASSERT(1 == (wc.main_barrier_wait_rval ^ wc.worker_barrier_wait_rval));",
          "85:   return 0;",
          "",
          "[Removed Lines]",
          "81:   uv_barrier_destroy(&wc.barrier);",
          "",
          "[Added Lines]",
          "83:   wc.main_barrier_wait_rval = -1;",
          "84:   wc.worker_barrier_wait_rval = -1;",
          "90:   if (wc.main_barrier_wait_rval == 1) {",
          "91:     uv_barrier_destroy(&wc.barrier);",
          "92:     ASSERT(wc.worker_barrier_wait_rval == 0);",
          "93:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91:   worker_config wc;",
          "93:   memset(&wc, 0, sizeof(wc));",
          "95:   ASSERT(0 == uv_barrier_init(&wc.barrier, 2));",
          "96:   ASSERT(0 == uv_thread_create(&thread, worker, &wc));",
          "98:   wc.main_barrier_wait_rval = uv_barrier_wait(&wc.barrier);",
          "100:   ASSERT(0 == uv_thread_join(&thread));",
          "103:   ASSERT(1 == (wc.main_barrier_wait_rval ^ wc.worker_barrier_wait_rval));",
          "105:   return 0;",
          "",
          "[Removed Lines]",
          "101:   uv_barrier_destroy(&wc.barrier);",
          "",
          "[Added Lines]",
          "107:   wc.main_barrier_wait_rval = -1;",
          "108:   wc.worker_barrier_wait_rval = -1;",
          "114:   if (wc.main_barrier_wait_rval == 1) {",
          "115:     uv_barrier_destroy(&wc.barrier);",
          "116:     ASSERT(wc.worker_barrier_wait_rval == 0);",
          "117:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-12192",
  "cve_desc": "The keyctl_read_key function in security/keys/keyctl.c in the Key Management subcomponent in the Linux kernel before 4.13.5 does not properly consider that a key may be possessed but negatively instantiated, which allows local users to cause a denial of service (OOPS and system crash) via a crafted KEYCTL_READ operation.",
  "repo": "torvalds/linux",
  "patch_hash": "37863c43b2c6464f252862bf2e9768264e961678",
  "patch_info": {
    "commit_hash": "37863c43b2c6464f252862bf2e9768264e961678",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678",
    "files": [
      "security/keys/keyctl.c"
    ],
    "message": "KEYS: prevent KEYCTL_READ on negative key\n\nBecause keyctl_read_key() looks up the key with no permissions\nrequested, it may find a negatively instantiated key.  If the key is\nalso possessed, we went ahead and called ->read() on the key.  But the\nkey payload will actually contain the ->reject_error rather than the\nnormal payload.  Thus, the kernel oopses trying to read the\nuser_key_payload from memory address (int)-ENOKEY = 0x00000000ffffff82.\n\nFortunately the payload data is stored inline, so it shouldn't be\npossible to abuse this as an arbitrary memory read primitive...\n\nReproducer:\n    keyctl new_session\n    keyctl request2 user desc '' @s\n    keyctl read $(keyctl show | awk '/user: desc/ {print $1}')\n\nIt causes a crash like the following:\n     BUG: unable to handle kernel paging request at 00000000ffffff92\n     IP: user_read+0x33/0xa0\n     PGD 36a54067 P4D 36a54067 PUD 0\n     Oops: 0000 [#1] SMP\n     CPU: 0 PID: 211 Comm: keyctl Not tainted 4.14.0-rc1 #337\n     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-20170228_101828-anatol 04/01/2014\n     task: ffff90aa3b74c3c0 task.stack: ffff9878c0478000\n     RIP: 0010:user_read+0x33/0xa0\n     RSP: 0018:ffff9878c047bee8 EFLAGS: 00010246\n     RAX: 0000000000000001 RBX: ffff90aa3d7da340 RCX: 0000000000000017\n     RDX: 0000000000000000 RSI: 00000000ffffff82 RDI: ffff90aa3d7da340\n     RBP: ffff9878c047bf00 R08: 00000024f95da94f R09: 0000000000000000\n     R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000\n     R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n     FS:  00007f58ece69740(0000) GS:ffff90aa3e200000(0000) knlGS:0000000000000000\n     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n     CR2: 00000000ffffff92 CR3: 0000000036adc001 CR4: 00000000003606f0\n     Call Trace:\n      keyctl_read_key+0xac/0xe0\n      SyS_keyctl+0x99/0x120\n      entry_SYSCALL_64_fastpath+0x1f/0xbe\n     RIP: 0033:0x7f58ec787bb9\n     RSP: 002b:00007ffc8d401678 EFLAGS: 00000206 ORIG_RAX: 00000000000000fa\n     RAX: ffffffffffffffda RBX: 00007ffc8d402800 RCX: 00007f58ec787bb9\n     RDX: 0000000000000000 RSI: 00000000174a63ac RDI: 000000000000000b\n     RBP: 0000000000000004 R08: 00007ffc8d402809 R09: 0000000000000020\n     R10: 0000000000000000 R11: 0000000000000206 R12: 00007ffc8d402800\n     R13: 00007ffc8d4016e0 R14: 0000000000000000 R15: 0000000000000000\n     Code: e5 41 55 49 89 f5 41 54 49 89 d4 53 48 89 fb e8 a4 b4 ad ff 85 c0 74 09 80 3d b9 4c 96 00 00 74 43 48 8b b3 20 01 00 00 4d 85 ed <0f> b7 5e 10 74 29 4d 85 e4 74 24 4c 39 e3 4c 89 e2 4c 89 ef 48\n     RIP: user_read+0x33/0xa0 RSP: ffff9878c047bee8\n     CR2: 00000000ffffff92\n\nFixes: 61ea0c0ba904 (\"KEYS: Skip key state checks when checking for possession\")\nCc: <stable@vger.kernel.org>\t[v3.13+]\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
    "before_after_code_files": [
      "security/keys/keyctl.c||security/keys/keyctl.c"
    ]
  },
  "patch_diff": {
    "security/keys/keyctl.c||security/keys/keyctl.c": [
      "File: security/keys/keyctl.c -> security/keys/keyctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "767:  key = key_ref_to_ptr(key_ref);",
      "770:  ret = key_permission(key_ref, KEY_NEED_READ);",
      "771:  if (ret == 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "769:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {",
      "770:   ret = -ENOKEY;",
      "771:   goto error2;",
      "772:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "363b02dab09b3226f3bd1420dad9c72b79a42a76",
      "candidate_info": {
        "commit_hash": "363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "files": [
          "include/linux/key.h",
          "net/dns_resolver/dns_key.c",
          "security/keys/big_key.c",
          "security/keys/encrypted-keys/encrypted.c",
          "security/keys/gc.c",
          "security/keys/key.c",
          "security/keys/keyctl.c",
          "security/keys/keyring.c",
          "security/keys/proc.c",
          "security/keys/process_keys.c",
          "security/keys/request_key.c",
          "security/keys/request_key_auth.c",
          "security/keys/trusted.c",
          "security/keys/user_defined.c"
        ],
        "message": "KEYS: Fix race between updating and finding a negative key\n\nConsolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection\nerror into one field such that:\n\n (1) The instantiation state can be modified/read atomically.\n\n (2) The error can be accessed atomically with the state.\n\n (3) The error isn't stored unioned with the payload pointers.\n\nThis deals with the problem that the state is spread over three different\nobjects (two bits and a separate variable) and reading or updating them\natomically isn't practical, given that not only can uninstantiated keys\nchange into instantiated or rejected keys, but rejected keys can also turn\ninto instantiated keys - and someone accessing the key might not be using\nany locking.\n\nThe main side effect of this problem is that what was held in the payload\nmay change, depending on the state.  For instance, you might observe the\nkey to be in the rejected state.  You then read the cached error, but if\nthe key semaphore wasn't locked, the key might've become instantiated\nbetween the two reads - and you might now have something in hand that isn't\nactually an error code.\n\nThe state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error\ncode if the key is negatively instantiated.  The key_is_instantiated()\nfunction is replaced with key_is_positive() to avoid confusion as negative\nkeys are also 'instantiated'.\n\nAdditionally, barriering is included:\n\n (1) Order payload-set before state-set during instantiation.\n\n (2) Order state-read before payload-read when using the key.\n\nFurther separate barriering is necessary if RCU is being used to access the\npayload content after reading the payload pointers.\n\nFixes: 146aa8b1453b (\"KEYS: Merge the type-specific data with the payload data\")\nCc: stable@vger.kernel.org # v4.4+\nReported-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>",
        "before_after_code_files": [
          "include/linux/key.h||include/linux/key.h",
          "net/dns_resolver/dns_key.c||net/dns_resolver/dns_key.c",
          "security/keys/big_key.c||security/keys/big_key.c",
          "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c",
          "security/keys/gc.c||security/keys/gc.c",
          "security/keys/key.c||security/keys/key.c",
          "security/keys/keyctl.c||security/keys/keyctl.c",
          "security/keys/keyring.c||security/keys/keyring.c",
          "security/keys/proc.c||security/keys/proc.c",
          "security/keys/process_keys.c||security/keys/process_keys.c",
          "security/keys/request_key.c||security/keys/request_key.c",
          "security/keys/request_key_auth.c||security/keys/request_key_auth.c",
          "security/keys/trusted.c||security/keys/trusted.c",
          "security/keys/user_defined.c||security/keys/user_defined.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "security/keys/keyctl.c||security/keys/keyctl.c"
          ],
          "candidate": [
            "security/keys/keyctl.c||security/keys/keyctl.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/key.h||include/linux/key.h": [
          "File: include/linux/key.h -> include/linux/key.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:  struct key_type *keytype;",
          "139: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: enum key_state {",
          "142:  KEY_IS_UNINSTANTIATED,",
          "144: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:    struct list_head name_link;",
          "214:    struct assoc_array keys;",
          "215:   };",
          "217:  };",
          "",
          "[Removed Lines]",
          "216:   int reject_error;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "364: {",
          "367: }",
          "369: #define dereference_key_rcu(KEY)     \\",
          "",
          "[Removed Lines]",
          "363: static inline bool key_is_instantiated(const struct key *key)",
          "365:  return test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&",
          "366:   !test_bit(KEY_FLAG_NEGATIVE, &key->flags);",
          "",
          "[Added Lines]",
          "359: static inline short key_read_state(const struct key *key)",
          "360: {",
          "362:  return smp_load_acquire(&key->state);",
          "363: }",
          "372: static inline bool key_is_positive(const struct key *key)",
          "373: {",
          "374:  return key_read_state(key) == KEY_IS_POSITIVE;",
          "375: }",
          "377: static inline bool key_is_negative(const struct key *key)",
          "379:  return key_read_state(key) < 0;",
          "",
          "---------------"
        ],
        "net/dns_resolver/dns_key.c||net/dns_resolver/dns_key.c": [
          "File: net/dns_resolver/dns_key.c -> net/dns_resolver/dns_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "224: static void dns_resolver_describe(const struct key *key, struct seq_file *m)",
          "225: {",
          "226:  seq_puts(m, key->description);",
          "228:   int err = PTR_ERR(key->payload.data[dns_key_error]);",
          "230:   if (err)",
          "",
          "[Removed Lines]",
          "227:  if (key_is_instantiated(key)) {",
          "",
          "[Added Lines]",
          "227:  if (key_is_positive(key)) {",
          "",
          "---------------"
        ],
        "security/keys/big_key.c||security/keys/big_key.c": [
          "File: security/keys/big_key.c -> security/keys/big_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "249:  key_payload_reserve(key, 0);",
          "251:      (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)",
          "252:   vfs_truncate(path, 0);",
          "253: }",
          "",
          "[Removed Lines]",
          "250:  if (key_is_instantiated(key) &&",
          "",
          "[Added Lines]",
          "250:  if (key_is_positive(key) &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "280:  seq_puts(m, key->description);",
          "283:   seq_printf(m, \": %zu [%s]\",",
          "284:       datalen,",
          "285:       datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");",
          "",
          "[Removed Lines]",
          "282:  if (key_is_instantiated(key))",
          "",
          "[Added Lines]",
          "282:  if (key_is_positive(key))",
          "",
          "---------------"
        ],
        "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c": [
          "File: security/keys/encrypted-keys/encrypted.c -> security/keys/encrypted-keys/encrypted.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "854:  size_t datalen = prep->datalen;",
          "855:  int ret = 0;",
          "858:   return -ENOKEY;",
          "859:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
          "860:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "857:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
          "",
          "[Added Lines]",
          "857:  if (key_is_negative(key))",
          "",
          "---------------"
        ],
        "security/keys/gc.c||security/keys/gc.c": [
          "File: security/keys/gc.c -> security/keys/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:  while (!list_empty(keys)) {",
          "130:   struct key *key =",
          "131:    list_entry(keys->next, struct key, graveyard_link);",
          "132:   list_del(&key->graveyard_link);",
          "134:   kdebug(\"- %u\", key->serial);",
          "135:   key_check(key);",
          "141:    key->type->destroy(key);",
          "143:   security_key_free(key);",
          "",
          "[Removed Lines]",
          "138:   if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&",
          "139:       !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&",
          "140:       key->type->destroy)",
          "",
          "[Added Lines]",
          "132:   short state = key->state;",
          "140:   if (state == KEY_IS_POSITIVE && key->type->destroy)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:   }",
          "153:   atomic_dec(&key->user->nkeys);",
          "155:    atomic_dec(&key->user->nikeys);",
          "157:   key_user_put(key->user);",
          "",
          "[Removed Lines]",
          "154:   if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))",
          "",
          "[Added Lines]",
          "154:   if (state != KEY_IS_UNINSTANTIATED)",
          "",
          "---------------"
        ],
        "security/keys/key.c||security/keys/key.c": [
          "File: security/keys/key.c -> security/keys/key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: }",
          "402: EXPORT_SYMBOL(key_payload_reserve);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "407: static void mark_key_instantiated(struct key *key, int reject_error)",
          "408: {",
          "412:  smp_store_release(&key->state,",
          "413:      (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);",
          "414: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "424:  mutex_lock(&key_construction_mutex);",
          "429:   ret = key->type->instantiate(key, prep);",
          "431:   if (ret == 0) {",
          "433:    atomic_inc(&key->user->nikeys);",
          "436:    if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))",
          "437:     awaken = 1;",
          "",
          "[Removed Lines]",
          "427:  if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {",
          "434:    set_bit(KEY_FLAG_INSTANTIATED, &key->flags);",
          "",
          "[Added Lines]",
          "439:  if (key->state == KEY_IS_UNINSTANTIATED) {",
          "446:    mark_key_instantiated(key, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "577:  mutex_lock(&key_construction_mutex);",
          "582:   atomic_inc(&key->user->nikeys);",
          "587:   now = current_kernel_time();",
          "588:   key->expiry = now.tv_sec + timeout;",
          "589:   key_schedule_gc(key->expiry + key_gc_delay);",
          "",
          "[Removed Lines]",
          "580:  if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {",
          "583:   key->reject_error = -error;",
          "584:   smp_wmb();",
          "585:   set_bit(KEY_FLAG_NEGATIVE, &key->flags);",
          "586:   set_bit(KEY_FLAG_INSTANTIATED, &key->flags);",
          "",
          "[Added Lines]",
          "592:  if (key->state == KEY_IS_UNINSTANTIATED) {",
          "595:   mark_key_instantiated(key, -error);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "753:  ret = key->type->update(key, prep);",
          "754:  if (ret == 0)",
          "758:  up_write(&key->sem);",
          "",
          "[Removed Lines]",
          "756:   clear_bit(KEY_FLAG_NEGATIVE, &key->flags);",
          "",
          "[Added Lines]",
          "765:   mark_key_instantiated(key, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "987:  ret = key->type->update(key, &prep);",
          "988:  if (ret == 0)",
          "992:  up_write(&key->sem);",
          "",
          "[Removed Lines]",
          "990:   clear_bit(KEY_FLAG_NEGATIVE, &key->flags);",
          "",
          "[Added Lines]",
          "999:   mark_key_instantiated(key, 0);",
          "",
          "---------------"
        ],
        "security/keys/keyctl.c||security/keys/keyctl.c": [
          "File: security/keys/keyctl.c -> security/keys/keyctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "767:  key = key_ref_to_ptr(key_ref);",
          "775:  ret = key_permission(key_ref, KEY_NEED_READ);",
          "",
          "[Removed Lines]",
          "769:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {",
          "770:   ret = -ENOKEY;",
          "771:   goto error2;",
          "772:  }",
          "",
          "[Added Lines]",
          "769:  ret = key_read_state(key);",
          "770:  if (ret < 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "901:   atomic_dec(&key->user->nkeys);",
          "902:   atomic_inc(&newowner->nkeys);",
          "905:    atomic_dec(&key->user->nikeys);",
          "906:    atomic_inc(&newowner->nikeys);",
          "907:   }",
          "",
          "[Removed Lines]",
          "904:   if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {",
          "",
          "[Added Lines]",
          "903:   if (key->state != KEY_IS_UNINSTANTIATED) {",
          "",
          "---------------"
        ],
        "security/keys/keyring.c||security/keys/keyring.c": [
          "File: security/keys/keyring.c -> security/keys/keyring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "414:  else",
          "415:   seq_puts(m, \"[anon]\");",
          "418:   if (keyring->keys.nr_leaves_on_tree != 0)",
          "419:    seq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);",
          "420:   else",
          "",
          "[Removed Lines]",
          "417:  if (key_is_instantiated(keyring)) {",
          "",
          "[Added Lines]",
          "417:  if (key_is_positive(keyring)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "553: {",
          "554:  struct keyring_search_context *ctx = iterator_data;",
          "555:  const struct key *key = keyring_ptr_to_key(object);",
          "558:  kenter(\"{%d}\", key->serial);",
          "",
          "[Removed Lines]",
          "556:  unsigned long kflags = key->flags;",
          "",
          "[Added Lines]",
          "556:  unsigned long kflags = READ_ONCE(key->flags);",
          "557:  short state = READ_ONCE(key->state);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "598:  if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {",
          "603:    kleave(\" = %d [neg]\", ctx->skipped_ret);",
          "604:    goto skipped;",
          "605:   }",
          "",
          "[Removed Lines]",
          "600:   if (kflags & (1 << KEY_FLAG_NEGATIVE)) {",
          "601:    smp_rmb();",
          "602:    ctx->result = ERR_PTR(key->reject_error);",
          "",
          "[Added Lines]",
          "601:   if (state < 0) {",
          "602:    ctx->result = ERR_PTR(state);",
          "",
          "---------------"
        ],
        "security/keys/proc.c||security/keys/proc.c": [
          "File: security/keys/proc.c -> security/keys/proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:  unsigned long timo;",
          "183:  key_ref_t key_ref, skey_ref;",
          "184:  char xbuf[16];",
          "185:  int rc;",
          "187:  struct keyring_search_context ctx = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185:  short state;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236:    sprintf(xbuf, \"%luw\", timo / (60*60*24*7));",
          "237:  }",
          "239: #define showflag(KEY, LETTER, FLAG) \\",
          "240:  (test_bit(FLAG, &(KEY)->flags) ? LETTER : '-')",
          "242:  seq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",",
          "243:      key->serial,",
          "245:      showflag(key, 'R', KEY_FLAG_REVOKED),",
          "246:      showflag(key, 'D', KEY_FLAG_DEAD),",
          "247:      showflag(key, 'Q', KEY_FLAG_IN_QUOTA),",
          "248:      showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),",
          "250:      showflag(key, 'i', KEY_FLAG_INVALIDATED),",
          "251:      refcount_read(&key->usage),",
          "252:      xbuf,",
          "",
          "[Removed Lines]",
          "244:      showflag(key, 'I', KEY_FLAG_INSTANTIATED),",
          "249:      showflag(key, 'N', KEY_FLAG_NEGATIVE),",
          "",
          "[Added Lines]",
          "240:  state = key_read_state(key);",
          "247:      state != KEY_IS_UNINSTANTIATED ? 'I' : '-',",
          "252:      state < 0 ? 'N' : '-',",
          "",
          "---------------"
        ],
        "security/keys/process_keys.c||security/keys/process_keys.c": [
          "File: security/keys/process_keys.c -> security/keys/process_keys.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "731:  ret = -EIO;",
          "732:  if (!(lflags & KEY_LOOKUP_PARTIAL) &&",
          "734:   goto invalid_key;",
          "",
          "[Removed Lines]",
          "733:      !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))",
          "",
          "[Added Lines]",
          "733:      key_read_state(key) == KEY_IS_UNINSTANTIATED)",
          "",
          "---------------"
        ],
        "security/keys/request_key.c||security/keys/request_key.c": [
          "File: security/keys/request_key.c -> security/keys/request_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "595:      intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);",
          "596:  if (ret)",
          "597:   return -ERESTARTSYS;",
          "602:  return key_validate(key);",
          "603: }",
          "604: EXPORT_SYMBOL(wait_for_key_construction);",
          "",
          "[Removed Lines]",
          "598:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {",
          "599:   smp_rmb();",
          "600:   return key->reject_error;",
          "601:  }",
          "",
          "[Added Lines]",
          "598:  ret = key_read_state(key);",
          "599:  if (ret < 0)",
          "600:   return ret;",
          "",
          "---------------"
        ],
        "security/keys/request_key_auth.c||security/keys/request_key_auth.c": [
          "File: security/keys/request_key_auth.c -> security/keys/request_key_auth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:  seq_puts(m, \"key:\");",
          "75:  seq_puts(m, key->description);",
          "77:   seq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);",
          "78: }",
          "",
          "[Removed Lines]",
          "76:  if (key_is_instantiated(key))",
          "",
          "[Added Lines]",
          "76:  if (key_is_positive(key))",
          "",
          "---------------"
        ],
        "security/keys/trusted.c||security/keys/trusted.c": [
          "File: security/keys/trusted.c -> security/keys/trusted.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1066:  char *datablob;",
          "1067:  int ret = 0;",
          "1070:   return -ENOKEY;",
          "1071:  p = key->payload.data[0];",
          "1072:  if (!p->migratable)",
          "",
          "[Removed Lines]",
          "1069:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
          "",
          "[Added Lines]",
          "1069:  if (key_is_negative(key))",
          "",
          "---------------"
        ],
        "security/keys/user_defined.c||security/keys/user_defined.c": [
          "File: security/keys/user_defined.c -> security/keys/user_defined.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:  key->expiry = prep->expiry;",
          "118:   zap = dereference_key_locked(key);",
          "119:  rcu_assign_keypointer(key, prep->payload.data[0]);",
          "120:  prep->payload.data[0] = NULL;",
          "",
          "[Removed Lines]",
          "117:  if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
          "",
          "[Added Lines]",
          "117:  if (key_is_positive(key))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162: void user_describe(const struct key *key, struct seq_file *m)",
          "163: {",
          "164:  seq_puts(m, key->description);",
          "166:   seq_printf(m, \": %u\", key->datalen);",
          "167: }",
          "",
          "[Removed Lines]",
          "165:  if (key_is_instantiated(key))",
          "",
          "[Added Lines]",
          "165:  if (key_is_positive(key))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
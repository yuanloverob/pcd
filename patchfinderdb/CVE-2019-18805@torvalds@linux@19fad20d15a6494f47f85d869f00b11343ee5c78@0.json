{
  "cve_id": "CVE-2019-18805",
  "cve_desc": "An issue was discovered in net/ipv4/sysctl_net_ipv4.c in the Linux kernel before 5.0.11. There is a net/ipv4/tcp_input.c signed integer overflow in tcp_ack_update_rtt() when userspace writes a very large integer to /proc/sys/net/ipv4/tcp_min_rtt_wlen, leading to a denial of service or possibly unspecified other impact, aka CID-19fad20d15a6.",
  "repo": "torvalds/linux",
  "patch_hash": "19fad20d15a6494f47f85d869f00b11343ee5c78",
  "patch_info": {
    "commit_hash": "19fad20d15a6494f47f85d869f00b11343ee5c78",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/19fad20d15a6494f47f85d869f00b11343ee5c78",
    "files": [
      "Documentation/networking/ip-sysctl.txt",
      "net/ipv4/sysctl_net_ipv4.c"
    ],
    "message": "ipv4: set the tcp_min_rtt_wlen range from 0 to one day\n\nThere is a UBSAN report as below:\nUBSAN: Undefined behaviour in net/ipv4/tcp_input.c:2877:56\nsigned integer overflow:\n2147483647 * 1000 cannot be represented in type 'int'\nCPU: 3 PID: 0 Comm: swapper/3 Not tainted 5.1.0-rc4-00058-g582549e #1\nCall Trace:\n <IRQ>\n dump_stack+0x8c/0xba\n ubsan_epilogue+0x11/0x60\n handle_overflow+0x12d/0x170\n ? ttwu_do_wakeup+0x21/0x320\n __ubsan_handle_mul_overflow+0x12/0x20\n tcp_ack_update_rtt+0x76c/0x780\n tcp_clean_rtx_queue+0x499/0x14d0\n tcp_ack+0x69e/0x1240\n ? __wake_up_sync_key+0x2c/0x50\n ? update_group_capacity+0x50/0x680\n tcp_rcv_established+0x4e2/0xe10\n tcp_v4_do_rcv+0x22b/0x420\n tcp_v4_rcv+0xfe8/0x1190\n ip_protocol_deliver_rcu+0x36/0x180\n ip_local_deliver+0x15b/0x1a0\n ip_rcv+0xac/0xd0\n __netif_receive_skb_one_core+0x7f/0xb0\n __netif_receive_skb+0x33/0xc0\n netif_receive_skb_internal+0x84/0x1c0\n napi_gro_receive+0x2a0/0x300\n receive_buf+0x3d4/0x2350\n ? detach_buf_split+0x159/0x390\n virtnet_poll+0x198/0x840\n ? reweight_entity+0x243/0x4b0\n net_rx_action+0x25c/0x770\n __do_softirq+0x19b/0x66d\n irq_exit+0x1eb/0x230\n do_IRQ+0x7a/0x150\n common_interrupt+0xf/0xf\n </IRQ>\n\nIt can be reproduced by:\n  echo 2147483647 > /proc/sys/net/ipv4/tcp_min_rtt_wlen\n\nFixes: f672258391b42 (\"tcp: track min RTT using windowed min-filter\")\nSigned-off-by: ZhangXiaoxu <zhangxiaoxu5@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/sysctl_net_ipv4.c||net/ipv4/sysctl_net_ipv4.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/sysctl_net_ipv4.c||net/ipv4/sysctl_net_ipv4.c": [
      "File: net/ipv4/sysctl_net_ipv4.c -> net/ipv4/sysctl_net_ipv4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "49: static int ip_ping_group_range_max[] = { GID_T_MAX, GID_T_MAX };",
      "50: static int comp_sack_nr_max = 255;",
      "51: static u32 u32_max_div_HZ = UINT_MAX / HZ;",
      "54: static int sysctl_tcp_low_latency __read_mostly;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "52: static int one_day_secs = 24 * 3600;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1151:   .data  = &init_net.ipv4.sysctl_tcp_min_rtt_wlen,",
      "1152:   .maxlen  = sizeof(int),",
      "1153:   .mode  = 0644,",
      "1155:  },",
      "1156:  {",
      "1157:   .procname = \"tcp_autocorking\",",
      "",
      "[Removed Lines]",
      "1154:   .proc_handler = proc_dointvec",
      "",
      "[Added Lines]",
      "1155:   .proc_handler = proc_dointvec_minmax,",
      "1156:   .extra1  = &zero,",
      "1157:   .extra2  = &one_day_secs",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7603df38cc8c1e5d540b18ec9eb9d62d823197d0",
      "candidate_info": {
        "commit_hash": "7603df38cc8c1e5d540b18ec9eb9d62d823197d0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7603df38cc8c1e5d540b18ec9eb9d62d823197d0",
        "files": [
          "drivers/gpu/drm/msm/msm_gem_vma.c"
        ],
        "message": "drm/msm: Fix NULL pointer dereference\n\n[    3.707412] Unable to handle kernel NULL pointer dereference at virtual address 0000009c\n[    3.714511] pgd = (ptrval)\n[    3.722742] [0000009c] *pgd=00000000\n[    3.725238] Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n[    3.728968] Modules linked in:\n[    3.734265] CPU: 3 PID: 112 Comm: kworker/3:2 Tainted: G        W         5.0.0-rc7-00183-g06a1c31df9eb #4\n[    3.737142] Hardware name: Generic DT based system\n[    3.746778] Workqueue: events deferred_probe_work_func\n[    3.751542] PC is at msm_gem_map_vma+0x3c/0xac\n[    3.756669] LR is at msm_gem_get_and_pin_iova+0xd8/0x134\n[    3.761086] pc : [<c07d3b7c>]    lr : [<c07d14f8>]    psr: 60000013\n[    3.766560] sp : ee297be8  ip : ed9ab1c0  fp : ed93b800\n[    3.772546] r10: ee35e180  r9 : 00000000  r8 : ee297c80\n[    3.777752] r7 : 00000000  r6 : 7c100000  r5 : 00000000  r4 : ee35e180\n[    3.782968] r3 : 00000001  r2 : 00000003  r1 : ee35e180  r0 : 00000000\n[    3.789562] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[    3.796079] Control: 10c5787d  Table: 2e3a806a  DAC: 00000051\n[    3.803282] Process kworker/3:2 (pid: 112, stack limit = 0x(ptrval))\n[    3.809006] Stack: (0xee297be8 to 0xee298000)\n[    3.815445] 7be0:                   00000000 c1108c48 eda8c000 00000003 eda8c0fc c1108c48\n[    3.819715] 7c00: eda8c000 00000003 eda8c0fc c07d14f8 00000001 c07d1100 7c100000 00000000\n[    3.827873] 7c20: eda8c000 bb7ffb78 00000000 eda8c000 00000000 00000000 c0c8b1d4 ee3bfa00\n[    3.836037] 7c40: ee3b9800 c07d1684 00000000 c1108c48 ee0d7810 ee3b9800 c0c8b1d4 c07d222c\n[    3.844193] 7c60: ee3bfd84 ee297c80 00000000 c0b1d5b0 ee3bfc40 c07dcfd8 ee3bfd84 ee297c80\n[    3.852357] 7c80: 0000006d ee3bfc40 ee0d7810 bb7ffb78 c0c8b1d4 00000000 ee3bfc40 c07ddb48\n[    3.860516] 7ca0: 00002004 c0eba384 ee3bfc40 c079eba0 ee3bd040 ee3b9800 00000001 ed93b800\n[    3.868673] 7cc0: ed9aa100 c07db7e8 ee3bf240 ed9a6500 00000001 ee3b9800 ee3bf2d4 c07a0a30\n[    3.876834] 7ce0: ed93b800 7d100000 c1108c48 ee0d7610 ee3b9800 ed93b800 c1108c48 00000000\n[    3.884991] 7d00: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[    3.893151] 7d20: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 bb7ffb78\n[    3.901310] 7d40: c12113c4 ed93b800 ee3b9800 c1108c48 ee9eec10 00000000 ed93b800 7d100000\n[    3.909472] 7d60: eff7b000 c07cf748 7d100000 00000000 c0e9a350 c0b1d5b0 c12113c4 c0961e40\n[    3.917633] 7d80: c12113c4 40000113 eeff4bec c0ebe004 00000019 c0b1d230 ee9eeda8 60000113\n[    3.925791] 7da0: ee35d300 ee9eeda8 c07ce260 bb7ffb78 c07ce260 ee35d2c0 00000028 00000002\n[    3.933950] 7dc0: eeb76280 c118f884 ee0be640 c11c6128 c07ce260 c07ea4ac 00000000 c0962b48\n[    3.942108] 7de0: c118f868 00000001 c0ebbc98 ee35d2c0 00000000 eeb76280 00000000 c118f87c\n[    3.950270] 7e00: ee35d2c0 00000000 c11c63e0 c118f694 00000019 c07ea5d0 ee0d7810 00000000\n[    3.958430] 7e20: c118f694 00000000 00000000 c07f2b0c c120f55c ee0d7810 c120f560 00000000\n[    3.966590] 7e40: 00000000 c07f08c4 c07f0e8c ee0d7810 c11ba3d0 ee0d7810 c118f694 c07f0e8c\n[    3.974748] 7e60: c1108c48 00000001 c0ebc3cc c11c63f8 c11ba3d0 c07f0c08 00000001 c07f2f8c\n[    3.982908] 7e80: c118f694 00000000 ee297ed4 c07f0e8c c1108c48 00000001 c0ebc3cc c11c63f8\n[    3.991068] 7ea0: c11ba3d0 c07ee8a0 c11ba3d0 ee82686c ee0baf38 bb7ffb78 ee0d7810 ee0d7810\n[    3.999227] 7ec0: c1108c48 ee0d7844 c118faac c07f05b0 ee0d7810 ee0d7810 00000001 bb7ffb78\n[    4.007389] 7ee0: ee0d7810 ee0d7810 c118fd18 c118faac c11c63e0 c07ef7d0 ee0d7810 c118fa90\n[    4.015548] 7f00: c118fa90 c07efd68 c118fac8 ee27fe00 eefd9c80 eefdcd00 00000000 c118facc\n[    4.023708] 7f20: 00000000 c033c038 eefd9c80 eefd9c80 00000008 ee27fe00 ee27fe14 eefd9c80\n[    4.031866] 7f40: 00000008 c1103d00 eefd9c98 ee296000 eefd9c80 c033ce54 ee907eac c0b1d230\n[    4.040026] 7f60: ee907eac eea24440 ee285000 00000000 ee296000 ee27fe00 c033ce24 eea2445c\n[    4.048188] 7f80: ee907eac c0341db0 00000000 ee285000 c0341c8c 00000000 00000000 00000000\n[    4.056346] 7fa0: 00000000 00000000 00000000 c03010e8 00000000 00000000 00000000 00000000\n[    4.064505] 7fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[    4.072665] 7fe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000\n[    4.080828] [<c07d3b7c>] (msm_gem_map_vma) from [<c07d14f8>] (msm_gem_get_and_pin_iova+0xd8/0x134)\n[    4.088983] [<c07d14f8>] (msm_gem_get_and_pin_iova) from [<c07d1684>] (_msm_gem_kernel_new+0x38/0xac)\n[    4.097839] [<c07d1684>] (_msm_gem_kernel_new) from [<c07d222c>] (msm_gem_kernel_new+0x24/0x2c)\n[    4.107130] [<c07d222c>] (msm_gem_kernel_new) from [<c07dcfd8>] (dsi_tx_buf_alloc_6g+0x44/0x90)\n[    4.115631] [<c07dcfd8>] (dsi_tx_buf_alloc_6g) from [<c07ddb48>] (msm_dsi_host_modeset_init+0x80/0x104)\n[    4.124313] [<c07ddb48>] (msm_dsi_host_modeset_init) from [<c07db7e8>] (msm_dsi_modeset_init+0x34/0x1c0)\n[    4.133691] [<c07db7e8>] (msm_dsi_modeset_init) from [<c07a0a30>] (mdp5_kms_init+0x764/0x7e0)\n[    4.143409] [<c07a0a30>] (mdp5_kms_init) from [<c07cf748>] (msm_drm_bind+0x56c/0x740)\n[    4.151824] [<c07cf748>] (msm_drm_bind) from [<c07ea4ac>] (try_to_bring_up_master+0x238/0x2b4)\n[    4.159636] [<c07ea4ac>] (try_to_bring_up_master) from [<c07ea5d0>] (component_add+0xa8/0x170)\n[    4.168146] [<c07ea5d0>] (component_add) from [<c07f2b0c>] (platform_drv_probe+0x48/0x9c)\n[    4.176737] [<c07f2b0c>] (platform_drv_probe) from [<c07f08c4>] (really_probe+0x278/0x404)\n[    4.184981] [<c07f08c4>] (really_probe) from [<c07f0c08>] (driver_probe_device+0x78/0x1c0)\n[    4.193147] [<c07f0c08>] (driver_probe_device) from [<c07ee8a0>] (bus_for_each_drv+0x74/0xb8)\n[    4.201389] [<c07ee8a0>] (bus_for_each_drv) from [<c07f05b0>] (__device_attach+0xd0/0x164)\n[    4.209984] [<c07f05b0>] (__device_attach) from [<c07ef7d0>] (bus_probe_device+0x84/0x8c)\n[    4.218143] [<c07ef7d0>] (bus_probe_device) from [<c07efd68>] (deferred_probe_work_func+0x48/0xc4)\n[    4.226398] [<c07efd68>] (deferred_probe_work_func) from [<c033c038>] (process_one_work+0x204/0x574)\n[    4.235254] [<c033c038>] (process_one_work) from [<c033ce54>] (worker_thread+0x30/0x560)\n[    4.244534] [<c033ce54>] (worker_thread) from [<c0341db0>] (kthread+0x124/0x154)\n[    4.252606] [<c0341db0>] (kthread) from [<c03010e8>] (ret_from_fork+0x14/0x2c)\n[    4.259966] Exception stack(0xee297fb0 to 0xee297ff8)\n[    4.266998] 7fa0:                                     00000000 00000000 00000000 00000000\n[    4.272143] 7fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[    4.280297] 7fe0: 00000000 00000000 00000000 00000000 00000013 00000000\n[    4.288451] Code: e5813080 1a000013 e3a03001 e5c4307c (e590009c)\n[    4.294933] ---[ end trace 18729cc2bca2b4b3 ]---\n\nSigned-off-by: Luca Weiss <luca@z3ntu.xyz>\nSigned-off-by: Rob Clark <robdclark@gmail.com>\nSigned-off-by: Rob Clark <robdclark@chromium.org>",
        "before_after_code_files": [
          "drivers/gpu/drm/msm/msm_gem_vma.c||drivers/gpu/drm/msm/msm_gem_vma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/msm/msm_gem_vma.c||drivers/gpu/drm/msm/msm_gem_vma.c": [
          "File: drivers/gpu/drm/msm/msm_gem_vma.c -> drivers/gpu/drm/msm/msm_gem_vma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:  vma->mapped = true;",
          "89:   ret = aspace->mmu->funcs->map(aspace->mmu, vma->iova, sgt,",
          "90:     size, prot);",
          "",
          "[Removed Lines]",
          "88:  if (aspace->mmu)",
          "",
          "[Added Lines]",
          "88:  if (aspace && aspace->mmu)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "73e6ff71a7ea924fb7121d576a2d41e3be3fc6b5",
      "candidate_info": {
        "commit_hash": "73e6ff71a7ea924fb7121d576a2d41e3be3fc6b5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/73e6ff71a7ea924fb7121d576a2d41e3be3fc6b5",
        "files": [
          "drivers/hwmon/f71805f.c"
        ],
        "message": "hwmon: (f71805f) Use request_muxed_region for Super-IO accesses\n\nSuper-IO accesses may fail on a system with no or unmapped LPC bus.\n\nUnable to handle kernel paging request at virtual address ffffffbffee0002e\npgd = ffffffc1d68d4000\n[ffffffbffee0002e] *pgd=0000000000000000, *pud=0000000000000000\nInternal error: Oops: 94000046 [#1] PREEMPT SMP\nModules linked in: f71805f(+) hwmon\nCPU: 3 PID: 1659 Comm: insmod Not tainted 4.5.0+ #88\nHardware name: linux,dummy-virt (DT)\ntask: ffffffc1f6665400 ti: ffffffc1d6418000 task.ti: ffffffc1d6418000\nPC is at f71805f_find+0x6c/0x358 [f71805f]\n\nAlso, other drivers may attempt to access the LPC bus at the same time,\nresulting in undefined behavior.\n\nUse request_muxed_region() to ensure that IO access on the requested\naddress space is supported, and to ensure that access by multiple\ndrivers is synchronized.\n\nFixes: e53004e20a58e (\"hwmon: New f71805f driver\")\nReported-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nReported-by: John Garry <john.garry@huawei.com>\nCc: John Garry <john.garry@huawei.com>\nAcked-by: John Garry <john.garry@huawei.com>\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>",
        "before_after_code_files": [
          "drivers/hwmon/f71805f.c||drivers/hwmon/f71805f.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/hwmon/f71805f.c||drivers/hwmon/f71805f.c": [
          "File: drivers/hwmon/f71805f.c -> drivers/hwmon/f71805f.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:  outb(ld, base + 1);",
          "97: }",
          "100: superio_enter(int base)",
          "101: {",
          "102:  outb(0x87, base);",
          "103:  outb(0x87, base);",
          "104: }",
          "106: static inline void",
          "107: superio_exit(int base)",
          "108: {",
          "109:  outb(0xaa, base);",
          "110: }",
          "",
          "[Removed Lines]",
          "99: static inline void",
          "",
          "[Added Lines]",
          "99: static inline int",
          "102:  if (!request_muxed_region(base, 2, DRVNAME))",
          "103:   return -EBUSY;",
          "108:  return 0;",
          "115:  release_region(base, 2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1561: static int __init f71805f_find(int sioaddr, unsigned short *address,",
          "1562:           struct f71805f_sio_data *sio_data)",
          "1563: {",
          "1565:  u16 devid;",
          "1567:  static const char * const names[] = {",
          "",
          "[Removed Lines]",
          "1564:  int err = -ENODEV;",
          "",
          "[Added Lines]",
          "1570:  int err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1569:   \"F71872F/FG or F71806F/FG\",",
          "1570:  };",
          "1574:  devid = superio_inw(sioaddr, SIO_REG_MANID);",
          "1575:  if (devid != SIO_FINTEK_ID)",
          "1576:   goto exit;",
          "",
          "[Removed Lines]",
          "1572:  superio_enter(sioaddr);",
          "",
          "[Added Lines]",
          "1578:  err = superio_enter(sioaddr);",
          "1579:  if (err)",
          "1580:   return err;",
          "1582:  err = -ENODEV;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
      "candidate_info": {
        "commit_hash": "3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
        "files": [
          "drivers/char/ipmi/ipmi_msghandler.c"
        ],
        "message": "ipmi: fix sleep-in-atomic in free_user at cleanup SRCU user->release_barrier\n\nfree_user() could be called in atomic context.\n\nThis patch pushed the free operation off into a workqueue.\n\nExample:\n\n BUG: sleeping function called from invalid context at kernel/workqueue.c:2856\n in_atomic(): 1, irqs_disabled(): 0, pid: 177, name: ksoftirqd/27\n CPU: 27 PID: 177 Comm: ksoftirqd/27 Not tainted 4.19.25-3 #1\n Hardware name: AIC 1S-HV26-08/MB-DPSB04-06, BIOS IVYBV060 10/21/2015\n Call Trace:\n  dump_stack+0x5c/0x7b\n  ___might_sleep+0xec/0x110\n  __flush_work+0x48/0x1f0\n  ? try_to_del_timer_sync+0x4d/0x80\n  _cleanup_srcu_struct+0x104/0x140\n  free_user+0x18/0x30 [ipmi_msghandler]\n  ipmi_free_recv_msg+0x3a/0x50 [ipmi_msghandler]\n  deliver_response+0xbd/0xd0 [ipmi_msghandler]\n  deliver_local_response+0xe/0x30 [ipmi_msghandler]\n  handle_one_recv_msg+0x163/0xc80 [ipmi_msghandler]\n  ? dequeue_entity+0xa0/0x960\n  handle_new_recv_msgs+0x15c/0x1f0 [ipmi_msghandler]\n  tasklet_action_common.isra.22+0x103/0x120\n  __do_softirq+0xf8/0x2d7\n  run_ksoftirqd+0x26/0x50\n  smpboot_thread_fn+0x11d/0x1e0\n  kthread+0x103/0x140\n  ? sort_range+0x20/0x20\n  ? kthread_destroy_worker+0x40/0x40\n  ret_from_fork+0x1f/0x40\n\nFixes: 77f8269606bf (\"ipmi: fix use-after-free of user->release_barrier.rda\")\n\nReported-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>\nCc: stable@vger.kernel.org # 5.0\nCc: Yang Yingliang <yangyingliang@huawei.com>",
        "before_after_code_files": [
          "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c": [
          "File: drivers/char/ipmi/ipmi_msghandler.c -> drivers/char/ipmi/ipmi_msghandler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  bool gets_events;",
          "217: };",
          "219: static struct ipmi_user *acquire_ipmi_user(struct ipmi_user *user, int *index)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:  struct work_struct remove_work;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1157:  return rv;",
          "1158: }",
          "1160: int ipmi_create_user(unsigned int          if_num,",
          "1161:        const struct ipmi_user_hndl *handler,",
          "1162:        void                  *handler_data,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1163: static void free_user_work(struct work_struct *work)",
          "1164: {",
          "1165:  struct ipmi_user *user = container_of(work, struct ipmi_user,",
          "1166:            remove_work);",
          "1168:  cleanup_srcu_struct(&user->release_barrier);",
          "1169:  kfree(user);",
          "1170: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1200:  goto out_kfree;",
          "1202:  found:",
          "1203:  rv = init_srcu_struct(&new_user->release_barrier);",
          "1204:  if (rv)",
          "1205:   goto out_kfree;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1215:  INIT_WORK(&new_user->remove_work, free_user_work);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1260: static void free_user(struct kref *ref)",
          "1261: {",
          "1262:  struct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);",
          "1265: }",
          "1267: static void _ipmi_destroy_user(struct ipmi_user *user)",
          "",
          "[Removed Lines]",
          "1263:  cleanup_srcu_struct(&user->release_barrier);",
          "1264:  kfree(user);",
          "",
          "[Added Lines]",
          "1279:  schedule_work(&user->remove_work);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eb9d7a62c38628ab0ba6e59d22d7cb7930e415d1",
      "candidate_info": {
        "commit_hash": "eb9d7a62c38628ab0ba6e59d22d7cb7930e415d1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eb9d7a62c38628ab0ba6e59d22d7cb7930e415d1",
        "files": [
          "arch/powerpc/mm/mmu_context_iommu.c"
        ],
        "message": "powerpc/mm_iommu: Fix potential deadlock\n\nCurrently mm_iommu_do_alloc() is called in 2 cases:\n- VFIO_IOMMU_SPAPR_REGISTER_MEMORY ioctl() for normal memory:\n\tthis locks &mem_list_mutex and then locks mm::mmap_sem\n\tseveral times when adjusting locked_vm or pinning pages;\n- vfio_pci_nvgpu_regops::mmap() for GPU memory:\n\tthis is called with mm::mmap_sem held already and it locks\n\t&mem_list_mutex.\n\nSo one can craft a userspace program to do special ioctl and mmap in\n2 threads concurrently and cause a deadlock which lockdep warns about\n(below).\n\nWe did not hit this yet because QEMU constructs the machine in a single\nthread.\n\nThis moves the overlap check next to where the new entry is added and\nreduces the amount of time spent with &mem_list_mutex held.\n\nThis moves locked_vm adjustment from under &mem_list_mutex.\n\nThis relies on mm_iommu_adjust_locked_vm() doing nothing when entries==0.\n\nThis is one of the lockdep warnings:\n\n======================================================\nWARNING: possible circular locking dependency detected\n5.1.0-rc2-le_nv2_aikATfstn1-p1 #363 Not tainted\n------------------------------------------------------\nqemu-system-ppc/8038 is trying to acquire lock:\n000000002ec6c453 (mem_list_mutex){+.+.}, at: mm_iommu_do_alloc+0x70/0x490\n\nbut task is already holding lock:\n00000000fd7da97f (&mm->mmap_sem){++++}, at: vm_mmap_pgoff+0xf0/0x160\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (&mm->mmap_sem){++++}:\n       lock_acquire+0xf8/0x260\n       down_write+0x44/0xa0\n       mm_iommu_adjust_locked_vm.part.1+0x4c/0x190\n       mm_iommu_do_alloc+0x310/0x490\n       tce_iommu_ioctl.part.9+0xb84/0x1150 [vfio_iommu_spapr_tce]\n       vfio_fops_unl_ioctl+0x94/0x430 [vfio]\n       do_vfs_ioctl+0xe4/0x930\n       ksys_ioctl+0xc4/0x110\n       sys_ioctl+0x28/0x80\n       system_call+0x5c/0x70\n\n-> #0 (mem_list_mutex){+.+.}:\n       __lock_acquire+0x1484/0x1900\n       lock_acquire+0xf8/0x260\n       __mutex_lock+0x88/0xa70\n       mm_iommu_do_alloc+0x70/0x490\n       vfio_pci_nvgpu_mmap+0xc0/0x130 [vfio_pci]\n       vfio_pci_mmap+0x198/0x2a0 [vfio_pci]\n       vfio_device_fops_mmap+0x44/0x70 [vfio]\n       mmap_region+0x5d4/0x770\n       do_mmap+0x42c/0x650\n       vm_mmap_pgoff+0x124/0x160\n       ksys_mmap_pgoff+0xdc/0x2f0\n       sys_mmap+0x40/0x80\n       system_call+0x5c/0x70\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&mm->mmap_sem);\n                               lock(mem_list_mutex);\n                               lock(&mm->mmap_sem);\n  lock(mem_list_mutex);\n\n *** DEADLOCK ***\n\n1 lock held by qemu-system-ppc/8038:\n #0: 00000000fd7da97f (&mm->mmap_sem){++++}, at: vm_mmap_pgoff+0xf0/0x160\n\nFixes: c10c21efa4bc (\"powerpc/vfio/iommu/kvm: Do not pin device memory\", 2018-12-19)\nSigned-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>",
        "before_after_code_files": [
          "arch/powerpc/mm/mmu_context_iommu.c||arch/powerpc/mm/mmu_context_iommu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/mm/mmu_context_iommu.c||arch/powerpc/mm/mmu_context_iommu.c": [
          "File: arch/powerpc/mm/mmu_context_iommu.c -> arch/powerpc/mm/mmu_context_iommu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:          unsigned long entries, unsigned long dev_hpa,",
          "96:          struct mm_iommu_table_group_mem_t **pmem)",
          "97: {",
          "100:  unsigned int pageshift;",
          "116:  if (dev_hpa == MM_IOMMU_TABLE_INVALID_HPA) {",
          "117:   ret = mm_iommu_adjust_locked_vm(mm, entries, true);",
          "118:   if (ret)",
          "121:   locked_entries = entries;",
          "122:  }",
          "",
          "[Removed Lines]",
          "98:  struct mm_iommu_table_group_mem_t *mem;",
          "99:  long i, ret, locked_entries = 0;",
          "102:  mutex_lock(&mem_list_mutex);",
          "104:  list_for_each_entry_rcu(mem, &mm->context.iommu_group_mem_list,",
          "105:    next) {",
          "107:   if ((mem->ua < (ua + (entries << PAGE_SHIFT))) &&",
          "108:     (ua < (mem->ua +",
          "109:            (mem->entries << PAGE_SHIFT)))) {",
          "110:    ret = -EINVAL;",
          "111:    goto unlock_exit;",
          "112:   }",
          "114:  }",
          "119:    goto unlock_exit;",
          "",
          "[Added Lines]",
          "98:  struct mm_iommu_table_group_mem_t *mem, *mem2;",
          "99:  long i, ret, locked_entries = 0, pinned = 0;",
          "105:    return ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:  down_read(&mm->mmap_sem);",
          "151:  ret = get_user_pages_longterm(ua, entries, FOLL_WRITE, mem->hpages, NULL);",
          "152:  up_read(&mm->mmap_sem);",
          "153:  if (ret != entries) {",
          "160:   ret = -EFAULT;",
          "162:  }",
          "164:  pageshift = PAGE_SHIFT;",
          "",
          "[Removed Lines]",
          "155:   for (i = 0; i < ret; i++)",
          "156:    put_page(mem->hpages[i]);",
          "158:   vfree(mem->hpas);",
          "159:   kfree(mem);",
          "161:   goto unlock_exit;",
          "",
          "[Added Lines]",
          "139:  pinned = ret > 0 ? ret : 0;",
          "142:   goto free_exit;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "183:  }",
          "185: good_exit:",
          "187:  atomic64_set(&mem->mapped, 1);",
          "188:  mem->used = 1;",
          "189:  mem->ua = ua;",
          "190:  mem->entries = entries;",
          "199:  mutex_unlock(&mem_list_mutex);",
          "201:  return ret;",
          "202: }",
          "",
          "[Removed Lines]",
          "186:  ret = 0;",
          "193:  list_add_rcu(&mem->next, &mm->context.iommu_group_mem_list);",
          "195: unlock_exit:",
          "196:  if (locked_entries && ret)",
          "197:   mm_iommu_adjust_locked_vm(mm, locked_entries, false);",
          "",
          "[Added Lines]",
          "172:  mutex_lock(&mem_list_mutex);",
          "174:  list_for_each_entry_rcu(mem2, &mm->context.iommu_group_mem_list, next) {",
          "176:   if ((mem2->ua < (ua + (entries << PAGE_SHIFT))) &&",
          "177:     (ua < (mem2->ua +",
          "178:            (mem2->entries << PAGE_SHIFT)))) {",
          "179:    ret = -EINVAL;",
          "180:    mutex_unlock(&mem_list_mutex);",
          "181:    goto free_exit;",
          "182:   }",
          "183:  }",
          "185:  list_add_rcu(&mem->next, &mm->context.iommu_group_mem_list);",
          "191:  return 0;",
          "193: free_exit:",
          "195:  for (i = 0; i < pinned; i++)",
          "196:   put_page(mem->hpages[i]);",
          "198:  vfree(mem->hpas);",
          "199:  kfree(mem);",
          "201: unlock_exit:",
          "202:  mm_iommu_adjust_locked_vm(mm, locked_entries, false);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "266: long mm_iommu_put(struct mm_struct *mm, struct mm_iommu_table_group_mem_t *mem)",
          "267: {",
          "268:  long ret = 0;",
          "271:  mutex_lock(&mem_list_mutex);",
          "",
          "[Removed Lines]",
          "269:  unsigned long entries, dev_hpa;",
          "",
          "[Added Lines]",
          "272:  unsigned long unlock_entries = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "287:   goto unlock_exit;",
          "288:  }",
          "293:  mm_iommu_release(mem);",
          "298: unlock_exit:",
          "299:  mutex_unlock(&mem_list_mutex);",
          "301:  return ret;",
          "302: }",
          "303: EXPORT_SYMBOL_GPL(mm_iommu_put);",
          "",
          "[Removed Lines]",
          "291:  entries = mem->entries;",
          "292:  dev_hpa = mem->dev_hpa;",
          "295:  if (dev_hpa == MM_IOMMU_TABLE_INVALID_HPA)",
          "296:   mm_iommu_adjust_locked_vm(mm, entries, false);",
          "",
          "[Added Lines]",
          "293:  if (mem->dev_hpa == MM_IOMMU_TABLE_INVALID_HPA)",
          "294:   unlock_entries = mem->entries;",
          "302:  mm_iommu_adjust_locked_vm(mm, unlock_entries, false);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6041186a32585fc7a1d0f6cfe2f138b05fdc3c82",
      "candidate_info": {
        "commit_hash": "6041186a32585fc7a1d0f6cfe2f138b05fdc3c82",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6041186a32585fc7a1d0f6cfe2f138b05fdc3c82",
        "files": [
          "init/main.c"
        ],
        "message": "init: initialize jump labels before command line option parsing\n\nWhen a module option, or core kernel argument, toggles a static-key it\nrequires jump labels to be initialized early.  While x86, PowerPC, and\nARM64 arrange for jump_label_init() to be called before parse_args(),\nARM does not.\n\n  Kernel command line: rdinit=/sbin/init page_alloc.shuffle=1 panic=-1 console=ttyAMA0,115200 page_alloc.shuffle=1\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 0 at ./include/linux/jump_label.h:303\n  page_alloc_shuffle+0x12c/0x1ac\n  static_key_enable(): static key 'page_alloc_shuffle_key+0x0/0x4' used\n  before call to jump_label_init()\n  Modules linked in:\n  CPU: 0 PID: 0 Comm: swapper Not tainted\n  5.1.0-rc4-next-20190410-00003-g3367c36ce744 #1\n  Hardware name: ARM Integrator/CP (Device Tree)\n  [<c0011c68>] (unwind_backtrace) from [<c000ec48>] (show_stack+0x10/0x18)\n  [<c000ec48>] (show_stack) from [<c07e9710>] (dump_stack+0x18/0x24)\n  [<c07e9710>] (dump_stack) from [<c001bb1c>] (__warn+0xe0/0x108)\n  [<c001bb1c>] (__warn) from [<c001bb88>] (warn_slowpath_fmt+0x44/0x6c)\n  [<c001bb88>] (warn_slowpath_fmt) from [<c0b0c4a8>]\n  (page_alloc_shuffle+0x12c/0x1ac)\n  [<c0b0c4a8>] (page_alloc_shuffle) from [<c0b0c550>] (shuffle_store+0x28/0x48)\n  [<c0b0c550>] (shuffle_store) from [<c003e6a0>] (parse_args+0x1f4/0x350)\n  [<c003e6a0>] (parse_args) from [<c0ac3c00>] (start_kernel+0x1c0/0x488)\n\nMove the fallback call to jump_label_init() to occur before\nparse_args().\n\nThe redundant calls to jump_label_init() in other archs are left intact\nin case they have static key toggling use cases that are even earlier\nthan option parsing.\n\nLink: http://lkml.kernel.org/r/155544804466.1032396.13418949511615676665.stgit@dwillia2-desk3.amr.corp.intel.com\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>\nReported-by: Guenter Roeck <groeck@google.com>\nReviewed-by: Kees Cook <keescook@chromium.org>\nCc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Mike Rapoport <rppt@linux.ibm.com>\nCc: Russell King <rmk@armlinux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "init/main.c||init/main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "init/main.c||init/main.c": [
          "File: init/main.c -> init/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "582:  page_alloc_init();",
          "584:  pr_notice(\"Kernel command line: %s\\n\", boot_command_line);",
          "585:  parse_early_param();",
          "586:  after_dashes = parse_args(\"Booting kernel\",",
          "587:       static_command_line, __start___param,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586:  jump_label_init();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "591:   parse_args(\"Setting init args\", after_dashes, NULL, 0, -1, -1,",
          "592:       NULL, set_init_arg);",
          "",
          "[Removed Lines]",
          "594:  jump_label_init();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
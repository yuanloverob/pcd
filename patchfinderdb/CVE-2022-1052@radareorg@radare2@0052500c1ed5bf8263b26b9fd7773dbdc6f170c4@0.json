{
  "cve_id": "CVE-2022-1052",
  "cve_desc": "Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.",
  "repo": "radareorg/radare2",
  "patch_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "patch_info": {
    "commit_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
    "files": [
      "libr/bin/format/mach0/mach0.c",
      "libr/bin/format/mach0/mach0.h",
      "libr/core/cmd_api.c"
    ],
    "message": "Fix heap OOB read in macho.iterate_chained_fixups ##crash\n\n* Reported by peacock-doris via huntr.dev\n* Reproducer 'tests_65305'\n\nmrmacete:\n* Return early if segs_count is 0\n* Initialize segs_count also for reconstructed fixups\n\nCo-authored-by: pancake <pancake@nopcode.org>\nCo-authored-by: Francesco Tamagni <mrmacete@protonmail.ch>",
    "before_after_code_files": [
      "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
      "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
      "libr/core/cmd_api.c||libr/core/cmd_api.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
      "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1510:  if (header.starts_offset > size) {",
      "1511:   return false;",
      "1512:  }",
      "1515:   return false;",
      "1516:  }",
      "1517:  bin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);",
      "1518:  if (!bin->chained_starts) {",
      "1519:   return false;",
      "",
      "[Removed Lines]",
      "1513:  ut32 segs_count;",
      "1514:  if ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {",
      "",
      "[Added Lines]",
      "1513:  ut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);",
      "1514:  if (segs_count == UT32_MAX || segs_count == 0) {",
      "1517:  bin->segs_count = segs_count;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1699:  }",
      "1700:  R_FREE (opcodes);",
      "1702:  return true;",
      "1703: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1703:  bin->segs_count = bin->nsegs;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2124:  free (mo->intrp);",
      "2125:  free (mo->compiler);",
      "2126:  if (mo->chained_starts) {",
      "2128:    if (mo->chained_starts[i]) {",
      "2129:     free (mo->chained_starts[i]->page_start);",
      "2130:     free (mo->chained_starts[i]);",
      "",
      "[Removed Lines]",
      "2127:   for (i = 0; i < mo->nsegs; i++) {",
      "",
      "[Added Lines]",
      "2129:   for (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4559: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
      "4560:  int i = 0;",
      "4562:   if (!bin->chained_starts[i]) {",
      "4563:    continue;",
      "4564:   }",
      "",
      "[Removed Lines]",
      "4561:  for (; i < bin->nsegs; i++) {",
      "",
      "[Added Lines]",
      "4563:  for (; i < bin->nsegs && i < bin->segs_count; i++) {",
      "",
      "---------------"
    ],
    "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
      "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  char *intrp;",
      "131:  char *compiler;",
      "132:  int nsegs;",
      "133:  struct r_dyld_chained_starts_in_segment **chained_starts;",
      "134:  struct dyld_chained_fixups_header fixups_header;",
      "135:  ut64 fixups_offset;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  int segs_count;",
      "",
      "---------------"
    ],
    "libr/core/cmd_api.c||libr/core/cmd_api.c": [
      "File: libr/core/cmd_api.c -> libr/core/cmd_api.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "392: R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {",
      "393:  r_return_val_if_fail (cmd && cmd->aliases && k, NULL);",
      "395: }",
      "397: static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {",
      "",
      "[Removed Lines]",
      "394:  return ht_pp_find(cmd->aliases, k, NULL);",
      "",
      "[Added Lines]",
      "394:  return ht_pp_find (cmd->aliases, k, NULL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a2e28857b350176af3a2302eeca1c729d11e1cc1",
      "candidate_info": {
        "commit_hash": "a2e28857b350176af3a2302eeca1c729d11e1cc1",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/a2e28857b350176af3a2302eeca1c729d11e1cc1",
        "files": [
          "libr/cons/cpipe.c",
          "libr/core/cmd_api.c",
          "libr/core/cmd_write.c",
          "test/db/cmd/cmd_print"
        ],
        "message": "Handle aliased files in wff and wtf commands ##shell",
        "before_after_code_files": [
          "libr/cons/cpipe.c||libr/cons/cpipe.c",
          "libr/core/cmd_api.c||libr/core/cmd_api.c",
          "libr/core/cmd_write.c||libr/core/cmd_write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ],
          "candidate": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/cons/cpipe.c||libr/cons/cpipe.c": [
          "File: libr/cons/cpipe.c -> libr/cons/cpipe.c"
        ],
        "libr/core/cmd_api.c||libr/core/cmd_api.c": [
          "File: libr/core/cmd_api.c -> libr/core/cmd_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "275: }",
          "277: R_API const char *r_cmd_alias_get(RCmd *cmd, const char *k, int remote) {",
          "278:  int matches, i;",
          "282:  for (i = 0; i < cmd->aliases.count; i++) {",
          "283:   matches = 0;",
          "284:   if (remote) {",
          "",
          "[Removed Lines]",
          "279:  if (!cmd || !k) {",
          "280:   return NULL;",
          "281:  }",
          "",
          "[Added Lines]",
          "278:  r_return_val_if_fail (cmd && k, NULL);",
          "",
          "---------------"
        ],
        "libr/core/cmd_write.c||libr/core/cmd_write.c": [
          "File: libr/core/cmd_write.c -> libr/core/cmd_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "621: }",
          "623: static bool cmd_wff(RCore *core, const char *input) {",
          "627:  const char *arg = input + ((input[0] == ' ') ? 1 : 0);",
          "628:  int wseek = r_config_get_i (core->config, \"cfg.wseek\");",
          "629:  char *p, *a = r_str_trim_dup (arg);",
          "",
          "[Removed Lines]",
          "624:  ut8 *buf;",
          "625:  size_t size;",
          "",
          "[Added Lines]",
          "624:  ut8 *buf = NULL;",
          "625:  size_t size = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "646:    free (out);",
          "647:   }",
          "648:  }",
          "650:   int u_offset = 0;",
          "651:   ut64 u_size = r_num_math (core->num, p);",
          "652:   if (u_size < 1) u_size = (ut64)size;",
          "",
          "[Removed Lines]",
          "649:  if ((buf = (ut8*) r_file_slurp (a, &size))) {",
          "",
          "[Added Lines]",
          "649:  if (*a == '$') {",
          "650:   const char *res = r_cmd_alias_get (core->rcmd, a, 1);",
          "651:   if (res) {",
          "652:    buf = (ut8*)strdup (res);",
          "653:    size = strlen (res);",
          "654:   }",
          "655:  } else {",
          "656:   buf = (ut8*) r_file_slurp (a, &size);",
          "657:  }",
          "658:  if (size < 1) {",
          "660:  } else if (buf) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1639:     }",
          "1640:    } else {",
          "1641:     sz = core->blocksize;",
          "1644:     }",
          "1645:    }",
          "1646:   }",
          "",
          "[Removed Lines]",
          "1642:     if (!r_file_dump (filename, core->block, sz, append)) {",
          "1643:      sz = -1;",
          "",
          "[Added Lines]",
          "1653:     if (*filename == '$') {",
          "1654:      char *data = r_str_ndup ((const char *)core->block, sz);",
          "1655:      r_cmd_alias_set (core->rcmd, filename, data, 1);",
          "1656:      free (data);",
          "1657:     } else {",
          "1658:      if (!r_file_dump (filename, core->block, sz, append)) {",
          "1659:       sz = -1;",
          "1660:      }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6c5d1ba17bbb761c35346ceef375f505db7a957",
      "candidate_info": {
        "commit_hash": "c6c5d1ba17bbb761c35346ceef375f505db7a957",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/c6c5d1ba17bbb761c35346ceef375f505db7a957",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_mach0.c",
          "libr/include/r_bin.h",
          "libr/main/r2pm.c"
        ],
        "message": "Implement qword to better display patched relocs in macho ##bin",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/include/r_bin.h||libr/include/r_bin.h",
          "libr/main/r2pm.c||libr/main/r2pm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2078:       ut64 va = offset_to_vaddr(bin, dw);",
          "2082:      }",
          "2083:     }",
          "2084:    }",
          "",
          "[Removed Lines]",
          "2081:       eprintf (\"Cd 4 %d @ 0x%\"PFMT64x\"\\n\", len / 4, va);",
          "",
          "[Added Lines]",
          "2081:       eprintf (\"Cd 8 %d @ 0x%\"PFMT64x\"\\n\", len / 8, va);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2089:     r_buf_read_at (bin->b, off + 8, buf, sizeof (buf));",
          "2090:     ut32 dataoff = r_read_ble32 (buf, bin->big_endian);",
          "2091:     ut32 datasize = r_read_ble32 (buf + 4, bin->big_endian);",
          "2093:    }",
          "2094:    break;",
          "2095:   case LC_DYLD_CHAINED_FIXUPS:",
          "",
          "[Removed Lines]",
          "2092:     eprintf (\"exports trie at 0x%x size %d\\n\", dataoff, datasize);",
          "",
          "[Added Lines]",
          "2092:     R_LOG_INFO (\"exports trie at 0x%x size %d\", dataoff, datasize);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2387:    r_list_append (list, s);",
          "2388:   }",
          "2389:  }",
          "2390:  if (macho->nsects > 0) {",
          "2391:   int last_section = R_MIN (macho->nsects, MACHO_MAX_SECTIONS);",
          "2392:   for (i = 0; i < last_section; i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2390: #if R_BIN_MACH064",
          "2391:  const int ws = 8;",
          "2392: #else",
          "2393:  const int ws = 4;",
          "2394: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2413:    char *segment_name = r_str_newf (\"%u.%s\", (ut32)i, macho->segs[segment_index].segname);",
          "2414:    s->name = r_str_newf (\"%s.%s\", segment_name, section_name);",
          "2415:    if (strstr (s->name, \"__const\")) {",
          "2417:    }",
          "2418:    s->is_data = is_data_section (s);",
          "2419:    if (strstr (section_name, \"interpos\") || strstr (section_name, \"__mod_\")) {",
          "2425:     s->format = r_str_newf (\"Cd %d[%\"PFMT64d\"]\", ws, s->vsize / ws);",
          "2426:    }",
          "2427:    r_list_append (list, s);",
          "",
          "[Removed Lines]",
          "2416:     s->format = r_str_newf (\"Cd 4 %\"PFMT64d, s->size / 4);",
          "2420: #if R_BIN_MACH064",
          "2421:     const int ws = 8;",
          "2422: #else",
          "2423:     const int ws = 4;",
          "2424: #endif",
          "",
          "[Added Lines]",
          "2421:     s->format = r_str_newf (\"Cd %d %\"PFMT64d, ws, s->size / ws);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4713: #define IS_FMT_32BIT(x) (x == DYLD_CHAINED_PTR_32 || x == DYLD_CHAINED_PTR_32_CACHE || x == DYLD_CHAINED_PTR_32_FIRMWARE)",
          "4715: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *mo, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
          "4718:   if (!mo->chained_starts[i]) {",
          "4719:    continue;",
          "4720:   }",
          "",
          "[Removed Lines]",
          "4716:  int i = 0;",
          "4717:  for (; i < mo->nsegs && i < mo->segs_count; i++) {",
          "",
          "[Added Lines]",
          "4716:  int i;",
          "4717:  for (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c"
        ],
        "libr/include/r_bin.h||libr/include/r_bin.h": [
          "File: libr/include/r_bin.h -> libr/include/r_bin.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "466:  RList/*<RBinTrycatch>*/* (*trycatch)(RBinFile *bf);",
          "467:  RList/*<RBinClass>*/* (*classes)(RBinFile *bf);",
          "468:  RList/*<RBinMem>*/* (*mem)(RBinFile *bf);",
          "470:  RList/*<RBinMap>*/* (*maps)(RBinFile *bf);",
          "471:  RList/*<RBinFileHash>*/* (*hashes)(RBinFile *bf);",
          "472:  void (*header)(RBinFile *bf);",
          "",
          "[Removed Lines]",
          "469:  RList/*<RBinReloc>*/* (*patch_relocs)(RBin *bin);",
          "",
          "[Added Lines]",
          "469:  RList/*<RBinReloc>*/* (*patch_relocs)(RBin *bin); // R2_590 RBinFile instead of RBin",
          "",
          "---------------"
        ],
        "libr/main/r2pm.c||libr/main/r2pm.c": [
          "File: libr/main/r2pm.c -> libr/main/r2pm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "426:  int i;",
          "427:  char *env_python = r_sys_getenv (\"PYTHON\");",
          "428: #if !R2_590",
          "430: #endif",
          "432:  if (R_STR_ISNOTEMPTY (env_python)) {",
          "",
          "[Removed Lines]",
          "429:  bool found;",
          "",
          "[Added Lines]",
          "429:  bool found = false;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0960ef4586b5c1f97e8aba3c6e236202a8032936",
      "candidate_info": {
        "commit_hash": "0960ef4586b5c1f97e8aba3c6e236202a8032936",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/0960ef4586b5c1f97e8aba3c6e236202a8032936",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/p/bin_mach0.c",
          "test/db/anal/classes"
        ],
        "message": "Expose the macho reloc fixups and use internal buffer for parsing ##bin\n\n* 7x faster, remove 4 globals, fix uaf, stack exhaustion and race condition bugs",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
            "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
            "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4622:  return macho_hdr;",
          "4623: }",
          "4626:  int i = 0;",
          "4629:    continue;",
          "4630:   }",
          "4632:   if (page_size < 1) {",
          "4633:    page_size = 4096;",
          "4634:   }",
          "4637:   if (end >= limit_start && start <= limit_end) {",
          "4638:    ut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;",
          "4639:    ut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;",
          "4640:    for (; page_idx <= page_end_idx; page_idx++) {",
          "4642:      break;",
          "4643:     }",
          "4645:      break;",
          "4646:     }",
          "4648:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "4649:      continue;",
          "4650:     }",
          "4651:     ut64 cursor = start + page_idx * page_size + page_start;",
          "4652:     while (cursor < limit_end && cursor < end) {",
          "4653:      ut8 tmp[8];",
          "4658:       break;",
          "4659:      }",
          "4661:      ut64 raw_ptr = r_read_le64 (tmp);",
          "4662:      ut64 ptr_value = raw_ptr;",
          "4663:      ut64 delta, stride, addend;",
          "4665:      RFixupEvent event = R_FIXUP_EVENT_NONE;",
          "4666:      ut8 key = 0, addr_div = 0;",
          "4667:      ut16 diversity = 0;",
          "",
          "[Removed Lines]",
          "4625: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
          "4627:  for (; i < bin->nsegs && i < bin->segs_count; i++) {",
          "4628:   if (!bin->chained_starts[i]) {",
          "4631:   int page_size = bin->chained_starts[i]->page_size;",
          "4635:   ut64 start = bin->segs[i].fileoff;",
          "4636:   ut64 end = start + bin->segs[i].filesize;",
          "4641:     if (page_idx >= bin->chained_starts[i]->page_count) {",
          "4644:     if (!bin->chained_starts[i]->page_start) {",
          "4647:     ut16 page_start = bin->chained_starts[i]->page_start[page_idx];",
          "4654:      bool previous_rebasing = bin->rebasing_buffer;",
          "4655:      bin->rebasing_buffer = true;",
          "4656:      if (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {",
          "4657:       bin->rebasing_buffer = previous_rebasing;",
          "4660:      bin->rebasing_buffer = previous_rebasing;",
          "4664:      ut16 pointer_format = bin->chained_starts[i]->pointer_format;",
          "",
          "[Added Lines]",
          "4625: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *mo, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
          "4627:  for (; i < mo->nsegs && i < mo->segs_count; i++) {",
          "4628:   if (!mo->chained_starts[i]) {",
          "4631:   int page_size = mo->chained_starts[i]->page_size;",
          "4635:   ut64 start = mo->segs[i].fileoff;",
          "4636:   ut64 end = start + mo->segs[i].filesize;",
          "4641:     if (page_idx >= mo->chained_starts[i]->page_count) {",
          "4644:     if (!mo->chained_starts[i]->page_start) {",
          "4647:     ut16 page_start = mo->chained_starts[i]->page_start[page_idx];",
          "4654:      bool previous_rebasing = mo->rebasing_buffer;",
          "4655:      mo->rebasing_buffer = true;",
          "4656:      if (r_buf_read_at (mo->b, cursor, tmp, 8) != 8) {",
          "4657:       mo->rebasing_buffer = previous_rebasing;",
          "4660:      mo->rebasing_buffer = previous_rebasing;",
          "4664:      ut16 pointer_format = mo->chained_starts[i]->pointer_format;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4693:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4694:        event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4695:        delta = p->next;",
          "4697:        key = p->key;",
          "4698:        addr_div = p->addrDiv;",
          "4699:        diversity = p->diversity;",
          "",
          "[Removed Lines]",
          "4696:        ptr_value = p->target + bin->baddr;",
          "",
          "[Added Lines]",
          "4696:        ptr_value = p->target + mo->baddr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4732:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4733:         event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4734:         delta = p->next;",
          "4736:         key = p->key;",
          "4737:         addr_div = p->addrDiv;",
          "4738:         diversity = p->diversity;",
          "",
          "[Removed Lines]",
          "4735:         ptr_value = p->target + bin->baddr;",
          "",
          "[Added Lines]",
          "4735:         ptr_value = p->target + mo->baddr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4741:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "4742:         event = R_FIXUP_EVENT_REBASE;",
          "4743:         delta = p->next;",
          "4745:        }",
          "4746:       }",
          "4747:       }",
          "",
          "[Removed Lines]",
          "4744:         ptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);",
          "",
          "[Added Lines]",
          "4744:         ptr_value = mo->baddr + (((ut64)p->high8 << 56) | p->target);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4764:        delta = p->next;",
          "4765:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "4766:        if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "4768:        }",
          "4769:       }",
          "4770:       }",
          "",
          "[Removed Lines]",
          "4767:         ptr_value += bin->baddr;",
          "",
          "[Added Lines]",
          "4767:         ptr_value += mo->baddr;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4780:        RFixupBindEventDetails event_details;",
          "4782:        event_details.type = event;",
          "4784:        event_details.offset = cursor;",
          "4785:        event_details.raw_ptr = raw_ptr;",
          "4786:        event_details.ordinal = ordinal;",
          "",
          "[Removed Lines]",
          "4783:        event_details.bin = bin;",
          "",
          "[Added Lines]",
          "4783:        event_details.bin = mo;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4793:        RFixupBindAuthEventDetails event_details;",
          "4795:        event_details.type = event;",
          "4797:        event_details.offset = cursor;",
          "4798:        event_details.raw_ptr = raw_ptr;",
          "4799:        event_details.ordinal = ordinal;",
          "",
          "[Removed Lines]",
          "4796:        event_details.bin = bin;",
          "",
          "[Added Lines]",
          "4796:        event_details.bin = mo;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4808:        RFixupRebaseEventDetails event_details;",
          "4810:        event_details.type = event;",
          "4812:        event_details.offset = cursor;",
          "4813:        event_details.raw_ptr = raw_ptr;",
          "4814:        event_details.ptr_value = ptr_value;",
          "",
          "[Removed Lines]",
          "4811:        event_details.bin = bin;",
          "",
          "[Added Lines]",
          "4811:        event_details.bin = mo;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4820:        RFixupRebaseAuthEventDetails event_details;",
          "4822:        event_details.type = event;",
          "4824:        event_details.offset = cursor;",
          "4825:        event_details.raw_ptr = raw_ptr;",
          "4826:        event_details.ptr_value = ptr_value;",
          "",
          "[Removed Lines]",
          "4823:        event_details.bin = bin;",
          "",
          "[Added Lines]",
          "4823:        event_details.bin = mo;",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:  bool rebasing_buffer;",
          "200:  RList *symbols_cache;",
          "201:  RList *sections_cache;",
          "202:  ut8 *internal_buffer;",
          "203:  int internal_buffer_size;",
          "204: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:  RList *reloc_fixups;",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  ut8 *buf;",
          "12:  int count;",
          "13:  ut64 off;",
          "14: } RFixupRebaseContext;",
          "18: extern RBinWrite r_bin_write_mach0;",
          "20: static RBinInfo *info(RBinFile *bf);",
          "30: #define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)",
          "31: #define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)",
          "",
          "[Removed Lines]",
          "21: static void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io);",
          "22: static int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count);",
          "23: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count);",
          "26: static R_TH_LOCAL void *Gorigread = NULL;",
          "27: static R_TH_LOCAL int Gorigdesc = 0;",
          "28: static R_TH_LOCAL RIOPlugin *Gorigplugin = NULL;",
          "29: static R_TH_LOCAL RIOPlugin *Gheapplugin = NULL;",
          "",
          "[Added Lines]",
          "14:  RIO *io;",
          "15:  struct MACH0_(obj_t) *obj;",
          "20: static bool rebase_buffer_callback2(void * context, RFixupEventDetails * event_details);",
          "22: static RBuffer *swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:  if (res) {",
          "60:   if (res->chained_starts) {",
          "61:    RIO *io = bf->rbin->iob.io;",
          "63:   }",
          "64:   sdb_ns_set (sdb, \"info\", res->kv);",
          "",
          "[Removed Lines]",
          "62:    swizzle_io_read (res, io);",
          "",
          "[Added Lines]",
          "56:    bf->buf = swizzle_io_read (res, io);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69: }",
          "71: static void destroy(RBinFile *bf) {",
          "82:  MACH0_(mach0_free) (bf->o->bin_obj);",
          "83: }",
          "",
          "[Removed Lines]",
          "72:  if (Gorigplugin) {",
          "73:   RIOBind *iob = &bf->rbin->iob;",
          "74:   RIO *io = iob->io;",
          "75:   RIODesc *desc = iob->desc_get (io, Gorigdesc);",
          "76:   if (desc) {",
          "77:    desc->plugin = Gorigplugin;",
          "78:   }",
          "79:   Gorigplugin = NULL;",
          "80:   R_FREE (Gheapplugin);",
          "81:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "623:  RList *ret = NULL;",
          "624:  RIO *io = NULL;",
          "625:  RBinObject *obj = NULL;",
          "627:  RIOMap *g = NULL;",
          "628:  HtUU *relocs_by_sym = NULL;",
          "629:  RIODesc *gotr2desc = NULL;",
          "",
          "[Removed Lines]",
          "626:  struct MACH0_(obj_t) *bin = NULL;",
          "",
          "[Added Lines]",
          "610:  struct MACH0_(obj_t) *mo = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "638:  if (!obj) {",
          "639:   return NULL;",
          "640:  }",
          "644:  if (!all_relocs) {",
          "645:   return NULL;",
          "646:  }",
          "",
          "[Removed Lines]",
          "641:  bin = obj->bin_obj;",
          "643:  RSkipList * all_relocs = MACH0_(get_relocs)(bin);",
          "",
          "[Added Lines]",
          "625:  mo = obj->bin_obj;",
          "627:  RSkipList * all_relocs = MACH0_(get_relocs)(mo);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "649:   goto beach;",
          "650:  }",
          "651:  RSkipListNode *it;",
          "653:  r_skiplist_foreach (all_relocs, it, reloc) {",
          "654:   if (!reloc->external) {",
          "655:    continue;",
          "656:   }",
          "657:   r_list_append (ext_relocs, reloc);",
          "658:  }",
          "659:  ut64 num_ext_relocs = r_list_length (ext_relocs);",
          "660:  if (!num_ext_relocs) {",
          "661:   goto beach;",
          "662:  }",
          "664:  if (!io->cached) {",
          "666:   goto beach;",
          "667:  }",
          "",
          "[Removed Lines]",
          "652:  struct reloc_t * reloc;",
          "665:   eprintf (\"Warning: run r2 with -e bin.cache=true to fix relocations in disassembly\\n\");",
          "",
          "[Added Lines]",
          "636:  struct reloc_t *reloc;",
          "643:  RBinReloc *r;",
          "644:  RListIter *iter2;",
          "646:  r_list_foreach (mo->reloc_fixups, iter2, r) {",
          "647:   ut64 paddr = r->paddr + mo->baddr;",
          "648:   ut8 buf[8], obuf[8];",
          "649:   r_write_ble64 (buf, r->vaddr, false);",
          "650:   r_io_read_at (io, paddr, obuf, 8);",
          "651:   if (memcmp (buf, obuf, 8)) {",
          "652:    r_io_write_at (io, paddr, buf, 8);",
          "653:   }",
          "654:  }",
          "661:   R_LOG_WARN (\"run r2 with -e bin.cache=true to fix relocations in disassembly\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "713:    ht_uu_insert (relocs_by_sym, reloc->ord, vaddr);",
          "714:    vaddr += cdsz;",
          "715:   }",
          "717:    continue;",
          "718:   }",
          "719:   RBinReloc *ptr = NULL;",
          "",
          "[Removed Lines]",
          "716:   if (!_patch_reloc (bin, &b->iob, reloc, sym_addr)) {",
          "",
          "[Added Lines]",
          "712:   if (!_patch_reloc (mo, &b->iob, reloc, sym_addr)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "722:   }",
          "723:   ptr->type = reloc->type;",
          "724:   ptr->additive = 0;",
          "727:    R_FREE (ptr);",
          "728:    goto beach;",
          "729:   }",
          "",
          "[Removed Lines]",
          "725:   RBinImport *imp;",
          "726:   if (!(imp = import_from_name (b, (char*) reloc->name, bin->imports_by_name))) {",
          "",
          "[Added Lines]",
          "721:   RBinImport *imp = import_from_name (b, (char*) reloc->name, mo->imports_by_name);",
          "722:   if (!imp) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "748:  return NULL;",
          "749: }",
          "769: }",
          "820:  }",
          "828: }",
          "831:  RFixupRebaseContext *ctx = context;",
          "833:  ut64 in_buf = event_details->offset - ctx->off;",
          "834:  switch (event_details->type) {",
          "835:  case R_FIXUP_EVENT_BIND:",
          "836:  case R_FIXUP_EVENT_BIND_AUTH:",
          "838:   break;",
          "839:  case R_FIXUP_EVENT_REBASE:",
          "840:  case R_FIXUP_EVENT_REBASE_AUTH:",
          "842:   break;",
          "843:  default:",
          "844:   R_LOG_ERROR (\"Unexpected event while rebasing buffer\");",
          "",
          "[Removed Lines]",
          "751: static void swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io) {",
          "752:  r_return_if_fail (io && io->desc && io->desc->plugin);",
          "753:  RIOPlugin *plugin = R_NEW0 (RIOPlugin);",
          "754:  if (Gheapplugin) {",
          "755:   R_LOG_WARN (\"Here be dragons\");",
          "756:   return;",
          "757:  } else {",
          "758:   Gorigplugin = io->desc->plugin;",
          "759:   Gorigdesc = io->desc->fd;",
          "760:  }",
          "761:  memcpy (plugin, Gorigplugin, sizeof (RIOPlugin));",
          "762:  io->desc->plugin = plugin;",
          "763:  obj->original_io_read = plugin->read;",
          "764:  if (Gorigread == NULL) {",
          "765:   Gorigread = plugin->read;",
          "766:  }",
          "767:  plugin->read = &rebasing_and_stripping_io_read;",
          "768:  Gheapplugin = plugin;",
          "771: static int rebasing_and_stripping_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {",
          "772:  r_return_val_if_fail (io, -1);",
          "773:  RCore *core = (RCore*) io->coreb.core;",
          "774:  if (!core || !core->bin || !core->bin->binfiles) {",
          "775:   return -1;",
          "776:  }",
          "777:  struct MACH0_(obj_t) *obj = NULL;",
          "778:  RListIter *iter;",
          "779:  RBinFile *bf;",
          "780:  r_list_foreach (core->bin->binfiles, iter, bf) {",
          "781:   if (bf->fd == fd->fd) {",
          "788:    if (bf->o) {",
          "789:     ut32 *magic = bf->o->bin_obj;",
          "790:     if (magic && (*magic == MH_MAGIC ||",
          "794:      obj = bf->o->bin_obj;",
          "795:     }",
          "796:    }",
          "797:    break;",
          "798:   }",
          "799:  }",
          "800:  if (!obj || !obj->original_io_read) {",
          "801:   if (fd->plugin->read == &rebasing_and_stripping_io_read) {",
          "802:    return -1;",
          "803:   }",
          "804:   return fd->plugin->read (io, fd, buf, count);",
          "805:  }",
          "806:  if (!obj->original_io_read) {",
          "807:   return -1;",
          "808:  }",
          "809:  if (obj->rebasing_buffer) {",
          "810:   return obj->original_io_read (io, fd, buf, count);",
          "811:  }",
          "812:  if (count > obj->internal_buffer_size) {",
          "813:   R_FREE (obj->internal_buffer);",
          "814:   obj->internal_buffer_size = R_MAX (count, 8);",
          "815:   obj->internal_buffer = (ut8 *) calloc (1, obj->internal_buffer_size);",
          "816:   if (!obj->internal_buffer) {",
          "817:    obj->internal_buffer_size = 0;",
          "818:    return -1;",
          "819:   }",
          "821:  ut64 io_off = io->off;",
          "822:  int result = obj->original_io_read (io, fd, obj->internal_buffer, count);",
          "823:  if (result == count) {",
          "824:   rebase_buffer (obj, io_off - bf->o->boffset, fd, obj->internal_buffer, obj->internal_buffer_size);",
          "825:   memcpy (buf, obj->internal_buffer, result);",
          "826:  }",
          "827:  return result;",
          "830: static bool rebase_buffer_callback(void * context, RFixupEventDetails * event_details) {",
          "837:   r_write_le64 (&ctx->buf[in_buf], 0);",
          "841:   r_write_le64 (&ctx->buf[in_buf], ((RFixupRebaseEventDetails *) event_details)->ptr_value);",
          "",
          "[Added Lines]",
          "747: static RBuffer *swizzle_io_read(struct MACH0_(obj_t) *obj, RIO *io) {",
          "748:  r_return_val_if_fail (io && io->desc && io->desc->plugin, NULL);",
          "749:  RFixupRebaseContext ctx = {0};",
          "750:  RBuffer *nb = r_buf_new_with_buf (obj->b);",
          "751:  RBuffer *ob = obj->b;",
          "752:  obj->b = nb;",
          "753:  ut64 count = r_buf_size (obj->b);",
          "754:  ctx.io = io;",
          "755:  ctx.obj = obj;",
          "756:  ut64 off = 0;",
          "757:  ctx.off = off;",
          "758:  MACH0_(iterate_chained_fixups) (obj, off, off + count, R_FIXUP_EVENT_MASK_ALL, &rebase_buffer_callback2, &ctx);",
          "759:  obj->b = ob;",
          "760:  return nb;",
          "763: static void add_fixup(RList *list, ut64 addr, ut64 value) {",
          "764:  RBinReloc *r = R_NEW0 (RBinReloc);",
          "765:  if (r) {",
          "766:   r->vaddr = value;",
          "767:   r->paddr = addr;",
          "768:   r_list_append (list, r);",
          "771: static bool rebase_buffer_callback2(void *context, RFixupEventDetails * event_details) {",
          "774:  RList *rflist = ctx->obj->reloc_fixups;",
          "776:  if (!rflist) {",
          "777:   rflist = r_list_newf (free);",
          "778:   ctx->obj->reloc_fixups = rflist;",
          "779:  }",
          "783:   r_buf_write_at (ctx->obj->b, in_buf, (const ut8*)\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8);",
          "784:   ut8 data[8] = {0};",
          "785:   r_buf_read_at (ctx->obj->b, in_buf, data, 8);",
          "786:   add_fixup (rflist, in_buf, 0);",
          "787:   if (data[0]) {",
          "788:    eprintf (\"DATA0 write has failed\\n\");",
          "789:   }",
          "793:   {",
          "794:    ut8 data[8] = {0};",
          "795:    ut64 v = ((RFixupRebaseEventDetails *) event_details)->ptr_value;",
          "796:    add_fixup (rflist, in_buf, v);",
          "797:    memcpy (&data, &v, sizeof (data));",
          "798:    r_buf_write_at (ctx->obj->b, in_buf, data, 8);",
          "799:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "848:  return true;",
          "849: }",
          "867: static RList *classes(RBinFile *bf) {",
          "868:  return MACH0_(parse_classes) (bf, NULL);",
          "869: }",
          "",
          "[Removed Lines]",
          "851: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {",
          "852:  if (obj->rebasing_buffer) {",
          "853:   return;",
          "854:  }",
          "855:  obj->rebasing_buffer = true;",
          "857:  RFixupRebaseContext ctx;",
          "859:  ctx.buf = buf;",
          "860:  ctx.count = count;",
          "861:  ctx.off = off;",
          "863:  MACH0_(iterate_chained_fixups) (obj, off, off + count, R_FIXUP_EVENT_MASK_ALL, &rebase_buffer_callback, &ctx);",
          "864:  obj->rebasing_buffer = false;",
          "865: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d1631b8d3499d4cb3e0365bc945c71183b93412b",
      "candidate_info": {
        "commit_hash": "d1631b8d3499d4cb3e0365bc945c71183b93412b",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/d1631b8d3499d4cb3e0365bc945c71183b93412b",
        "files": [
          "libr/core/cmd.c",
          "libr/core/cmd_api.c",
          "libr/core/cmd_cmp.c",
          "libr/core/cmd_debug.c",
          "libr/core/cmd_write.c",
          "test/db/cmd/cmd_alias"
        ],
        "message": "Multiple alias improvements\n\n* Add proper hashtable functions in RCmdAlias to prevent memory leaks\n* Fix off-by-one error in alias name processing\n* Don't allow 0-length aliases\n* Fix memory leak in r_cmd_alias_set_raw() when malloc fails and add\n  null checks to other alias set functions\n* Document intended use of strlen() result for buffer size",
        "before_after_code_files": [
          "libr/core/cmd.c||libr/core/cmd.c",
          "libr/core/cmd_api.c||libr/core/cmd_api.c",
          "libr/core/cmd_cmp.c||libr/core/cmd_cmp.c",
          "libr/core/cmd_debug.c||libr/core/cmd_debug.c",
          "libr/core/cmd_write.c||libr/core/cmd_write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ],
          "candidate": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/core/cmd.c||libr/core/cmd.c": [
          "File: libr/core/cmd.c -> libr/core/cmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "650:  char *def = strchr (buf, '=');",
          "651:  char *desc = strchr (buf, '?');",
          "653:  int defmode = 0;",
          "654:  if (def && def > buf) {",
          "655:   char *prev = def - 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653:  if (buf == def) {",
          "654:   eprintf (\"No alias name given.\\n\");",
          "655:   free (buf);",
          "656:   return 0;",
          "657:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "720:      free (s);",
          "721:     } else if (!strncmp (def, \"base64:\", 7)) {",
          "722:      int b64_len = strlen (def+7);",
          "724:       ut8* decoded = malloc (b64_len);",
          "725:       if (decoded) {",
          "726:        int decoded_sz = r_base64_decode (decoded, def+7, b64_len);",
          "",
          "[Removed Lines]",
          "723:      if (b64_len) {",
          "",
          "[Added Lines]",
          "729:      if (b64_len > 0 && b64_len % 4 == 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "789:     r_core_cmd0 (core, (char *)v->data);",
          "790:    }",
          "791:   } else {",
          "793:    if (at != UT64_MAX) {",
          "794:     r_core_seek (core, at, true);",
          "795:    } else {",
          "797:    }",
          "798:   }",
          "799:  }",
          "",
          "[Removed Lines]",
          "792:    ut64 at = r_num_get (core->num, buf + 1);",
          "796:     eprintf (\"No such alias \\\"$%s\\\"\\n\", buf + 1);",
          "",
          "[Added Lines]",
          "800:    ut64 at = r_num_get (core->num, buf);",
          "804:     eprintf (\"No such alias \\\"$%s\\\"\\n\", buf);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1694:    eprintf (\"Usage: ,. [file | $alias]\\n\");",
          "1695:   } else {",
          "1696:    const char *file = r_str_trim_head_ro (input + 1);",
          "1698:     RCmdAliasVal *file_data = r_cmd_alias_get (core->rcmd, file+1);",
          "1699:     if (file_data) {",
          "1700:      char *file_data_str = r_cmd_alias_val_strdup (file_data);",
          "",
          "[Removed Lines]",
          "1697:    if (*file == '$') {",
          "",
          "[Added Lines]",
          "1705:    if (*file == '$' && !file[1]) {",
          "1706:     eprintf (\"No alias name given.\\n\");",
          "1707:    } else if (*file == '$') {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1825:  case ' ': // \". \"",
          "1826:   {",
          "1827:    const char *script_file = r_str_trim_head_ro (input + 1);",
          "1829:     RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, script_file+1);",
          "1830:     if (v) {",
          "1831:      char *cmd_text = r_cmd_alias_val_strdup (v);",
          "",
          "[Removed Lines]",
          "1828:    if (*script_file == '$') {",
          "",
          "[Added Lines]",
          "1838:    if (*script_file == '$' && !script_file[1]) {",
          "1839:     eprintf (\"No alias name given.\\n\");",
          "1840:    } else if (*script_file == '$') {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3719:    r_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);",
          "3720:   }",
          "3721:   const bool appendResult = (ptr[1] == '>');",
          "",
          "[Removed Lines]",
          "3722:   if (*str == '$') {",
          "",
          "[Added Lines]",
          "3734:   if (*str == '$' && !str[1]) {",
          "3735:    eprintf (\"No alias name given.\\n\");",
          "3736:   } else if (*str == '$') {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3739:    }",
          "3740:    ret = 0;",
          "3741:    r_buf_free (cmd_out);",
          "3742:   } else if (fdn > 0) {",
          "3744:    pipefd = r_cons_pipe_open (str, fdn, appendResult);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3756:    free (alias_data);",
          "",
          "---------------"
        ],
        "libr/core/cmd_api.c||libr/core/cmd_api.c": [
          "File: libr/core/cmd_api.c -> libr/core/cmd_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:  return NULL;",
          "102: }",
          "104: R_API void r_cmd_alias_init(RCmd *cmd) {",
          "106: }",
          "108: R_API RCmd *r_cmd_new(void) {",
          "",
          "[Removed Lines]",
          "105:  cmd->aliases = ht_pp_new0 ();",
          "",
          "[Added Lines]",
          "104: static void alias_freefn(HtPPKv *kv) {",
          "105:  char *k = kv->key;",
          "106:  RCmdAliasVal *v = kv->value;",
          "108:  free (v->data);",
          "109:  free (k);",
          "110:  free (v);",
          "111: }",
          "113: static void *alias_dupkey(const void *k) {",
          "114:  return strdup ((const char *)k);",
          "115: }",
          "117: static void *alias_dupvalue(const void *v_void) {",
          "118:  RCmdAliasVal *v = (RCmdAliasVal *)v_void;",
          "119:  RCmdAliasVal *vcopy = R_NEW (RCmdAliasVal);",
          "120:  if (!vcopy) {",
          "121:   return NULL;",
          "122:  }",
          "123:  ut8 *data = malloc (v->sz);",
          "124:  if (!data) {",
          "125:   free (vcopy);",
          "126:   return NULL;",
          "127:  }",
          "128:  vcopy->is_data = v->is_data;",
          "129:  vcopy->is_str = v->is_str;",
          "130:  vcopy->sz = v->sz;",
          "131:  vcopy->data = data;",
          "132:  memcpy (vcopy->data, v->data, v->sz);",
          "134:  return vcopy;",
          "135: }",
          "137: static ut32 alias_calcsizeK(const void *k) {",
          "138:  return strlen ((const char *)k);",
          "139: }",
          "141: static ut32 alias_calcsizeV(const void *v) {",
          "142:  return ((RCmdAliasVal *)v)->sz;",
          "143: }",
          "145: static int alias_cmp(const void *k1, const void *k2) {",
          "146:  return strcmp ((const char *)k1, (const char *)k2);",
          "147: }",
          "149: static ut32 alias_hashfn(const void *k_in) {",
          "151:  ut32 hash = 5381;",
          "152:  ut8 c;",
          "153:  const char *k = k_in;",
          "155:  while (*k) {",
          "156:   c = *k++;",
          "158:   hash += (hash << 5) + c;",
          "159:  }",
          "161:  return hash;",
          "162: }",
          "165:  HtPPOptions opt = { 0 };",
          "166:  opt.cmp = alias_cmp;",
          "167:  opt.hashfn = alias_hashfn;",
          "168:  opt.dupkey = alias_dupkey;",
          "169:  opt.dupvalue = alias_dupvalue;",
          "170:  opt.calcsizeK = alias_calcsizeK;",
          "171:  opt.calcsizeV = alias_calcsizeV;",
          "172:  opt.freefn = alias_freefn;",
          "174:  cmd->aliases = ht_pp_new_opt (&opt);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "210: }",
          "212: R_API int r_cmd_alias_set_cmd(RCmd *cmd, const char *k, const char *v) {",
          "220: }",
          "222: R_API int r_cmd_alias_set_str(RCmd *cmd, const char *k, const char *v) {",
          "229:  int len = strlen (v);",
          "230:  while (len-- > 0) {",
          "231:   if (v[len] == '\\r' || v[len] == '\\n') {",
          "233:   } else {",
          "234:    break;",
          "235:   }",
          "236:  }",
          "240: }",
          "242: R_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {",
          "",
          "[Removed Lines]",
          "213:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "214:  val->data = (ut8 *) strdup (v);",
          "215:  val->sz = strlen (v) + 1;",
          "216:  val->is_str = true;",
          "217:  val->is_data = false;",
          "219:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "223:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "224:  val->data = (ut8 *) strdup (v);",
          "225:  val->is_str = true;",
          "226:  val->is_data = true;",
          "232:    val->data[len] = '\\0';",
          "237:  val->sz = len+1;",
          "239:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "",
          "[Added Lines]",
          "282:  RCmdAliasVal val;",
          "283:  val.data = (ut8 *)v;",
          "284:  if (!val.data) {",
          "285:   return 1;",
          "286:  }",
          "287:  val.sz = strlen (v) + 1;",
          "288:  val.is_str = true;",
          "289:  val.is_data = false;",
          "291:  return ht_pp_update (cmd->aliases, k, &val);",
          "295:  RCmdAliasVal val;",
          "296:  val.data = (ut8 *)strdup (v);",
          "297:  if (!val.data) {",
          "298:   return 1;",
          "299:  }",
          "300:  val.is_str = true;",
          "301:  val.is_data = true;",
          "307:    val.data[len] = '\\0';",
          "313:  val.sz = len + 2;",
          "315:  int ret = ht_pp_update (cmd->aliases, k, &val);",
          "316:  free (val.data);",
          "317:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "246:   return 1;",
          "247:  }",
          "251:   return 1;",
          "252:  }",
          "264:  const ut8 *firstnull = NULL;",
          "",
          "[Removed Lines]",
          "249:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "250:  if (!val) {",
          "254:  val->data = malloc (sz);",
          "255:  if (!val->data) {",
          "256:   free (val);",
          "257:   return 1;",
          "258:  }",
          "260:  memcpy (val->data, v, sz);",
          "261:  val->sz = sz;",
          "",
          "[Added Lines]",
          "327:  RCmdAliasVal val;",
          "328:  val.data = malloc (sz);",
          "329:  if (!val.data) {",
          "333:  memcpy (val.data, v, sz);",
          "334:  val.sz = sz;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "280:  if (firstnull == &v[sz-1] && !is_binary) {",
          "283:  } else if (!firstnull && !is_binary) {",
          "287:   if (!data) {",
          "289:   }",
          "293:  } else {",
          "296:  }",
          "303:   while (len-- > 0) {",
          "304:    if (v[len] == '\\r' || v[len] == '\\n') {",
          "306:    } else {",
          "307:     break;",
          "308:    }",
          "309:   }",
          "311:  }",
          "314: }",
          "316: R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {",
          "317:  r_return_val_if_fail (cmd && cmd->aliases && k, NULL);",
          "322: }",
          "324: static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {",
          "",
          "[Removed Lines]",
          "282:   val->is_str = true;",
          "285:   val->sz++;",
          "286:   ut8 *data = realloc (val->data, val->sz);",
          "288:    return 0;",
          "290:   val->data = data;",
          "291:   val->data[val->sz-1] = '\\0';",
          "292:   val->is_str = true;",
          "295:   val->is_str = false;",
          "298:  val->is_data = true;",
          "300:  if (val->is_str) {",
          "302:   int len = val->sz - 1;",
          "305:     val->data[len] = '\\0';",
          "310:   val->sz = len+1;",
          "313:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "319:  bool found;",
          "320:  RCmdAliasVal *v = ht_pp_find(cmd->aliases, k, &found);",
          "321:  return found? v: NULL;",
          "",
          "[Added Lines]",
          "355:   val.is_str = true;",
          "358:   val.sz++;",
          "359:   ut8 *data = realloc (val.data, val.sz);",
          "361:    return 1;",
          "363:   val.data = data;",
          "364:   val.data[val.sz - 1] = '\\0';",
          "365:   val.is_str = true;",
          "368:   val.is_str = false;",
          "371:  val.is_data = true;",
          "373:  if (val.is_str) {",
          "375:   int len = val.sz - 1;",
          "378:     val.data[len] = '\\0';",
          "384:   val.sz = len + 2;",
          "387:  int ret = ht_pp_update (cmd->aliases, k, &val);",
          "388:  free (val.data);",
          "389:  return ret;",
          "395:  return ht_pp_find(cmd->aliases, k, NULL);",
          "",
          "---------------"
        ],
        "libr/core/cmd_cmp.c||libr/core/cmd_cmp.c": [
          "File: libr/core/cmd_cmp.c -> libr/core/cmd_cmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "559:  case 'a': // \"cat\"",
          "560:   if (input[1] == 't') {",
          "561:    const char *path = r_str_trim_head_ro (input + 2);",
          "563:     RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, path+1);",
          "564:     if (v) {",
          "565:      char *v_str = r_cmd_alias_val_strdup (v);",
          "",
          "[Removed Lines]",
          "562:    if (*path == '$') {",
          "",
          "[Added Lines]",
          "562:    if (*path == '$' && !path[1]) {",
          "563:     eprintf (\"No alias name given.\\n\");",
          "564:    } else if (*path == '$') {",
          "",
          "---------------"
        ],
        "libr/core/cmd_debug.c||libr/core/cmd_debug.c": [
          "File: libr/core/cmd_debug.c -> libr/core/cmd_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4728: static ut8 *getFileData(RCore *core, const char *arg, int *sz) {",
          "4729:  ut8 *out = NULL;",
          "4730:  int size = 0;",
          "4732:   RCmdAliasVal *v  = r_cmd_alias_get (core->rcmd, arg+1);",
          "4733:   if (v) {",
          "4734:    out = malloc (v->sz);",
          "",
          "[Removed Lines]",
          "4731:  if (*arg == '$') {",
          "",
          "[Added Lines]",
          "4731:  if (*arg == '$' && !arg[1]) {",
          "4732:   eprintf (\"No alias name given\\n\");",
          "4733:  } else if (*arg == '$') {",
          "",
          "---------------"
        ],
        "libr/core/cmd_write.c||libr/core/cmd_write.c": [
          "File: libr/core/cmd_write.c -> libr/core/cmd_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:    free (out);",
          "587:   }",
          "588:  }",
          "591:   RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, a+1);",
          "592:   if (v) {",
          "593:    buf = malloc (v->sz);",
          "",
          "[Removed Lines]",
          "590:  if (*a == '$') {",
          "",
          "[Added Lines]",
          "590:  if (*a == '$' && !a[1]) {",
          "591:   eprintf (\"No alias name given.\\n\");",
          "592:  } else if (*a == '$') {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "25fc71570ccdeb5838cf0a19bbc0926fccc1582e",
      "candidate_info": {
        "commit_hash": "25fc71570ccdeb5838cf0a19bbc0926fccc1582e",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/25fc71570ccdeb5838cf0a19bbc0926fccc1582e",
        "files": [
          "libr/core/cmd.c",
          "libr/core/cmd_api.c",
          "libr/core/cmd_cmp.c",
          "libr/core/cmd_debug.c",
          "libr/core/cmd_write.c",
          "libr/core/core.c",
          "libr/include/r_cmd.h",
          "libr/include/r_util/r_str.h",
          "libr/util/str.c",
          "test/db/cmd/cmd_alias",
          "test/db/cmd/cmd_print"
        ],
        "message": "Overhaul alias system\n\nAliases now use a hashtable. Aliases are now either commands or data.\nData aliases may be strings or raw bytes.\n\n* Expand alias API\n* Remove remote aliases - remote commands can still be aliased normally\n* Update alias help text\n* Fix an alias test and add new tests\n* Add r_str_escape_raw() for null-safe escaping of unprintable characters\n* Remove command to print alias without newline\n* Fix dif command opening files as strings",
        "before_after_code_files": [
          "libr/core/cmd.c||libr/core/cmd.c",
          "libr/core/cmd_api.c||libr/core/cmd_api.c",
          "libr/core/cmd_cmp.c||libr/core/cmd_cmp.c",
          "libr/core/cmd_debug.c||libr/core/cmd_debug.c",
          "libr/core/cmd_write.c||libr/core/cmd_write.c",
          "libr/core/core.c||libr/core/core.c",
          "libr/include/r_cmd.h||libr/include/r_cmd.h",
          "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h",
          "libr/util/str.c||libr/util/str.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ],
          "candidate": [
            "libr/core/cmd_api.c||libr/core/cmd_api.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/core/cmd.c||libr/core/cmd.c": [
          "File: libr/core/cmd.c -> libr/core/cmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: static const char *help_msg_dollar[] = {",
          "64:  \"Usage:\", \"$alias[=cmd] [args...]\", \"Alias commands and strings (See ?$? for help on $variables)\",",
          "65:  \"$\", \"\", \"list all defined aliases\",",
          "68:  \"$\", \"foo:=123\", \"alias for 'f foo=123'\",",
          "69:  \"$\", \"foo-=4\", \"alias for 'f foo-=4'\",",
          "70:  \"$\", \"foo+=4\", \"alias for 'f foo+=4'\",",
          "71:  \"$\", \"foo\", \"alias for 's foo' (note that command aliases can override flag resolution)\",",
          "76:  \"$\", \"test=#!pipe node /tmp/test.js\", \"create command - rlangpipe script\",",
          "77:  \"$\", \"dis=\", \"undefine alias\",",
          "79:  \"$\", \"dis?\", \"show commands aliased by $dis\",",
          "81:  NULL",
          "82: };",
          "",
          "[Removed Lines]",
          "66:  \"$*\", \"\", \"list all the aliases as r2 commands in base64\",",
          "67:  \"$**\", \"\", \"same as above, but using plain text\",",
          "72:  \"$\", \"dis=base64:AAA==\", \"alias this base64 encoded text to be printed when $dis is called\",",
          "73:  \"$\", \"dis=$hello world\", \"alias this text to be printed when $dis is called\",",
          "74:  \"$\", \"dis=-\", \"open cfg.editor to set the new value for dis alias\",",
          "75:  \"$\", \"dis=af;pdf\", \"create command - analyze to show function\",",
          "78:  \"$\", \"dis\", \"execute the previously defined alias\",",
          "80:  \"$\", \"dis?n\", \"show commands aliased by $dis, without a new line\",",
          "",
          "[Added Lines]",
          "66:  \"$*\", \"\", \"list all defined aliases and their respective values, unprintable characters escaped\",",
          "67:  \"$**\", \"\", \"same as above, but if an alias has unprintable characters, b64 encode it\",",
          "72:  \"$\", \"dis=base64:AAA=\", \"alias $dis to the raw byte output from decoding this base64 string\",",
          "73:  \"$\", \"dis=$hello world\", \"alias $dis to the string after '$' (accepts double-backslash and hex escaping)\",",
          "74:  \"$\", \"dis=-\", \"edit $dis in cfg.editor (accepts backslash and hex escaping)\",",
          "75:  \"$\", \"dis=af\", \"alias $dis to the af command\",",
          "76:  \"$\", \"dis=af;pdf\", \"alias $dis to the af command, then run pdf\",",
          "79:  \"$\", \"dis\", \"execute a defined command alias, or print a data alias with unprintable characters escaped\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "463:  return 1;",
          "464: }",
          "466: static int cmd_uname(void *data, const char *input) { // \"uniq\"",
          "467:  RSysInfo *si = r_sys_info();",
          "468:  if (si) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "467: static bool print_aliases(void *use_b64, const void *key, const void *val){",
          "468:  const char *k = (char *) key;",
          "469:  RCmdAliasVal *v = (RCmdAliasVal *) val;",
          "470:  bool base64 = *(bool *)use_b64;",
          "471:  if (v->is_str) {",
          "472:   r_cons_printf (\"$%s=%s\\n\", k, (char *)v->data);",
          "473:  } else {",
          "474:   char *val_str = base64",
          "475:    ? r_cmd_alias_val_strdup_b64 (v)",
          "476:    : r_cmd_alias_val_strdup (v);",
          "478:   r_cons_printf (\"$%s=%s%s\\n\", k, base64? \"base64:\": \"\", val_str);",
          "479:   free (val_str);",
          "480:  }",
          "481:  return true;",
          "482: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "624:   r_core_cmd_help (core, help_msg_dollar);",
          "625:   return 0;",
          "626:  }",
          "629:  if (!buf) {",
          "630:   return 0;",
          "631:  }",
          "634:  char *q = strchr (buf, ' ');",
          "635:  char *def = strchr (buf, '=');",
          "636:  char *desc = strchr (buf, '?');",
          "639:  int defmode = 0;",
          "640:  if (def && def > buf) {",
          "",
          "[Removed Lines]",
          "627:  int i = strlen (input);",
          "628:  char *buf = malloc (i + 2);",
          "633:  memcpy (buf + 1, input, i + 1);",
          "637:  char *nonl = strchr (buf, 'n');",
          "",
          "[Added Lines]",
          "645:  char *buf = strdup (input);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "663:    ut64 at = r_num_math (core->num, def);",
          "664:    switch (defmode) {",
          "665:    case ':':",
          "667:     return 1;",
          "668:    case '+':",
          "669:     at = r_num_get (core->num, buf + 1) + at;",
          "671:     return 1;",
          "672:    case '-':",
          "673:     at = r_num_get (core->num, buf + 1) - at;",
          "675:     return 1;",
          "676:    }",
          "677:   }",
          "",
          "[Removed Lines]",
          "666:     r_flag_set (core->flags, buf + 1, at, 1);",
          "670:     r_flag_set (core->flags, buf + 1, at, 1);",
          "674:     r_flag_set (core->flags, buf + 1, at, 1);",
          "",
          "[Added Lines]",
          "680:     r_flag_set (core->flags, buf, at, 1);",
          "684:     r_flag_set (core->flags, buf, at, 1);",
          "688:     r_flag_set (core->flags, buf, at, 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "684:   if (!q || (q && q > def)) {",
          "685:    if (*def) {",
          "686:     if (!strcmp (def, \"-\")) {",
          "689:      if (n) {",
          "691:       free (n);",
          "692:      }",
          "693:     } else {",
          "695:     }",
          "696:    } else {",
          "697:     r_cmd_alias_del (core->rcmd, buf);",
          "",
          "[Removed Lines]",
          "687:      const char *v = r_cmd_alias_get (core->rcmd, buf, 0);",
          "688:      char *n = r_cons_editor (NULL, v);",
          "690:       r_cmd_alias_set (core->rcmd, buf, n, 0);",
          "694:      r_cmd_alias_set (core->rcmd, buf, def, 0);",
          "",
          "[Added Lines]",
          "701:      RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, buf);",
          "702:      char *n;",
          "703:      if (v) {",
          "704:       char *v_str = r_cmd_alias_val_strdup (v);",
          "705:       n = r_cons_editor (NULL, v_str);",
          "706:       free (v_str);",
          "707:      } else {",
          "708:       n = r_cons_editor (NULL, NULL);",
          "709:      }",
          "712:       int l = r_str_unescape (n);",
          "713:       r_cmd_alias_set_raw (core->rcmd, buf, (ut8 *)n, l);",
          "716:     } else if (*def == '$') {",
          "717:      char *s = strdup (def+1);",
          "718:      int l = r_str_unescape (s);",
          "719:      r_cmd_alias_set_raw (core->rcmd, buf, (ut8 *)s, l);",
          "720:      free (s);",
          "721:     } else if (!strncmp (def, \"base64:\", 7)) {",
          "722:      int b64_len = strlen (def+7);",
          "723:      if (b64_len) {",
          "724:       ut8* decoded = malloc (b64_len);",
          "725:       if (decoded) {",
          "726:        int decoded_sz = r_base64_decode (decoded, def+7, b64_len);",
          "727:        if (decoded_sz > 0) {",
          "728:         r_cmd_alias_set_raw (core->rcmd, buf, decoded, decoded_sz);",
          "729:        } else {",
          "730:         eprintf (\"Invalid base64.\\n\");",
          "731:        }",
          "732:        free (decoded);",
          "733:       }",
          "734:      } else {",
          "735:       eprintf (\"Invalid base64.\\n\");",
          "736:      }",
          "738:      r_cmd_alias_set_cmd (core->rcmd, buf, def);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "701:  } else if (desc && !q) {",
          "710:    free (buf);",
          "711:    return 1;",
          "712:   } else {",
          "728:   }",
          "734:   }",
          "735:  } else {",
          "737:   if (q) {",
          "739:   }",
          "741:   if (v) {",
          "744:     r_cons_newline ();",
          "745:    } else if (q) {",
          "747:     r_core_cmd0 (core, out);",
          "748:     free (out);",
          "749:    } else {",
          "751:    }",
          "752:   } else {",
          "753:    ut64 at = r_num_get (core->num, buf + 1);",
          "754:    if (at != UT64_MAX) {",
          "755:     r_core_seek (core, at, true);",
          "756:    } else {",
          "758:    }",
          "759:   }",
          "760:  }",
          "",
          "[Removed Lines]",
          "703:   const char *v = r_cmd_alias_get (core->rcmd, buf, 0);",
          "704:   if (v) {",
          "705:    if (nonl == desc + 1) {",
          "706:     r_cons_print (v);",
          "707:    } else {",
          "708:     r_cons_println (v);",
          "709:    }",
          "713:    eprintf (\"unknown key '%s'\\n\", buf);",
          "714:   }",
          "715:  } else if (buf[1] == '*') {",
          "717:   int i, count = 0;",
          "718:   char **keys = r_cmd_alias_keys (core->rcmd, &count);",
          "719:   for (i = 0; i < count; i++) {",
          "720:    const char *v = r_cmd_alias_get (core->rcmd, keys[i], 0);",
          "721:    char *q = r_base64_encode_dyn (v, -1);",
          "722:    if (buf[2] == '*') {",
          "723:     r_cons_printf (\"%s=%s\\n\", keys[i], v);",
          "724:    } else {",
          "725:     r_cons_printf (\"%s=base64:%s\\n\", keys[i], q);",
          "726:    }",
          "727:    free (q);",
          "729:  } else if (!buf[1]) {",
          "730:   int i, count = 0;",
          "731:   char **keys = r_cmd_alias_keys (core->rcmd, &count);",
          "732:   for (i = 0; i < count; i++) {",
          "733:    r_cons_println (keys[i]);",
          "740:   const char *v = r_cmd_alias_get (core->rcmd, buf, 0);",
          "742:    if (*v == '$') {",
          "743:     r_cons_strcat (v + 1);",
          "746:     char *out = r_str_newf (\"%s %s\", v, q + 1);",
          "750:     r_core_cmd0 (core, v);",
          "757:     eprintf (\"Unknown alias '%s'\\n\", buf + 1);",
          "",
          "[Added Lines]",
          "747:   RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, buf);",
          "748:   if (v && !v->is_data) {",
          "750:    r_cons_println ((char *)v->data);",
          "751:    r_cons_flush ();",
          "755:   } else if (v) {",
          "756:    eprintf (\"Alias \\\"$%s\\\" is not a command\\n\", buf);",
          "758:    eprintf (\"No such alias \\\"$%s\\\"\\n\", buf);",
          "760:  } else if (*buf == '*') {",
          "761:   bool use_b64 = (buf[1] == '*');",
          "762:   ht_pp_foreach (core->rcmd->aliases, print_aliases, &use_b64);",
          "763:  } else if (!*buf) {",
          "764:   RList *keys = r_cmd_alias_keys (core->rcmd);",
          "765:   if (keys) {",
          "766:    RListIter *it;",
          "767:    r_list_foreach_iter (keys, it) {",
          "768:     r_cons_printf (\"$%s\\n\", (char *)it->data);",
          "769:    }",
          "770:    r_list_free (keys);",
          "777:   RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, buf);",
          "779:    if (v->is_data) {",
          "780:     char *v_str = r_cmd_alias_val_strdup (v);",
          "781:     r_cons_strcat (v_str);",
          "783:     free (v_str);",
          "785:     char *out = r_str_newf (\"%s %s\", (char *)v->data, q + 1);",
          "789:     r_core_cmd0 (core, (char *)v->data);",
          "796:     eprintf (\"No such alias \\\"$%s\\\"\\n\", buf + 1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "771:  return def;",
          "772: }",
          "799: static void cmd_remote(RCore *core, const char *input, bool retry) {",
          "800:  if (!*input) {",
          "801:   return;",
          "",
          "[Removed Lines]",
          "775: static void aliascmd(RCore *core, const char *str) {",
          "776:  switch (str[0]) {",
          "777:  case '\\0': // \"=$\"",
          "778:   r_core_cmd0 (core, \"$\");",
          "779:   break;",
          "780:  case '-': // \"=$-\"",
          "781:   if (str[1]) {",
          "782:    r_cmd_alias_del (core->rcmd, str + 2);",
          "783:   } else {",
          "784:    r_cmd_alias_del (core->rcmd, NULL);",
          "786:   }",
          "787:   break;",
          "788:  case '?': // \"=$?\"",
          "789:   eprintf (\"Usage: =$[-][remotecmd]  # remote command alias\\n\");",
          "790:   eprintf (\" =$dr   # makes 'dr' alias for =!dr\\n\");",
          "791:   eprintf (\" =$-dr  # unset 'dr' alias\\n\");",
          "792:   break;",
          "793:  default:",
          "794:   r_cmd_alias_set (core->rcmd, str, \"\", 1);",
          "795:   break;",
          "796:  }",
          "797: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "914:    }",
          "915:   }",
          "916:   break;",
          "921:  case '+': // \"=+\"",
          "922:   if (input[1] && input[1] != '?') {",
          "923:    r_core_rtr_add (core, input + 1);",
          "",
          "[Removed Lines]",
          "917:  case '$': // \"=$\"",
          "919:   aliascmd (core, input + 1);",
          "920:   break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1685:   } else {",
          "1686:    const char *file = r_str_trim_head_ro (input + 1);",
          "1687:    if (*file == '$') {",
          "1689:     if (file_data) {",
          "1691:     }",
          "1692:    } else {",
          "1693:     char *file_data = r_file_slurp (file, NULL);",
          "",
          "[Removed Lines]",
          "1688:     const char *file_data = r_cmd_alias_get (core->rcmd, file, 1);",
          "1690:      load_table (core, core->table, strdup (file_data + 1));",
          "",
          "[Added Lines]",
          "1698:     RCmdAliasVal *file_data = r_cmd_alias_get (core->rcmd, file+1);",
          "1700:      char *file_data_str = r_cmd_alias_val_strdup (file_data);",
          "1701:      load_table (core, core->table, strdup (file_data_str));",
          "1702:      free (file_data_str);",
          "1703:     } else {",
          "1704:      eprintf (\"No such alias \\\"$%s\\\"\\n\", file+1);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1812:   {",
          "1813:    const char *script_file = r_str_trim_head_ro (input + 1);",
          "1814:    if (*script_file == '$') {",
          "1817:    } else {",
          "1818:     if (!r_core_run_script (core, script_file)) {",
          "1819:      eprintf (\"Cannot find script '%s'\\n\", script_file);",
          "",
          "[Removed Lines]",
          "1815:     const char *oldText = r_cmd_alias_get (core->rcmd, script_file, 1);",
          "1816:     r_core_cmd0 (core, oldText); // script_file);",
          "",
          "[Added Lines]",
          "1829:     RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, script_file+1);",
          "1830:     if (v) {",
          "1831:      char *cmd_text = r_cmd_alias_val_strdup (v);",
          "1832:      r_core_cmd0 (core, cmd_text);",
          "1833:      free (cmd_text);",
          "1834:     } else {",
          "1835:      eprintf (\"No such alias \\\"$%s\\\"\\n\", script_file+1);",
          "1836:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3702:   if (*str == '$') {",
          "3706:    if (appendResult) {",
          "3714:     } else {",
          "3718:     }",
          "3719:    } else {",
          "3723:    }",
          "3724:    ret = 0;",
          "3726:   } else if (fdn > 0) {",
          "3728:    pipefd = r_cons_pipe_open (str, fdn, appendResult);",
          "",
          "[Removed Lines]",
          "3705:    char *o = r_core_cmd_str (core, cmd);",
          "3707:     const char *oldText = r_cmd_alias_get (core->rcmd, str, 1);",
          "3708:     if (oldText) {",
          "3709:      char *two = r_str_newf (\"%s%s\", oldText, o);",
          "3710:      if (two) {",
          "3711:       r_cmd_alias_set (core->rcmd, str, two, 1);",
          "3712:       free (two);",
          "3713:      }",
          "3715:      char *n = r_str_newf (\"$%s\", o);",
          "3716:      r_cmd_alias_set (core->rcmd, str, n, 1);",
          "3717:      free (n);",
          "3720:     char *n = r_str_newf (\"$%s\", o);",
          "3721:     r_cmd_alias_set (core->rcmd, str, n, 1);",
          "3722:     free (n);",
          "3725:    free (o);",
          "",
          "[Added Lines]",
          "3726:    RBuffer *cmd_out = r_core_cmd_tobuf (core, cmd);",
          "3727:    int alias_len;",
          "3728:    ut8 *alias_data = r_buf_read_all (cmd_out, &alias_len);",
          "3730:     if (r_cmd_alias_append_raw (core->rcmd, str+1, alias_data, alias_len)) {",
          "3731:      eprintf (\"Alias \\\"$%s\\\" is a command - will not attempt to append.\\n\", str+1);",
          "3734:      r_cmd_alias_set_raw (core->rcmd, str+1, alias_data, alias_len);",
          "3737:     r_cmd_alias_set_raw (core->rcmd, str+1, alias_data, alias_len);",
          "3740:    r_buf_free (cmd_out);",
          "",
          "---------------"
        ],
        "libr/core/cmd_api.c||libr/core/cmd_api.c": [
          "File: libr/core/cmd_api.c -> libr/core/cmd_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include <r_core.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include \"ht_pp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101: }",
          "103: R_API void r_cmd_alias_init(RCmd *cmd) {",
          "107: }",
          "109: R_API RCmd *r_cmd_new(void) {",
          "",
          "[Removed Lines]",
          "104:  cmd->aliases.count = 0;",
          "105:  cmd->aliases.keys = NULL;",
          "106:  cmd->aliases.values = NULL;",
          "",
          "[Added Lines]",
          "105:  cmd->aliases = ht_pp_new0 ();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "185:  return res;",
          "186: }",
          "193: }",
          "200:  }",
          "205: }",
          "228:   }",
          "229:  }",
          "231: }",
          "241:   }",
          "242:  }",
          "250:    return 1;",
          "251:   }",
          "252:  }",
          "270:    }",
          "271:   }",
          "272:  }",
          "275: }",
          "290:   }",
          "293:   }",
          "294:  }",
          "296: }",
          "298: R_API void r_cmd_set_data(RCmd *cmd, void *data) {",
          "",
          "[Removed Lines]",
          "188: R_API char **r_cmd_alias_keys(RCmd *cmd, int *sz) {",
          "189:  if (sz) {",
          "191:  }",
          "192:  return cmd->aliases.keys;",
          "195: R_API void r_cmd_alias_free (RCmd *cmd) {",
          "196:  int i; // find",
          "197:  for (i = 0; i < cmd->aliases.count; i++) {",
          "198:   free (cmd->aliases.keys[i]);",
          "199:   free (cmd->aliases.values[i]);",
          "201:  cmd->aliases.count = 0;",
          "202:  R_FREE (cmd->aliases.keys);",
          "203:  R_FREE (cmd->aliases.values);",
          "204:  free (cmd->aliases.remote);",
          "207: R_API bool r_cmd_alias_del (RCmd *cmd, const char *k) {",
          "208:  int i; // find",
          "209:  for (i = 0; i < cmd->aliases.count; i++) {",
          "210:   if (!k || !strcmp (k, cmd->aliases.keys[i])) {",
          "211:    R_FREE (cmd->aliases.values[i]);",
          "212:    cmd->aliases.count--;",
          "213:    if (cmd->aliases.count > 0) {",
          "214:     if (i > 0) {",
          "215:      free (cmd->aliases.keys[i]);",
          "216:      cmd->aliases.keys[i] = cmd->aliases.keys[0];",
          "217:      free (cmd->aliases.values[i]);",
          "218:      cmd->aliases.values[i] = cmd->aliases.values[0];",
          "219:     }",
          "220:     memmove (cmd->aliases.values,",
          "221:      cmd->aliases.values + 1,",
          "222:      cmd->aliases.count * sizeof (void*));",
          "223:     memmove (cmd->aliases.keys,",
          "224:      cmd->aliases.keys + 1,",
          "225:      cmd->aliases.count * sizeof (void*));",
          "226:    }",
          "227:    return true;",
          "230:  return false;",
          "234: R_API int r_cmd_alias_set(RCmd *cmd, const char *k, const char *v, int remote) {",
          "235:  void *tofree = NULL;",
          "236:  if (!strncmp (v, \"base64:\", 7)) {",
          "237:   ut8 *s = r_base64_decode_dyn (v + 7, -1);",
          "238:   if (s) {",
          "239:    tofree = s;",
          "240:    v = (const char *)s;",
          "243:  int i;",
          "244:  for (i = 0; i < cmd->aliases.count; i++) {",
          "245:   int matches = !strcmp (k, cmd->aliases.keys[i]);",
          "246:   if (matches) {",
          "247:    free (cmd->aliases.values[i]);",
          "248:    cmd->aliases.values[i] = strdup (v);",
          "249:    free (tofree);",
          "254:  i = cmd->aliases.count++;",
          "255:  char **K = (char **)realloc (cmd->aliases.keys,",
          "256:          sizeof (char *) * cmd->aliases.count);",
          "257:  if (K) {",
          "258:   cmd->aliases.keys = K;",
          "259:   int *R = (int *)realloc (cmd->aliases.remote,",
          "260:     sizeof (int) * cmd->aliases.count);",
          "261:   if (R) {",
          "262:    cmd->aliases.remote = R;",
          "263:    char **V = (char **)realloc (cmd->aliases.values,",
          "264:      sizeof (char *) * cmd->aliases.count);",
          "265:    if (V) {",
          "266:     cmd->aliases.values = V;",
          "267:     cmd->aliases.keys[i] = strdup (k);",
          "268:     cmd->aliases.values[i] = strdup (v);",
          "269:     cmd->aliases.remote[i] = remote;",
          "273:  free (tofree);",
          "274:  return 0;",
          "277: R_API const char *r_cmd_alias_get(RCmd *cmd, const char *k, int remote) {",
          "278:  r_return_val_if_fail (cmd && k, NULL);",
          "279:  int matches, i;",
          "281:  for (i = 0; i < cmd->aliases.count; i++) {",
          "282:   matches = 0;",
          "283:   if (remote) {",
          "284:    if (cmd->aliases.remote[i]) {",
          "285:     matches = !strncmp (k, cmd->aliases.keys[i],",
          "286:      strlen (cmd->aliases.keys[i]));",
          "287:    }",
          "288:   } else {",
          "289:    matches = !strcmp (k, cmd->aliases.keys[i]);",
          "291:   if (matches) {",
          "292:    return cmd->aliases.values[i];",
          "295:  return NULL;",
          "",
          "[Added Lines]",
          "187: static bool get_keys(void *keylist_in, const void *k, const void *v) {",
          "188:  RList *keylist = (RList *) keylist_in;",
          "189:  return r_list_append (keylist, (char *) k);",
          "192: R_API RList *r_cmd_alias_keys(RCmd *cmd) {",
          "193:  RList *keylist = r_list_new ();",
          "194:  if (!keylist) {",
          "195:   return NULL;",
          "198:  ht_pp_foreach (cmd->aliases, get_keys, keylist);",
          "200:  return keylist;",
          "203: R_API void r_cmd_alias_free(RCmd *cmd) {",
          "204:  ht_pp_free (cmd->aliases);",
          "205:  cmd->aliases = NULL;",
          "206: }",
          "208: R_API bool r_cmd_alias_del(RCmd *cmd, const char *k) {",
          "209:  return ht_pp_delete(cmd->aliases, k);",
          "210: }",
          "212: R_API int r_cmd_alias_set_cmd(RCmd *cmd, const char *k, const char *v) {",
          "213:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "214:  val->data = (ut8 *) strdup (v);",
          "215:  val->sz = strlen (v) + 1;",
          "216:  val->is_str = true;",
          "217:  val->is_data = false;",
          "219:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "220: }",
          "222: R_API int r_cmd_alias_set_str(RCmd *cmd, const char *k, const char *v) {",
          "223:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "224:  val->data = (ut8 *) strdup (v);",
          "225:  val->is_str = true;",
          "226:  val->is_data = true;",
          "229:  int len = strlen (v);",
          "230:  while (len-- > 0) {",
          "231:   if (v[len] == '\\r' || v[len] == '\\n') {",
          "232:    val->data[len] = '\\0';",
          "233:   } else {",
          "234:    break;",
          "237:  val->sz = len+1;",
          "239:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "242: R_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {",
          "243:  int i;",
          "245:  if (sz < 1) {",
          "246:   return 1;",
          "247:  }",
          "249:  RCmdAliasVal *val = R_NEW (RCmdAliasVal);",
          "250:  if (!val) {",
          "251:   return 1;",
          "252:  }",
          "254:  val->data = malloc (sz);",
          "255:  if (!val->data) {",
          "256:   free (val);",
          "257:   return 1;",
          "258:  }",
          "260:  memcpy (val->data, v, sz);",
          "261:  val->sz = sz;",
          "264:  const ut8 *firstnull = NULL;",
          "265:  for (i = 0; i < sz; i++) {",
          "267:   if (v[i] == '\\0') {",
          "268:    firstnull = &v[i];",
          "269:    break;",
          "273:  if (firstnull && firstnull == &v[sz-1]) {",
          "275:   val->is_str = true;",
          "276:  } else if (!firstnull) {",
          "278:   val->sz++;",
          "279:   val->data = realloc(val->data, val->sz);",
          "280:   if (!val->data) {",
          "281:    free (val);",
          "284:   val->data[val->sz-1] = '\\0';",
          "285:   val->is_str = true;",
          "286:  } else {",
          "287:   val->is_str = false;",
          "290:  val->is_data = true;",
          "292:  if (val->is_str) {",
          "294:   int len = val->sz - 1;",
          "295:   while (len-- > 0) {",
          "296:    if (v[len] == '\\r' || v[len] == '\\n') {",
          "297:     val->data[len] = '\\0';",
          "298:    } else {",
          "299:     break;",
          "302:   val->sz = len+1;",
          "305:  return ht_pp_update (cmd->aliases, strdup (k), val);",
          "308: R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {",
          "309:  r_return_val_if_fail (cmd && cmd->aliases && k, NULL);",
          "311:  bool found;",
          "312:  RCmdAliasVal *v = ht_pp_find(cmd->aliases, k, &found);",
          "313:  return found? v: NULL;",
          "314: }",
          "316: static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {",
          "317:  ut8* out;",
          "318:  int out_sz;",
          "321:  int bytes_from_first = first->is_str",
          "322:   ? first->sz - 1",
          "323:   : first->sz;",
          "325:  out_sz = bytes_from_first + second_sz;",
          "326:  out = malloc (out_sz);",
          "327:  if (!out) {",
          "328:   return NULL;",
          "329:  }",
          "332:  memcpy (out, first->data, bytes_from_first);",
          "334:  memcpy (out+bytes_from_first, second, second_sz);",
          "336:  if (out_sz) {",
          "338:  }",
          "339:  return out;",
          "340: }",
          "342: R_API int r_cmd_alias_append_str(RCmd *cmd, const char *k, const char *a) {",
          "343:  RCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);",
          "344:  if (v_old) {",
          "345:   if (!v_old->is_data) {",
          "346:    return 1;",
          "349:   int new_len;",
          "350:   ut8* new = alias_append_internal (&new_len, v_old, (ut8 *)a, strlen (a) + 1);",
          "352:   if (!new) {",
          "353:    return 1;",
          "356:   r_cmd_alias_set_raw (cmd, k, new, new_len);",
          "357:   free (new);",
          "358:  } else {",
          "359:   r_cmd_alias_set_str (cmd, k, a);",
          "362:  return 0;",
          "363: }",
          "365: R_API int r_cmd_alias_append_raw(RCmd *cmd, const char *k, const ut8 *a, int sz) {",
          "366:  RCmdAliasVal *v_old = r_cmd_alias_get (cmd, k);",
          "367:  if (v_old) {",
          "368:   if (!v_old->is_data) {",
          "369:    return 1;",
          "370:   }",
          "372:   int new_len;",
          "373:   ut8 *new = alias_append_internal (&new_len, v_old, a, sz);",
          "375:   r_cmd_alias_set_raw (cmd, k, new, new_len);",
          "376:   free (new);",
          "377:  } else {",
          "378:   r_cmd_alias_set_raw (cmd, k, a, sz);",
          "379:  }",
          "381:  return 0;",
          "382: }",
          "385: R_API char *r_cmd_alias_val_strdup(RCmdAliasVal *v) {",
          "386:  if (v->is_str) {",
          "387:   return strdup ((char *)v->data);",
          "388:  }",
          "390:  return r_str_escape_raw (v->data, v->sz);",
          "391: }",
          "394: R_API char *r_cmd_alias_val_strdup_b64(RCmdAliasVal *v) {",
          "395:  if (v->is_str) {",
          "396:   return strdup ((char *)v->data);",
          "397:  }",
          "399:  return r_base64_encode_dyn ((char *)v->data, v->sz);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "328:   }",
          "329:  } else {",
          "330:   char *nstr = NULL;",
          "340:   }",
          "341:   r_list_foreach (cmd->plist, iter, cp) {",
          "342:    if (cp->call && cp->call (cmd->data, input)) {",
          "",
          "[Removed Lines]",
          "331:   const char *ji = r_cmd_alias_get (cmd, input, 1);",
          "332:   if (ji) {",
          "333:    if (*ji == '$') {",
          "334:     r_cons_strcat (ji + 1);",
          "335:     return true;",
          "336:    } else {",
          "337:     nstr = r_str_newf (\"=!%s\", input);",
          "338:     input = nstr;",
          "339:    }",
          "",
          "[Added Lines]",
          "435:   RCmdAliasVal *v = r_cmd_alias_get (cmd, input);",
          "436:   if (v && v->is_data) {",
          "437:    char *v_str = r_cmd_alias_val_strdup (v);",
          "438:    r_cons_strcat (v_str);",
          "439:    free (v_str);",
          "440:    return true;",
          "",
          "---------------"
        ],
        "libr/core/cmd_cmp.c||libr/core/cmd_cmp.c": [
          "File: libr/core/cmd_cmp.c -> libr/core/cmd_cmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "560:   if (input[1] == 't') {",
          "561:    const char *path = r_str_trim_head_ro (input + 2);",
          "562:    if (*path == '$') {",
          "566:     }",
          "567:    } else {",
          "568:     if (r_fs_check (core->fs, path)) {",
          "",
          "[Removed Lines]",
          "563:     const char *oldText = r_cmd_alias_get (core->rcmd, path, 1);",
          "564:     if (oldText) {",
          "565:      r_cons_printf (\"%s\\n\", oldText + 1);",
          "",
          "[Added Lines]",
          "563:     RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, path+1);",
          "564:     if (v) {",
          "565:      char *v_str = r_cmd_alias_val_strdup (v);",
          "566:      r_cons_println (v_str);",
          "567:      free (v_str);",
          "568:     } else {",
          "569:      eprintf (\"No such alias \\\"$%s\\\"\\n\", path+1);",
          "",
          "---------------"
        ],
        "libr/core/cmd_debug.c||libr/core/cmd_debug.c": [
          "File: libr/core/cmd_debug.c -> libr/core/cmd_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4725:  return 1;",
          "4726: }",
          "4729:  if (*arg == '$') {",
          "4731:  }",
          "4733: }",
          "4735: static void consumeBuffer(RBuffer *buf, const char *cmd, const char *errmsg) {",
          "",
          "[Removed Lines]",
          "4728: static ut8*getFileData(RCore *core, const char *arg) {",
          "4730:   return (ut8*) r_cmd_alias_get (core->rcmd, arg, 1);",
          "4732:  return (ut8*)r_file_slurp (arg, NULL);",
          "",
          "[Added Lines]",
          "4728: static ut8 *getFileData(RCore *core, const char *arg, int *sz) {",
          "4729:  ut8 *out = NULL;",
          "4730:  int size = 0;",
          "4732:   RCmdAliasVal *v  = r_cmd_alias_get (core->rcmd, arg+1);",
          "4733:   if (v) {",
          "4734:    out = malloc (v->sz);",
          "4735:    if (out) {",
          "4736:     memcpy (out, v->data, v->sz);",
          "4737:     size = v->sz;",
          "4738:    }",
          "4739:   } else {",
          "4740:    eprintf (\"No such alias \\\"$%s\\\"\\n\", arg+1);",
          "4741:   }",
          "4742:  } else {",
          "4743:   size_t file_sz;",
          "4744:   out = (ut8*) r_file_slurp (arg, &file_sz);",
          "4745:   size = file_sz;",
          "4746:  }",
          "4748:  if (sz) {",
          "4752:  return out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5225:       char *arg2 = strchr (arg, ' ');",
          "5226:       if (arg2) {",
          "5230:        if (a && b) {",
          "5233:         RDiff *d = r_diff_new ();",
          "5234:         char *uni = r_diff_buffers_to_string (d, a, al, b, bl);",
          "5235:         r_cons_printf (\"%s\\n\", uni);",
          "",
          "[Removed Lines]",
          "5228:        ut8 *a = getFileData (core, arg);",
          "5229:        ut8 *b = getFileData (core, arg2);",
          "5231:         int al = strlen ((const char*)a);",
          "5232:         int bl = strlen ((const char*)b);",
          "",
          "[Added Lines]",
          "5248:        int al;",
          "5249:        int bl;",
          "5250:        ut8 *a = getFileData (core, arg, &al);",
          "5251:        ut8 *b = getFileData (core, arg2, &bl);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5238:        } else {",
          "5239:         eprintf (\"Cannot open those alias files\\n\");",
          "5240:        }",
          "5241:       }",
          "5242:       free (arg);",
          "5243:      } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5261:        free (a);",
          "5262:        free (b);",
          "",
          "---------------"
        ],
        "libr/core/cmd_write.c||libr/core/cmd_write.c": [
          "File: libr/core/cmd_write.c -> libr/core/cmd_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:  }",
          "590:  if (*a == '$') {",
          "595:   }",
          "596:  } else {",
          "597:   buf = (ut8*) r_file_slurp (a, &size);",
          "",
          "[Removed Lines]",
          "591:   const char *res = r_cmd_alias_get (core->rcmd, a, 1);",
          "592:   if (res) {",
          "593:    buf = (ut8*)strdup (res);",
          "594:    size = strlen (res);",
          "",
          "[Added Lines]",
          "591:   RCmdAliasVal *v = r_cmd_alias_get (core->rcmd, a+1);",
          "592:   if (v) {",
          "593:    buf = malloc (v->sz);",
          "594:    if (buf) {",
          "595:     size = v->sz;",
          "596:     memcpy (buf, v->data, size);",
          "597:    } else {",
          "598:     size = 0;",
          "599:    }",
          "600:   } else {",
          "601:    eprintf (\"No such alias \\\"$%s\\\"\\n\", a+1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1436:  const char *filename = \"\";",
          "1437:  char _fn[32];",
          "1438:  _fn[0] = 0;",
          "1440:  if (*str == 's') { // \"wts\"",
          "1441:   if (str[1] == ' ') {",
          "1442:    eprintf (\"Write to server\\n\");",
          "",
          "[Removed Lines]",
          "1439:  char *tmp;",
          "",
          "[Added Lines]",
          "1446:  char *size_sep;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1546:   } else {",
          "1547:    filename = str + 1;",
          "1548:   }",
          "1550:   if (!filename || !*filename) {",
          "1551:    const char* prefix = r_config_get (core->config, \"cfg.prefixdump\");",
          "1552:    snprintf (_fn, sizeof (_fn), \"%s.0x%08\"PFMT64x, prefix, poff);",
          "1553:    filename = _fn;",
          "1554:   }",
          "1556:    if (toend) {",
          "1557:     sz = r_io_fd_size (core->io, core->io->desc->fd) - core->offset;",
          "1558:     if (sz < 0) {",
          "1559:      eprintf (\"Warning: File size is unknown.\");",
          "1560:     }",
          "1561:    } else {",
          "1564:    }",
          "1570:    }",
          "1571:   } else {",
          "1572:    if (toend) {",
          "",
          "[Removed Lines]",
          "1549:   tmp = *str? strchr (str + 1, ' ') : NULL;",
          "1555:   if (tmp) {",
          "1562:     sz = (st64) r_num_math (core->num, tmp + 1);",
          "1565:    if ((st64)sz < 1) {",
          "1567:     sz = 0;",
          "1568:    } else if (!r_core_dump (core, filename, poff, (ut64)sz, append)) {",
          "1569:     sz = -1;",
          "",
          "[Added Lines]",
          "1556:   size_sep = *str? strchr (str + 1, ' ') : NULL;",
          "1564:   if (size_sep) {",
          "1571:     sz = (st64) r_num_math (core->num, size_sep + 1);",
          "1573:     if (sz < 1) {",
          "1574:      eprintf (\"%s is not a valid size.\\n\", size_sep + 1);",
          "1575:      sz = -1;",
          "1576:     }",
          "1582:    if (*filename == '$') {",
          "1583:     if (append) {",
          "1584:      if (sz > 0 && r_cmd_alias_append_raw (core->rcmd, filename+1, core->block, sz)) {",
          "1585:       eprintf (\"Alias \\\"$%s\\\" is a command - will not attempt to append.\\n\", filename+1);",
          "1586:      }",
          "1587:     } else {",
          "1588:      if (sz > 0) {",
          "1589:       r_cmd_alias_set_raw (core->rcmd, filename+1, core->block, sz);",
          "1590:      }",
          "1591:     }",
          "1592:    } else {",
          "1594:     if (sz > 0 && !r_core_dump (core, filename, poff, (ut64)sz, append)) {",
          "1595:      sz = -1;",
          "1596:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1583:      sz = -1;",
          "1584:     }",
          "1585:    } else {",
          "1587:     if (*filename == '$') {",
          "1591:     } else {",
          "1593:       sz = -1;",
          "1594:      }",
          "1595:     }",
          "",
          "[Removed Lines]",
          "1586:     sz = core->blocksize;",
          "1588:      char *data = r_str_ndup ((const char *)core->block, sz);",
          "1589:      r_cmd_alias_set (core->rcmd, filename, data, 1);",
          "1590:      free (data);",
          "1592:      if (!r_file_dump (filename, core->block, sz, append)) {",
          "",
          "[Added Lines]",
          "1614:      if (append) {",
          "1615:       if (r_cmd_alias_append_raw (core->rcmd, filename+1, core->block, sz)) {",
          "1616:        eprintf (\"Alias \\\"$%s\\\" is a command - will not attempt to append.\\n\", filename+1);",
          "1617:       }",
          "1618:      } else {",
          "1619:       r_cmd_alias_set_raw (core->rcmd, filename+1, core->block, sz);",
          "1620:      }",
          "1622:      if (sz > 0 && !r_file_dump (filename, core->block, sz, append)) {",
          "",
          "---------------"
        ],
        "libr/core/core.c||libr/core/core.c": [
          "File: libr/core/core.c -> libr/core/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1416:  }",
          "1417: }",
          "1419: static void autocomplete_minus(RCore *core, RLineCompletion *completion, const char *str) {",
          "1420:  r_return_if_fail (str);",
          "1422:  int length = strlen (str);",
          "1424:  if (!keys) {",
          "1425:   return;",
          "1426:  }",
          "1431:   }",
          "1432:  }",
          "1433: }",
          "1435: static void autocomplete_breakpoints(RCore *core, RLineCompletion *completion, const char *str) {",
          "",
          "[Removed Lines]",
          "1421:  int count;",
          "1423:  char **keys = r_cmd_alias_keys(core->rcmd, &count);",
          "1427:  int i;",
          "1428:  for (i = 0; i < count; i++) {",
          "1429:   if (!strncmp (keys[i], str, length)) {",
          "1430:    r_line_completion_push (completion, keys[i]);",
          "",
          "[Added Lines]",
          "1419: static bool get_alias_keys(void *keylist_in, const void *k, const void *v){",
          "1420:  RList *keylist = (RList *)keylist_in;",
          "1421:  return r_list_append (keylist, (char *)k);",
          "1422: }",
          "1428:  RList *keys = r_list_new ();",
          "1433:  ht_pp_foreach (core->rcmd->aliases, get_alias_keys, keys);",
          "1435:  RListIter *it;",
          "1436:  r_list_foreach_iter (keys, it) {",
          "1437:   if (!strncmp (it->data, str, length)) {",
          "1438:    r_line_completion_push (completion, it->data);",
          "1442:  r_list_free (keys);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1976:   }",
          "1977:   ls_free (l);",
          "1978:  } else if (!strncmp (buf->data, \"$\", 1)) {",
          "1983:    if (!len || !strncmp (buf->data, key, len)) {",
          "1984:     r_line_completion_push (completion, key);",
          "1985:    }",
          "1986:   }",
          "1987:  } else if (!strncmp (buf->data, \"ts \", 3)",
          "1988:  || !strncmp (buf->data, \"ta \", 3)",
          "1989:  || !strncmp (buf->data, \"tp \", 3)",
          "",
          "[Removed Lines]",
          "1979:   int i;",
          "1980:   for (i = 0; i < core->rcmd->aliases.count; i++) {",
          "1981:    const char *key = core->rcmd->aliases.keys[i];",
          "1982:    int len = strlen (buf->data);",
          "",
          "[Added Lines]",
          "1989:   RList *keys = r_cmd_alias_keys (core->rcmd);",
          "1990:   RListIter *it;",
          "1991:   int len = strlen (buf->data);",
          "1992:   r_list_foreach_iter (keys, it) {",
          "1993:    char *key = (char *)it->data;",
          "1998:   r_list_free (keys);",
          "",
          "---------------"
        ],
        "libr/include/r_cmd.h||libr/include/r_cmd.h": [
          "File: libr/include/r_cmd.h -> libr/include/r_cmd.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_types.h>",
          "5: #include <r_util.h>",
          "6: #include <r_bind.h>",
          "8: #ifdef __cplusplus",
          "9: extern \"C\" {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include \"ht_pp.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:  RCmdCb callback;",
          "69: } RCmdItem;",
          "78: typedef struct r_cmd_desc_example_t {",
          "79:  const char *example;",
          "",
          "[Removed Lines]",
          "71: typedef struct r_cmd_alias_t {",
          "72:  int count;",
          "73:  char **keys;",
          "74:  char **values;",
          "75:  int *remote;",
          "76: } RCmdAlias;",
          "",
          "[Added Lines]",
          "72: typedef HtPP *RCmdAlias;",
          "74: typedef struct r_cmd_alias_val_t {",
          "75:  ut8 *data; // The actual value buffer",
          "76:  int sz; // Buffer size",
          "77:  bool is_str; // Is the buffer string-safe? (i.e. strlen(v) == sz-1. dont strlen if this isnt set)",
          "78:  bool is_data; // Is the buffer data or a command? (if false, is_str must be true - commands can't be raw)",
          "79: } RCmdAliasVal;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "283: R_API int r_cmd_macro_break(RCmdMacro *mac, const char *value);",
          "285: R_API bool r_cmd_alias_del(RCmd *cmd, const char *k);",
          "289: R_API void r_cmd_alias_free(RCmd *cmd);",
          "290: R_API void r_cmd_macro_fini(RCmdMacro *mac);",
          "",
          "[Removed Lines]",
          "286: R_API char **r_cmd_alias_keys(RCmd *cmd, int *sz);",
          "287: R_API int r_cmd_alias_set(RCmd *cmd, const char *k, const char *v, int remote);",
          "288: R_API const char *r_cmd_alias_get(RCmd *cmd, const char *k, int remote);",
          "",
          "[Added Lines]",
          "289: R_API RList *r_cmd_alias_keys(RCmd *cmd);",
          "290: R_API int r_cmd_alias_set_cmd(RCmd *cmd, const char *k, const char *v);",
          "291: R_API int r_cmd_alias_set_str(RCmd *cmd, const char *k, const char *v);",
          "292: R_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz);",
          "293: R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k);",
          "294: R_API int r_cmd_alias_append_str(RCmd *cmd, const char *k, const char *a);",
          "295: R_API int r_cmd_alias_append_raw(RCmd *cmd, const char *k, const ut8 *a, int sz);",
          "296: R_API char *r_cmd_alias_val_strdup(RCmdAliasVal *v);",
          "297: R_API char *r_cmd_alias_val_strdup_b64(RCmdAliasVal *v);",
          "",
          "---------------"
        ],
        "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h": [
          "File: libr/include/r_util/r_str.h -> libr/include/r_util/r_str.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: R_API char *r_str_path_escape(const char *path);",
          "189: R_API int r_str_unescape(char *buf);",
          "190: R_API char *r_str_sanitize_r2(const char *buf);",
          "191: R_API char *r_str_escape(const char *buf);",
          "192: R_API char *r_str_escape_sh(const char *buf);",
          "193: R_API char *r_str_escape_sql(const char *buf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: R_API char *r_str_escape_raw(const ut8 *buf, int sz);",
          "",
          "---------------"
        ],
        "libr/util/str.c||libr/util/str.c": [
          "File: libr/util/str.c -> libr/util/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1381:  return new_buf;",
          "1382: }",
          "1384: R_API char *r_str_escape(const char *buf) {",
          "1385:  return r_str_escape_ (buf, false, true, true, false, true);",
          "1386: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1385: R_API char *r_str_escape_raw(const ut8 *buf, int sz) {",
          "1386:  r_return_val_if_fail (buf, NULL);",
          "1389:  char *new_buf = malloc (1 + sz * 4);",
          "1390:  if (!new_buf) {",
          "1391:   return NULL;",
          "1392:  }",
          "1393:  char *q = new_buf;",
          "1394:  int i;",
          "1395:  for (i = 0; i < sz; i++) {",
          "1396:   r_str_byte_escape ((char *)&buf[i], &q, false, false, true);",
          "1397:  }",
          "1399:  return new_buf;",
          "1400: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
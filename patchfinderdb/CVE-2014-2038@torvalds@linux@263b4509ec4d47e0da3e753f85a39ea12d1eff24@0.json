{
  "cve_id": "CVE-2014-2038",
  "cve_desc": "The nfs_can_extend_write function in fs/nfs/write.c in the Linux kernel before 3.13.3 relies on a write delegation to extend a write operation without a certain up-to-date verification, which allows local users to obtain sensitive information from kernel memory in opportunistic circumstances by writing to a file in an NFS filesystem and then reading the same file.",
  "repo": "torvalds/linux",
  "patch_hash": "263b4509ec4d47e0da3e753f85a39ea12d1eff24",
  "patch_info": {
    "commit_hash": "263b4509ec4d47e0da3e753f85a39ea12d1eff24",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24",
    "files": [
      "fs/nfs/write.c"
    ],
    "message": "nfs: always make sure page is up-to-date before extending a write to cover the entire page\n\nWe should always make sure the cached page is up-to-date when we're\ndetermining whether we can extend a write to cover the full page -- even\nif we've received a write delegation from the server.\n\nCommit c7559663 added logic to skip this check if we have a write\ndelegation, which can lead to data corruption such as the following\nscenario if client B receives a write delegation from the NFS server:\n\nClient A:\n    # echo 123456789 > /mnt/file\n\nClient B:\n    # echo abcdefghi >> /mnt/file\n    # cat /mnt/file\n    0\ufffdD0\ufffdabcdefghi\n\nJust because we hold a write delegation doesn't mean that we've read in\nthe entire page contents.\n\nCc: <stable@vger.kernel.org> # v3.11+\nSigned-off-by: Scott Mayhew <smayhew@redhat.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
    "before_after_code_files": [
      "fs/nfs/write.c||fs/nfs/write.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/write.c||fs/nfs/write.c": [
      "File: fs/nfs/write.c -> fs/nfs/write.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "928: static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)",
      "929: {",
      "930:  if (file->f_flags & O_DSYNC)",
      "931:   return 0;",
      "932:  if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))",
      "933:   return 1;",
      "936:    inode->i_flock->fl_end == OFFSET_MAX &&",
      "938:   return 1;",
      "939:  return 0;",
      "940: }",
      "",
      "[Removed Lines]",
      "934:  if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||",
      "935:    (inode->i_flock->fl_start == 0 &&",
      "937:    inode->i_flock->fl_type != F_RDLCK)))",
      "",
      "[Added Lines]",
      "932:  if (!nfs_write_pageuptodate(page, inode))",
      "933:   return 0;",
      "936:  if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&",
      "938:    inode->i_flock->fl_type != F_RDLCK))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5263e31e452fb84138b9bee061d5c06c0f359fea",
      "candidate_info": {
        "commit_hash": "5263e31e452fb84138b9bee061d5c06c0f359fea",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5263e31e452fb84138b9bee061d5c06c0f359fea",
        "files": [
          "fs/ceph/locks.c",
          "fs/locks.c",
          "fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c",
          "fs/nfs/pagelist.c",
          "fs/nfs/write.c"
        ],
        "message": "locks: move flock locks to file_lock_context\n\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nAcked-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "fs/ceph/locks.c||fs/ceph/locks.c",
          "fs/locks.c||fs/locks.c",
          "fs/nfs/delegation.c||fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c",
          "fs/nfs/pagelist.c||fs/nfs/pagelist.c",
          "fs/nfs/write.c||fs/nfs/write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ],
          "candidate": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ceph/locks.c||fs/ceph/locks.c": [
          "File: fs/ceph/locks.c -> fs/ceph/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "239:  return err;",
          "240: }",
          "247: void ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)",
          "248: {",
          "249:  struct file_lock *lock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "251:  struct file_lock_context *ctx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255:  for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {",
          "256:   if (lock->fl_flags & FL_POSIX)",
          "257:    ++(*fcntl_count);",
          "259:    ++(*flock_count);",
          "260:  }",
          "261:  spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "258:   else if (lock->fl_flags & FL_FLOCK)",
          "",
          "[Added Lines]",
          "260:  }",
          "262:  ctx = inode->i_flctx;",
          "263:  if (ctx) {",
          "264:   list_for_each_entry(lock, &ctx->flc_flock, fl_list)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "273:     int num_fcntl_locks, int num_flock_locks)",
          "274: {",
          "275:  struct file_lock *lock;",
          "276:  int err = 0;",
          "277:  int seen_fcntl = 0;",
          "278:  int seen_flock = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:  struct file_lock_context *ctx;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "295:    ++l;",
          "296:   }",
          "297:  }",
          "300:    ++seen_flock;",
          "301:    if (seen_flock > num_flock_locks) {",
          "302:     err = -ENOSPC;",
          "",
          "[Removed Lines]",
          "298:  for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {",
          "299:   if (lock->fl_flags & FL_FLOCK) {",
          "",
          "[Added Lines]",
          "306:  ctx = inode->i_flctx;",
          "307:  if (ctx) {",
          "308:   list_for_each_entry(lock, &ctx->flc_flock, fl_list) {",
          "",
          "---------------"
        ],
        "fs/locks.c||fs/locks.c": [
          "File: fs/locks.c -> fs/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "694:  locks_insert_global_locks(fl);",
          "695: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "697: static void",
          "698: locks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)",
          "699: {",
          "700:  fl->fl_nspid = get_pid(task_tgid(current));",
          "701:  list_add_tail(&fl->fl_list, before);",
          "702:  locks_insert_global_locks(fl);",
          "703: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "739:   locks_free_lock(fl);",
          "740: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "750: static void",
          "751: locks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)",
          "752: {",
          "753:  locks_delete_global_locks(fl);",
          "754:  if (fl->fl_nspid) {",
          "755:   put_pid(fl->fl_nspid);",
          "756:   fl->fl_nspid = NULL;",
          "757:  }",
          "758:  locks_wake_up_blocks(fl);",
          "759:  list_move(&fl->fl_list, dispose);",
          "760: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "888: static int flock_lock_file(struct file *filp, struct file_lock *request)",
          "889: {",
          "890:  struct file_lock *new_fl = NULL;",
          "893:  int error = 0;",
          "895:  LIST_HEAD(dispose);",
          "897:  if (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {",
          "898:   new_fl = locks_alloc_lock();",
          "899:   if (!new_fl)",
          "",
          "[Removed Lines]",
          "891:  struct file_lock **before;",
          "892:  struct inode * inode = file_inode(filp);",
          "894:  int found = 0;",
          "",
          "[Added Lines]",
          "911:  struct file_lock *fl;",
          "912:  struct file_lock_context *ctx;",
          "913:  struct inode *inode = file_inode(filp);",
          "915:  bool found = false;",
          "918:  ctx = locks_get_lock_context(inode);",
          "919:  if (!ctx)",
          "920:   return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "904:  if (request->fl_flags & FL_ACCESS)",
          "905:   goto find_conflict;",
          "913:   if (filp != fl->fl_file)",
          "914:    continue;",
          "915:   if (request->fl_type == fl->fl_type)",
          "916:    goto out;",
          "919:   break;",
          "920:  }",
          "",
          "[Removed Lines]",
          "907:  for_each_lock(inode, before) {",
          "908:   struct file_lock *fl = *before;",
          "909:   if (IS_POSIX(fl))",
          "910:    break;",
          "911:   if (IS_LEASE(fl))",
          "912:    continue;",
          "917:   found = 1;",
          "918:   locks_delete_lock(before, &dispose);",
          "",
          "[Added Lines]",
          "932:  list_for_each_entry(fl, &ctx->flc_flock, fl_list) {",
          "937:   found = true;",
          "938:   locks_delete_lock_ctx(fl, &dispose);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "936:  }",
          "938: find_conflict:",
          "945:   if (!flock_locks_conflict(request, fl))",
          "946:    continue;",
          "947:   error = -EAGAIN;",
          "",
          "[Removed Lines]",
          "939:  for_each_lock(inode, before) {",
          "940:   struct file_lock *fl = *before;",
          "941:   if (IS_POSIX(fl))",
          "942:    break;",
          "943:   if (IS_LEASE(fl))",
          "944:    continue;",
          "",
          "[Added Lines]",
          "959:  list_for_each_entry(fl, &ctx->flc_flock, fl_list) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "954:  if (request->fl_flags & FL_ACCESS)",
          "955:   goto out;",
          "956:  locks_copy_lock(new_fl, request);",
          "958:  new_fl = NULL;",
          "959:  error = 0;",
          "",
          "[Removed Lines]",
          "957:  locks_insert_lock(before, new_fl);",
          "",
          "[Added Lines]",
          "972:  locks_insert_lock_ctx(new_fl, &ctx->flc_flock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2412:   .fl_type = F_UNLCK,",
          "2413:   .fl_end = OFFSET_MAX,",
          "2414:  };",
          "2417:   return;",
          "2419:  if (filp->f_op->flock)",
          "",
          "[Removed Lines]",
          "2416:  if (!file_inode(filp)->i_flock)",
          "",
          "[Added Lines]",
          "2430:  struct file_lock_context *flctx = file_inode(filp)->i_flctx;",
          "2432:  if (!flctx || list_empty(&flctx->flc_flock))",
          "",
          "---------------"
        ],
        "fs/nfs/delegation.c||fs/nfs/delegation.c": [
          "File: fs/nfs/delegation.c -> fs/nfs/delegation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: {",
          "86:  struct inode *inode = state->inode;",
          "87:  struct file_lock *fl;",
          "88:  int status = 0;",
          "91:   goto out;",
          "94:  spin_lock(&inode->i_lock);",
          "95:  for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {",
          "97:    continue;",
          "98:   if (nfs_file_open_context(fl->fl_file) != ctx)",
          "99:    continue;",
          "",
          "[Removed Lines]",
          "90:  if (inode->i_flock == NULL)",
          "96:   if (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))",
          "",
          "[Added Lines]",
          "88:  struct file_lock_context *flctx;",
          "91:  if (inode->i_flock == NULL && inode->i_flctx == NULL)",
          "97:   if (!(fl->fl_flags & (FL_POSIX)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:    goto out;",
          "104:   spin_lock(&inode->i_lock);",
          "105:  }",
          "106:  spin_unlock(&inode->i_lock);",
          "107: out:",
          "108:  return status;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108:  flctx = inode->i_flctx;",
          "109:  if (flctx) {",
          "110:   list_for_each_entry(fl, &flctx->flc_flock, fl_list) {",
          "111:    if (nfs_file_open_context(fl->fl_file) != ctx)",
          "112:     continue;",
          "113:    spin_unlock(&inode->i_lock);",
          "114:    status = nfs4_lock_delegation_recall(fl, state,",
          "115:         stateid);",
          "116:    if (status < 0)",
          "117:     goto out;",
          "118:    spin_lock(&inode->i_lock);",
          "119:   }",
          "120:  }",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c": [
          "File: fs/nfs/nfs4state.c -> fs/nfs/nfs4state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1366:  struct nfs_inode *nfsi = NFS_I(inode);",
          "1367:  struct file_lock *fl;",
          "1368:  int status = 0;",
          "1371:   return 0;",
          "",
          "[Removed Lines]",
          "1370:  if (inode->i_flock == NULL)",
          "",
          "[Added Lines]",
          "1369:  struct file_lock_context *flctx = inode->i_flctx;",
          "1371:  if (inode->i_flock == NULL && flctx == NULL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1376:  spin_lock(&inode->i_lock);",
          "1377:  for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {",
          "1379:    continue;",
          "1380:   if (nfs_file_open_context(fl->fl_file)->state != state)",
          "1381:    continue;",
          "",
          "[Removed Lines]",
          "1378:   if (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))",
          "",
          "[Added Lines]",
          "1379:   if (!(fl->fl_flags & FL_POSIX))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1408:   }",
          "1409:   spin_lock(&inode->i_lock);",
          "1410:  }",
          "1411:  spin_unlock(&inode->i_lock);",
          "1412: out:",
          "1413:  up_write(&nfsi->rwsem);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1413:  if (!flctx)",
          "1414:   goto out_unlock;",
          "1416:  list_for_each_entry(fl, &flctx->flc_flock, fl_list) {",
          "1417:   if (nfs_file_open_context(fl->fl_file)->state != state)",
          "1418:    continue;",
          "1419:   spin_unlock(&inode->i_lock);",
          "1420:   status = ops->recover_lock(state, fl);",
          "1421:   switch (status) {",
          "1422:   case 0:",
          "1423:    break;",
          "1424:   case -ESTALE:",
          "1425:   case -NFS4ERR_ADMIN_REVOKED:",
          "1426:   case -NFS4ERR_STALE_STATEID:",
          "1427:   case -NFS4ERR_BAD_STATEID:",
          "1428:   case -NFS4ERR_EXPIRED:",
          "1429:   case -NFS4ERR_NO_GRACE:",
          "1430:   case -NFS4ERR_STALE_CLIENTID:",
          "1431:   case -NFS4ERR_BADSESSION:",
          "1432:   case -NFS4ERR_BADSLOT:",
          "1433:   case -NFS4ERR_BAD_HIGH_SLOT:",
          "1434:   case -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:",
          "1435:    goto out;",
          "1436:   default:",
          "1437:    pr_err(\"NFS: %s: unhandled error %d\\n\",",
          "1438:      __func__, status);",
          "1439:   case -ENOMEM:",
          "1440:   case -NFS4ERR_DENIED:",
          "1441:   case -NFS4ERR_RECLAIM_BAD:",
          "1442:   case -NFS4ERR_RECLAIM_CONFLICT:",
          "1444:    status = 0;",
          "1445:   }",
          "1446:   spin_lock(&inode->i_lock);",
          "1447:  }",
          "1448: out_unlock:",
          "",
          "---------------"
        ],
        "fs/nfs/pagelist.c||fs/nfs/pagelist.c": [
          "File: fs/nfs/pagelist.c -> fs/nfs/pagelist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "826:           struct nfs_pageio_descriptor *pgio)",
          "827: {",
          "828:  size_t size;",
          "830:  if (prev) {",
          "831:   if (!nfs_match_open_context(req->wb_context, prev->wb_context))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "829:  struct file_lock_context *flctx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:       !nfs_match_lock_context(req->wb_lock_context,",
          "835:          prev->wb_lock_context))",
          "836:    return false;",
          "837:   if (req_offset(req) != req_offset(prev) + prev->wb_bytes)",
          "838:    return false;",
          "839:   if (req->wb_page == prev->wb_page) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "838:   flctx = req->wb_context->dentry->d_inode->i_flctx;",
          "839:   if (flctx != NULL && !list_empty_careful(&flctx->flc_flock) &&",
          "840:       !nfs_match_lock_context(req->wb_lock_context,",
          "841:          prev->wb_lock_context))",
          "842:    return false;",
          "",
          "---------------"
        ],
        "fs/nfs/write.c||fs/nfs/write.c": [
          "File: fs/nfs/write.c -> fs/nfs/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1113:    do_flush |= l_ctx->lockowner.l_owner != current->files",
          "1114:     || l_ctx->lockowner.l_pid != current->tgid;",
          "1115:   }",
          "1116:   nfs_release_request(req);",
          "1117:   if (!do_flush)",
          "1118:    return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1116:   if (l_ctx && ctx->dentry->d_inode->i_flctx &&",
          "1117:       !list_empty_careful(&ctx->dentry->d_inode->i_flctx->flc_flock)) {",
          "1118:    do_flush |= l_ctx->lockowner.l_owner != current->files",
          "1119:     || l_ctx->lockowner.l_pid != current->tgid;",
          "1120:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1170:  return PageUptodate(page) != 0;",
          "1171: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1178: static bool",
          "1179: is_whole_file_wrlock(struct file_lock *fl)",
          "1180: {",
          "1181:  return fl->fl_start == 0 && fl->fl_end == OFFSET_MAX &&",
          "1182:    fl->fl_type == F_WRLCK;",
          "1183: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1181: static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)",
          "1182: {",
          "1183:  if (file->f_flags & O_DSYNC)",
          "1184:   return 0;",
          "1185:  if (!nfs_write_pageuptodate(page, inode))",
          "1186:   return 0;",
          "1187:  if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))",
          "1188:   return 1;",
          "1194: }",
          "",
          "[Removed Lines]",
          "1189:  if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&",
          "1190:    inode->i_flock->fl_end == OFFSET_MAX &&",
          "1191:    inode->i_flock->fl_type != F_RDLCK))",
          "1192:   return 1;",
          "1193:  return 0;",
          "",
          "[Added Lines]",
          "1195:  int ret;",
          "1196:  struct file_lock_context *flctx = inode->i_flctx;",
          "1197:  struct file_lock *fl;",
          "1205:  if (!inode->i_flock && !flctx)",
          "1206:   return 0;",
          "1209:  spin_lock(&inode->i_lock);",
          "1210:  ret = 0;",
          "1212:  fl = inode->i_flock;",
          "1213:  if (fl && is_whole_file_wrlock(fl)) {",
          "1214:   ret = 1;",
          "1215:   goto out;",
          "1216:  }",
          "1218:  if (!list_empty(&flctx->flc_flock)) {",
          "1219:   fl = list_first_entry(&flctx->flc_flock, struct file_lock,",
          "1220:      fl_list);",
          "1221:   if (fl->fl_type == F_WRLCK)",
          "1222:    ret = 1;",
          "1223:  }",
          "1224: out:",
          "1225:  spin_unlock(&inode->i_lock);",
          "1226:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd61e0a9c852de2d705b6f1bb2cc54c5774db570",
      "candidate_info": {
        "commit_hash": "bd61e0a9c852de2d705b6f1bb2cc54c5774db570",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bd61e0a9c852de2d705b6f1bb2cc54c5774db570",
        "files": [
          "fs/ceph/locks.c",
          "fs/cifs/file.c",
          "fs/lockd/svcsubs.c",
          "fs/locks.c",
          "fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c",
          "fs/nfs/pagelist.c",
          "fs/nfs/write.c",
          "fs/nfsd/nfs4state.c",
          "fs/read_write.c",
          "include/linux/fs.h"
        ],
        "message": "locks: convert posix locks to file_lock_context\n\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nAcked-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "fs/ceph/locks.c||fs/ceph/locks.c",
          "fs/cifs/file.c||fs/cifs/file.c",
          "fs/lockd/svcsubs.c||fs/lockd/svcsubs.c",
          "fs/locks.c||fs/locks.c",
          "fs/nfs/delegation.c||fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c",
          "fs/nfs/pagelist.c||fs/nfs/pagelist.c",
          "fs/nfs/write.c||fs/nfs/write.c",
          "fs/nfsd/nfs4state.c||fs/nfsd/nfs4state.c",
          "fs/read_write.c||fs/read_write.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ],
          "candidate": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ceph/locks.c||fs/ceph/locks.c": [
          "File: fs/ceph/locks.c -> fs/ceph/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:  ctx = inode->i_flctx;",
          "263:  if (ctx) {",
          "264:   list_for_each_entry(lock, &ctx->flc_flock, fl_list)",
          "265:    ++(*flock_count);",
          "266:  }",
          "268:  dout(\"counted %d flock locks and %d fcntl locks\",",
          "270: }",
          "",
          "[Removed Lines]",
          "256:  spin_lock(&inode->i_lock);",
          "257:  for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {",
          "258:   if (lock->fl_flags & FL_POSIX)",
          "259:    ++(*fcntl_count);",
          "260:  }",
          "267:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "258:   spin_lock(&inode->i_lock);",
          "259:   list_for_each_entry(lock, &ctx->flc_posix, fl_list)",
          "260:    ++(*fcntl_count);",
          "263:   spin_unlock(&inode->i_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "279:     int num_fcntl_locks, int num_flock_locks)",
          "280: {",
          "281:  struct file_lock *lock;",
          "283:  int err = 0;",
          "284:  int seen_fcntl = 0;",
          "285:  int seen_flock = 0;",
          "",
          "[Removed Lines]",
          "282:  struct file_lock_context *ctx;",
          "",
          "[Added Lines]",
          "279:  struct file_lock_context *ctx = inode->i_flctx;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:  dout(\"encoding %d flock and %d fcntl locks\", num_flock_locks,",
          "289:       num_fcntl_locks);",
          "291:  spin_lock(&inode->i_lock);",
          "303:   }",
          "304:  }",
          "318:   }",
          "319:  }",
          "320: fail:",
          "321:  spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "292:  for (lock = inode->i_flock; lock != NULL; lock = lock->fl_next) {",
          "293:   if (lock->fl_flags & FL_POSIX) {",
          "294:    ++seen_fcntl;",
          "295:    if (seen_fcntl > num_fcntl_locks) {",
          "296:     err = -ENOSPC;",
          "297:     goto fail;",
          "298:    }",
          "299:    err = lock_to_ceph_filelock(lock, &flocks[l]);",
          "300:    if (err)",
          "301:     goto fail;",
          "302:    ++l;",
          "306:  ctx = inode->i_flctx;",
          "307:  if (ctx) {",
          "308:   list_for_each_entry(lock, &ctx->flc_flock, fl_list) {",
          "309:    ++seen_flock;",
          "310:    if (seen_flock > num_flock_locks) {",
          "311:     err = -ENOSPC;",
          "312:     goto fail;",
          "313:    }",
          "314:    err = lock_to_ceph_filelock(lock, &flocks[l]);",
          "315:    if (err)",
          "316:     goto fail;",
          "317:    ++l;",
          "",
          "[Added Lines]",
          "288:  if (!ctx)",
          "289:   return 0;",
          "292:  list_for_each_entry(lock, &ctx->flc_flock, fl_list) {",
          "293:   ++seen_fcntl;",
          "294:   if (seen_fcntl > num_fcntl_locks) {",
          "295:    err = -ENOSPC;",
          "296:    goto fail;",
          "298:   err = lock_to_ceph_filelock(lock, &flocks[l]);",
          "299:   if (err)",
          "300:    goto fail;",
          "301:   ++l;",
          "303:  list_for_each_entry(lock, &ctx->flc_flock, fl_list) {",
          "304:   ++seen_flock;",
          "305:   if (seen_flock > num_flock_locks) {",
          "306:    err = -ENOSPC;",
          "307:    goto fail;",
          "309:   err = lock_to_ceph_filelock(lock, &flocks[l]);",
          "310:   if (err)",
          "311:    goto fail;",
          "312:   ++l;",
          "",
          "---------------"
        ],
        "fs/cifs/file.c||fs/cifs/file.c": [
          "File: fs/cifs/file.c -> fs/cifs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1109:  return rc;",
          "1110: }",
          "1117: struct lock_to_push {",
          "1118:  struct list_head llist;",
          "1119:  __u64 offset;",
          "",
          "[Removed Lines]",
          "1113: #define cifs_for_each_lock(inode, lockp) \\",
          "1114:  for (lockp = &inode->i_flock; *lockp != NULL; \\",
          "1115:       lockp = &(*lockp)->fl_next)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1128: {",
          "1129:  struct inode *inode = cfile->dentry->d_inode;",
          "1130:  struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);",
          "1133:  int rc = 0, xid, type;",
          "1134:  struct list_head locks_to_send, *el;",
          "1135:  struct lock_to_push *lck, *tmp;",
          "",
          "[Removed Lines]",
          "1131:  struct file_lock *flock, **before;",
          "1132:  unsigned int count = 0, i = 0;",
          "",
          "[Added Lines]",
          "1126:  struct file_lock *flock;",
          "1127:  struct file_lock_context *flctx = inode->i_flctx;",
          "1128:  unsigned int count = 0, i;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1138:  xid = get_xid();",
          "1140:  spin_lock(&inode->i_lock);",
          "1144:  }",
          "1145:  spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "1141:  cifs_for_each_lock(inode, before) {",
          "1142:   if ((*before)->fl_flags & FL_POSIX)",
          "1143:    count++;",
          "",
          "[Added Lines]",
          "1136:  if (!flctx)",
          "1137:   goto out;",
          "1140:  list_for_each(el, &flctx->flc_posix) {",
          "1141:   count++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1155:   lck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);",
          "1156:   if (!lck) {",
          "1157:    rc = -ENOMEM;",
          "",
          "[Removed Lines]",
          "1154:  for (; i < count; i++) {",
          "",
          "[Added Lines]",
          "1152:  for (i = 0; i < count; i++) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1163:  el = locks_to_send.next;",
          "1164:  spin_lock(&inode->i_lock);",
          "1169:   if (el == &locks_to_send) {",
          "",
          "[Removed Lines]",
          "1165:  cifs_for_each_lock(inode, before) {",
          "1166:   flock = *before;",
          "1167:   if ((flock->fl_flags & FL_POSIX) == 0)",
          "1168:    continue;",
          "",
          "[Added Lines]",
          "1163:  list_for_each_entry(flock, &flctx->flc_posix, fl_list) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1185:   lck->length = length;",
          "1186:   lck->type = type;",
          "1187:   lck->offset = flock->fl_start;",
          "1189:  }",
          "1190:  spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "1188:   el = el->next;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/lockd/svcsubs.c||fs/lockd/svcsubs.c": [
          "File: fs/lockd/svcsubs.c -> fs/lockd/svcsubs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: {",
          "165:  struct inode  *inode = nlmsvc_file_inode(file);",
          "166:  struct file_lock *fl;",
          "167:  struct nlm_host  *lockhost;",
          "169: again:",
          "170:  file->f_locks = 0;",
          "171:  spin_lock(&inode->i_lock);",
          "173:   if (fl->fl_lmops != &nlmsvc_lock_operations)",
          "174:    continue;",
          "",
          "[Removed Lines]",
          "172:  for (fl = inode->i_flock; fl; fl = fl->fl_next) {",
          "",
          "[Added Lines]",
          "167:  struct file_lock_context *flctx = inode->i_flctx;",
          "170:  if (!flctx || list_empty_careful(&flctx->flc_posix))",
          "171:   return 0;",
          "175:  list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223: {",
          "224:  struct inode  *inode = nlmsvc_file_inode(file);",
          "225:  struct file_lock *fl;",
          "227:  if (file->f_count || !list_empty(&file->f_blocks) || file->f_shares)",
          "228:   return 1;",
          "235:   }",
          "236:  }",
          "238:  file->f_locks = 0;",
          "239:  return 0;",
          "240: }",
          "",
          "[Removed Lines]",
          "230:  spin_lock(&inode->i_lock);",
          "231:  for (fl = inode->i_flock; fl; fl = fl->fl_next) {",
          "232:   if (fl->fl_lmops == &nlmsvc_lock_operations) {",
          "233:    spin_unlock(&inode->i_lock);",
          "234:    return 1;",
          "237:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "229:  struct file_lock_context *flctx = inode->i_flctx;",
          "234:  if (flctx && !list_empty_careful(&flctx->flc_posix)) {",
          "235:   spin_lock(&inode->i_lock);",
          "236:   list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "237:    if (fl->fl_lmops == &nlmsvc_lock_operations) {",
          "238:     spin_unlock(&inode->i_lock);",
          "239:     return 1;",
          "240:    }",
          "242:   spin_unlock(&inode->i_lock);",
          "",
          "---------------"
        ],
        "fs/locks.c||fs/locks.c": [
          "File: fs/locks.c -> fs/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157: int leases_enable = 1;",
          "158: int lease_break_time = 45;",
          "",
          "[Removed Lines]",
          "160: #define for_each_lock(inode, lockp) \\",
          "161:  for (lockp = &inode->i_flock; *lockp != NULL; lockp = &(*lockp)->fl_next)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218:   goto out;",
          "220:  INIT_LIST_HEAD(&new->flc_flock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  INIT_LIST_HEAD(&new->flc_posix);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "241: {",
          "242:  if (ctx) {",
          "243:   WARN_ON_ONCE(!list_empty(&ctx->flc_flock));",
          "244:   kmem_cache_free(flctx_cache, ctx);",
          "245:  }",
          "246: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242:   WARN_ON_ONCE(!list_empty(&ctx->flc_posix));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "809: posix_test_lock(struct file *filp, struct file_lock *fl)",
          "810: {",
          "811:  struct file_lock *cfl;",
          "812:  struct inode *inode = file_inode(filp);",
          "814:  spin_lock(&inode->i_lock);",
          "820:  }",
          "827:  spin_unlock(&inode->i_lock);",
          "828:  return;",
          "829: }",
          "",
          "[Removed Lines]",
          "815:  for (cfl = file_inode(filp)->i_flock; cfl; cfl = cfl->fl_next) {",
          "816:   if (!IS_POSIX(cfl))",
          "817:    continue;",
          "818:   if (posix_locks_conflict(fl, cfl))",
          "819:    break;",
          "821:  if (cfl) {",
          "822:   locks_copy_conflock(fl, cfl);",
          "823:   if (cfl->fl_nspid)",
          "824:    fl->fl_pid = pid_vnr(cfl->fl_nspid);",
          "825:  } else",
          "826:   fl->fl_type = F_UNLCK;",
          "",
          "[Added Lines]",
          "811:  struct file_lock_context *ctx;",
          "814:  ctx = inode->i_flctx;",
          "815:  if (!ctx || list_empty_careful(&ctx->flc_posix)) {",
          "816:   fl->fl_type = F_UNLCK;",
          "817:   return;",
          "818:  }",
          "821:  list_for_each_entry(cfl, &ctx->flc_posix, fl_list) {",
          "822:   if (posix_locks_conflict(fl, cfl)) {",
          "823:    locks_copy_conflock(fl, cfl);",
          "824:    if (cfl->fl_nspid)",
          "825:     fl->fl_pid = pid_vnr(cfl->fl_nspid);",
          "826:    goto out;",
          "827:   }",
          "829:  fl->fl_type = F_UNLCK;",
          "830: out:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "984: static int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)",
          "985: {",
          "987:  struct file_lock *new_fl = NULL;",
          "988:  struct file_lock *new_fl2 = NULL;",
          "989:  struct file_lock *left = NULL;",
          "990:  struct file_lock *right = NULL;",
          "992:  int error;",
          "993:  bool added = false;",
          "994:  LIST_HEAD(dispose);",
          "",
          "[Removed Lines]",
          "986:  struct file_lock *fl;",
          "991:  struct file_lock **before;",
          "",
          "[Added Lines]",
          "990:  struct file_lock *fl, *tmp;",
          "995:  struct file_lock_context *ctx;",
          "1000:  ctx = locks_get_lock_context(inode);",
          "1001:  if (!ctx)",
          "1002:   return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1015:  if (request->fl_type != F_UNLCK) {",
          "1018:    if (!IS_POSIX(fl))",
          "1019:     continue;",
          "1020:    if (!posix_locks_conflict(request, fl))",
          "",
          "[Removed Lines]",
          "1016:   for_each_lock(inode, before) {",
          "1017:    fl = *before;",
          "",
          "[Added Lines]",
          "1024:   list_for_each_entry(fl, &ctx->flc_posix, fl_list) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1044:  if (request->fl_flags & FL_ACCESS)",
          "1045:   goto out;",
          "1057:  }",
          "1063:   if (request->fl_type == fl->fl_type) {",
          "1068:    if (fl->fl_end < request->fl_start - 1)",
          "",
          "[Removed Lines]",
          "1051:  before = &inode->i_flock;",
          "1054:  while ((fl = *before) && (!IS_POSIX(fl) ||",
          "1055:       !posix_same_owner(request, fl))) {",
          "1056:   before = &fl->fl_next;",
          "1060:  while ((fl = *before) && posix_same_owner(request, fl)) {",
          "1069:     goto next_lock;",
          "",
          "[Added Lines]",
          "1055:  list_for_each_entry(fl, &ctx->flc_posix, fl_list) {",
          "1056:   if (posix_same_owner(request, fl))",
          "1057:    break;",
          "1061:  list_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {",
          "1062:   if (!posix_same_owner(request, fl))",
          "1063:    break;",
          "1072:     continue;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1087:    else",
          "1088:     request->fl_end = fl->fl_end;",
          "1089:    if (added) {",
          "1091:     continue;",
          "1092:    }",
          "1093:    request = fl;",
          "1094:    added = true;",
          "1100:    if (fl->fl_end < request->fl_start)",
          "1102:    if (fl->fl_start > request->fl_end)",
          "1103:     break;",
          "1104:    if (request->fl_type == F_UNLCK)",
          "",
          "[Removed Lines]",
          "1090:     locks_delete_lock(before, &dispose);",
          "1095:   }",
          "1096:   else {",
          "1101:     goto next_lock;",
          "",
          "[Added Lines]",
          "1093:     locks_delete_lock_ctx(fl, &dispose);",
          "1098:   } else {",
          "1103:     continue;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1119:     if (added) {",
          "1121:      continue;",
          "1122:     }",
          "",
          "[Removed Lines]",
          "1120:      locks_delete_lock(before, &dispose);",
          "",
          "[Added Lines]",
          "1122:      locks_delete_lock_ctx(fl, &dispose);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1133:     locks_copy_lock(new_fl, request);",
          "1134:     request = new_fl;",
          "1135:     new_fl = NULL;",
          "1138:     added = true;",
          "1139:    }",
          "1140:   }",
          "1145:  }",
          "",
          "[Removed Lines]",
          "1136:     locks_delete_lock(before, &dispose);",
          "1137:     locks_insert_lock(before, request);",
          "1143:  next_lock:",
          "1144:   before = &fl->fl_next;",
          "",
          "[Added Lines]",
          "1138:     locks_insert_lock_ctx(request, &fl->fl_list);",
          "1139:     locks_delete_lock_ctx(fl, &dispose);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1166:    goto out;",
          "1167:   }",
          "1168:   locks_copy_lock(new_fl, request);",
          "1170:   new_fl = NULL;",
          "1171:  }",
          "1172:  if (right) {",
          "",
          "[Removed Lines]",
          "1169:   locks_insert_lock(before, new_fl);",
          "",
          "[Added Lines]",
          "1167:   locks_insert_lock_ctx(new_fl, &fl->fl_list);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1177:    left = new_fl2;",
          "1178:    new_fl2 = NULL;",
          "1179:    locks_copy_lock(left, right);",
          "1181:   }",
          "1182:   right->fl_start = request->fl_end + 1;",
          "1183:   locks_wake_up_blocks(right);",
          "",
          "[Removed Lines]",
          "1180:    locks_insert_lock(before, left);",
          "",
          "[Added Lines]",
          "1178:    locks_insert_lock_ctx(left, &fl->fl_list);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1258: int locks_mandatory_locked(struct file *file)",
          "1259: {",
          "1260:  struct inode *inode = file_inode(file);",
          "1261:  struct file_lock *fl;",
          "1266:  spin_lock(&inode->i_lock);",
          "1270:   if (fl->fl_owner != current->files &&",
          "1272:    break;",
          "1273:  }",
          "1274:  spin_unlock(&inode->i_lock);",
          "1276: }",
          "",
          "[Removed Lines]",
          "1267:  for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {",
          "1268:   if (!IS_POSIX(fl))",
          "1269:    continue;",
          "1271:       fl->fl_owner != file)",
          "1275:  return fl ? -EAGAIN : 0;",
          "",
          "[Added Lines]",
          "1258:  int ret;",
          "1260:  struct file_lock_context *ctx;",
          "1263:  ctx = inode->i_flctx;",
          "1264:  if (!ctx || list_empty_careful(&ctx->flc_posix))",
          "1265:   return 0;",
          "1271:  ret = 0;",
          "1272:  list_for_each_entry(fl, &ctx->flc_posix, fl_list) {",
          "1274:       fl->fl_owner != file) {",
          "1275:    ret = -EAGAIN;",
          "1277:   }",
          "1280:  return ret;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2389: void locks_remove_posix(struct file *filp, fl_owner_t owner)",
          "2390: {",
          "2391:  struct file_lock lock;",
          "2399:   return;",
          "2401:  lock.fl_type = F_UNLCK;",
          "",
          "[Removed Lines]",
          "2398:  if (!file_inode(filp)->i_flock)",
          "",
          "[Added Lines]",
          "2397:  struct file_lock_context *ctx = file_inode(filp)->i_flctx;",
          "2404:  if (!ctx || list_empty(&ctx->flc_posix))",
          "",
          "---------------"
        ],
        "fs/nfs/delegation.c||fs/nfs/delegation.c": [
          "File: fs/nfs/delegation.c -> fs/nfs/delegation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: {",
          "86:  struct inode *inode = state->inode;",
          "87:  struct file_lock *fl;",
          "89:  int status = 0;",
          "92:   goto out;",
          "95:  spin_lock(&inode->i_lock);",
          "99:   if (nfs_file_open_context(fl->fl_file) != ctx)",
          "100:    continue;",
          "101:   spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "88:  struct file_lock_context *flctx;",
          "91:  if (inode->i_flock == NULL && inode->i_flctx == NULL)",
          "96:  for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {",
          "97:   if (!(fl->fl_flags & (FL_POSIX)))",
          "98:    continue;",
          "",
          "[Added Lines]",
          "88:  struct file_lock_context *flctx = inode->i_flctx;",
          "89:  struct list_head *list;",
          "92:  if (flctx == NULL)",
          "95:  list = &flctx->flc_posix;",
          "97: restart:",
          "98:  list_for_each_entry(fl, list, fl_list) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:    goto out;",
          "105:   spin_lock(&inode->i_lock);",
          "106:  }",
          "120:  }",
          "121:  spin_unlock(&inode->i_lock);",
          "122: out:",
          "",
          "[Removed Lines]",
          "108:  flctx = inode->i_flctx;",
          "109:  if (flctx) {",
          "110:   list_for_each_entry(fl, &flctx->flc_flock, fl_list) {",
          "111:    if (nfs_file_open_context(fl->fl_file) != ctx)",
          "112:     continue;",
          "113:    spin_unlock(&inode->i_lock);",
          "114:    status = nfs4_lock_delegation_recall(fl, state,",
          "115:         stateid);",
          "116:    if (status < 0)",
          "117:     goto out;",
          "118:    spin_lock(&inode->i_lock);",
          "119:   }",
          "",
          "[Added Lines]",
          "107:  if (list == &flctx->flc_posix) {",
          "108:   list = &flctx->flc_flock;",
          "109:   goto restart;",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c": [
          "File: fs/nfs/nfs4state.c -> fs/nfs/nfs4state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1367:  struct file_lock *fl;",
          "1368:  int status = 0;",
          "1369:  struct file_lock_context *flctx = inode->i_flctx;",
          "1372:   return 0;",
          "1375:  down_write(&nfsi->rwsem);",
          "1377:  spin_lock(&inode->i_lock);",
          "1417:   if (nfs_file_open_context(fl->fl_file)->state != state)",
          "1418:    continue;",
          "1419:   spin_unlock(&inode->i_lock);",
          "",
          "[Removed Lines]",
          "1371:  if (inode->i_flock == NULL && flctx == NULL)",
          "1378:  for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {",
          "1379:   if (!(fl->fl_flags & FL_POSIX))",
          "1380:    continue;",
          "1381:   if (nfs_file_open_context(fl->fl_file)->state != state)",
          "1382:    continue;",
          "1383:   spin_unlock(&inode->i_lock);",
          "1384:   status = ops->recover_lock(state, fl);",
          "1385:   switch (status) {",
          "1386:    case 0:",
          "1387:     break;",
          "1388:    case -ESTALE:",
          "1389:    case -NFS4ERR_ADMIN_REVOKED:",
          "1390:    case -NFS4ERR_STALE_STATEID:",
          "1391:    case -NFS4ERR_BAD_STATEID:",
          "1392:    case -NFS4ERR_EXPIRED:",
          "1393:    case -NFS4ERR_NO_GRACE:",
          "1394:    case -NFS4ERR_STALE_CLIENTID:",
          "1395:    case -NFS4ERR_BADSESSION:",
          "1396:    case -NFS4ERR_BADSLOT:",
          "1397:    case -NFS4ERR_BAD_HIGH_SLOT:",
          "1398:    case -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:",
          "1399:     goto out;",
          "1400:    default:",
          "1401:     printk(KERN_ERR \"NFS: %s: unhandled error %d\\n\",",
          "1402:       __func__, status);",
          "1403:    case -ENOMEM:",
          "1404:    case -NFS4ERR_DENIED:",
          "1405:    case -NFS4ERR_RECLAIM_BAD:",
          "1406:    case -NFS4ERR_RECLAIM_CONFLICT:",
          "1408:     status = 0;",
          "1409:   }",
          "1410:   spin_lock(&inode->i_lock);",
          "1411:  }",
          "1413:  if (!flctx)",
          "1414:   goto out_unlock;",
          "1416:  list_for_each_entry(fl, &flctx->flc_flock, fl_list) {",
          "",
          "[Added Lines]",
          "1370:  struct list_head *list;",
          "1372:  if (flctx == NULL)",
          "1375:  list = &flctx->flc_posix;",
          "1380: restart:",
          "1381:  list_for_each_entry(fl, list, fl_list) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1445:   }",
          "1446:   spin_lock(&inode->i_lock);",
          "1447:  }",
          "1449:  spin_unlock(&inode->i_lock);",
          "1450: out:",
          "1451:  up_write(&nfsi->rwsem);",
          "",
          "[Removed Lines]",
          "1448: out_unlock:",
          "",
          "[Added Lines]",
          "1413:  if (list == &flctx->flc_posix) {",
          "1414:   list = &flctx->flc_flock;",
          "1415:   goto restart;",
          "1416:  }",
          "",
          "---------------"
        ],
        "fs/nfs/pagelist.c||fs/nfs/pagelist.c": [
          "File: fs/nfs/pagelist.c -> fs/nfs/pagelist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "831:  if (prev) {",
          "832:   if (!nfs_match_open_context(req->wb_context, prev->wb_context))",
          "833:    return false;",
          "838:   flctx = req->wb_context->dentry->d_inode->i_flctx;",
          "840:       !nfs_match_lock_context(req->wb_lock_context,",
          "841:          prev->wb_lock_context))",
          "842:    return false;",
          "",
          "[Removed Lines]",
          "834:   if (req->wb_context->dentry->d_inode->i_flock != NULL &&",
          "835:       !nfs_match_lock_context(req->wb_lock_context,",
          "836:          prev->wb_lock_context))",
          "837:    return false;",
          "839:   if (flctx != NULL && !list_empty_careful(&flctx->flc_flock) &&",
          "",
          "[Added Lines]",
          "835:   if (flctx != NULL &&",
          "836:       !(list_empty_careful(&flctx->flc_posix) &&",
          "837:         list_empty_careful(&flctx->flc_flock)) &&",
          "",
          "---------------"
        ],
        "fs/nfs/write.c||fs/nfs/write.c": [
          "File: fs/nfs/write.c -> fs/nfs/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1091: {",
          "1092:  struct nfs_open_context *ctx = nfs_file_open_context(file);",
          "1093:  struct nfs_lock_context *l_ctx;",
          "1094:  struct nfs_page *req;",
          "1095:  int do_flush, status;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1094:  struct file_lock_context *flctx = file_inode(file)->i_flctx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1109:   do_flush = req->wb_page != page || req->wb_context != ctx;",
          "1111:   do_flush |= req->wb_this_page != req;",
          "1118:    do_flush |= l_ctx->lockowner.l_owner != current->files",
          "1119:     || l_ctx->lockowner.l_pid != current->tgid;",
          "1120:   }",
          "",
          "[Removed Lines]",
          "1112:   if (l_ctx && ctx->dentry->d_inode->i_flock != NULL) {",
          "1113:    do_flush |= l_ctx->lockowner.l_owner != current->files",
          "1114:     || l_ctx->lockowner.l_pid != current->tgid;",
          "1115:   }",
          "1116:   if (l_ctx && ctx->dentry->d_inode->i_flctx &&",
          "1117:       !list_empty_careful(&ctx->dentry->d_inode->i_flctx->flc_flock)) {",
          "",
          "[Added Lines]",
          "1113:   if (l_ctx && flctx &&",
          "1114:       !(list_empty_careful(&flctx->flc_posix) &&",
          "1115:         list_empty_careful(&flctx->flc_flock))) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1202:   return 0;",
          "1203:  if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))",
          "1204:   return 1;",
          "1206:   return 0;",
          "1210:  ret = 0;",
          "1219:   fl = list_first_entry(&flctx->flc_flock, struct file_lock,",
          "1220:      fl_list);",
          "1221:   if (fl->fl_type == F_WRLCK)",
          "1222:    ret = 1;",
          "1223:  }",
          "1225:  spin_unlock(&inode->i_lock);",
          "1226:  return ret;",
          "1227: }",
          "",
          "[Removed Lines]",
          "1205:  if (!inode->i_flock && !flctx)",
          "1209:  spin_lock(&inode->i_lock);",
          "1212:  fl = inode->i_flock;",
          "1213:  if (fl && is_whole_file_wrlock(fl)) {",
          "1214:   ret = 1;",
          "1215:   goto out;",
          "1216:  }",
          "1218:  if (!list_empty(&flctx->flc_flock)) {",
          "1224: out:",
          "",
          "[Added Lines]",
          "1203:  if (!flctx || (list_empty_careful(&flctx->flc_flock) &&",
          "1204:          list_empty_careful(&flctx->flc_posix)))",
          "1209:  spin_lock(&inode->i_lock);",
          "1210:  if (!list_empty(&flctx->flc_posix)) {",
          "1211:   fl = list_first_entry(&flctx->flc_posix, struct file_lock,",
          "1212:      fl_list);",
          "1213:   if (is_whole_file_wrlock(fl))",
          "1214:    ret = 1;",
          "1215:  } else if (!list_empty(&flctx->flc_flock)) {",
          "",
          "---------------"
        ],
        "fs/nfsd/nfs4state.c||fs/nfsd/nfs4state.c": [
          "File: fs/nfsd/nfs4state.c -> fs/nfsd/nfs4state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5556: static bool",
          "5557: check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)",
          "5558: {",
          "5560:  int status = false;",
          "5561:  struct file *filp = find_any_file(fp);",
          "5562:  struct inode *inode;",
          "5564:  if (!filp) {",
          "",
          "[Removed Lines]",
          "5559:  struct file_lock **flpp;",
          "",
          "[Added Lines]",
          "5559:  struct file_lock *fl;",
          "5563:  struct file_lock_context *flctx;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5568:  }",
          "5570:  inode = file_inode(filp);",
          "5577:   }",
          "5578:  }",
          "5580:  fput(filp);",
          "5581:  return status;",
          "5582: }",
          "",
          "[Removed Lines]",
          "5572:  spin_lock(&inode->i_lock);",
          "5573:  for (flpp = &inode->i_flock; *flpp != NULL; flpp = &(*flpp)->fl_next) {",
          "5574:   if ((*flpp)->fl_owner == (fl_owner_t)lowner) {",
          "5575:    status = true;",
          "5576:    break;",
          "5579:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "5572:  flctx = inode->i_flctx;",
          "5574:  if (flctx && !list_empty_careful(&flctx->flc_posix)) {",
          "5575:   spin_lock(&inode->i_lock);",
          "5576:   list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "5577:    if (fl->fl_owner == (fl_owner_t)lowner) {",
          "5578:     status = true;",
          "5579:     break;",
          "5580:    }",
          "5582:   spin_unlock(&inode->i_lock);",
          "",
          "---------------"
        ],
        "fs/read_write.c||fs/read_write.c": [
          "File: fs/read_write.c -> fs/read_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "358:    return retval;",
          "359:  }",
          "362:   retval = locks_mandatory_area(",
          "363:    read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,",
          "364:    inode, file, pos, count);",
          "",
          "[Removed Lines]",
          "361:  if (unlikely(inode->i_flock && mandatory_lock(inode))) {",
          "",
          "[Added Lines]",
          "361:  if (unlikely(inode->i_flctx && mandatory_lock(inode))) {",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "969: struct file_lock_context {",
          "970:  struct list_head flc_flock;",
          "971: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "971:  struct list_head flc_posix;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1971:         struct file *filp,",
          "1972:         loff_t size)",
          "1973: {",
          "1975:   return locks_mandatory_area(",
          "1976:    FLOCK_VERIFY_WRITE, inode, filp,",
          "1977:    size < inode->i_size ? size : inode->i_size,",
          "",
          "[Removed Lines]",
          "1974:  if (inode->i_flock && mandatory_lock(inode))",
          "",
          "[Added Lines]",
          "1975:  if (inode->i_flctx && mandatory_lock(inode))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c7559663e42f4294ffe31fe159da6b6a66b35d61",
      "candidate_info": {
        "commit_hash": "c7559663e42f4294ffe31fe159da6b6a66b35d61",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c7559663e42f4294ffe31fe159da6b6a66b35d61",
        "files": [
          "fs/nfs/write.c"
        ],
        "message": "NFS: Allow nfs_updatepage to extend a write under additional circumstances\n\nCurrently nfs_updatepage allows a write to be extended to cover a full\npage only if we don't have a byte range lock lock on the file... but if\nwe have a write delegation on the file or if we have the whole file\nlocked for writing then we should be allowed to extend the write as\nwell.\n\nSigned-off-by: Scott Mayhew <smayhew@redhat.com>\n[Trond: fix up call to nfs_have_delegation()]\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/write.c||fs/nfs/write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ],
          "candidate": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/write.c||fs/nfs/write.c": [
          "File: fs/nfs/write.c -> fs/nfs/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "888:  return PageUptodate(page) != 0;",
          "889: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "899: static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)",
          "900: {",
          "901:  if (file->f_flags & O_DSYNC)",
          "902:   return 0;",
          "903:  if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))",
          "904:   return 1;",
          "905:  if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||",
          "906:    (inode->i_flock->fl_start == 0 &&",
          "907:    inode->i_flock->fl_end == OFFSET_MAX &&",
          "908:    inode->i_flock->fl_type != F_RDLCK)))",
          "909:   return 1;",
          "910:  return 0;",
          "911: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "908:   file->f_path.dentry->d_name.name, count,",
          "909:   (long long)(page_file_offset(page) + offset));",
          "919:   count = max(count + offset, nfs_page_length(page));",
          "920:   offset = 0;",
          "921:  }",
          "",
          "[Removed Lines]",
          "916:  if (nfs_write_pageuptodate(page, inode) &&",
          "917:    inode->i_flock == NULL &&",
          "918:    !(file->f_flags & O_DSYNC)) {",
          "",
          "[Added Lines]",
          "933:  if (nfs_can_extend_write(file, page, inode)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6109c85037e53443f29fd39c0de69f578a1cf285",
      "candidate_info": {
        "commit_hash": "6109c85037e53443f29fd39c0de69f578a1cf285",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6109c85037e53443f29fd39c0de69f578a1cf285",
        "files": [
          "fs/ceph/locks.c",
          "fs/cifs/file.c",
          "fs/lockd/svcsubs.c",
          "fs/locks.c",
          "fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c",
          "fs/nfs/write.c",
          "fs/nfsd/nfs4state.c",
          "include/linux/fs.h"
        ],
        "message": "locks: add a dedicated spinlock to protect i_flctx lists\n\nWe can now add a dedicated spinlock without expanding struct inode.\nChange to using that to protect the various i_flctx lists.\n\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nAcked-by: Christoph Hellwig <hch@lst.de>",
        "before_after_code_files": [
          "fs/ceph/locks.c||fs/ceph/locks.c",
          "fs/cifs/file.c||fs/cifs/file.c",
          "fs/lockd/svcsubs.c||fs/lockd/svcsubs.c",
          "fs/locks.c||fs/locks.c",
          "fs/nfs/delegation.c||fs/nfs/delegation.c",
          "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c",
          "fs/nfs/write.c||fs/nfs/write.c",
          "fs/nfsd/nfs4state.c||fs/nfsd/nfs4state.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ],
          "candidate": [
            "fs/nfs/write.c||fs/nfs/write.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ceph/locks.c||fs/ceph/locks.c": [
          "File: fs/ceph/locks.c -> fs/ceph/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:  ctx = inode->i_flctx;",
          "257:  if (ctx) {",
          "259:   list_for_each_entry(lock, &ctx->flc_posix, fl_list)",
          "260:    ++(*fcntl_count);",
          "261:   list_for_each_entry(lock, &ctx->flc_flock, fl_list)",
          "262:    ++(*flock_count);",
          "264:  }",
          "265:  dout(\"counted %d flock locks and %d fcntl locks\",",
          "",
          "[Removed Lines]",
          "258:   spin_lock(&inode->i_lock);",
          "263:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "258:   spin_lock(&ctx->flc_lock);",
          "263:   spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "288:  if (!ctx)",
          "289:   return 0;",
          "292:  list_for_each_entry(lock, &ctx->flc_flock, fl_list) {",
          "293:   ++seen_fcntl;",
          "294:   if (seen_fcntl > num_fcntl_locks) {",
          "",
          "[Removed Lines]",
          "291:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "291:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "312:   ++l;",
          "313:  }",
          "314: fail:",
          "316:  return err;",
          "317: }",
          "",
          "[Removed Lines]",
          "315:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "315:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/cifs/file.c||fs/cifs/file.c": [
          "File: fs/cifs/file.c -> fs/cifs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1136:  if (!flctx)",
          "1137:   goto out;",
          "1140:  list_for_each(el, &flctx->flc_posix) {",
          "1141:   count++;",
          "1142:  }",
          "1145:  INIT_LIST_HEAD(&locks_to_send);",
          "",
          "[Removed Lines]",
          "1139:  spin_lock(&inode->i_lock);",
          "1143:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1139:  spin_lock(&flctx->flc_lock);",
          "1143:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1159:  }",
          "1161:  el = locks_to_send.next;",
          "1163:  list_for_each_entry(flock, &flctx->flc_posix, fl_list) {",
          "1164:   if (el == &locks_to_send) {",
          "",
          "[Removed Lines]",
          "1162:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1162:  spin_lock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1181:   lck->type = type;",
          "1182:   lck->offset = flock->fl_start;",
          "1183:  }",
          "1186:  list_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {",
          "1187:   int stored_rc;",
          "",
          "[Removed Lines]",
          "1184:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1184:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/lockd/svcsubs.c||fs/lockd/svcsubs.c": [
          "File: fs/lockd/svcsubs.c -> fs/lockd/svcsubs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:   return 0;",
          "172: again:",
          "173:  file->f_locks = 0;",
          "175:  list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "176:   if (fl->fl_lmops != &nlmsvc_lock_operations)",
          "177:    continue;",
          "",
          "[Removed Lines]",
          "174:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "174:  spin_lock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "183:   if (match(lockhost, host)) {",
          "184:    struct file_lock lock = *fl;",
          "187:    lock.fl_type  = F_UNLCK;",
          "188:    lock.fl_start = 0;",
          "189:    lock.fl_end   = OFFSET_MAX;",
          "",
          "[Removed Lines]",
          "186:    spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "186:    spin_unlock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:    goto again;",
          "196:   }",
          "197:  }",
          "200:  return 0;",
          "201: }",
          "",
          "[Removed Lines]",
          "198:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "198:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "232:   return 1;",
          "234:  if (flctx && !list_empty_careful(&flctx->flc_posix)) {",
          "236:   list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "237:    if (fl->fl_lmops == &nlmsvc_lock_operations) {",
          "239:     return 1;",
          "240:    }",
          "241:   }",
          "243:  }",
          "244:  file->f_locks = 0;",
          "245:  return 0;",
          "",
          "[Removed Lines]",
          "235:   spin_lock(&inode->i_lock);",
          "238:     spin_unlock(&inode->i_lock);",
          "242:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "235:   spin_lock(&flctx->flc_lock);",
          "238:     spin_unlock(&flctx->flc_lock);",
          "242:   spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/locks.c||fs/locks.c": [
          "File: fs/locks.c -> fs/locks.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:  if (!new)",
          "215:   goto out;",
          "217:  INIT_LIST_HEAD(&new->flc_flock);",
          "218:  INIT_LIST_HEAD(&new->flc_posix);",
          "219:  INIT_LIST_HEAD(&new->flc_lease);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:  spin_lock_init(&new->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "768:   return;",
          "769:  }",
          "772:  list_for_each_entry(cfl, &ctx->flc_posix, fl_list) {",
          "773:   if (posix_locks_conflict(fl, cfl)) {",
          "774:    locks_copy_conflock(fl, cfl);",
          "",
          "[Removed Lines]",
          "771:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "772:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "779:  }",
          "780:  fl->fl_type = F_UNLCK;",
          "781: out:",
          "783:  return;",
          "784: }",
          "785: EXPORT_SYMBOL(posix_test_lock);",
          "",
          "[Removed Lines]",
          "782:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "783:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "880:    return -ENOMEM;",
          "881:  }",
          "884:  if (request->fl_flags & FL_ACCESS)",
          "885:   goto find_conflict;",
          "",
          "[Removed Lines]",
          "883:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "884:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "907:  if (found) {",
          "909:   cond_resched();",
          "911:  }",
          "913: find_conflict:",
          "",
          "[Removed Lines]",
          "908:   spin_unlock(&inode->i_lock);",
          "910:   spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "909:   spin_unlock(&ctx->flc_lock);",
          "911:   spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "929:  error = 0;",
          "931: out:",
          "933:  if (new_fl)",
          "934:   locks_free_lock(new_fl);",
          "935:  locks_dispose_list(&dispose);",
          "",
          "[Removed Lines]",
          "932:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "933:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "965:   new_fl2 = locks_alloc_lock();",
          "966:  }",
          "",
          "[Removed Lines]",
          "968:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "969:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1136:   locks_wake_up_blocks(left);",
          "1137:  }",
          "1138:  out:",
          "",
          "[Removed Lines]",
          "1139:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1140:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1222:  ret = 0;",
          "1223:  list_for_each_entry(fl, &ctx->flc_posix, fl_list) {",
          "1224:   if (fl->fl_owner != current->files &&",
          "",
          "[Removed Lines]",
          "1221:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1222:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1227:    break;",
          "1228:   }",
          "1229:  }",
          "1231:  return ret;",
          "1232: }",
          "",
          "[Removed Lines]",
          "1230:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1231:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1346:  struct file_lock_context *ctx = inode->i_flctx;",
          "1347:  struct file_lock *fl, *tmp;",
          "1351:  list_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {",
          "1352:   trace_time_out_leases(inode, fl);",
          "",
          "[Removed Lines]",
          "1349:  lockdep_assert_held(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1350:  lockdep_assert_held(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1370:  struct file_lock_context *ctx = inode->i_flctx;",
          "1371:  struct file_lock *fl;",
          "1375:  list_for_each_entry(fl, &ctx->flc_lease, fl_list) {",
          "1376:   if (leases_conflict(fl, breaker))",
          "",
          "[Removed Lines]",
          "1373:  lockdep_assert_held(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1374:  lockdep_assert_held(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1413:   return error;",
          "1414:  }",
          "1418:  time_out_leases(inode, &dispose);",
          "",
          "[Removed Lines]",
          "1416:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1417:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1463:   break_time++;",
          "1464:  locks_insert_block(fl, new_fl);",
          "1465:  trace_break_lease_block(inode, new_fl);",
          "1467:  locks_dispose_list(&dispose);",
          "1468:  error = wait_event_interruptible_timeout(new_fl->fl_wait,",
          "1469:       !new_fl->fl_next, break_time);",
          "1471:  trace_break_lease_unblock(inode, new_fl);",
          "1472:  locks_delete_block(new_fl);",
          "1473:  if (error >= 0) {",
          "",
          "[Removed Lines]",
          "1466:  spin_unlock(&inode->i_lock);",
          "1470:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1467:  spin_unlock(&ctx->flc_lock);",
          "1471:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1482:   error = 0;",
          "1483:  }",
          "1484: out:",
          "1486:  locks_dispose_list(&dispose);",
          "1487:  locks_free_lock(new_fl);",
          "1488:  return error;",
          "",
          "[Removed Lines]",
          "1485:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1486:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1506:  struct file_lock *fl;",
          "1508:  if (ctx && !list_empty_careful(&ctx->flc_lease)) {",
          "1510:   if (!list_empty(&ctx->flc_lease)) {",
          "1511:    fl = list_first_entry(&ctx->flc_lease,",
          "1512:       struct file_lock, fl_list);",
          "1513:    if (fl->fl_type == F_WRLCK)",
          "1514:     has_lease = true;",
          "1515:   }",
          "1517:  }",
          "1519:  if (has_lease)",
          "",
          "[Removed Lines]",
          "1509:   spin_lock(&inode->i_lock);",
          "1516:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1510:   spin_lock(&ctx->flc_lock);",
          "1517:   spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1556:  LIST_HEAD(dispose);",
          "1558:  if (ctx && !list_empty_careful(&ctx->flc_lease)) {",
          "1560:   time_out_leases(file_inode(filp), &dispose);",
          "1561:   list_for_each_entry(fl, &ctx->flc_lease, fl_list) {",
          "1562:    if (fl->fl_file != filp)",
          "",
          "[Removed Lines]",
          "1559:   spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1560:   spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1564:    type = target_leasetype(fl);",
          "1565:    break;",
          "1566:   }",
          "1568:   locks_dispose_list(&dispose);",
          "1569:  }",
          "1570:  return type;",
          "",
          "[Removed Lines]",
          "1567:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1568:   spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1632:   return -EINVAL;",
          "1633:  }",
          "1636:  time_out_leases(inode, &dispose);",
          "1637:  error = check_conflicting_open(dentry, arg);",
          "1638:  if (error)",
          "",
          "[Removed Lines]",
          "1635:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1636:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1699:  if (lease->fl_lmops->lm_setup)",
          "1700:   lease->fl_lmops->lm_setup(lease, priv);",
          "1701: out:",
          "1703:  locks_dispose_list(&dispose);",
          "1704:  if (is_deleg)",
          "1705:   mutex_unlock(&inode->i_mutex);",
          "",
          "[Removed Lines]",
          "1702:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1703:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1722:   return error;",
          "1723:  }",
          "1726:  list_for_each_entry(fl, &ctx->flc_lease, fl_list) {",
          "1727:   if (fl->fl_file == filp) {",
          "1728:    victim = fl;",
          "",
          "[Removed Lines]",
          "1725:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1726:  spin_lock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1732:  trace_generic_delete_lease(inode, fl);",
          "1733:  if (victim)",
          "1734:   error = fl->fl_lmops->lm_change(&victim, F_UNLCK, &dispose);",
          "1736:  locks_dispose_list(&dispose);",
          "1737:  return error;",
          "1738: }",
          "",
          "[Removed Lines]",
          "1735:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1736:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2423:  if (!ctx || list_empty(&ctx->flc_lease))",
          "2424:   return;",
          "2427:  list_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)",
          "2428:   lease_modify(&fl, F_UNLCK, &dispose);",
          "2430:  locks_dispose_list(&dispose);",
          "2431: }",
          "",
          "[Removed Lines]",
          "2426:  spin_lock(&inode->i_lock);",
          "2429:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "2427:  spin_lock(&ctx->flc_lock);",
          "2430:  spin_unlock(&ctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/nfs/delegation.c||fs/nfs/delegation.c": [
          "File: fs/nfs/delegation.c -> fs/nfs/delegation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:   goto out;",
          "95:  list = &flctx->flc_posix;",
          "97: restart:",
          "98:  list_for_each_entry(fl, list, fl_list) {",
          "99:   if (nfs_file_open_context(fl->fl_file) != ctx)",
          "100:    continue;",
          "102:   status = nfs4_lock_delegation_recall(fl, state, stateid);",
          "103:   if (status < 0)",
          "104:    goto out;",
          "106:  }",
          "107:  if (list == &flctx->flc_posix) {",
          "108:   list = &flctx->flc_flock;",
          "109:   goto restart;",
          "110:  }",
          "112: out:",
          "113:  return status;",
          "114: }",
          "",
          "[Removed Lines]",
          "96:  spin_lock(&inode->i_lock);",
          "101:   spin_unlock(&inode->i_lock);",
          "105:   spin_lock(&inode->i_lock);",
          "111:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "96:  spin_lock(&flctx->flc_lock);",
          "101:   spin_unlock(&flctx->flc_lock);",
          "105:   spin_lock(&flctx->flc_lock);",
          "111:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/nfs/nfs4state.c||fs/nfs/nfs4state.c": [
          "File: fs/nfs/nfs4state.c -> fs/nfs/nfs4state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1378:  down_write(&nfsi->rwsem);",
          "1380: restart:",
          "1381:  list_for_each_entry(fl, list, fl_list) {",
          "1382:   if (nfs_file_open_context(fl->fl_file)->state != state)",
          "1383:    continue;",
          "1385:   status = ops->recover_lock(state, fl);",
          "1386:   switch (status) {",
          "1387:   case 0:",
          "",
          "[Removed Lines]",
          "1379:  spin_lock(&inode->i_lock);",
          "1384:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1379:  spin_lock(&flctx->flc_lock);",
          "1384:   spin_unlock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1409:    status = 0;",
          "1410:   }",
          "1412:  }",
          "1413:  if (list == &flctx->flc_posix) {",
          "1414:   list = &flctx->flc_flock;",
          "1415:   goto restart;",
          "1416:  }",
          "1418: out:",
          "1419:  up_write(&nfsi->rwsem);",
          "1420:  return status;",
          "",
          "[Removed Lines]",
          "1411:   spin_lock(&inode->i_lock);",
          "1417:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1411:   spin_lock(&flctx->flc_lock);",
          "1417:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/nfs/write.c||fs/nfs/write.c": [
          "File: fs/nfs/write.c -> fs/nfs/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1208:  ret = 0;",
          "1210:  if (!list_empty(&flctx->flc_posix)) {",
          "1211:   fl = list_first_entry(&flctx->flc_posix, struct file_lock,",
          "1212:      fl_list);",
          "",
          "[Removed Lines]",
          "1209:  spin_lock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1209:  spin_lock(&flctx->flc_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1218:   if (fl->fl_type == F_WRLCK)",
          "1219:    ret = 1;",
          "1220:  }",
          "1222:  return ret;",
          "1223: }",
          "",
          "[Removed Lines]",
          "1221:  spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "1221:  spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "fs/nfsd/nfs4state.c||fs/nfsd/nfs4state.c": [
          "File: fs/nfsd/nfs4state.c -> fs/nfsd/nfs4state.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5572:  flctx = inode->i_flctx;",
          "5574:  if (flctx && !list_empty_careful(&flctx->flc_posix)) {",
          "5576:   list_for_each_entry(fl, &flctx->flc_posix, fl_list) {",
          "5577:    if (fl->fl_owner == (fl_owner_t)lowner) {",
          "5578:     status = true;",
          "5579:     break;",
          "5580:    }",
          "5581:   }",
          "5583:  }",
          "5584:  fput(filp);",
          "5585:  return status;",
          "",
          "[Removed Lines]",
          "5575:   spin_lock(&inode->i_lock);",
          "5582:   spin_unlock(&inode->i_lock);",
          "",
          "[Added Lines]",
          "5575:   spin_lock(&flctx->flc_lock);",
          "5582:   spin_unlock(&flctx->flc_lock);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "968: };",
          "970: struct file_lock_context {",
          "971:  struct list_head flc_flock;",
          "972:  struct list_head flc_posix;",
          "973:  struct list_head flc_lease;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "971:  spinlock_t  flc_lock;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-10878",
  "cve_desc": "A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write and a denial of service or unspecified other impact is possible by mounting and operating a crafted ext4 filesystem image.",
  "repo": "torvalds/linux",
  "patch_hash": "77260807d1170a8cf35dbb06e07461a655f67eee",
  "patch_info": {
    "commit_hash": "77260807d1170a8cf35dbb06e07461a655f67eee",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/77260807d1170a8cf35dbb06e07461a655f67eee",
    "files": [
      "fs/ext4/super.c"
    ],
    "message": "ext4: make sure bitmaps and the inode table don't overlap with bg descriptors\n\nIt's really bad when the allocation bitmaps and the inode table\noverlap with the block group descriptors, since it causes random\ncorruption of the bg descriptors.  So we really want to head those off\nat the pass.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199865\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@kernel.org",
    "before_after_code_files": [
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2348:  struct ext4_sb_info *sbi = EXT4_SB(sb);",
      "2349:  ext4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);",
      "2350:  ext4_fsblk_t last_block;",
      "2351:  ext4_fsblk_t block_bitmap;",
      "2352:  ext4_fsblk_t inode_bitmap;",
      "2353:  ext4_fsblk_t inode_table;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2351:  ext4_fsblk_t last_bg_block = sb_block + ext4_bg_num_gdb(sb, 0) + 1;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2380:    if (!sb_rdonly(sb))",
      "2381:     return 0;",
      "2382:   }",
      "2383:   if (block_bitmap < first_block || block_bitmap > last_block) {",
      "2384:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "2385:           \"Block bitmap for group %u not in group \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2384:   if (block_bitmap >= sb_block + 1 &&",
      "2385:       block_bitmap <= last_bg_block) {",
      "2386:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "2387:      \"Block bitmap for group %u overlaps \"",
      "2388:      \"block group descriptors\", i);",
      "2389:    if (!sb_rdonly(sb))",
      "2390:     return 0;",
      "2391:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2394:    if (!sb_rdonly(sb))",
      "2395:     return 0;",
      "2396:   }",
      "2397:   if (inode_bitmap < first_block || inode_bitmap > last_block) {",
      "2398:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "2399:           \"Inode bitmap for group %u not in group \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2406:   if (inode_bitmap >= sb_block + 1 &&",
      "2407:       inode_bitmap <= last_bg_block) {",
      "2408:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "2409:      \"Inode bitmap for group %u overlaps \"",
      "2410:      \"block group descriptors\", i);",
      "2411:    if (!sb_rdonly(sb))",
      "2412:     return 0;",
      "2413:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2408:    if (!sb_rdonly(sb))",
      "2409:     return 0;",
      "2410:   }",
      "2411:   if (inode_table < first_block ||",
      "2412:       inode_table + sbi->s_itb_per_group - 1 > last_block) {",
      "2413:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2428:   if (inode_table >= sb_block + 1 &&",
      "2429:       inode_table <= last_bg_block) {",
      "2430:    ext4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"",
      "2431:      \"Inode table for group %u overlaps \"",
      "2432:      \"block group descriptors\", i);",
      "2433:    if (!sb_rdonly(sb))",
      "2434:     return 0;",
      "2435:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "44de022c4382541cebdd6de4465d1f4f465ff1dd",
      "candidate_info": {
        "commit_hash": "44de022c4382541cebdd6de4465d1f4f465ff1dd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/44de022c4382541cebdd6de4465d1f4f465ff1dd",
        "files": [
          "fs/ext4/super.c"
        ],
        "message": "ext4: fix false negatives *and* false positives in ext4_check_descriptors()\n\nExt4_check_descriptors() was getting called before s_gdb_count was\ninitialized.  So for file systems w/o the meta_bg feature, allocation\nbitmaps could overlap the block group descriptors and ext4 wouldn't\nnotice.\n\nFor file systems with the meta_bg feature enabled, there was a\nfencepost error which would cause the ext4_check_descriptors() to\nincorrectly believe that the block allocation bitmap overlaps with the\nblock group descriptor blocks, and it would reject the mount.\n\nFix both of these problems.\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org",
        "before_after_code_files": [
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2342:  struct ext4_sb_info *sbi = EXT4_SB(sb);",
          "2343:  ext4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);",
          "2344:  ext4_fsblk_t last_block;",
          "2346:  ext4_fsblk_t block_bitmap;",
          "2347:  ext4_fsblk_t inode_bitmap;",
          "2348:  ext4_fsblk_t inode_table;",
          "",
          "[Removed Lines]",
          "2345:  ext4_fsblk_t last_bg_block = sb_block + ext4_bg_num_gdb(sb, 0) + 1;",
          "",
          "[Added Lines]",
          "2345:  ext4_fsblk_t last_bg_block = sb_block + ext4_bg_num_gdb(sb, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4085:    goto failed_mount2;",
          "4086:   }",
          "4087:  }",
          "4088:  if (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {",
          "4089:   ext4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");",
          "4090:   ret = -EFSCORRUPTED;",
          "4091:   goto failed_mount2;",
          "4092:  }",
          "4096:  timer_setup(&sbi->s_err_report, print_daily_error_info, 0);",
          "",
          "[Removed Lines]",
          "4094:  sbi->s_gdb_count = db_count;",
          "",
          "[Added Lines]",
          "4088:  sbi->s_gdb_count = db_count;",
          "",
          "---------------"
        ]
      }
    }
  ]
}